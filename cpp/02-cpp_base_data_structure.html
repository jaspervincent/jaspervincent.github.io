<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>C++: 基础数据结构</title>
<meta name="description" content="C++" />
<meta name="keywords" content="计算机, 原理, C++" />
<meta name="generator" content="Org Mode" />
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="me" href="https://emacs.ch/@jasperhsu">
<meta name="google-adsense-account" content="ca-pub-1741779893655624">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1741779893655624" crossorigin="anonymous"></script>
<!-- from -->
<!--
<style>#back-to-top{background:#000;-webkit-border-radius:50%;-moz-border-radius:50%;border-radius:50%;bottom:20px;-webkit-box-shadow:0 2px 5px 0 rgba(0,0,0,.26);-moz-box-shadow:0 2px 5px 0 rgba(0,0,0,.26);box-shadow:0 2px 5px 0 rgba(0,0,0,.26);color:#fff;cursor:pointer;display:block;height:56px;opacity:1;outline:0;position:fixed;right:20px;-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none;-webkit-transition:bottom .2s,opacity .2s;-o-transition:bottom .2s,opacity .2s;-moz-transition:bottom .2s,opacity .2s;transition:bottom .2s,opacity .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:56px;z-index:1}#back-to-top svg{display:block;fill:currentColor;height:24px;margin:16px auto 0;width:24px}#back-to-top.hidden{bottom:-56px;opacity:0}</style>
-->
<link rel="stylesheet" href="/static/distro-htmlize.css">
<link rel="stylesheet" href="/static/aandds.com/css/main.css">
<link rel="stylesheet" href="/static/aandds.com/css/drollery.min.css">
<script type="text/javascript" src="/static/aandds.com/js/main.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">C++: 基础数据结构</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#h:4e02255b-fe76-4ef1-a75c-a728b9d5665c">基础概念</a>
<ul>
<li><a href="#h:088b37dd-b08b-4ffd-87bd-14454f0c08a9">数据结构概览</a>
<ul>
<li><a href="#h:4d803779-9a4f-49f8-88f3-c47d75b193b2">数据结构和算法</a></li>
<li><a href="#h:e58c8712-dffe-4962-9499-0f15fefdc38a">数据结构</a></li>
<li><a href="#h:1524464d-7fd9-4408-ba1b-11f848ba2173">逻辑结构</a></li>
<li><a href="#h:ed597323-b1d8-4126-9708-f12fe2a89e2a">存储结构</a></li>
</ul>
</li>
<li><a href="#h:e9b95c86-f753-4275-bc37-e5bea83a43a6">时间复杂度</a>
<ul>
<li><a href="#h:3ca4d298-8fb0-47ea-8193-b2ad9ca0de9f">穷举法</a>
<ul>
<li><a href="#h:535b2847-eba1-4cb5-9466-bc8e63b61f7a">单层循环</a></li>
<li><a href="#h:04a976b5-6468-4ea2-b7bb-2f6ed35b3066">双层循环</a></li>
<li><a href="#h:581ae3e9-8cd6-467c-b06e-6e8b904960d7">三层循环</a></li>
<li><a href="#h:dc29d1b8-6197-49c2-9705-13ebc50c7638">递归枚举</a></li>
</ul>
</li>
<li><a href="#h:64b2d0a1-e83e-42ca-b6a4-84564f69ecc2">时间复杂度</a>
<ul>
<li><a href="#h:1ce4d14f-4a6b-4902-b6ef-77e3e4763b1e">时间复杂度的表示法</a></li>
<li><a href="#h:1325677a-749a-4574-960a-37419b4e4e93">时间复杂度</a></li>
<li><a href="#h:d5dd3598-23aa-48a3-9e01-47fdbac760d6">高阶无穷小</a></li>
<li><a href="#h:619ba3a0-d195-4e93-be94-dad8a13be79d">简化系数</a></li>
</ul>
</li>
<li><a href="#h:44be47a5-3585-4657-95e2-e76540d4f64f">常见的时间复杂度</a>
<ul>
<li><a href="#h:59c8ce86-8b9d-4204-b8ce-2387471044ab">常数阶</a></li>
<li><a href="#h:7c9d1d84-8eea-49df-9cee-b3928ac5724a">对数阶</a></li>
<li><a href="#h:62aecb69-c61e-4e2b-8043-d26f7d8c8200">根号阶</a></li>
<li><a href="#h:587f90a6-82b5-49d8-80c1-040d2e8765bf">线性阶</a></li>
<li><a href="#h:69a863f1-8c29-43e8-ba74-459bd3cedb06">线性对数阶</a></li>
<li><a href="#h:2027a063-2e5c-442d-a0d1-7a86536341c9">多项式阶</a></li>
<li><a href="#h:5ab3daa8-a572-4d60-a55c-2b672089e875">指数阶</a></li>
<li><a href="#h:3adc371b-b593-4400-9c93-edfbf627526d">阶乘阶</a></li>
</ul>
</li>
<li><a href="#h:3c344e12-1083-4202-8a3c-fecb6881f340">如何判断时间复杂度</a>
<ul>
<li><a href="#h:bd2f0e14-b368-4cc3-ac3b-147ec1c5cc91">标准</a></li>
<li><a href="#h:6bd6429f-46b3-4826-8594-761dc869ac28">问题规模</a></li>
<li><a href="#h:03c3b7b2-a43c-421d-a7b5-f8a4f0468fb4">套公式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:94dc38b1-fb11-4b9f-962f-2d5648084a6b">空间复杂度</a>
<ul>
<li><a href="#h:e3fed39f-b9fd-4644-8dc2-449d753ec875">概念</a></li>
<li><a href="#h:0e9501d3-b382-4488-a17b-52def597ec4b">常见数据结构的空间复杂度</a></li>
<li><a href="#h:cde0f5ad-fb73-469e-86f5-42d383b8fd3c">空间换时间</a></li>
<li><a href="#h:cc28969b-75a9-4b32-a3f0-2d8fec290efc">总结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:2b071966-fede-4e7b-ba02-91821c0ea61d">环境使用</a></li>
<li><a href="#h:c6967906-3638-45d3-8985-afede709b5ff">线性结构-顺序表</a>
<ul>
<li><a href="#h:c1da5528-9142-464b-b410-2864229cc466">顺序表（概念篇）</a>
<ul>
<li><a href="#h:858e2e3f-e656-412d-82cf-fa119d2e4e8a">顺序表的概念</a></li>
<li><a href="#h:b1830c6d-06d2-4ffa-a0c2-ae23baa8782c">顺序表的元素插入</a></li>
<li><a href="#h:81d81bef-2c3c-4426-bb4a-e4f16f37d44d">顺序表的元素删除</a></li>
<li><a href="#h:98a97b50-baac-441c-b041-b5cb65b85676">顺序表的元素查找</a></li>
<li><a href="#h:a7fbf6c5-010c-4d26-86d3-8b90a62d9362">顺序表的元素索引</a></li>
<li><a href="#h:5b8dd9a3-d9e3-49a8-9d4c-3139c1bac210">顺序表的元素修改</a></li>
</ul>
</li>
<li><a href="#h:8f6e16c8-d163-47b9-9518-778ebc6ced5a">代码篇</a>
<ul>
<li><a href="#h:a196dd4e-0276-473b-9a78-5723c0491c37">手写顺序表模板</a></li>
<li><a href="#h:720f9860-0494-4bbd-be68-c7cba95da075">C++中的顺序表(vector)</a></li>
</ul>
</li>
<li><a href="#h:e6497083-6454-4c28-8caa-5a237c7c589f">实战篇</a>
<ul>
<li><a href="#h:3f5df4bc-9dec-4c87-b68a-7e30eb9545be">ACM模式</a>
<ul>
<li><a href="#h:fbb12821-8afa-42c8-90ad-ee6aa211a5ca">1.求奇数的乘积</a></li>
<li><a href="#h:403b978f-b5a9-4f2a-b519-b1faeca28da2">2.数值统计</a></li>
<li><a href="#h:9f438411-8b2f-41a3-897c-6ac09dfc5216">3.青年歌手大奖赛</a></li>
</ul>
</li>
<li><a href="#h:ce6b006f-a28f-4fce-a4d3-d43318b01162">核心代码模式</a>
<ul>
<li><a href="#h:cd8ad3c7-8797-47f4-a00c-37c8a95ded0e">顺序表的索引</a></li>
<li><a href="#h:d6e29109-1023-48e5-8fcb-92ddc82423c7">顺序表的大小</a></li>
<li><a href="#h:d0c2de0a-378a-4c06-8e27-7ec8b33e59c0">顺序表的插入</a></li>
<li><a href="#h:5152d553-235a-4ae6-8c03-2dbb6a1a06c2">顺序表的枚举</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:3b5178eb-4d07-4100-9d43-2435bb3cd923">应用篇</a>
<ul>
<li><a href="#h:696d13b2-defd-41ef-8b7a-f2aad55c7a85">春晚魔术顺序表代码实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:e92a5d72-7cc1-4d50-b52a-2f75a32c9cda">线性结构-单向链表</a>
<ul>
<li><a href="#h:0563f432-6332-4c70-ae1f-a43ec5deec75">单向链表（概念篇）</a>
<ul>
<li><a href="#h:f2aef0fa-a2ce-43dc-a8c2-65504a2be8ec">单向链表的概念</a></li>
<li><a href="#h:94020b32-637f-40c1-9b89-9bcd79ab911e">单向链表的元素插入</a></li>
<li><a href="#h:0cb254a0-08eb-4c79-b687-2f9b65d949c4">单向链表的元素删除</a></li>
<li><a href="#h:92de0588-4373-4589-8ead-a16b58136d57">单向链表的元素查找</a></li>
<li><a href="#h:0e7d5dcb-fb5c-4ad4-bc2a-25a00540eaa7">单向链表的元素索引</a></li>
<li><a href="#h:da9d2e8b-491a-42d1-8a29-e2df7ed2aa5f">单向链表的元素修改</a></li>
</ul>
</li>
<li><a href="#h:8f455a3b-d94f-4999-9033-bb4dbbe412a9">代码篇</a></li>
<li><a href="#h:87b2d42a-db27-426c-8711-117f4cf01d72">实战篇</a>
<ul>
<li><a href="#h:3eaef271-dfe9-4db4-9636-f0264e880e50">ACM模式</a>
<ul>
<li><a href="#h:bdbaa645-6f7f-4a17-89f3-edbce5480417">1.A+B for Input-Output Practice (IV)</a></li>
<li><a href="#h:7b5eb6e1-50fb-481b-b3a7-5a1a32a1c5d5">2.超级楼梯</a></li>
<li><a href="#h:791f0902-9d2d-45c8-8be6-31f448a4a394">3.数列有序!</a></li>
</ul>
</li>
<li><a href="#h:40d1ef7d-2b30-406b-8497-806ec6217ded">核心代码模式</a>
<ul>
<li><a href="#h:c0120296-680f-460b-a8a8-bb069c23c54b">单向链表的遍历</a></li>
<li><a href="#h:569e3286-f966-4967-bd4b-aa1207c42286">单向链表的删除</a></li>
<li><a href="#h:68614d1b-efd3-44ea-8839-4af917cee10e">单向链表的插入</a></li>
<li><a href="#h:a44f6933-bc79-4e68-8ec7-a36a851145fe">单向链表的递归和迭代</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:1727c49d-d9e7-47e1-ba88-db9662395ce0">应用篇</a>
<ul>
<li><a href="#h:9d39fa8f-401e-44a2-adb7-2494489c8bf1">剑网三中的应用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:828e9793-e732-425f-83d6-738759787427">线性结构-栈</a>
<ul>
<li><a href="#h:07a38c80-720c-42c7-8cae-cefbde443ec3">栈（概念篇）</a>
<ul>
<li><a href="#h:eff2423f-64a8-4577-abf5-7d90ffb93912">栈的概念</a></li>
<li><a href="#h:ea68e888-0193-445c-a566-9f9b809fd551">入栈</a></li>
<li><a href="#h:d5232d1a-70ea-46b3-8375-18e31fb956fd">出栈</a></li>
<li><a href="#h:3212fdfe-4694-4701-b4ab-63e35e80fbba">获取栈顶元素</a></li>
</ul>
</li>
<li><a href="#h:da6598ff-6d32-4141-8574-a28c6f00ffe8">代码篇</a>
<ul>
<li><a href="#h:daade084-0b99-40a1-947e-61fc9a8b257a">顺序表实现</a></li>
<li><a href="#h:fbf72fa7-818f-4b8e-8ea3-aa5e8bdecbd2">链表实现</a></li>
<li><a href="#h:44a092a7-b2bf-46e6-a541-11187b9ae9bb">C++中的栈实现（stack）</a></li>
</ul>
</li>
<li><a href="#h:88fb4ab1-1ca1-47d9-8355-8a9edaaaa13d">实战篇</a>
<ul>
<li><a href="#h:eb9d7667-c427-41cd-9dd2-3a4d8e23c90b">ACM模式</a>
<ul>
<li><a href="#h:5e75fad7-96bb-460d-b99d-2af3e8cd19e8">1.进制转换</a></li>
<li><a href="#h:eba9209e-c776-4acc-a55d-9a7d3efd0ebe">2.Bitset</a></li>
</ul>
</li>
<li><a href="#h:4dc90428-d127-4f75-818b-cc3b29fee143">核心代码模式</a>
<ul>
<li><a href="#h:f24606b7-9d1f-47ea-844e-d5309d094c3a">3.图书整理 I</a></li>
<li><a href="#h:9092139e-5dbd-4547-bfd2-d738c95b3cd2">4.回文链表</a></li>
<li><a href="#h:d319b5ff-75d3-4288-b76d-b7f6faa58cb9">5.括号的最大嵌套深度</a></li>
<li><a href="#h:1ea2bdd8-8742-4359-a0af-fd9e04b4c2c5">6.有效的括号</a></li>
<li><a href="#h:3074620b-ea7d-4c9a-83b2-452f90e7e9cc">7.每日温度</a></li>
<li><a href="#h:c0833816-2ffd-4d6e-b079-fc468fb48d5f">8.从链表中移除节点</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:72ed696d-cf24-43f4-854c-01000b47a679">应用篇</a>
<ul>
<li><a href="#h:6e28f97d-7c74-46fa-80ca-1b753883be69">原神、剑网3中的应用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:808736b4-7170-4b7d-b9aa-d51d9e31ea51">线性结构-队列</a>
<ul>
<li><a href="#h:c8b099ea-310f-41aa-807d-1022aa312d52">队列（概念篇）</a>
<ul>
<li><a href="#h:1662f1cb-3985-418d-a2e4-9bc11b6a7ca0">队列的概念</a></li>
<li><a href="#h:45e02948-24e7-47cc-a5ad-9c41f7bed51c">入队</a></li>
<li><a href="#h:416677ce-422f-42d3-a350-f40aebd0606c">出队</a></li>
<li><a href="#h:5129e1fb-44de-4593-a020-9221455887c3">获取队首元素</a></li>
</ul>
</li>
<li><a href="#h:243ff972-acda-4877-9313-16f7ffdb5447">代码篇</a>
<ul>
<li><a href="#h:39b00ce6-ba17-4fc6-9ec8-8ce4e19450b5">顺序表实现</a></li>
<li><a href="#h:dbf7eb60-3554-443c-b940-984a7488f210">链表实现</a></li>
<li><a href="#h:cbd5808c-cb7c-4ef2-9365-7b5eda2ecdfe">C++中的队列实现（queue）</a></li>
</ul>
</li>
<li><a href="#h:7282191f-2e00-4564-8ccf-89e149109dee">实战篇</a>
<ul>
<li><a href="#h:ecc5aebd-1ce8-4e45-be46-62344fddb2a8">ACM模式</a>
<ul>
<li><a href="#h:c39989ed-6a72-4f96-8a9a-83decb79f883">1.士兵队列训练问题</a></li>
<li><a href="#h:664df143-bb24-4bd9-851e-80e6ebb0ee52">2.Team Queue</a></li>
</ul>
</li>
<li><a href="#h:91c59eaf-57d5-45b2-ad8e-704909c43384">核心代码模式</a>
<ul>
<li><a href="#h:04d55be7-9005-4985-b146-4254af185012">3.最近的请求次数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:2266f762-c34b-4512-bf91-639dceef71e3">应用篇</a>
<ul>
<li><a href="#h:023f0454-2f81-4133-bdfd-7c129e523711">原神中的应用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:fbfeb4e5-36e3-42bc-a51b-f183f7372fba">线性结构-栈 &amp;&amp; 队列</a>
<ul>
<li><a href="#h:b308e73c-43b6-4b37-b963-04a749a80e71">概念篇</a>
<ul>
<li><a href="#h:8a800187-8295-46ab-940b-b9e060e40252">用栈实现队列</a></li>
<li><a href="#h:c5f2b9b6-c24c-4fe5-9cce-5a9f79c41345">用队列实现栈</a></li>
</ul>
</li>
<li><a href="#h:3791834e-fbe2-43a4-80b7-ced20d36c224">代码篇</a>
<ul>
<li><a href="#h:d277799a-d38f-43ee-ac64-907d464a43ba">用栈实现队列</a></li>
<li><a href="#h:0f904019-bf02-43ee-9b8a-5aad6f6eeb9d">用队列实现栈</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:601ecd66-8031-4834-bebd-57d1d757dcc9">线性结构-串</a>
<ul>
<li><a href="#h:2c0c5d9b-960c-480e-b963-7b702968feb9">串（概念篇）</a>
<ul>
<li><a href="#h:a7913ee7-9581-4faf-8d80-6612051e9c69">串的概念</a></li>
<li><a href="#h:b2e247d1-4372-4347-bdaa-0c88c85c328a">获取串的长度</a></li>
<li><a href="#h:42eb1f95-218d-45ad-8b5c-6361f8967794">串的拷贝</a></li>
<li><a href="#h:f7f13194-b503-4ce1-9a81-134394479927">串的比较</a></li>
<li><a href="#h:11f41fb1-dbbe-4ee9-9021-669a6a07fb37">串的拼接</a></li>
<li><a href="#h:41af551f-efc9-484a-b2c3-60ba118a12bd">串的索引</a></li>
</ul>
</li>
<li><a href="#h:66b7bfed-9eeb-46be-ae2b-eb5d80e7a39e">代码篇</a></li>
<li><a href="#h:e3b6689f-c5a9-4510-a8d7-8120e5f063da">实战篇</a>
<ul>
<li><a href="#h:234a1694-d4e1-4c0e-ac7f-5c11f86867e7">ACM模式</a>
<ul>
<li><a href="#h:1ce7d29d-c2de-4250-86b6-ab005df52485">1.汉字统计</a></li>
<li><a href="#h:6ec1405a-8d86-48e4-a578-6bbee20bde53">2.首字母变大写</a></li>
<li><a href="#h:e1dfccfb-7f9b-40cf-92c4-521ab1878d04">3.查找最大元素</a></li>
</ul>
</li>
<li><a href="#h:38743f20-a75a-4594-8ac9-0718004bce4e">核心代码模式</a>
<ul>
<li><a href="#h:3a22b860-bb99-453b-8a86-aa6bfe7b7791">4.判断国际象棋棋盘中一个格子的颜色</a></li>
<li><a href="#h:07ce264b-ce60-4d2f-963d-318d8e4e752e">5.路径加密</a></li>
<li><a href="#h:ce2e696a-75d6-403c-88dc-5def0b8b3eef">6.长度为三且各字符不同的子字符串</a></li>
<li><a href="#h:80b5375e-b7e2-45c6-a09b-37f0a5763456">7.速算机器人</a></li>
<li><a href="#h:7288ccaa-780d-48b1-8293-ac8f80a3d10a">8.执行操作后的变量值</a></li>
<li><a href="#h:d85be20f-59b4-4612-89ce-31bddc0fc631">9.IP 地址无效化</a></li>
<li><a href="#h:c4c1d5e3-2e26-4a45-a716-bac31436f3f8">10.统计星号</a></li>
<li><a href="#h:d343f858-fb2e-4cfd-a843-8bac6378927c">11.分割平衡字符串</a></li>
<li><a href="#h:ef42541d-8311-4f84-a24a-8fff67ebe8a2">12.动态口令</a></li>
<li><a href="#h:71c6caa1-a711-4ec8-877c-c3eb0fc1f5ff">13.设计 Goal 解析器</a></li>
<li><a href="#h:ada1442e-6df2-409f-b396-0ae32b953ae3">14.句子中的最多单词数</a></li>
<li><a href="#h:8a3f8181-1817-4271-93f4-17a38f422635">15.统计一致字符串的数目</a></li>
<li><a href="#h:2404f376-f3f6-48e9-bdfb-275c0d12849b">16.字符串的分数</a></li>
<li><a href="#h:e99aa254-fa6b-44d5-a6a0-83673857b68b">17.TinyURL 的加密与解密</a></li>
<li><a href="#h:c2f75ee4-cc1a-44e6-8bae-a495fb4362d0">18.查找包含给定字符的单词</a></li>
<li><a href="#h:a2a9f98e-9268-4e24-870d-1679e1f25a03">19.判别首字母缩略词</a></li>
<li><a href="#h:cbdf3b09-dcad-437f-bd91-e2318346b1ac">20.从字符串中移除星号</a></li>
<li><a href="#h:895e0c84-3df0-4824-ad4b-00d7818f8fb9">21.删除字符串中的所有相邻重复项</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:0e99b34b-323e-4e38-9626-32f71f10813e">树形结构-树</a>
<ul>
<li><a href="#h:9414bebf-d8b2-4324-befb-221cff9f3d30">树（概念篇）</a>
<ul>
<li><a href="#h:2972ad0a-0c7e-4a17-9d15-6f86661453d5">树的概念</a></li>
<li><a href="#h:c8bca72c-1e6a-4714-90d3-6d88ce511d6a">树的数据结构表示</a></li>
</ul>
</li>
<li><a href="#h:12d759a5-23eb-401e-aedc-f5ecae20130b">代码篇</a></li>
<li><a href="#h:9959c363-1958-4a29-ad4a-cdf29ee6cbb6">实战篇</a>
<ul>
<li><a href="#h:8fedeeb1-a6e0-487f-9233-c2e119d2b77f">核心代码模式</a>
<ul>
<li><a href="#h:28a5de02-21fc-4cd9-ab30-e47efee39d6b">1.判断根结点是否等于子结点之和</a></li>
<li><a href="#h:3ed69a04-fd21-40d9-913e-18b39195556b">2.二叉树的最大深度</a></li>
<li><a href="#h:507e24a3-5157-4029-b067-2f79c7dcb33c">3.计算二叉树的深度</a></li>
<li><a href="#h:63849cd6-0228-41d2-9846-b29c5863cbd7">4.计算布尔二叉树的值</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:9482bf2f-0bef-49ee-bca6-a06fe60adcb4">应用篇</a>
<ul>
<li><a href="#h:43ce7635-1fda-4e85-a61f-fa91609025a6">剑网三中的应用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:356ea822-92bb-4659-a1c0-b2ddd39f2845">树形结构-二叉树</a>
<ul>
<li><a href="#h:7d50965d-1ca5-456d-9fbb-a51b09475cc0">二叉树（概念篇）</a>
<ul>
<li><a href="#h:d05a6b4a-970b-41f5-836b-89d634e86e9d">二叉树的定义</a></li>
<li><a href="#h:b170369d-1798-4ea6-9f1d-720f37bca7d7">二叉树的特点</a></li>
<li><a href="#h:28d3294f-fe86-4c1a-990b-f39273c75f87">特殊二叉树</a></li>
<li><a href="#h:484bb238-c2fd-40a8-8381-dcc627984160">二叉树的性质</a></li>
<li><a href="#h:034d398f-e950-46a4-8be5-30061235bb3a">二叉树的顺序存储</a></li>
<li><a href="#h:5fb6ec6e-0dc5-4002-a7c8-0b4d233cfa22">二叉树的链式存储</a></li>
<li><a href="#h:b73cd568-c769-42e3-a77e-caf1a8ac0f4d">二叉树的遍历概念</a></li>
<li><a href="#h:2acc94ff-3e29-4df9-88f0-515beab0310b">二叉树的前序遍历</a></li>
<li><a href="#h:d1644b56-d867-4f4f-a57b-77065bae1f96">二叉树的中序遍历</a></li>
<li><a href="#h:ac8cde68-7c60-4aad-ae18-236ddf1a1c8a">二叉树的后序遍历</a></li>
<li><a href="#h:6241171f-2b8d-417e-8ec4-970af3b85c18">二叉树的层序遍历</a></li>
</ul>
</li>
<li><a href="#h:ffeda76c-fc39-4701-885d-0b7bc2029feb">代码篇</a></li>
<li><a href="#h:3c7bc718-fc28-47bf-9d8d-70cd46c8268b">实战篇</a>
<ul>
<li><a href="#h:adae264e-4c42-4dd3-b9bf-691f5aa6544c">核心代码模式</a>
<ul>
<li><a href="#h:755c6533-3c86-41ce-b531-0d5ce614eca5">1.单值二叉树</a></li>
<li><a href="#h:c3e6fee3-ba5d-4e17-8c3a-f5a49665d55f">2.完全二叉树的节点个数</a></li>
<li><a href="#h:7c623dd6-7d3d-48fc-9231-293b670526ae">3.二叉树的前序遍历</a></li>
<li><a href="#h:08cf55e0-cb14-48b0-9848-6048d6af13f7">4.二叉树的中序遍历</a></li>
<li><a href="#h:b40627b6-888e-4509-ab3f-a058714423ea">5.二叉树的后序遍历</a></li>
<li><a href="#h:a4e4efe4-860e-4ad2-ae5e-16e3dea8a2fb">6.翻转二叉树</a></li>
<li><a href="#h:1ccaaeae-2540-4e3f-9ff1-7d469450367d">7.从根到叶的二进制数之和</a></li>
<li><a href="#h:66d1a57b-6306-4018-98ba-d7bb77b116cb">8.找出克隆二叉树中的相同节点</a></li>
<li><a href="#h:f6fc6fb3-8245-42f2-8661-822a0b8b00d6">9.层数最深叶子节点的和</a></li>
<li><a href="#h:373fe498-5853-42cc-b58a-cea6d269ad73">10.最大二叉树</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:673bbd99-7441-4440-af8e-9533c6fd5232">树形结构-二叉搜索树</a>
<ul>
<li><a href="#h:b2e6a607-6dde-4301-a60b-adc9a1ae588d">二叉搜索树（概念篇）</a>
<ul>
<li><a href="#h:49401b4b-d730-47c9-a9d4-0b9528ce798e">二叉搜索树的概念</a></li>
<li><a href="#h:1ed6387e-94e1-4a04-a83c-2b17c4633b91">二叉搜索树的链式存储</a></li>
<li><a href="#h:a699cf7b-8cdd-4190-bfc7-ef6333ce39c7">二叉搜索树的结点查找</a></li>
<li><a href="#h:59be9ada-1308-40ff-96c2-16e2e6536147">二叉搜索树的结点插入</a></li>
<li><a href="#h:739bd582-223b-433c-bebd-7f07222b35a8">二叉搜索树的结点删除</a></li>
<li><a href="#h:9f2a7960-7f8a-4f48-90c1-19c033d8b2c9">二叉搜索树的总结</a></li>
</ul>
</li>
<li><a href="#h:312ef4b6-7533-4677-827e-d66f439c5c81">代码篇</a></li>
<li><a href="#h:f7407e44-af55-4e32-a9a3-dcecc493726c">实战篇</a>
<ul>
<li><a href="#h:9342cda1-674f-4c4c-9100-9b1f76c67668">核心代码模式</a>
<ul>
<li><a href="#h:c79e8f82-a6db-4d1b-83fe-e6c442d03f81">1.二叉搜索树中的搜索</a></li>
<li><a href="#h:a0e9cb6d-15d7-4c56-9f0a-cbf955e30d60">2.二叉搜索树的范围和</a></li>
<li><a href="#h:c70791b1-5aa3-4a07-b881-eb7bb36d9d88">3.将有序数组转换为二叉搜索树</a></li>
<li><a href="#h:44ba654a-bd2f-4f23-af4e-ea9ac942c0dc">4.验证二叉搜索树</a></li>
<li><a href="#h:c3c4c673-329d-4687-a8a9-5d47f4d8cbc3">5.递增顺序搜索树(重要)</a></li>
<li><a href="#h:948287a7-8abf-4254-acaa-aa371fe940ba">6.递增顺序搜索树迭代</a></li>
<li><a href="#h:d80416dc-4ec6-4d3b-af14-e35bc433d4f0">7.二叉搜索树的最小绝对差</a></li>
<li><a href="#h:be3cc70d-066d-42e4-a143-4c22e729d883">8.两数之和 IV - 输入二叉搜索树</a></li>
<li><a href="#h:04b0778f-ad21-4434-8a0d-90bd801499fa">9.二叉搜索树中的众数</a></li>
<li><a href="#h:15ed2412-1ae7-405f-9b72-50cfd4099ad3">10.恢复二叉搜索树</a></li>
<li><a href="#h:e56d5970-2e26-44ae-8d97-edfc2dd7a2e0">11.删除二叉搜索树中的节点</a></li>
<li><a href="#h:164f0d0c-4afe-4bf9-b7eb-3e64b5d766a9">12.寻找二叉搜索树中的目标节点</a></li>
<li><a href="#h:67b22e1d-9202-4900-9d96-d64f6b37b3ad">13.前序遍历构造二叉搜索树</a></li>
<li><a href="#h:a83b2ec4-720f-4b48-ac71-8176fe150054">14.二叉搜索树中的插入操作</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:4b19da01-b627-4148-8c99-1a7a1a905d3e">图形结构-图</a>
<ul>
<li><a href="#h:4cfaa8e3-05b1-49c7-b774-381c5b74de99">图（概念篇）</a>
<ul>
<li><a href="#h:33826fcb-3256-4880-b9ad-ca2770090486">图的定义</a></li>
<li><a href="#h:247c95a2-b0a2-4f51-b4dd-7b8454509a57">有向图和无向图</a>
<ul>
<li><a href="#h:021580e2-0cbd-489f-9771-6765b993177a">无向边和无向图</a></li>
<li><a href="#h:b17f81f1-9114-4e25-834b-37ef823a591b">有向边和有向图</a></li>
</ul>
</li>
<li><a href="#h:537dbb09-e547-4d39-92d8-4d61024e6b7b">稀疏图和稠密图</a></li>
<li><a href="#h:9d3acf4c-88fe-416f-94ec-bf9aebacc80c">完全图</a></li>
<li><a href="#h:d8eb12d4-1183-4276-9576-1776f8a4c676">简单图</a></li>
<li><a href="#h:cbe3076a-a883-4b98-a1c0-c116beed5828">度</a></li>
<li><a href="#h:4f540212-7cae-4e5d-ac29-6c5be088a0a1">权</a></li>
<li><a href="#h:cba21b7d-331c-497e-afb9-70973ac9db37">路径</a></li>
<li><a href="#h:30fd2044-5f74-4b76-b7f0-77c648f7ee29">连通图和连通分量</a></li>
<li><a href="#h:b487f2a5-35e4-4199-b460-98871568ccf7">生成树</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:2883167f-5804-4998-9411-7cb21f14b01c">图形结构-邻接矩阵</a>
<ul>
<li><a href="#h:6d188199-ae4f-4b6e-b7f3-246c27548b93">邻接矩阵（概念篇）</a>
<ul>
<li><a href="#h:605aaf69-c613-47a0-968c-ef7c54b4bcc9">邻接矩阵的概念</a></li>
<li><a href="#h:83a602d2-f5dd-4e0f-83f0-c79d3cea8cd3">无权图的邻接矩阵</a></li>
<li><a href="#h:6f95e758-dd65-4891-bfda-c73643a287e1">带权图的邻接矩阵</a></li>
<li><a href="#h:8c685456-d3ec-4bca-afa3-8cbe0c3712c8">邻接矩阵的优点</a></li>
<li><a href="#h:4f4a3242-f3a3-48ff-8722-b75d2724fdc2">邻接矩阵的缺点</a></li>
</ul>
</li>
<li><a href="#h:d7bd4997-b05d-4f66-ac55-e22ae3ac0a78">代码篇</a></li>
<li><a href="#h:ad30a6c7-98e3-43ed-b7a7-914f51cc1343">实战篇</a>
<ul>
<li><a href="#h:67a9d68d-4c2b-4e9b-9e65-d9b4bf0bd6c9">1.传递信息</a></li>
<li><a href="#h:8ef9d5aa-f90a-49c5-89b2-cd80020f13dd">2.省份数量</a></li>
<li><a href="#h:f9a869b3-ad59-4914-be33-843b686cd822">3.判断二分图</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:c594ba4a-347f-4171-b1ec-b9386a3c2472">图形结构-邻接表</a>
<ul>
<li><a href="#h:43e05dd8-f6bd-4730-9b51-2a6d7505a40c">邻接表（概念篇）</a>
<ul>
<li><a href="#h:85646b11-a09a-4488-b79b-9b897a469ba8">邻接表的概念</a></li>
<li><a href="#h:637ff9e0-7950-4367-86ea-06790cb59af0">邻接表的顺序表存储</a></li>
<li><a href="#h:98e27aeb-1ca0-47d5-a4e5-7c03e507e320">邻接表的链表存储</a></li>
<li><a href="#h:52462698-da5c-4d22-92cc-b0a346be41b7">邻接表的应用</a></li>
<li><a href="#h:9a2399fe-d5a3-4ec8-b5a8-d956e544be19">邻接表的优点</a></li>
<li><a href="#h:9388a511-2f2e-4a06-aa64-63c11068f22f">邻接表的缺点</a></li>
</ul>
</li>
<li><a href="#h:0befef9f-0b32-42d8-bfe0-cb22f5250e1f">代码篇</a></li>
<li><a href="#h:efb22c33-603f-4c19-8c83-a1aec57e3dff">实战篇</a>
<ul>
<li><a href="#h:3a5c2cd3-7e75-40f5-bc2f-ad676fa540d4">1.传递信息</a></li>
<li><a href="#h:1e26d03e-f4b6-4716-aa08-728116e67d0e">2.省份数量</a></li>
<li><a href="#h:c614bafe-02de-49f4-b173-f38b3f93d972">3.判断二分图</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:3bb59632-f537-4a02-9565-dacd49f79c49">散列结构-哈希表</a>
<ul>
<li><a href="#h:118a0a8f-dfa0-4105-b454-b72a8703dfc3">哈希表（概念篇）</a>
<ul>
<li><a href="#h:a7291b2f-e7e3-4ff9-ba36-f423ab0a2a8d">查找算法概述</a></li>
<li><a href="#h:bb1f3579-1698-46f9-a2b8-97ad0240d062">哈希表的概念</a></li>
<li><a href="#h:94caccaf-f564-4026-b509-9e9ab1c00db9">键值对的概念</a></li>
<li><a href="#h:06ff36a8-9628-4764-89f8-1c7ee08f93d6">哈希函数的概念</a></li>
<li><a href="#h:6eff32a0-a1d5-4d92-a1de-0abf66f80326">哈希冲突的概念</a></li>
<li><a href="#h:d69f1895-36e3-4264-82bc-f7aa47efa138">常用的哈希函数</a></li>
<li><a href="#h:717b4b0d-306f-4d02-a1a7-24f7f57baa07">哈希冲突的解决方案</a></li>
<li><a href="#h:2e62b104-73d6-4832-bd0d-54aba15f3d55">哈希表的初始化</a></li>
<li><a href="#h:e0587536-6a8a-48cc-8f68-950e6bb8a778">哈希表的元素插入</a></li>
<li><a href="#h:a2c37701-66c2-4dfd-9138-b51ef72f1403">哈希表的元素删除</a></li>
<li><a href="#h:ecc07ee3-824e-4e9c-8634-9d7bc84802a1">哈希表的元素查找</a></li>
</ul>
</li>
<li><a href="#h:37411b00-5e26-418e-b3ba-550b4c044b86">代码篇</a>
<ul>
<li><a href="#h:7bd020b7-b151-4fa4-9909-2512a457ce7a">1.哈希表</a></li>
<li><a href="#h:444dc625-3407-4f6b-8d15-d225d4d3fbe7">2.哈希计数器</a></li>
<li><a href="#h:73360bba-d969-47ce-b775-4df897ae4667">3.C++中的哈希表实现(unordered_map)</a></li>
</ul>
</li>
<li><a href="#h:812d4b94-1aea-4529-b2ac-39b9430e8613">实战篇</a>
<ul>
<li><a href="#h:eff5605f-8bd7-47b3-ba03-82db3053e103">核心代码模式</a>
<ul>
<li><a href="#h:8609e5e8-c280-4cf6-9b4b-e0fa998034e8">1.消失的数字</a></li>
<li><a href="#h:4f40c329-aaf8-472c-a836-2313b468ed15">2.缺失的第一个正数</a></li>
<li><a href="#h:a0d73fd8-ecbd-4766-b09b-81a69c4e4bf3">3.点名</a></li>
<li><a href="#h:7b51733e-92d4-4dc3-af52-66b5dacae62b">4.丢失的数字</a></li>
<li><a href="#h:abe72e93-92bb-4fcb-9c54-9cef37547dda">5.寻找文件副本</a></li>
<li><a href="#h:bdf41192-2385-47d8-b4a2-d7dd2129695c">6.分糖果</a></li>
<li><a href="#h:8f86a9d8-c2cf-4eb9-a420-aa16dcc6635a">7.两数之和</a></li>
<li><a href="#h:0119d5f0-258c-4c95-81dd-1ec582a4c178">8.字符串中的第一个唯一字符</a></li>
<li><a href="#h:27c640f8-ab2d-4db3-bb72-72d8bc381bb6">9.招式拆解 II</a></li>
<li><a href="#h:2104cc9f-f02b-4ca6-a4e5-d3b881b663d2">10.两个相同字符之间的最长子字符串</a></li>
<li><a href="#h:b5801f8a-196e-4873-acce-36c5c5feba5f">11.好数对的数目</a></li>
<li><a href="#h:55d5d37c-18d5-4255-b815-b1eec3264e57">12.在长度 2N 的数组中找出重复 N 次的元素</a></li>
<li><a href="#h:f3430040-faff-42e7-b3f5-e996c41cb910">13.独一无二的出现次数</a></li>
<li><a href="#h:912f1d67-57cc-4796-9fb7-c1b0129ec2a3">14.找出数组中的所有孤独数字</a></li>
<li><a href="#h:59df4f91-b32b-4ebd-bbb6-b05126556ae3">15.单词频率</a></li>
<li><a href="#h:ae721dfe-a2bc-4df1-8b4f-02f5e9ed338f">16.人口最多的年份</a></li>
<li><a href="#h:a0f18f27-aa16-4f7e-9464-c5651f0caf75">17.盒子中小球的最大数量</a></li>
<li><a href="#h:005d2468-3242-41f5-9692-28a6f1e57e56">18.最大字符串配对数目</a></li>
<li><a href="#h:b0142e19-e02f-48b2-b826-3fbfe6140171">19.两个字符串的排列差</a></li>
<li><a href="#h:ba482be2-9aaa-42cc-b408-df98193024b2">20.找出缺失和重复的数字</a></li>
<li><a href="#h:b2328e94-9875-49aa-86ad-b833ead14e9a">21.判断句子是否为全字母句</a></li>
<li><a href="#h:a104f5f2-1850-43d6-82d5-6e2ce7df6c9e">22.第一个出现两次的字母</a></li>
<li><a href="#h:e1bd16d4-c1fb-4b26-b479-207f61ca216d">23.找出不同元素数目差数组</a></li>
<li><a href="#h:1bc56e88-12b5-494b-9e98-fb9847c977a3">24.查询数组中元素的出现位置</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:cb95ecd6-42dc-4744-bc00-d146b99b526d">蓝桥杯学习路线</a></li>
</ul>
</div>
</nav>
<ul class="org-ul">
<li>TAGS: <a href="././index.html">C++</a></li>
</ul>
<section id="outline-container-h:4e02255b-fe76-4ef1-a75c-a728b9d5665c" class="outline-2">
<h2 id="h:4e02255b-fe76-4ef1-a75c-a728b9d5665c"><a href="#h:4e02255b-fe76-4ef1-a75c-a728b9d5665c">基础概念</a></h2>
<div class="outline-text-2" id="text-h:4e02255b-fe76-4ef1-a75c-a728b9d5665c">
</div>
<div id="outline-container-h:088b37dd-b08b-4ffd-87bd-14454f0c08a9" class="outline-3">
<h3 id="h:088b37dd-b08b-4ffd-87bd-14454f0c08a9"><a href="#h:088b37dd-b08b-4ffd-87bd-14454f0c08a9">数据结构概览</a></h3>
<div class="outline-text-3" id="text-h:088b37dd-b08b-4ffd-87bd-14454f0c08a9">
</div>
<div id="outline-container-h:4d803779-9a4f-49f8-88f3-c47d75b193b2" class="outline-4">
<h4 id="h:4d803779-9a4f-49f8-88f3-c47d75b193b2"><a href="#h:4d803779-9a4f-49f8-88f3-c47d75b193b2">数据结构和算法</a></h4>
<div class="outline-text-4" id="text-h:4d803779-9a4f-49f8-88f3-c47d75b193b2">
<p>
数据结构和算法是计算机科学中的两个非常重要的概念，它们相辅相成缺一不可。
</p>

<p>
数据结构是指数据的组织和存储方式，它决定了数据的逻辑结构和物理结构。
</p>
<ul class="org-ul">
<li>良好的数据可以提高数据的存储效率、查询效率和修改效率，同时还可以降低程序的复杂度和错误率。</li>
<li>例如：在处理大量数据时，使用合适的数据结构可以大大提高程序的运行效率</li>
</ul>

<p>
算法则是批解决问题的步骤和方法，它决定了程序的执行效率和正确性。
</p>
<ul class="org-ul">
<li>一个好的算法，应该具有高效性、正确性、简洁性和可维护性等等特点。</li>
<li>在设计算法时，需要考虑数据结构的选择和使用，以便更好地利用数据结构的优势来提高算法的效率。</li>
</ul>

<p>
数据结构和算法是相互依赖的关系，在设计程序时，需要根据具体问题选择合适的数据结构和算法。
例如，在处理排序问题时，可以选择使用冒泡排序、插入排序、选择排序、快速排序等不同的算法，同时还需要选择合适的数据结构来存储待排序的数据。
</p>

<p>
不同的数据结构和算法应用于不同的场景，需要根据具体情况进行选择。
</p>

<p>
相当来说，数据结构就像一个容器，对容器里的元素执行增删改查的过程我们称之为算法。所以在数据结构的过程中，同样可以学到算法。
</p>
</div>
</div>
<div id="outline-container-h:e58c8712-dffe-4962-9499-0f15fefdc38a" class="outline-4">
<h4 id="h:e58c8712-dffe-4962-9499-0f15fefdc38a"><a href="#h:e58c8712-dffe-4962-9499-0f15fefdc38a">数据结构</a></h4>
<div class="outline-text-4" id="text-h:e58c8712-dffe-4962-9499-0f15fefdc38a">
<p>
<b>数据</b>
</p>

<p>
数据是描述客观事物的符号，是计算机中可以操作的对象，数据不仅仅包括整数、小数、字符，还包括声音、图像、视频等等非数值类型。
</p>

<p>
数据有2个特点
</p>
<ul class="org-ul">
<li>可以输入到计算机中</li>
<li>能被计算机程序处理</li>
</ul>

<p>
对于数值类型可以进行数值计算，对于字符类型需要进行非数值处理，而声音图像视频等可以通过编码的手段变成字符数据来进行处理。
</p>

<p>
<b>结构</b>
</p>

<p>
结构可以简单理解为关系，比如分子结构就是说组成分子的原子之间的排列方式。而数据结构就是不同数据相互之间存在一种或多种特定关系的元素集合。
</p>

<p>
在计算机中，数据元素并不是孤立的、杂乱无序的，而是具有内在联系的数据集合。数据元素之间存在一种或多种特定的关系，也就是数据组织形式，它可以分为逻辑结构和物理结构。
</p>
</div>
</div>
<div id="outline-container-h:1524464d-7fd9-4408-ba1b-11f848ba2173" class="outline-4">
<h4 id="h:1524464d-7fd9-4408-ba1b-11f848ba2173"><a href="#h:1524464d-7fd9-4408-ba1b-11f848ba2173">逻辑结构</a></h4>
<div class="outline-text-4" id="text-h:1524464d-7fd9-4408-ba1b-11f848ba2173">
<p>
数据结构的逻辑结构指的是数据元素之间的逻辑关系，即数据在用户面前呈现的方式，而与数据在计算机内部的存储关系无关。
</p>

<p>
包括以下四种基本类型
</p>
<ul class="org-ul">
<li>集合结构：数据元素之间没有固定顺序，只是属于同一集合</li>
<li>线性结构：数据元素之间存在一对一的线性关系</li>
<li>树状结构：数据元素之间存在一对多的层次关系</li>
<li>图表结构：数据元素之间存在多对多的任意关系</li>
</ul>
</div>
</div>
<div id="outline-container-h:ed597323-b1d8-4126-9708-f12fe2a89e2a" class="outline-4">
<h4 id="h:ed597323-b1d8-4126-9708-f12fe2a89e2a"><a href="#h:ed597323-b1d8-4126-9708-f12fe2a89e2a">存储结构</a></h4>
<div class="outline-text-4" id="text-h:ed597323-b1d8-4126-9708-f12fe2a89e2a">
<p>
数据结构的存储结构又叫物理结构，指的是数据在计算机中的存储形式。
</p>

<p>
物理结构总共有两种：
</p>
<ul class="org-ul">
<li>顺序存储：数据元素按照一定的顺序存储在连续的内存空间中。C/C++中的数组就是这样的存储结构，当你告诉计算机创建一个10个元素的数组时，计算机就在内存中找到一块连续的区域，这样在访问的时候就可以利用索引快速找到对应位置上的数据。</li>
<li>链式存储：把数据元素存储在任意的内存中，无所谓连续，然后通过链接的关系把两个元素联系在一起。像链表就是一种基础的链式结构。</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-h:e9b95c86-f753-4275-bc37-e5bea83a43a6" class="outline-3">
<h3 id="h:e9b95c86-f753-4275-bc37-e5bea83a43a6"><a href="#h:e9b95c86-f753-4275-bc37-e5bea83a43a6">时间复杂度</a></h3>
<div class="outline-text-3" id="text-h:e9b95c86-f753-4275-bc37-e5bea83a43a6">
<p>
前言
</p>

<p>
很多人觉得算法难，是因为被困在了时间和空间这两个维度上。如果不考虑时间和空间的因素，其实我们可以把所有问题都通过「穷举法」来解决，也就是你告诉计算机你要做什么，然后通过它强大的算力帮你计算。
</p>

<p>
那么，说到了时间，今天我就和大家来聊一下「算法时间复杂度」。
</p>
</div>
<div id="outline-container-h:3ca4d298-8fb0-47ea-8193-b2ad9ca0de9f" class="outline-4">
<h4 id="h:3ca4d298-8fb0-47ea-8193-b2ad9ca0de9f"><a href="#h:3ca4d298-8fb0-47ea-8193-b2ad9ca0de9f">穷举法</a></h4>
<div class="outline-text-4" id="text-h:3ca4d298-8fb0-47ea-8193-b2ad9ca0de9f">
</div>
<div id="outline-container-h:535b2847-eba1-4cb5-9466-bc8e63b61f7a" class="outline-5">
<h5 id="h:535b2847-eba1-4cb5-9466-bc8e63b61f7a"><a href="#h:535b2847-eba1-4cb5-9466-bc8e63b61f7a">单层循环</a></h5>
<div class="outline-text-5" id="text-h:535b2847-eba1-4cb5-9466-bc8e63b61f7a">
<p>
所谓穷举法，就是我们通常所说的枚举，就是把所有情况都遍历了(跑到)的意思。举个最简单的例子:
</p>

<ul class="org-ul">
<li>【例题1】给定n(n&lt;=1000)个元素ai，求其中奇数有多少个。</li>
</ul>

<p>
判断一个数是偶数还是奇数，只需要求它除上2的余数是0还是是1，那么我们把所有数都判断一遍，并且对符合条件的情况进行计数，最后返回这个计数器就是答案，这里需要遍历所有的数，这就是穷举。如图所示:
</p>

<figure id="orgb8293df">
<img src="././images/time-img-20251023.gif" alt="time-img-20251023.gif" width="50%">

</figure>


<p>
C/C++代码实现如下：
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-function-name">countOdd</span>(<span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-type">int</span> <span class="org-variable-name">a</span>[]) {
    <span class="org-type">int</span> <span class="org-variable-name">cnt</span> = 0;
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; ++i) {
        <span class="org-keyword">if</span> (a[i] &amp; 1) {
            ++cnt;
        }
    }
    <span class="org-keyword">return</span> cnt;
}
</pre>
</div>

<p>
Python代码实现如下：
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">countOdd</span>(n, a):
    <span class="org-variable-name">cnt</span> <span class="org-operator">=</span> 0
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n):
        <span class="org-keyword">if</span> a[i] <span class="org-operator">&amp;</span> 1:
            <span class="org-variable-name">cnt</span> <span class="org-operator">+=</span> 1
    <span class="org-keyword">return</span> cnt
</pre>
</div>

<p>
其中 a &amp; 1等价于 a % 2，代表a模2的余数。
</p>
</div>
</div>
<div id="outline-container-h:04a976b5-6468-4ea2-b7bb-2f6ed35b3066" class="outline-5">
<h5 id="h:04a976b5-6468-4ea2-b7bb-2f6ed35b3066"><a href="#h:04a976b5-6468-4ea2-b7bb-2f6ed35b3066">双层循环</a></h5>
<div class="outline-text-5" id="text-h:04a976b5-6468-4ea2-b7bb-2f6ed35b3066">
<p>
经过上面的例子，相信你对穷举法已经有一定的理解，那么我我们来看看稍微复杂一点的情况。
</p>

<ul class="org-ul">
<li>【例题2】给定n(n&lt;=1000)个元素ai，求有多少个二元组(i，j)，满足ai+aj是奇数(i&lt;j)。
<ul class="org-ul">
<li>我们还是秉承穷举法的思想，这里需要两个变量i和j，所以可以收举ai和aj，再对ai+aj进行奇偶性断，所以很快设计出一个利用穷举的算法。如图二-2-1所示:</li>
</ul></li>
</ul>


<figure id="org4ee44fd">
<img src="././images/time-img-202510232.gif" alt="time-img-202510232.gif" width="50%">

</figure>

<p>
C/C++代码实现如下：
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-function-name">countOddPair</span>(<span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-type">int</span> <span class="org-variable-name">a</span>[]) {
    <span class="org-type">int</span> <span class="org-variable-name">cnt</span> = 0;
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; ++i) {
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = i + 1; j &lt; n; ++j) {
            <span class="org-keyword">if</span> (a[i] + a[j] &amp; 1)
                ++cnt;
        }
    }
    <span class="org-keyword">return</span> cnt;
}
</pre>
</div>

<p>
Python代码实现如下：
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">countOddPair</span>(n, a):
    <span class="org-variable-name">cnt</span> <span class="org-operator">=</span> 0
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n):
        <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(i<span class="org-operator">+</span>1, n):
            <span class="org-keyword">if</span> a[i] <span class="org-operator">+</span> a[j] <span class="org-operator">&amp;</span> 1:
                <span class="org-variable-name">cnt</span> <span class="org-operator">+=</span> 1
    <span class="org-keyword">return</span> cnt
</pre>
</div>
</div>
</div>
<div id="outline-container-h:581ae3e9-8cd6-467c-b06e-6e8b904960d7" class="outline-5">
<h5 id="h:581ae3e9-8cd6-467c-b06e-6e8b904960d7"><a href="#h:581ae3e9-8cd6-467c-b06e-6e8b904960d7">三层循环</a></h5>
<div class="outline-text-5" id="text-h:581ae3e9-8cd6-467c-b06e-6e8b904960d7">
<p>
经过这两个例子，是不是对穷举已经有点感觉了?那么，我们继读来看下一个例子。
</p>

<p>
【例题3】给定n(n&lt;=1000)个元素ai，求有多少个三元组(i，j，k)，满制足ai+aj+ak 是奇数(i&lt;j&lt;k)
</p>

<p>
相信聪明的你也已经猜到了，直接给出代码:
</p>

<p>
c/c++代码实现如下:
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-function-name">countOddTriple</span>(<span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-type">int</span> <span class="org-variable-name">a</span>[]) {
    <span class="org-type">int</span> <span class="org-variable-name">cnt</span> = 0;
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; ++i) {
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = i + 1; j &lt; n; ++j) {
            <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">k</span> = j + 1; k &lt; n; ++k) {
                <span class="org-keyword">if</span> (a[i] + a[j] + a[k] &amp; 1)
                    ++cnt;
            }
        }
    }
    <span class="org-keyword">return</span> cnt;
}
</pre>
</div>

<p>
Python代码实现如下：
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">countOddTriple</span>(n, a):
    <span class="org-variable-name">cnt</span> <span class="org-operator">=</span> 0
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n):
        <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(i<span class="org-operator">+</span>1, n):
            <span class="org-keyword">for</span> k <span class="org-keyword">in</span> <span class="org-builtin">range</span>(j<span class="org-operator">+</span>1, n):
                <span class="org-keyword">if</span> a[i] <span class="org-operator">+</span> a[j] <span class="org-operator">+</span> a[k] <span class="org-operator">&amp;</span> 1:
                    <span class="org-variable-name">cnt</span> <span class="org-operator">+=</span> 1
    <span class="org-keyword">return</span> cnt
</pre>
</div>

<p>
这时间，相信你已经意识到一个问题：时间
</p>

<p>
是的，随着循环嵌套的增多，时间消耗会越来越多，并且是是三个循环是乘法的关系，也就是遍历次数随着n的增加，呈立方式的增长。
</p>
</div>
</div>
<div id="outline-container-h:dc29d1b8-6197-49c2-9705-13ebc50c7638" class="outline-5">
<h5 id="h:dc29d1b8-6197-49c2-9705-13ebc50c7638"><a href="#h:dc29d1b8-6197-49c2-9705-13ebc50c7638">递归枚举</a></h5>
<div class="outline-text-5" id="text-h:dc29d1b8-6197-49c2-9705-13ebc50c7638">
<p>
【例题4】给定n(n&lt;=1000)个元素ai和一个整数k(k&lt;=n)，求有多少个有序k元组，满足它们的和是偶数。
</p>

<ul class="org-ul">
<li>一层循环，两层循环，三层循环，k层循环?</li>
<li>我们需要根据k的不同，决定写几层循环，k的最大值为1000，也就意味着我们要写1000的if else语句。</li>
<li>显然，这样是无法接受，比较暴力的做法是采用到递归;</li>
</ul>

<p>
c/c++代码实现如下:
</p>
<ul class="org-ul">
<li>代码可以先不看，当学到树的数据结构后比较好理解</li>
</ul>
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-function-name">dfs</span>(<span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-type">int</span> <span class="org-variable-name">a</span>[], <span class="org-type">int</span> <span class="org-variable-name">start</span>, <span class="org-type">int</span> <span class="org-variable-name">k</span>, <span class="org-type">int</span> <span class="org-variable-name">sum</span>) {
    <span class="org-keyword">if</span> (k = 0)
        <span class="org-keyword">return</span> (sum &amp; 1) ? 0 : 1;                 <span class="org-comment-delimiter">// </span><span class="org-comment">(1)
</span>    <span class="org-type">int</span> <span class="org-variable-name">s</span> = 0;
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = start; i &lt; n; ++i)
        s += dfs(n, a, i + 1, k - 1, sum + a[i]); <span class="org-comment-delimiter">// </span><span class="org-comment">(2)
</span>    <span class="org-keyword">return</span> s;
}
</pre>
</div>


<p>
Python代码实现如下：
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">dfs</span>(n, a, start, k, sum_):
    <span class="org-keyword">if</span> k <span class="org-operator">==</span> 0:
        <span class="org-keyword">return</span> 0 <span class="org-keyword">if</span> sum_ <span class="org-operator">&amp;</span> 1 <span class="org-keyword">else</span> 1 <span class="org-comment-delimiter">#</span><span class="org-comment">(1)
</span>    <span class="org-variable-name">s</span> <span class="org-operator">=</span> 0
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(start, n):
        <span class="org-variable-name">s</span> <span class="org-operator">+=</span> dfs(n, a, i<span class="org-operator">+</span>1, k<span class="org-operator">-</span>1, sum_ <span class="org-operator">+</span> a[i]) <span class="org-comment-delimiter"># </span><span class="org-comment">(2)
</span>    <span class="org-keyword">return</span> s
</pre>
</div>

<p>
这是一个经典的深度优先遍历的过程，对于初学者来说可能比较难理解，这个过程比较复杂。
</p>
<ul class="org-ul">
<li>(1)dfs(int n, inta[], int start, int k, int k, int sum)这个函数的含义是:给定n元素的数组a[]，从下标start开始，选择k个元素，得到的和为sum的情况下的方案数，当k=0时代表的是递归的出口;</li>
<li>(2)当前第 i元素选择以后，剩下就是从i+1个元素开始选择k-1个的情况，递归求解。</li>
<li>我们简单分析一下，n个元素选择k个，根据排列组合，方案数为:C(n,k)，当n=1000，k=500时已经是天文数字，这段代码是完全出不了解的。</li>
<li>当然，对于初学者来说，这段代码如果不理解，问题也不大，只是为了说明穷举这个思想。</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-h:64b2d0a1-e83e-42ca-b6a4-84564f69ecc2" class="outline-4">
<h4 id="h:64b2d0a1-e83e-42ca-b6a4-84564f69ecc2"><a href="#h:64b2d0a1-e83e-42ca-b6a4-84564f69ecc2">时间复杂度</a></h4>
<div class="outline-text-4" id="text-h:64b2d0a1-e83e-42ca-b6a4-84564f69ecc2">
</div>
<div id="outline-container-h:1ce4d14f-4a6b-4902-b6ef-77e3e4763b1e" class="outline-5">
<h5 id="h:1ce4d14f-4a6b-4902-b6ef-77e3e4763b1e"><a href="#h:1ce4d14f-4a6b-4902-b6ef-77e3e4763b1e">时间复杂度的表示法</a></h5>
<div class="outline-text-5" id="text-h:1ce4d14f-4a6b-4902-b6ef-77e3e4763b1e">
<p>
在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随着n的变化情况而确定T(n)的数量级。
</p>

<p>
算法的时间复杂度，就是算法的时间度量，记作: T(n)=O(f(n)) 用大写的O来体现算法时间复杂度的记法，我们称之为大O记法。
</p>
</div>
<ul class="org-ul">
<li><a id="h:8e8b2be1-8f9e-4be8-b670-163a90913bec"></a><a href="#h:8e8b2be1-8f9e-4be8-b670-163a90913bec">时间函数</a><br>
<div class="outline-text-6" id="text-h:8e8b2be1-8f9e-4be8-b670-163a90913bec">
<p>
时间复杂度往往会联系到一个函数，自变量表示规模，应变量表示执行时间。
</p>

<p>
这里所说的执行时间，是指广义的时间，也就是单位并不是"秒"、"毫秒"这些时间单位，它代表的是一个"执行次数"的概念。我们用f(n)来表示这个时间函数。
</p>
</div>
</li>
<li><a id="h:d35513cb-b503-433f-9614-b38a8eed6dd2"></a><a href="#h:d35513cb-b503-433f-9614-b38a8eed6dd2">经典函数举例</a><br>
<div class="outline-text-6" id="text-h:d35513cb-b503-433f-9614-b38a8eed6dd2">
<p>
在【例题1】中，我们接触到了单层循环，这里的n是一个变量，随着n的增大，执行次数增大，执行时间就会增加，所以就有了时间函数的表示法如下:f(n)=n
</p>


<figure id="orgbf66009">
<img src="././images/time-img-202510233.gif" alt="time-img-202510233.gif" width="50%">

</figure>

<p>
这个就是最经典的线性时间函数
</p>

<p>
在【例题2】中，我们接触到了双层循环，它的时间函数表示法如下：f(n) = n(n-1)/2。也就是随着n的增大，消耗的时间越多些。
</p>


<figure id="orgea50cd3">
<img src="././images/time-img-202510234.gif" alt="time-img-202510234.gif" width="50%">

</figure>

<p>
这是一个平方级别的时间函数
</p>

<p>
在【例3】中，我们接触到了三层循环，它的时间函数表示法如下：f(n) = n(n-1)(n-2)/6
</p>


<figure id="org3bd5b1a">
<img src="././images/time-img-202510235.gif" alt="time-img-202510235.gif" width="50%">

</figure>

<p>
这是一个立方级别的时间函数。
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-h:1325677a-749a-4574-960a-37419b4e4e93" class="outline-5">
<h5 id="h:1325677a-749a-4574-960a-37419b4e4e93"><a href="#h:1325677a-749a-4574-960a-37419b4e4e93">时间复杂度</a></h5>
<div class="outline-text-5" id="text-h:1325677a-749a-4574-960a-37419b4e4e93">
<p>
一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。
</p>

<p>
并且我们有一个更加优雅的表示法，即:T(n)=O(f(n))
</p>

<p>
其中O念成大O;
</p>
<ol class="org-ol">
<li>当f(n)=n，我们称这个算法拥有线性时间复杂度，记作O(n);</li>
<li>当f(n)=n(n-1)/2，我们称这个算法拥有平方级时间复杂度，记作O(n^2);</li>
<li>当f(n)=n(n-1)(n-2)/6，我们称这个算法拥有立方级的时间复杂度，记作O(n^3);</li>
</ol>

<p>
这时候我们发现，f的函数可能很复杂，但是O表示的函数往往比较简单，它舍弃了一些"细节"，这是为什么呢?
</p>

<p>
接下来我们来谈下数学上一个非常有名的概念"高阶无穷小"。
</p>
</div>
</div>
<div id="outline-container-h:d5dd3598-23aa-48a3-9e01-47fdbac760d6" class="outline-5">
<h5 id="h:d5dd3598-23aa-48a3-9e01-47fdbac760d6"><a href="#h:d5dd3598-23aa-48a3-9e01-47fdbac760d6">高阶无穷小</a></h5>
<div class="outline-text-5" id="text-h:d5dd3598-23aa-48a3-9e01-47fdbac760d6">
<p>
有这么一个定义:如果lim(B/a)=0，则称"β是比a较高阶的无穷小"。
</p>

<p>
如果对极限没有什么概念，我会用更加通俗的语言来解释一下。
</p>

<p>
我们来看上面提到的一个函数:
</p>

<p>
f(n) = n(n-1) / 2
</p>

<p>
总共两部分组成:一部分是n^2的部分，另一部分是n的部分，直观感受，那个更大呢?
</p>

<p>
显而易见，一定是n^2，相对于n^2来说，n就是"小巫见大巫"!
</p>

<p>
所以随着n的增长，线性的部分增长已经跟不上平方部分，这样，线性部分的时间消耗相对于平方不分来说已经"微不足道"，所以我们就索性不提它了，于是就有时间复杂度表示如下
</p>

<p>
\(T(n) = O(f(n))\)
</p>

<p>
\(=O(\frac{1}{2} n^2 - \frac{1}{2}n)\)
</p>

<p>
\(=O(\frac{1}{2} n^2)\)
</p>

<p>
\(=O(n^2)\)
</p>

<p>
所以它的时间复杂度就是 O(n^2)了。
</p>
</div>
</div>
<div id="outline-container-h:619ba3a0-d195-4e93-be94-dad8a13be79d" class="outline-5">
<h5 id="h:619ba3a0-d195-4e93-be94-dad8a13be79d"><a href="#h:619ba3a0-d195-4e93-be94-dad8a13be79d">简化系数</a></h5>
<div class="outline-text-5" id="text-h:619ba3a0-d195-4e93-be94-dad8a13be79d">
<p>
我们发现上述的公式推导的过程中，将n^2前面的系数1/2给去掉了，这是由于时间复杂度描述的更多的是一个数量级，所以尽量减少干扰项。对于两个不同的问题，可能执行时间不同，但是我们可以说他们的 <b>时间复杂度</b> 是一样的。
</p>

<p>
接下来让我们来看下一些常见的时间复杂度。
</p>
</div>
</div>
</div>
<div id="outline-container-h:44be47a5-3585-4657-95e2-e76540d4f64f" class="outline-4">
<h4 id="h:44be47a5-3585-4657-95e2-e76540d4f64f"><a href="#h:44be47a5-3585-4657-95e2-e76540d4f64f">常见的时间复杂度</a></h4>
<div class="outline-text-4" id="text-h:44be47a5-3585-4657-95e2-e76540d4f64f">
</div>
<div id="outline-container-h:59c8ce86-8b9d-4204-b8ce-2387471044ab" class="outline-5">
<h5 id="h:59c8ce86-8b9d-4204-b8ce-2387471044ab"><a href="#h:59c8ce86-8b9d-4204-b8ce-2387471044ab">常数阶</a></h5>
<div class="outline-text-5" id="text-h:59c8ce86-8b9d-4204-b8ce-2387471044ab">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">MAXN</span> = 1024;

<span class="org-type">int</span> <span class="org-function-name">getMAXN</span>() {
    <span class="org-keyword">return</span> MAXN;
}
</pre>
</div>

<p>
这个比较好理解，一共就一句话，没有循环，是常数时间，表示为O(1)。
</p>
</div>
</div>
<div id="outline-container-h:7c9d1d84-8eea-49df-9cee-b3928ac5724a" class="outline-5">
<h5 id="h:7c9d1d84-8eea-49df-9cee-b3928ac5724a"><a href="#h:7c9d1d84-8eea-49df-9cee-b3928ac5724a">对数阶</a></h5>
<div class="outline-text-5" id="text-h:7c9d1d84-8eea-49df-9cee-b3928ac5724a">
<p>
【例题4】给定n(n&lt;=10000000)个元素的有序数组 ai 和整数v，才v在数组中的下标，不存在输出-1。
</p>

<p>
这个问题就是一个常见的查询问题，我们可以用O(n)的算法遍历整个数组，然后去找v的值。
</p>

<p>
当然，也有更快的办法，注意到题目中的条件，数组ai是是有序的，所以我们可以利用二分查找来实现。
</p>

<p>
C/C++代码实现如下:
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-function-name">bin</span>(<span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-type">int</span> <span class="org-variable-name">a</span>[], <span class="org-type">int</span> <span class="org-variable-name">v</span>) {
    <span class="org-type">int</span> <span class="org-variable-name">l</span> = 0, <span class="org-variable-name">r</span> = n - 1;
    <span class="org-keyword">while</span> (l &lt;= r) {
        <span class="org-type">int</span> <span class="org-variable-name">mid</span> = (l + r) &gt;&gt; 1;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21491;&#31227;&#19968;&#20301;&#30456;&#24403;&#20110;&#23545;&#21407;&#26469;&#30340;&#36825;&#20010;&#25968;&#38500;&#19978;2
</span>        <span class="org-keyword">if</span> (a[mid] == v)
            <span class="org-keyword">return</span> mid;
        <span class="org-keyword">else</span> <span class="org-keyword">if</span> (a[mid] &lt; v)
            r = mid + 1;
        <span class="org-keyword">else</span>
            l = mid + 1;
    }
    <span class="org-keyword">return</span> -1;
}
</pre>
</div>

<p>
python代码实现如下:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">bin</span>(n, a, v):
    <span class="org-variable-name">l</span> <span class="org-operator">=</span> 0
    <span class="org-variable-name">r</span> <span class="org-operator">=</span> n <span class="org-operator">-</span>1
    <span class="org-keyword">while</span> l <span class="org-operator">&lt;=</span> r:
        <span class="org-variable-name">mid</span> <span class="org-operator">=</span> (l <span class="org-operator">+</span> r) <span class="org-operator">//</span> 2
        <span class="org-keyword">if</span> a[mid] <span class="org-operator">==</span> v:
            <span class="org-keyword">return</span> mid
        <span class="org-keyword">elif</span> a[mid] <span class="org-operator">&lt;</span> v:
            <span class="org-variable-name">r</span>  <span class="org-operator">=</span> mid <span class="org-operator">+</span> 1
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">l</span> <span class="org-operator">=</span> mid <span class="org-operator">+</span> 1
    <span class="org-keyword">return</span> <span class="org-operator">-</span>1
</pre>
</div>

<p>
这是一个二分查找的实现，时间复杂度为O(logn)。
</p>

<p>
每次相当于把n切半，即：
</p>

<p>
\(n \rightarrow \frac{n}{2} \rightarrow \frac{n}{4} \rightarrow \dots \rightarrow \frac{n}{2^k} \rightarrow \dots \rightarrow 0\)
</p>

<p>
这条路径长度也就是执行次数，也就是要求 \(2^k \leq n\) 中的 k 的最大值，两边取以2为底的对数，得到：
</p>

<p>
\(k \leq log_{2^n}\)
</p>

<p>
所以 T(n) = O(f(n)) = O(k) = O(logn)。
</p>
</div>
</div>
<div id="outline-container-h:62aecb69-c61e-4e2b-8043-d26f7d8c8200" class="outline-5">
<h5 id="h:62aecb69-c61e-4e2b-8043-d26f7d8c8200"><a href="#h:62aecb69-c61e-4e2b-8043-d26f7d8c8200">根号阶</a></h5>
<div class="outline-text-5" id="text-h:62aecb69-c61e-4e2b-8043-d26f7d8c8200">
<p>
【例题5】给定一个数n(n&lt;=10^9)，问n是否是一个素数(素数的既念，就是除了1和它本身，没有其它因子)。
</p>

<p>
基于素数的概念，我们可以枚举所有i属于[2，n)，看能否整除n，一旦能整除，代表找到了一个因子，则不是素数;当所有数枚举完还没找到，它就是素数。
</p>

<p>
但是这样做，显然效率太低，所以我们需要进行一些思考，最后得到以下算法:
</p>

<p>
C/C++代码实现如下:
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">bool</span> <span class="org-function-name">isPrime</span>(<span class="org-type">int</span> <span class="org-variable-name">n</span>) {
    <span class="org-type">int</span> <span class="org-variable-name">i</span>;
    <span class="org-keyword">if</span> (n == 1) {
        <span class="org-keyword">return</span> <span class="org-constant">false</span>;
    }
    <span class="org-type">int</span> <span class="org-variable-name">sqrtn</span> = sqrt(n + 0.0);
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 2; i &lt;= sqrtn; ++i) {
        <span class="org-keyword">if</span> (n % i == 0) {
            <span class="org-keyword">return</span> <span class="org-constant">false</span>;
        }
    }
    <span class="org-keyword">return</span> <span class="org-constant">true</span>;
}
</pre>
</div>

<p>
Python代码实现如下:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> math

<span class="org-keyword">def</span> <span class="org-function-name">isPrime</span>(n):
    <span class="org-keyword">if</span> n <span class="org-operator">==</span> 1:
        <span class="org-keyword">return</span> <span class="org-constant">False</span>
    <span class="org-variable-name">sqrtn</span> <span class="org-operator">=</span> <span class="org-builtin">int</span>(math.sqrt(n))
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(2, sqrtn <span class="org-operator">+</span> 1):
        <span class="org-keyword">if</span> n <span class="org-operator">%</span> i <span class="org-operator">==</span> 0:
            <span class="org-keyword">return</span> <span class="org-constant">False</span>
    <span class="org-keyword">return</span> <span class="org-constant">True</span>
</pre>
</div>

<p>
这个算法的时间复杂度为O(根号n)。
</p>

<p>
为什么只需要枚举根号n内的数呢?
</p>

<p>
因为一旦有一个因子s，必然有另一个因子n/s，它们之间必然有个大小关系，无论是s&lt;=n/s还是n/s &lt;= s，都能通过两边乘上s得出:
</p>

<p>
\(s \leq \sqrt{n}\)
</p>
</div>
</div>
<div id="outline-container-h:587f90a6-82b5-49d8-80c1-040d2e8765bf" class="outline-5">
<h5 id="h:587f90a6-82b5-49d8-80c1-040d2e8765bf"><a href="#h:587f90a6-82b5-49d8-80c1-040d2e8765bf">线性阶</a></h5>
<div class="outline-text-5" id="text-h:587f90a6-82b5-49d8-80c1-040d2e8765bf">
<p>
【例题1】中我们接触到的单层循环，这里的n是一个变量，随着着n的增大，执行次数增大，执行时间就会增加，所以就有了时间函数的表示法如下:
</p>

<p>
f(n) = n
</p>


<figure id="org4235fb3">
<img src="././images/time-img-202510236.gif" alt="time-img-202510236.gif" width="50%">

</figure>

<p>
这个就是最经典的线性时间，即O(n)。
</p>
</div>
</div>
<div id="outline-container-h:69a863f1-8c29-43e8-ba74-459bd3cedb06" class="outline-5">
<h5 id="h:69a863f1-8c29-43e8-ba74-459bd3cedb06"><a href="#h:69a863f1-8c29-43e8-ba74-459bd3cedb06">线性对数阶</a></h5>
<div class="outline-text-5" id="text-h:69a863f1-8c29-43e8-ba74-459bd3cedb06">
<p>
【例题6】给定n(n&lt;=10000000)个元素ai，求满足ai+aj=1024的有序二元组(i，j)有多少对。
</p>

<p>
首先，还是先思考最朴素的算法，当然是两层枚举了，参考【例题2】，时间复杂度O(n^2)。
</p>

<p>
但是，这个问题n的范围较大。
</p>

<p>
我们来看下这个问题，如果你对【例题4】已经理解了，那那么这个问题也就不难了。
</p>

<p>
我们可以先对所有元素ai按照递增排序，然后枚举ai，并且在[i-+1, n)范围内找是否存在aj=1024
</p>
</div>
</div>
<div id="outline-container-h:2027a063-2e5c-442d-a0d1-7a86536341c9" class="outline-5">
<h5 id="h:2027a063-2e5c-442d-a0d1-7a86536341c9"><a href="#h:2027a063-2e5c-442d-a0d1-7a86536341c9">多项式阶</a></h5>
<div class="outline-text-5" id="text-h:2027a063-2e5c-442d-a0d1-7a86536341c9">
<p>
多项式的含义是函数f(n)可以表示成如下形式:
</p>

<p>
\(f(n) = an^k + bn^{k-1} + \dots + C\)
</p>

<p>
所以O(n^5)、O(n^4)、O(n^3)(立方阶)、O(n^2)(平方阶)、O(n)(线性阶)都是多项式时间。
</p>
</div>
</div>
<div id="outline-container-h:5ab3daa8-a572-4d60-a55c-2b672089e875" class="outline-5">
<h5 id="h:5ab3daa8-a572-4d60-a55c-2b672089e875"><a href="#h:5ab3daa8-a572-4d60-a55c-2b672089e875">指数阶</a></h5>
<div class="outline-text-5" id="text-h:5ab3daa8-a572-4d60-a55c-2b672089e875">
<p>
【例题7】给出n(n&lt;=15)个点，以及每两个点之间的关系(连通还是不连通)，求一个最大的集合，使得在这个集合中都连通。
</p>

<p>
这是求子集的问题，由于最多只有15个点，我们就可以枚举每个点选或者不选，总共2^n种情况，然后再判断是否满足题目中的连通性，这个算法时间复杂度为O(n^2 * 2^n);
</p>

<p>
当然有更加优秀的算法，但不是本文讨论的重点，所以就交给优秀的你自己去探索啦!
</p>
</div>
</div>
<div id="outline-container-h:3adc371b-b593-4400-9c93-edfbf627526d" class="outline-5">
<h5 id="h:3adc371b-b593-4400-9c93-edfbf627526d"><a href="#h:3adc371b-b593-4400-9c93-edfbf627526d">阶乘阶</a></h5>
<div class="outline-text-5" id="text-h:3adc371b-b593-4400-9c93-edfbf627526d">
<p>
【例题8】给定n(n&lt;=12)个点，并且给出任意两点间的距离，求从S点开始经过所有点回到S的距离的最小值。
</p>

<p>
这个问题就是典型的暴力枚举所有情况求解，可以把这些点当成是一个排列，所以排列方案数为 n! 。
</p>

<p>
暴力枚举的时间复杂度为O(n!)。
</p>

<p>
当然，一般这类问题，暴力搜索没有实际意义，我们可以通过动态规划来进行优化。
</p>
</div>
</div>
</div>
<div id="outline-container-h:3c344e12-1083-4202-8a3c-fecb6881f340" class="outline-4">
<h4 id="h:3c344e12-1083-4202-8a3c-fecb6881f340"><a href="#h:3c344e12-1083-4202-8a3c-fecb6881f340">如何判断时间复杂度</a></h4>
<div class="outline-text-4" id="text-h:3c344e12-1083-4202-8a3c-fecb6881f340">
<p>
接下来我们来讨论下，如何通过一个问题的规模来判断这个个问题应该能够承受的时间复杂度。
</p>
</div>
<div id="outline-container-h:bd2f0e14-b368-4cc3-ac3b-147ec1c5cc91" class="outline-5">
<h5 id="h:bd2f0e14-b368-4cc3-ac3b-147ec1c5cc91"><a href="#h:bd2f0e14-b368-4cc3-ac3b-147ec1c5cc91">标准</a></h5>
<div class="outline-text-5" id="text-h:bd2f0e14-b368-4cc3-ac3b-147ec1c5cc91">
<p>
首先，我们需要一个标准，也就是总执行次数多少合适。
</p>

<p>
这个标准是我经过多年做题经验得出，我们把它定义为S = 10^6。一个数据如果跑 10^6 以上，那么时间复杂度就是偏高了。
</p>
</div>
</div>
<div id="outline-container-h:6bd6429f-46b3-4826-8594-761dc869ac28" class="outline-5">
<h5 id="h:6bd6429f-46b3-4826-8594-761dc869ac28"><a href="#h:6bd6429f-46b3-4826-8594-761dc869ac28">问题规模</a></h5>
<div class="outline-text-5" id="text-h:6bd6429f-46b3-4826-8594-761dc869ac28">
<p>
有了标准以后，我们还需要知道问题规模，也就是O(n)中的n。
</p>
</div>
</div>
<div id="outline-container-h:03c3b7b2-a43c-421d-a7b5-f8a4f0468fb4" class="outline-5">
<h5 id="h:03c3b7b2-a43c-421d-a7b5-f8a4f0468fb4"><a href="#h:03c3b7b2-a43c-421d-a7b5-f8a4f0468fb4">套公式</a></h5>
<div class="outline-text-5" id="text-h:03c3b7b2-a43c-421d-a7b5-f8a4f0468fb4">
<p>
然后就是凭感觉套公式了。
</p>

<ul class="org-ul">
<li>当n&lt;12时，可能是需要用到阶乘级别的算法，即 \(O(n!)\);</li>
<li>当n&lt;16时，可能是需要状态压缩的算法，比如 \(O(2^n) 、 O(n2^n) 、 O(n^22^n)\);</li>
<li>当n&lt;30时，可能是需要 \(O(n^4)\) 的算法，因为 \(30^4\) 差不多接近 \(10^6\);</li>
<li>当n&lt;100时，可能是需要 \(O(n^3)\) 的算法，因为 \(100^3 = 10^6\);</li>
<li>当n&lt;1000时，可能是需要 \(O(n^2)\) 的算法，因为 \(1000^2 = 10^6\);</li>
<li>当n&lt;100000时，可能是需要 \(O(nlog_{2^n}) 、 O(n(log_{2^n})^2)\) 的算法;</li>
<li>当n&lt;1000000时，可能是需要 \(O(\sqrt{n}) 、 O(n)\) 的算法;</li>
</ul>

<p>
细心的读者可能会发现，我在描述的时候都是用了可能的话语气，那是因为以上数据量都是我通过做题总结出来的，有时候还需要结合题目本身的时间限制、出题人的阴险程度来决定，所以不能一概而论。
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-h:94dc38b1-fb11-4b9f-962f-2d5648084a6b" class="outline-3">
<h3 id="h:94dc38b1-fb11-4b9f-962f-2d5648084a6b"><a href="#h:94dc38b1-fb11-4b9f-962f-2d5648084a6b">空间复杂度</a></h3>
<div class="outline-text-3" id="text-h:94dc38b1-fb11-4b9f-962f-2d5648084a6b">
<p>
前言
</p>

<p>
很多人觉得算法难，是因为被困在了时间和空间这两个维度上。如果不考虑时间和空间的因素，其实我们可以把所有问题都通过「穷举法」来解决，也就是你告诉计算机你要做什么，然后通过它强大的算力帮你计算。
</p>

<p>
那么。今天我就和大家来聊一下「算法空间复杂度」。
</p>
</div>
<div id="outline-container-h:e3fed39f-b9fd-4644-8dc2-449d753ec875" class="outline-4">
<h4 id="h:e3fed39f-b9fd-4644-8dc2-449d753ec875"><a href="#h:e3fed39f-b9fd-4644-8dc2-449d753ec875">概念</a></h4>
<div class="outline-text-4" id="text-h:e3fed39f-b9fd-4644-8dc2-449d753ec875">
<p>
空间复杂度是指算法在执行过程中所需的额外存储空间。这包括算法在运行时使用的变量、数组、链表等数据结构所占用的内存空间。它和算法的时间复杂度一起，是衡量算法性能的重要指标之一。
</p>
<ul class="org-ul">
<li>额外存储空间：比如给写一个n个元素的数组要你怎么样怎么样。如果你不用其它额外的空间，空间复杂度就是O(1)，也就是说这个给你的数组不能算在空间复杂度里。</li>
</ul>

<p>
在算法设计中，我们通常希望尽可能地降低空间复杂度，以减少内存的使用，提高算法的效率。然而，在某些情况下，为了实现算法的功能，可能需要使用更多的存储空间。
</p>
</div>
</div>
<div id="outline-container-h:0e9501d3-b382-4488-a17b-52def597ec4b" class="outline-4">
<h4 id="h:0e9501d3-b382-4488-a17b-52def597ec4b"><a href="#h:0e9501d3-b382-4488-a17b-52def597ec4b">常见数据结构的空间复杂度</a></h4>
<div class="outline-text-4" id="text-h:0e9501d3-b382-4488-a17b-52def597ec4b">
<ol class="org-ol">
<li>顺序表:0(n)，其中n是顺序表的长度。</li>
<li>链表:O(n)，其中n是链表的长度。</li>
<li>栈:O(n)，其中n是栈的最大深度。</li>
<li>队列:O(n)，其中n是队列的最大长度。</li>
<li>哈希表:O(n)，其中n是哈希表中元素的数量。</li>
<li>树:O(n)，其中n是树的结点数量。</li>
<li>图:O(n+m)，其中n是图中顶点的数量，其中m是图中边的数量。</li>
</ol>

<p>
当然具体情况还需要具体分析。
</p>
</div>
</div>
<div id="outline-container-h:cde0f5ad-fb73-469e-86f5-42d383b8fd3c" class="outline-4">
<h4 id="h:cde0f5ad-fb73-469e-86f5-42d383b8fd3c"><a href="#h:cde0f5ad-fb73-469e-86f5-42d383b8fd3c">空间换时间</a></h4>
<div class="outline-text-4" id="text-h:cde0f5ad-fb73-469e-86f5-42d383b8fd3c">
<p>
通常使用额外空间的目的，就是为了换取时间上的效率，也就是我们常说的空间换时间。最经典的空间换时间就是动态规划，例如求一个斐波那契数列的第n项的值，如如果不做任何优化，就是利用循环进行计算，时间复杂度O(n)，但是如果引入了数组，将计算结果预先存储在数组中，那么每次询问只需要0(1)的时间复杂度就可以得到第n项的值，而这时，由于引入了数组，所以空间复杂度就变成了O(n)。
</p>
</div>
</div>
<div id="outline-container-h:cc28969b-75a9-4b32-a3f0-2d8fec290efc" class="outline-4">
<h4 id="h:cc28969b-75a9-4b32-a3f0-2d8fec290efc"><a href="#h:cc28969b-75a9-4b32-a3f0-2d8fec290efc">总结</a></h4>
<div class="outline-text-4" id="text-h:cc28969b-75a9-4b32-a3f0-2d8fec290efc">
<p>
对于空间复杂度，不需要太过纠结于概念，学习动态规划以后，会对它有非常深刻的理解。
</p>
</div>
</div>
</div>
</section>
<section id="outline-container-h:2b071966-fede-4e7b-ba02-91821c0ea61d" class="outline-2">
<h2 id="h:2b071966-fede-4e7b-ba02-91821c0ea61d"><a href="#h:2b071966-fede-4e7b-ba02-91821c0ea61d">环境使用</a></h2>
<div class="outline-text-2" id="text-h:2b071966-fede-4e7b-ba02-91821c0ea61d">
<ul class="org-ul">
<li>在线编译 <a href="https://www.jyshare.com/compile/12/">https://www.jyshare.com/compile/12/</a></li>
<li>杭电在线评测系统 HDOJ <a href="https://acm.hdu.edu.cn/">https://acm.hdu.edu.cn/</a>  (相对简单)
<ul class="org-ul">
<li>ACM 模式例子。</li>
<li>Problem Archive 第11页是中文题目</li>
</ul></li>

<li>北大在线评测系统 POJ <a href="http://poj.org/">http://poj.org/</a> (相对难些)
<ul class="org-ul">
<li>Register 注册账号。在 Problems 找到题目。</li>
</ul></li>
<li>力扣核心代码模式 <a href="https://leetcode.cn/problemset/">https://leetcode.cn/problemset/</a> (面向求职的，相对简单)
<ul class="org-ul">
<li>核心代码模式例子</li>
</ul></li>
</ul>

<p>
vs2022安装 <a href="https://visualstudio.microsoft.com/zh-hans/free-developer-offers/">https://visualstudio.microsoft.com/zh-hans/free-developer-offers/</a>
</p>

<p>
<b>语言其实也不重要，最重要的还是数据结构和算法的思想</b> 。
</p>
</div>
</section>
<section id="outline-container-h:c6967906-3638-45d3-8985-afede709b5ff" class="outline-2">
<h2 id="h:c6967906-3638-45d3-8985-afede709b5ff"><a href="#h:c6967906-3638-45d3-8985-afede709b5ff">线性结构-顺序表</a></h2>
<div class="outline-text-2" id="text-h:c6967906-3638-45d3-8985-afede709b5ff">
</div>
<div id="outline-container-h:c1da5528-9142-464b-b410-2864229cc466" class="outline-3">
<h3 id="h:c1da5528-9142-464b-b410-2864229cc466"><a href="#h:c1da5528-9142-464b-b410-2864229cc466">顺序表（概念篇）</a></h3>
<div class="outline-text-3" id="text-h:c1da5528-9142-464b-b410-2864229cc466">
</div>
<div id="outline-container-h:858e2e3f-e656-412d-82cf-fa119d2e4e8a" class="outline-4">
<h4 id="h:858e2e3f-e656-412d-82cf-fa119d2e4e8a"><a href="#h:858e2e3f-e656-412d-82cf-fa119d2e4e8a">顺序表的概念</a></h4>
<div class="outline-text-4" id="text-h:858e2e3f-e656-412d-82cf-fa119d2e4e8a">
<p>
顺序表的增删改查、顺序表的扩容、顺序表的应用
</p>
<ul class="org-ul">
<li>插入、删除、查找、索引、修改</li>
</ul>

<p>
顺序表是一种线性的数据结构，其中数据元素按照特定的顺序依次存储在连续的内存空间中。它由一系列元素组成，每个元素都与唯一的索引(或者叫下标)相关联，索引从0开始递增。
</p>

<p>
下图中，下面那排数字0到9代表的就是索引，天蓝色柱子上的数字，代表的则是顺序表中的元素，元素可以整数，可以是浮点数，可以是任意类型，包括结构体或者对象，等等。
</p>


<figure id="org8ea8dfc">
<img src="././images/img-202510237.png" alt="img-202510237.png" width="50%">

</figure>
</div>
</div>
<div id="outline-container-h:b1830c6d-06d2-4ffa-a0c2-ae23baa8782c" class="outline-4">
<h4 id="h:b1830c6d-06d2-4ffa-a0c2-ae23baa8782c"><a href="#h:b1830c6d-06d2-4ffa-a0c2-ae23baa8782c">顺序表的元素插入</a></h4>
<div class="outline-text-4" id="text-h:b1830c6d-06d2-4ffa-a0c2-ae23baa8782c">
<p>
元素插入的概念
</p>
<ul class="org-ul">
<li>顺序表的元素插入，就是指给定一个索引和一个元素，将这个元素插入到对应的索引位置上，这个位置以后的所有元素都要往后移动一个位置。</li>
</ul>

<p>
元素插入图解
</p>
<ul class="org-ul">
<li>本次插入操作，是给定一个元素值为5的元素，插入到顺序表的3的索引上(下标从0开始)。我们看到，从后往前把元素往后挪，直到找到要插入的位置嘛，把元素插入进去。</li>
</ul>


<figure id="org68ef831">
<img src="././images/img-202510238.gif" alt="img-202510238.gif" width="50%">

</figure>

<p>
元素插入的步骤
</p>
<ul class="org-ul">
<li>第1步、判断插入位置是否合法，如果不合法则抛出异常(比比如:原本只有5个元素，给定的索引是100，那显然这个位置是不合法的)。</li>
<li>第2步、如果顺序表已满，则需要扩容顺序表，一般是把原有顺序表的容量进行倍增。</li>
<li>第3步、将插入位置之后的元素向后移动，为新元素腾出空间。</li>
<li>第4步、将新元素插入到指定位置。</li>
<li>第5步、更新顺序表的大小。</li>
</ul>
</div>
</div>
<div id="outline-container-h:81d81bef-2c3c-4426-bb4a-e4f16f37d44d" class="outline-4">
<h4 id="h:81d81bef-2c3c-4426-bb4a-e4f16f37d44d"><a href="#h:81d81bef-2c3c-4426-bb4a-e4f16f37d44d">顺序表的元素删除</a></h4>
<div class="outline-text-4" id="text-h:81d81bef-2c3c-4426-bb4a-e4f16f37d44d">
<p>
元素删除的概念
</p>
<ul class="org-ul">
<li>顺序表的元素删除，就是指给定一个索引，将这个索引上的元素删除除，并且把这个索引位置以后的所有元素都往前移动一个位置。</li>
</ul>

<p>
元素删除的图解
</p>
<ul class="org-ul">
<li>图中要删除的是索引为3的元素，也就是5这个元素，然后从前往后，将元素往前移。</li>
</ul>


<figure id="orge2b708e">
<img src="././images/img-202510239.gif" alt="img-202510239.gif" width="50%">

</figure>

<p>
元素删除的步骤
</p>
<ul class="org-ul">
<li>第1步、判断删除位置是否合法，如果不合法则抛出异常。</li>
<li>第2步、如果删除位置为最后一个元素，直接将顺序表的大小减1。</li>
<li>第3步、如果删除位置不是最后一个元素，将删除位置之后的元素向前移动，覆盖要删除的元素。</li>
<li>第4步、更新顺序表的大小。</li>
</ul>
</div>
</div>
<div id="outline-container-h:98a97b50-baac-441c-b041-b5cb65b85676" class="outline-4">
<h4 id="h:98a97b50-baac-441c-b041-b5cb65b85676"><a href="#h:98a97b50-baac-441c-b041-b5cb65b85676">顺序表的元素查找</a></h4>
<div class="outline-text-4" id="text-h:98a97b50-baac-441c-b041-b5cb65b85676">
<p>
元素查找的概念
</p>
<ul class="org-ul">
<li>顺序表的元素查找，是指在顺序表中查找指定元素是否存在，如果存在则返回该元素的索引，否则返回-1。由于需要遍历整个顺序表进行元素对比，所以查找的时间复杂度为O(n)。</li>
</ul>

<p>
元素查找的图解
</p>
<ul class="org-ul">
<li>要查找的是一个值为7的元素，通过遍历所有元素，找到值直为7的元素以后，返回它所在的索引。</li>
</ul>


<figure id="orga9b3c04">
<img src="././images/img-2025102310.gif" alt="img-2025102310.gif" width="50%">

</figure>

<p>
元素查找的步骤
</p>
<ul class="org-ul">
<li>第1步、遍历整个顺序表，对顺序表中的每个元素，和指定元素进行比较，如果相等则返回当前的索引;</li>
<li>第2步、如果遍历完所有的顺序表元素，都没有找到相等的元素，则返回-1;</li>
</ul>
</div>
</div>
<div id="outline-container-h:a7fbf6c5-010c-4d26-86d3-8b90a62d9362" class="outline-4">
<h4 id="h:a7fbf6c5-010c-4d26-86d3-8b90a62d9362"><a href="#h:a7fbf6c5-010c-4d26-86d3-8b90a62d9362">顺序表的元素索引</a></h4>
<div class="outline-text-4" id="text-h:a7fbf6c5-010c-4d26-86d3-8b90a62d9362">
<p>
元素素引的概念
</p>
<ul class="org-ul">
<li>顺序表的元素索引，是指给定一个索引值，通过下标访问，直接在顺序表中获取元素的值，时间复杂度0(1)。</li>
</ul>

<p>
元素索引的图解
</p>
<ul class="org-ul">
<li>给定的是5这个索引，通过下标访问，直接获取到7这个元素。一般每个语言都会有这个特性在里面。</li>
</ul>


<figure id="org2ea9641">
<img src="././images/img-2025102311.gif" alt="img-2025102311.gif" width="50%">

</figure>

<p>
元素索引的步骤
</p>
<ul class="org-ul">
<li>第1步、直接通过索引访问即可获得对应的元素;</li>
</ul>
</div>
</div>
<div id="outline-container-h:5b8dd9a3-d9e3-49a8-9d4c-3139c1bac210" class="outline-4">
<h4 id="h:5b8dd9a3-d9e3-49a8-9d4c-3139c1bac210"><a href="#h:5b8dd9a3-d9e3-49a8-9d4c-3139c1bac210">顺序表的元素修改</a></h4>
<div class="outline-text-4" id="text-h:5b8dd9a3-d9e3-49a8-9d4c-3139c1bac210">
<p>
元素修改的概念
</p>
<ul class="org-ul">
<li>顺序表的元素修改是指将顺序表中指定位置的元素更新为新的值。</li>
</ul>

<p>
元素索引的图解
</p>
<ul class="org-ul">
<li>如图所示，给定的是5这个索引，通过下标访问，把它从原来的7改成9</li>
</ul>

<p>
元素修改的步骤
</p>
<ul class="org-ul">
<li>直接通过索引访问即可获得对应的元素，修改成指定的值;</li>
</ul>


<figure id="org0802c96">
<img src="././images/img-2025102312.gif" alt="img-2025102312.gif" width="50%">

</figure>
</div>
</div>
</div>
<div id="outline-container-h:8f6e16c8-d163-47b9-9518-778ebc6ced5a" class="outline-3">
<h3 id="h:8f6e16c8-d163-47b9-9518-778ebc6ced5a"><a href="#h:8f6e16c8-d163-47b9-9518-778ebc6ced5a">代码篇</a></h3>
<div class="outline-text-3" id="text-h:8f6e16c8-d163-47b9-9518-778ebc6ced5a">
</div>
<div id="outline-container-h:a196dd4e-0276-473b-9a78-5723c0491c37" class="outline-4">
<h4 id="h:a196dd4e-0276-473b-9a78-5723c0491c37"><a href="#h:a196dd4e-0276-473b-9a78-5723c0491c37">手写顺序表模板</a></h4>
<div class="outline-text-4" id="text-h:a196dd4e-0276-473b-9a78-5723c0491c37">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-preprocessor">#define</span> <span class="org-variable-name">eleType</span> <span class="org-type">double</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">&#34920;&#31034;&#39034;&#24207;&#34920;&#20013;&#25152;&#26377;&#20803;&#32032;&#37117;&#36825;&#20010;&#31867;&#22411;&#30340;
</span>
<span class="org-keyword">struct</span> <span class="org-type">SequentialList</span> {
    <span class="org-type">eleType</span>* <span class="org-variable-name">elements</span>;
    <span class="org-type">int</span> <span class="org-variable-name">size</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">&#20803;&#32032;&#20010;&#25968;
</span>    <span class="org-type">int</span> <span class="org-variable-name">capacity</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23481;&#37327;
</span>};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#39034;&#24207;&#34920;&#21021;&#22987;&#21270;
</span><span class="org-type">void</span> <span class="org-function-name">initializeList</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>, <span class="org-type">int</span> <span class="org-variable-name">capacity</span>) {
    list-&gt;elements = <span class="org-keyword">new</span> <span class="org-type">eleType</span>[capacity];
    list-&gt;size = 0;
    list-&gt;capacity = capacity;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#39034;&#24207;&#34920;&#30340;&#38144;&#27585;
</span><span class="org-type">void</span> <span class="org-function-name">destroyList</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>) {
    <span class="org-keyword">delete</span>[] list-&gt;elements;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#33719;&#21462;&#39034;&#24207;&#34920;&#22823;&#23567;&#25509;&#21475;
</span><span class="org-type">int</span> <span class="org-function-name">size</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>) {
    <span class="org-keyword">return</span> list-&gt;size;
}

<span class="org-type">bool</span> <span class="org-function-name">isEmpty</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>) {
    <span class="org-keyword">return</span> list-&gt;size == 0;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#39034;&#24207;&#34920;&#30340;&#25554;&#20837;&#25805;&#20316;
</span><span class="org-type">void</span> <span class="org-function-name">insert</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>, <span class="org-type">int</span> <span class="org-variable-name">index</span>, <span class="org-type">eleType</span> <span class="org-variable-name">element</span>) {
    <span class="org-keyword">if</span> (<span class="org-type">index</span> &lt; 0 || index &gt; <span class="org-variable-name">list</span>-&gt;size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::invalid_argument(<span class="org-string">"Invalid index"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25243;&#24322;&#24120;
</span>    }
    <span class="org-keyword">if</span> (list-&gt;capacity == list-&gt;size) {
        <span class="org-type">int</span> <span class="org-variable-name">newCapacity</span> = list-&gt;capacity * 2;
        <span class="org-type">eleType</span>* <span class="org-variable-name">newElements</span> = <span class="org-keyword">new</span> <span class="org-type">eleType</span>[newCapacity];
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; newCapacity/2; ++i) {
            newElements[i] = list-&gt;elements[i];
        }
        <span class="org-keyword">delete</span>[] list-&gt;elements;
        list-&gt;elements = newElements;
        list-&gt;capacity = newCapacity;
    }
    list-&gt;size++;
    <span class="org-keyword">if</span> (list-&gt;size &lt;= list-&gt;capacity) {
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = list-&gt;size -1; i &gt; index; --i) {
            list-&gt;elements[i] = list-&gt;elements[i - 1];
        }
        list-&gt;elements[index] = element;
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#39034;&#24207;&#34920;&#30340;&#20803;&#32032;&#21024;&#38500;
</span><span class="org-type">void</span> <span class="org-function-name">deleteElement</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>, <span class="org-type">int</span> <span class="org-variable-name">index</span>) {
    <span class="org-keyword">if</span> (index &lt; 0 || index &gt;= list-&gt;size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::invalid_argument(<span class="org-string">"Invalid index"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25243;&#24322;&#24120;
</span>    }
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = index; i &lt; list-&gt;size; ++i) {
        list-&gt;elements[i] = list-&gt;elements[i + 1];
    }
    list-&gt;size--;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#39034;&#24207;&#34920;&#20803;&#32032;&#26597;&#25214;
</span><span class="org-type">int</span> <span class="org-function-name">findElement</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>, <span class="org-type">eleType</span> <span class="org-variable-name">element</span>) {
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; list-&gt;size; ++i) {
        <span class="org-keyword">if</span> (list-&gt;elements[i] == element) {
            <span class="org-keyword">return</span> i;
        }
    }
    <span class="org-keyword">return</span> -1;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#39034;&#24207;&#34920;&#20803;&#32032;&#32034;&#24341;
</span><span class="org-type">eleType</span> <span class="org-function-name">getElement</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>, <span class="org-type">int</span> <span class="org-variable-name">index</span>) {
    <span class="org-keyword">if</span> (<span class="org-type">index</span> &lt; 0 || index &gt; <span class="org-variable-name">list</span>-&gt;size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::invalid_argument(<span class="org-string">"Invalid index"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25243;&#24322;&#24120;
</span>    }
    <span class="org-keyword">return</span> list-&gt;elements[index];
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#39034;&#24207;&#34920;&#20803;&#32032;&#20462;&#25913;
</span><span class="org-type">void</span> <span class="org-function-name">updateElement</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>, <span class="org-type">int</span> <span class="org-variable-name">index</span>, <span class="org-type">eleType</span> <span class="org-variable-name">value</span>) {
    <span class="org-keyword">if</span> (<span class="org-type">index</span> &lt; 0 || index &gt; <span class="org-variable-name">list</span>-&gt;size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::invalid_argument(<span class="org-string">"Invalid index"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25243;&#24322;&#24120;
</span>    }
    list-&gt;elements[index] = value;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">SequentialList</span> <span class="org-variable-name">myList</span>;
    initializeList(&amp;myList, 10);
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 10; ++i) {
        insert(&amp;myList, i, i * 10);
    }
    cout &lt;&lt; <span class="org-string">"Size: "</span> &lt;&lt; size(&amp;myList) &lt;&lt; endl;
    cout &lt;&lt; <span class="org-string">"Is empty: "</span> &lt;&lt; isEmpty(&amp;myList) &lt;&lt; endl;

    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; size(&amp;myList); ++i) {
        cout &lt;&lt; getElement(&amp;myList, i) &lt;&lt; <span class="org-string">' '</span>;
    }
    cout &lt;&lt; endl;

    deleteElement(&amp;myList, 5);
    updateElement(&amp;myList, 1, 1314);
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; size(&amp;myList); ++i) {
        cout &lt;&lt; getElement(&amp;myList, i) &lt;&lt; <span class="org-string">' '</span>;
    }
    cout &lt;&lt; endl;

    <span class="org-type">int</span> <span class="org-variable-name">idx</span> = findElement(&amp;myList, 20);
    updateElement(&amp;myList, idx, 520);
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; size(&amp;myList); ++i) {
        cout &lt;&lt; getElement(&amp;myList, i) &lt;&lt; <span class="org-string">' '</span>;
    }
    cout &lt;&lt; endl;

    destroyList(&amp;myList);

    <span class="org-keyword">return</span> 0;
}

</pre>
</div>
</div>
</div>
<div id="outline-container-h:720f9860-0494-4bbd-be68-c7cba95da075" class="outline-4">
<h4 id="h:720f9860-0494-4bbd-be68-c7cba95da075"><a href="#h:720f9860-0494-4bbd-be68-c7cba95da075">C++中的顺序表(vector)</a></h4>
<div class="outline-text-4" id="text-h:720f9860-0494-4bbd-be68-c7cba95da075">
<p>
也就是vector模板类，中文是向量的意思。模板类就是vector内部的元素可以是任意类型，如vector加一个整型然后它的类型叫ret： vector&lt;int&gt; ret; 可以理解成一个空的顺序表。
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;vector&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">ret</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21487;&#20197;&#29702;&#35299;&#20026;&#31354;&#30340;&#39034;&#24207;&#34920;
</span>    cout &lt;&lt; ret.size() &lt;&lt; endl; <span class="org-comment-delimiter">// </span><span class="org-comment">0
</span>    ret.push_back(1024); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25554;&#20837;&#19968;&#20010;&#20803;&#32032;&#21040;&#39034;&#24207;&#34920;&#23614;&#37096;
</span>    cout &lt;&lt; ret.size() &lt;&lt; endl; <span class="org-comment-delimiter">// </span><span class="org-comment">1
</span>    cout &lt;&lt; ret[0] &lt;&lt; endl; <span class="org-comment-delimiter">// </span><span class="org-comment">1024&#12290;0&#20301;&#32622;&#30340;&#20803;&#32032;
</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">&#39034;&#24207;&#34920;&#30340;&#21024;&#38500;&#26412;&#36523;&#26102;&#38388;&#22797;&#26434;&#24230;&#27604;&#36739;&#39640;&#65292;&#19968;&#33324;&#19981;&#29992;&#36825;&#20010;&#25968;&#25454;&#32467;&#26500;&#65292;&#35201;&#37319;&#29992;&#20854;&#23427;&#30340;&#25968;&#25454;&#32467;&#26500;
</span>
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">ret1</span> = { 1, 2, 3, 4, 5 }; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#21270;
</span>    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; ret1.size(); ++i) {
        cout &lt;&lt; ret1[i] &lt;&lt; <span class="org-string">' '</span>;
    }
    cout &lt;&lt; endl;

    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:e6497083-6454-4c28-8caa-5a237c7c589f" class="outline-3">
<h3 id="h:e6497083-6454-4c28-8caa-5a237c7c589f"><a href="#h:e6497083-6454-4c28-8caa-5a237c7c589f">实战篇</a></h3>
<div class="outline-text-3" id="text-h:e6497083-6454-4c28-8caa-5a237c7c589f">
</div>
<div id="outline-container-h:3f5df4bc-9dec-4c87-b68a-7e30eb9545be" class="outline-4">
<h4 id="h:3f5df4bc-9dec-4c87-b68a-7e30eb9545be"><a href="#h:3f5df4bc-9dec-4c87-b68a-7e30eb9545be">ACM模式</a></h4>
<div class="outline-text-4" id="text-h:3f5df4bc-9dec-4c87-b68a-7e30eb9545be">
</div>
<div id="outline-container-h:fbb12821-8afa-42c8-90ad-ee6aa211a5ca" class="outline-5">
<h5 id="h:fbb12821-8afa-42c8-90ad-ee6aa211a5ca"><a href="#h:fbb12821-8afa-42c8-90ad-ee6aa211a5ca">1.求奇数的乘积</a></h5>
<div class="outline-text-5" id="text-h:fbb12821-8afa-42c8-90ad-ee6aa211a5ca">
<p>
<a href="https://acm.hdu.edu.cn/showproblem.php?pid=2006">https://acm.hdu.edu.cn/showproblem.php?pid=2006</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-preprocessor">#define</span> <span class="org-variable-name">eleType</span> <span class="org-type">int</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">&#34920;&#31034;&#39034;&#24207;&#34920;&#20013;&#25152;&#26377;&#20803;&#32032;&#37117;&#36825;&#20010;&#31867;&#22411;&#30340;
</span>
<span class="org-keyword">struct</span> <span class="org-type">SequentialList</span> {
    <span class="org-type">eleType</span>* <span class="org-variable-name">elements</span>;
    <span class="org-type">int</span> <span class="org-variable-name">size</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">&#20803;&#32032;&#20010;&#25968;
</span>    <span class="org-type">int</span> <span class="org-variable-name">capacity</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23481;&#37327;
</span>};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#39034;&#24207;&#34920;&#21021;&#22987;&#21270;
</span><span class="org-type">void</span> <span class="org-function-name">initializeList</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>, <span class="org-type">int</span> <span class="org-variable-name">capacity</span>) {
    list-&gt;elements = <span class="org-keyword">new</span> <span class="org-type">eleType</span>[capacity];
    list-&gt;size = 0;
    list-&gt;capacity = capacity;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#39034;&#24207;&#34920;&#30340;&#38144;&#27585;
</span><span class="org-type">void</span> <span class="org-function-name">destroyList</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>) {
    <span class="org-keyword">delete</span>[] list-&gt;elements;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#33719;&#21462;&#39034;&#24207;&#34920;&#22823;&#23567;&#25509;&#21475;
</span><span class="org-type">int</span> <span class="org-function-name">size</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>) {
    <span class="org-keyword">return</span> list-&gt;size;
}

<span class="org-type">bool</span> <span class="org-function-name">isEmpty</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>) {
    <span class="org-keyword">return</span> list-&gt;size == 0;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#39034;&#24207;&#34920;&#30340;&#25554;&#20837;&#25805;&#20316;
</span><span class="org-type">void</span> <span class="org-function-name">insert</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>, <span class="org-type">int</span> <span class="org-variable-name">index</span>, <span class="org-type">eleType</span> <span class="org-variable-name">element</span>) {
    <span class="org-keyword">if</span> (<span class="org-type">index</span> &lt; 0 || index &gt; <span class="org-variable-name">list</span>-&gt;size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::invalid_argument(<span class="org-string">"Invalid index"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25243;&#24322;&#24120;
</span>    }
    <span class="org-keyword">if</span> (list-&gt;capacity == list-&gt;size) {
        <span class="org-type">int</span> <span class="org-variable-name">newCapacity</span> = list-&gt;capacity * 2;
        <span class="org-type">eleType</span>* <span class="org-variable-name">newElements</span> = <span class="org-keyword">new</span> <span class="org-type">eleType</span>[newCapacity];
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; newCapacity/2; ++i) {
            newElements[i] = list-&gt;elements[i];
        }
        <span class="org-keyword">delete</span>[] list-&gt;elements;
        list-&gt;elements = newElements;
        list-&gt;capacity = newCapacity;
    }
    list-&gt;size++;
    <span class="org-keyword">if</span> (list-&gt;size &lt;= list-&gt;capacity) {
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = list-&gt;size -1; i &gt; index; --i) {
            list-&gt;elements[i] = list-&gt;elements[i - 1];
        }
        list-&gt;elements[index] = element;
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#39034;&#24207;&#34920;&#30340;&#20803;&#32032;&#21024;&#38500;
</span><span class="org-type">void</span> <span class="org-function-name">deleteElement</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>, <span class="org-type">int</span> <span class="org-variable-name">index</span>) {
    <span class="org-keyword">if</span> (index &lt; 0 || index &gt;= list-&gt;size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::invalid_argument(<span class="org-string">"Invalid index"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25243;&#24322;&#24120;
</span>    }
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = index; i &lt; list-&gt;size; ++i) {
        list-&gt;elements[i] = list-&gt;elements[i + 1];
    }
    list-&gt;size--;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#39034;&#24207;&#34920;&#20803;&#32032;&#26597;&#25214;
</span><span class="org-type">int</span> <span class="org-function-name">findElement</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>, <span class="org-type">eleType</span> <span class="org-variable-name">element</span>) {
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; list-&gt;size; ++i) {
        <span class="org-keyword">if</span> (list-&gt;elements[i] == element) {
            <span class="org-keyword">return</span> i;
        }
    }
    <span class="org-keyword">return</span> -1;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#39034;&#24207;&#34920;&#20803;&#32032;&#32034;&#24341;
</span><span class="org-type">eleType</span> <span class="org-function-name">getElement</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>, <span class="org-type">int</span> <span class="org-variable-name">index</span>) {
    <span class="org-keyword">if</span> (<span class="org-type">index</span> &lt; 0 || index &gt; <span class="org-variable-name">list</span>-&gt;size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::invalid_argument(<span class="org-string">"Invalid index"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25243;&#24322;&#24120;
</span>    }
    <span class="org-keyword">return</span> list-&gt;elements[index];
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#39034;&#24207;&#34920;&#20803;&#32032;&#20462;&#25913;
</span><span class="org-type">void</span> <span class="org-function-name">updateElement</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>, <span class="org-type">int</span> <span class="org-variable-name">index</span>, <span class="org-type">eleType</span> <span class="org-variable-name">value</span>) {
    <span class="org-keyword">if</span> (<span class="org-type">index</span> &lt; 0 || index &gt; <span class="org-variable-name">list</span>-&gt;size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::invalid_argument(<span class="org-string">"Invalid index"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25243;&#24322;&#24120;
</span>    }
    list-&gt;elements[index] = value;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">n</span>;
    <span class="org-keyword">while</span> (cin &gt;&gt; n) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#36755;&#20837;&#19968;&#20010;&#25968;n&#65292;&#34920;&#31034;&#20849;&#26377;n&#20010;&#25968;
</span>        <span class="org-type">SequentialList</span> <span class="org-variable-name">s</span>;
        initializeList(&amp;s, 1);
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; ++i) {<span class="org-comment-delimiter">// </span><span class="org-comment">&#36941;&#21382;&#36825;n&#20010;&#25968;
</span>            <span class="org-type">eleType</span> <span class="org-variable-name">x</span>;
            cin &gt;&gt; x; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#19968;&#20010;x&#65292;&#24182;&#25554;&#20837;&#21040;&#39034;&#24207;&#34920;&#20013;
</span>            insert(&amp;s, i, x);
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">s.size == n &#25554;&#20837;&#20043;&#21518;&#36825;&#26159;&#30456;&#31561;&#30340;
</span>        <span class="org-type">int</span> <span class="org-variable-name">prod</span> = 1;
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; s.size; ++i) {
            <span class="org-type">int</span> <span class="org-variable-name">val</span> = getElement(&amp;s, i);
            <span class="org-keyword">if</span> (val % 2 == 1) {
                prod = prod * val;
            }
        }
        cout &lt;&lt; prod &lt;&lt; endl;
    }

    <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<p>
直接用数组
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">int</span> <span class="org-variable-name">a</span>[100000];

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">n</span>;
    <span class="org-keyword">while</span> (cin &gt;&gt; n) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#36755;&#20837;&#19968;&#20010;&#25968;n&#65292;&#34920;&#31034;&#20849;&#26377;n&#20010;&#25968;
</span>        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; ++i) {<span class="org-comment-delimiter">// </span><span class="org-comment">&#36941;&#21382;&#36825;n&#20010;&#25968;
</span>            <span class="org-type">int</span> <span class="org-variable-name">x</span>;
            cin &gt;&gt; x; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#19968;&#20010;x&#65292;&#24182;&#25554;&#20837;&#21040;&#39034;&#24207;&#34920;&#20013;
</span>            a[i] = x;
        }
        <span class="org-type">int</span> <span class="org-variable-name">prod</span> = 1;
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; ++i) {
            <span class="org-type">int</span> <span class="org-variable-name">val</span> = a[i];
            <span class="org-keyword">if</span> (val % 2 == 1) {
                prod = prod * val;
            }
        }
        cout &lt;&lt; prod &lt;&lt; endl;
    }

    <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<p>
明明可以这么短的代码写出来，为什么需要抽象出这么多奇奇怪怪的增删改查的函数呢？原因就是这段代码只能过这道题目，而当你把那些函数抽象成模板以后，就可以过任意的题目了。
</p>

<p>
所以说任何一个数据结构，我们都可以抽象出一套公用的代码，而那套代码在C++中已经帮你实现好了，也就是vector。但在比赛时，怎么快怎么来。
</p>

<p>
上面写模板的意义在于，顺序表、链表比较简单，但是假设要你写一个字典数、树状数组、线段数呢？如果没有这个模板思维的话，正式比赛时，那些复杂代码很容易写错。所以在比赛之前，我们要把那些代码抽象成公共的函数或者类以后做模板，比赛的时候打印出来可以带进去，这样你就不用担心比赛时某个细节给忘记了。
</p>
</div>
</div>
<div id="outline-container-h:403b978f-b5a9-4f2a-b519-b1faeca28da2" class="outline-5">
<h5 id="h:403b978f-b5a9-4f2a-b519-b1faeca28da2"><a href="#h:403b978f-b5a9-4f2a-b519-b1faeca28da2">2.数值统计</a></h5>
<div class="outline-text-5" id="text-h:403b978f-b5a9-4f2a-b519-b1faeca28da2">
<p>
<a href="https://acm.hdu.edu.cn/showproblem.php?pid=2008">https://acm.hdu.edu.cn/showproblem.php?pid=2008</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-preprocessor">#define</span> <span class="org-variable-name">eleType</span> <span class="org-type">double</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">&#34920;&#31034;&#39034;&#24207;&#34920;&#20013;&#25152;&#26377;&#20803;&#32032;&#37117;&#36825;&#20010;&#31867;&#22411;&#30340;
</span>
<span class="org-keyword">struct</span> <span class="org-type">SequentialList</span> {
    <span class="org-type">eleType</span>* <span class="org-variable-name">elements</span>;
    <span class="org-type">int</span> <span class="org-variable-name">size</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">&#20803;&#32032;&#20010;&#25968;
</span>    <span class="org-type">int</span> <span class="org-variable-name">capacity</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23481;&#37327;
</span>};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#39034;&#24207;&#34920;&#21021;&#22987;&#21270;
</span><span class="org-type">void</span> <span class="org-function-name">initializeList</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>, <span class="org-type">int</span> <span class="org-variable-name">capacity</span>) {
    list-&gt;elements = <span class="org-keyword">new</span> <span class="org-type">eleType</span>[capacity];
    list-&gt;size = 0;
    list-&gt;capacity = capacity;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#39034;&#24207;&#34920;&#30340;&#38144;&#27585;
</span><span class="org-type">void</span> <span class="org-function-name">destroyList</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>) {
    <span class="org-keyword">delete</span>[] list-&gt;elements;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#33719;&#21462;&#39034;&#24207;&#34920;&#22823;&#23567;&#25509;&#21475;
</span><span class="org-type">int</span> <span class="org-function-name">size</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>) {
    <span class="org-keyword">return</span> list-&gt;size;
}

<span class="org-type">bool</span> <span class="org-function-name">isEmpty</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>) {
    <span class="org-keyword">return</span> list-&gt;size == 0;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#39034;&#24207;&#34920;&#30340;&#25554;&#20837;&#25805;&#20316;
</span><span class="org-type">void</span> <span class="org-function-name">insert</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>, <span class="org-type">int</span> <span class="org-variable-name">index</span>, <span class="org-type">eleType</span> <span class="org-variable-name">element</span>) {
    <span class="org-keyword">if</span> (<span class="org-type">index</span> &lt; 0 || index &gt; <span class="org-variable-name">list</span>-&gt;size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::invalid_argument(<span class="org-string">"Invalid index"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25243;&#24322;&#24120;
</span>    }
    <span class="org-keyword">if</span> (list-&gt;capacity == list-&gt;size) {
        <span class="org-type">int</span> <span class="org-variable-name">newCapacity</span> = list-&gt;capacity * 2;
        <span class="org-type">eleType</span>* <span class="org-variable-name">newElements</span> = <span class="org-keyword">new</span> <span class="org-type">eleType</span>[newCapacity];
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; newCapacity / 2; ++i) {
            newElements[i] = list-&gt;elements[i];
        }
        <span class="org-keyword">delete</span>[] list-&gt;elements;
        list-&gt;elements = newElements;
        list-&gt;capacity = newCapacity;
    }
    list-&gt;size++;
    <span class="org-keyword">if</span> (list-&gt;size &lt;= list-&gt;capacity) {
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = list-&gt;size - 1; i &gt; index; --i) {
            list-&gt;elements[i] = list-&gt;elements[i - 1];
        }
        list-&gt;elements[index] = element;
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#39034;&#24207;&#34920;&#30340;&#20803;&#32032;&#21024;&#38500;
</span><span class="org-type">void</span> <span class="org-function-name">deleteElement</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>, <span class="org-type">int</span> <span class="org-variable-name">index</span>) {
    <span class="org-keyword">if</span> (index &lt; 0 || index &gt;= list-&gt;size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::invalid_argument(<span class="org-string">"Invalid index"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25243;&#24322;&#24120;
</span>    }
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = index; i &lt; list-&gt;size; ++i) {
        list-&gt;elements[i] = list-&gt;elements[i + 1];
    }
    list-&gt;size--;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#39034;&#24207;&#34920;&#20803;&#32032;&#26597;&#25214;
</span><span class="org-type">int</span> <span class="org-function-name">findElement</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>, <span class="org-type">eleType</span> <span class="org-variable-name">element</span>) {
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; list-&gt;size; ++i) {
        <span class="org-keyword">if</span> (list-&gt;elements[i] == element) {
            <span class="org-keyword">return</span> i;
        }
    }
    <span class="org-keyword">return</span> -1;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#39034;&#24207;&#34920;&#20803;&#32032;&#32034;&#24341;
</span><span class="org-type">eleType</span> <span class="org-function-name">getElement</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>, <span class="org-type">int</span> <span class="org-variable-name">index</span>) {
    <span class="org-keyword">if</span> (<span class="org-type">index</span> &lt; 0 || index &gt; <span class="org-variable-name">list</span>-&gt;size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::invalid_argument(<span class="org-string">"Invalid index"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25243;&#24322;&#24120;
</span>    }
    <span class="org-keyword">return</span> list-&gt;elements[index];
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#39034;&#24207;&#34920;&#20803;&#32032;&#20462;&#25913;
</span><span class="org-type">void</span> <span class="org-function-name">updateElement</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>, <span class="org-type">int</span> <span class="org-variable-name">index</span>, <span class="org-type">eleType</span> <span class="org-variable-name">value</span>) {
    <span class="org-keyword">if</span> (<span class="org-type">index</span> &lt; 0 || index &gt; <span class="org-variable-name">list</span>-&gt;size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::invalid_argument(<span class="org-string">"Invalid index"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25243;&#24322;&#24120;
</span>    }
    list-&gt;elements[index] = value;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">n</span>;
    <span class="org-keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#36755;&#20837;&#19968;&#20010;n&#65292;&#24182;&#19988;&#36755;&#20837;n&#31561;&#20110;0&#26102;&#36339;&#20986;&#24490;&#29615;
</span>        <span class="org-type">SequentialList</span> <span class="org-variable-name">s</span>;
        initializeList(&amp;s, 1);
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; ++i) {
            <span class="org-type">eleType</span> <span class="org-variable-name">x</span>;
            cin &gt;&gt; x;
            insert(&amp;s, i, x);
        }
        <span class="org-type">int</span> <span class="org-variable-name">pcnt</span> = 0, <span class="org-variable-name">zcnt</span> = 0, <span class="org-variable-name">ncnt</span> = 0; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22823;&#20110;0 pcnt&#12289;&#31561;&#20110;0 zcnt&#12289;&#23567;&#20110;0 ncnt
</span>        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; size(&amp;s); ++i) {
            <span class="org-type">eleType</span> <span class="org-variable-name">ele</span> = getElement(&amp;s, i);
            <span class="org-keyword">if</span> (ele &gt; 1e-8) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#28014;&#28857;&#25968;&#26159;&#26377;&#35823;&#24046;&#30340;&#65292;&#25152;&#20197;&#25105;&#20204;&#19981;&#33021;&#22823;&#20110;0&#65292;&#22823;&#20110;&#19968;&#20010;&#38750;&#24120;&#23567;&#30340;&#27491;&#25968;&#25105;&#23601;&#31639;&#23427;&#22823;&#20110;0
</span>                ++pcnt;
            }
            <span class="org-keyword">else</span> <span class="org-keyword">if</span> (ele &lt; -1e-8) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#23567;&#20110;&#38750;&#24120;&#22823;&#30340;&#36127;&#25968;&#65292;&#23601;&#25226;&#23427;&#23450;&#20041;&#20026;&#23567;&#20110;0
</span>                ++ncnt;
            }
            <span class="org-keyword">else</span> {
                ++zcnt;
            }
        }
        cout &lt;&lt; ncnt &lt;&lt; <span class="org-string">' '</span> &lt;&lt; zcnt &lt;&lt; <span class="org-string">' '</span> &lt;&lt; pcnt &lt;&lt; endl;
    }

    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-h:9f438411-8b2f-41a3-897c-6ac09dfc5216" class="outline-5">
<h5 id="h:9f438411-8b2f-41a3-897c-6ac09dfc5216"><a href="#h:9f438411-8b2f-41a3-897c-6ac09dfc5216">3.青年歌手大奖赛</a></h5>
<div class="outline-text-5" id="text-h:9f438411-8b2f-41a3-897c-6ac09dfc5216">
<p>
<a href="https://acm.hdu.edu.cn/showproblem.php?pid=2014">https://acm.hdu.edu.cn/showproblem.php?pid=2014</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-preprocessor">#define</span> <span class="org-variable-name">eleType</span> <span class="org-type">double</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">&#34920;&#31034;&#39034;&#24207;&#34920;&#20013;&#25152;&#26377;&#20803;&#32032;&#37117;&#36825;&#20010;&#31867;&#22411;&#30340;
</span>
<span class="org-keyword">struct</span> <span class="org-type">SequentialList</span> {
    <span class="org-type">eleType</span>* <span class="org-variable-name">elements</span>;
    <span class="org-type">int</span> <span class="org-variable-name">size</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">&#20803;&#32032;&#20010;&#25968;
</span>    <span class="org-type">int</span> <span class="org-variable-name">capacity</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23481;&#37327;
</span>};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#39034;&#24207;&#34920;&#21021;&#22987;&#21270;
</span><span class="org-type">void</span> <span class="org-function-name">initializeList</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>, <span class="org-type">int</span> <span class="org-variable-name">capacity</span>) {
    list-&gt;elements = <span class="org-keyword">new</span> <span class="org-type">eleType</span>[capacity];
    list-&gt;size = 0;
    list-&gt;capacity = capacity;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#39034;&#24207;&#34920;&#30340;&#38144;&#27585;
</span><span class="org-type">void</span> <span class="org-function-name">destroyList</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>) {
    <span class="org-keyword">delete</span>[] list-&gt;elements;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#33719;&#21462;&#39034;&#24207;&#34920;&#22823;&#23567;&#25509;&#21475;
</span><span class="org-type">int</span> <span class="org-function-name">size</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>) {
    <span class="org-keyword">return</span> list-&gt;size;
}

<span class="org-type">bool</span> <span class="org-function-name">isEmpty</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>) {
    <span class="org-keyword">return</span> list-&gt;size == 0;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#39034;&#24207;&#34920;&#30340;&#25554;&#20837;&#25805;&#20316;
</span><span class="org-type">void</span> <span class="org-function-name">insert</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>, <span class="org-type">int</span> <span class="org-variable-name">index</span>, <span class="org-type">eleType</span> <span class="org-variable-name">element</span>) {
    <span class="org-keyword">if</span> (<span class="org-type">index</span> &lt; 0 || index &gt; <span class="org-variable-name">list</span>-&gt;size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::invalid_argument(<span class="org-string">"Invalid index"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25243;&#24322;&#24120;
</span>    }
    <span class="org-keyword">if</span> (list-&gt;capacity == list-&gt;size) {
        <span class="org-type">int</span> <span class="org-variable-name">newCapacity</span> = list-&gt;capacity * 2;
        <span class="org-type">eleType</span>* <span class="org-variable-name">newElements</span> = <span class="org-keyword">new</span> <span class="org-type">eleType</span>[newCapacity];
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; newCapacity / 2; ++i) {
            newElements[i] = list-&gt;elements[i];
        }
        <span class="org-keyword">delete</span>[] list-&gt;elements;
        list-&gt;elements = newElements;
        list-&gt;capacity = newCapacity;
    }
    list-&gt;size++;
    <span class="org-keyword">if</span> (list-&gt;size &lt;= list-&gt;capacity) {
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = list-&gt;size - 1; i &gt; index; --i) {
            list-&gt;elements[i] = list-&gt;elements[i - 1];
        }
        list-&gt;elements[index] = element;
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#39034;&#24207;&#34920;&#30340;&#20803;&#32032;&#21024;&#38500;
</span><span class="org-type">void</span> <span class="org-function-name">deleteElement</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>, <span class="org-type">int</span> <span class="org-variable-name">index</span>) {
    <span class="org-keyword">if</span> (index &lt; 0 || index &gt;= list-&gt;size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::invalid_argument(<span class="org-string">"Invalid index"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25243;&#24322;&#24120;
</span>    }
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = index; i &lt; list-&gt;size; ++i) {
        list-&gt;elements[i] = list-&gt;elements[i + 1];
    }
    list-&gt;size--;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#39034;&#24207;&#34920;&#20803;&#32032;&#26597;&#25214;
</span><span class="org-type">int</span> <span class="org-function-name">findElement</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>, <span class="org-type">eleType</span> <span class="org-variable-name">element</span>) {
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; list-&gt;size; ++i) {
        <span class="org-keyword">if</span> (list-&gt;elements[i] == element) {
            <span class="org-keyword">return</span> i;
        }
    }
    <span class="org-keyword">return</span> -1;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#39034;&#24207;&#34920;&#20803;&#32032;&#32034;&#24341;
</span><span class="org-type">eleType</span> <span class="org-function-name">getElement</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>, <span class="org-type">int</span> <span class="org-variable-name">index</span>) {
    <span class="org-keyword">if</span> (<span class="org-type">index</span> &lt; 0 || index &gt; <span class="org-variable-name">list</span>-&gt;size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::invalid_argument(<span class="org-string">"Invalid index"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25243;&#24322;&#24120;
</span>    }
    <span class="org-keyword">return</span> list-&gt;elements[index];
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#39034;&#24207;&#34920;&#20803;&#32032;&#20462;&#25913;
</span><span class="org-type">void</span> <span class="org-function-name">updateElement</span>(<span class="org-type">SequentialList</span>* <span class="org-variable-name">list</span>, <span class="org-type">int</span> <span class="org-variable-name">index</span>, <span class="org-type">eleType</span> <span class="org-variable-name">value</span>) {
    <span class="org-keyword">if</span> (<span class="org-type">index</span> &lt; 0 || index &gt; <span class="org-variable-name">list</span>-&gt;size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::invalid_argument(<span class="org-string">"Invalid index"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25243;&#24322;&#24120;
</span>    }
    list-&gt;elements[index] = value;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">n</span>;
    <span class="org-keyword">while</span> (cin &gt;&gt; n) {
        <span class="org-type">SequentialList</span> <span class="org-variable-name">s</span>;
        initializeList(&amp;s, 1);
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; ++i) {
            <span class="org-type">eleType</span> <span class="org-variable-name">ele</span>;
            cin &gt;&gt; ele;
            insert(&amp;s, i, ele);
        }
        <span class="org-type">eleType</span> <span class="org-variable-name">eMax</span> = -1000000000, <span class="org-variable-name">eMin</span> = 10000000000;
        <span class="org-type">eleType</span> <span class="org-variable-name">eSum</span> = 0; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#19968;&#20010;&#27714;&#21644;&#21464;&#37327;
</span>        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; size(&amp;s); ++i) {
            <span class="org-type">eleType</span> <span class="org-variable-name">ele</span> = getElement(&amp;s,i);
            <span class="org-keyword">if</span> (ele &gt; eMax) eMax = ele;
            <span class="org-keyword">if</span> (ele &lt; eMin) eMin = ele;
            eSum += ele;
        }
        eSum -= eMax;
        eSum -= eMin;
        eSum /= (n - 2);
        printf(<span class="org-string">"%.2lf\n"</span>, eSum);
    }

    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:ce6b006f-a28f-4fce-a4d3-d43318b01162" class="outline-4">
<h4 id="h:ce6b006f-a28f-4fce-a4d3-d43318b01162"><a href="#h:ce6b006f-a28f-4fce-a4d3-d43318b01162">核心代码模式</a></h4>
<div class="outline-text-4" id="text-h:ce6b006f-a28f-4fce-a4d3-d43318b01162">
</div>
<div id="outline-container-h:cd8ad3c7-8797-47f4-a00c-37c8a95ded0e" class="outline-5">
<h5 id="h:cd8ad3c7-8797-47f4-a00c-37c8a95ded0e"><a href="#h:cd8ad3c7-8797-47f4-a00c-37c8a95ded0e">顺序表的索引</a></h5>
<div class="outline-text-5" id="text-h:cd8ad3c7-8797-47f4-a00c-37c8a95ded0e">
<p>
下标获取[]
</p>
</div>
<ul class="org-ul">
<li><a id="h:e400f82b-55d7-4609-a645-174c8150ade1"></a><a href="#h:e400f82b-55d7-4609-a645-174c8150ade1">4.猜数字</a><br>
<div class="outline-text-6" id="text-h:e400f82b-55d7-4609-a645-174c8150ade1">
<p>
<a href="https://leetcode.cn/problems/guess-numbers/description/">https://leetcode.cn/problems/guess-numbers/description/</a>
</p>

<p>
输入数据是两个顺序表，并且长度已经确定都是3，所以只需同步遍历顺序表的这个三个元素，并且判断是否相等。如果相等则计数器加1，最后输出这个计数器就可以了。
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;vector&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">game</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">guess</span>, <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">answer</span>) {
        <span class="org-type">int</span> <span class="org-variable-name">ret</span> = 0; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#19968;&#20010;&#35745;&#25968;&#22120;
</span>        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 3; ++i) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#36941;&#21382;&#39034;&#24207;&#34920;&#30340;&#19977;&#20010;&#20803;&#32032;
</span>            <span class="org-keyword">if</span> (guess[i] == answer[i]) {
                ret++;
            }
        }
        <span class="org-keyword">return</span> ret;
    }
};

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">Solution</span> <span class="org-variable-name">s</span>;
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">guess</span>(3);
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">answer</span>(3);
    <span class="org-comment-delimiter">// </span><span class="org-comment">std::cin&#19981;&#25903;&#25345;&#30452;&#25509;&#35835;&#21462;&#25972;&#20010;vector&#12290;&#25105;&#20204;&#38656;&#35201;&#36880;&#20010;&#20803;&#32032;&#35835;&#21462;
</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">&#35835;&#21462;&#23567;A&#30340;&#29468;&#27979;
</span>    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 3; i++) {
        cin &gt;&gt; guess[i];
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#35835;&#21462;&#23567;B&#30340;&#36873;&#25321;
</span>    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 3; i++) {
        cin &gt;&gt; answer[i];
    }
    <span class="org-type">int</span> <span class="org-variable-name">ret</span>;
    ret = s.game(guess, answer);
    <span class="org-constant">std</span>::cout &lt;&lt; ret &lt;&lt; endl;
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</li>
<li><a id="h:e9083aa6-8517-45eb-b5ed-11739f76ca85"></a><a href="#h:e9083aa6-8517-45eb-b5ed-11739f76ca85">5.拿硬币</a><br>
<div class="outline-text-6" id="text-h:e9083aa6-8517-45eb-b5ed-11739f76ca85">
<p>
<a href="https://leetcode.cn/problems/na-ying-bi/description/">https://leetcode.cn/problems/na-ying-bi/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">minCount</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">coins</span>) {
        <span class="org-type">int</span> <span class="org-variable-name">ret</span> = 0;
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; coins.size(); ++i) {
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;coins[i]&#26159;&#20598;&#25968;&#26102;&#65292;&#21152;&#30340;1&#26159;&#26080;&#25928;&#30340;&#65292;&#31561;&#20215;&#20110;&#38500;&#19978;2&#12290;
</span>            <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;coins[i]&#26159;&#22855;&#25968;&#26102;&#65292;&#21152;&#19978;1&#21464;&#25104;&#20598;&#25968;&#65292;&#20877;&#38500;&#19978;2&#23601;&#31561;&#20215;&#20110;&#21069;&#38754;&#20960;&#27425;&#37117;&#26159;&#25343;&#20004;&#26522;&#26368;&#21518;&#19968;&#27425;&#25343;&#19968;&#26522;&#30340;&#27425;&#25968;&#12290;
</span>            ret += (<span class="org-type">coins</span>[i] + 1) / 2; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24471;&#21040;&#30340;&#26159;&#26368;&#23569;&#25343;&#30828;&#24065;&#30340;&#27425;&#25968;
</span>        }
        <span class="org-keyword">return</span> ret;
    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:49dc9d60-2b72-4ca0-8110-0341ef8c38ad"></a><a href="#h:49dc9d60-2b72-4ca0-8110-0341ef8c38ad">6.值相等的最小索引</a><br>
<div class="outline-text-6" id="text-h:49dc9d60-2b72-4ca0-8110-0341ef8c38ad">
<p>
<a href="https://leetcode.cn/problems/smallest-index-with-equal-value/description/">https://leetcode.cn/problems/smallest-index-with-equal-value/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">smallestEqual</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21482;&#38656;&#35201;&#36941;&#21382;&#36825;&#20010;&#39034;&#24207;&#34920;&#65292;&#28982;&#21518;&#23545;&#39034;&#24207;&#34920;&#20013;&#27599;&#20010;&#20803;&#32032;&#36827;&#34892;&#21028;&#26029;
</span>        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; nums.size(); ++i) {
            <span class="org-keyword">if</span> (i % 10 == nums[i]) {
                <span class="org-keyword">return</span> i;
            }
        }
        <span class="org-keyword">return</span> -1;
    }
};
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-h:d6e29109-1023-48e5-8fcb-92ddc82423c7" class="outline-5">
<h5 id="h:d6e29109-1023-48e5-8fcb-92ddc82423c7"><a href="#h:d6e29109-1023-48e5-8fcb-92ddc82423c7">顺序表的大小</a></h5>
<div class="outline-text-5" id="text-h:d6e29109-1023-48e5-8fcb-92ddc82423c7">
<p>
vector.size
</p>
</div>
<ul class="org-ul">
<li><a id="h:f8bab07a-3cc4-4584-b61d-06011ec1c1c6"></a><a href="#h:f8bab07a-3cc4-4584-b61d-06011ec1c1c6">7.最大连续 1 的个数</a><br>
<div class="outline-text-6" id="text-h:f8bab07a-3cc4-4584-b61d-06011ec1c1c6">
<p>
<a href="https://leetcode.cn/problems/max-consecutive-ones/description/">https://leetcode.cn/problems/max-consecutive-ones/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">findMaxConsecutiveOnes</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#25968;&#32452;&#20869;&#20803;&#32032;&#20540;&#20026;0&#25110;1&#65292;&#21487;&#20197;&#20197;&#24403;&#21069;&#20803;&#32032;&#33267;&#32467;&#23614;&#36830;&#32493;1&#30340;&#20010;&#25968;&#26159;&#22810;&#23569;
</span>        <span class="org-type">int</span> <span class="org-variable-name">ret</span> = 0, <span class="org-variable-name">pre</span> = 0; <span class="org-comment-delimiter">// </span><span class="org-comment">ret &#34920;&#31034;&#26368;&#22823;&#36830;&#32493;1&#30340;&#20010;&#25968;&#65292;pre&#34920;&#31034;&#21040;&#24403;&#21069;&#25968;&#32467;&#23614;&#36830;&#32493;1&#30340;&#20010;&#25968;
</span>        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; nums.size(); ++i) {
            <span class="org-keyword">if</span> (nums[i] == 1) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#20197;&#24403;&#21069;&#25968;&#32467;&#23614;&#30340;&#36830;&#32493;1&#30340;&#20010;&#25968;&#23601;&#26159;&#20197;&#21069;&#38754;1&#20010;&#25968;&#32467;&#23614;&#30340;&#36830;&#32493;1&#30340;&#20010;&#25968;&#21152;1
</span>                pre += 1;
                <span class="org-keyword">if</span> (pre &gt; ret) ret = pre;
            }<span class="org-keyword">else</span> {
                pre = 0;
            }
        }
        <span class="org-keyword">return</span> ret;
    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:7c129d93-9c84-4eb8-8d77-b87eb88fe92a"></a><a href="#h:7c129d93-9c84-4eb8-8d77-b87eb88fe92a">8.差的绝对值为 K 的数对数目</a><br>
<div class="outline-text-6" id="text-h:7c129d93-9c84-4eb8-8d77-b87eb88fe92a">
<p>
<a href="https://leetcode.cn/problems/count-number-of-pairs-with-absolute-difference-k/">https://leetcode.cn/problems/count-number-of-pairs-with-absolute-difference-k/</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">countKDifference</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>, <span class="org-type">int</span> <span class="org-variable-name">k</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#27714;&#25968;&#23545;&#26368;&#26292;&#21147;&#30340;&#26041;&#27861;&#33258;&#28982;&#26159;&#20004;&#23618;&#26522;&#20030;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#30475;&#19968;&#19979;&#25968;&#25454;&#33539;&#22260;&#65292;200 &#30340;&#35805;O(n^2) &#30340;&#31639;&#27861;&#26159;&#21487;&#20197;&#25480;&#21463;&#30340;
</span>        <span class="org-type">int</span> <span class="org-variable-name">ret</span> = 0;
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; nums.size(); ++i) {
            <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = i+1; j &lt; nums.size(); ++j) {
                <span class="org-keyword">if</span> (abs(<span class="org-type">nums</span>[i] - nums[j]) == k) {
                    ret++;
                }
            }
        }
        <span class="org-keyword">return</span> ret;
    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:7795fe76-0181-4e20-a141-28c733e1c799"></a><a href="#h:7795fe76-0181-4e20-a141-28c733e1c799">9.数组中两元素的最大乘积</a><br>
<div class="outline-text-6" id="text-h:7795fe76-0181-4e20-a141-28c733e1c799">
<p>
<a href="https://leetcode.cn/problems/maximum-product-of-two-elements-in-an-array/description/">https://leetcode.cn/problems/maximum-product-of-two-elements-in-an-array/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">maxProduct</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#25968;&#32452;&#20803;&#32032;&#37117;&#26159;&#22823;&#20110;0&#30340;&#24773;&#20917;&#19979;&#65292;&#19968;&#23450;&#26159;&#25214;&#21040;&#26368;&#22823;&#30340;&#21644;&#27425;&#22823;&#30340;&#25968;&#65292;&#28982;&#21518;&#20943;1&#30456;&#20056;&#65292;&#24471;&#21040;&#30340;&#32467;&#26524;&#19968;&#23450;&#26159;&#26368;&#22823;&#30340;
</span>        <span class="org-type">int</span> <span class="org-variable-name">maxId</span> = 0; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26368;&#22823;&#25968;&#19979;&#26631;
</span>        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; nums.size(); ++i) {
            <span class="org-keyword">if</span> ( nums[i] &gt; nums[maxId]) {
                maxId = i;
            }
        }
        <span class="org-type">int</span> <span class="org-variable-name">subMaxId</span> = -1; <span class="org-comment-delimiter">// </span><span class="org-comment">&#27425;&#22823;&#25968;&#19979;&#26631;
</span>        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; nums.size(); ++i) {
            <span class="org-keyword">if</span> ( i != maxId ) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#19981;&#26159;&#26368;&#22823;&#25968;&#30340;&#19979;&#26631;&#24182;&#19988;&#26368;&#22823;&#30340;&#35805;&#65292;&#23601;&#26159;&#27425;&#22823;&#25968;&#30340;&#19979;&#26631;
</span>                <span class="org-keyword">if</span> ( subMaxId == -1 || nums[i] &gt; nums[subMaxId]) {
                    subMaxId = i;
                }
            }
        }
        <span class="org-keyword">return</span> (<span class="org-type">nums</span>[maxId]-1) * (<span class="org-type">nums</span>[subMaxId] -1);
    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:33e333d9-63df-490d-ba19-33e433c91d2a"></a><a href="#h:33e333d9-63df-490d-ba19-33e433c91d2a">10.数组元素和与数字和的绝对差</a><br>
<div class="outline-text-6" id="text-h:33e333d9-63df-490d-ba19-33e433c91d2a">
<p>
<a href="https://leetcode.cn/problems/difference-between-element-sum-and-digit-sum-of-an-array/description/">https://leetcode.cn/problems/difference-between-element-sum-and-digit-sum-of-an-array/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">differenceOfSum</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>) {
        <span class="org-type">int</span> <span class="org-variable-name">x</span> = 0, <span class="org-variable-name">y</span> = 0;
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; nums.size(); ++i) {
            x += nums[i]; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20803;&#32032;&#32047;&#21152;&#21040;x&#19978;
</span>            <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;&#27599;&#20010;&#20803;&#32032;&#30340;&#27599;&#19968;&#20010;&#21313;&#36827;&#21046;&#20301;&#21093;&#31163;&#20986;&#26469;&#65292;&#32047;&#21152;&#21040;y&#19978;
</span>            <span class="org-keyword">while</span> (nums[i]) {
                y += nums[i] % 10;
                nums[i] /= 10;
            }
        }
        <span class="org-keyword">return</span> abs(x - y);
    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:e4d63f3f-de24-4cd1-a871-26f94df271e0"></a><a href="#h:e4d63f3f-de24-4cd1-a871-26f94df271e0">11.K 个元素的最大和</a><br>
<div class="outline-text-6" id="text-h:e4d63f3f-de24-4cd1-a871-26f94df271e0">
<p>
<a href="https://leetcode.cn/problems/maximum-sum-with-exactly-k-elements/description/">https://leetcode.cn/problems/maximum-sum-with-exactly-k-elements/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">maximizeSum</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>, <span class="org-type">int</span> <span class="org-variable-name">k</span>) {
        <span class="org-type">int</span> <span class="org-variable-name">ret</span> = 0;
        <span class="org-keyword">while</span> (k--) {
            <span class="org-type">int</span> <span class="org-variable-name">maxId</span> = 0;
            <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; nums.size(); ++i) {
                <span class="org-keyword">if</span> (nums[i] &gt; nums[maxId]) {
                    maxId = i;
                }
            }
            ret += nums[maxId];
            nums[maxId] += 1;
        }
        <span class="org-keyword">return</span> ret;
    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:db47fe9b-c9d6-4db6-8353-3c2c37fe1064"></a><a href="#h:db47fe9b-c9d6-4db6-8353-3c2c37fe1064">12.算术三元组的数目</a><br>
<div class="outline-text-6" id="text-h:db47fe9b-c9d6-4db6-8353-3c2c37fe1064">
<p>
<a href="https://leetcode.cn/problems/number-of-arithmetic-triplets/description/">https://leetcode.cn/problems/number-of-arithmetic-triplets/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">arithmeticTriplets</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>, <span class="org-type">int</span> <span class="org-variable-name">diff</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#25968;&#25454;&#30340;&#33539;&#22260;&#65306;&#22312;200&#30340;&#37327;&#32423;&#65292;&#25152;&#20197;O(n^3)&#30340;&#26102;&#38388;&#22797;&#26434;&#24230;&#26159;&#21487;&#20197;&#36890;&#36807;&#30340;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#20808;&#26522;&#20030;&#20013;&#38388;&#30340;&#32034;&#24341;j&#65292;&#28982;&#21518;&#26522;&#20030; i
</span>        <span class="org-type">int</span> <span class="org-variable-name">ret</span> = 0;
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; nums.size(); ++j) {
            <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; j; ++i) {
                <span class="org-keyword">if</span> (nums[j] - nums[i] == diff) {
                    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">k</span> = j + 1; k &lt; nums.size(); ++k) {
                        <span class="org-keyword">if</span> (nums[k] - nums[j] == diff) {
                            ret++;
                        }
                    }
                }
            }
        }
        <span class="org-keyword">return</span> ret; 
    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:56be9ffc-617c-4d5b-b4a1-4d5fe3c14e57"></a><a href="#h:56be9ffc-617c-4d5b-b4a1-4d5fe3c14e57">13.移除元素</a><br>
<div class="outline-text-6" id="text-h:56be9ffc-617c-4d5b-b4a1-4d5fe3c14e57">
<p>
<a href="https://leetcode.cn/problems/remove-element/description/">https://leetcode.cn/problems/remove-element/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#25968;&#32452; nums &#21644;&#19968;&#20010;&#20540; val&#65292;&#20320;&#38656;&#35201; &#21407;&#22320; &#31227;&#38500;&#25152;&#26377;&#25968;&#20540;&#31561;&#20110; val &#30340;&#20803;&#32032;&#65292;&#24182;&#36820;&#22238;&#31227;&#38500;&#21518;&#25968;&#32452;&#30340;&#38271;&#24230;&#12290;

&#19981;&#35201;&#20351;&#29992;&#39069;&#22806;&#30340;&#25968;&#32452;&#31354;&#38388;&#65292;&#20320;&#24517;&#39035;&#20165;&#20351;&#29992;O(1)&#39069;&#22806;&#31354;&#38388;&#24182; &#21407;&#22320; &#20462;&#25913;&#36755;&#20837;&#25968;&#32452;&#12290;

&#20803;&#32032;&#30340;&#39034;&#24207;&#21487;&#20197;&#25913;&#21464;&#12290;&#20320;&#19981;&#38656;&#35201;&#32771;&#34385;&#25968;&#32452;&#20013;&#36229;&#20986;&#26032;&#38271;&#24230;&#21518;&#38754;&#30340;&#20803;&#32032;&#12290;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">removeElement</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>, <span class="org-type">int</span> <span class="org-variable-name">val</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21452;&#25351;&#38024;
</span>        <span class="org-type">int</span> <span class="org-variable-name">l</span> = 0, <span class="org-variable-name">r</span> = nums.size() - 1;
        <span class="org-keyword">while</span> (l &lt; r) {
            <span class="org-keyword">if</span> (nums[l] == val) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#30456;&#31561;&#20195;&#34920;nums[l] &#26159;&#35201;&#34987;&#21024;&#38500;&#30340;
</span>                <span class="org-type">int</span> <span class="org-variable-name">tmp</span> = nums[l];
                nums[l] = nums[r];
                nums[r] = tmp;
                r--;
            } <span class="org-keyword">else</span> {
                l++;
            }
        }
        <span class="org-keyword">return</span> r + 1;
    }
};
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-h:d0c2de0a-378a-4c06-8e27-7ec8b33e59c0" class="outline-5">
<h5 id="h:d0c2de0a-378a-4c06-8e27-7ec8b33e59c0"><a href="#h:d0c2de0a-378a-4c06-8e27-7ec8b33e59c0">顺序表的插入</a></h5>
<div class="outline-text-5" id="text-h:d0c2de0a-378a-4c06-8e27-7ec8b33e59c0">
<p>
vector.push_back
</p>
</div>
<ul class="org-ul">
<li><a id="h:d316631a-4fc4-4cdd-ad99-b03a8afd1a46"></a><a href="#h:d316631a-4fc4-4cdd-ad99-b03a8afd1a46">14.基于排列构建数组</a><br>
<div class="outline-text-6" id="text-h:d316631a-4fc4-4cdd-ad99-b03a8afd1a46">
<p>
<a href="https://leetcode.cn/problems/build-array-from-permutation/description/">https://leetcode.cn/problems/build-array-from-permutation/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010; &#20174; 0 &#24320;&#22987;&#30340;&#25490;&#21015; nums&#65288;&#19979;&#26631;&#20063;&#20174; 0 &#24320;&#22987;&#65289;&#12290;&#35831;&#20320;&#26500;&#24314;&#19968;&#20010; &#21516;&#26679;&#38271;&#24230; &#30340;&#25968;&#32452; ans &#65292;&#20854;&#20013;&#65292;&#23545;&#20110;&#27599;&#20010; i&#65288;0 &lt;= i &lt; nums.length&#65289;&#65292;&#37117;&#28385;&#36275; ans[i] = nums[nums[i]] &#12290;&#36820;&#22238;&#26500;&#24314;&#22909;&#30340;&#25968;&#32452; ans &#12290;

&#20174; 0 &#24320;&#22987;&#30340;&#25490;&#21015; nums &#26159;&#19968;&#20010;&#30001; 0 &#21040; nums.length - 1&#65288;0 &#21644; nums.length - 1 &#20063;&#21253;&#21547;&#22312;&#20869;&#65289;&#30340;&#19981;&#21516;&#25972;&#25968;&#32452;&#25104;&#30340;&#25968;&#32452;&#12290;

 

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;nums = [0,2,1,5,3,4]
&#36755;&#20986;&#65306;[0,1,2,4,5,3]
&#35299;&#37322;&#65306;&#25968;&#32452; ans &#26500;&#24314;&#22914;&#19979;&#65306;
ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]
    = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]]
    = [0,1,2,4,5,3]

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;nums = [5,0,1,2,3,4]
&#36755;&#20986;&#65306;[4,5,0,1,2,3]
&#35299;&#37322;&#65306;&#25968;&#32452; ans &#26500;&#24314;&#22914;&#19979;&#65306;
ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]
    = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]]
    = [4,5,0,1,2,3]
 

&#25552;&#31034;&#65306;
1 &lt;= nums.length &lt;= 1000
0 &lt;= nums[i] &lt; nums.length
nums &#20013;&#30340;&#20803;&#32032; &#20114;&#19981;&#30456;&#21516;
 

&#36827;&#38454;&#65306;&#20320;&#33021;&#22312;&#19981;&#20351;&#29992;&#39069;&#22806;&#31354;&#38388;&#30340;&#24773;&#20917;&#19979;&#35299;&#20915;&#27492;&#38382;&#39064;&#21527;&#65288;&#21363; O(1) &#20869;&#23384;&#65289;&#65311;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-function-name">buildArray</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#32771;&#26597;vector&#30340;&#25554;&#20837;&#25805;&#20316;
</span>        <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">ret</span>;
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; nums.size(); ++i) {
            <span class="org-type">int</span> <span class="org-variable-name">ans</span> = nums[nums[i]];
            ret.push_back( ans );
        }
        <span class="org-keyword">return</span> ret;
    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:ae91aaaa-c9c1-4db4-88e3-0dd5d84862a2"></a><a href="#h:ae91aaaa-c9c1-4db4-88e3-0dd5d84862a2">15.数组串联</a><br>
<div class="outline-text-6" id="text-h:ae91aaaa-c9c1-4db4-88e3-0dd5d84862a2">
<p>
<a href="https://leetcode.cn/problems/concatenation-of-array/description/">https://leetcode.cn/problems/concatenation-of-array/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#38271;&#24230;&#20026; n &#30340;&#25972;&#25968;&#25968;&#32452; nums &#12290;&#35831;&#20320;&#26500;&#24314;&#19968;&#20010;&#38271;&#24230;&#20026; 2n &#30340;&#31572;&#26696;&#25968;&#32452; ans &#65292;&#25968;&#32452;&#19979;&#26631; &#20174; 0 &#24320;&#22987;&#35745;&#25968; &#65292;&#23545;&#20110;&#25152;&#26377; 0 &lt;= i &lt; n &#30340; i &#65292;&#28385;&#36275;&#19979;&#36848;&#25152;&#26377;&#35201;&#27714;&#65306;

ans[i] == nums[i]
ans[i + n] == nums[i]
&#20855;&#20307;&#32780;&#35328;&#65292;ans &#30001;&#20004;&#20010; nums &#25968;&#32452; &#20018;&#32852; &#24418;&#25104;&#12290;

&#36820;&#22238;&#25968;&#32452; ans &#12290;

&#31034;&#20363; 1&#65306;

&#36755;&#20837;&#65306;nums = [1,2,1]
&#36755;&#20986;&#65306;[1,2,1,1,2,1]
&#35299;&#37322;&#65306;&#25968;&#32452; ans &#25353;&#19979;&#36848;&#26041;&#24335;&#24418;&#25104;&#65306;
- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]
- ans = [1,2,1,1,2,1]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-function-name">getConcatenation</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>) {
        <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">ans</span>;
        <span class="org-type">int</span> <span class="org-variable-name">size</span> = nums.size();
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; size; ++i ) {
            ans.push_back(<span class="org-type">nums</span>[i]);
        }
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; size; ++i ) {
            ans.push_back(<span class="org-type">nums</span>[i]);
        }
        <span class="org-keyword">return</span> ans;
    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:896ab511-0578-44b8-9edd-0cb3e602022f"></a><a href="#h:896ab511-0578-44b8-9edd-0cb3e602022f">16.拥有最多糖果的孩子</a><br>
<div class="outline-text-6" id="text-h:896ab511-0578-44b8-9edd-0cb3e602022f">
<p>
<a href="https://leetcode.cn/problems/kids-with-the-greatest-number-of-candies/description/">https://leetcode.cn/problems/kids-with-the-greatest-number-of-candies/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#26377; n &#20010;&#26377;&#31958;&#26524;&#30340;&#23401;&#23376;&#12290;&#32473;&#20320;&#19968;&#20010;&#25968;&#32452; candies&#65292;&#20854;&#20013; candies[i] &#20195;&#34920;&#31532; i &#20010;&#23401;&#23376;&#25317;&#26377;&#30340;&#31958;&#26524;&#25968;&#30446;&#65292;&#21644;&#19968;&#20010;&#25972;&#25968; extraCandies &#34920;&#31034;&#20320;&#25152;&#26377;&#30340;&#39069;&#22806;&#31958;&#26524;&#30340;&#25968;&#37327;&#12290;

&#36820;&#22238;&#19968;&#20010;&#38271;&#24230;&#20026; n &#30340;&#24067;&#23572;&#25968;&#32452; result&#65292;&#22914;&#26524;&#25226;&#25152;&#26377;&#30340; extraCandies &#32473;&#31532; i &#20010;&#23401;&#23376;&#20043;&#21518;&#65292;&#20182;&#20250;&#25317;&#26377;&#25152;&#26377;&#23401;&#23376;&#20013; &#26368;&#22810; &#30340;&#31958;&#26524;&#65292;&#37027;&#20040; result[i] &#20026; true&#65292;&#21542;&#21017;&#20026; false&#12290;

&#27880;&#24847;&#65292;&#20801;&#35768;&#26377;&#22810;&#20010;&#23401;&#23376;&#21516;&#26102;&#25317;&#26377; &#26368;&#22810; &#30340;&#31958;&#26524;&#25968;&#30446;&#12290;

 

&#31034;&#20363; 1&#65306;

&#36755;&#20837;&#65306;candies = [2,3,5,1,3], extraCandies = 3
&#36755;&#20986;&#65306;[true,true,true,false,true] 
&#35299;&#37322;&#65306;&#22914;&#26524;&#20320;&#25226;&#39069;&#22806;&#30340;&#31958;&#26524;&#20840;&#37096;&#32473;&#65306;
&#23401;&#23376; 1&#65292;&#23558;&#26377; 2 + 3 = 5 &#20010;&#31958;&#26524;&#65292;&#26159;&#23401;&#23376;&#20013;&#26368;&#22810;&#30340;&#12290;
&#23401;&#23376; 2&#65292;&#23558;&#26377; 3 + 3 = 6 &#20010;&#31958;&#26524;&#65292;&#26159;&#23401;&#23376;&#20013;&#26368;&#22810;&#30340;&#12290;
&#23401;&#23376; 3&#65292;&#23558;&#26377; 5 + 3 = 8 &#20010;&#31958;&#26524;&#65292;&#26159;&#23401;&#23376;&#20013;&#26368;&#22810;&#30340;&#12290;
&#23401;&#23376; 4&#65292;&#23558;&#26377; 1 + 3 = 4 &#20010;&#31958;&#26524;&#65292;&#19981;&#26159;&#23401;&#23376;&#20013;&#26368;&#22810;&#30340;&#12290;
&#23401;&#23376; 5&#65292;&#23558;&#26377; 3 + 3 = 6 &#20010;&#31958;&#26524;&#65292;&#26159;&#23401;&#23376;&#20013;&#26368;&#22810;&#30340;&#12290;
&#31034;&#20363; 2&#65306;

&#36755;&#20837;&#65306;candies = [4,2,1,1,2], extraCandies = 1
&#36755;&#20986;&#65306;[true,false,false,false,false] 
&#35299;&#37322;&#65306;&#21482;&#26377; 1 &#20010;&#39069;&#22806;&#31958;&#26524;&#65292;&#25152;&#20197;&#19981;&#31649;&#39069;&#22806;&#31958;&#26524;&#32473;&#35841;&#65292;&#21482;&#26377;&#23401;&#23376; 1 &#21487;&#20197;&#25104;&#20026;&#25317;&#26377;&#31958;&#26524;&#26368;&#22810;&#30340;&#23401;&#23376;&#12290;
&#31034;&#20363; 3&#65306;

&#36755;&#20837;&#65306;candies = [12,1,12], extraCandies = 10
&#36755;&#20986;&#65306;[true,false,true]
 

&#25552;&#31034;&#65306;

n == candies.length
2 &lt;= n &lt;= 100
1 &lt;= candies[i] &lt;= 100
1 &lt;= extraCandies &lt;= 50
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">vector</span>&lt;<span class="org-type">bool</span>&gt; <span class="org-function-name">kidsWithCandies</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">candies</span>, <span class="org-type">int</span> <span class="org-variable-name">extraCandies</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#25968;&#25454;&#33539;&#22260;&#65306;100&#20010;&#23401;&#23376; O(n^2) &#26159;&#21487;&#20197;&#25509;&#21463;&#30340;
</span>        <span class="org-type">vector</span>&lt;<span class="org-type">bool</span>&gt; <span class="org-variable-name">ans</span>;
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; candies.size(); ++i) {
            candies[i] += extraCandies;
            <span class="org-type">int</span> <span class="org-variable-name">maxId</span> = 0;
            <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = 1; j &lt; candies.size(); ++j) {
                <span class="org-keyword">if</span>(candies[j] &gt; candies[maxId]){
                    maxId = j;
                }
            }
            <span class="org-keyword">if</span> (candies[maxId] == candies[i]) {
                ans.push_back(<span class="org-constant">true</span>);
            } <span class="org-keyword">else</span> {
                ans.push_back(<span class="org-constant">false</span>);
            }
            candies[i] -= extraCandies;
        }
        <span class="org-keyword">return</span> ans;
    }
};
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-h:5152d553-235a-4ae6-8c03-2dbb6a1a06c2" class="outline-5">
<h5 id="h:5152d553-235a-4ae6-8c03-2dbb6a1a06c2"><a href="#h:5152d553-235a-4ae6-8c03-2dbb6a1a06c2">顺序表的枚举</a></h5>
<div class="outline-text-5" id="text-h:5152d553-235a-4ae6-8c03-2dbb6a1a06c2">
</div>
<ul class="org-ul">
<li><a id="h:9bfe06aa-6893-4eda-a0ce-e6636df1f8ed"></a><a href="#h:9bfe06aa-6893-4eda-a0ce-e6636df1f8ed">17.找到数组的中间位置</a><br>
<div class="outline-text-6" id="text-h:9bfe06aa-6893-4eda-a0ce-e6636df1f8ed">
<p>
<a href="https://leetcode.cn/problems/find-the-middle-index-in-array/description/">https://leetcode.cn/problems/find-the-middle-index-in-array/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#19979;&#26631;&#20174; 0 &#24320;&#22987;&#30340;&#25972;&#25968;&#25968;&#32452; nums &#65292;&#35831;&#20320;&#25214;&#21040; &#26368;&#24038;&#36793; &#30340;&#20013;&#38388;&#20301;&#32622; middleIndex &#65288;&#20063;&#23601;&#26159;&#25152;&#26377;&#21487;&#33021;&#20013;&#38388;&#20301;&#32622;&#19979;&#26631;&#26368;&#23567;&#30340;&#19968;&#20010;&#65289;&#12290;

&#20013;&#38388;&#20301;&#32622; middleIndex &#26159;&#28385;&#36275; nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1] &#30340;&#25968;&#32452;&#19979;&#26631;&#12290;

&#22914;&#26524; middleIndex == 0 &#65292;&#24038;&#36793;&#37096;&#20998;&#30340;&#21644;&#23450;&#20041;&#20026; 0 &#12290;&#31867;&#20284;&#30340;&#65292;&#22914;&#26524; middleIndex == nums.length - 1 &#65292;&#21491;&#36793;&#37096;&#20998;&#30340;&#21644;&#23450;&#20041;&#20026; 0 &#12290;

&#35831;&#20320;&#36820;&#22238;&#28385;&#36275;&#19978;&#36848;&#26465;&#20214; &#26368;&#24038;&#36793; &#30340; middleIndex &#65292;&#22914;&#26524;&#19981;&#23384;&#22312;&#36825;&#26679;&#30340;&#20013;&#38388;&#20301;&#32622;&#65292;&#35831;&#20320;&#36820;&#22238; -1 &#12290;

 

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;nums = [2,3,-1,8,4]
&#36755;&#20986;&#65306;3
&#35299;&#37322;&#65306;
&#19979;&#26631; 3 &#20043;&#21069;&#30340;&#25968;&#23383;&#21644;&#20026;&#65306;2 + 3 + -1 = 4
&#19979;&#26631; 3 &#20043;&#21518;&#30340;&#25968;&#23383;&#21644;&#20026;&#65306;4 = 4

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;nums = [1,-1,4]
&#36755;&#20986;&#65306;2
&#35299;&#37322;&#65306;
&#19979;&#26631; 2 &#20043;&#21069;&#30340;&#25968;&#23383;&#21644;&#20026;&#65306;1 + -1 = 0
&#19979;&#26631; 2 &#20043;&#21518;&#30340;&#25968;&#23383;&#21644;&#20026;&#65306;0

&#25552;&#31034;&#65306;
1 &lt;= nums.length &lt;= 100
-1000 &lt;= nums[i] &lt;= 1000
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">findMiddleIndex</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#26102;&#38388;&#22797;&#26434;&#24230; O(n^2)&#65292;&#22240;&#20026;&#25968;&#32452;&#38271;&#24230;&#21482;&#26377;100&#65292; 100^2 = 10000
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#26356;&#22909;&#30340;&#21150;&#27861;&#26159;&#21069;&#32512;&#21644;&#20102;&#65292;&#36825;&#27425;&#29992;&#26368;&#31616;&#21333;&#30340;&#27169;&#25311;&#30340;&#26041;&#27861;&#26469;&#20570;
</span>        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; nums.size(); ++i) {
            <span class="org-type">int</span> <span class="org-variable-name">l</span> = 0, <span class="org-variable-name">r</span> = 0;
            <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; i; ++j) {
                l += nums[j];
            }
            <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = i + 1; j &lt; nums.size(); ++j) {
                r += nums[j];
            }
            <span class="org-keyword">if</span> (l == r) {
                <span class="org-keyword">return</span> i;
            }
        }
        <span class="org-keyword">return</span> -1;
    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:e2c036f3-6326-426c-825e-760181df351b"></a><a href="#h:e2c036f3-6326-426c-825e-760181df351b">18.有序数组中的单一元素</a><br>
<div class="outline-text-6" id="text-h:e2c036f3-6326-426c-825e-760181df351b">
<p>
<a href="https://leetcode.cn/problems/single-element-in-a-sorted-array/solutions/">https://leetcode.cn/problems/single-element-in-a-sorted-array/solutions/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#20165;&#30001;&#25972;&#25968;&#32452;&#25104;&#30340;&#26377;&#24207;&#25968;&#32452;&#65292;&#20854;&#20013;&#27599;&#20010;&#20803;&#32032;&#37117;&#20250;&#20986;&#29616;&#20004;&#27425;&#65292;&#21807;&#26377;&#19968;&#20010;&#25968;&#21482;&#20250;&#20986;&#29616;&#19968;&#27425;&#12290;

&#35831;&#20320;&#25214;&#20986;&#24182;&#36820;&#22238;&#21482;&#20986;&#29616;&#19968;&#27425;&#30340;&#37027;&#20010;&#25968;&#12290;

&#20320;&#35774;&#35745;&#30340;&#35299;&#20915;&#26041;&#26696;&#24517;&#39035;&#28385;&#36275; O(log n) &#26102;&#38388;&#22797;&#26434;&#24230;&#21644; O(1) &#31354;&#38388;&#22797;&#26434;&#24230;&#12290;

 

&#31034;&#20363; 1:

&#36755;&#20837;: nums = [1,1,2,3,3,4,4,8,8]
&#36755;&#20986;: 2
&#31034;&#20363; 2:

&#36755;&#20837;: nums =  [3,3,7,7,10,11,11]
&#36755;&#20986;: 10
 

&#25552;&#31034;:

1 &lt;= nums.length &lt;= 105
0 &lt;= nums[i] &lt;= 105
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">singleNonDuplicate</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#22240;&#20026;&#26159;&#26377;&#24207;&#25968;&#32452;&#65292;&#27604;&#36739;&#36825;&#20010;&#25968;&#19982;&#24038;&#36793;&#21644;&#21491;&#36793;&#37117;&#19981;&#30456;&#31561;&#65292;&#36825;&#20010;&#25968;&#23601;&#26159;&#21482;&#20986;&#29616;&#19968;&#27425;&#30340;&#25968;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#31532; 0 &#20010;&#20803;&#32032;&#21644;&#26368;&#21518;&#19968;&#20010;&#20803;&#32032;&#35201;&#21333;&#29420;&#21028;&#26029;
</span>        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 1; i &lt; nums.size()-1; ++i) {
            <span class="org-keyword">if</span> ( nums[i] != nums[i-1] &amp;&amp; nums[i] != nums[i+1] ) {
                <span class="org-keyword">return</span> nums[i];
            }
        }
        <span class="org-keyword">if</span> (nums.size() == 1) {
            <span class="org-keyword">return</span> nums[0];
        }
        <span class="org-keyword">if</span> (nums[0] != nums[1]) {
            <span class="org-keyword">return</span> nums[0];
        }
        <span class="org-keyword">return</span> nums.back(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#26368;&#21518;&#19968;&#20010;&#20803;&#32032;
</span>    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:cfb28e2f-c698-49b4-a117-f97f6460cb89"></a><a href="#h:cfb28e2f-c698-49b4-a117-f97f6460cb89">19.杨辉三角 II</a><br>
<div class="outline-text-6" id="text-h:cfb28e2f-c698-49b4-a117-f97f6460cb89">
<p>
<a href="https://leetcode.cn/problems/pascals-triangle-ii/description/">https://leetcode.cn/problems/pascals-triangle-ii/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#23450;&#19968;&#20010;&#38750;&#36127;&#32034;&#24341; rowIndex&#65292;&#36820;&#22238;&#12300;&#26472;&#36745;&#19977;&#35282;&#12301;&#30340;&#31532; rowIndex &#34892;&#12290;

&#22312;&#12300;&#26472;&#36745;&#19977;&#35282;&#12301;&#20013;&#65292;&#27599;&#20010;&#25968;&#26159;&#23427;&#24038;&#19978;&#26041;&#21644;&#21491;&#19978;&#26041;&#30340;&#25968;&#30340;&#21644;&#12290;


&#31034;&#20363; 1:
&#36755;&#20837;: rowIndex = 3
&#36755;&#20986;: [1,3,3,1]

&#25552;&#31034;:
0 &lt;= rowIndex &lt;= 33
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-function-name">getRow</span>(<span class="org-type">int</span> <span class="org-variable-name">rowIndex</span>) {
        <span class="org-type">int</span> <span class="org-variable-name">f</span>[34][34];
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt;= rowIndex; ++i) {
            <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt;= i; ++j) {
                <span class="org-keyword">if</span> (j == 0 || j == i) {
                    f[i][j] = 1;
                } <span class="org-keyword">else</span> {
                    f[i][j] = f[i-1][j] + f[i-1][j-1];
                }
            }
        }
        <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">ret</span>;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt;= rowIndex; ++j) {
            ret.push_back(<span class="org-type">f</span>[rowIndex][j]);
        }
        <span class="org-keyword">return</span> ret;
    }
};

<span class="org-comment-delimiter">/* </span><span class="org-comment">&#20108;&#32500;&#25968;&#32452;&#27169;&#25311;
1 0 0 0 0
1 1 0 0 0
1 2 1 0 0
1 3 3 1 0
1 3 6 4 1
</span><span class="org-comment-delimiter">*/</span>
</pre>
</div>
</div>
</li>
<li><a id="h:2e43cef1-e57c-4286-b520-d23bafef06b0"></a><a href="#h:2e43cef1-e57c-4286-b520-d23bafef06b0">20.超过阈值的最少操作数 I</a><br>
<div class="outline-text-6" id="text-h:2e43cef1-e57c-4286-b520-d23bafef06b0">
<p>
<a href="https://leetcode.cn/problems/minimum-operations-to-exceed-threshold-value-i/description/">https://leetcode.cn/problems/minimum-operations-to-exceed-threshold-value-i/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#19979;&#26631;&#20174; 0 &#24320;&#22987;&#30340;&#25972;&#25968;&#25968;&#32452; nums &#21644;&#19968;&#20010;&#25972;&#25968; k &#12290;

&#19968;&#27425;&#25805;&#20316;&#20013;&#65292;&#20320;&#21487;&#20197;&#21024;&#38500; nums &#20013;&#30340;&#26368;&#23567;&#20803;&#32032;&#12290;

&#20320;&#38656;&#35201;&#20351;&#25968;&#32452;&#20013;&#30340;&#25152;&#26377;&#20803;&#32032;&#37117;&#22823;&#20110;&#25110;&#31561;&#20110; k &#65292;&#35831;&#20320;&#36820;&#22238;&#38656;&#35201;&#30340; &#26368;&#23569; &#25805;&#20316;&#27425;&#25968;&#12290;


&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;nums = [2,11,10,1,3], k = 10
&#36755;&#20986;&#65306;3
&#35299;&#37322;&#65306;&#31532;&#19968;&#27425;&#25805;&#20316;&#21518;&#65292;nums &#21464;&#20026; [2, 11, 10, 3] &#12290;
&#31532;&#20108;&#27425;&#25805;&#20316;&#21518;&#65292;nums &#21464;&#20026; [11, 10, 3] &#12290;
&#31532;&#19977;&#27425;&#25805;&#20316;&#21518;&#65292;nums &#21464;&#20026; [11, 10] &#12290;
&#27492;&#26102;&#65292;&#25968;&#32452;&#20013;&#30340;&#25152;&#26377;&#20803;&#32032;&#37117;&#22823;&#20110;&#31561;&#20110; 10 &#65292;&#25152;&#20197;&#25105;&#20204;&#20572;&#27490;&#25805;&#20316;&#12290;
&#20351;&#25968;&#32452;&#20013;&#25152;&#26377;&#20803;&#32032;&#37117;&#22823;&#20110;&#31561;&#20110; 10 &#38656;&#35201;&#30340;&#26368;&#23569;&#25805;&#20316;&#27425;&#25968;&#20026; 3 &#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;nums = [1,1,2,4,9], k = 1
&#36755;&#20986;&#65306;0
&#35299;&#37322;&#65306;&#25968;&#32452;&#20013;&#30340;&#25152;&#26377;&#20803;&#32032;&#37117;&#22823;&#20110;&#31561;&#20110; 1 &#65292;&#25152;&#20197;&#19981;&#38656;&#35201;&#23545; nums &#20570;&#20219;&#20309;&#25805;&#20316;&#12290;

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;nums = [1,1,2,4,9], k = 9
&#36755;&#20986;&#65306;4
&#35299;&#37322;&#65306;nums &#20013;&#21482;&#26377;&#19968;&#20010;&#20803;&#32032;&#22823;&#20110;&#31561;&#20110; 9 &#65292;&#25152;&#20197;&#38656;&#35201;&#25191;&#34892; 4 &#27425;&#25805;&#20316;&#12290;
 

&#25552;&#31034;&#65306;
1 &lt;= nums.length &lt;= 50
1 &lt;= nums[i] &lt;= 109
1 &lt;= k &lt;= 109
&#36755;&#20837;&#20445;&#35777;&#33267;&#23569;&#26377;&#19968;&#20010;&#28385;&#36275; nums[i] &gt;= k &#30340;&#19979;&#26631; i &#23384;&#22312;&#12290;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">minOperations</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>, <span class="org-type">int</span> <span class="org-variable-name">k</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#32479;&#35745;&#25968;&#32452;&#20013;&#26377;&#22810;&#23569;&#20010;&#23567;&#20110;k&#30340;&#25968;
</span>        <span class="org-type">int</span> <span class="org-variable-name">cnt</span> = 0;
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; nums.size(); ++i) {
            <span class="org-keyword">if</span> (nums[i] &lt; k) {
                cnt++;
            }
        }
        <span class="org-keyword">return</span> cnt;
    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:29fc412e-b7d1-408e-a157-5177d6325492"></a><a href="#h:29fc412e-b7d1-408e-a157-5177d6325492">21.找出峰值</a><br>
<div class="outline-text-6" id="text-h:29fc412e-b7d1-408e-a157-5177d6325492">
<p>
<a href="https://leetcode.cn/problems/find-the-peaks/description/">https://leetcode.cn/problems/find-the-peaks/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#19979;&#26631;&#20174; 0 &#24320;&#22987;&#30340;&#25968;&#32452; mountain &#12290;&#20320;&#30340;&#20219;&#21153;&#26159;&#25214;&#20986;&#25968;&#32452; mountain &#20013;&#30340;&#25152;&#26377; &#23792;&#20540;&#12290;

&#20197;&#25968;&#32452;&#24418;&#24335;&#36820;&#22238;&#32473;&#23450;&#25968;&#32452;&#20013; &#23792;&#20540; &#30340;&#19979;&#26631;&#65292;&#39034;&#24207;&#19981;&#38480; &#12290;

&#27880;&#24847;&#65306;
&#23792;&#20540; &#26159;&#25351;&#19968;&#20010;&#20005;&#26684;&#22823;&#20110;&#20854;&#30456;&#37051;&#20803;&#32032;&#30340;&#20803;&#32032;&#12290;
&#25968;&#32452;&#30340;&#31532;&#19968;&#20010;&#21644;&#26368;&#21518;&#19968;&#20010;&#20803;&#32032; &#19981; &#26159;&#23792;&#20540;&#12290;
 

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;mountain = [2,4,4]
&#36755;&#20986;&#65306;[]
&#35299;&#37322;&#65306;mountain[0] &#21644; mountain[2] &#19981;&#21487;&#33021;&#26159;&#23792;&#20540;&#65292;&#22240;&#20026;&#23427;&#20204;&#26159;&#25968;&#32452;&#30340;&#31532;&#19968;&#20010;&#21644;&#26368;&#21518;&#19968;&#20010;&#20803;&#32032;&#12290;
mountain[1] &#20063;&#19981;&#21487;&#33021;&#26159;&#23792;&#20540;&#65292;&#22240;&#20026;&#23427;&#19981;&#20005;&#26684;&#22823;&#20110; mountain[2] &#12290;
&#22240;&#27492;&#65292;&#31572;&#26696;&#20026; [] &#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;mountain = [1,4,3,8,5]
&#36755;&#20986;&#65306;[1,3]
&#35299;&#37322;&#65306;mountain[0] &#21644; mountain[4] &#19981;&#21487;&#33021;&#26159;&#23792;&#20540;&#65292;&#22240;&#20026;&#23427;&#20204;&#26159;&#25968;&#32452;&#30340;&#31532;&#19968;&#20010;&#21644;&#26368;&#21518;&#19968;&#20010;&#20803;&#32032;&#12290;
mountain[2] &#20063;&#19981;&#21487;&#33021;&#26159;&#23792;&#20540;&#65292;&#22240;&#20026;&#23427;&#19981;&#20005;&#26684;&#22823;&#20110; mountain[3] &#21644; mountain[1] &#12290;
&#20294;&#26159; mountain[1] &#21644; mountain[3] &#20005;&#26684;&#22823;&#20110;&#23427;&#20204;&#30340;&#30456;&#37051;&#20803;&#32032;&#12290;
&#22240;&#27492;&#65292;&#31572;&#26696;&#26159; [1,3] &#12290;
 

&#25552;&#31034;&#65306;
3 &lt;= mountain.length &lt;= 100
1 &lt;= mountain[i] &lt;= 100
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-function-name">findPeaks</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">mountain</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#26522;&#20030;&#25968;&#32452;&#37324;&#38754;&#30340;&#27599;&#20010;&#20803;&#32032;&#65292;&#20998;&#21035;&#21028;&#26029;&#23427;&#21644;&#21608;&#22260;&#20004;&#20010;&#20803;&#32032;&#30340;&#20851;&#31995;&#65292;&#26159;&#21542;&#22823;&#20110;&#20004;&#36793;&#30340;&#25968;&#65311;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;&#65292;&#23601;&#26159;&#23792;&#20540;&#65292;&#21542;&#21017;&#19981;&#26159;&#12290;
</span>        <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">ret</span>;
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 1; i &lt; mountain.size()-1; ++i) {
            <span class="org-keyword">if</span> (mountain[i] &gt; mountain[i-1] &amp;&amp; mountain[i] &gt; mountain[i+1]) {
                ret.push_back(i);
            }
        }
        <span class="org-keyword">return</span> ret;
    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:d228b6c5-97f0-429f-ba34-9a7739db6525"></a><a href="#h:d228b6c5-97f0-429f-ba34-9a7739db6525">22.统计已测试设备</a><br>
<div class="outline-text-6" id="text-h:d228b6c5-97f0-429f-ba34-9a7739db6525">
<p>
<a href="https://leetcode.cn/problems/count-tested-devices-after-test-operations/description/">https://leetcode.cn/problems/count-tested-devices-after-test-operations/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#38271;&#24230;&#20026; n &#12289;&#19979;&#26631;&#20174; 0 &#24320;&#22987;&#30340;&#25972;&#25968;&#25968;&#32452; batteryPercentages &#65292;&#34920;&#31034; n &#20010;&#35774;&#22791;&#30340;&#30005;&#27744;&#30334;&#20998;&#27604;&#12290;

&#20320;&#30340;&#20219;&#21153;&#26159;&#25353;&#29031;&#39034;&#24207;&#27979;&#35797;&#27599;&#20010;&#35774;&#22791; i&#65292;&#25191;&#34892;&#20197;&#19979;&#27979;&#35797;&#25805;&#20316;&#65306;

&#22914;&#26524; batteryPercentages[i] &#22823;&#20110; 0&#65306;
&#22686;&#21152; &#24050;&#27979;&#35797;&#35774;&#22791;&#30340;&#35745;&#25968;&#12290;
&#23558;&#19979;&#26631; j &#22312; [i + 1, n - 1] &#30340;&#25152;&#26377;&#35774;&#22791;&#30340;&#30005;&#27744;&#30334;&#20998;&#27604;&#20943;&#23569; 1&#65292;&#30830;&#20445;&#23427;&#20204;&#30340;&#30005;&#27744;&#30334;&#20998;&#27604; &#19981;&#20250;&#20302;&#20110; 0 &#65292;&#21363; batteryPercentages[j] = max(0, batteryPercentages[j] - 1)&#12290;
&#31227;&#21160;&#21040;&#19979;&#19968;&#20010;&#35774;&#22791;&#12290;
&#21542;&#21017;&#65292;&#31227;&#21160;&#21040;&#19979;&#19968;&#20010;&#35774;&#22791;&#32780;&#19981;&#25191;&#34892;&#20219;&#20309;&#27979;&#35797;&#12290;
&#36820;&#22238;&#19968;&#20010;&#25972;&#25968;&#65292;&#34920;&#31034;&#25353;&#39034;&#24207;&#25191;&#34892;&#27979;&#35797;&#25805;&#20316;&#21518; &#24050;&#27979;&#35797;&#35774;&#22791; &#30340;&#25968;&#37327;&#12290;


&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;batteryPercentages = [1,1,2,1,3]
&#36755;&#20986;&#65306;3
&#35299;&#37322;&#65306;&#25353;&#39034;&#24207;&#20174;&#35774;&#22791; 0 &#24320;&#22987;&#25191;&#34892;&#27979;&#35797;&#25805;&#20316;&#65306;
&#22312;&#35774;&#22791; 0 &#19978;&#65292;batteryPercentages[0] &gt; 0 &#65292;&#29616;&#22312;&#26377; 1 &#20010;&#24050;&#27979;&#35797;&#35774;&#22791;&#65292;batteryPercentages &#21464;&#20026; [1,0,1,0,2] &#12290;
&#22312;&#35774;&#22791; 1 &#19978;&#65292;batteryPercentages[1] == 0 &#65292;&#31227;&#21160;&#21040;&#19979;&#19968;&#20010;&#35774;&#22791;&#32780;&#19981;&#36827;&#34892;&#27979;&#35797;&#12290;
&#22312;&#35774;&#22791; 2 &#19978;&#65292;batteryPercentages[2] &gt; 0 &#65292;&#29616;&#22312;&#26377; 2 &#20010;&#24050;&#27979;&#35797;&#35774;&#22791;&#65292;batteryPercentages &#21464;&#20026; [1,0,1,0,1] &#12290;
&#22312;&#35774;&#22791; 3 &#19978;&#65292;batteryPercentages[3] == 0 &#65292;&#31227;&#21160;&#21040;&#19979;&#19968;&#20010;&#35774;&#22791;&#32780;&#19981;&#36827;&#34892;&#27979;&#35797;&#12290;
&#22312;&#35774;&#22791; 4 &#19978;&#65292;batteryPercentages[4] &gt; 0 &#65292;&#29616;&#22312;&#26377; 3 &#20010;&#24050;&#27979;&#35797;&#35774;&#22791;&#65292;batteryPercentages &#20445;&#25345;&#19981;&#21464;&#12290;
&#22240;&#27492;&#65292;&#31572;&#26696;&#26159; 3 &#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;batteryPercentages = [0,1,2]
&#36755;&#20986;&#65306;2
&#35299;&#37322;&#65306;&#25353;&#39034;&#24207;&#20174;&#35774;&#22791; 0 &#24320;&#22987;&#25191;&#34892;&#27979;&#35797;&#25805;&#20316;&#65306;
&#22312;&#35774;&#22791; 0 &#19978;&#65292;batteryPercentages[0] == 0 &#65292;&#31227;&#21160;&#21040;&#19979;&#19968;&#20010;&#35774;&#22791;&#32780;&#19981;&#36827;&#34892;&#27979;&#35797;&#12290;
&#22312;&#35774;&#22791; 1 &#19978;&#65292;batteryPercentages[1] &gt; 0 &#65292;&#29616;&#22312;&#26377; 1 &#20010;&#24050;&#27979;&#35797;&#35774;&#22791;&#65292;batteryPercentages &#21464;&#20026; [0,1,1] &#12290;
&#22312;&#35774;&#22791; 2 &#19978;&#65292;batteryPercentages[2] &gt; 0 &#65292;&#29616;&#22312;&#26377; 2 &#20010;&#24050;&#27979;&#35797;&#35774;&#22791;&#65292;batteryPercentages &#20445;&#25345;&#19981;&#21464;&#12290;
&#22240;&#27492;&#65292;&#31572;&#26696;&#26159; 2 &#12290;
 

&#25552;&#31034;&#65306;
1 &lt;= n == batteryPercentages.length &lt;= 100 
0 &lt;= batteryPercentages[i] &lt;= 100
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">countTestedDevices</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">bp</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#25968;&#25454;&#33539;&#22260;&#65306;100&#30340;&#35805;&#65292;O(n^2)&#30340;&#26102;&#38388;&#22797;&#26434;&#24230;&#23436;&#25104;&#21345;&#19981;&#20303;&#20320;&#30340;&#65292;&#26159;10000&#30340;&#26102;&#20505;&#25165;&#38656;&#35201;&#32771;&#34385;
</span>        <span class="org-type">int</span> <span class="org-variable-name">cnt</span> = 0;
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; bp.size(); ++i) {
            
            <span class="org-keyword">if</span> (bp[i] &gt; 0) {
                ++cnt;
                <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = i+1; j &lt; bp.size(); ++j) {
                    bp[j] = max(0, <span class="org-type">bp</span>[j]-1);
                }
            }
        }
        <span class="org-keyword">return</span> cnt;
    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:19044e68-d442-4e4c-a270-ff5b4372792d"></a><a href="#h:19044e68-d442-4e4c-a270-ff5b4372792d">23.统计和小于目标的下标对数目</a><br>
<div class="outline-text-6" id="text-h:19044e68-d442-4e4c-a270-ff5b4372792d">
<p>
<a href="https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target/description/">https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#19979;&#26631;&#20174; 0 &#24320;&#22987;&#38271;&#24230;&#20026; n &#30340;&#25972;&#25968;&#25968;&#32452; nums &#21644;&#19968;&#20010;&#25972;&#25968; target &#65292;&#35831;&#20320;&#36820;&#22238;&#28385;&#36275; 0 &lt;= i &lt; j &lt; n &#19988; nums[i] + nums[j] &lt; target &#30340;&#19979;&#26631;&#23545; (i, j) &#30340;&#25968;&#30446;&#12290;
 

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;nums = [-1,1,2,3,1], target = 2
&#36755;&#20986;&#65306;3
&#35299;&#37322;&#65306;&#24635;&#20849;&#26377; 3 &#20010;&#19979;&#26631;&#23545;&#28385;&#36275;&#39064;&#30446;&#25551;&#36848;&#65306;
- (0, 1) &#65292;0 &lt; 1 &#19988; nums[0] + nums[1] = 0 &lt; target
- (0, 2) &#65292;0 &lt; 2 &#19988; nums[0] + nums[2] = 1 &lt; target 
- (0, 4) &#65292;0 &lt; 4 &#19988; nums[0] + nums[4] = 0 &lt; target
&#27880;&#24847; (0, 3) &#19981;&#35745;&#20837;&#31572;&#26696;&#22240;&#20026; nums[0] + nums[3] &#19981;&#26159;&#20005;&#26684;&#23567;&#20110; target &#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;nums = [-6,2,5,-2,-7,-1,3], target = -2
&#36755;&#20986;&#65306;10
&#35299;&#37322;&#65306;&#24635;&#20849;&#26377; 10 &#20010;&#19979;&#26631;&#23545;&#28385;&#36275;&#39064;&#30446;&#25551;&#36848;&#65306;
- (0, 1) &#65292;0 &lt; 1 &#19988; nums[0] + nums[1] = -4 &lt; target
- (0, 3) &#65292;0 &lt; 3 &#19988; nums[0] + nums[3] = -8 &lt; target
- (0, 4) &#65292;0 &lt; 4 &#19988; nums[0] + nums[4] = -13 &lt; target
- (0, 5) &#65292;0 &lt; 5 &#19988; nums[0] + nums[5] = -7 &lt; target
- (0, 6) &#65292;0 &lt; 6 &#19988; nums[0] + nums[6] = -3 &lt; target
- (1, 4) &#65292;1 &lt; 4 &#19988; nums[1] + nums[4] = -5 &lt; target
- (3, 4) &#65292;3 &lt; 4 &#19988; nums[3] + nums[4] = -9 &lt; target
- (3, 5) &#65292;3 &lt; 5 &#19988; nums[3] + nums[5] = -3 &lt; target
- (4, 5) &#65292;4 &lt; 5 &#19988; nums[4] + nums[5] = -8 &lt; target
- (4, 6) &#65292;4 &lt; 6 &#19988; nums[4] + nums[6] = -4 &lt; target
 

&#25552;&#31034;&#65306;
1 &lt;= nums.length == n &lt;= 50
-50 &lt;= nums[i], target &lt;= 50
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">countPairs</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">a</span>, <span class="org-type">int</span> <span class="org-variable-name">t</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">n &#26159;50&#65292;n^2=2500&#65292;&#26102;&#38388;&#22797;&#26434;&#24230;&#21487;&#20197;&#25509;&#21463;&#12290;&#26292;&#21147;&#20570;
</span>        <span class="org-type">int</span> <span class="org-variable-name">cnt</span> = 0;
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; a.size(); ++i) {
            <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">j</span> = i+1; j &lt; a.size(); ++j) {
                <span class="org-keyword">if</span> (a[i] + a[j] &lt; t) {
                    ++cnt;
                }
            }
        }
        <span class="org-keyword">return</span> cnt;
    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:995f87e1-517d-4bad-b19e-0724e96594a2"></a><a href="#h:995f87e1-517d-4bad-b19e-0724e96594a2">24.计算 K 置位下标对应元素的和</a><br>
<div class="outline-text-6" id="text-h:995f87e1-517d-4bad-b19e-0724e96594a2">
<p>
<a href="https://leetcode.cn/problems/sum-of-values-at-indices-with-k-set-bits/description/">https://leetcode.cn/problems/sum-of-values-at-indices-with-k-set-bits/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#19979;&#26631;&#20174; 0 &#24320;&#22987;&#30340;&#25972;&#25968;&#25968;&#32452; nums &#21644;&#19968;&#20010;&#25972;&#25968; k &#12290;

&#35831;&#20320;&#29992;&#25972;&#25968;&#24418;&#24335;&#36820;&#22238; nums &#20013;&#30340;&#29305;&#23450;&#20803;&#32032;&#20043; &#21644; &#65292;&#36825;&#20123;&#29305;&#23450;&#20803;&#32032;&#28385;&#36275;&#65306;&#20854;&#23545;&#24212;&#19979;&#26631;&#30340;&#20108;&#36827;&#21046;&#34920;&#31034;&#20013;&#24688;&#23384;&#22312; k &#20010;&#32622;&#20301;&#12290;

&#25972;&#25968;&#30340;&#20108;&#36827;&#21046;&#34920;&#31034;&#20013;&#30340; 1 &#23601;&#26159;&#36825;&#20010;&#25972;&#25968;&#30340; &#32622;&#20301; &#12290;

&#20363;&#22914;&#65292;21 &#30340;&#20108;&#36827;&#21046;&#34920;&#31034;&#20026; 10101 &#65292;&#20854;&#20013;&#26377; 3 &#20010;&#32622;&#20301;&#12290;


&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;nums = [5,10,1,5,2], k = 1
&#36755;&#20986;&#65306;13
&#35299;&#37322;&#65306;&#19979;&#26631;&#30340;&#20108;&#36827;&#21046;&#34920;&#31034;&#26159;&#65306; 
0 = 0002
1 = 0012
2 = 0102
3 = 0112
4 = 1002 
&#19979;&#26631; 1&#12289;2 &#21644; 4 &#22312;&#20854;&#20108;&#36827;&#21046;&#34920;&#31034;&#20013;&#37117;&#23384;&#22312; k = 1 &#20010;&#32622;&#20301;&#12290;
&#22240;&#27492;&#65292;&#31572;&#26696;&#20026; nums[1] + nums[2] + nums[4] = 13 &#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;nums = [4,3,2,1], k = 2
&#36755;&#20986;&#65306;1
&#35299;&#37322;&#65306;&#19979;&#26631;&#30340;&#20108;&#36827;&#21046;&#34920;&#31034;&#26159;&#65306; 
0 = 002
1 = 012
2 = 102
3 = 112
&#21482;&#26377;&#19979;&#26631; 3 &#30340;&#20108;&#36827;&#21046;&#34920;&#31034;&#20013;&#23384;&#22312; k = 2 &#20010;&#32622;&#20301;&#12290;
&#22240;&#27492;&#65292;&#31572;&#26696;&#20026; nums[3] = 1 &#12290;

&#25552;&#31034;&#65306;
1 &lt;= nums.length &lt;= 1000
1 &lt;= nums[i] &lt;= 105
0 &lt;= k &lt;= 10
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">sumIndicesWithKSetBits</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>, <span class="org-type">int</span> <span class="org-variable-name">k</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#25968;&#32452;&#19979;&#26631;&#30340;&#20108;&#36827;&#21046;&#20013;&#20026;1&#30340;&#20010;&#25968;&#31561;&#20110;k&#65292;&#25226;&#23545;&#24212;&#30340;&#25968;&#32047;&#21152;
</span>        <span class="org-type">int</span> <span class="org-variable-name">sum</span> = 0;
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; nums.size(); ++i) {
            <span class="org-type">int</span> <span class="org-variable-name">x</span> = i;
            <span class="org-type">int</span> <span class="org-variable-name">cnt</span> = 0; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26377;&#22810;&#23569;&#20010;1
</span>            <span class="org-keyword">while</span>(x) {
                <span class="org-keyword">if</span>(x &amp; 1) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#26368;&#20302;&#20301;&#20026;1
</span>                    ++cnt;
                }
                x &gt;&gt;= 1; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21491;&#31227;1&#20301;&#65292;&#21435;&#25481;&#26368;&#20302;&#20301;
</span>            }
            <span class="org-keyword">if</span> (cnt == k) {
                sum += nums[i];
            }
        }
        <span class="org-keyword">return</span> sum;
    }
};
<span class="org-comment-delimiter">// </span><span class="org-comment">5 10 1  5 2
</span><span class="org-comment-delimiter">// </span><span class="org-comment">0 1  10 11 100</span>
</pre>
</div>
</div>
</li>
<li><a id="h:9c010350-4525-4069-a497-21198828b01b"></a><a href="#h:9c010350-4525-4069-a497-21198828b01b">25. 数组能形成多少数对</a><br>
<div class="outline-text-6" id="text-h:9c010350-4525-4069-a497-21198828b01b">
<p>
<a href="https://leetcode.cn/problems/maximum-number-of-pairs-in-array/description/">https://leetcode.cn/problems/maximum-number-of-pairs-in-array/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#19979;&#26631;&#20174; 0 &#24320;&#22987;&#30340;&#25972;&#25968;&#25968;&#32452; nums &#12290;&#22312;&#19968;&#27493;&#25805;&#20316;&#20013;&#65292;&#20320;&#21487;&#20197;&#25191;&#34892;&#20197;&#19979;&#27493;&#39588;&#65306;

&#20174; nums &#36873;&#20986; &#20004;&#20010; &#30456;&#31561;&#30340; &#25972;&#25968;
&#20174; nums &#20013;&#31227;&#38500;&#36825;&#20004;&#20010;&#25972;&#25968;&#65292;&#24418;&#25104;&#19968;&#20010; &#25968;&#23545;
&#35831;&#20320;&#22312; nums &#19978;&#22810;&#27425;&#25191;&#34892;&#27492;&#25805;&#20316;&#30452;&#21040;&#26080;&#27861;&#32487;&#32493;&#25191;&#34892;&#12290;

&#36820;&#22238;&#19968;&#20010;&#19979;&#26631;&#20174; 0 &#24320;&#22987;&#12289;&#38271;&#24230;&#20026; 2 &#30340;&#25972;&#25968;&#25968;&#32452; answer &#20316;&#20026;&#31572;&#26696;&#65292;&#20854;&#20013; answer[0] &#26159;&#24418;&#25104;&#30340;&#25968;&#23545;&#25968;&#30446;&#65292;answer[1] &#26159;&#23545; nums &#23613;&#21487;&#33021;&#25191;&#34892;&#19978;&#36848;&#25805;&#20316;&#21518;&#21097;&#19979;&#30340;&#25972;&#25968;&#25968;&#30446;&#12290;


&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;nums = [1,3,2,1,3,2,2]
&#36755;&#20986;&#65306;[3,1]
&#35299;&#37322;&#65306;
nums[0] &#21644; nums[3] &#24418;&#25104;&#19968;&#20010;&#25968;&#23545;&#65292;&#24182;&#20174; nums &#20013;&#31227;&#38500;&#65292;nums = [3,2,3,2,2] &#12290;
nums[0] &#21644; nums[2] &#24418;&#25104;&#19968;&#20010;&#25968;&#23545;&#65292;&#24182;&#20174; nums &#20013;&#31227;&#38500;&#65292;nums = [2,2,2] &#12290;
nums[0] &#21644; nums[1] &#24418;&#25104;&#19968;&#20010;&#25968;&#23545;&#65292;&#24182;&#20174; nums &#20013;&#31227;&#38500;&#65292;nums = [2] &#12290;
&#26080;&#27861;&#24418;&#25104;&#26356;&#22810;&#25968;&#23545;&#12290;&#24635;&#20849;&#24418;&#25104; 3 &#20010;&#25968;&#23545;&#65292;nums &#20013;&#21097;&#19979; 1 &#20010;&#25968;&#23383;&#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;nums = [1,1]
&#36755;&#20986;&#65306;[1,0]
&#35299;&#37322;&#65306;nums[0] &#21644; nums[1] &#24418;&#25104;&#19968;&#20010;&#25968;&#23545;&#65292;&#24182;&#20174; nums &#20013;&#31227;&#38500;&#65292;nums = [] &#12290;
&#26080;&#27861;&#24418;&#25104;&#26356;&#22810;&#25968;&#23545;&#12290;&#24635;&#20849;&#24418;&#25104; 1 &#20010;&#25968;&#23545;&#65292;nums &#20013;&#21097;&#19979; 0 &#20010;&#25968;&#23383;&#12290;

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;nums = [0]
&#36755;&#20986;&#65306;[0,1]
&#35299;&#37322;&#65306;&#26080;&#27861;&#24418;&#25104;&#25968;&#23545;&#65292;nums &#20013;&#21097;&#19979; 1 &#20010;&#25968;&#23383;&#12290;
 

&#25552;&#31034;&#65306;
1 &lt;= nums.length &lt;= 100
0 &lt;= nums[i] &lt;= 100
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-function-name">numberOfPairs</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#36941;&#21382;&#26522;&#20030;&#25152;&#26377;&#30340;&#25968;&#65292;&#22312;&#26522;&#20030;&#21040;&#31532;i&#25968;&#30340;&#26102;&#20505;&#65292;&#21040;&#21069;&#38754;&#25214;&#26377;&#27809;&#26377;&#36319;&#23427;&#30456;&#31561;&#30340;&#25968;&#65292;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#25226;&#36825;&#20004;&#20010;&#25968;&#26631;&#35760;&#25481;&#65292;&#26631;&#35760;&#25104;1&#65292;&#20197;&#21518;&#20877;&#25214;&#23601;&#19981;&#33021;&#25214;&#36825;&#20004;&#20010;&#25968;
</span>        <span class="org-type">int</span> <span class="org-variable-name">match</span>[100] = {0}; <span class="org-comment-delimiter">// </span><span class="org-comment">match[i] = 1&#34920;&#31034;&#34987;&#21305;&#37197;&#25481;&#20102;
</span>        <span class="org-type">int</span> <span class="org-variable-name">cnt</span> = 0;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; nums.size(); ++i) {
            <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; i; ++j) {
                <span class="org-keyword">if</span>(match[j]) {
                    <span class="org-keyword">continue</span>;
                }
                <span class="org-keyword">if</span> (nums[i] == nums[j]) {
                    match[i] = match[j] = 1; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;match[i]&#21644;match[j]&#32622;&#20026;1
</span>                    ++cnt;
                    <span class="org-keyword">break</span>;
                }
            }
        }
        <span class="org-keyword">return</span> {cnt, (<span class="org-type">int</span>)nums.size()-2*cnt};
    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:44cbf568-d778-423e-b4cd-3d3525ed87a0"></a><a href="#h:44cbf568-d778-423e-b4cd-3d3525ed87a0">26.求出出现两次数字的 XOR 值</a><br>
<div class="outline-text-6" id="text-h:44cbf568-d778-423e-b4cd-3d3525ed87a0">
<p>
<a href="https://leetcode.cn/problems/find-the-xor-of-numbers-which-appear-twice/description/">https://leetcode.cn/problems/find-the-xor-of-numbers-which-appear-twice/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#25968;&#32452; nums &#65292;&#25968;&#32452;&#20013;&#30340;&#25968;&#23383; &#35201;&#20040; &#20986;&#29616;&#19968;&#27425;&#65292;&#35201;&#20040; &#20986;&#29616;&#20004;&#27425;&#12290;

&#35831;&#20320;&#36820;&#22238;&#25968;&#32452;&#20013;&#25152;&#26377;&#20986;&#29616;&#20004;&#27425;&#25968;&#23383;&#30340;&#25353;&#20301; XOR &#20540;&#65292;&#22914;&#26524;&#27809;&#26377;&#25968;&#23383;&#20986;&#29616;&#36807;&#20004;&#27425;&#65292;&#36820;&#22238; 0 &#12290;


&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;nums = [1,2,1,3]
&#36755;&#20986;&#65306;1
&#35299;&#37322;&#65306;
nums &#20013;&#21807;&#19968;&#20986;&#29616;&#36807;&#20004;&#27425;&#30340;&#25968;&#23383;&#26159; 1 &#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;nums = [1,2,3]
&#36755;&#20986;&#65306;0
&#35299;&#37322;&#65306;
nums &#20013;&#27809;&#26377;&#25968;&#23383;&#20986;&#29616;&#20004;&#27425;&#12290;

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;nums = [1,2,2,1]
&#36755;&#20986;&#65306;3
&#35299;&#37322;&#65306;
&#25968;&#23383; 1 &#21644; 2 &#20986;&#29616;&#36807;&#20004;&#27425;&#12290;1 XOR 2 == 3 &#12290;


&#25552;&#31034;&#65306;
1 &lt;= nums.length &lt;= 50
1 &lt;= nums[i] &lt;= 50
nums &#20013;&#27599;&#20010;&#25968;&#23383;&#35201;&#20040;&#20986;&#29616;&#36807;&#19968;&#27425;&#65292;&#35201;&#20040;&#20986;&#29616;&#36807;&#20004;&#27425;&#12290;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp">
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-h:3b5178eb-4d07-4100-9d43-2435bb3cd923" class="outline-3">
<h3 id="h:3b5178eb-4d07-4100-9d43-2435bb3cd923"><a href="#h:3b5178eb-4d07-4100-9d43-2435bb3cd923">应用篇</a></h3>
<div class="outline-text-3" id="text-h:3b5178eb-4d07-4100-9d43-2435bb3cd923">
</div>
<div id="outline-container-h:696d13b2-defd-41ef-8b7a-f2aad55c7a85" class="outline-4">
<h4 id="h:696d13b2-defd-41ef-8b7a-f2aad55c7a85"><a href="#h:696d13b2-defd-41ef-8b7a-f2aad55c7a85">春晚魔术顺序表代码实现</a></h4>
<div class="outline-text-4" id="text-h:696d13b2-defd-41ef-8b7a-f2aad55c7a85">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">void</span> <span class="org-function-name">print</span>(<span class="org-type">int</span> <span class="org-variable-name">c</span>[], <span class="org-type">int</span> <span class="org-variable-name">l</span>, <span class="org-type">int</span> <span class="org-variable-name">r</span>) {
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = l; i &lt; r; ++i) {
        cout &lt;&lt; c[i] &lt;&lt; <span class="org-string">' '</span>;
    }
    cout &lt;&lt; endl;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">a</span>[4] = { 2, 7, 6, 5 }; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;4&#24352;&#29260;
</span>    <span class="org-type">int</span> <span class="org-variable-name">cnt</span> = 0;               <span class="org-comment-delimiter">// </span><span class="org-comment">&#35745;&#25968;&#22120;&#21464;&#37327;
</span>    <span class="org-keyword">while</span> (cnt++ &lt; 100) {      <span class="org-comment-delimiter">// </span><span class="org-comment">&#36845;&#20195;100&#27425;&#65307;&#27599;&#27425;&#36845;&#20195;&#38543;&#26426;&#20132;&#25442;2&#20010;&#25968;&#65292;&#23454;&#29616;&#24324;&#20081;&#25928;&#26524;
</span>        <span class="org-type">int</span> <span class="org-variable-name">x</span> = rand() % 4;
        <span class="org-type">int</span> <span class="org-variable-name">y</span> = rand() % 4;
        <span class="org-type">int</span> <span class="org-variable-name">tmp</span> = a[x];
        a[x] = a[y];
        a[y] = tmp;
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#25968;&#32452;b&#65292;&#25226;a&#30340;&#25968;&#25454;&#25335;&#36125;&#32473;b
</span>    <span class="org-type">int</span> <span class="org-variable-name">b</span>[4];
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 4; ++i) {
        b[i] = a[i];
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#28378;&#21160;&#25968;&#32452;c&#65292;l&#21644;r&#20998;&#21035;&#20026;&#25968;&#32452;&#20013;&#20803;&#32032;&#30340;&#36793;&#30028;&#65292;&#24038;&#21322;&#21491;&#24320;
</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">&#24182;&#19988;&#25226;a&#25968;&#32452;&#30340;&#25968;&#25454;&#25554;&#20837;c&#23614;&#37096;&#65292;&#24182;&#19988;&#25226;b&#25968;&#32452;&#30340;&#25968;&#25454;&#25554;&#20837;c&#23614;&#37096;
</span>    <span class="org-type">int</span> <span class="org-variable-name">c</span>[1000];
    <span class="org-type">int</span> <span class="org-variable-name">l</span> = 0, <span class="org-variable-name">r</span> = 0;
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 1; i &lt; 4; ++i) {
        c[r++] = a[i];
    }
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 1; i &lt; 4; ++i) {
        c[r++] = b[i];
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;&#31532;&#19968;&#20010;&#25968;&#25454;&#25554;&#20837;&#21040;&#26368;&#21518;
</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20877;&#27425;&#31532;&#19968;&#20010;&#25968;&#25454;&#25554;&#20837;&#21040;&#26368;&#21518;
</span>    c[r++] = c[l++];
    c[r++] = c[l++];

    print(c, l, r);

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;&#25968;&#32452;&#26368;&#21518;&#19977;&#20010;&#20803;&#32032;&#24448;&#21518;&#25386;&#19977;&#20010;&#20301;&#32622;
</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;&#25968;&#32452;&#22836;&#19977;&#20010;&#20803;&#32032;&#25554;&#20837;&#20013;&#38388;&#31354;&#20986;&#26469;&#30340;&#20301;&#32622;
</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">l&#21644;r&#30340;&#20540;&#21491;&#31227;&#19977;&#20301;
</span>    c[r] = c[r - 3];
    c[r + 1] = c[r - 2];
    c[r + 2] = c[r - 1];
    c[r - 3] = c[l];
    c[r - 2] = c[l + 1];
    c[r - 1] = c[l + 2];
    l += 3;
    r += 3;
    
    print(c, l, r);

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;&#25968;&#32452;&#22836;&#30340;&#20803;&#32032;&#21462;&#20986;&#26469;
</span>    <span class="org-type">int</span> <span class="org-variable-name">pigudixia</span> = c[l++];

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20154; &#25343;&#25968;&#32452;&#30340;&#39318;&#20803;&#32032;&#38543;&#20415;&#25214;&#20010;&#20301;&#32622;&#25554;&#20837;
</span>    <span class="org-type">int</span> <span class="org-variable-name">x</span> = c[l++];
    c[r] = c[r - 1];
    c[r - 1] = x;
    ++r;

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25343;&#36215;&#19968;&#24352;&#25172;&#25481;
</span>    ++l;

    <span class="org-comment-delimiter">// </span><span class="org-comment">7&#27425;&#24490;&#29615;&#65292;&#31532;&#27425;&#24490;&#29615;&#25226;&#31532;&#19968;&#20010;&#20803;&#32032;&#25918;&#21040;&#26368;&#21518;&#65292;
</span>    cnt = 0;
    <span class="org-keyword">while</span> (cnt++ &lt; 7) {
        c[r++] = c[l++];
    }

    cnt = 0;
    <span class="org-keyword">while</span> (cnt++ &lt; 5) {
        c[r++] = c[l++];
        print(c, l, r);
        l++;
        print(c, l, r);
    }

    cout &lt;&lt; pigudixia &lt;&lt; <span class="org-string">' '</span> &lt;&lt; c[l] &lt;&lt; endl;

    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
</section>
<section id="outline-container-h:e92a5d72-7cc1-4d50-b52a-2f75a32c9cda" class="outline-2">
<h2 id="h:e92a5d72-7cc1-4d50-b52a-2f75a32c9cda"><a href="#h:e92a5d72-7cc1-4d50-b52a-2f75a32c9cda">线性结构-单向链表</a></h2>
<div class="outline-text-2" id="text-h:e92a5d72-7cc1-4d50-b52a-2f75a32c9cda">
</div>
<div id="outline-container-h:0563f432-6332-4c70-ae1f-a43ec5deec75" class="outline-3">
<h3 id="h:0563f432-6332-4c70-ae1f-a43ec5deec75"><a href="#h:0563f432-6332-4c70-ae1f-a43ec5deec75">单向链表（概念篇）</a></h3>
<div class="outline-text-3" id="text-h:0563f432-6332-4c70-ae1f-a43ec5deec75">
<p>
单项链表的增删改查、单项链表的应用
</p>
</div>
<div id="outline-container-h:f2aef0fa-a2ce-43dc-a8c2-65504a2be8ec" class="outline-4">
<h4 id="h:f2aef0fa-a2ce-43dc-a8c2-65504a2be8ec"><a href="#h:f2aef0fa-a2ce-43dc-a8c2-65504a2be8ec">单向链表的概念</a></h4>
<div class="outline-text-4" id="text-h:f2aef0fa-a2ce-43dc-a8c2-65504a2be8ec">
<p>
对于顺序存储的结构，最大的缺点就是: 插入和删除的时候需要移动大量的元素，所以基于前人的智慧，他们发明了链表。
</p>

<p>
链表是由一个个结点组成，每个结点之间通过链接关系串联起来，每个结点都有一个后继结点，最后一个结点的后继结点为空结点，如图所示。
</p>


<figure id="orgf87efa7">
<img src="././images/img-2025102313.png" alt="img-2025102313.png" width="50%">

</figure>

<p>
由链接关系A-&gt;B组织起来的两个结点，B被称为A的后继结点，A被称为B的前驱结点。链表分为单向链表、双向链表、循环链表等等。本文只介绍单向链表。
</p>

<p>
一个链表结点由两部分组成: 数据域和指针域。数据可以是任意类型，由编码的人自行指定。指针域指向后继结点的地址。一个结点包含的两部分如下图所示:
</p>


<figure id="orgf4f4a00">
<img src="././images/img-2025102314.png" alt="img-2025102314.png" width="50%">

</figure>
</div>
</div>
<div id="outline-container-h:94020b32-637f-40c1-9b89-9bcd79ab911e" class="outline-4">
<h4 id="h:94020b32-637f-40c1-9b89-9bcd79ab911e"><a href="#h:94020b32-637f-40c1-9b89-9bcd79ab911e">单向链表的元素插入</a></h4>
<div class="outline-text-4" id="text-h:94020b32-637f-40c1-9b89-9bcd79ab911e">
<p>
元素插入的概念
</p>
<ul class="org-ul">
<li>单向链表的元素插入，就是指给定一个索引i和一个元素data，生成一个值为data的结点，并且插入到第i个位置上。</li>
</ul>


<p>
元素插入图解
</p>
<ul class="org-ul">
<li>本次插入操作，是给定一个数值5，要求插入到单向链表的索引为4的位置上。</li>
<li>p(即pre)代表目前正在遍历的结点，当计数到3的时候，p的后继结点a(即aft)也找到了，然后生成值为5的结点vtx，将p的后继指向vtx，将vtx的后继指向a。</li>
</ul>


<figure id="orga675d9f">
<img src="././images/img-2025102315.gif" alt="img-2025102315.gif" width="50%">

</figure>

<p>
元素插入的步骤
</p>
<ul class="org-ul">
<li>第1步、判断插入位置是否合法，如果不合法则抛出异常(比如: 原本只有5个元素，给定的索引是100，那显然这个位置是不合法的)。</li>
<li>第2步、对给定的元素，生成一个链表结点。</li>
<li>第3步、如果插入位置是0，则直接把生成的结点的后继结点，设置为当前的链表头结点，并且把生成的结点设置为新的链表头。</li>
<li>第4步、如果插入位置不是0，则遍历到插入位置的前一个位置，把生成的结点插入进来。</li>
<li>第5步、更新链表的大小，即对链表的大小执行加一操作。</li>
</ul>
</div>
</div>
<div id="outline-container-h:0cb254a0-08eb-4c79-b687-2f9b65d949c4" class="outline-4">
<h4 id="h:0cb254a0-08eb-4c79-b687-2f9b65d949c4"><a href="#h:0cb254a0-08eb-4c79-b687-2f9b65d949c4">单向链表的元素删除</a></h4>
<div class="outline-text-4" id="text-h:0cb254a0-08eb-4c79-b687-2f9b65d949c4">
<p>
元素删除的概念
</p>
<ul class="org-ul">
<li>单向链表的元素删除，就是指给定一个索引i，将从链表头开始数到的第i个结点删除</li>
</ul>

<p>
元素删除的图解
</p>
<ul class="org-ul">
<li>要求删除索引为4的链表结点，从前往后遍历链表，当遍历到到索引为3的链表结点，则将它的后继结点存储到del中，并且将它的后继指向它后继的后继。</li>
</ul>


<figure id="orge5efaeb">
<img src="././images/img-2025102316.gif" alt="img-2025102316.gif" width="50%">

</figure>

<p>
要求删除索引为 4 的链表结点，从前往后遍历链表，当遍历到索引 3 的链表结点，则将它的后继结点来存储到 del 中，并且将它的后继指向它后继的后继。
</p>

<p>
元素删除的步骤
</p>
<ul class="org-ul">
<li>第1步、判断删除位置是否合法，如果不合法则抛出异常。</li>
<li>第2步、如果删除位置为首个结点，直接把链表头更新为它的后继结点。</li>
<li>第3步、如果删除位置非首个结点，则遍历到要删除位置的前一个结点，并且把前一个结点的后继结点设置为它后继的后继。</li>
<li>第4步、更新链表的大小，也就是将链表的大小执行减一操作。</li>
</ul>
</div>
</div>
<div id="outline-container-h:92de0588-4373-4589-8ead-a16b58136d57" class="outline-4">
<h4 id="h:92de0588-4373-4589-8ead-a16b58136d57"><a href="#h:92de0588-4373-4589-8ead-a16b58136d57">单向链表的元素查找</a></h4>
<div class="outline-text-4" id="text-h:92de0588-4373-4589-8ead-a16b58136d57">
<p>
元素查找的概念
</p>
<ul class="org-ul">
<li>单向链表的元素查找，是指在链表中查找指定元素x是否存在，如果存在则返回该结点，否则返回NULL。由于需要遍历整个链表进行元素对比，所以查找的时间复杂度为0(n)。</li>
</ul>

<p>
元素查找的图解
</p>
<ul class="org-ul">
<li>如图所示，要求查找值为8的结点，从链表头结点开始遍历，直到遍历到值为8到结点以后，返回这个结点。
<ul class="org-ul">
<li>每次遍历，把当前节点存储在这个tmp中，每次把tmp改成它的后继，这个迭代就完成了。</li>
</ul></li>
</ul>


<figure id="org808e471">
<img src="././images/img-2025102317.gif" alt="img-2025102317.gif" width="50%">

</figure>

<p>
元素查找的步骤
</p>
<ul class="org-ul">
<li>第1步、遍历整个链表，对链表中的每个元素，和指定元素进行比较，如果相等则返回当前遍历到的结点;</li>
<li>第2步、如果遍历完整个链表，都没有找到相等的元素，则返回NULL;</li>
</ul>
</div>
</div>
<div id="outline-container-h:0e7d5dcb-fb5c-4ad4-bc2a-25a00540eaa7" class="outline-4">
<h4 id="h:0e7d5dcb-fb5c-4ad4-bc2a-25a00540eaa7"><a href="#h:0e7d5dcb-fb5c-4ad4-bc2a-25a00540eaa7">单向链表的元素索引</a></h4>
<div class="outline-text-4" id="text-h:0e7d5dcb-fb5c-4ad4-bc2a-25a00540eaa7">
<p>
元素素引的概念
</p>
<ul class="org-ul">
<li>单向链表的元素索引，是指给定一个索引值i，从链表头结点开始数，数到第 i个结点并且返回它，时间复杂度0(n)。</li>
</ul>

<p>
元素索引的图解
</p>
<ul class="org-ul">
<li>给定的索引值是5，tmp代表当前遍历到的结点，记录一个变量j，j自增的过程，判断是否和5相等，如果相等则代表找到对应的结点，直接返回图中值为8的结点。</li>
</ul>


<figure id="orgb638d4e">
<img src="././images/img-2025102318.gif" alt="img-2025102318.gif" width="50%">

</figure>

<p>
元素素引的步骤
</p>
<ul class="org-ul">
<li>第1步、首先判断给定的索引是否合法，不合法就抛出异常;</li>
<li>第2步、直接通过索引访问即可获得对应的元素;</li>
</ul>
</div>
</div>
<div id="outline-container-h:da9d2e8b-491a-42d1-8a29-e2df7ed2aa5f" class="outline-4">
<h4 id="h:da9d2e8b-491a-42d1-8a29-e2df7ed2aa5f"><a href="#h:da9d2e8b-491a-42d1-8a29-e2df7ed2aa5f">单向链表的元素修改</a></h4>
<div class="outline-text-4" id="text-h:da9d2e8b-491a-42d1-8a29-e2df7ed2aa5f">
<p>
元素修改的概念
</p>
<ul class="org-ul">
<li>单向链表的元素修改是指将链表中指定索引的元素更新为新的值。</li>
</ul>

<p>
元素素引的图解
</p>
<ul class="org-ul">
<li>如图所示，给定的是5这个索引，首先通过遍历找到对应的结点，然后修改成给定的值。</li>
</ul>


<figure id="org22b880a">
<img src="././images/img-2025102319.gif" alt="img-2025102319.gif" width="50%">

</figure>

<p>
元素修改的步骤
</p>
<ul class="org-ul">
<li>直接通过索引访问即可获得对应的结点，修改成指定的值。</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-h:8f455a3b-d94f-4999-9033-bb4dbbe412a9" class="outline-3">
<h3 id="h:8f455a3b-d94f-4999-9033-bb4dbbe412a9"><a href="#h:8f455a3b-d94f-4999-9033-bb4dbbe412a9">代码篇</a></h3>
<div class="outline-text-3" id="text-h:8f455a3b-d94f-4999-9033-bb4dbbe412a9">
<p>
c++实现单向链表
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdexcept&gt;</span> <span class="org-comment-delimiter">// </span><span class="org-comment">&#22788;&#29702;&#24322;&#24120;
</span><span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-preprocessor">#define</span> <span class="org-variable-name">eleType</span> <span class="org-type">int</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#32467;&#28857;&#30340;&#32467;&#26500;&#20307;
</span><span class="org-keyword">struct</span> <span class="org-type">ListNode</span> {
    <span class="org-type">eleType</span> <span class="org-variable-name">data</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">&#25968;&#25454;&#22495;
</span>    <span class="org-type">ListNode</span> *<span class="org-variable-name">next</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25351;&#38024;&#22495;
</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">c++&#20013;&#30340;struct&#21644;class&#26159;&#19968;&#26679;&#30340;&#65292;&#21487;&#20197;&#20889;&#26500;&#36896;&#20989;&#25968;
</span>    <span class="org-function-name">ListNode</span>(<span class="org-type">eleType</span> <span class="org-variable-name">x</span>): data(x), next(<span class="org-constant">NULL</span>) {}
};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#21333;&#21521;&#38142;&#34920;&#30340;&#31867;
</span><span class="org-keyword">class</span> <span class="org-type">LinkedList</span> {
<span class="org-keyword">private</span>:
    <span class="org-type">ListNode</span>* <span class="org-variable-name">head</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22836;&#32467;&#28857;
</span>    <span class="org-type">int</span> <span class="org-variable-name">size</span>;       <span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#20803;&#32032;&#20010;&#25968;
</span><span class="org-keyword">public</span>:
    <span class="org-function-name">LinkedList</span>(): head(<span class="org-constant">NULL</span>), size(0) {}
    ~<span class="org-function-name">LinkedList</span>();
    <span class="org-type">void</span> <span class="org-function-name">insert</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>, <span class="org-type">eleType</span> <span class="org-variable-name">value</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">i&#20301;&#32622;&#25554;&#20837;&#20540;&#20026;value&#30340;&#20803;&#32032;
</span>    <span class="org-type">void</span> <span class="org-function-name">remove</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>);                <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;&#31532;i&#20010;&#32467;&#28857;
</span>    <span class="org-type">ListNode</span>* <span class="org-function-name">find</span>(<span class="org-type">eleType</span> <span class="org-variable-name">value</span>);     <span class="org-comment-delimiter">// </span><span class="org-comment">&#26597;&#25214;&#20540;&#20026;value&#30340;&#32467;&#28857;&#65292;&#36820;&#22238;&#32467;&#28857;&#26412;&#36523;
</span>    <span class="org-type">ListNode</span>* <span class="org-function-name">get</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>);              <span class="org-comment-delimiter">// </span><span class="org-comment">i &#32034;&#24341;&#20301;&#32622;&#12290;&#33719;&#21462;&#38142;&#34920;&#30340;&#31532;&#20960;&#20010;&#32467;&#28857;
</span>    <span class="org-type">void</span> <span class="org-function-name">update</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>, <span class="org-type">eleType</span> <span class="org-variable-name">value</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#26356;&#26032;&#31532;i&#20010;&#32467;&#28857;&#30340;&#20540;
</span>    <span class="org-type">void</span> <span class="org-function-name">print</span>();                      <span class="org-comment-delimiter">// </span><span class="org-comment">&#25171;&#21360;&#38142;&#34920;
</span>};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#20219;&#20309;&#19968;&#20010;&#25968;&#25454;&#32467;&#26500;&#20854;&#23454;&#37117;&#26159;&#22686;&#21024;&#25913;&#26597;
</span><span class="org-constant">LinkedList</span>::~<span class="org-function-name">LinkedList</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#27599;&#20010;&#32467;&#28857;&#30340;&#20869;&#23384;&#31354;&#38388;&#26512;&#26500;&#25481;
</span>    <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22836;&#32467;&#28857;&#36171;&#20540;&#32473;current
</span>    <span class="org-keyword">while</span> (curr != <span class="org-constant">NULL</span>) {
        <span class="org-type">ListNode</span>* <span class="org-variable-name">tmp</span> = curr;
        curr = curr-&gt;next;
        <span class="org-keyword">delete</span> tmp;
    }
}

<span class="org-type">void</span> <span class="org-constant">LinkedList</span>::<span class="org-function-name">insert</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>, <span class="org-type">eleType</span> <span class="org-variable-name">value</span>) {
    <span class="org-keyword">if</span> (<span class="org-type">i</span> &lt;0 || i &gt; <span class="org-variable-name">size</span>) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::out_of_range(<span class="org-string">"Invlid position"</span>);
    }
    <span class="org-type">ListNode</span>* <span class="org-variable-name">newNode</span> = <span class="org-keyword">new</span> <span class="org-type">ListNode</span>(value);
    <span class="org-keyword">if</span> (i == 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;&#38142;&#34920;&#22836;
</span>        newNode-&gt;next = head;
        head = newNode;
    }
    <span class="org-keyword">else</span> {
        <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#28216;&#26631;&#32467;&#28857;&#65292;&#20174;head&#24320;&#22987;
</span>        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; i - 1; ++j) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#30830;&#23450;&#35201;&#25554;&#20837;&#20301;&#32622;&#30340;&#21069;&#19968;&#20010;&#32467;&#28857;
</span>            curr = curr-&gt;next;
        }
        newNode-&gt;next = curr-&gt;next;
        curr-&gt;next = newNode;
    }
    ++size;
}


<span class="org-type">void</span> <span class="org-constant">LinkedList</span>::<span class="org-function-name">remove</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>) {
    <span class="org-keyword">if</span> (i &lt; 0 || i &gt;= size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::out_of_range(<span class="org-string">"Invalid position"</span>);
    }
    <span class="org-keyword">if</span> (i == 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;&#22836;&#32467;&#28857;
</span>        <span class="org-type">ListNode</span>* <span class="org-variable-name">temp</span> = head;
        head = head-&gt;next;
        <span class="org-keyword">delete</span> temp;
    }
    <span class="org-keyword">else</span> {
        <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head;
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; i - 1; ++j) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#25214;&#21040;&#35201;&#21024;&#38500;&#32467;&#28857;&#30340;&#21069;&#19968;&#20010;&#32467;&#28857;
</span>            curr = curr-&gt;next;
        }
        <span class="org-type">ListNode</span>* <span class="org-variable-name">temp</span> = curr-&gt;next; <span class="org-comment-delimiter">// </span><span class="org-comment">&#35201;&#21024;&#38500;&#30340;&#32467;&#28857;&#23384;&#20648;&#21040;temp&#20013;
</span>        curr-&gt;next = temp-&gt;next;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;&#35201;&#21024;&#38500;&#30340;&#32467;&#28857;&#30340;&#21069;&#39537;&#32467;&#28857;&#30340;&#21518;&#32487;&#65292;&#35774;&#32622;&#20026;&#35201;&#21024;&#38500;&#32467;&#28857;&#30340;&#21518;&#32487;&#32467;&#28857;
</span>        <span class="org-keyword">delete</span> temp;                 <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;&#35201;&#21024;&#38500;&#30340;&#32467;&#28857;
</span>    }
    --size;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#26597;&#25214;&#20540;&#20026;value&#30340;&#32467;&#28857;&#65292;&#36820;&#22238;&#32467;&#28857;&#26412;&#36523;
</span><span class="org-type">ListNode</span>* <span class="org-constant">LinkedList</span>::<span class="org-function-name">find</span>(<span class="org-type">eleType</span> <span class="org-variable-name">value</span>) {
    <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;&#26681;&#32467;&#28857;&#24320;&#22987;
</span>    <span class="org-keyword">while</span> (<span class="org-type">curr</span> &amp;&amp; <span class="org-variable-name">curr</span>-&gt;data != value) {
        curr = curr-&gt;next; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#32467;&#28857;&#21464;&#20026;&#23427;&#30340;&#21518;&#32487;
</span>    }
    <span class="org-keyword">return</span> curr; <span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#36941;&#21382;&#23436;&#27809;&#25214;&#21040;&#36820;&#22238;&#31354;&#32467;&#28857;&#65292;&#25214;&#21040;&#36820;&#22238;data&#20026;value&#30340;&#32467;&#28857;
</span>}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#32034;&#24341;
</span><span class="org-type">ListNode</span>* <span class="org-constant">LinkedList</span>::<span class="org-function-name">get</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>) {
    <span class="org-keyword">if</span> (i &lt; 0 || i &gt;= size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::out_of_range(<span class="org-string">"Invalid position"</span>);
    }
    <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head;         <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#21270;curr&#65292;&#20174;&#22836;&#32467;&#28857;&#24320;&#22987;
</span>    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; i; ++j) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#36845;&#20195;i&#27425;&#65292;&#27599;&#27425;&#25805;&#20316;&#21464;&#20026;&#23427;&#30340;&#21518;&#32487;
</span>        curr = curr-&gt;next;
    }
    <span class="org-keyword">return</span> curr;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#26356;&#26032;&#12290;&#26356;&#26032;&#31532;i&#20010;&#32467;&#28857;&#30340;&#20540;
</span><span class="org-type">void</span> <span class="org-constant">LinkedList</span>::<span class="org-function-name">update</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>, <span class="org-type">eleType</span> <span class="org-variable-name">value</span>) {
    get(i)-&gt;data = value;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#35843;&#35797;&#20989;&#25968;
</span><span class="org-type">void</span> <span class="org-constant">LinkedList</span>::<span class="org-function-name">print</span>() {
    <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head;
    <span class="org-keyword">while</span> (curr) {
        cout &lt;&lt; curr-&gt;data &lt;&lt; <span class="org-string">' '</span>;
        curr = curr-&gt;next; <span class="org-comment-delimiter">// </span><span class="org-comment">curr&#31561;&#20110;&#20182;&#30340;&#21518;&#32487;
</span>    }
    cout &lt;&lt; endl;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">LinkedList</span> <span class="org-variable-name">list</span>;
    list.insert(0, 10);
    list.insert(1, 20);
    list.insert(2, 30);
    list.insert(3, 40);
    list.insert(4, 50);
    list.print();
    list.remove(1);
    list.print();
    list.update(2, 60);
    list.print();
    <span class="org-type">ListNode</span>* <span class="org-variable-name">tmp</span> = list.find(30);
    cout &lt;&lt; tmp-&gt;data &lt;&lt; endl;
    cout &lt;&lt; list.get(3)-&gt;data &lt;&lt; endl;

    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-h:87b2d42a-db27-426c-8711-117f4cf01d72" class="outline-3">
<h3 id="h:87b2d42a-db27-426c-8711-117f4cf01d72"><a href="#h:87b2d42a-db27-426c-8711-117f4cf01d72">实战篇</a></h3>
<div class="outline-text-3" id="text-h:87b2d42a-db27-426c-8711-117f4cf01d72">
</div>
<div id="outline-container-h:3eaef271-dfe9-4db4-9636-f0264e880e50" class="outline-4">
<h4 id="h:3eaef271-dfe9-4db4-9636-f0264e880e50"><a href="#h:3eaef271-dfe9-4db4-9636-f0264e880e50">ACM模式</a></h4>
<div class="outline-text-4" id="text-h:3eaef271-dfe9-4db4-9636-f0264e880e50">
</div>
<div id="outline-container-h:bdbaa645-6f7f-4a17-89f3-edbce5480417" class="outline-5">
<h5 id="h:bdbaa645-6f7f-4a17-89f3-edbce5480417"><a href="#h:bdbaa645-6f7f-4a17-89f3-edbce5480417">1.A+B for Input-Output Practice (IV)</a></h5>
<div class="outline-text-5" id="text-h:bdbaa645-6f7f-4a17-89f3-edbce5480417">
<p>
<a href="https://acm.hdu.edu.cn/showproblem.php?pid=1092">https://acm.hdu.edu.cn/showproblem.php?pid=1092</a>
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdexcept&gt;</span> <span class="org-comment-delimiter">// </span><span class="org-comment">&#22788;&#29702;&#24322;&#24120;
</span><span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-preprocessor">#define</span> <span class="org-variable-name">eleType</span> <span class="org-type">int</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#32467;&#28857;&#30340;&#32467;&#26500;&#20307;
</span><span class="org-keyword">struct</span> <span class="org-type">ListNode</span> {
    <span class="org-type">eleType</span> <span class="org-variable-name">data</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">&#25968;&#25454;&#22495;
</span>    <span class="org-type">ListNode</span> *<span class="org-variable-name">next</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25351;&#38024;&#22495;
</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">c++&#20013;&#30340;struct&#21644;class&#26159;&#19968;&#26679;&#30340;&#65292;&#21487;&#20197;&#20889;&#26500;&#36896;&#20989;&#25968;
</span>    <span class="org-function-name">ListNode</span>(<span class="org-type">eleType</span> <span class="org-variable-name">x</span>): data(x), next(<span class="org-constant">NULL</span>) {}
};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#21333;&#21521;&#38142;&#34920;&#30340;&#31867;
</span><span class="org-keyword">class</span> <span class="org-type">LinkedList</span> {
<span class="org-keyword">private</span>:
    <span class="org-type">ListNode</span>* <span class="org-variable-name">head</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22836;&#32467;&#28857;
</span>    <span class="org-type">int</span> <span class="org-variable-name">size</span>;       <span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#20803;&#32032;&#20010;&#25968;
</span><span class="org-keyword">public</span>:
    <span class="org-function-name">LinkedList</span>(): head(<span class="org-constant">NULL</span>), size(0) {}
    ~<span class="org-function-name">LinkedList</span>();
    <span class="org-type">void</span> <span class="org-function-name">insert</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>, <span class="org-type">eleType</span> <span class="org-variable-name">value</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">i&#20301;&#32622;&#25554;&#20837;&#20540;&#20026;value&#30340;&#20803;&#32032;
</span>    <span class="org-type">void</span> <span class="org-function-name">remove</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>);                <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;&#31532;i&#20010;&#32467;&#28857;
</span>    <span class="org-type">ListNode</span>* <span class="org-function-name">find</span>(<span class="org-type">eleType</span> <span class="org-variable-name">value</span>);     <span class="org-comment-delimiter">// </span><span class="org-comment">&#26597;&#25214;&#20540;&#20026;value&#30340;&#32467;&#28857;&#65292;&#36820;&#22238;&#32467;&#28857;&#26412;&#36523;
</span>    <span class="org-type">ListNode</span>* <span class="org-function-name">get</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>);              <span class="org-comment-delimiter">// </span><span class="org-comment">i &#32034;&#24341;&#20301;&#32622;&#12290;&#33719;&#21462;&#38142;&#34920;&#30340;&#31532;&#20960;&#20010;&#32467;&#28857;
</span>    <span class="org-type">void</span> <span class="org-function-name">update</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>, <span class="org-type">eleType</span> <span class="org-variable-name">value</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#26356;&#26032;&#31532;i&#20010;&#32467;&#28857;&#30340;&#20540;
</span>    <span class="org-type">void</span> <span class="org-function-name">print</span>();                      <span class="org-comment-delimiter">// </span><span class="org-comment">&#25171;&#21360;&#38142;&#34920;
</span>    <span class="org-type">eleType</span> <span class="org-function-name">sum</span>();                     <span class="org-comment-delimiter">// </span><span class="org-comment">&#27714;&#38142;&#34920;&#20013;&#25152;&#26377;&#20803;&#32032;&#30340;&#21644;
</span>};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#20219;&#20309;&#19968;&#20010;&#25968;&#25454;&#32467;&#26500;&#20854;&#23454;&#37117;&#26159;&#22686;&#21024;&#25913;&#26597;
</span><span class="org-constant">LinkedList</span>::~<span class="org-function-name">LinkedList</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#27599;&#20010;&#32467;&#28857;&#30340;&#20869;&#23384;&#31354;&#38388;&#26512;&#26500;&#25481;
</span>    <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22836;&#32467;&#28857;&#36171;&#20540;&#32473;current
</span>    <span class="org-keyword">while</span> (curr != <span class="org-constant">NULL</span>) {
        <span class="org-type">ListNode</span>* <span class="org-variable-name">tmp</span> = curr;
        curr = curr-&gt;next;
        <span class="org-keyword">delete</span> tmp;
    }
}

<span class="org-type">void</span> <span class="org-constant">LinkedList</span>::<span class="org-function-name">insert</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>, <span class="org-type">eleType</span> <span class="org-variable-name">value</span>) {
    <span class="org-keyword">if</span> (<span class="org-type">i</span> &lt;0 || i &gt; <span class="org-variable-name">size</span>) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::out_of_range(<span class="org-string">"Invlid position"</span>);
    }
    <span class="org-type">ListNode</span>* <span class="org-variable-name">newNode</span> = <span class="org-keyword">new</span> <span class="org-type">ListNode</span>(value);
    <span class="org-keyword">if</span> (i == 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;&#38142;&#34920;&#22836;
</span>        newNode-&gt;next = head;
        head = newNode;
    }
    <span class="org-keyword">else</span> {
        <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#28216;&#26631;&#32467;&#28857;&#65292;&#20174;head&#24320;&#22987;
</span>        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; i - 1; ++j) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#30830;&#23450;&#35201;&#25554;&#20837;&#20301;&#32622;&#30340;&#21069;&#19968;&#20010;&#32467;&#28857;
</span>            curr = curr-&gt;next;
        }
        newNode-&gt;next = curr-&gt;next;
        curr-&gt;next = newNode;
    }
    ++size;
}

<span class="org-type">void</span> <span class="org-constant">LinkedList</span>::<span class="org-function-name">remove</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>) {
    <span class="org-keyword">if</span> (i &lt; 0 || i &gt;= size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::out_of_range(<span class="org-string">"Invalid position"</span>);
    }
    <span class="org-keyword">if</span> (i == 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;&#22836;&#32467;&#28857;
</span>        <span class="org-type">ListNode</span>* <span class="org-variable-name">temp</span> = head;
        head = head-&gt;next;
        <span class="org-keyword">delete</span> temp;
    }
    <span class="org-keyword">else</span> {
        <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head;
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; i - 1; ++j) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#25214;&#21040;&#35201;&#21024;&#38500;&#32467;&#28857;&#30340;&#21069;&#19968;&#20010;&#32467;&#28857;
</span>            curr = curr-&gt;next;
        }
        <span class="org-type">ListNode</span>* <span class="org-variable-name">temp</span> = curr-&gt;next; <span class="org-comment-delimiter">// </span><span class="org-comment">&#35201;&#21024;&#38500;&#30340;&#32467;&#28857;&#23384;&#20648;&#21040;temp&#20013;
</span>        curr-&gt;next = temp-&gt;next;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;&#35201;&#21024;&#38500;&#30340;&#32467;&#28857;&#30340;&#21069;&#39537;&#32467;&#28857;&#30340;&#21518;&#32487;&#65292;&#35774;&#32622;&#20026;&#35201;&#21024;&#38500;&#32467;&#28857;&#30340;&#21518;&#32487;&#32467;&#28857;
</span>        <span class="org-keyword">delete</span> temp;                 <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;&#35201;&#21024;&#38500;&#30340;&#32467;&#28857;
</span>    }
    --size;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#26597;&#25214;&#20540;&#20026;value&#30340;&#32467;&#28857;&#65292;&#36820;&#22238;&#32467;&#28857;&#26412;&#36523;
</span><span class="org-type">ListNode</span>* <span class="org-constant">LinkedList</span>::<span class="org-function-name">find</span>(<span class="org-type">eleType</span> <span class="org-variable-name">value</span>) {
    <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;&#26681;&#32467;&#28857;&#24320;&#22987;
</span>    <span class="org-keyword">while</span> (<span class="org-type">curr</span> &amp;&amp; <span class="org-variable-name">curr</span>-&gt;data != value) {
        curr = curr-&gt;next; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#32467;&#28857;&#21464;&#20026;&#23427;&#30340;&#21518;&#32487;
</span>    }
    <span class="org-keyword">return</span> curr; <span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#36941;&#21382;&#23436;&#27809;&#25214;&#21040;&#36820;&#22238;&#31354;&#32467;&#28857;&#65292;&#25214;&#21040;&#36820;&#22238;data&#20026;value&#30340;&#32467;&#28857;
</span>}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#32034;&#24341;
</span><span class="org-type">ListNode</span>* <span class="org-constant">LinkedList</span>::<span class="org-function-name">get</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>) {
    <span class="org-keyword">if</span> (i &lt; 0 || i &gt;= size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::out_of_range(<span class="org-string">"Invalid position"</span>);
    }
    <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head;         <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#21270;curr&#65292;&#20174;&#22836;&#32467;&#28857;&#24320;&#22987;
</span>    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; i; ++j) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#36845;&#20195;i&#27425;&#65292;&#27599;&#27425;&#25805;&#20316;&#21464;&#20026;&#23427;&#30340;&#21518;&#32487;
</span>        curr = curr-&gt;next;
    }
    <span class="org-keyword">return</span> curr;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#26356;&#26032;&#12290;&#26356;&#26032;&#31532;i&#20010;&#32467;&#28857;&#30340;&#20540;
</span><span class="org-type">void</span> <span class="org-constant">LinkedList</span>::<span class="org-function-name">update</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>, <span class="org-type">eleType</span> <span class="org-variable-name">value</span>) {
    get(i)-&gt;data = value;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#35843;&#35797;&#20989;&#25968;
</span><span class="org-type">void</span> <span class="org-constant">LinkedList</span>::<span class="org-function-name">print</span>() {
    <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head;
    <span class="org-keyword">while</span> (curr) {
        cout &lt;&lt; curr-&gt;data &lt;&lt; <span class="org-string">' '</span>;
        curr = curr-&gt;next; <span class="org-comment-delimiter">// </span><span class="org-comment">curr&#31561;&#20110;&#20182;&#30340;&#21518;&#32487;
</span>    }
    cout &lt;&lt; endl;
}

<span class="org-type">eleType</span> <span class="org-constant">LinkedList</span>::<span class="org-function-name">sum</span>() {
    <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head;
    <span class="org-type">eleType</span> <span class="org-variable-name">ret</span> = 0;
    <span class="org-keyword">while</span> (curr) {
        ret += curr-&gt;data;
        curr = curr-&gt;next;
    }
    <span class="org-keyword">return</span> ret;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">n</span>;
    <span class="org-keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) {
        <span class="org-type">LinkedList</span> <span class="org-variable-name">l</span>;
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; ++i) {
            <span class="org-type">int</span> <span class="org-variable-name">x</span>;
            cin &gt;&gt; x;
            l.insert(i, x);
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">l.print();
</span>        cout &lt;&lt; l.sum() &lt;&lt; endl;
    }

    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-h:7b5eb6e1-50fb-481b-b3a7-5a1a32a1c5d5" class="outline-5">
<h5 id="h:7b5eb6e1-50fb-481b-b3a7-5a1a32a1c5d5"><a href="#h:7b5eb6e1-50fb-481b-b3a7-5a1a32a1c5d5">2.超级楼梯</a></h5>
<div class="outline-text-5" id="text-h:7b5eb6e1-50fb-481b-b3a7-5a1a32a1c5d5">
<p>
<a href="https://acm.hdu.edu.cn/showproblem.php?pid=2041">https://acm.hdu.edu.cn/showproblem.php?pid=2041</a>
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdexcept&gt;</span> <span class="org-comment-delimiter">// </span><span class="org-comment">&#22788;&#29702;&#24322;&#24120;
</span><span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-preprocessor">#define</span> <span class="org-variable-name">eleType</span> <span class="org-type">int</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#32467;&#28857;&#30340;&#32467;&#26500;&#20307;
</span><span class="org-keyword">struct</span> <span class="org-type">ListNode</span> {
    <span class="org-type">eleType</span> <span class="org-variable-name">data</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">&#25968;&#25454;&#22495;
</span>    <span class="org-type">ListNode</span> *<span class="org-variable-name">next</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25351;&#38024;&#22495;
</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">c++&#20013;&#30340;struct&#21644;class&#26159;&#19968;&#26679;&#30340;&#65292;&#21487;&#20197;&#20889;&#26500;&#36896;&#20989;&#25968;
</span>    <span class="org-function-name">ListNode</span>(<span class="org-type">eleType</span> <span class="org-variable-name">x</span>): data(x), next(<span class="org-constant">NULL</span>) {}
};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#21333;&#21521;&#38142;&#34920;&#30340;&#31867;
</span><span class="org-keyword">class</span> <span class="org-type">LinkedList</span> {
<span class="org-keyword">private</span>:
    <span class="org-type">ListNode</span>* <span class="org-variable-name">head</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22836;&#32467;&#28857;
</span>    <span class="org-type">int</span> <span class="org-variable-name">size</span>;       <span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#20803;&#32032;&#20010;&#25968;
</span><span class="org-keyword">public</span>:
    <span class="org-function-name">LinkedList</span>(): head(<span class="org-constant">NULL</span>), size(0) {}
    ~<span class="org-function-name">LinkedList</span>();
    <span class="org-type">void</span> <span class="org-function-name">insert</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>, <span class="org-type">eleType</span> <span class="org-variable-name">value</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">i&#20301;&#32622;&#25554;&#20837;&#20540;&#20026;value&#30340;&#20803;&#32032;
</span>    <span class="org-type">void</span> <span class="org-function-name">remove</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>);                <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;&#31532;i&#20010;&#32467;&#28857;
</span>    <span class="org-type">ListNode</span>* <span class="org-function-name">find</span>(<span class="org-type">eleType</span> <span class="org-variable-name">value</span>);     <span class="org-comment-delimiter">// </span><span class="org-comment">&#26597;&#25214;&#20540;&#20026;value&#30340;&#32467;&#28857;&#65292;&#36820;&#22238;&#32467;&#28857;&#26412;&#36523;
</span>    <span class="org-type">ListNode</span>* <span class="org-function-name">get</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>);              <span class="org-comment-delimiter">// </span><span class="org-comment">i &#32034;&#24341;&#20301;&#32622;&#12290;&#33719;&#21462;&#38142;&#34920;&#30340;&#31532;&#20960;&#20010;&#32467;&#28857;
</span>    <span class="org-type">void</span> <span class="org-function-name">update</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>, <span class="org-type">eleType</span> <span class="org-variable-name">value</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#26356;&#26032;&#31532;i&#20010;&#32467;&#28857;&#30340;&#20540;
</span>    <span class="org-type">void</span> <span class="org-function-name">print</span>();                      <span class="org-comment-delimiter">// </span><span class="org-comment">&#25171;&#21360;&#38142;&#34920;
</span>};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#20219;&#20309;&#19968;&#20010;&#25968;&#25454;&#32467;&#26500;&#20854;&#23454;&#37117;&#26159;&#22686;&#21024;&#25913;&#26597;
</span><span class="org-constant">LinkedList</span>::~<span class="org-function-name">LinkedList</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#27599;&#20010;&#32467;&#28857;&#30340;&#20869;&#23384;&#31354;&#38388;&#26512;&#26500;&#25481;
</span>    <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22836;&#32467;&#28857;&#36171;&#20540;&#32473;current
</span>    <span class="org-keyword">while</span> (curr != <span class="org-constant">NULL</span>) {
        <span class="org-type">ListNode</span>* <span class="org-variable-name">tmp</span> = curr;
        curr = curr-&gt;next;
        <span class="org-keyword">delete</span> tmp;
    }
}

<span class="org-type">void</span> <span class="org-constant">LinkedList</span>::<span class="org-function-name">insert</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>, <span class="org-type">eleType</span> <span class="org-variable-name">value</span>) {
    <span class="org-keyword">if</span> (<span class="org-type">i</span> &lt;0 || i &gt; <span class="org-variable-name">size</span>) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::out_of_range(<span class="org-string">"Invlid position"</span>);
    }
    <span class="org-type">ListNode</span>* <span class="org-variable-name">newNode</span> = <span class="org-keyword">new</span> <span class="org-type">ListNode</span>(value);
    <span class="org-keyword">if</span> (i == 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;&#38142;&#34920;&#22836;
</span>        newNode-&gt;next = head;
        head = newNode;
    }
    <span class="org-keyword">else</span> {
        <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head;            <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#28216;&#26631;&#32467;&#28857;&#65292;&#20174;head&#24320;&#22987;
</span>        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; i - 1; j++) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#30830;&#23450;&#35201;&#25554;&#20837;&#20301;&#32622;&#30340;&#21069;&#19968;&#20010;&#32467;&#28857;
</span>            curr = curr-&gt;next;
        }
        newNode-&gt;next = curr-&gt;next;
        curr-&gt;next = newNode;
    }
    size++;
}

<span class="org-type">void</span> <span class="org-constant">LinkedList</span>::<span class="org-function-name">remove</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>) {
    <span class="org-keyword">if</span> (i &lt; 0 || i &gt;= size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::out_of_range(<span class="org-string">"Invalid position"</span>);
    }
    <span class="org-keyword">if</span> (i == 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;&#22836;&#32467;&#28857;
</span>        <span class="org-type">ListNode</span>* <span class="org-variable-name">temp</span> = head;
        head = head-&gt;next;
        <span class="org-keyword">delete</span> temp;
    }
    <span class="org-keyword">else</span> {
        <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head;
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; i - 1; j++) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#25214;&#21040;&#35201;&#21024;&#38500;&#32467;&#28857;&#30340;&#21069;&#19968;&#20010;&#32467;&#28857;
</span>            curr = curr-&gt;next;
        }
        <span class="org-type">ListNode</span>* <span class="org-variable-name">temp</span> = curr-&gt;next; <span class="org-comment-delimiter">// </span><span class="org-comment">&#35201;&#21024;&#38500;&#30340;&#32467;&#28857;&#23384;&#20648;&#21040;temp&#20013;
</span>        curr-&gt;next = temp-&gt;next;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;&#35201;&#21024;&#38500;&#30340;&#32467;&#28857;&#30340;&#21069;&#39537;&#32467;&#28857;&#30340;&#21518;&#32487;&#65292;&#35774;&#32622;&#20026;&#35201;&#21024;&#38500;&#32467;&#28857;&#30340;&#21518;&#32487;&#32467;&#28857;
</span>        <span class="org-keyword">delete</span> temp;                 <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;&#35201;&#21024;&#38500;&#30340;&#32467;&#28857;
</span>    }
    size--;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#26597;&#25214;&#20540;&#20026;value&#30340;&#32467;&#28857;&#65292;&#36820;&#22238;&#32467;&#28857;&#26412;&#36523;
</span><span class="org-type">ListNode</span>* <span class="org-constant">LinkedList</span>::<span class="org-function-name">find</span>(<span class="org-type">eleType</span> <span class="org-variable-name">value</span>) {
    <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;&#26681;&#32467;&#28857;&#24320;&#22987;
</span>    <span class="org-keyword">while</span> (<span class="org-type">curr</span> &amp;&amp; <span class="org-variable-name">curr</span>-&gt;data != value) {
        curr = curr-&gt;next;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#32467;&#28857;&#21464;&#20026;&#23427;&#30340;&#21518;&#32487;
</span>    }
    <span class="org-keyword">return</span> curr; <span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#36941;&#21382;&#23436;&#27809;&#25214;&#21040;&#36820;&#22238;&#31354;&#32467;&#28857;&#65292;&#25214;&#21040;&#36820;&#22238;data&#20026;value&#30340;&#32467;&#28857;
</span>}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#32034;&#24341;
</span><span class="org-type">ListNode</span>* <span class="org-constant">LinkedList</span>::<span class="org-function-name">get</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>) {
    <span class="org-keyword">if</span> (i &lt; 0 || i &gt;= size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::out_of_range(<span class="org-string">"Invalid position"</span>);
    }
    <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head;         <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#21270;curr&#65292;&#20174;&#22836;&#32467;&#28857;&#24320;&#22987;
</span>    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; i; ++j) {  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36845;&#20195;i&#27425;&#65292;&#27599;&#27425;&#25805;&#20316;&#21464;&#20026;&#23427;&#30340;&#21518;&#32487;
</span>        curr = curr-&gt;next;
    }
    <span class="org-keyword">return</span> curr;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#26356;&#26032;&#12290;&#26356;&#26032;&#31532;i&#20010;&#32467;&#28857;&#30340;&#20540;
</span><span class="org-type">void</span> <span class="org-constant">LinkedList</span>::<span class="org-function-name">update</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>, <span class="org-type">eleType</span> <span class="org-variable-name">value</span>) {
    <span class="org-keyword">if</span> (i &lt; 0 || i &gt;= size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::out_of_range(<span class="org-string">"Invalid position"</span>);
    }
    get(i)-&gt;data = value;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#35843;&#35797;&#20989;&#25968;
</span><span class="org-type">void</span> <span class="org-constant">LinkedList</span>::<span class="org-function-name">print</span>() {
    <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head;
    <span class="org-keyword">while</span> (curr != <span class="org-constant">NULL</span>) {
        cout &lt;&lt; curr-&gt;data;
        curr = curr-&gt;next; <span class="org-comment-delimiter">// </span><span class="org-comment">curr&#31561;&#20110;&#20182;&#30340;&#21518;&#32487;
</span>        <span class="org-keyword">if</span> (curr) {
            cout &lt;&lt; <span class="org-string">" "</span>;
        }
        <span class="org-keyword">else</span> {
            cout &lt;&lt; endl;
        }
    }
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">LinkedList</span> <span class="org-variable-name">f</span>;
    f.insert(0, 1);
    f.insert(1, 1);
    f.insert(2, 1);
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 3; i &lt;= 40; ++i) {
        <span class="org-type">ListNode</span>* <span class="org-variable-name">a</span> = f.get(i - 1);
        <span class="org-type">ListNode</span>* <span class="org-variable-name">b</span> = f.get(i - 2);
        f.insert(i, a-&gt;data + b-&gt;data);
    }
    <span class="org-comment-delimiter">//</span><span class="org-comment">f.print();
</span>    <span class="org-type">int</span> <span class="org-variable-name">n</span>;
    cin &gt;&gt; n;
    <span class="org-keyword">while</span> (n--) {
        <span class="org-type">int</span> <span class="org-variable-name">x</span>;
        cin &gt;&gt; x;
        cout &lt;&lt; f.get(x)-&gt;data &lt;&lt; endl;
    }

    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-h:791f0902-9d2d-45c8-8be6-31f448a4a394" class="outline-5">
<h5 id="h:791f0902-9d2d-45c8-8be6-31f448a4a394"><a href="#h:791f0902-9d2d-45c8-8be6-31f448a4a394">3.数列有序!</a></h5>
<div class="outline-text-5" id="text-h:791f0902-9d2d-45c8-8be6-31f448a4a394">
<p>
<a href="https://acm.hdu.edu.cn/showproblem.php?pid=2019">https://acm.hdu.edu.cn/showproblem.php?pid=2019</a>
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdexcept&gt;</span> <span class="org-comment-delimiter">// </span><span class="org-comment">&#22788;&#29702;&#24322;&#24120;
</span><span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-preprocessor">#define</span> <span class="org-variable-name">eleType</span> <span class="org-type">int</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#32467;&#28857;&#30340;&#32467;&#26500;&#20307;
</span><span class="org-keyword">struct</span> <span class="org-type">ListNode</span> {
    <span class="org-type">eleType</span> <span class="org-variable-name">data</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">&#25968;&#25454;&#22495;
</span>    <span class="org-type">ListNode</span> *<span class="org-variable-name">next</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25351;&#38024;&#22495;
</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">c++&#20013;&#30340;struct&#21644;class&#26159;&#19968;&#26679;&#30340;&#65292;&#21487;&#20197;&#20889;&#26500;&#36896;&#20989;&#25968;
</span>    <span class="org-function-name">ListNode</span>(<span class="org-type">eleType</span> <span class="org-variable-name">x</span>): data(x), next(<span class="org-constant">NULL</span>) {}
};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#21333;&#21521;&#38142;&#34920;&#30340;&#31867;
</span><span class="org-keyword">class</span> <span class="org-type">LinkedList</span> {
<span class="org-keyword">private</span>:
    <span class="org-type">ListNode</span>* <span class="org-variable-name">head</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22836;&#32467;&#28857;
</span>    <span class="org-type">int</span> <span class="org-variable-name">size</span>;       <span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#20803;&#32032;&#20010;&#25968;
</span><span class="org-keyword">public</span>:
    <span class="org-function-name">LinkedList</span>(): head(<span class="org-constant">NULL</span>), size(0) {}
    ~<span class="org-function-name">LinkedList</span>();
    <span class="org-type">void</span> <span class="org-function-name">insert</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>, <span class="org-type">eleType</span> <span class="org-variable-name">value</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">i&#20301;&#32622;&#25554;&#20837;&#20540;&#20026;value&#30340;&#20803;&#32032;
</span>    <span class="org-type">void</span> <span class="org-function-name">remove</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>);                <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;&#31532;i&#20010;&#32467;&#28857;
</span>    <span class="org-type">ListNode</span>* <span class="org-function-name">find</span>(<span class="org-type">eleType</span> <span class="org-variable-name">value</span>);     <span class="org-comment-delimiter">// </span><span class="org-comment">&#26597;&#25214;&#20540;&#20026;value&#30340;&#32467;&#28857;&#65292;&#36820;&#22238;&#32467;&#28857;&#26412;&#36523;
</span>    <span class="org-type">ListNode</span>* <span class="org-function-name">get</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>);              <span class="org-comment-delimiter">// </span><span class="org-comment">i &#32034;&#24341;&#20301;&#32622;&#12290;&#33719;&#21462;&#38142;&#34920;&#30340;&#31532;&#20960;&#20010;&#32467;&#28857;
</span>    <span class="org-type">void</span> <span class="org-function-name">update</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>, <span class="org-type">eleType</span> <span class="org-variable-name">value</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#26356;&#26032;&#31532;i&#20010;&#32467;&#28857;&#30340;&#20540;
</span>    <span class="org-type">void</span> <span class="org-function-name">print</span>();                      <span class="org-comment-delimiter">// </span><span class="org-comment">&#25171;&#21360;&#38142;&#34920;
</span>    <span class="org-type">eleType</span> <span class="org-function-name">sum</span>();                     <span class="org-comment-delimiter">// </span><span class="org-comment">&#27714;&#38142;&#34920;&#20013;&#25152;&#26377;&#20803;&#32032;&#30340;&#21644;
</span>    <span class="org-type">void</span> <span class="org-function-name">append</span>(<span class="org-type">eleType</span>);              <span class="org-comment-delimiter">// </span><span class="org-comment">&#25554;&#20837;&#20803;&#32032;&#21040;&#38142;&#34920;&#30340;&#23614;&#37096;
</span>    <span class="org-type">void</span> <span class="org-function-name">ascInsert</span>(<span class="org-type">eleType</span> <span class="org-variable-name">value</span>);     <span class="org-comment-delimiter">// </span><span class="org-comment">&#25353;&#36882;&#22686;&#39034;&#24207;&#36827;&#34892;&#25554;&#20837;
</span>};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#20219;&#20309;&#19968;&#20010;&#25968;&#25454;&#32467;&#26500;&#20854;&#23454;&#37117;&#26159;&#22686;&#21024;&#25913;&#26597;
</span><span class="org-constant">LinkedList</span>::~<span class="org-function-name">LinkedList</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#27599;&#20010;&#32467;&#28857;&#30340;&#20869;&#23384;&#31354;&#38388;&#26512;&#26500;&#25481;
</span>    <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22836;&#32467;&#28857;&#36171;&#20540;&#32473;current
</span>    <span class="org-keyword">while</span> (curr != <span class="org-constant">NULL</span>) {
        <span class="org-type">ListNode</span>* <span class="org-variable-name">tmp</span> = curr;
        curr = curr-&gt;next;
        <span class="org-keyword">delete</span> tmp;
    }
}

<span class="org-type">void</span> <span class="org-constant">LinkedList</span>::<span class="org-function-name">insert</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>, <span class="org-type">eleType</span> <span class="org-variable-name">value</span>) {
    <span class="org-keyword">if</span> (<span class="org-type">i</span> &lt;0 || i &gt; <span class="org-variable-name">size</span>) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::out_of_range(<span class="org-string">"Invlid position"</span>);
    }
    <span class="org-type">ListNode</span>* <span class="org-variable-name">newNode</span> = <span class="org-keyword">new</span> <span class="org-type">ListNode</span>(value);
    <span class="org-keyword">if</span> (i == 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;&#38142;&#34920;&#22836;
</span>        newNode-&gt;next = head;
        head = newNode;
    }
    <span class="org-keyword">else</span> {
        <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head;            <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#28216;&#26631;&#32467;&#28857;&#65292;&#20174;head&#24320;&#22987;
</span>        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; i - 1; j++) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#30830;&#23450;&#35201;&#25554;&#20837;&#20301;&#32622;&#30340;&#21069;&#19968;&#20010;&#32467;&#28857;
</span>            curr = curr-&gt;next;
        }
        newNode-&gt;next = curr-&gt;next;
        curr-&gt;next = newNode;
    }
    size++;
}

<span class="org-type">void</span> <span class="org-constant">LinkedList</span>::<span class="org-function-name">remove</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>) {
    <span class="org-keyword">if</span> (i &lt; 0 || i &gt;= size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::out_of_range(<span class="org-string">"Invalid position"</span>);
    }
    <span class="org-keyword">if</span> (i == 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;&#22836;&#32467;&#28857;
</span>        <span class="org-type">ListNode</span>* <span class="org-variable-name">temp</span> = head;
        head = head-&gt;next;
        <span class="org-keyword">delete</span> temp;
    }
    <span class="org-keyword">else</span> {
        <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head;
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; i - 1; j++) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#25214;&#21040;&#35201;&#21024;&#38500;&#32467;&#28857;&#30340;&#21069;&#19968;&#20010;&#32467;&#28857;
</span>            curr = curr-&gt;next;
        }
        <span class="org-type">ListNode</span>* <span class="org-variable-name">temp</span> = curr-&gt;next; <span class="org-comment-delimiter">// </span><span class="org-comment">&#35201;&#21024;&#38500;&#30340;&#32467;&#28857;&#23384;&#20648;&#21040;temp&#20013;
</span>        curr-&gt;next = temp-&gt;next;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;&#35201;&#21024;&#38500;&#30340;&#32467;&#28857;&#30340;&#21069;&#39537;&#32467;&#28857;&#30340;&#21518;&#32487;&#65292;&#35774;&#32622;&#20026;&#35201;&#21024;&#38500;&#32467;&#28857;&#30340;&#21518;&#32487;&#32467;&#28857;
</span>        <span class="org-keyword">delete</span> temp;                 <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;&#35201;&#21024;&#38500;&#30340;&#32467;&#28857;
</span>    }
    size--;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#26597;&#25214;&#20540;&#20026;value&#30340;&#32467;&#28857;&#65292;&#36820;&#22238;&#32467;&#28857;&#26412;&#36523;
</span><span class="org-type">ListNode</span>* <span class="org-constant">LinkedList</span>::<span class="org-function-name">find</span>(<span class="org-type">eleType</span> <span class="org-variable-name">value</span>) {
    <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;&#26681;&#32467;&#28857;&#24320;&#22987;
</span>    <span class="org-keyword">while</span> (<span class="org-type">curr</span> &amp;&amp; <span class="org-variable-name">curr</span>-&gt;data != value) {
        curr = curr-&gt;next;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#32467;&#28857;&#21464;&#20026;&#23427;&#30340;&#21518;&#32487;
</span>    }
    <span class="org-keyword">return</span> curr; <span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#36941;&#21382;&#23436;&#27809;&#25214;&#21040;&#36820;&#22238;&#31354;&#32467;&#28857;&#65292;&#25214;&#21040;&#36820;&#22238;data&#20026;value&#30340;&#32467;&#28857;
</span>}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#32034;&#24341;
</span><span class="org-type">ListNode</span>* <span class="org-constant">LinkedList</span>::<span class="org-function-name">get</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>) {
    <span class="org-keyword">if</span> (i &lt; 0 || i &gt;= size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::out_of_range(<span class="org-string">"Invalid position"</span>);
    }
    <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head;         <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#21270;curr&#65292;&#20174;&#22836;&#32467;&#28857;&#24320;&#22987;
</span>    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; i; ++j) {  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36845;&#20195;i&#27425;&#65292;&#27599;&#27425;&#25805;&#20316;&#21464;&#20026;&#23427;&#30340;&#21518;&#32487;
</span>        curr = curr-&gt;next;
    }
    <span class="org-keyword">return</span> curr;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#26356;&#26032;&#12290;&#26356;&#26032;&#31532;i&#20010;&#32467;&#28857;&#30340;&#20540;
</span><span class="org-type">void</span> <span class="org-constant">LinkedList</span>::<span class="org-function-name">update</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span>, <span class="org-type">eleType</span> <span class="org-variable-name">value</span>) {
    <span class="org-keyword">if</span> (i &lt; 0 || i &gt;= size) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::out_of_range(<span class="org-string">"Invalid position"</span>);
    }
    get(i)-&gt;data = value;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#35843;&#35797;&#20989;&#25968;
</span><span class="org-type">void</span> <span class="org-constant">LinkedList</span>::<span class="org-function-name">print</span>() {
    <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head;
    <span class="org-keyword">while</span> (curr != <span class="org-constant">NULL</span>) {
        cout &lt;&lt; curr-&gt;data;
        curr = curr-&gt;next; <span class="org-comment-delimiter">// </span><span class="org-comment">curr&#31561;&#20110;&#20182;&#30340;&#21518;&#32487;
</span>        <span class="org-keyword">if</span> (curr) {
            cout &lt;&lt; <span class="org-string">" "</span>;
        }
        <span class="org-keyword">else</span> {
            cout &lt;&lt; endl;
        }
    }
}

<span class="org-type">eleType</span> <span class="org-constant">LinkedList</span>::<span class="org-function-name">sum</span>() {
    <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head;
    <span class="org-type">eleType</span> <span class="org-variable-name">ret</span> = 0;
    <span class="org-keyword">while</span> (curr) {
        ret += curr-&gt;data;
        curr = curr-&gt;next;
    }
    <span class="org-keyword">return</span> ret;
}

<span class="org-type">void</span> <span class="org-constant">LinkedList</span>::<span class="org-function-name">append</span>(<span class="org-type">eleType</span> <span class="org-variable-name">v</span>) {
    insert(size, v);
}
<span class="org-type">void</span> <span class="org-constant">LinkedList</span>::<span class="org-function-name">ascInsert</span>(<span class="org-type">eleType</span> <span class="org-variable-name">value</span>) {
    <span class="org-keyword">if</span> (size = 0) {
        insert(0, value);
        <span class="org-keyword">return</span>;
    }
    <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head;
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; size; ++i) {
        <span class="org-keyword">if</span> (value &lt;= curr-&gt;data) {
            insert(i, value);
            <span class="org-keyword">return</span>;
        }
        curr = curr-&gt;next;
    }
    insert(size, value);
}


<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-variable-name">x</span>;
    <span class="org-keyword">while</span> (cin &gt;&gt; n &gt;&gt; x) {
        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>n &amp;&amp; <span class="org-negation-char">!</span>x) {
            <span class="org-keyword">break</span>;
        }
        <span class="org-type">LinkedList</span> <span class="org-variable-name">l</span>;
        <span class="org-keyword">while</span> (n--) {
            <span class="org-type">int</span> <span class="org-variable-name">v</span>;
            cin &gt;&gt; v;
            l.append(v);
        }
        l.ascInsert(x);
        l.print();
    }

    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:40d1ef7d-2b30-406b-8497-806ec6217ded" class="outline-4">
<h4 id="h:40d1ef7d-2b30-406b-8497-806ec6217ded"><a href="#h:40d1ef7d-2b30-406b-8497-806ec6217ded">核心代码模式</a></h4>
<div class="outline-text-4" id="text-h:40d1ef7d-2b30-406b-8497-806ec6217ded">
</div>
<div id="outline-container-h:c0120296-680f-460b-a8a8-bb069c23c54b" class="outline-5">
<h5 id="h:c0120296-680f-460b-a8a8-bb069c23c54b"><a href="#h:c0120296-680f-460b-a8a8-bb069c23c54b">单向链表的遍历</a></h5>
<div class="outline-text-5" id="text-h:c0120296-680f-460b-a8a8-bb069c23c54b">
</div>
<ul class="org-ul">
<li><a id="h:0f17234b-7d2b-40bb-872b-378241104ef4"></a><a href="#h:0f17234b-7d2b-40bb-872b-378241104ef4">4.二进制链表转整数</a><br>
<div class="outline-text-6" id="text-h:0f17234b-7d2b-40bb-872b-378241104ef4">
<p>
<a href="https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer/description/">https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#21333;&#38142;&#34920;&#30340;&#24341;&#29992;&#32467;&#28857; head&#12290;&#38142;&#34920;&#20013;&#27599;&#20010;&#32467;&#28857;&#30340;&#20540;&#19981;&#26159; 0 &#23601;&#26159; 1&#12290;&#24050;&#30693;&#27492;&#38142;&#34920;&#26159;&#19968;&#20010;&#25972;&#25968;&#25968;&#23383;&#30340;&#20108;&#36827;&#21046;&#34920;&#31034;&#24418;&#24335;&#12290;

&#35831;&#20320;&#36820;&#22238;&#35813;&#38142;&#34920;&#25152;&#34920;&#31034;&#25968;&#23383;&#30340; &#21313;&#36827;&#21046;&#20540; &#12290;

&#26368;&#39640;&#20301; &#22312;&#38142;&#34920;&#30340;&#22836;&#37096;&#12290;


&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;head = [1,0,1]
&#36755;&#20986;&#65306;5
&#35299;&#37322;&#65306;&#20108;&#36827;&#21046;&#25968; (101) &#36716;&#21270;&#20026;&#21313;&#36827;&#21046;&#25968; (5)

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;head = [0]
&#36755;&#20986;&#65306;0

&#25552;&#31034;&#65306;
&#38142;&#34920;&#19981;&#20026;&#31354;&#12290;
&#38142;&#34920;&#30340;&#32467;&#28857;&#24635;&#25968;&#19981;&#36229;&#36807; 30&#12290;
&#27599;&#20010;&#32467;&#28857;&#30340;&#20540;&#19981;&#26159; 0 &#23601;&#26159; 1&#12290;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     </span><span class="org-doc"><span class="org-doc-markup">ListNode()</span></span><span class="org-doc"> : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">getDecimalValue</span>(<span class="org-type">ListNode</span>* <span class="org-variable-name">head</span>) {
        <span class="org-type">int</span> <span class="org-variable-name">sum</span> = 0;
        <span class="org-keyword">while</span>(head) {
            sum = sum * 2 + head-&gt;val;
            head = head-&gt;next;
        }
        <span class="org-keyword">return</span> sum;
    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:e0078d51-8d08-45ef-a4d0-0850299788e7"></a><a href="#h:e0078d51-8d08-45ef-a4d0-0850299788e7">5.返回倒数第 k 个节点</a><br>
<div class="outline-text-6" id="text-h:e0078d51-8d08-45ef-a4d0-0850299788e7">
<p>
<a href="https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/">https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#23454;&#29616;&#19968;&#31181;&#31639;&#27861;&#65292;&#25214;&#20986;&#21333;&#21521;&#38142;&#34920;&#20013;&#20498;&#25968;&#31532; k &#20010;&#33410;&#28857;&#12290;&#36820;&#22238;&#35813;&#33410;&#28857;&#30340;&#20540;&#12290;

&#27880;&#24847;&#65306;&#26412;&#39064;&#30456;&#23545;&#21407;&#39064;&#31245;&#20316;&#25913;&#21160;

&#31034;&#20363;&#65306;
&#36755;&#20837;&#65306; 1-&gt;2-&gt;3-&gt;4-&gt;5 &#21644; k = 2
&#36755;&#20986;&#65306; 4

&#35828;&#26126;&#65306;
&#32473;&#23450;&#30340; k &#20445;&#35777;&#26159;&#26377;&#25928;&#30340;&#12290;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     </span><span class="org-doc"><span class="org-doc-markup">ListNode()</span></span><span class="org-doc"> : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">kthToLast</span>(<span class="org-type">ListNode</span>* <span class="org-variable-name">head</span>, <span class="org-type">int</span> <span class="org-variable-name">k</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#32463;&#20856;&#31639;&#27861;&#65306;&#24555;&#24930;&#25351;&#38024;
</span>        <span class="org-type">ListNode</span>* <span class="org-variable-name">fast</span> = head; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24555;&#25351;&#38024;&#25351;&#21521;&#38142;&#34920;&#22836;
</span>        <span class="org-keyword">while</span>(k--) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21521;&#21069;&#36208;k&#27493;
</span>            fast = fast-&gt;next;
        }
        <span class="org-type">ListNode</span>* <span class="org-variable-name">slow</span> = head; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24930;&#25351;&#38024;&#25351;&#21521;&#38142;&#34920;&#22836;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#35753;&#24555;&#25351;&#38024;&#21644;&#24930;&#25351;&#38024;&#19968;&#30452;&#36208;&#65292;&#30452;&#21040;&#24555;&#25351;&#38024;&#20026;&#31354;&#20026;&#27490;;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#26102;&#20505;&#24930;&#25351;&#38024;&#25351;&#21521;&#30340;&#23601;&#26159;&#20498;&#25968;&#31532;k&#20010;&#38142;&#34920;&#33410;&#28857;&#20102;
</span>        <span class="org-keyword">while</span>(fast){
            fast = fast-&gt;next;
            slow = slow-&gt;next;
        }
        <span class="org-keyword">return</span> slow-&gt;val;
    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:ba634ac7-b50a-437b-9574-db89a16d3cd5"></a><a href="#h:ba634ac7-b50a-437b-9574-db89a16d3cd5">6.训练计划 II</a><br>
<div class="outline-text-6" id="text-h:ba634ac7-b50a-437b-9574-db89a16d3cd5">
<p>
<a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/description/">https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#23450;&#19968;&#20010;&#22836;&#33410;&#28857;&#20026; head &#30340;&#38142;&#34920;&#29992;&#20110;&#35760;&#24405;&#19968;&#31995;&#21015;&#26680;&#24515;&#32908;&#32676;&#35757;&#32451;&#39033;&#30446;&#32534;&#21495;&#65292;&#35831;&#26597;&#25214;&#24182;&#36820;&#22238;&#20498;&#25968;&#31532; cnt &#20010;&#35757;&#32451;&#39033;&#30446;&#32534;&#21495;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;head = [2,4,7,8], cnt = 1
&#36755;&#20986;&#65306;8

&#25552;&#31034;&#65306;
1 &lt;= head.length &lt;= 100
0 &lt;= head[i] &lt;= 100
1 &lt;= cnt &lt;= head.length
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     </span><span class="org-doc"><span class="org-doc-markup">ListNode()</span></span><span class="org-doc"> : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">ListNode</span>* <span class="org-function-name">trainingPlan</span>(<span class="org-type">ListNode</span>* <span class="org-variable-name">head</span>, <span class="org-type">int</span> <span class="org-variable-name">cnt</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#32463;&#20856;&#31639;&#27861;&#65306;&#24555;&#24930;&#25351;&#38024;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#24555;&#25351;&#38024;&#25351;&#21521;&#38142;&#34920;&#22836;&#65292;&#20808;&#24448;&#21069;&#36208;cnt&#27493;
</span>        <span class="org-type">ListNode</span>* <span class="org-variable-name">fast</span> = head;
        <span class="org-keyword">while</span>(cnt--){
            fast = fast-&gt;next;
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#24930;&#25351;&#38024;&#25351;&#21521;&#38142;&#34920;&#22836;&#65292;&#35753;&#24555;&#25351;&#38024;&#21644;&#24930;&#25351;&#38024;&#19968;&#36208;&#65292;&#30452;&#21040;&#24555;&#25351;&#38024;&#20026;&#31354;&#20026;&#27490;&#12290;
</span>        <span class="org-type">ListNode</span>* <span class="org-variable-name">slow</span> = head;
        <span class="org-keyword">while</span>(fast){
            fast = fast-&gt;next;
            slow = slow-&gt;next;
        }
        <span class="org-keyword">return</span> slow;
    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:5eb67129-befe-4170-a0fb-af1c3101a869"></a><a href="#h:5eb67129-befe-4170-a0fb-af1c3101a869">7.链表的中间结点</a><br>
<div class="outline-text-6" id="text-h:5eb67129-befe-4170-a0fb-af1c3101a869">
<p>
<a href="https://leetcode.cn/problems/middle-of-the-linked-list/description/">https://leetcode.cn/problems/middle-of-the-linked-list/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#21333;&#38142;&#34920;&#30340;&#22836;&#32467;&#28857; head &#65292;&#35831;&#20320;&#25214;&#20986;&#24182;&#36820;&#22238;&#38142;&#34920;&#30340;&#20013;&#38388;&#32467;&#28857;&#12290;

&#22914;&#26524;&#26377;&#20004;&#20010;&#20013;&#38388;&#32467;&#28857;&#65292;&#21017;&#36820;&#22238;&#31532;&#20108;&#20010;&#20013;&#38388;&#32467;&#28857;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;head = [1,2,3,4,5]
&#36755;&#20986;&#65306;[3,4,5]
&#35299;&#37322;&#65306;&#38142;&#34920;&#21482;&#26377;&#19968;&#20010;&#20013;&#38388;&#32467;&#28857;&#65292;&#20540;&#20026; 3 

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;head = [1,2,3,4,5,6]
&#36755;&#20986;&#65306;[4,5,6]
&#35299;&#37322;&#65306;&#35813;&#38142;&#34920;&#26377;&#20004;&#20010;&#20013;&#38388;&#32467;&#28857;&#65292;&#20540;&#20998;&#21035;&#20026; 3 &#21644; 4 &#65292;&#36820;&#22238;&#31532;&#20108;&#20010;&#32467;&#28857;&#12290;

&#25552;&#31034;&#65306;
&#38142;&#34920;&#30340;&#32467;&#28857;&#25968;&#33539;&#22260;&#26159; [1, 100]
1 &lt;= Node.val &lt;= 100
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     </span><span class="org-doc"><span class="org-doc-markup">ListNode()</span></span><span class="org-doc"> : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">ListNode</span>* <span class="org-function-name">middleNode</span>(<span class="org-type">ListNode</span>* <span class="org-variable-name">head</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21487;&#20197;&#29992;&#24555;&#24930;&#25351;&#38024;&#26469;&#27714;&#35299;&#65306;&#24555;&#25351;&#38024;&#27599;&#27425;&#36208;2&#27493;&#65292;&#24930;&#25351;&#38024;&#27599;&#27425;&#36208;&#19968;&#27493;&#65292;&#24403;&#24555;&#25351;&#38024;&#36208;&#21040;&#38142;&#34920;&#23614;&#37096;&#32467;&#26524;&#23601;&#20986;&#26469;&#20102;
</span>        <span class="org-type">ListNode</span>* <span class="org-variable-name">fast</span> = head;
        <span class="org-type">ListNode</span>* <span class="org-variable-name">slow</span> = head;
        <span class="org-keyword">while</span>(fast) {
            fast = fast-&gt;next;
            <span class="org-keyword">if</span> (fast == <span class="org-constant">NULL</span>) {
                <span class="org-keyword">return</span> slow;
            }
            fast = fast-&gt;next;
            <span class="org-keyword">if</span> (fast == <span class="org-constant">NULL</span>) {
                <span class="org-keyword">return</span> slow-&gt;next;;
            }
            slow = slow-&gt;next;
        }
        <span class="org-keyword">return</span> <span class="org-constant">NULL</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#38543;&#20415;&#32473;&#20010;&#20540;&#23601;&#22909;&#65292;&#22240;&#20026;&#24930;&#25351;&#38024;&#27604;&#24555;&#25351;&#21521;&#24930;
</span>    }
};
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-h:569e3286-f966-4967-bd4b-aa1207c42286" class="outline-5">
<h5 id="h:569e3286-f966-4967-bd4b-aa1207c42286"><a href="#h:569e3286-f966-4967-bd4b-aa1207c42286">单向链表的删除</a></h5>
<div class="outline-text-5" id="text-h:569e3286-f966-4967-bd4b-aa1207c42286">
</div>
<ul class="org-ul">
<li><a id="h:e652ec58-13e1-47b4-9e7e-4e97d19b4bc5"></a><a href="#h:e652ec58-13e1-47b4-9e7e-4e97d19b4bc5">8.面试题 02.03. 删除中间节点</a><br>
<div class="outline-text-6" id="text-h:e652ec58-13e1-47b4-9e7e-4e97d19b4bc5">
<p>
<a href="https://leetcode.cn/problems/delete-middle-node-lcci/description/">https://leetcode.cn/problems/delete-middle-node-lcci/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#33509;&#38142;&#34920;&#20013;&#30340;&#26576;&#20010;&#33410;&#28857;&#65292;&#26082;&#19981;&#26159;&#38142;&#34920;&#22836;&#33410;&#28857;&#65292;&#20063;&#19981;&#26159;&#38142;&#34920;&#23614;&#33410;&#28857;&#65292;&#21017;&#31216;&#20854;&#20026;&#35813;&#38142;&#34920;&#30340;&#12300;&#20013;&#38388;&#33410;&#28857;&#12301;&#12290;

&#20551;&#23450;&#24050;&#30693;&#38142;&#34920;&#30340;&#26576;&#19968;&#20010;&#20013;&#38388;&#33410;&#28857;&#65292;&#35831;&#23454;&#29616;&#19968;&#31181;&#31639;&#27861;&#65292;&#23558;&#35813;&#33410;&#28857;&#20174;&#38142;&#34920;&#20013;&#21024;&#38500;&#12290;

&#20363;&#22914;&#65292;&#20256;&#20837;&#33410;&#28857; c&#65288;&#20301;&#20110;&#21333;&#21521;&#38142;&#34920; a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f &#20013;&#65289;&#65292;&#23558;&#20854;&#21024;&#38500;&#21518;&#65292;&#21097;&#20313;&#38142;&#34920;&#20026; a-&gt;b-&gt;d-&gt;e-&gt;f


&#31034;&#20363;&#65306;
&#36755;&#20837;&#65306;&#33410;&#28857; 5 &#65288;&#20301;&#20110;&#21333;&#21521;&#38142;&#34920; 4-&gt;5-&gt;1-&gt;9 &#20013;&#65289;
&#36755;&#20986;&#65306;&#19981;&#36820;&#22238;&#20219;&#20309;&#25968;&#25454;&#65292;&#20174;&#38142;&#34920;&#20013;&#21024;&#38500;&#20256;&#20837;&#30340;&#33410;&#28857; 5&#65292;&#20351;&#38142;&#34920;&#21464;&#20026; 4-&gt;1-&gt;9
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">void</span> <span class="org-function-name">deleteNode</span>(<span class="org-type">ListNode</span>* <span class="org-variable-name">node</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#25105;&#20204;&#30693;&#36947;&#38656;&#35201;&#21024;&#38500;&#21015;&#34920;&#33410;&#28857;&#65292;&#24517;&#39035;&#30693;&#36947;&#23427;&#30340;&#21069;&#39537;&#33410;&#28857;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#20294;&#36825;&#39064;&#21482;&#32473;&#20986;&#20102;&#38656;&#35201;&#21024;&#38500;&#30340;&#32467;&#28857;&#65292;&#25152;&#20197;&#21487;&#20197;&#36825;&#26679;&#20570;&#65292;&#25226;&#32473;&#23450;&#33410;&#28857;&#30340;&#21518;&#32487;&#32467;&#28857;&#30340;&#20540;&#36171;&#20540;&#32473;&#23427;&#65292;&#28982;&#21518;&#21024;&#38500;&#23427;&#30340;&#21518;&#32487;&#23601;&#21487;&#20197;&#20102;
</span>        
        node-&gt;val = node-&gt;next-&gt;val; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20808;&#25226;&#24403;&#21069;&#32467;&#28857;&#30340;&#20540;&#65292;&#29992;&#23427;&#21518;&#32487;&#32467;&#28857;&#30340;&#20540;&#35206;&#30422;&#25481;
</span>        node-&gt;next = node-&gt;next-&gt;next; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;&#21518;&#32487;&#32467;&#28857;&#21024;&#38500;&#25481;
</span>    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:3771f19d-42ae-426f-b2da-d8aa3b1424a1"></a><a href="#h:3771f19d-42ae-426f-b2da-d8aa3b1424a1">9.移除链表元素</a><br>
<div class="outline-text-6" id="text-h:3771f19d-42ae-426f-b2da-d8aa3b1424a1">
<p>
<a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">https://leetcode.cn/problems/remove-linked-list-elements/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#38142;&#34920;&#30340;&#22836;&#33410;&#28857; head &#21644;&#19968;&#20010;&#25972;&#25968; val &#65292;&#35831;&#20320;&#21024;&#38500;&#38142;&#34920;&#20013;&#25152;&#26377;&#28385;&#36275; Node.val == val &#30340;&#33410;&#28857;&#65292;&#24182;&#36820;&#22238; &#26032;&#30340;&#22836;&#33410;&#28857; &#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;head = [1,2,6,3,4,5,6], val = 6
&#36755;&#20986;&#65306;[1,2,3,4,5]

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;head = [], val = 1
&#36755;&#20986;&#65306;[]

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;head = [7,7,7,7], val = 7
&#36755;&#20986;&#65306;[]

&#25552;&#31034;&#65306;
&#21015;&#34920;&#20013;&#30340;&#33410;&#28857;&#25968;&#30446;&#22312;&#33539;&#22260; [0, 104] &#20869;
1 &lt;= Node.val &lt;= 50
0 &lt;= val &lt;= 50
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     </span><span class="org-doc"><span class="org-doc-markup">ListNode()</span></span><span class="org-doc"> : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">ListNode</span>* <span class="org-function-name">removeElements</span>(<span class="org-type">ListNode</span>* <span class="org-variable-name">head</span>, <span class="org-type">int</span> <span class="org-variable-name">val</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#22240;&#20026;&#22836;&#32467;&#28857;&#21487;&#33021;&#34987;&#31227;&#38500;&#65292;&#25152;&#20197;&#26368;&#22909;&#29983;&#25104;&#19968;&#20010;&#34394;&#25311;&#22836;&#32467;&#28857;&#65292;&#36825;&#26679;&#23601;&#19981;&#29992;&#21333;&#29420;&#32771;&#34385;&#22836;&#32467;&#28857;&#21644;&#38750;&#22836;&#32467;&#28857;&#20102;
</span>        <span class="org-type">ListNode</span>* <span class="org-variable-name">newHead</span> = <span class="org-keyword">new</span> <span class="org-type">ListNode</span>();
        newHead-&gt;next = head; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;&#29983;&#25104;&#30340;&#34394;&#25311;&#22836;&#32467;&#28857;&#30340;&#21518;&#32487;&#32467;&#28857;&#32622;&#20026;&#24403;&#21069;&#38142;&#34920;&#30340;&#22836;&#32467;&#28857;
</span>        <span class="org-type">ListNode</span>* <span class="org-variable-name">pre</span> = newHead;<span class="org-comment-delimiter">// </span><span class="org-comment">&#22240;&#20026;&#35201;&#21024;&#38500;&#32467;&#28857;&#65292;&#25152;&#20197;&#24517;&#39035;&#26377;&#19968;&#20010;&#21069;&#39537;&#25351;&#38024;&#65292;&#21021;&#22987;&#21270;&#20026;&#34394;&#25311;&#22836;&#32467;&#28857;
</span>        <span class="org-keyword">while</span>(pre-&gt;next) {
            <span class="org-keyword">if</span> (pre-&gt;next-&gt;val == val) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#35828;&#26126;pre &#30340;&#21518;&#32487;&#32467;&#28857;&#38656;&#35201;&#34987;&#21024;&#38500;
</span>                pre-&gt;next = pre-&gt;next-&gt;next;
            }<span class="org-keyword">else</span> {
                pre = pre-&gt;next;
            }
        }
        <span class="org-keyword">return</span> newHead-&gt;next;
    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:e1d8ddad-5dae-402d-9f35-f8c4ff8ae02e"></a><a href="#h:e1d8ddad-5dae-402d-9f35-f8c4ff8ae02e">10.删除链表中的节点</a><br>
<div class="outline-text-6" id="text-h:e1d8ddad-5dae-402d-9f35-f8c4ff8ae02e">
<p>
<a href="https://leetcode.cn/problems/delete-node-in-a-linked-list/description/">https://leetcode.cn/problems/delete-node-in-a-linked-list/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#26377;&#19968;&#20010;&#21333;&#38142;&#34920;&#30340; head&#65292;&#25105;&#20204;&#24819;&#21024;&#38500;&#23427;&#20854;&#20013;&#30340;&#19968;&#20010;&#33410;&#28857; node&#12290;

&#32473;&#20320;&#19968;&#20010;&#38656;&#35201;&#21024;&#38500;&#30340;&#33410;&#28857; node &#12290;&#20320;&#23558; &#26080;&#27861;&#35775;&#38382; &#31532;&#19968;&#20010;&#33410;&#28857;  head&#12290;

&#38142;&#34920;&#30340;&#25152;&#26377;&#20540;&#37117;&#26159; &#21807;&#19968;&#30340;&#65292;&#24182;&#19988;&#20445;&#35777;&#32473;&#23450;&#30340;&#33410;&#28857; node &#19981;&#26159;&#38142;&#34920;&#20013;&#30340;&#26368;&#21518;&#19968;&#20010;&#33410;&#28857;&#12290;

&#21024;&#38500;&#32473;&#23450;&#30340;&#33410;&#28857;&#12290;&#27880;&#24847;&#65292;&#21024;&#38500;&#33410;&#28857;&#24182;&#19981;&#26159;&#25351;&#20174;&#20869;&#23384;&#20013;&#21024;&#38500;&#23427;&#12290;&#36825;&#37324;&#30340;&#24847;&#24605;&#26159;&#65306;

&#32473;&#23450;&#33410;&#28857;&#30340;&#20540;&#19981;&#24212;&#35813;&#23384;&#22312;&#20110;&#38142;&#34920;&#20013;&#12290;
&#38142;&#34920;&#20013;&#30340;&#33410;&#28857;&#25968;&#24212;&#35813;&#20943;&#23569; 1&#12290;
node &#21069;&#38754;&#30340;&#25152;&#26377;&#20540;&#39034;&#24207;&#30456;&#21516;&#12290;
node &#21518;&#38754;&#30340;&#25152;&#26377;&#20540;&#39034;&#24207;&#30456;&#21516;&#12290;
&#33258;&#23450;&#20041;&#27979;&#35797;&#65306;

&#23545;&#20110;&#36755;&#20837;&#65292;&#20320;&#24212;&#35813;&#25552;&#20379;&#25972;&#20010;&#38142;&#34920; head &#21644;&#35201;&#32473;&#20986;&#30340;&#33410;&#28857; node&#12290;node &#19981;&#24212;&#35813;&#26159;&#38142;&#34920;&#30340;&#26368;&#21518;&#19968;&#20010;&#33410;&#28857;&#65292;&#32780;&#24212;&#35813;&#26159;&#38142;&#34920;&#20013;&#30340;&#19968;&#20010;&#23454;&#38469;&#33410;&#28857;&#12290;
&#25105;&#20204;&#23558;&#26500;&#24314;&#38142;&#34920;&#65292;&#24182;&#23558;&#33410;&#28857;&#20256;&#36882;&#32473;&#20320;&#30340;&#20989;&#25968;&#12290;
&#36755;&#20986;&#23558;&#26159;&#35843;&#29992;&#20320;&#20989;&#25968;&#21518;&#30340;&#25972;&#20010;&#38142;&#34920;&#12290;


&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;head = [4,5,1,9], node = 5
&#36755;&#20986;&#65306;[4,1,9]
&#35299;&#37322;&#65306;&#25351;&#23450;&#38142;&#34920;&#20013;&#20540;&#20026; 5 &#30340;&#31532;&#20108;&#20010;&#33410;&#28857;&#65292;&#37027;&#20040;&#22312;&#35843;&#29992;&#20102;&#20320;&#30340;&#20989;&#25968;&#20043;&#21518;&#65292;&#35813;&#38142;&#34920;&#24212;&#21464;&#20026; 4 -&gt; 1 -&gt; 9

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;head = [4,5,1,9], node = 1
&#36755;&#20986;&#65306;[4,5,9]
&#35299;&#37322;&#65306;&#25351;&#23450;&#38142;&#34920;&#20013;&#20540;&#20026; 1 &#30340;&#31532;&#19977;&#20010;&#33410;&#28857;&#65292;&#37027;&#20040;&#22312;&#35843;&#29992;&#20102;&#20320;&#30340;&#20989;&#25968;&#20043;&#21518;&#65292;&#35813;&#38142;&#34920;&#24212;&#21464;&#20026; 4 -&gt; 5 -&gt; 9

&#25552;&#31034;&#65306;
&#38142;&#34920;&#20013;&#33410;&#28857;&#30340;&#25968;&#30446;&#33539;&#22260;&#26159; [2, 1000]
-1000 &lt;= Node.val &lt;= 1000
&#38142;&#34920;&#20013;&#27599;&#20010;&#33410;&#28857;&#30340;&#20540;&#37117;&#26159; &#21807;&#19968; &#30340;
&#38656;&#35201;&#21024;&#38500;&#30340;&#33410;&#28857; node &#26159; &#38142;&#34920;&#20013;&#30340;&#33410;&#28857; &#65292;&#19988; &#19981;&#26159;&#26411;&#23614;&#33410;&#28857;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">void</span> <span class="org-function-name">deleteNode</span>(<span class="org-type">ListNode</span>* <span class="org-variable-name">node</span>) {
        node-&gt;val = node-&gt;next-&gt;val; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#33410;&#28857;&#30340;&#20540;&#29992;&#23427;&#30340;&#21518;&#32487;&#32467;&#28857;&#30340;&#20540;&#35206;&#30422;&#25481;
</span>        node-&gt;next = node-&gt;next-&gt;next; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;&#21518;&#32487;&#33410;&#28857;
</span>    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:fe47a7f9-786f-4365-ac98-25af5665b2b1"></a><a href="#h:fe47a7f9-786f-4365-ac98-25af5665b2b1">11.删除排序链表中的重复元素</a><br>
<div class="outline-text-6" id="text-h:fe47a7f9-786f-4365-ac98-25af5665b2b1">
<p>
<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/">https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#23450;&#19968;&#20010;&#24050;&#25490;&#24207;&#30340;&#38142;&#34920;&#30340;&#22836; head &#65292; &#21024;&#38500;&#25152;&#26377;&#37325;&#22797;&#30340;&#20803;&#32032;&#65292;&#20351;&#27599;&#20010;&#20803;&#32032;&#21482;&#20986;&#29616;&#19968;&#27425; &#12290;&#36820;&#22238; &#24050;&#25490;&#24207;&#30340;&#38142;&#34920; &#12290;


&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;head = [1,1,2]
&#36755;&#20986;&#65306;[1,2]

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;head = [1,1,2,3,3]
&#36755;&#20986;&#65306;[1,2,3]

&#25552;&#31034;&#65306;
&#38142;&#34920;&#20013;&#33410;&#28857;&#25968;&#30446;&#22312;&#33539;&#22260; [0, 300] &#20869;
-100 &lt;= Node.val &lt;= 100
&#39064;&#30446;&#25968;&#25454;&#20445;&#35777;&#38142;&#34920;&#24050;&#32463;&#25353;&#21319;&#24207; &#25490;&#21015;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     </span><span class="org-doc"><span class="org-doc-markup">ListNode()</span></span><span class="org-doc"> : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">ListNode</span>* <span class="org-function-name">deleteDuplicates</span>(<span class="org-type">ListNode</span>* <span class="org-variable-name">head</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#30001;&#20110;&#38142;&#34920;&#26159;&#25490;&#22909;&#24207;&#30340;&#65292;&#25152;&#20197;&#37325;&#22797;&#30340;&#38142;&#34920;&#26159;&#38752;&#22312;&#19968;&#36215;&#30340;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#19968;&#33324;&#36935;&#21040;&#21024;&#38500;&#30340;&#38382;&#39064;&#65292;&#24517;&#39035;&#23450;&#20041;&#21069;&#39537;
</span>        <span class="org-type">ListNode</span>* <span class="org-variable-name">prev</span> = <span class="org-constant">NULL</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">head&#30340;&#21069;&#39537;&#20026;NULL
</span>        <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head;
        <span class="org-keyword">while</span>(curr) {
            <span class="org-keyword">while</span>(<span class="org-type">prev</span> &amp;&amp; <span class="org-variable-name">prev</span>-&gt;val == curr-&gt;val){ <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26377;&#36830;&#32493;&#30456;&#31561;&#30340;&#20540;&#35201;&#19968;&#30452;&#21024;&#38500;
</span>                <span class="org-comment-delimiter">// </span><span class="org-comment">prev&#30340;&#21518;&#32487;&#33410;&#28857;&#21464;&#25104;curr&#30340;&#21518;&#32493;&#33410;&#28857;
</span>                prev-&gt;next = curr-&gt;next;
                curr = prev-&gt;next;
                <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>curr) { <span class="org-comment-delimiter">// </span><span class="org-comment">curr&#20026;&#31354;&#26102;&#36941;&#21382;&#23436;&#27605;
</span>                    <span class="org-keyword">break</span>;
                } 
            }
            <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>curr) { <span class="org-comment-delimiter">// </span><span class="org-comment">curr&#20026;&#31354;&#26102;&#36941;&#21382;&#23436;&#27605;
</span>                <span class="org-keyword">break</span>;
            } 
            prev = curr;
            curr = curr-&gt;next;
        }
        <span class="org-keyword">return</span> head; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26080;&#35770;&#33258;&#24049;&#21024;&#38500;&#65292;&#26368;&#21518;&#36820;&#22238;&#30340;&#36824;&#26159;&#38142;&#34920;&#22836;
</span>    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:aba57654-0323-4a90-8d4e-e8b305106305"></a><a href="#h:aba57654-0323-4a90-8d4e-e8b305106305">12.删除链表的倒数第 N 个结点</a><br>
<div class="outline-text-6" id="text-h:aba57654-0323-4a90-8d4e-e8b305106305">
<p>
<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#38142;&#34920;&#65292;&#21024;&#38500;&#38142;&#34920;&#30340;&#20498;&#25968;&#31532; n &#20010;&#32467;&#28857;&#65292;&#24182;&#19988;&#36820;&#22238;&#38142;&#34920;&#30340;&#22836;&#32467;&#28857;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;head = [1,2,3,4,5], n = 2
&#36755;&#20986;&#65306;[1,2,3,5]

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;head = [1], n = 1
&#36755;&#20986;&#65306;[]

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;head = [1,2], n = 1
&#36755;&#20986;&#65306;[1]

&#25552;&#31034;&#65306;
&#38142;&#34920;&#20013;&#32467;&#28857;&#30340;&#25968;&#30446;&#20026; sz
1 &lt;= sz &lt;= 30
0 &lt;= Node.val &lt;= 100
1 &lt;= n &lt;= sz
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     </span><span class="org-doc"><span class="org-doc-markup">ListNode()</span></span><span class="org-doc"> : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">ListNode</span>* <span class="org-function-name">removeNthFromEnd</span>(<span class="org-type">ListNode</span>* <span class="org-variable-name">head</span>, <span class="org-type">int</span> <span class="org-variable-name">n</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21033;&#29992;&#24555;&#24930;&#25351;&#38024;&#25214;&#21040;&#20498;&#25968;&#31532;n&#20010;&#32467;&#28857;
</span>        <span class="org-type">ListNode</span>* <span class="org-variable-name">fast</span> = head;
        <span class="org-type">ListNode</span>* <span class="org-variable-name">slow</span> = head;
        <span class="org-type">ListNode</span>* <span class="org-variable-name">prev</span> = <span class="org-constant">NULL</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21069;&#39537;&#33410;&#28857;
</span>        <span class="org-keyword">while</span>(n--){
            fast = fast-&gt;next;
        }
        <span class="org-keyword">while</span>(fast) {
            fast = fast-&gt;next;
            prev = slow;
            slow = slow-&gt;next;
        }
        <span class="org-keyword">if</span>(<span class="org-negation-char">!</span>prev){ <span class="org-comment-delimiter">// </span><span class="org-comment">prev&#20026;&#31354;&#65292;&#34920;&#31034;&#21024;&#38500;&#30340;&#26159;&#38142;&#34920;&#30340;&#22836;&#32467;&#28857;
</span>            <span class="org-keyword">return</span> head-&gt;next;
        }
        prev-&gt;next = slow-&gt;next;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;&#31532;n&#20010;&#32467;&#28857;
</span>        <span class="org-keyword">return</span> head;
    }
};
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-h:68614d1b-efd3-44ea-8839-4af917cee10e" class="outline-5">
<h5 id="h:68614d1b-efd3-44ea-8839-4af917cee10e"><a href="#h:68614d1b-efd3-44ea-8839-4af917cee10e">单向链表的插入</a></h5>
<div class="outline-text-5" id="text-h:68614d1b-efd3-44ea-8839-4af917cee10e">
</div>
<ul class="org-ul">
<li><a id="h:e6a7835e-677b-482f-8818-defff327bdc4"></a><a href="#h:e6a7835e-677b-482f-8818-defff327bdc4">13.移除重复节点</a><br>
<div class="outline-text-6" id="text-h:e6a7835e-677b-482f-8818-defff327bdc4">
<div class="org-src-container">
<pre class="src src-text">&#32534;&#20889;&#20195;&#30721;&#65292;&#31227;&#38500;&#26410;&#25490;&#24207;&#38142;&#34920;&#20013;&#30340;&#37325;&#22797;&#33410;&#28857;&#12290;&#20445;&#30041;&#26368;&#24320;&#22987;&#20986;&#29616;&#30340;&#33410;&#28857;&#12290;

&#31034;&#20363;1&#65306;
&#36755;&#20837;&#65306;[1, 2, 3, 3, 2, 1]
&#36755;&#20986;&#65306;[1, 2, 3]

&#31034;&#20363;2&#65306;
&#36755;&#20837;&#65306;[1, 1, 1, 1, 2]
&#36755;&#20986;&#65306;[1, 2]

&#25552;&#31034;&#65306;
&#38142;&#34920;&#38271;&#24230;&#22312;[0, 20000]&#33539;&#22260;&#20869;&#12290;
&#38142;&#34920;&#20803;&#32032;&#22312;[0, 20000]&#33539;&#22260;&#20869;&#12290;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     </span><span class="org-doc"><span class="org-doc-markup">ListNode()</span></span><span class="org-doc"> : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">ListNode</span>* <span class="org-function-name">removeDuplicateNodes</span>(<span class="org-type">ListNode</span>* <span class="org-variable-name">head</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#38271;&#24230;&#26159;2000&#65292;&#20803;&#32032;&#25968;&#22312;20000&#33539;&#22260;&#20869;&#65292;&#25152;&#20197;&#21487;&#20197;&#29992;&#25968;&#32452;&#26469;&#26631;&#35760;&#36825;&#20010;&#20803;&#32032;&#26159;&#21542;&#20986;&#29616;&#36807;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;&#27809;&#26377;&#20986;&#29616;&#30340;&#20803;&#32032;&#38142;&#25509;&#21040;&#19968;&#20010;&#26032;&#38142;&#34920;&#20013;&#65292;&#24182;&#36820;&#22238;
</span>        <span class="org-keyword">if</span>(head == <span class="org-constant">NULL</span>) <span class="org-keyword">return</span> <span class="org-constant">NULL</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;&#31354;&#38142;&#34920;&#65292;&#30452;&#25509;&#36820;&#22238;&#31354;&#38142;&#34920;
</span>        <span class="org-type">bool</span> <span class="org-variable-name">hash</span>[2000] = {0}; <span class="org-comment-delimiter">// </span><span class="org-comment">&#29992;&#20110;&#24555;&#36895;&#21028;&#26029;&#36825;&#20010;&#20803;&#32032;&#26159;&#21542;&#20986;&#29616;&#36807;&#65292;&#21021;&#22987;&#21270;&#25152;&#26377;&#20803;&#32032;&#20026;0
</span>        <span class="org-type">ListNode</span>* <span class="org-variable-name">tmp</span> = head; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20195;&#34920;&#26032;&#38142;&#25509;&#20986;&#26469;&#19968;&#20010;&#38142;&#34920;
</span>        <span class="org-type">ListNode</span>* <span class="org-variable-name">prev</span> = head;
        <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head-&gt;next;
        <span class="org-type">hash</span>[head-&gt;val] = 1; <span class="org-comment-delimiter">// </span><span class="org-comment">&#34920;&#31034;&#22836;&#32467;&#28857;&#34987;&#26631;&#35760;&#25481;&#20102;
</span>
        <span class="org-keyword">while</span>(curr){
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#27599;&#27425;&#21028;&#26029;hash&#36825;&#20010;&#20540;&#26159;&#21542;&#22312;&#25968;&#32452;&#20013;&#20986;&#29616;&#36807;
</span>            <span class="org-keyword">if</span>(<span class="org-negation-char">!</span>hash[curr-&gt;val]){
                <span class="org-type">hash</span>[curr-&gt;val] = 1; <span class="org-comment-delimiter">// </span><span class="org-comment">&#27809;&#26377;&#20986;&#29616;&#36807;&#65292;&#25226;&#20540;&#32622;&#20026;1
</span>                tmp-&gt;next = curr;    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;curr&#20018;&#32852;&#21040;tmp&#21518;&#38754;
</span>                tmp = tmp-&gt;next;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#35753;tmp&#21521;&#21518;&#36208;&#19968;&#20010;
</span>            }

            prev = curr;
            curr = curr-&gt;next;
        }
        tmp-&gt;next = <span class="org-constant">NULL</span>;            <span class="org-comment-delimiter">// </span><span class="org-comment">&#26368;&#21518;&#35753;tmp&#30340;&#21518;&#32487;&#32622;&#20026;&#31354;
</span>        <span class="org-keyword">return</span> head;
    }
};
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-h:a44f6933-bc79-4e68-8ec7-a36a851145fe" class="outline-5">
<h5 id="h:a44f6933-bc79-4e68-8ec7-a36a851145fe"><a href="#h:a44f6933-bc79-4e68-8ec7-a36a851145fe">单向链表的递归和迭代</a></h5>
<div class="outline-text-5" id="text-h:a44f6933-bc79-4e68-8ec7-a36a851145fe">
</div>
<ul class="org-ul">
<li><a id="h:c2a8bec8-f7a9-4a12-ae22-20f8be986f77"></a><a href="#h:c2a8bec8-f7a9-4a12-ae22-20f8be986f77">14.图书整理 I</a><br>
<div class="outline-text-6" id="text-h:c2a8bec8-f7a9-4a12-ae22-20f8be986f77">
<p>
<a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#20070;&#24215;&#24215;&#21592;&#26377;&#19968;&#24352;&#38142;&#34920;&#24418;&#24335;&#30340;&#20070;&#21333;&#65292;&#27599;&#20010;&#33410;&#28857;&#20195;&#34920;&#19968;&#26412;&#20070;&#65292;&#33410;&#28857;&#20013;&#30340;&#20540;&#34920;&#31034;&#20070;&#30340;&#32534;&#21495;&#12290;
&#20026;&#26356;&#26041;&#20415;&#25972;&#29702;&#20070;&#26550;&#65292;&#24215;&#21592;&#38656;&#35201;&#23558;&#20070;&#21333;&#20498;&#36807;&#26469;&#25490;&#21015;&#65292;&#23601;&#21487;&#20197;&#20174;&#26368;&#21518;&#19968;&#26412;&#20070;&#24320;&#22987;&#25972;&#29702;&#65292;
&#36880;&#19968;&#23558;&#20070;&#25918;&#22238;&#21040;&#20070;&#26550;&#19978;&#12290;&#35831;&#20498;&#24207;&#36820;&#22238;&#36825;&#20010;&#20070;&#21333;&#38142;&#34920;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;head = [3,6,4,1]
&#36755;&#20986;&#65306;[1,4,6,3]

&#25552;&#31034;&#65306;
0 &lt;= &#38142;&#34920;&#38271;&#24230; &lt;= 10000
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     </span><span class="org-doc"><span class="org-doc-markup">ListNode()</span></span><span class="org-doc"> : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-function-name">reverseBookList</span>(<span class="org-type">ListNode</span>* <span class="org-variable-name">head</span>) {
        <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">ans</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;&#38142;&#34920;&#36941;&#21382;&#30340;&#21516;&#26102;&#25554;&#20837;&#21040;&#39034;&#24207;&#34920;&#20013;
</span>        <span class="org-keyword">while</span>(head){
            ans.push_back(head-&gt;val);
            head = head-&gt;next;
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#28216;&#26631;l&#21644;r&#65292;l&#25351;&#21521;&#39034;&#24207;&#34920;&#31532;0&#20010;&#20803;&#32032;&#65292;r&#25351;&#21521;&#39034;&#24207;&#34920;&#26368;&#21518;&#19968;&#20010;&#20803;&#32032;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#20132;&#25442;&#31532;l&#21644;&#31532;r&#19978;&#20803;&#32032;&#65292;&#24182;&#21521;&#20013;&#38388;&#38752;&#25314;&#65292;ans&#36825;&#20010;&#39034;&#24207;&#34920;&#23601;&#36870;&#24207;&#23436;&#27605;&#20102;
</span>        <span class="org-type">int</span> <span class="org-variable-name">l</span> = 0, <span class="org-variable-name">r</span> = ans.size() - 1;
        <span class="org-keyword">while</span>(l &lt; r){
            <span class="org-type">int</span> <span class="org-variable-name">tmp</span> = ans[l];
            ans[l] = ans[r];
            ans[r] = tmp;
            ++l;
            --r;
        }
        <span class="org-keyword">return</span> ans;
    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:c74f751b-420c-403a-a3ff-7824e6b27284"></a><a href="#h:c74f751b-420c-403a-a3ff-7824e6b27284">15.反转链表(递归)</a><br>
<div class="outline-text-6" id="text-h:c74f751b-420c-403a-a3ff-7824e6b27284">
<p>
<a href="https://leetcode.cn/problems/UHnkqh/description/">https://leetcode.cn/problems/UHnkqh/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#23450;&#21333;&#38142;&#34920;&#30340;&#22836;&#33410;&#28857; head &#65292;&#35831;&#21453;&#36716;&#38142;&#34920;&#65292;&#24182;&#36820;&#22238;&#21453;&#36716;&#21518;&#30340;&#38142;&#34920;&#30340;&#22836;&#33410;&#28857;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;head = [1,2,3,4,5]
&#36755;&#20986;&#65306;[5,4,3,2,1]

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;head = [1,2]
&#36755;&#20986;&#65306;[2,1]

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;head = []
&#36755;&#20986;&#65306;[]

&#25552;&#31034;&#65306;
&#38142;&#34920;&#20013;&#33410;&#28857;&#30340;&#25968;&#30446;&#33539;&#22260;&#26159; [0, 5000]
-5000 &lt;= Node.val &lt;= 5000
 
&#36827;&#38454;&#65306;&#38142;&#34920;&#21487;&#20197;&#36873;&#29992;&#36845;&#20195;&#25110;&#36882;&#24402;&#26041;&#24335;&#23436;&#25104;&#21453;&#36716;&#12290;&#20320;&#33021;&#21542;&#29992;&#20004;&#31181;&#26041;&#27861;&#35299;&#20915;&#36825;&#36947;&#39064;&#65311;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     </span><span class="org-doc"><span class="org-doc-markup">ListNode()</span></span><span class="org-doc"> : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">ListNode</span>* <span class="org-function-name">reverseList</span>(<span class="org-type">ListNode</span>* <span class="org-variable-name">head</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#36882;&#24402;&#20986;&#21475;
</span>        <span class="org-keyword">if</span>(head == <span class="org-constant">NULL</span> || head-&gt;next == <span class="org-constant">NULL</span>) {
            <span class="org-keyword">return</span> head;
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">1.&#35753;head&#21518;&#32487;&#65288;&#20063;&#23601;&#26159;head-&gt;next&#65289;&#20026;&#22836;&#32467;&#28857;&#30340;&#38142;&#34920;&#65292;&#29575;&#20808;&#23454;&#29616;&#36820;&#22238;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">2.&#24182;&#19988;&#36820;&#22238;&#21453;&#36716;&#21518;&#30340;&#38142;&#34920;&#22836;&#32467;&#28857;&#65292;&#23384;&#20648;&#21040;newHead
</span>        <span class="org-type">ListNode</span>* <span class="org-variable-name">newHead</span> = reverseList(head-&gt;next);  <span class="org-comment-delimiter">// </span><span class="org-comment">newHead&#24517;&#23450;&#26159;&#36870;&#24207;&#21518;&#30340;&#22836;&#32467;&#28857;&#65292;&#30452;&#25509;&#36820;&#22238;
</span>        head-&gt;next-&gt;next = head; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21453;&#36716;&#21518;&#30340;&#23614;&#32467;&#28857;&#35774;&#32622;&#36825;&#20026;head
</span>        head-&gt;next = <span class="org-constant">NULL</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">reverseList&#23454;&#29616;&#20102;&#21453;&#36716;&#65292;&#37027;&#20040;reverseList(head-&gt;next)&#35843;&#29992;&#21518;&#65292;head-&gt;next&#24517;&#28982;&#25104;&#20026;&#26412;&#27425;&#30340;&#23614;&#32467;&#28857;
</span>        <span class="org-keyword">return</span> newHead;
    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:7679e6d5-e071-4c7b-a865-91a350312280"></a><a href="#h:7679e6d5-e071-4c7b-a865-91a350312280">16.训练计划 III</a><br>
<div class="outline-text-6" id="text-h:7679e6d5-e071-4c7b-a865-91a350312280">
<p>
<a href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/description/">https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#23450;&#19968;&#20010;&#22836;&#33410;&#28857;&#20026; head &#30340;&#21333;&#38142;&#34920;&#29992;&#20110;&#35760;&#24405;&#19968;&#31995;&#21015;&#26680;&#24515;&#32908;&#32676;&#35757;&#32451;&#32534;&#21495;&#65292;&#35831;&#23558;&#35813;&#31995;&#21015;&#35757;&#32451;&#32534;&#21495; &#20498;&#24207; &#35760;&#24405;&#20110;&#38142;&#34920;&#24182;&#36820;&#22238;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;head = [1,2,3,4,5]
&#36755;&#20986;&#65306;[5,4,3,2,1]

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;head = [1,2]
&#36755;&#20986;&#65306;[2,1]

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;head = []
&#36755;&#20986;&#65306;[]

&#25552;&#31034;&#65306;
&#38142;&#34920;&#20013;&#33410;&#28857;&#30340;&#25968;&#30446;&#33539;&#22260;&#26159; [0, 5000]
-5000 &lt;= Node.val &lt;= 5000
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     </span><span class="org-doc"><span class="org-doc-markup">ListNode()</span></span><span class="org-doc"> : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">ListNode</span>* <span class="org-function-name">trainningPlan</span>(<span class="org-type">ListNode</span>* <span class="org-variable-name">head</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21516;&#26679;&#20063;&#26159;&#38142;&#34920;&#30340;&#36870;&#24207;
</span>        <span class="org-keyword">if</span>(head == <span class="org-constant">NULL</span> || head-&gt;next == <span class="org-constant">NULL</span>) {
            <span class="org-keyword">return</span> head;
        }
        <span class="org-type">ListNode</span>* <span class="org-variable-name">newHead</span> = trainningPlan(head-&gt;next);
        head-&gt;next-&gt;next = head;
        head-&gt;next = <span class="org-constant">NULL</span>;
        <span class="org-keyword">return</span> newHead;
    }
};
</pre>
</div>
</div>
</li>
<li><a id="h:1de64b1a-8d01-4fcc-884e-3bdd3a63628b"></a><a href="#h:1de64b1a-8d01-4fcc-884e-3bdd3a63628b">17.反转链表(迭代)</a><br>
<div class="outline-text-6" id="text-h:1de64b1a-8d01-4fcc-884e-3bdd3a63628b">
<p>
<a href="https://leetcode.cn/problems/reverse-linked-list/description/">https://leetcode.cn/problems/reverse-linked-list/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#23450;&#21333;&#38142;&#34920;&#30340;&#22836;&#33410;&#28857; head &#65292;&#35831;&#21453;&#36716;&#38142;&#34920;&#65292;&#24182;&#36820;&#22238;&#21453;&#36716;&#21518;&#30340;&#38142;&#34920;&#30340;&#22836;&#33410;&#28857;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;head = [1,2,3,4,5]
&#36755;&#20986;&#65306;[5,4,3,2,1]

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;head = [1,2]
&#36755;&#20986;&#65306;[2,1]

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;head = []
&#36755;&#20986;&#65306;[]

&#25552;&#31034;&#65306;
&#38142;&#34920;&#20013;&#33410;&#28857;&#30340;&#25968;&#30446;&#33539;&#22260;&#26159; [0, 5000]
-5000 &lt;= Node.val &lt;= 5000
 
&#36827;&#38454;&#65306;&#38142;&#34920;&#21487;&#20197;&#36873;&#29992;&#36845;&#20195;&#25110;&#36882;&#24402;&#26041;&#24335;&#23436;&#25104;&#21453;&#36716;&#12290;&#20320;&#33021;&#21542;&#29992;&#20004;&#31181;&#26041;&#27861;&#35299;&#20915;&#36825;&#36947;&#39064;&#65311;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     </span><span class="org-doc"><span class="org-doc-markup">ListNode()</span></span><span class="org-doc"> : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">ListNode</span>* <span class="org-function-name">reverseList</span>(<span class="org-type">ListNode</span>* <span class="org-variable-name">head</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">1.&#20174;current head&#24320;&#22987;
</span>        <span class="org-type">ListNode</span>* <span class="org-variable-name">curr</span> = head;
        <span class="org-comment-delimiter">// </span><span class="org-comment">2.&#23450;&#20041;&#21069;&#39537;&#65292;&#21021;&#22987;&#20026;&#31354;
</span>        <span class="org-type">ListNode</span>* <span class="org-variable-name">prev</span> = <span class="org-constant">NULL</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">3.&#21033;&#29992;curr&#36941;&#21382;&#38142;&#34920;
</span>        <span class="org-keyword">while</span>(curr){
            <span class="org-comment-delimiter">// </span><span class="org-comment">4.&#25226;curr&#21518;&#32487;&#36171;&#20540;&#32473;next
</span>            <span class="org-type">ListNode</span>* <span class="org-variable-name">next</span> = curr-&gt;next;
            <span class="org-comment-delimiter">// </span><span class="org-comment">7.&#23545;&#20110;&#27599;&#20010;curr&#65292;&#21482;&#35201;&#25226;&#23427;&#30340;&#21518;&#32487;&#21464;&#25104;&#23427;&#21407;&#20808;&#30340;&#21069;&#39537;
</span>            curr-&gt;next = prev;
            <span class="org-comment-delimiter">// </span><span class="org-comment">6.&#36825;&#20010;&#26102;&#20505;prev&#24212;&#35813;&#26159;curr
</span>            <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#26102;&#20505;&#65292;&#38142;&#34920;&#19981;&#20572;&#21521;&#21518;&#36208;&#65292;&#24182;&#19988;prev&#27704;&#36828;&#26159;curr&#30340;&#21069;&#39537;
</span>            <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;curr&#26159;NULL&#26102;&#65292;prev&#23601;&#38142;&#34920;&#30340;&#26368;&#21518;&#19968;&#20010;&#33410;&#28857;&#12290;&#25152;&#20197;&#36820;&#22238;&#20540;&#26159;prev
</span>            prev = curr;
            <span class="org-comment-delimiter">// </span><span class="org-comment">5.&#25226;curr&#21464;&#25104;next
</span>            curr = next;
        }
        <span class="org-keyword">return</span> prev;
    }
};

<span class="org-comment-delimiter">/*</span><span class="org-comment">
     1 -&gt; 2 -&gt; 3-&gt;N
N &lt;- 1 &lt;- 2 &lt;- 3
</span><span class="org-comment-delimiter">*/</span>
</pre>
</div>
</div>
</li>
<li><a id="h:300cff9a-2707-4546-bd7a-c0524b250f1f"></a><a href="#h:300cff9a-2707-4546-bd7a-c0524b250f1f">18.从链表中移除节点</a><br>
<div class="outline-text-6" id="text-h:300cff9a-2707-4546-bd7a-c0524b250f1f">
<p>
<a href="https://leetcode.cn/problems/remove-nodes-from-linked-list/description/">https://leetcode.cn/problems/remove-nodes-from-linked-list/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#38142;&#34920;&#30340;&#22836;&#33410;&#28857; head &#12290;

&#31227;&#38500;&#27599;&#20010;&#21491;&#20391;&#26377;&#19968;&#20010;&#26356;&#22823;&#25968;&#20540;&#30340;&#33410;&#28857;&#12290;

&#36820;&#22238;&#20462;&#25913;&#21518;&#38142;&#34920;&#30340;&#22836;&#33410;&#28857; head &#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;head = [5,2,13,3,8]
&#36755;&#20986;&#65306;[13,8]
&#35299;&#37322;&#65306;&#38656;&#35201;&#31227;&#38500;&#30340;&#33410;&#28857;&#26159; 5 &#65292;2 &#21644; 3 &#12290;
- &#33410;&#28857; 13 &#22312;&#33410;&#28857; 5 &#21491;&#20391;&#12290;
- &#33410;&#28857; 13 &#22312;&#33410;&#28857; 2 &#21491;&#20391;&#12290;
- &#33410;&#28857; 8 &#22312;&#33410;&#28857; 3 &#21491;&#20391;&#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;head = [1,1,1,1]
&#36755;&#20986;&#65306;[1,1,1,1]
&#35299;&#37322;&#65306;&#27599;&#20010;&#33410;&#28857;&#30340;&#20540;&#37117;&#26159; 1 &#65292;&#25152;&#20197;&#27809;&#26377;&#38656;&#35201;&#31227;&#38500;&#30340;&#33410;&#28857;&#12290;

&#25552;&#31034;&#65306;
&#32473;&#23450;&#21015;&#34920;&#20013;&#30340;&#33410;&#28857;&#25968;&#30446;&#22312;&#33539;&#22260; [1, 105] &#20869;
1 &lt;= Node.val &lt;= 105
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     </span><span class="org-doc"><span class="org-doc-markup">ListNode()</span></span><span class="org-doc"> : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">ListNode</span>* <span class="org-function-name">removeNodes</span>(<span class="org-type">ListNode</span>* <span class="org-variable-name">head</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21333;&#35843;&#19981;&#22686;&#30340;&#38142;&#34920;&#65306;&#25152;&#26377;&#20803;&#32032;&#20013;&#24403;&#21069;&#20803;&#32032;&#27604;&#21518;&#32487;&#20803;&#32032;&#37117;&#26159;&#22823;&#20110;&#31561;&#20110;&#30340;&#20851;&#31995; 
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">5.&#36882;&#24402;&#20986;&#21475;
</span>        <span class="org-keyword">if</span>(head == <span class="org-constant">NULL</span>) {
            <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
        }
        head-&gt;next = removeNodes(head-&gt;next); <span class="org-comment-delimiter">// </span><span class="org-comment">1.&#20551;&#35774;head-&gt;next&#20808;&#25191;&#34892;&#23436;&#27605;&#65292;BCD&#23601;&#26159;&#21333;&#35843;&#19981;&#22686;&#30340;&#38142;&#34920;
</span>        <span class="org-keyword">if</span>(head-&gt;next == <span class="org-constant">NULL</span>){               <span class="org-comment-delimiter">// </span><span class="org-comment">4. head-&gt;next&#26159;&#31354;&#26102;
</span>            <span class="org-keyword">return</span> head;
        }
        <span class="org-keyword">if</span>(head-&gt;val &lt; head-&gt;next-&gt;val) {      <span class="org-comment-delimiter">// </span><span class="org-comment">2.&#21028;&#26029;A B&#30340;&#20851;&#31995;&#65292;&#23567;&#20110;&#21017;&#21024;&#38500;
</span>            <span class="org-keyword">return</span> head-&gt;next;
        }
        <span class="org-keyword">return</span> head;                          <span class="org-comment-delimiter">// </span><span class="org-comment">3.&#30452;&#25509;&#36820;&#22238;head
</span>    }
};

<span class="org-comment-delimiter">// </span><span class="org-comment">A    -&gt;   B         -&gt; C -&gt; D
</span><span class="org-comment-delimiter">// </span><span class="org-comment">head      head-&gt;next</span>
</pre>
</div>
</div>
</li>
<li><a id="h:01d8f682-d92d-4462-b7b6-5a3aefef14f0"></a><a href="#h:01d8f682-d92d-4462-b7b6-5a3aefef14f0">19.翻倍以链表形式表示的数字</a><br>
<div class="outline-text-6" id="text-h:01d8f682-d92d-4462-b7b6-5a3aefef14f0">
<p>
<a href="https://leetcode.cn/problems/double-a-number-represented-as-a-linked-list/description/">https://leetcode.cn/problems/double-a-number-represented-as-a-linked-list/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010; &#38750;&#31354; &#38142;&#34920;&#30340;&#22836;&#33410;&#28857; head &#65292;&#34920;&#31034;&#19968;&#20010;&#19981;&#21547;&#21069;&#23548;&#38646;&#30340;&#38750;&#36127;&#25968;&#25972;&#25968;&#12290;

&#23558;&#38142;&#34920; &#32763;&#20493; &#21518;&#65292;&#36820;&#22238;&#22836;&#33410;&#28857; head &#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;head = [1,8,9]
&#36755;&#20986;&#65306;[3,7,8]
&#35299;&#37322;&#65306;&#19978;&#22270;&#20013;&#32473;&#20986;&#30340;&#38142;&#34920;&#65292;&#34920;&#31034;&#25968;&#23383; 189 &#12290;&#36820;&#22238;&#30340;&#38142;&#34920;&#34920;&#31034;&#25968;&#23383; 189 * 2 = 378 &#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;head = [9,9,9]
&#36755;&#20986;&#65306;[1,9,9,8]
&#35299;&#37322;&#65306;&#19978;&#22270;&#20013;&#32473;&#20986;&#30340;&#38142;&#34920;&#65292;&#34920;&#31034;&#25968;&#23383; 999 &#12290;&#36820;&#22238;&#30340;&#38142;&#34920;&#34920;&#31034;&#25968;&#23383; 999 * 2 = 1998 &#12290;

&#25552;&#31034;&#65306;
&#38142;&#34920;&#20013;&#33410;&#28857;&#30340;&#25968;&#30446;&#22312;&#33539;&#22260; [1, 104] &#20869;
0 &lt;= Node.val &lt;= 9
&#29983;&#25104;&#30340;&#36755;&#20837;&#28385;&#36275;&#65306;&#38142;&#34920;&#34920;&#31034;&#19968;&#20010;&#19981;&#21547;&#21069;&#23548;&#38646;&#30340;&#25968;&#23383;&#65292;&#38500;&#20102;&#25968;&#23383; 0 &#26412;&#36523;&#12290;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     </span><span class="org-doc"><span class="org-doc-markup">ListNode()</span></span><span class="org-doc"> : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-type">void</span> <span class="org-function-name">doDouble</span>(<span class="org-type">ListNode</span>* <span class="org-variable-name">head</span>, <span class="org-type">int</span>* <span class="org-variable-name">cap</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#25972;&#25968;&#30340;&#30446;&#30340;&#26159;&#35760;&#24405;&#36827;&#20301;&#65292;1&#20026;&#36827;&#20301;&#26159;1&#65292;0&#36827;&#20301;&#26159;0
</span>        <span class="org-keyword">if</span>(head == <span class="org-constant">NULL</span>) {
            *cap = 0;
            <span class="org-keyword">return</span>;
        }
        <span class="org-type">int</span> <span class="org-variable-name">val</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#29992;&#26469;&#25509;&#25910;&#36827;&#20301;
</span>        doDouble(head-&gt;next, &amp;val);
        head-&gt;val = head-&gt;val * 2 + val;
        *cap = head-&gt;val / 10;
        head-&gt;val %= 10;
    }
<span class="org-keyword">public</span>:
    <span class="org-type">ListNode</span>* <span class="org-function-name">doubleIt</span>(<span class="org-type">ListNode</span>* <span class="org-variable-name">head</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#32763;&#20493;&#23601;&#26159;&#20174;&#38142;&#34920;&#23614;&#24320;&#22987;&#20056;2&#36827;&#20301;
</span>        <span class="org-type">int</span> <span class="org-variable-name">val</span>;
        doDouble(head, &amp;val);
        <span class="org-comment-delimiter">/*</span><span class="org-comment">
        if (val == 0) { // &#27809;&#26377;&#36827;&#20301;&#65292;&#30452;&#25509;&#36820;&#22238;head
            return head;
        }
</span><span class="org-comment-delimiter">        */</span>
        <span class="org-keyword">return</span> val == 0 ? head : <span class="org-keyword">new</span> <span class="org-type">ListNode</span>(val, head);
    }
};
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-h:1727c49d-d9e7-47e1-ba88-db9662395ce0" class="outline-3">
<h3 id="h:1727c49d-d9e7-47e1-ba88-db9662395ce0"><a href="#h:1727c49d-d9e7-47e1-ba88-db9662395ce0">应用篇</a></h3>
<div class="outline-text-3" id="text-h:1727c49d-d9e7-47e1-ba88-db9662395ce0">
</div>
<div id="outline-container-h:9d39fa8f-401e-44a2-adb7-2494489c8bf1" class="outline-4">
<h4 id="h:9d39fa8f-401e-44a2-adb7-2494489c8bf1"><a href="#h:9d39fa8f-401e-44a2-adb7-2494489c8bf1">剑网三中的应用</a></h4>
<div class="outline-text-4" id="text-h:9d39fa8f-401e-44a2-adb7-2494489c8bf1">
<p>
链表相对于顺序表的优势在于
</p>
<ul class="org-ul">
<li>对于给定的结点，删除操作优于顺序表</li>
</ul>

<p>
卡分很多种
</p>
<ul class="org-ul">
<li>客户端卡顿</li>
<li>服务器卡顿。这个和电脑配置没关系</li>
</ul>

<p>
任何一个玩家行为都要通知其它玩家，那么就是O(n^2)的时间复杂度，玩家越多自己越卡。
</p>

<p>
所以在MMO游戏开发过程中，有一个经典的概念叫 AOI(Area of Interest)。简单来说，就是每个玩家只关心他周围的玩家的数据同步，而不关心整个游戏世界的玩家数据。实现方式有很多，其中比较经典的实现是 双向十字链表 。
</p>

<p>
双向十字链表
</p>
<ul class="org-ul">
<li>所有玩家都被串联在一个十字链表上，当有玩家移动时，其实是链表上附近结点交换的过程。</li>
<li>每一个玩家想获取附近玩家的数据，只需要在链表上进行遍历即可，而服务器同步给客户端的数据受AOI控制，所以可以根据客户端实际能够承受的性能，调整AOI的半径，比如只显示100米以内的玩家数据。</li>
</ul>

<p>
通过有效的实现AOI技术，游戏开发者可以显著的
</p>
<ul class="org-ul">
<li>减少服务器负载</li>
<li>降低网络延迟</li>
<li>提升游戏性能</li>
<li>增强玩家用户体验</li>
</ul>
</div>
</div>
</div>
</section>
<section id="outline-container-h:828e9793-e732-425f-83d6-738759787427" class="outline-2">
<h2 id="h:828e9793-e732-425f-83d6-738759787427"><a href="#h:828e9793-e732-425f-83d6-738759787427">线性结构-栈</a></h2>
<div class="outline-text-2" id="text-h:828e9793-e732-425f-83d6-738759787427">
</div>
<div id="outline-container-h:07a38c80-720c-42c7-8cae-cefbde443ec3" class="outline-3">
<h3 id="h:07a38c80-720c-42c7-8cae-cefbde443ec3"><a href="#h:07a38c80-720c-42c7-8cae-cefbde443ec3">栈（概念篇）</a></h3>
<div class="outline-text-3" id="text-h:07a38c80-720c-42c7-8cae-cefbde443ec3">
<p>
栈的入栈、栈的出栈、栈的应用
</p>
</div>
<div id="outline-container-h:eff2423f-64a8-4577-abf5-7d90ffb93912" class="outline-4">
<h4 id="h:eff2423f-64a8-4577-abf5-7d90ffb93912"><a href="#h:eff2423f-64a8-4577-abf5-7d90ffb93912">栈的概念</a></h4>
<div class="outline-text-4" id="text-h:eff2423f-64a8-4577-abf5-7d90ffb93912">
<p>
栈是仅限在表尾进行插入和删除的线性表，它遵循后进先出(Last-In-First-Out，LIFO)的原则。栈可以类比为一叠盘子，你只能访问顶部的盘子，而添加或删除盘子只能在顶部进行。
</p>

<p>
在计算机科学中，栈通常用于实现函数调用、递归、表达式求值等操作。我们一般可以用顺序表或者链表来实现栈。
</p>
</div>
</div>
<div id="outline-container-h:ea68e888-0193-445c-a566-9f9b809fd551" class="outline-4">
<h4 id="h:ea68e888-0193-445c-a566-9f9b809fd551"><a href="#h:ea68e888-0193-445c-a566-9f9b809fd551">入栈</a></h4>
<div class="outline-text-4" id="text-h:ea68e888-0193-445c-a566-9f9b809fd551">
<p>
入栈的概念
</p>
<ul class="org-ul">
<li>栈元素的插入操作叫做入栈，也可称为进栈、压栈。直接将元素添加到栈的顶部即可。这个操作类似于将盘子添加到叠盘子的顶部。</li>
</ul>

<p>
入栈的图解
</p>
<ul class="org-ul">
<li>如图所示，新建一个值为1的结点vtx，并且将它压入栈顶，将它标记为新的栈顶，入栈的过程就完成了。</li>
</ul>


<figure id="org80795f5">
<img src="././images/img-2025102320.gif" alt="img-2025102320.gif" width="50%">

</figure>

<p>
入栈的步骤
</p>
<ul class="org-ul">
<li>第1步、将元素压入栈中，并将栈顶指针或素引指向新的栈顶元素。</li>
<li>第2步、栈的大小增加了1，顶部元素为刚刚入栈的元素。</li>
</ul>
</div>
</div>
<div id="outline-container-h:d5232d1a-70ea-46b3-8375-18e31fb956fd" class="outline-4">
<h4 id="h:d5232d1a-70ea-46b3-8375-18e31fb956fd"><a href="#h:d5232d1a-70ea-46b3-8375-18e31fb956fd">出栈</a></h4>
<div class="outline-text-4" id="text-h:d5232d1a-70ea-46b3-8375-18e31fb956fd">
<p>
出栈的概念
</p>
<ul class="org-ul">
<li>栈元素的删除操作叫做出栈，也可称为弹栈。直接将栈的顶部元素删除即可。这个操作类似于将叠盘子的顶部的盘子拿走的过程。</li>
</ul>

<p>
出栈的图解
</p>
<ul class="org-ul">
<li>如图所示，像这样将栈顶的元素删除掉。</li>
</ul>


<figure id="orga6129cd">
<img src="././images/img-2025102321.gif" alt="img-2025102321.gif" width="50%">

</figure>

<p>
出栈的步骤
</p>
<ul class="org-ul">
<li>第1步、将栈顶元素删除掉，并将栈顶指针或素引指向新的栈顶元素。</li>
<li>第2步、栈的大小减小了1。</li>
</ul>
</div>
</div>
<div id="outline-container-h:3212fdfe-4694-4701-b4ab-63e35e80fbba" class="outline-4">
<h4 id="h:3212fdfe-4694-4701-b4ab-63e35e80fbba"><a href="#h:3212fdfe-4694-4701-b4ab-63e35e80fbba">获取栈顶元素</a></h4>
<div class="outline-text-4" id="text-h:3212fdfe-4694-4701-b4ab-63e35e80fbba">
<p>
获取栈顶元素的概念
</p>
<ul class="org-ul">
<li>返回栈顶元素的值，无论是链表还是顺序表，都可以通过栈顶指针在0(1)的时间复杂度获取到栈顶元素。</li>
</ul>

<p>
获取栈顶元素的图解
</p>
<ul class="org-ul">
<li>如图所示，直接通过栈顶指针获取栈顶元素。</li>
</ul>


<figure id="orge81fc5b">
<img src="././images/img-2025102322.gif" alt="img-2025102322.gif" width="50%">

</figure>

<p>
获取栈顶元素的步骤
</p>
<ul class="org-ul">
<li>利用栈顶指针获取栈顶元素，由于是查询操作，所以不会改变栈本身的数据。</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-h:da6598ff-6d32-4141-8574-a28c6f00ffe8" class="outline-3">
<h3 id="h:da6598ff-6d32-4141-8574-a28c6f00ffe8"><a href="#h:da6598ff-6d32-4141-8574-a28c6f00ffe8">代码篇</a></h3>
<div class="outline-text-3" id="text-h:da6598ff-6d32-4141-8574-a28c6f00ffe8">
</div>
<div id="outline-container-h:daade084-0b99-40a1-947e-61fc9a8b257a" class="outline-4">
<h4 id="h:daade084-0b99-40a1-947e-61fc9a8b257a"><a href="#h:daade084-0b99-40a1-947e-61fc9a8b257a">顺序表实现</a></h4>
<div class="outline-text-4" id="text-h:daade084-0b99-40a1-947e-61fc9a8b257a">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdexcept&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">&#24076;&#26395;&#26632;&#20013;&#20803;&#32032;&#33021;&#33258;&#24049;&#23450;&#21046;&#21270;&#65292;&#20351;&#29992;&#27169;&#26495;&#26469;&#23454;&#29616;&#36825;&#20010;&#21151;&#33021;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#26632;&#30340;&#31867;
</span><span class="org-keyword">class</span> <span class="org-type">Stack</span> {
<span class="org-keyword">private</span>:
    <span class="org-type">T</span>* <span class="org-variable-name">data</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">T&#31867;&#22411;&#30340;&#25968;&#32452;, &#39034;&#24207;&#34920;&#20803;&#32032;&#30340;&#39318;&#22320;&#22336;
</span>    <span class="org-type">int</span> <span class="org-variable-name">size</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#20803;&#32032;&#20010;&#25968;
</span>    <span class="org-type">int</span> <span class="org-variable-name">capacity</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#38469;&#30340;&#23481;&#37327;
</span>    <span class="org-type">void</span> <span class="org-function-name">resize</span>();<span class="org-comment-delimiter">// </span><span class="org-comment">&#25193;&#23481;&#20989;&#25968;
</span>
<span class="org-keyword">public</span>:
    <span class="org-function-name">Stack</span>() : data(<span class="org-keyword">new</span> <span class="org-type">T</span>[10]), size(0), capacity(10) {}
    ~<span class="org-function-name">Stack</span>();
    <span class="org-type">void</span> <span class="org-function-name">push</span>(<span class="org-type">T</span> <span class="org-variable-name">element</span>);  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20837;&#26632;
</span>    <span class="org-type">T</span> <span class="org-function-name">pop</span>();               <span class="org-comment-delimiter">// </span><span class="org-comment">&#24377;&#20986;&#19968;&#20010;&#20803;&#32032;
</span>    <span class="org-type">T</span> <span class="org-function-name">top</span>() <span class="org-keyword">const</span>;         <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#19968;&#20010;&#20803;&#32032;&#12290;&#19981;&#38656;&#35201;&#20462;&#25913;&#25104;&#21592;&#21464;&#37327;&#30340;
</span>    <span class="org-type">int</span> <span class="org-function-name">getSize</span>() <span class="org-keyword">const</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">&#26632;&#22823;&#23567;
</span>};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#26632;&#30340;2&#20493;&#25193;&#23481;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">resize</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">newCapacity</span> = capacity * 2;
    <span class="org-type">T</span>* <span class="org-variable-name">newData</span> = <span class="org-keyword">new</span> <span class="org-type">T</span>[newCapacity];
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; size; ++i) {
        newData[i] = data[i];
    }
    <span class="org-keyword">delete</span>[] data;
    data = newData;
    capacity = newCapacity;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#39034;&#24207;&#34920;&#30340;&#26512;&#26500;&#20989;&#25968;: &#21024;&#38500;&#39034;&#24207;&#34920;&#30340;&#25968;&#25454;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::~<span class="org-function-name">Stack</span>() {
    <span class="org-keyword">delete</span>[] data;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#20837;&#26632;&#23454;&#29616;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">push</span>(<span class="org-type">T</span> <span class="org-variable-name">element</span>){
    <span class="org-keyword">if</span> (size == capacity) {
        resize();
    }
    data[size++] = element;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#20986;&#26632;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">T</span> <span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">pop</span>() {
    <span class="org-keyword">if</span> (size == 0) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::underflow_error(<span class="org-string">"Stack is empty"</span>);
    }
    <span class="org-keyword">return</span> data[--size];
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#20803;&#32032;: &#26632;&#30340;&#25351;&#38024;&#19981;&#20250;&#21464;&#21270;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">T</span> <span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">top</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">if</span> (size == 0) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::underflow_error(<span class="org-string">"Stack is empty"</span>);
    }
    <span class="org-keyword">return</span> data[size - 1];
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#26632;&#22823;&#23567;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">int</span> <span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">getSize</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">return</span> size;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">Stack</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">st</span>;
    st.push(4);
    st.push(7);
    st.push(13);
    cout &lt;&lt; st.top() &lt;&lt; endl; <span class="org-comment-delimiter">// </span><span class="org-comment">13
</span>    st.push(17);
    cout &lt;&lt; st.top() &lt;&lt; endl; <span class="org-comment-delimiter">// </span><span class="org-comment">17
</span>    st.pop();
    st.pop();
    cout &lt;&lt; st.top() &lt;&lt; endl; <span class="org-comment-delimiter">// </span><span class="org-comment">7
</span>    cout &lt;&lt; st.getSize() &lt;&lt; endl; <span class="org-comment-delimiter">// </span><span class="org-comment">2
</span>
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-h:fbf72fa7-818f-4b8e-8ea3-aa5e8bdecbd2" class="outline-4">
<h4 id="h:fbf72fa7-818f-4b8e-8ea3-aa5e8bdecbd2"><a href="#h:fbf72fa7-818f-4b8e-8ea3-aa5e8bdecbd2">链表实现</a></h4>
<div class="outline-text-4" id="text-h:fbf72fa7-818f-4b8e-8ea3-aa5e8bdecbd2">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdexcept&gt;</span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#26679;&#26632;&#20013;&#30340;&#27599;&#20010;&#20803;&#32032;&#37117;&#21487;&#20197;&#26159;&#33258;&#23450;&#20041;&#30340;
</span><span class="org-keyword">class</span> <span class="org-type">Stack</span> {
<span class="org-keyword">private</span>:
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#32467;&#28857;&#30340;&#32467;&#26500;&#20307;
</span>    <span class="org-keyword">struct</span> <span class="org-type">Node</span> {
        <span class="org-type">T</span> <span class="org-variable-name">data</span>;
        <span class="org-type">Node</span>* <span class="org-variable-name">next</span>;
        <span class="org-function-name">Node</span>(<span class="org-type">T</span> <span class="org-variable-name">d</span>) : data(d), next(<span class="org-constant">NULL</span>) {}
    };    
    <span class="org-type">Node</span>* <span class="org-variable-name">head</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#22836;&#65292;&#20063;&#26159;&#26632;&#39030;&#20803;&#32032;&#25351;&#38024;
</span>    <span class="org-type">int</span> <span class="org-variable-name">size</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">&#26632;&#20013;&#20803;&#32032;&#20010;&#25968;
</span>
<span class="org-keyword">public</span>:
    <span class="org-function-name">Stack</span>() :head(<span class="org-constant">NULL</span>), size(0) {}
    ~<span class="org-function-name">Stack</span>();
    <span class="org-type">void</span> <span class="org-function-name">push</span>(<span class="org-type">T</span> <span class="org-variable-name">element</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20837;&#26632;
</span>    <span class="org-type">T</span> <span class="org-function-name">pop</span>();              <span class="org-comment-delimiter">// </span><span class="org-comment">&#20986;&#26632;
</span>    <span class="org-type">T</span> <span class="org-function-name">top</span>() <span class="org-keyword">const</span>;         <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#26632;&#39030;
</span>    <span class="org-type">int</span> <span class="org-function-name">getSize</span>() <span class="org-keyword">const</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#26632;&#20013;&#20803;&#32032;&#20010;&#25968;
</span>};

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::~<span class="org-function-name">Stack</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36941;&#21382;&#38142;&#34920;&#65292;&#22914;&#26524;&#21457;&#29616;&#24403;&#21069;&#32467;&#28857;&#19981;&#20026;&#31354;&#26102;&#65292;&#25226;&#26632;&#39030;&#20803;&#32032;&#21462;&#20986;&#24182;&#23384;&#20648;&#22312;temp&#20013;
</span>    <span class="org-keyword">while</span> (head) {
        <span class="org-type">Node</span>* <span class="org-variable-name">temp</span> = head;
        head = head-&gt;next; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;&#26632;&#39030;&#20803;&#32032;&#65292;&#20294;&#20869;&#23384;&#36824;&#22312;&#65292;&#38656;&#35201;&#28165;&#29702;
</span>        <span class="org-keyword">delete</span> temp;
    }
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">push</span>(<span class="org-type">T</span> <span class="org-variable-name">element</span>) {
    <span class="org-type">Node</span>* <span class="org-variable-name">newNode</span> = <span class="org-keyword">new</span> <span class="org-type">Node</span>(element);
    newNode-&gt;next = head;
    head = newNode;
    ++size;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">T</span> <span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">pop</span>() {
    <span class="org-keyword">if</span> (head == <span class="org-constant">NULL</span>) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::underflow_error(<span class="org-string">"Stack is empty"</span>);
    }
    <span class="org-type">T</span> <span class="org-variable-name">result</span> = head-&gt;data;
    <span class="org-type">Node</span>* <span class="org-variable-name">temp</span> = head;
    head = head-&gt;next;
    <span class="org-keyword">delete</span> temp;
    --size;
    <span class="org-keyword">return</span> result;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">T</span> <span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">top</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">if</span> (head == <span class="org-constant">NULL</span>) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::underflow_error(<span class="org-string">"Stack is empty"</span>);
    }
    <span class="org-keyword">return</span> head-&gt;data;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">int</span> <span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">getSize</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">return</span> size;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">Stack</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">st</span>;
    st.push(4);
    st.push(7);
    st.push(13);
    cout &lt;&lt; st.top() &lt;&lt; endl;
    st.push(17);
    cout &lt;&lt; st.top() &lt;&lt; endl;
    st.pop();
    st.pop();
    cout &lt;&lt; st.top() &lt;&lt; endl;
    cout &lt;&lt; st.getSize() &lt;&lt; endl;


    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-h:44a092a7-b2bf-46e6-a541-11187b9ae9bb" class="outline-4">
<h4 id="h:44a092a7-b2bf-46e6-a541-11187b9ae9bb"><a href="#h:44a092a7-b2bf-46e6-a541-11187b9ae9bb">C++中的栈实现（stack）</a></h4>
<div class="outline-text-4" id="text-h:44a092a7-b2bf-46e6-a541-11187b9ae9bb">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stack&gt;</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">&#24341;&#20837;&#26632; &#30340;&#22836;&#25991;&#20214;&#65292;&#23427;&#20854;&#23454;&#26159;&#19968;&#20010;&#27169;&#26495;&#31867;
</span><span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">stack</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">intStk</span>;
    <span class="org-type">stack</span>&lt;<span class="org-type">double</span>&gt; <span class="org-variable-name">doubleStk</span>;
    doubleStk.push(1.1);
    doubleStk.push(2.2);
    doubleStk.push(3.3);
    doubleStk.push(4.4);
    <span class="org-keyword">while</span> (<span class="org-negation-char">!</span>doubleStk.empty()) {
        cout &lt;&lt; doubleStk.top() &lt;&lt; <span class="org-string">" "</span>;
        doubleStk.pop();
    }
    <span class="org-keyword">return</span> 0;
}

<span class="org-comment-delimiter">/*</span><span class="org-comment">
empty() &#21028;&#31354;
push(v) &#20837;&#26632;&#12290;&#22622;&#20837;&#20803;&#32032;
pop()  &#24377;&#20986;
top() &#33719;&#21462;&#26632;&#39030;&#20803;&#32032;
</span><span class="org-comment-delimiter">*/</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:88fb4ab1-1ca1-47d9-8355-8a9edaaaa13d" class="outline-3">
<h3 id="h:88fb4ab1-1ca1-47d9-8355-8a9edaaaa13d"><a href="#h:88fb4ab1-1ca1-47d9-8355-8a9edaaaa13d">实战篇</a></h3>
<div class="outline-text-3" id="text-h:88fb4ab1-1ca1-47d9-8355-8a9edaaaa13d">
</div>
<div id="outline-container-h:eb9d7667-c427-41cd-9dd2-3a4d8e23c90b" class="outline-4">
<h4 id="h:eb9d7667-c427-41cd-9dd2-3a4d8e23c90b"><a href="#h:eb9d7667-c427-41cd-9dd2-3a4d8e23c90b">ACM模式</a></h4>
<div class="outline-text-4" id="text-h:eb9d7667-c427-41cd-9dd2-3a4d8e23c90b">
</div>
<div id="outline-container-h:5e75fad7-96bb-460d-b99d-2af3e8cd19e8" class="outline-5">
<h5 id="h:5e75fad7-96bb-460d-b99d-2af3e8cd19e8"><a href="#h:5e75fad7-96bb-460d-b99d-2af3e8cd19e8">1.进制转换</a></h5>
<div class="outline-text-5" id="text-h:5e75fad7-96bb-460d-b99d-2af3e8cd19e8">
<p>
<a href="https://acm.hdu.edu.cn/showproblem.php?pid=2031">https://acm.hdu.edu.cn/showproblem.php?pid=2031</a>
</p>

<p>
所谓进制转换，就是把一个数除上这个数(多少进制)，并且把余数存起来，最后把余数逆序输出。涉及到逆序，用栈就非常合适。
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdexcept&gt;</span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#26679;&#26632;&#20013;&#30340;&#27599;&#20010;&#20803;&#32032;&#37117;&#21487;&#20197;&#26159;&#33258;&#23450;&#20041;&#30340;
</span><span class="org-keyword">class</span> <span class="org-type">Stack</span> {
<span class="org-keyword">private</span>:
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#32467;&#28857;&#30340;&#32467;&#26500;&#20307;
</span>    <span class="org-keyword">struct</span> <span class="org-type">Node</span> {
        <span class="org-type">T</span> <span class="org-variable-name">data</span>;
        <span class="org-type">Node</span>* <span class="org-variable-name">next</span>;
        <span class="org-function-name">Node</span>(<span class="org-type">T</span> <span class="org-variable-name">d</span>) : data(d), next(<span class="org-constant">NULL</span>) {}
    };
    <span class="org-type">Node</span>* <span class="org-variable-name">head</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#22836;&#65292;&#20063;&#26159;&#26632;&#39030;&#20803;&#32032;&#25351;&#38024;
</span>    <span class="org-type">int</span> <span class="org-variable-name">size</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">&#26632;&#20013;&#20803;&#32032;&#20010;&#25968;
</span>
<span class="org-keyword">public</span>:
    <span class="org-function-name">Stack</span>() :head(<span class="org-constant">NULL</span>), size(0) {}
    ~<span class="org-function-name">Stack</span>();
    <span class="org-type">void</span> <span class="org-function-name">push</span>(<span class="org-type">T</span> <span class="org-variable-name">element</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20837;&#26632;
</span>    <span class="org-type">T</span> <span class="org-function-name">pop</span>();              <span class="org-comment-delimiter">// </span><span class="org-comment">&#20986;&#26632;
</span>    <span class="org-type">T</span> <span class="org-function-name">top</span>() <span class="org-keyword">const</span>;         <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#26632;&#39030;
</span>    <span class="org-type">int</span> <span class="org-function-name">getSize</span>() <span class="org-keyword">const</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#26632;&#20013;&#20803;&#32032;&#20010;&#25968;
</span>};

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::~<span class="org-function-name">Stack</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36941;&#21382;&#38142;&#34920;&#65292;&#22914;&#26524;&#21457;&#29616;&#24403;&#21069;&#32467;&#28857;&#19981;&#20026;&#31354;&#26102;&#65292;&#25226;&#26632;&#39030;&#20803;&#32032;&#21462;&#20986;&#24182;&#23384;&#20648;&#22312;temp&#20013;
</span>    <span class="org-keyword">while</span> (head) {
        <span class="org-type">Node</span>* <span class="org-variable-name">temp</span> = head;
        head = head-&gt;next; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;&#26632;&#39030;&#20803;&#32032;&#65292;&#20294;&#20869;&#23384;&#36824;&#22312;&#65292;&#38656;&#35201;&#28165;&#29702;
</span>        <span class="org-keyword">delete</span> temp;
    }
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">push</span>(<span class="org-type">T</span> <span class="org-variable-name">element</span>) {
    <span class="org-type">Node</span>* <span class="org-variable-name">newNode</span> = <span class="org-keyword">new</span> <span class="org-type">Node</span>(element);
    newNode-&gt;next = head;
    head = newNode;
    ++size;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">T</span> <span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">pop</span>() {
    <span class="org-keyword">if</span> (head == <span class="org-constant">NULL</span>) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::underflow_error(<span class="org-string">"Stack is empty"</span>);
    }
    <span class="org-type">T</span> <span class="org-variable-name">result</span> = head-&gt;data;
    <span class="org-type">Node</span>* <span class="org-variable-name">temp</span> = head;
    head = head-&gt;next;
    <span class="org-keyword">delete</span> temp;
    --size;
    <span class="org-keyword">return</span> result;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">T</span> <span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">top</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">if</span> (head == <span class="org-constant">NULL</span>) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::underflow_error(<span class="org-string">"Stack is empty"</span>);
    }
    <span class="org-keyword">return</span> head-&gt;data;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">int</span> <span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">getSize</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">return</span> size;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">N</span>, <span class="org-variable-name">x</span>;
    <span class="org-keyword">while</span> (cin &gt;&gt; N &gt;&gt; x) {
        <span class="org-keyword">if</span> (N == 0) {
            cout &lt;&lt; 0 &lt;&lt; endl;
            <span class="org-keyword">continue</span>;
        }
        <span class="org-keyword">if</span> (N &lt; 0) {
            cout &lt;&lt; <span class="org-string">'-'</span>;
            N = -N; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#26679;&#65292;&#21482;&#38656;&#35201;&#22788;&#29702;N&#20026;&#27491;&#25968;&#30340;&#24773;&#20917;
</span>        }
        <span class="org-type">Stack</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">stk</span>;
        <span class="org-keyword">while</span> (N) {
            stk.push(N % x);
            N /= x;
        }
        <span class="org-keyword">while</span> (stk.getSize()) {
            <span class="org-type">int</span> <span class="org-variable-name">x</span> = stk.pop();
            <span class="org-keyword">if</span> (x &gt; 10) {
                printf(<span class="org-string">"%c"</span>, <span class="org-string">'A'</span> + x - 10);
            }
            <span class="org-keyword">else</span> {
                printf(<span class="org-string">"%d"</span>, x);
            }
        }
        cout &lt;&lt; endl;
    }
    
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-h:eba9209e-c776-4acc-a55d-9a7d3efd0ebe" class="outline-5">
<h5 id="h:eba9209e-c776-4acc-a55d-9a7d3efd0ebe"><a href="#h:eba9209e-c776-4acc-a55d-9a7d3efd0ebe">2.Bitset</a></h5>
<div class="outline-text-5" id="text-h:eba9209e-c776-4acc-a55d-9a7d3efd0ebe">
<p>
<a href="https://acm.hdu.edu.cn/showproblem.php?pid=2051">https://acm.hdu.edu.cn/showproblem.php?pid=2051</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdexcept&gt;</span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#26679;&#26632;&#20013;&#30340;&#27599;&#20010;&#20803;&#32032;&#37117;&#21487;&#20197;&#26159;&#33258;&#23450;&#20041;&#30340;
</span><span class="org-keyword">class</span> <span class="org-type">Stack</span> {
<span class="org-keyword">private</span>:
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#32467;&#28857;&#30340;&#32467;&#26500;&#20307;
</span>    <span class="org-keyword">struct</span> <span class="org-type">Node</span> {
        <span class="org-type">T</span> <span class="org-variable-name">data</span>;
        <span class="org-type">Node</span>* <span class="org-variable-name">next</span>;
        <span class="org-function-name">Node</span>(<span class="org-type">T</span> <span class="org-variable-name">d</span>) : data(d), next(<span class="org-constant">NULL</span>) {}
    };
    <span class="org-type">Node</span>* <span class="org-variable-name">head</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#22836;&#65292;&#20063;&#26159;&#26632;&#39030;&#20803;&#32032;&#25351;&#38024;
</span>    <span class="org-type">int</span> <span class="org-variable-name">size</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">&#26632;&#20013;&#20803;&#32032;&#20010;&#25968;
</span>
<span class="org-keyword">public</span>:
    <span class="org-function-name">Stack</span>() :head(<span class="org-constant">NULL</span>), size(0) {}
    ~<span class="org-function-name">Stack</span>();
    <span class="org-type">void</span> <span class="org-function-name">push</span>(<span class="org-type">T</span> <span class="org-variable-name">element</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20837;&#26632;
</span>    <span class="org-type">T</span> <span class="org-function-name">pop</span>();              <span class="org-comment-delimiter">// </span><span class="org-comment">&#20986;&#26632;
</span>    <span class="org-type">T</span> <span class="org-function-name">top</span>() <span class="org-keyword">const</span>;         <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#26632;&#39030;
</span>    <span class="org-type">int</span> <span class="org-function-name">getSize</span>() <span class="org-keyword">const</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#26632;&#20013;&#20803;&#32032;&#20010;&#25968;
</span>};

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::~<span class="org-function-name">Stack</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36941;&#21382;&#38142;&#34920;&#65292;&#22914;&#26524;&#21457;&#29616;&#24403;&#21069;&#32467;&#28857;&#19981;&#20026;&#31354;&#26102;&#65292;&#25226;&#26632;&#39030;&#20803;&#32032;&#21462;&#20986;&#24182;&#23384;&#20648;&#22312;temp&#20013;
</span>    <span class="org-keyword">while</span> (head) {
        <span class="org-type">Node</span>* <span class="org-variable-name">temp</span> = head;
        head = head-&gt;next; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;&#26632;&#39030;&#20803;&#32032;&#65292;&#20294;&#20869;&#23384;&#36824;&#22312;&#65292;&#38656;&#35201;&#28165;&#29702;
</span>        <span class="org-keyword">delete</span> temp;
    }
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">push</span>(<span class="org-type">T</span> <span class="org-variable-name">element</span>) {
    <span class="org-type">Node</span>* <span class="org-variable-name">newNode</span> = <span class="org-keyword">new</span> <span class="org-type">Node</span>(element);
    newNode-&gt;next = head;
    head = newNode;
    ++size;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">T</span> <span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">pop</span>() {
    <span class="org-keyword">if</span> (head == <span class="org-constant">NULL</span>) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::underflow_error(<span class="org-string">"Stack is empty"</span>);
    }
    <span class="org-type">T</span> <span class="org-variable-name">result</span> = head-&gt;data;
    <span class="org-type">Node</span>* <span class="org-variable-name">temp</span> = head;
    head = head-&gt;next;
    <span class="org-keyword">delete</span> temp;
    --size;
    <span class="org-keyword">return</span> result;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">T</span> <span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">top</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">if</span> (head == <span class="org-constant">NULL</span>) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::underflow_error(<span class="org-string">"Stack is empty"</span>);
    }
    <span class="org-keyword">return</span> head-&gt;data;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">int</span> <span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">getSize</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">return</span> size;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">n</span>;
    <span class="org-keyword">while</span> (cin &gt;&gt; n) {
        <span class="org-type">Stack</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">stk</span>;
        <span class="org-keyword">while</span> (n) {
            stk.push(n % 2);
            n /= 2;
        }
        <span class="org-keyword">while</span> (stk.getSize()) {
            cout &lt;&lt; stk.pop();
        }
        cout &lt;&lt; endl;
    }
    
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:4dc90428-d127-4f75-818b-cc3b29fee143" class="outline-4">
<h4 id="h:4dc90428-d127-4f75-818b-cc3b29fee143"><a href="#h:4dc90428-d127-4f75-818b-cc3b29fee143">核心代码模式</a></h4>
<div class="outline-text-4" id="text-h:4dc90428-d127-4f75-818b-cc3b29fee143">
</div>
<div id="outline-container-h:f24606b7-9d1f-47ea-844e-d5309d094c3a" class="outline-5">
<h5 id="h:f24606b7-9d1f-47ea-844e-d5309d094c3a"><a href="#h:f24606b7-9d1f-47ea-844e-d5309d094c3a">3.图书整理 I</a></h5>
<div class="outline-text-5" id="text-h:f24606b7-9d1f-47ea-844e-d5309d094c3a">
<p>
<a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/description/">https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#20070;&#24215;&#24215;&#21592;&#26377;&#19968;&#24352;&#38142;&#34920;&#24418;&#24335;&#30340;&#20070;&#21333;&#65292;&#27599;&#20010;&#33410;&#28857;&#20195;&#34920;&#19968;&#26412;&#20070;&#65292;&#33410;&#28857;&#20013;&#30340;&#20540;&#34920;&#31034;&#20070;&#30340;&#32534;&#21495;&#12290;
&#20026;&#26356;&#26041;&#20415;&#25972;&#29702;&#20070;&#26550;&#65292;&#24215;&#21592;&#38656;&#35201;&#23558;&#20070;&#21333;&#20498;&#36807;&#26469;&#25490;&#21015;&#65292;&#23601;&#21487;&#20197;&#20174;&#26368;&#21518;&#19968;&#26412;&#20070;&#24320;&#22987;&#25972;&#29702;&#65292;&#36880;&#19968;&#23558;&#20070;&#25918;&#22238;&#21040;&#20070;&#26550;&#19978;&#12290;&#35831;&#20498;&#24207;&#36820;&#22238;&#36825;&#20010;&#20070;&#21333;&#38142;&#34920;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;head = [3,6,4,1]
&#36755;&#20986;&#65306;[1,4,6,3]

&#25552;&#31034;&#65306;
0 &lt;= &#38142;&#34920;&#38271;&#24230; &lt;= 10000
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     </span><span class="org-doc"><span class="org-doc-markup">ListNode()</span></span><span class="org-doc"> : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-function-name">reverseBookList</span>(<span class="org-type">ListNode</span>* <span class="org-variable-name">head</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#20854;&#23454;&#19978;&#26159;&#23545;&#38142;&#34920;&#20570;&#36870;&#24207;&#65292;&#23384;&#20648;&#21040;&#39034;&#24207;&#34920;&#20013;&#36827;&#34892;&#36820;&#22238;&#12290;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#20961;&#26159;&#28041;&#21450;&#21040;&#36870;&#24207;&#65292;&#37117;&#21487;&#20197;&#21644;&#26632;&#32852;&#31995;&#36215;&#26469;&#65292;&#22240;&#20026;&#23427;&#26159;&#20808;&#36827;&#21518;&#20986;&#30340;&#65307;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;&#38142;&#34920;&#20013;&#30340;&#20803;&#32032;&#25918;&#20837;&#26632;&#20013;&#65292;&#21033;&#29992;&#24377;&#26632;&#30340;&#26041;&#24335;&#23558;&#24377;&#20986;&#30340;&#20803;&#32032;&#36880;&#27425;&#25918;&#20837;&#39034;&#24207;&#21015;&#20013;
</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">1.&#36941;&#21382;&#38142;&#34920;&#65292;&#36880;&#20010;&#21387;&#26632;
</span>        <span class="org-type">stack</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">stk</span>;
        <span class="org-keyword">while</span>(head) {
            stk.push(head-&gt;val);
            head = head-&gt;next;
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">2.&#29983;&#25104;&#39034;&#24207;&#34920;ans&#65292;&#23558;&#26632;&#20869;&#20803;&#32032;&#19968;&#20010;&#20010;&#24377;&#20986;&#23384;&#20837;&#39034;&#24207;&#34920;&#20013;
</span>        <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">ans</span>;
        <span class="org-keyword">while</span>(<span class="org-negation-char">!</span>stk.empty()){
            ans.push_back(stk.top());
            stk.pop();
        }
        <span class="org-keyword">return</span> ans;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:9092139e-5dbd-4547-bfd2-d738c95b3cd2" class="outline-5">
<h5 id="h:9092139e-5dbd-4547-bfd2-d738c95b3cd2"><a href="#h:9092139e-5dbd-4547-bfd2-d738c95b3cd2">4.回文链表</a></h5>
<div class="outline-text-5" id="text-h:9092139e-5dbd-4547-bfd2-d738c95b3cd2">
<p>
<a href="https://leetcode.cn/problems/aMhZSa/description/">https://leetcode.cn/problems/aMhZSa/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#23450;&#19968;&#20010;&#38142;&#34920;&#30340; &#22836;&#33410;&#28857; head &#65292;&#35831;&#21028;&#26029;&#20854;&#26159;&#21542;&#20026;&#22238;&#25991;&#38142;&#34920;&#12290;

&#22914;&#26524;&#19968;&#20010;&#38142;&#34920;&#26159;&#22238;&#25991;&#65292;&#37027;&#20040;&#38142;&#34920;&#33410;&#28857;&#24207;&#21015;&#20174;&#21069;&#24448;&#21518;&#30475;&#21644;&#20174;&#21518;&#24448;&#21069;&#30475;&#26159;&#30456;&#21516;&#30340;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;: head = [1,2,3,3,2,1]
&#36755;&#20986;: true

&#31034;&#20363; 2&#65306;
&#36755;&#20837;: head = [1,2]
&#36755;&#20986;: false

&#25552;&#31034;&#65306;
&#38142;&#34920; L &#30340;&#38271;&#24230;&#33539;&#22260;&#20026; [1, 105]
0 &lt;= node.val &lt;= 9
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     </span><span class="org-doc"><span class="org-doc-markup">ListNode()</span></span><span class="org-doc"> : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">bool</span> <span class="org-function-name">isPalindrome</span>(<span class="org-type">ListNode</span>* <span class="org-variable-name">head</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#36825;&#20010;&#38142;&#34920;&#36870;&#24207;&#21518;&#65292;&#21644;&#21407;&#26469;&#38142;&#34920;&#20803;&#32032;&#19968;&#19968;&#23545;&#24212;&#65292;&#36825;&#20010;&#38142;&#34920;&#24517;&#28982;&#26159;&#20010;&#22238;&#25991;&#38142;&#34920;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21487;&#20197;&#25226;&#38142;&#34920;&#30340;&#20803;&#32032;&#19981;&#26029;&#22320;&#21387;&#20837;&#26632;&#65292;&#28982;&#21518;&#24377;&#20986;&#26632;&#39030;&#20803;&#32032;&#21644;&#38142;&#34920;&#20803;&#32032;&#27604;&#36739;&#65292;&#19981;&#30456;&#31561;&#23601;&#19981;&#26159;&#22238;&#25991;&#12290;
</span>        <span class="org-type">stack</span>&lt;<span class="org-type">ListNode</span>*&gt; <span class="org-variable-name">stk</span>;
        <span class="org-type">ListNode</span>* <span class="org-variable-name">tmp</span> = head;
        <span class="org-keyword">while</span> (tmp) {
            stk.push(tmp);
            tmp = tmp-&gt;next;
        }
        <span class="org-keyword">while</span>(head){
            <span class="org-keyword">if</span>(head-&gt;val != stk.top()-&gt;val) {
                <span class="org-keyword">return</span> <span class="org-constant">false</span>;
            }
            stk.pop();
            head = head-&gt;next;
        }
        <span class="org-keyword">return</span> <span class="org-constant">true</span>;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:d319b5ff-75d3-4288-b76d-b7f6faa58cb9" class="outline-5">
<h5 id="h:d319b5ff-75d3-4288-b76d-b7f6faa58cb9"><a href="#h:d319b5ff-75d3-4288-b76d-b7f6faa58cb9">5.括号的最大嵌套深度</a></h5>
<div class="outline-text-5" id="text-h:d319b5ff-75d3-4288-b76d-b7f6faa58cb9">
<p>
<a href="https://leetcode.cn/problems/maximum-nesting-depth-of-the-parentheses/description/">https://leetcode.cn/problems/maximum-nesting-depth-of-the-parentheses/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#23450; &#26377;&#25928;&#25324;&#21495;&#23383;&#31526;&#20018; s&#65292;&#36820;&#22238; s &#30340; &#23884;&#22871;&#28145;&#24230;&#12290;&#23884;&#22871;&#28145;&#24230;&#26159;&#23884;&#22871;&#25324;&#21495;&#30340; &#26368;&#22823; &#25968;&#37327;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;s = "(1+(2*3)+((8)/4))+1"
&#36755;&#20986;&#65306;3
&#35299;&#37322;&#65306;&#25968;&#23383; 8 &#22312;&#23884;&#22871;&#30340; 3 &#23618;&#25324;&#21495;&#20013;&#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;s = "(1)+((2))+(((3)))"
&#36755;&#20986;&#65306;3
&#35299;&#37322;&#65306;&#25968;&#23383; 3 &#22312;&#23884;&#22871;&#30340; 3 &#23618;&#25324;&#21495;&#20013;&#12290;

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;s = "()(())((()()))"
&#36755;&#20986;&#65306;3

&#25552;&#31034;&#65306;
1 &lt;= s.length &lt;= 100
s &#30001;&#25968;&#23383; 0-9 &#21644;&#23383;&#31526; '+'&#12289;'-'&#12289;'*'&#12289;'/'&#12289;'('&#12289;')' &#32452;&#25104;
&#39064;&#30446;&#25968;&#25454;&#20445;&#35777;&#25324;&#21495;&#23383;&#31526;&#20018; s &#26159; &#26377;&#25928;&#30340;&#25324;&#21495;&#23383;&#31526;&#20018;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">maxDepth</span>(<span class="org-type">string</span> <span class="org-variable-name">s</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#32473;&#23450;&#19968;&#20010;&#24102;&#25324;&#21495;&#30340;&#23383;&#31526;&#20018;&#65292;&#25324;&#21495;&#37117;&#26159;&#21305;&#37197;&#30340;&#65292;&#25324;&#21495;&#25903;&#25345;&#23884;&#22871;&#65292;&#27714;&#23884;&#22871;&#30340;&#26368;&#28145;&#30340;&#25324;&#21495;&#23618;&#25968;&#65311;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#36941;&#21382;&#23383;&#31526;&#20018;x&#65292;&#22914;&#26524;&#36935;&#21040;&#24038;&#25324;&#21495;&#20837;&#26632;&#65292;&#22914;&#26524;&#36935;&#21040;&#21491;&#25324;&#21495;&#23601;&#24377;&#20986;&#26632;&#39030;&#24038;&#25324;&#21495;&#65292;&#36825;&#20010;&#36807;&#31243;&#20013;&#26632;&#30340;&#22823;&#23567;&#30340;&#26368;&#22823;&#20540;&#23601;&#26159;s&#30340;&#23884;&#22871;&#28145;&#24230;
</span>
        <span class="org-type">int</span> <span class="org-variable-name">ret</span> = 0, <span class="org-variable-name">top</span> = 0; <span class="org-comment-delimiter">// </span><span class="org-comment">top &#26632;&#20803;&#32032;&#20010;&#25968;&#65292;ret&#25324;&#21495;&#23618;&#25968;
</span>        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; s.size(); ++i) {
            <span class="org-keyword">if</span> (s[i] == <span class="org-string">'('</span>) {
                ++top;
                ret = max(ret, top); <span class="org-comment-delimiter">// </span><span class="org-comment">&#35760;&#24405;&#26368;&#22823;&#20540;&#21040;ret&#20013;
</span>            }<span class="org-keyword">else</span> <span class="org-keyword">if</span> (s[i] == <span class="org-string">')'</span>) {
                --top;
            }
        }
        <span class="org-keyword">return</span> ret;
        
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:1ea2bdd8-8742-4359-a0af-fd9e04b4c2c5" class="outline-5">
<h5 id="h:1ea2bdd8-8742-4359-a0af-fd9e04b4c2c5"><a href="#h:1ea2bdd8-8742-4359-a0af-fd9e04b4c2c5">6.有效的括号</a></h5>
<div class="outline-text-5" id="text-h:1ea2bdd8-8742-4359-a0af-fd9e04b4c2c5">
<p>
<a href="https://leetcode.cn/problems/valid-parentheses/description/">https://leetcode.cn/problems/valid-parentheses/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#23450;&#19968;&#20010;&#21482;&#21253;&#25324; '('&#65292;')'&#65292;'{'&#65292;'}'&#65292;'['&#65292;']' &#30340;&#23383;&#31526;&#20018; s &#65292;&#21028;&#26029;&#23383;&#31526;&#20018;&#26159;&#21542;&#26377;&#25928;&#12290;

&#26377;&#25928;&#23383;&#31526;&#20018;&#38656;&#28385;&#36275;&#65306;

&#24038;&#25324;&#21495;&#24517;&#39035;&#29992;&#30456;&#21516;&#31867;&#22411;&#30340;&#21491;&#25324;&#21495;&#38381;&#21512;&#12290;
&#24038;&#25324;&#21495;&#24517;&#39035;&#20197;&#27491;&#30830;&#30340;&#39034;&#24207;&#38381;&#21512;&#12290;
&#27599;&#20010;&#21491;&#25324;&#21495;&#37117;&#26377;&#19968;&#20010;&#23545;&#24212;&#30340;&#30456;&#21516;&#31867;&#22411;&#30340;&#24038;&#25324;&#21495;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;s = "()"
&#36755;&#20986;&#65306;true

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;s = "()[]{}"
&#36755;&#20986;&#65306;true

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;s = "(]"
&#36755;&#20986;&#65306;false

&#31034;&#20363; 4&#65306;
&#36755;&#20837;&#65306;s = "([])"
&#36755;&#20986;&#65306;true

&#31034;&#20363; 5&#65306;
&#36755;&#20837;&#65306;s = "([)]"
&#36755;&#20986;&#65306;false

&#25552;&#31034;&#65306;
1 &lt;= s.length &lt;= 104
s &#20165;&#30001;&#25324;&#21495; '()[]{}' &#32452;&#25104;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-type">bool</span> <span class="org-function-name">isLeft</span>(<span class="org-type">char</span> <span class="org-variable-name">c</span>) {
        <span class="org-keyword">return</span> c == <span class="org-string">'('</span> || c == <span class="org-string">'['</span> || c == <span class="org-string">'{'</span>;
    }

    <span class="org-type">bool</span> <span class="org-function-name">isMatch</span>(<span class="org-type">char</span> <span class="org-variable-name">l</span>, <span class="org-type">char</span> <span class="org-variable-name">r</span>) {
        <span class="org-keyword">return</span> l == <span class="org-string">'('</span> &amp;&amp; r == <span class="org-string">')'</span> ||
        l == <span class="org-string">'['</span> &amp;&amp; r == <span class="org-string">']'</span> ||
        l == <span class="org-string">'{'</span> &amp;&amp; r == <span class="org-string">'}'</span>;
    }
<span class="org-keyword">public</span>:
    <span class="org-type">bool</span> <span class="org-function-name">isValid</span>(<span class="org-type">string</span> <span class="org-variable-name">s</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#25152;&#26377;&#30340;&#24038;&#25324;&#21495;&#37117;&#26377;&#21491;&#25324;&#21495;&#38381;&#21512;
</span>        <span class="org-type">stack</span>&lt;<span class="org-type">char</span>&gt; <span class="org-variable-name">stk</span>;
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; s.size(); ++i) {
            <span class="org-keyword">if</span> (isLeft(<span class="org-type">s</span>[i])) {
                stk.push(<span class="org-type">s</span>[i]);
            }<span class="org-keyword">else</span> {
                <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26632;&#20013;&#27809;&#26377;&#20803;&#32032;&#65292;&#24517;&#28982;&#32570;&#23569;&#21644;&#23427;&#21305;&#37197;&#30340;&#24038;&#25324;&#21495;&#65292;&#30452;&#25509;&#36820;&#22238;false
</span>                <span class="org-keyword">if</span> (stk.empty()) { 
                    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
                }
                <span class="org-comment-delimiter">// </span><span class="org-comment">&#21644;&#21491;&#25324;&#21495;&#21305;&#37197;&#65292;&#19981;&#33021;&#21305;&#37197;&#36820;&#22238;false
</span>                <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>isMatch(stk.top(), <span class="org-type">s</span>[i])) {
                    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
                }
                stk.pop();
            }
        }
        <span class="org-keyword">return</span> stk.empty(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#26632;&#20026;&#31354;&#26102;&#25165;&#31639;&#21305;&#37197;&#23436;&#27605;
</span>    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:3074620b-ea7d-4c9a-83b2-452f90e7e9cc" class="outline-5">
<h5 id="h:3074620b-ea7d-4c9a-83b2-452f90e7e9cc"><a href="#h:3074620b-ea7d-4c9a-83b2-452f90e7e9cc">7.每日温度</a></h5>
<div class="outline-text-5" id="text-h:3074620b-ea7d-4c9a-83b2-452f90e7e9cc">
<p>
<a href="https://leetcode.cn/problems/daily-temperatures/description/">https://leetcode.cn/problems/daily-temperatures/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#23450;&#19968;&#20010;&#25972;&#25968;&#25968;&#32452; temperatures &#65292;&#34920;&#31034;&#27599;&#22825;&#30340;&#28201;&#24230;&#65292;&#36820;&#22238;&#19968;&#20010;&#25968;&#32452; answer &#65292;
&#20854;&#20013; answer[i] &#26159;&#25351;&#23545;&#20110;&#31532; i &#22825;&#65292;&#19979;&#19968;&#20010;&#26356;&#39640;&#28201;&#24230;&#20986;&#29616;&#22312;&#20960;&#22825;&#21518;&#12290;&#22914;&#26524;&#27668;&#28201;&#22312;&#36825;&#20043;&#21518;&#37117;&#19981;&#20250;&#21319;&#39640;&#65292;&#35831;&#22312;&#35813;&#20301;&#32622;&#29992; 0 &#26469;&#20195;&#26367;&#12290;


&#31034;&#20363; 1:
&#36755;&#20837;: temperatures = [73,74,75,71,69,72,76,73]
&#36755;&#20986;: [1,1,4,2,1,1,0,0]

&#31034;&#20363; 2:
&#36755;&#20837;: temperatures = [30,40,50,60]
&#36755;&#20986;: [1,1,1,0]

&#31034;&#20363; 3:
&#36755;&#20837;: temperatures = [30,60,90]
&#36755;&#20986;: [1,1,0]

&#25552;&#31034;&#65306;
1 &lt;= temperatures.length &lt;= 105
30 &lt;= temperatures[i] &lt;= 100
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-function-name">dailyTemperatures</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">temperatures</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;&#26632;&#29992;vector&#26469;&#27169;&#25311;
</span>        <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">stk</span>;
        <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">ans</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#25152;&#26377;&#25968;&#23383;&#37117;&#21333;&#35843;&#36882;&#20943;&#65292;&#37027;&#20040;&#21487;&#20197;&#20808;&#25226;ans&#25152;&#26377;&#20803;&#32032;&#21021;&#22987;&#21270;&#20026;0
</span>        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; temperatures.size(); ++i) {
            ans.push_back(0);
        }
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; temperatures.size(); ++i) {
            <span class="org-keyword">if</span>(stk.size() == 0) {
                stk.push_back(i);  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26632;&#22823;&#23567;&#20026;0&#65292;&#25226;&#19979;&#26631;&#21387;&#20837;&#26632;&#20013;
</span>            }<span class="org-keyword">else</span> {
                <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26632;&#39030;&#26377;&#20803;&#32032;&#65292;&#23384;&#20648;&#30340;&#26159;&#28201;&#24230;&#19979;&#26631;; &#22914;&#26524;&#28201;&#24230;&#20540;&#23567;&#20110;&#24403;&#21069;&#28201;&#24230;, &#35828;&#26126;&#19979;&#19968;&#20010;&#26356;&#39640;&#30340;&#28201;&#24230;&#23601;&#26159;i
</span>                <span class="org-keyword">while</span>(stk.size() &amp;&amp; temperatures[ stk.back() ] &lt; temperatures[i]) {
                    ans[stk.back()] = i - stk.back();
                    stk.pop_back();
                }
                stk.push_back(i); 
            }
        }
        <span class="org-keyword">return</span> ans;
        
    }
};

<span class="org-comment-delimiter">/*</span><span class="org-comment">
&#23545;&#20110;&#20219;&#24847;&#19968;&#20010;&#25968;&#65292;&#21521;&#21491;&#25214;&#31532;1&#20010;&#27604;&#23427;&#22823;&#30340;&#25968;&#65292;&#21521;&#21491;&#25214;&#20960;&#20301;
1 2 3 4 5
1 1 1 1 0

9 8 7 6 5
0 0 0 0 0
</span><span class="org-comment-delimiter">*/</span>
</pre>
</div>

<p>
优化一下
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-function-name">dailyTemperatures</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">temperatures</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;&#26632;&#29992;vector&#26469;&#27169;&#25311;
</span>        <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">stk</span>;
        <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">ans</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#25152;&#26377;&#25968;&#23383;&#37117;&#21333;&#35843;&#36882;&#20943;&#65292;&#37027;&#20040;&#21487;&#20197;&#20808;&#25226;ans&#25152;&#26377;&#20803;&#32032;&#21021;&#22987;&#21270;&#20026;0
</span>        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; temperatures.size(); ++i) {
            ans.push_back(0);
        }
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; temperatures.size(); ++i) {
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26632;&#39030;&#26377;&#20803;&#32032;&#65292;&#23384;&#20648;&#30340;&#26159;&#28201;&#24230;&#19979;&#26631;; &#22914;&#26524;&#28201;&#24230;&#20540;&#23567;&#20110;&#24403;&#21069;&#28201;&#24230;, &#35828;&#26126;&#19979;&#19968;&#20010;&#26356;&#39640;&#30340;&#28201;&#24230;&#23601;&#26159;i
</span>            <span class="org-keyword">while</span>(stk.size() &amp;&amp; temperatures[ stk.back() ] &lt; temperatures[i]) {
                ans[stk.back()] = i - stk.back();
                stk.pop_back();
            }  
            stk.push_back(i); 
        }
        <span class="org-keyword">return</span> ans;    
    }
};

<span class="org-comment-delimiter">/*</span><span class="org-comment">
&#23545;&#20110;&#20219;&#24847;&#19968;&#20010;&#25968;&#65292;&#21521;&#21491;&#25214;&#31532;1&#20010;&#27604;&#23427;&#22823;&#30340;&#25968;&#65292;&#21521;&#21491;&#25214;&#20960;&#20301;
1 2 3 4 5
1 1 1 1 0

9 8 7 6 5
0 0 0 0 0
</span><span class="org-comment-delimiter">*/</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-h:c0833816-2ffd-4d6e-b079-fc468fb48d5f" class="outline-5">
<h5 id="h:c0833816-2ffd-4d6e-b079-fc468fb48d5f"><a href="#h:c0833816-2ffd-4d6e-b079-fc468fb48d5f">8.从链表中移除节点</a></h5>
<div class="outline-text-5" id="text-h:c0833816-2ffd-4d6e-b079-fc468fb48d5f">
<p>
<a href="https://leetcode.cn/problems/remove-nodes-from-linked-list/description/">https://leetcode.cn/problems/remove-nodes-from-linked-list/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#38142;&#34920;&#30340;&#22836;&#33410;&#28857; head &#12290;

&#31227;&#38500;&#27599;&#20010;&#21491;&#20391;&#26377;&#19968;&#20010;&#26356;&#22823;&#25968;&#20540;&#30340;&#33410;&#28857;&#12290;

&#36820;&#22238;&#20462;&#25913;&#21518;&#38142;&#34920;&#30340;&#22836;&#33410;&#28857; head &#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;head = [5,2,13,3,8]
&#36755;&#20986;&#65306;[13,8]
&#35299;&#37322;&#65306;&#38656;&#35201;&#31227;&#38500;&#30340;&#33410;&#28857;&#26159; 5 &#65292;2 &#21644; 3 &#12290;
- &#33410;&#28857; 13 &#22312;&#33410;&#28857; 5 &#21491;&#20391;&#12290;
- &#33410;&#28857; 13 &#22312;&#33410;&#28857; 2 &#21491;&#20391;&#12290;
- &#33410;&#28857; 8 &#22312;&#33410;&#28857; 3 &#21491;&#20391;&#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;head = [1,1,1,1]
&#36755;&#20986;&#65306;[1,1,1,1]
&#35299;&#37322;&#65306;&#27599;&#20010;&#33410;&#28857;&#30340;&#20540;&#37117;&#26159; 1 &#65292;&#25152;&#20197;&#27809;&#26377;&#38656;&#35201;&#31227;&#38500;&#30340;&#33410;&#28857;&#12290;

&#25552;&#31034;&#65306;
&#32473;&#23450;&#21015;&#34920;&#20013;&#30340;&#33410;&#28857;&#25968;&#30446;&#22312;&#33539;&#22260; [1, 105] &#20869;
1 &lt;= Node.val &lt;= 105
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     </span><span class="org-doc"><span class="org-doc-markup">ListNode()</span></span><span class="org-doc"> : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">ListNode</span>* <span class="org-function-name">removeNodes</span>(<span class="org-type">ListNode</span>* <span class="org-variable-name">head</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#36882;&#24402;(&#28145;&#25628;)&#23601;&#26159;&#21644;&#26632;&#32852;&#31995;&#36215;&#26469;&#30340;; &#24191;&#25628;&#21644;&#38431;&#21015;&#32852;&#31995;&#36215;&#26469;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#29992;vector&#25968;&#32452;&#26469;&#27169;&#25311;&#26632;
</span>        <span class="org-type">vector</span>&lt;<span class="org-type">ListNode</span>*&gt; <span class="org-variable-name">stk</span>;
        <span class="org-type">ListNode</span>* <span class="org-variable-name">dummy</span> = <span class="org-keyword">new</span> <span class="org-type">ListNode</span>(100000, head); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#34394;&#25311;&#22836;&#32467;&#28857;
</span>        <span class="org-type">ListNode</span>* <span class="org-variable-name">now</span> = head;                         <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#28216;&#26631;&#32467;&#28857;&#65292;&#20174;head&#24320;&#22987;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#27599;&#27425;&#25226;&#26632;&#39030;&#20803;&#32032;&#21644;&#24403;&#21069;&#36941;&#21382;&#21040;&#30340;&#36825;&#20010;&#38142;&#34920;&#32467;&#28857;&#27604;&#36739;&#65292;&#22914;&#26524;&#23567;&#20110;&#65292;&#25226;&#26632;&#39030;&#20803;&#32032;&#32473;pop&#20986;&#26469;
</span>        stk.push_back(dummy);
        <span class="org-keyword">while</span>(now) {
            <span class="org-keyword">while</span>(stk.back()-&gt;val &lt; now-&gt;val) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21333;&#35843;&#19981;&#22686;&#30340;&#26632;
</span>                stk.pop_back();
            }
            stk.push_back(now);
            now = now-&gt;next;
        }
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; stk.size(); ++i) {
            stk[i]-&gt;next = stk[i+1];
        }
        stk.back()-&gt;next = <span class="org-constant">NULL</span>;
        <span class="org-keyword">return</span> dummy-&gt;next;
    }
};
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-h:72ed696d-cf24-43f4-854c-01000b47a679" class="outline-3">
<h3 id="h:72ed696d-cf24-43f4-854c-01000b47a679"><a href="#h:72ed696d-cf24-43f4-854c-01000b47a679">应用篇</a></h3>
<div class="outline-text-3" id="text-h:72ed696d-cf24-43f4-854c-01000b47a679">
</div>
<div id="outline-container-h:6e28f97d-7c74-46fa-80ca-1b753883be69" class="outline-4">
<h4 id="h:6e28f97d-7c74-46fa-80ca-1b753883be69"><a href="#h:6e28f97d-7c74-46fa-80ca-1b753883be69">原神、剑网3中的应用</a></h4>
<div class="outline-text-4" id="text-h:6e28f97d-7c74-46fa-80ca-1b753883be69">
<p>
后打开的先关闭。栈后进先出。
</p>

<p>
如打开游戏界面是入栈操作，关闭操作认为是出栈操作。
</p>
</div>
</div>
</div>
</section>
<section id="outline-container-h:808736b4-7170-4b7d-b9aa-d51d9e31ea51" class="outline-2">
<h2 id="h:808736b4-7170-4b7d-b9aa-d51d9e31ea51"><a href="#h:808736b4-7170-4b7d-b9aa-d51d9e31ea51">线性结构-队列</a></h2>
<div class="outline-text-2" id="text-h:808736b4-7170-4b7d-b9aa-d51d9e31ea51">
</div>
<div id="outline-container-h:c8b099ea-310f-41aa-807d-1022aa312d52" class="outline-3">
<h3 id="h:c8b099ea-310f-41aa-807d-1022aa312d52"><a href="#h:c8b099ea-310f-41aa-807d-1022aa312d52">队列（概念篇）</a></h3>
<div class="outline-text-3" id="text-h:c8b099ea-310f-41aa-807d-1022aa312d52">
<p>
队列的入队、队列的出队、队列的应用
</p>

<p>
队列有很多
</p>
<ul class="org-ul">
<li>数据结构上的分类，如普通队列（先进先出）、双端队列（单调队列、优先队列）、循环队列（用于循环利用存储空间）；</li>
<li>实现方式上的分类，如顺序队列（基于数组）和链式队列（基于链表）；</li>
<li>线程安全和并发场景下的分类，如阻塞队列（支持线程间同步）和优先队列（元素按优先级出队）；</li>
<li>其他特定类型的分类，如消息队列（用于异步通信）</li>
</ul>

<p>
这里讲的是先进先出队列。
</p>
</div>
<div id="outline-container-h:1662f1cb-3985-418d-a2e4-9bc11b6a7ca0" class="outline-4">
<h4 id="h:1662f1cb-3985-418d-a2e4-9bc11b6a7ca0"><a href="#h:1662f1cb-3985-418d-a2e4-9bc11b6a7ca0">队列的概念</a></h4>
<div class="outline-text-4" id="text-h:1662f1cb-3985-418d-a2e4-9bc11b6a7ca0">
<p>
队列是仅限在表尾进行插入，表头进行删除的线性表，它遵循先进先出(First-In-First-Out，FIFO)的原则。队列就像排队等候的人群一样，最先进入队列的元素将首先被处理或移除。
</p>

<p>
在计算机科学中，队列通常用于实现排队系统、任务调度、消息传递(消息队列可用于进程间通信)。我们一般可以用顺序表或者链表来实现队列。
</p>
</div>
</div>
<div id="outline-container-h:45e02948-24e7-47cc-a5ad-9c41f7bed51c" class="outline-4">
<h4 id="h:45e02948-24e7-47cc-a5ad-9c41f7bed51c"><a href="#h:45e02948-24e7-47cc-a5ad-9c41f7bed51c">入队</a></h4>
<div class="outline-text-4" id="text-h:45e02948-24e7-47cc-a5ad-9c41f7bed51c">
<p>
入队的概念
</p>
<ul class="org-ul">
<li>队列的插入操作叫做入队，它是将数据元素从队尾进行插入的过程。</li>
</ul>

<p>
入队的图解
</p>
<ul class="org-ul">
<li>如图所示，4号元素是原先的队尾，在它后面插入一个元素6，就完成了入队的过程。</li>
</ul>


<figure id="org49c2ccc">
<img src="././images/img-2025102401.gif" alt="img-2025102401.gif" width="50%">

</figure>

<p>
入队的步骤
</p>
<ul class="org-ul">
<li>第1步、将元素添加到队列尾部，更新队尾指针(适用于链表)或者索引(适用于顺序表)。</li>
<li>第2步、队列大小增加1。</li>
</ul>
</div>
</div>
<div id="outline-container-h:416677ce-422f-42d3-a350-f40aebd0606c" class="outline-4">
<h4 id="h:416677ce-422f-42d3-a350-f40aebd0606c"><a href="#h:416677ce-422f-42d3-a350-f40aebd0606c">出队</a></h4>
<div class="outline-text-4" id="text-h:416677ce-422f-42d3-a350-f40aebd0606c">
<p>
出队的概念
</p>
<ul class="org-ul">
<li>队列的删除操作叫做出队，它是将队首元素进行删除的过程。</li>
</ul>

<p>
出队的图解
</p>
<ul class="org-ul">
<li>如图所示，直接删除队首的元素，并且更新为新的队首即可1。</li>
</ul>


<figure id="orge5bb7cd">
<img src="././images/img-2025102402.gif" alt="img-2025102402.gif" width="50%">

</figure>

<p>
出队的步骤
</p>
<ul class="org-ul">
<li>第1步、删除队首元素，更新队首指针(适用于链表)或者索引(适用于顺序表)。</li>
<li>第2步、队列的大小减小1。</li>
</ul>
</div>
</div>
<div id="outline-container-h:5129e1fb-44de-4593-a020-9221455887c3" class="outline-4">
<h4 id="h:5129e1fb-44de-4593-a020-9221455887c3"><a href="#h:5129e1fb-44de-4593-a020-9221455887c3">获取队首元素</a></h4>
<div class="outline-text-4" id="text-h:5129e1fb-44de-4593-a020-9221455887c3">
<p>
获取队首元素的概念
</p>
<ul class="org-ul">
<li>返回队首指针(或者索引)指向的元素的值，无论是链表还是顺顾序表，都可以通过队首指针(或者索引)在O(1)的时间复杂度获取到队首元素。</li>
</ul>

<p>
获取队首元素的图解
</p>
<ul class="org-ul">
<li>如图所示，直接通过队首指针(或者索引)获取队首元素。</li>
</ul>


<figure id="org29bd830">
<img src="././images/img-2025102403.gif" alt="img-2025102403.gif" width="50%">

</figure>

<p>
获取队首元素的步骤
</p>
<ul class="org-ul">
<li>利用队首指针（或者索引）获取队首元素并返回。由于是查询操作，所以不会改变队列本身的数据。</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-h:243ff972-acda-4877-9313-16f7ffdb5447" class="outline-3">
<h3 id="h:243ff972-acda-4877-9313-16f7ffdb5447"><a href="#h:243ff972-acda-4877-9313-16f7ffdb5447">代码篇</a></h3>
<div class="outline-text-3" id="text-h:243ff972-acda-4877-9313-16f7ffdb5447">
</div>
<div id="outline-container-h:39b00ce6-ba17-4fc6-9ec8-8ce4e19450b5" class="outline-4">
<h4 id="h:39b00ce6-ba17-4fc6-9ec8-8ce4e19450b5"><a href="#h:39b00ce6-ba17-4fc6-9ec8-8ce4e19450b5">顺序表实现</a></h4>
<div class="outline-text-4" id="text-h:39b00ce6-ba17-4fc6-9ec8-8ce4e19450b5">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdexcept&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#38431;&#21015;&#30340;&#31867;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#20803;&#32032;&#30340;&#31867;&#22411; T
</span><span class="org-keyword">class</span> <span class="org-type">Queue</span> {
<span class="org-keyword">private</span>:
    <span class="org-type">T</span>* <span class="org-variable-name">data</span>;       <span class="org-comment-delimiter">// </span><span class="org-comment">&#21160;&#24577;&#25968;&#32452;&#12290;&#25152;&#26377;&#20803;&#32032;&#37117;&#23384;&#20648;&#22312;&#36825;&#20010;&#21160;&#24577;&#25968;&#32452;&#20013;
</span>    <span class="org-type">int</span> <span class="org-variable-name">front</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#38431;&#39318;&#32034;&#24341;
</span>    <span class="org-type">int</span> <span class="org-variable-name">rear</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">&#38431;&#23614;&#32034;&#24341;&#65292;&#25351;&#21521;&#38431;&#23614;&#20803;&#32032;&#30340;&#21518;&#19968;&#20010;&#20301;&#32622;
</span>    <span class="org-type">int</span> <span class="org-variable-name">capacity</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23481;&#37327;
</span>    <span class="org-type">void</span> <span class="org-function-name">resize</span>(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#30001;&#20110;&#26159;&#21160;&#24577;&#25968;&#32452;&#65292;&#38656;&#35201;&#25193;&#23481;
</span>
<span class="org-keyword">public</span>:
    <span class="org-function-name">Queue</span>():data(<span class="org-keyword">new</span> <span class="org-type">T</span>[10]), front(0), rear(0), capacity(10) {}
    ~<span class="org-function-name">Queue</span>();
    <span class="org-type">void</span> <span class="org-function-name">enqueue</span>(<span class="org-type">T</span> <span class="org-variable-name">element</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20837;&#38431;
</span>    <span class="org-type">T</span> <span class="org-function-name">dequeue</span>();             <span class="org-comment-delimiter">// </span><span class="org-comment">&#20986;&#38431;
</span>    <span class="org-type">T</span> <span class="org-function-name">getFront</span>() <span class="org-keyword">const</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#38431;&#39318;&#20803;&#32032;
</span>    <span class="org-type">int</span> <span class="org-function-name">getSize</span>() <span class="org-keyword">const</span>;       <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#38431;&#21015;&#30340;&#22823;&#23567;
</span>};

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">resize</span>() {
    <span class="org-type">T</span>* <span class="org-variable-name">newData</span> = <span class="org-keyword">new</span> <span class="org-type">T</span>[capacity * 2];
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; rear; ++i) {
        newData[i] = data[i];
    }
    <span class="org-keyword">delete</span>[] data;            <span class="org-comment-delimiter">// </span><span class="org-comment">&#28165;&#29702;&#20869;&#23384;
</span>    data = newData;           <span class="org-comment-delimiter">// </span><span class="org-comment">&#26032;&#20869;&#23384;&#31354;&#38388;&#39318;&#22320;&#22336;&#36171;&#20540;&#32473;data
</span>    capacity *= 2;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::~<span class="org-function-name">Queue</span>() {
    <span class="org-keyword">delete</span>[] data;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">enqueue</span>(<span class="org-type">T</span> <span class="org-variable-name">element</span>) {
    <span class="org-keyword">if</span> (rear == capacity) {
        resize();
    }
    data[rear++] = element;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">T</span> <span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">dequeue</span>() {
    <span class="org-keyword">if</span> (front == rear) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21363;&#27809;&#26377;&#20803;&#32032;
</span>        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::underflow_error(<span class="org-string">"Queue is empty"</span>);
    }
    <span class="org-keyword">return</span> data[front++]; <span class="org-comment-delimiter">// </span><span class="org-comment">front &#25351;&#38024;&#21521;&#21491;&#31227;&#19968;&#20301;&#23601;&#21487;&#20197;&#20102;
</span>}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">T</span> <span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">getFront</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">if</span> (front == rear) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21363;&#27809;&#26377;&#20803;&#32032;
</span>        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::underflow_error(<span class="org-string">"Queue is empty"</span>);
    }
    <span class="org-keyword">return</span> data[front];
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">int</span> <span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">getSize</span>() <span class="org-keyword">const</span>{
    <span class="org-keyword">return</span> rear - front; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36820;&#22238;&#38431;&#23614;&#25351;&#38024;&#20943;&#38431;&#39318;&#25351;&#38024;
</span>}


<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">Queue</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">q</span>;
    q.enqueue(3);
    q.enqueue(4);
    cout &lt;&lt; q.getFront() &lt;&lt; endl; <span class="org-comment-delimiter">// </span><span class="org-comment">3
</span>    q.enqueue(5);
    cout &lt;&lt; q.getFront() &lt;&lt; endl; <span class="org-comment-delimiter">// </span><span class="org-comment">3
</span>    q.dequeue();
    cout &lt;&lt; q.getFront() &lt;&lt; endl; <span class="org-comment-delimiter">// </span><span class="org-comment">4
</span>    cout &lt;&lt; q.getSize() &lt;&lt; endl;  <span class="org-comment-delimiter">// </span><span class="org-comment">2
</span>
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-h:dbf7eb60-3554-443c-b940-984a7488f210" class="outline-4">
<h4 id="h:dbf7eb60-3554-443c-b940-984a7488f210"><a href="#h:dbf7eb60-3554-443c-b940-984a7488f210">链表实现</a></h4>
<div class="outline-text-4" id="text-h:dbf7eb60-3554-443c-b940-984a7488f210">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdexcept&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#38431;&#21015;&#30340;&#31867;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt; <span class="org-comment-delimiter">// </span><span class="org-comment">&#29992;&#27169;&#26495;&#30340;&#26041;&#24335;&#65292;&#36825;&#26679;&#27599;&#20010;&#20803;&#32032;&#37117;&#26159;&#33258;&#23450;&#20041;&#30340;
</span><span class="org-keyword">class</span> <span class="org-type">Queue</span> {
<span class="org-keyword">private</span>:
    <span class="org-keyword">struct</span> <span class="org-type">Node</span> {
        <span class="org-type">T</span> <span class="org-variable-name">data</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#25968;&#25454;&#22495;
</span>        <span class="org-type">Node</span>* <span class="org-variable-name">next</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25351;&#38024;&#22495;
</span>        <span class="org-function-name">Node</span>(<span class="org-type">T</span> <span class="org-variable-name">d</span>) : data(d), next(<span class="org-constant">NULL</span>) {} <span class="org-comment-delimiter">// </span><span class="org-comment">&#32467;&#28857;&#30340;&#26500;&#36896;
</span>    };
    <span class="org-type">Node</span>* <span class="org-variable-name">front</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#38431;&#39318;&#25351;&#38024;
</span>    <span class="org-type">Node</span>* <span class="org-variable-name">rear</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">&#38431;&#23614;&#25351;&#38024;
</span>    <span class="org-type">int</span> <span class="org-variable-name">size</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#38431;&#21015;&#20013;&#20803;&#32032;&#20010;&#25968;
</span><span class="org-keyword">public</span>:
    <span class="org-function-name">Queue</span>() : front(<span class="org-constant">NULL</span>), rear(<span class="org-constant">NULL</span>), size(0) {}
    ~<span class="org-function-name">Queue</span>();
    <span class="org-type">void</span> <span class="org-function-name">enqueue</span>(<span class="org-type">T</span> <span class="org-variable-name">element</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20837;&#38431;
</span>    <span class="org-type">T</span> <span class="org-function-name">dequeue</span>();             <span class="org-comment-delimiter">// </span><span class="org-comment">&#20986;&#38431;
</span>    <span class="org-type">T</span> <span class="org-function-name">getFront</span>() <span class="org-keyword">const</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#38431;&#39318;&#20803;&#32032;
</span>    <span class="org-type">int</span> <span class="org-function-name">getSize</span>() <span class="org-keyword">const</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#38431;&#21015;&#30340;&#20803;&#32032;&#20010;&#25968;
</span>};

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20195;&#34920;&#27599;&#20010;&#20989;&#25968;&#37117;&#26377;&#36825;&#20010;&#31867;&#22411;
</span><span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::~<span class="org-function-name">Queue</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;&#22836;&#24320;&#22987;&#36941;&#21382;&#25972;&#20010;&#38142;&#34920;&#65292;&#33719;&#21462;&#21040;&#24403;&#21069;&#30340;&#22836;&#65292;&#28982;&#21518;&#25226;&#38142;&#34920;&#22836;&#21024;&#38500;
</span>    <span class="org-keyword">while</span> (front) {
        <span class="org-type">Node</span>* <span class="org-variable-name">temp</span> = front;
        front = front-&gt;next;
        <span class="org-keyword">delete</span> temp;
    }
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">enqueue</span>(<span class="org-type">T</span> <span class="org-variable-name">element</span>) {
    <span class="org-keyword">if</span> (rear == <span class="org-constant">NULL</span>) {
        rear = <span class="org-keyword">new</span> <span class="org-type">Node</span>(element);
        front = rear;
    }
    <span class="org-keyword">else</span> {
        rear-&gt;next = <span class="org-keyword">new</span> <span class="org-type">Node</span>(element);
        rear = rear-&gt;next;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#26032;&#21152;&#36827;&#26469;&#30340;&#32467;&#28857;&#20316;&#20026;&#38431;&#23614;&#25351;&#38024;
</span>    }
    ++size;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">T</span> <span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">dequeue</span>() {
    <span class="org-keyword">if</span> (front == <span class="org-constant">NULL</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#31354;&#38431;&#21015;&#65292;&#25243;&#24322;&#24120;
</span>        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::underflow_error(<span class="org-string">"Queue is empty"</span>);
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#38431;&#39318;&#20803;&#32032;&#65292;&#24182;&#19988;&#25226;&#38431;&#39318;&#25351;&#38024;&#23384;&#20648;&#21040;temp&#20013;,&#21024;&#38500;&#38431;&#39318;&#32467;&#28857;&#65292;&#36820;&#22238;element&#65292;&#21363;&#20986;&#38431;&#23436;&#25104;
</span>    <span class="org-type">T</span> <span class="org-variable-name">element</span> = front-&gt;data; 
    <span class="org-type">Node</span>* <span class="org-variable-name">temp</span> = front;
    front = front-&gt;next;
    <span class="org-keyword">delete</span> temp;
    --size;
    <span class="org-keyword">if</span> (size == 0) {
        rear = <span class="org-constant">NULL</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#38431;&#21015;&#20026;&#31354;&#26102;&#65292;&#25226;rear&#25351;&#38024;&#32622;&#20026;NULL&#12290;&#22914;&#26524;&#19981;&#36825;&#26679;&#65292;rear&#23601;&#21464;&#25104;&#37326;&#25351;&#38024;&#20102;&#65292;&#22312;&#19979;&#27425;&#20837;&#38431;&#26102;&#20250;&#25253;&#38169;
</span>    }
    <span class="org-keyword">return</span> element;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">T</span> <span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">getFront</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">if</span> (front == <span class="org-constant">NULL</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#31354;&#38431;&#21015;&#65292;&#25243;&#24322;&#24120;
</span>        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::underflow_error(<span class="org-string">"Queue is empty"</span>);
    }
    <span class="org-keyword">return</span> front-&gt;data;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">int</span> <span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">getSize</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">return</span> size;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">Queue</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">q</span>;
    q.enqueue(3);
    q.enqueue(4);
    cout &lt;&lt; q.getFront() &lt;&lt; endl;
    q.enqueue(5);
    q.dequeue();
    cout &lt;&lt; q.getFront() &lt;&lt; endl;
    cout &lt;&lt; q.getSize() &lt;&lt; endl;

    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-h:cbd5808c-cb7c-4ef2-9365-7b5eda2ecdfe" class="outline-4">
<h4 id="h:cbd5808c-cb7c-4ef2-9365-7b5eda2ecdfe"><a href="#h:cbd5808c-cb7c-4ef2-9365-7b5eda2ecdfe">C++中的队列实现（queue）</a></h4>
<div class="outline-text-4" id="text-h:cbd5808c-cb7c-4ef2-9365-7b5eda2ecdfe">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;queue&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">queue</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">q</span>;

    q.push(1); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25554;&#20837;&#20803;&#32032;
</span>    q.push(3);
    q.push(2);
    q.push(4);
    
    <span class="org-keyword">while</span> (<span class="org-negation-char">!</span>q.empty()) {           <span class="org-comment-delimiter">// </span><span class="org-comment">&#21028;&#26029;&#38431;&#21015;&#38750;&#31354;
</span>        cout &lt;&lt; q.front() &lt;&lt; endl; <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#38431;&#39318;&#20803;&#32032;
</span>        q.pop();                   <span class="org-comment-delimiter">// </span><span class="org-comment">&#24377;&#20986;&#38431;&#39318;&#20803;&#32032;
</span>    }

    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:7282191f-2e00-4564-8ccf-89e149109dee" class="outline-3">
<h3 id="h:7282191f-2e00-4564-8ccf-89e149109dee"><a href="#h:7282191f-2e00-4564-8ccf-89e149109dee">实战篇</a></h3>
<div class="outline-text-3" id="text-h:7282191f-2e00-4564-8ccf-89e149109dee">
</div>
<div id="outline-container-h:ecc5aebd-1ce8-4e45-be46-62344fddb2a8" class="outline-4">
<h4 id="h:ecc5aebd-1ce8-4e45-be46-62344fddb2a8"><a href="#h:ecc5aebd-1ce8-4e45-be46-62344fddb2a8">ACM模式</a></h4>
<div class="outline-text-4" id="text-h:ecc5aebd-1ce8-4e45-be46-62344fddb2a8">
</div>
<div id="outline-container-h:c39989ed-6a72-4f96-8a9a-83decb79f883" class="outline-5">
<h5 id="h:c39989ed-6a72-4f96-8a9a-83decb79f883"><a href="#h:c39989ed-6a72-4f96-8a9a-83decb79f883">1.士兵队列训练问题</a></h5>
<div class="outline-text-5" id="text-h:c39989ed-6a72-4f96-8a9a-83decb79f883">
<p>
<a href="https://acm.hdu.edu.cn/showproblem.php?pid=1276">https://acm.hdu.edu.cn/showproblem.php?pid=1276</a>
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdexcept&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#38431;&#21015;&#30340;&#31867;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt; <span class="org-comment-delimiter">// </span><span class="org-comment">&#29992;&#27169;&#26495;&#30340;&#26041;&#24335;&#65292;&#36825;&#26679;&#27599;&#20010;&#20803;&#32032;&#37117;&#26159;&#33258;&#23450;&#20041;&#30340;
</span><span class="org-keyword">class</span> <span class="org-type">Queue</span> {
<span class="org-keyword">private</span>:
    <span class="org-keyword">struct</span> <span class="org-type">Node</span> {
        <span class="org-type">T</span> <span class="org-variable-name">data</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#25968;&#25454;&#22495;
</span>        <span class="org-type">Node</span>* <span class="org-variable-name">next</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25351;&#38024;&#22495;
</span>        <span class="org-function-name">Node</span>(<span class="org-type">T</span> <span class="org-variable-name">d</span>) : data(d), next(<span class="org-constant">NULL</span>) {} <span class="org-comment-delimiter">// </span><span class="org-comment">&#32467;&#28857;&#30340;&#26500;&#36896;
</span>    };
    <span class="org-type">Node</span>* <span class="org-variable-name">front</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#38431;&#39318;&#25351;&#38024;
</span>    <span class="org-type">Node</span>* <span class="org-variable-name">rear</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">&#38431;&#23614;&#25351;&#38024;
</span>    <span class="org-type">int</span> <span class="org-variable-name">size</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#38431;&#21015;&#20013;&#20803;&#32032;&#20010;&#25968;
</span><span class="org-keyword">public</span>:
    <span class="org-function-name">Queue</span>() : front(<span class="org-constant">NULL</span>), rear(<span class="org-constant">NULL</span>), size(0) {}
    ~<span class="org-function-name">Queue</span>();
    <span class="org-type">void</span> <span class="org-function-name">enqueue</span>(<span class="org-type">T</span> <span class="org-variable-name">element</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20837;&#38431;
</span>    <span class="org-type">T</span> <span class="org-function-name">dequeue</span>();             <span class="org-comment-delimiter">// </span><span class="org-comment">&#20986;&#38431;
</span>    <span class="org-type">T</span> <span class="org-function-name">getFront</span>() <span class="org-keyword">const</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#38431;&#39318;&#20803;&#32032;
</span>    <span class="org-type">int</span> <span class="org-function-name">getSize</span>() <span class="org-keyword">const</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#38431;&#21015;&#30340;&#20803;&#32032;&#20010;&#25968;
</span>};

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20195;&#34920;&#27599;&#20010;&#20989;&#25968;&#37117;&#26377;&#36825;&#20010;&#31867;&#22411;
</span><span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::~<span class="org-function-name">Queue</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;&#22836;&#24320;&#22987;&#36941;&#21382;&#25972;&#20010;&#38142;&#34920;&#65292;&#33719;&#21462;&#21040;&#24403;&#21069;&#30340;&#22836;&#65292;&#28982;&#21518;&#25226;&#38142;&#34920;&#22836;&#21024;&#38500;
</span>    <span class="org-keyword">while</span> (front) {
        <span class="org-type">Node</span>* <span class="org-variable-name">temp</span> = front;
        front = front-&gt;next;
        <span class="org-keyword">delete</span> temp;
    }
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">enqueue</span>(<span class="org-type">T</span> <span class="org-variable-name">element</span>) {
    <span class="org-keyword">if</span> (rear == <span class="org-constant">NULL</span>) {
        rear = <span class="org-keyword">new</span> <span class="org-type">Node</span>(element);
        front = rear;
    }
    <span class="org-keyword">else</span> {
        rear-&gt;next = <span class="org-keyword">new</span> <span class="org-type">Node</span>(element);
        rear = rear-&gt;next;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#26032;&#21152;&#36827;&#26469;&#30340;&#32467;&#28857;&#20316;&#20026;&#38431;&#23614;&#25351;&#38024;
</span>    }
    ++size;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">T</span> <span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">dequeue</span>() {
    <span class="org-keyword">if</span> (front == <span class="org-constant">NULL</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#31354;&#38431;&#21015;&#65292;&#25243;&#24322;&#24120;
</span>        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::underflow_error(<span class="org-string">"Queue is empty"</span>);
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#38431;&#39318;&#20803;&#32032;&#65292;&#24182;&#19988;&#25226;&#38431;&#39318;&#25351;&#38024;&#23384;&#20648;&#21040;temp&#20013;,&#21024;&#38500;&#38431;&#39318;&#32467;&#28857;&#65292;&#36820;&#22238;element&#65292;&#21363;&#20986;&#38431;&#23436;&#25104;
</span>    <span class="org-type">T</span> <span class="org-variable-name">element</span> = front-&gt;data;
    <span class="org-type">Node</span>* <span class="org-variable-name">temp</span> = front;
    front = front-&gt;next;
    <span class="org-keyword">delete</span> temp;
    --size;
    <span class="org-keyword">if</span> (size == 0) {
        rear = <span class="org-constant">NULL</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#38431;&#21015;&#20026;&#31354;&#26102;&#65292;&#25226;rear&#25351;&#38024;&#32622;&#20026;NULL&#12290;&#22914;&#26524;&#19981;&#36825;&#26679;&#65292;rear&#23601;&#21464;&#25104;&#37326;&#25351;&#38024;&#20102;&#65292;&#22312;&#19979;&#27425;&#20837;&#38431;&#26102;&#20250;&#25253;&#38169;
</span>    }
    <span class="org-keyword">return</span> element;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">T</span> <span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">getFront</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">if</span> (front == <span class="org-constant">NULL</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#31354;&#38431;&#21015;&#65292;&#25243;&#24322;&#24120;
</span>        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::underflow_error(<span class="org-string">"Queue is empty"</span>);
    }
    <span class="org-keyword">return</span> front-&gt;data;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">int</span> <span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">getSize</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">return</span> size;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">t</span>;
    cin &gt;&gt; t;
    <span class="org-keyword">while</span> (t--) {
        <span class="org-type">int</span> <span class="org-variable-name">n</span>;
        cin &gt;&gt; n;
        <span class="org-type">Queue</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">q1</span>, <span class="org-variable-name">q2</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#20803;&#32032;&#25554;&#20837;q1&#20013;
</span>        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 1; i &lt;= n; ++i) {
            q1.enqueue(i);
        }
        <span class="org-keyword">while</span> (q1.getSize() &gt; 3) {
            <span class="org-type">int</span> <span class="org-variable-name">cnt</span> = 0;
            <span class="org-keyword">while</span> (q1.getSize()) {
                <span class="org-type">int</span> <span class="org-variable-name">v</span> = q1.dequeue();
                ++cnt;
                <span class="org-keyword">if</span> (cnt % 2 == 1) {
                    q2.enqueue(v);
                }
            }
            <span class="org-keyword">if</span> (q2.getSize() &lt;= 3) {
                <span class="org-keyword">while</span> (q2.getSize()) q1.enqueue(q2.dequeue());
                <span class="org-keyword">break</span>;
            }
            cnt = 0;
            <span class="org-keyword">while</span> (q2.getSize()) {
                <span class="org-type">int</span> <span class="org-variable-name">v</span> = q2.dequeue();
                ++cnt;
                <span class="org-keyword">if</span> (cnt % 3 == 1 || cnt % 3 == 2) {
                    q1.enqueue(v);
                }
            }
        }
        <span class="org-type">int</span> <span class="org-variable-name">flag</span> = 0;
        <span class="org-keyword">while</span> (q1.getSize()) {
            <span class="org-keyword">if</span> (flag) {
                cout &lt;&lt; <span class="org-string">' '</span>;
            }
            cout &lt;&lt; q1.dequeue();
            flag++;
        }
        cout &lt;&lt; endl;
    }
    
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-h:664df143-bb24-4bd9-851e-80e6ebb0ee52" class="outline-5">
<h5 id="h:664df143-bb24-4bd9-851e-80e6ebb0ee52"><a href="#h:664df143-bb24-4bd9-851e-80e6ebb0ee52">2.Team Queue</a></h5>
<div class="outline-text-5" id="text-h:664df143-bb24-4bd9-851e-80e6ebb0ee52">
<p>
<a href="https://acm.hdu.edu.cn/showproblem.php?pid=1387">https://acm.hdu.edu.cn/showproblem.php?pid=1387</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;string&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;cstring&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdexcept&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#38431;&#21015;&#30340;&#31867;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt; <span class="org-comment-delimiter">// </span><span class="org-comment">&#29992;&#27169;&#26495;&#30340;&#26041;&#24335;&#65292;&#36825;&#26679;&#27599;&#20010;&#20803;&#32032;&#37117;&#26159;&#33258;&#23450;&#20041;&#30340;
</span><span class="org-keyword">class</span> <span class="org-type">Queue</span> {
<span class="org-keyword">private</span>:
    <span class="org-keyword">struct</span> <span class="org-type">Node</span> {
        <span class="org-type">T</span> <span class="org-variable-name">data</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#25968;&#25454;&#22495;
</span>        <span class="org-type">Node</span>* <span class="org-variable-name">next</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25351;&#38024;&#22495;
</span>        <span class="org-function-name">Node</span>(<span class="org-type">T</span> <span class="org-variable-name">d</span>) : data(d), next(<span class="org-constant">NULL</span>) {} <span class="org-comment-delimiter">// </span><span class="org-comment">&#32467;&#28857;&#30340;&#26500;&#36896;
</span>    };
    <span class="org-type">Node</span>* <span class="org-variable-name">front</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#38431;&#39318;&#25351;&#38024;
</span>    <span class="org-type">Node</span>* <span class="org-variable-name">rear</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">&#38431;&#23614;&#25351;&#38024;
</span>    <span class="org-type">int</span> <span class="org-variable-name">size</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#38431;&#21015;&#20013;&#20803;&#32032;&#20010;&#25968;
</span><span class="org-keyword">public</span>:
    <span class="org-function-name">Queue</span>() : front(<span class="org-constant">NULL</span>), rear(<span class="org-constant">NULL</span>), size(0) {}
    ~<span class="org-function-name">Queue</span>();
    <span class="org-type">void</span> <span class="org-function-name">enqueue</span>(<span class="org-type">T</span> <span class="org-variable-name">element</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20837;&#38431;
</span>    <span class="org-type">T</span> <span class="org-function-name">dequeue</span>();             <span class="org-comment-delimiter">// </span><span class="org-comment">&#20986;&#38431;
</span>    <span class="org-type">T</span> <span class="org-function-name">getFront</span>() <span class="org-keyword">const</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#38431;&#39318;&#20803;&#32032;
</span>    <span class="org-type">int</span> <span class="org-function-name">getSize</span>() <span class="org-keyword">const</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#38431;&#21015;&#30340;&#20803;&#32032;&#20010;&#25968;
</span>};

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20195;&#34920;&#27599;&#20010;&#20989;&#25968;&#37117;&#26377;&#36825;&#20010;&#31867;&#22411;
</span><span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::~<span class="org-function-name">Queue</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;&#22836;&#24320;&#22987;&#36941;&#21382;&#25972;&#20010;&#38142;&#34920;&#65292;&#33719;&#21462;&#21040;&#24403;&#21069;&#30340;&#22836;&#65292;&#28982;&#21518;&#25226;&#38142;&#34920;&#22836;&#21024;&#38500;
</span>    <span class="org-keyword">while</span> (front) {
        <span class="org-type">Node</span>* <span class="org-variable-name">temp</span> = front;
        front = front-&gt;next;
        <span class="org-keyword">delete</span> temp;
    }
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">enqueue</span>(<span class="org-type">T</span> <span class="org-variable-name">element</span>) {
    <span class="org-keyword">if</span> (rear == <span class="org-constant">NULL</span>) {
        rear = <span class="org-keyword">new</span> <span class="org-type">Node</span>(element);
        front = rear;
    }
    <span class="org-keyword">else</span> {
        rear-&gt;next = <span class="org-keyword">new</span> <span class="org-type">Node</span>(element);
        rear = rear-&gt;next;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#26032;&#21152;&#36827;&#26469;&#30340;&#32467;&#28857;&#20316;&#20026;&#38431;&#23614;&#25351;&#38024;
</span>    }
    ++size;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">T</span> <span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">dequeue</span>() {
    <span class="org-keyword">if</span> (front == <span class="org-constant">NULL</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#31354;&#38431;&#21015;&#65292;&#25243;&#24322;&#24120;
</span>        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::underflow_error(<span class="org-string">"Queue is empty"</span>);
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#38431;&#39318;&#20803;&#32032;&#65292;&#24182;&#19988;&#25226;&#38431;&#39318;&#25351;&#38024;&#23384;&#20648;&#21040;temp&#20013;,&#21024;&#38500;&#38431;&#39318;&#32467;&#28857;&#65292;&#36820;&#22238;element&#65292;&#21363;&#20986;&#38431;&#23436;&#25104;
</span>    <span class="org-type">T</span> <span class="org-variable-name">element</span> = front-&gt;data;
    <span class="org-type">Node</span>* <span class="org-variable-name">temp</span> = front;
    front = front-&gt;next;
    <span class="org-keyword">delete</span> temp;
    --size;
    <span class="org-keyword">if</span> (size == 0) {
        rear = <span class="org-constant">NULL</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#38431;&#21015;&#20026;&#31354;&#26102;&#65292;&#25226;rear&#25351;&#38024;&#32622;&#20026;NULL&#12290;&#22914;&#26524;&#19981;&#36825;&#26679;&#65292;rear&#23601;&#21464;&#25104;&#37326;&#25351;&#38024;&#20102;&#65292;&#22312;&#19979;&#27425;&#20837;&#38431;&#26102;&#20250;&#25253;&#38169;
</span>    }
    <span class="org-keyword">return</span> element;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">T</span> <span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">getFront</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">if</span> (front == <span class="org-constant">NULL</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#31354;&#38431;&#21015;&#65292;&#25243;&#24322;&#24120;
</span>        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::underflow_error(<span class="org-string">"Queue is empty"</span>);
    }
    <span class="org-keyword">return</span> front-&gt;data;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">int</span> <span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">getSize</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">return</span> size;
}

<span class="org-type">int</span> <span class="org-variable-name">team</span>[1000000]; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23384;&#25918;&#27599;&#20010;&#20154;&#30340;&#38431;&#20237;
</span><span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#26377;&#19968;&#20010;&#38431;&#21015;&#65292;&#22914;&#26524;&#21457;&#29616;&#38431;&#21015;&#37324;&#26377;&#19968;&#20010;&#20154;&#21644;&#25105;&#30340;&#38431;&#20237;&#26159;&#22312;&#21516;&#19968;&#20010;&#38431;&#37324;&#65292;&#25105;&#23601;&#25490;&#22312;&#20182;&#30340;&#21518;&#38754;&#12290;
</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#22312;&#36825;&#20010;&#38431;&#21015;&#20013;&#27809;&#25214;&#21040;&#65292;&#21017;&#25490;&#22312;&#25972;&#20010;&#38431;&#21015;&#30340;&#21518;&#38754;&#12290;
</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">&#31532;&#19968;&#32500;&#20195;&#34920;&#20808;&#25554;&#20837;&#30340;&#20154;&#65307;&#31532;&#20108;&#32500;&#20195;&#34920;&#21516;&#19968;&#20010;&#38431;&#21015;&#37324;&#30340;&#19981;&#21516;&#30340;&#20154;&#24182;&#19988;&#25353;&#20808;&#21518;&#26102;&#38388;&#39034;&#24207;
</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20986;&#38431;&#23601;&#26159;&#31532;&#19968;&#32500;&#30340;&#37027;&#20010;&#38431;&#21015;&#37324;&#30340;&#20803;&#32032;&#20986;&#38431;&#12290;
</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">&#27599;&#20010;&#20154;&#37117;&#26377;&#32534;&#21495;&#65292;0~99999
</span>    <span class="org-type">int</span> <span class="org-variable-name">t</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">t &#20010;&#38431;&#20237;
</span>    <span class="org-type">int</span> <span class="org-variable-name">cases</span> = 0;
    <span class="org-keyword">while</span> (cin &gt;&gt; t &amp;&amp; t) {
        ++cases;
        <span class="org-comment-delimiter">// </span><span class="org-comment">1.&#38431;&#20237;&#25968;&#25454;
</span>        memset(team, 0, <span class="org-keyword">sizeof</span>(team)); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#21270;team
</span>        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 1; i &lt;= t; ++i) {
            <span class="org-type">int</span> <span class="org-variable-name">n</span>;
            cin &gt;&gt; n;
            <span class="org-keyword">while</span> (n--) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#34920;&#31034;&#27599;&#20010;&#38431;&#20237;&#26377;&#22810;&#23569;&#20154;
</span>                <span class="org-type">int</span> <span class="org-variable-name">x</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">x &#34920;&#31034;&#32534;&#21495;
</span>                cin &gt;&gt; x;
                team[x] = i;
            }
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">2.&#20837;&#38431;&#20986;&#38431;&#25805;&#20316;
</span>        <span class="org-type">Queue</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">q</span>[1001];
        <span class="org-type">int</span> <span class="org-variable-name">s</span> = 0, <span class="org-variable-name">e</span> = 0; <span class="org-comment-delimiter">// </span><span class="org-comment">start end
</span>        <span class="org-type">string</span> <span class="org-variable-name">str</span>;
        cout &lt;&lt; <span class="org-string">"Scenario #"</span> &lt;&lt; cases &lt;&lt; endl;
        <span class="org-keyword">while</span> (cin &gt;&gt; str) {
            <span class="org-keyword">if</span> (str == <span class="org-string">"STOP"</span>) <span class="org-keyword">break</span>;
            <span class="org-keyword">if</span> (str == <span class="org-string">"ENQUEUE"</span>) {
                <span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-variable-name">i</span>;
                cin &gt;&gt; x;
                <span class="org-keyword">for</span> (i = s; i &lt; e; ++i) {
                    <span class="org-keyword">if</span> (team[q[i].getFront()] == team[x]) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#35828;&#26126;&#26377;&#20010;&#38431;&#21451;&#22312;&#31532;i&#20010;&#38431;&#20237;&#37324;
</span>                        <span class="org-keyword">break</span>;
                    }
                }
                q[i].enqueue(x);
                <span class="org-keyword">if</span> (i == e) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#34920;&#31034;&#38431;&#21015;&#19981;&#23384;&#22312;
</span>                    ++e;
                }
            }
            <span class="org-keyword">else</span> {
                <span class="org-type">int</span> <span class="org-variable-name">val</span> = q[s].dequeue();
                <span class="org-keyword">if</span> (q[s].getSize() == 0) {
                    ++s;
                }
                cout &lt;&lt; val &lt;&lt; endl;
            }
        }
        cout &lt;&lt; endl;

    }
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:91c59eaf-57d5-45b2-ad8e-704909c43384" class="outline-4">
<h4 id="h:91c59eaf-57d5-45b2-ad8e-704909c43384"><a href="#h:91c59eaf-57d5-45b2-ad8e-704909c43384">核心代码模式</a></h4>
<div class="outline-text-4" id="text-h:91c59eaf-57d5-45b2-ad8e-704909c43384">
</div>
<div id="outline-container-h:04d55be7-9005-4985-b146-4254af185012" class="outline-5">
<h5 id="h:04d55be7-9005-4985-b146-4254af185012"><a href="#h:04d55be7-9005-4985-b146-4254af185012">3.最近的请求次数</a></h5>
<div class="outline-text-5" id="text-h:04d55be7-9005-4985-b146-4254af185012">
<p>
<a href="https://leetcode.cn/problems/number-of-recent-calls/description/">https://leetcode.cn/problems/number-of-recent-calls/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#20889;&#19968;&#20010; RecentCounter &#31867;&#26469;&#35745;&#31639;&#29305;&#23450;&#26102;&#38388;&#33539;&#22260;&#20869;&#26368;&#36817;&#30340;&#35831;&#27714;&#12290;

&#35831;&#20320;&#23454;&#29616; RecentCounter &#31867;&#65306;

RecentCounter() &#21021;&#22987;&#21270;&#35745;&#25968;&#22120;&#65292;&#35831;&#27714;&#25968;&#20026; 0 &#12290;
int ping(int t) &#22312;&#26102;&#38388; t &#28155;&#21152;&#19968;&#20010;&#26032;&#35831;&#27714;&#65292;&#20854;&#20013; t &#34920;&#31034;&#20197;&#27627;&#31186;&#20026;&#21333;&#20301;&#30340;&#26576;&#20010;&#26102;&#38388;&#65292;&#24182;&#36820;&#22238;&#36807;&#21435; 3000 &#27627;&#31186;&#20869;&#21457;&#29983;&#30340;&#25152;&#26377;&#35831;&#27714;&#25968;&#65288;&#21253;&#25324;&#26032;&#35831;&#27714;&#65289;&#12290;&#30830;&#20999;&#22320;&#35828;&#65292;&#36820;&#22238;&#22312; [t-3000, t] &#20869;&#21457;&#29983;&#30340;&#35831;&#27714;&#25968;&#12290;
&#20445;&#35777; &#27599;&#27425;&#23545; ping &#30340;&#35843;&#29992;&#37117;&#20351;&#29992;&#27604;&#20043;&#21069;&#26356;&#22823;&#30340; t &#20540;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;
["RecentCounter", "ping", "ping", "ping", "ping"]
[[], [1], [100], [3001], [3002]]
&#36755;&#20986;&#65306;
[null, 1, 2, 3, 3]

&#35299;&#37322;&#65306;
RecentCounter recentCounter = new RecentCounter();
recentCounter.ping(1);     // requests = [1]&#65292;&#33539;&#22260;&#26159; [-2999,1]&#65292;&#36820;&#22238; 1
recentCounter.ping(100);   // requests = [1, 100]&#65292;&#33539;&#22260;&#26159; [-2900,100]&#65292;&#36820;&#22238; 2
recentCounter.ping(3001);  // requests = [1, 100, 3001]&#65292;&#33539;&#22260;&#26159; [1,3001]&#65292;&#36820;&#22238; 3
recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002]&#65292;&#33539;&#22260;&#26159; [2,3002]&#65292;&#36820;&#22238; 3

&#25552;&#31034;&#65306;
1 &lt;= t &lt;= 109
&#20445;&#35777;&#27599;&#27425;&#23545; ping &#35843;&#29992;&#25152;&#20351;&#29992;&#30340; t &#20540;&#37117; &#20005;&#26684;&#36882;&#22686;
&#33267;&#22810;&#35843;&#29992; ping &#26041;&#27861; 104 &#27425;
</pre>
</div>


<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">RecentCounter</span> {
    <span class="org-type">queue</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">q</span>;
<span class="org-keyword">public</span>:
    <span class="org-function-name">RecentCounter</span>() {
        
    }
    
    <span class="org-type">int</span> <span class="org-function-name">ping</span>(<span class="org-type">int</span> <span class="org-variable-name">t</span>) {
        q.push(t);
        <span class="org-keyword">while</span>(t - q.front() &gt; 3000 ) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#38431;&#23614;&#20803;&#32032;&#20943;&#38431;&#39318;&#20803;&#32032;&#36229;&#36807;3000&#27627;&#31186;&#65292;&#23601;&#28165;&#29702;&#38431;&#39318;&#20803;&#32032;
</span>            q.pop();
        }
        <span class="org-keyword">return</span> q.size();
    }
};

<span class="org-doc">/**
 * Your RecentCounter object will be instantiated and called as such:
 * RecentCounter* obj = new </span><span class="org-doc"><span class="org-doc-markup">RecentCounter()</span></span><span class="org-doc">;
 * int param_1 = obj-&gt;ping(t);
 */</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-h:2266f762-c34b-4512-bf91-639dceef71e3" class="outline-3">
<h3 id="h:2266f762-c34b-4512-bf91-639dceef71e3"><a href="#h:2266f762-c34b-4512-bf91-639dceef71e3">应用篇</a></h3>
<div class="outline-text-3" id="text-h:2266f762-c34b-4512-bf91-639dceef71e3">
</div>
<div id="outline-container-h:023f0454-2f81-4133-bdfd-7c129e523711" class="outline-4">
<h4 id="h:023f0454-2f81-4133-bdfd-7c129e523711"><a href="#h:023f0454-2f81-4133-bdfd-7c129e523711">原神中的应用</a></h4>
<div class="outline-text-4" id="text-h:023f0454-2f81-4133-bdfd-7c129e523711">
<p>
队列是先进先出的线性表。
</p>

<p>
在游戏中，我们在捡起地上的掉落物时，左边会有tips提示，比如按顺序捡起物品，左边就会按捡起顺序进行显示，并且依次消失。于是我们发现：先捡起先消失。
</p>

<p>
每捡起一个物品就把它塞入tips队列中并进行显示，循环检查塞入时间，当前时间减去塞入时间大于2秒就从队列头部将物品删除。
</p>
</div>
</div>
</div>
</section>
<section id="outline-container-h:fbfeb4e5-36e3-42bc-a51b-f183f7372fba" class="outline-2">
<h2 id="h:fbfeb4e5-36e3-42bc-a51b-f183f7372fba"><a href="#h:fbfeb4e5-36e3-42bc-a51b-f183f7372fba">线性结构-栈 &amp;&amp; 队列</a></h2>
<div class="outline-text-2" id="text-h:fbfeb4e5-36e3-42bc-a51b-f183f7372fba">
</div>
<div id="outline-container-h:b308e73c-43b6-4b37-b963-04a749a80e71" class="outline-3">
<h3 id="h:b308e73c-43b6-4b37-b963-04a749a80e71"><a href="#h:b308e73c-43b6-4b37-b963-04a749a80e71">概念篇</a></h3>
<div class="outline-text-3" id="text-h:b308e73c-43b6-4b37-b963-04a749a80e71">
<p>
队列和栈的转换
</p>
</div>
<div id="outline-container-h:8a800187-8295-46ab-940b-b9e060e40252" class="outline-4">
<h4 id="h:8a800187-8295-46ab-940b-b9e060e40252"><a href="#h:8a800187-8295-46ab-940b-b9e060e40252">用栈实现队列</a></h4>
<div class="outline-text-4" id="text-h:8a800187-8295-46ab-940b-b9e060e40252">
<p>
前言
</p>
<ul class="org-ul">
<li>所谓用栈实现队列，就是要求实现一个队列，只不过这个队列的底层容器，不是顺序表，也不是链表，而是栈。要满足这个需求，必须用到两个栈，一个叫入队栈s1，一个叫出队栈s2。</li>
</ul>

<p>
入队操作
</p>
<ul class="org-ul">
<li>将元素压入s1。</li>
</ul>


<figure id="org670b748">
<img src="././images/img-2025102404.gif" alt="img-2025102404.gif" width="50%">

</figure>

<p>
出队操作
</p>
<ul class="org-ul">
<li>首先，判断s2是否为空，如果为空，则将s1中的元素全部弹出并依次压入s2;</li>
<li>然后，弹出s2栈顶元素并返回;</li>
</ul>


<figure id="org70af4dc">
<img src="././images/img-2025102405.gif" alt="img-2025102405.gif" width="50%">

</figure>

<p>
获取队首元素
</p>
<ul class="org-ul">
<li>首先，判断s2是否为空，如果为空，则将s1中的元素全部弹出并依次压入s2(和出队操作一致);</li>
<li>然后，获取s2栈顶元素并返回;</li>
</ul>


<figure id="org6171993">
<img src="././images/img-2025102406.gif" alt="img-2025102406.gif" width="50%">

</figure>

<p>
队列判空
</p>
<ul class="org-ul">
<li>如果s1和s2都为空，则返回true; 否则，返回false。</li>
</ul>
</div>
</div>
<div id="outline-container-h:c5f2b9b6-c24c-4fe5-9cce-5a9f79c41345" class="outline-4">
<h4 id="h:c5f2b9b6-c24c-4fe5-9cce-5a9f79c41345"><a href="#h:c5f2b9b6-c24c-4fe5-9cce-5a9f79c41345">用队列实现栈</a></h4>
<div class="outline-text-4" id="text-h:c5f2b9b6-c24c-4fe5-9cce-5a9f79c41345">
<p>
前言
</p>
<ul class="org-ul">
<li>所谓用队列实现栈，就是要求实现一个栈，只不过这个栈的底层容器，不是顺序表，也不是链表，而是队列。</li>
<li>要满足这个需求，必须用到两个队列，一个叫主队列q1，一个4辅助队列q2。注意，辅助队列每次操作完毕一定会变成空的。</li>
</ul>

<p>
入栈操作
</p>
<ul class="org-ul">
<li>将元素在q1中入队。</li>
</ul>


<figure id="orgc1f369b">
<img src="././images/img-2025102407.gif" alt="img-2025102407.gif" width="50%">

</figure>

<p>
出栈操作
</p>
<ul class="org-ul">
<li>第1步、如果q1没有元素，那么这个操作非法。</li>
<li>第2步、判断q1的元素个数是否大于1，如果大于1，则将q1的元素全部按照顺序在q2入队;</li>
<li>第3步、获取q1的队首元素，保存起来用于最后返回;并且将q1执行出队操作;</li>
<li>第4步、将q2的元素全部按照顺序在q1入队;</li>
<li>第5步、返回第3步中保存起来的q1的队首元素;</li>
</ul>


<figure id="org7843f64">
<img src="././images/img-2025102408.gif" alt="img-2025102408.gif" width="50%">

</figure>

<p>
获取栈顶元素
</p>
<ul class="org-ul">
<li>第1步、如果q1没有元素，那么这个操作非法。</li>
<li>第2步、判断q1的元素个数是否大于1，如果大于1，则将q1的元无素全部按照顺序在q2入队</li>
<li>第3步、获取q1的队首元素，保存起来用于最后返回;并且将q1执行出队操作;并且将这个元素在q2入队;</li>
<li>第4步、将q2的元素全部按照顺序在q1入队;</li>
<li>第5步、返回第3步中保存起来的q1的队首元素;</li>
</ul>


<figure id="org40caa98">
<img src="././images/img-2025102409.gif" alt="img-2025102409.gif" width="50%">

</figure>

<p>
栈判空
</p>
<ul class="org-ul">
<li>由于 q2每次操作完毕必然会变成空的，所以只需判断q1是否会空，如果q1为空，则返回true；否则，返回false。</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-h:3791834e-fbe2-43a4-80b7-ced20d36c224" class="outline-3">
<h3 id="h:3791834e-fbe2-43a4-80b7-ced20d36c224"><a href="#h:3791834e-fbe2-43a4-80b7-ced20d36c224">代码篇</a></h3>
<div class="outline-text-3" id="text-h:3791834e-fbe2-43a4-80b7-ced20d36c224">
</div>
<div id="outline-container-h:d277799a-d38f-43ee-ac64-907d464a43ba" class="outline-4">
<h4 id="h:d277799a-d38f-43ee-ac64-907d464a43ba"><a href="#h:d277799a-d38f-43ee-ac64-907d464a43ba">用栈实现队列</a></h4>
<div class="outline-text-4" id="text-h:d277799a-d38f-43ee-ac64-907d464a43ba">
<p>
<a href="https://leetcode.cn/problems/implement-queue-using-stacks-lcci/">https://leetcode.cn/problems/implement-queue-using-stacks-lcci/</a>
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdexcept&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">&#24076;&#26395;&#26632;&#20013;&#20803;&#32032;&#33021;&#33258;&#24049;&#23450;&#21046;&#21270;&#65292;&#20351;&#29992;&#27169;&#26495;&#26469;&#23454;&#29616;&#36825;&#20010;&#21151;&#33021;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#26632;&#30340;&#31867;
</span><span class="org-keyword">class</span> <span class="org-type">Stack</span> {
<span class="org-keyword">private</span>:
    <span class="org-type">T</span>* <span class="org-variable-name">data</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">T&#31867;&#22411;&#30340;&#25968;&#32452;, &#39034;&#24207;&#34920;&#20803;&#32032;&#30340;&#39318;&#22320;&#22336;
</span>    <span class="org-type">int</span> <span class="org-variable-name">size</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#20803;&#32032;&#20010;&#25968;
</span>    <span class="org-type">int</span> <span class="org-variable-name">capacity</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#38469;&#30340;&#23481;&#37327;
</span>    <span class="org-type">void</span> <span class="org-function-name">resize</span>();<span class="org-comment-delimiter">// </span><span class="org-comment">&#25193;&#23481;&#20989;&#25968;
</span>
<span class="org-keyword">public</span>:
    <span class="org-function-name">Stack</span>() : data(<span class="org-keyword">new</span> <span class="org-type">T</span>[10]), size(0), capacity(10) {}
    ~<span class="org-function-name">Stack</span>();
    <span class="org-type">void</span> <span class="org-function-name">push</span>(<span class="org-type">T</span> <span class="org-variable-name">element</span>);  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20837;&#26632;
</span>    <span class="org-type">T</span> <span class="org-function-name">pop</span>();               <span class="org-comment-delimiter">// </span><span class="org-comment">&#24377;&#20986;&#19968;&#20010;&#20803;&#32032;
</span>    <span class="org-type">T</span> <span class="org-function-name">top</span>() <span class="org-keyword">const</span>;         <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#19968;&#20010;&#20803;&#32032;&#12290;&#19981;&#38656;&#35201;&#20462;&#25913;&#25104;&#21592;&#21464;&#37327;&#30340;
</span>    <span class="org-type">int</span> <span class="org-function-name">getSize</span>() <span class="org-keyword">const</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">&#26632;&#22823;&#23567;
</span>    <span class="org-type">bool</span> <span class="org-function-name">empty</span>() <span class="org-keyword">const</span>;    <span class="org-comment-delimiter">// </span><span class="org-comment">&#21028;&#26029;&#26159;&#21542;&#31354;
</span>};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#26632;&#30340;2&#20493;&#25193;&#23481;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">resize</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">newCapacity</span> = capacity * 2;
    <span class="org-type">T</span>* <span class="org-variable-name">newData</span> = <span class="org-keyword">new</span> <span class="org-type">T</span>[newCapacity];
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; size; ++i) {
        newData[i] = data[i];
    }
    <span class="org-keyword">delete</span>[] data;
    data = newData;
    capacity = newCapacity;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#39034;&#24207;&#34920;&#30340;&#26512;&#26500;&#20989;&#25968;: &#21024;&#38500;&#39034;&#24207;&#34920;&#30340;&#25968;&#25454;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::~<span class="org-function-name">Stack</span>() {
    <span class="org-keyword">delete</span>[] data;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#20837;&#26632;&#23454;&#29616;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">push</span>(<span class="org-type">T</span> <span class="org-variable-name">element</span>) {
    <span class="org-keyword">if</span> (size == capacity) {
        resize();
    }
    data[size++] = element;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#20986;&#26632;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">T</span> <span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">pop</span>() {
    <span class="org-keyword">if</span> (size == 0) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::underflow_error(<span class="org-string">"Stack is empty"</span>);
    }
    <span class="org-keyword">return</span> data[--size];
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#20803;&#32032;: &#26632;&#30340;&#25351;&#38024;&#19981;&#20250;&#21464;&#21270;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">T</span> <span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">top</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">if</span> (size == 0) {
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::underflow_error(<span class="org-string">"Stack is empty"</span>);
    }
    <span class="org-keyword">return</span> data[size - 1];
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#26632;&#22823;&#23567;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">int</span> <span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">getSize</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">return</span> size;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#21028;&#26029;&#26632;&#26159;&#21542;&#20026;&#31354;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">bool</span> <span class="org-constant">Stack</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">empty</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">return</span> size == 0;
}

<span class="org-keyword">class</span> <span class="org-type">MyQueue</span> {
<span class="org-keyword">private</span>:
    <span class="org-type">Stack</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">s1</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20027;&#26632;
</span>    <span class="org-type">Stack</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">s2</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36741;&#21161;&#26632;
</span><span class="org-keyword">public</span>:
    <span class="org-function-name">MyQueue</span>() {}
    <span class="org-type">void</span> <span class="org-function-name">push</span>(<span class="org-type">int</span> <span class="org-variable-name">x</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#20837;&#38431;
</span>        s1.push(x);
    }
    <span class="org-type">int</span> <span class="org-function-name">pop</span>() {        <span class="org-comment-delimiter">// </span><span class="org-comment">&#20986;&#38431;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#36741;&#21161;&#26632;&#20026;&#31354;&#65292;&#23601;&#25226;s1&#24377;&#20986;&#26469;&#65292;&#24182;&#21387;&#20837;&#36741;&#21161;&#26632;&#20013;
</span>        <span class="org-keyword">if</span> (s2.empty()) {
            <span class="org-keyword">while</span> (<span class="org-negation-char">!</span>s1.empty()) {
                s2.push(s1.pop());
            } 
        }
        <span class="org-keyword">return</span> s2.pop();
    }

    <span class="org-type">int</span> <span class="org-function-name">peek</span>() { <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#38431;&#39318;&#20803;&#32032;
</span>        <span class="org-keyword">if</span> (s2.empty()) {
            <span class="org-keyword">while</span> (<span class="org-negation-char">!</span>s1.empty()) {
                s2.push(s1.pop());
            }
        }
        <span class="org-keyword">return</span> s2.top();
    }
    <span class="org-type">bool</span> <span class="org-function-name">empty</span>() { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21028;&#26029;&#38431;&#21015;&#26159;&#21542;&#20026;&#31354;
</span>        <span class="org-keyword">return</span> s1.empty() &amp;&amp; s2.empty();
    }
};

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">MyQueue</span> <span class="org-variable-name">q</span>;

    q.push(1); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25554;&#20837;&#20803;&#32032;
</span>    q.push(3);
    q.push(2);
    q.push(4);

    <span class="org-keyword">while</span> (<span class="org-negation-char">!</span>q.empty()) {           <span class="org-comment-delimiter">// </span><span class="org-comment">&#21028;&#26029;&#38431;&#21015;&#38750;&#31354;
</span>        cout &lt;&lt; q.peek() &lt;&lt; endl; <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#38431;&#39318;&#20803;&#32032;
</span>        q.pop();                   <span class="org-comment-delimiter">// </span><span class="org-comment">&#24377;&#20986;&#38431;&#39318;&#20803;&#32032;
</span>    }
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-h:0f904019-bf02-43ee-9b8a-5aad6f6eeb9d" class="outline-4">
<h4 id="h:0f904019-bf02-43ee-9b8a-5aad6f6eeb9d"><a href="#h:0f904019-bf02-43ee-9b8a-5aad6f6eeb9d">用队列实现栈</a></h4>
<div class="outline-text-4" id="text-h:0f904019-bf02-43ee-9b8a-5aad6f6eeb9d">
<p>
<a href="https://leetcode.cn/problems/implement-stack-using-queues/description/">https://leetcode.cn/problems/implement-stack-using-queues/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdexcept&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#38431;&#21015;&#30340;&#31867;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt; <span class="org-comment-delimiter">// </span><span class="org-comment">&#29992;&#27169;&#26495;&#30340;&#26041;&#24335;&#65292;&#36825;&#26679;&#27599;&#20010;&#20803;&#32032;&#37117;&#26159;&#33258;&#23450;&#20041;&#30340;
</span><span class="org-keyword">class</span> <span class="org-type">Queue</span> {
<span class="org-keyword">private</span>:
    <span class="org-keyword">struct</span> <span class="org-type">Node</span> {
        <span class="org-type">T</span> <span class="org-variable-name">data</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#25968;&#25454;&#22495;
</span>        <span class="org-type">Node</span>* <span class="org-variable-name">next</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25351;&#38024;&#22495;
</span>        <span class="org-function-name">Node</span>(<span class="org-type">T</span> <span class="org-variable-name">d</span>) : data(d), next(<span class="org-constant">NULL</span>) {} <span class="org-comment-delimiter">// </span><span class="org-comment">&#32467;&#28857;&#30340;&#26500;&#36896;
</span>    };
    <span class="org-type">Node</span>* <span class="org-variable-name">front</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#38431;&#39318;&#25351;&#38024;
</span>    <span class="org-type">Node</span>* <span class="org-variable-name">rear</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">&#38431;&#23614;&#25351;&#38024;
</span>    <span class="org-type">int</span> <span class="org-variable-name">size</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#38431;&#21015;&#20013;&#20803;&#32032;&#20010;&#25968;
</span><span class="org-keyword">public</span>:
    <span class="org-function-name">Queue</span>() : front(<span class="org-constant">NULL</span>), rear(<span class="org-constant">NULL</span>), size(0) {}
    ~<span class="org-function-name">Queue</span>();
    <span class="org-type">void</span> <span class="org-function-name">enqueue</span>(<span class="org-type">T</span> <span class="org-variable-name">element</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20837;&#38431;
</span>    <span class="org-type">T</span> <span class="org-function-name">dequeue</span>();             <span class="org-comment-delimiter">// </span><span class="org-comment">&#20986;&#38431;
</span>    <span class="org-type">T</span> <span class="org-function-name">getFront</span>() <span class="org-keyword">const</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#38431;&#39318;&#20803;&#32032;
</span>    <span class="org-type">int</span> <span class="org-function-name">getSize</span>() <span class="org-keyword">const</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#38431;&#21015;&#30340;&#20803;&#32032;&#20010;&#25968;
</span>    <span class="org-type">bool</span> <span class="org-function-name">empty</span>() <span class="org-keyword">const</span>;
};

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20195;&#34920;&#27599;&#20010;&#20989;&#25968;&#37117;&#26377;&#36825;&#20010;&#31867;&#22411;
</span><span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::~<span class="org-function-name">Queue</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;&#22836;&#24320;&#22987;&#36941;&#21382;&#25972;&#20010;&#38142;&#34920;&#65292;&#33719;&#21462;&#21040;&#24403;&#21069;&#30340;&#22836;&#65292;&#28982;&#21518;&#25226;&#38142;&#34920;&#22836;&#21024;&#38500;
</span>    <span class="org-keyword">while</span> (front) {
        <span class="org-type">Node</span>* <span class="org-variable-name">temp</span> = front;
        front = front-&gt;next;
        <span class="org-keyword">delete</span> temp;
    }
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">enqueue</span>(<span class="org-type">T</span> <span class="org-variable-name">element</span>) {
    <span class="org-keyword">if</span> (rear == <span class="org-constant">NULL</span>) {
        rear = <span class="org-keyword">new</span> <span class="org-type">Node</span>(element);
        front = rear;
    }
    <span class="org-keyword">else</span> {
        rear-&gt;next = <span class="org-keyword">new</span> <span class="org-type">Node</span>(element);
        rear = rear-&gt;next;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#26032;&#21152;&#36827;&#26469;&#30340;&#32467;&#28857;&#20316;&#20026;&#38431;&#23614;&#25351;&#38024;
</span>    }
    ++size;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">T</span> <span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">dequeue</span>() {
    <span class="org-keyword">if</span> (front == <span class="org-constant">NULL</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#31354;&#38431;&#21015;&#65292;&#25243;&#24322;&#24120;
</span>        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::underflow_error(<span class="org-string">"Queue is empty"</span>);
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#38431;&#39318;&#20803;&#32032;&#65292;&#24182;&#19988;&#25226;&#38431;&#39318;&#25351;&#38024;&#23384;&#20648;&#21040;temp&#20013;,&#21024;&#38500;&#38431;&#39318;&#32467;&#28857;&#65292;&#36820;&#22238;element&#65292;&#21363;&#20986;&#38431;&#23436;&#25104;
</span>    <span class="org-type">T</span> <span class="org-variable-name">element</span> = front-&gt;data;
    <span class="org-type">Node</span>* <span class="org-variable-name">temp</span> = front;
    front = front-&gt;next;
    <span class="org-keyword">delete</span> temp;
    --size;
    <span class="org-keyword">if</span> (size == 0) {
        rear = <span class="org-constant">NULL</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#38431;&#21015;&#20026;&#31354;&#26102;&#65292;&#25226;rear&#25351;&#38024;&#32622;&#20026;NULL&#12290;&#22914;&#26524;&#19981;&#36825;&#26679;&#65292;rear&#23601;&#21464;&#25104;&#37326;&#25351;&#38024;&#20102;&#65292;&#22312;&#19979;&#27425;&#20837;&#38431;&#26102;&#20250;&#25253;&#38169;
</span>    }
    <span class="org-keyword">return</span> element;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">T</span> <span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">getFront</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">if</span> (front == <span class="org-constant">NULL</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#31354;&#38431;&#21015;&#65292;&#25243;&#24322;&#24120;
</span>        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::underflow_error(<span class="org-string">"Queue is empty"</span>);
    }
    <span class="org-keyword">return</span> front-&gt;data;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">int</span> <span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">getSize</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">return</span> size;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">bool</span> <span class="org-constant">Queue</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">empty</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">return</span> size == 0;
}


<span class="org-keyword">class</span> <span class="org-type">MyStack</span> {
<span class="org-keyword">private</span>:
    <span class="org-type">Queue</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">q1</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20027;&#38431;&#21015;
</span>    <span class="org-type">Queue</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">q2</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36741;&#21161;&#38431;&#21015;
</span>
<span class="org-keyword">public</span>:
    <span class="org-function-name">MyStack</span>() {}

    <span class="org-type">void</span> <span class="org-function-name">push</span>(<span class="org-type">int</span> <span class="org-variable-name">x</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#20837;&#26632;&#65292;&#25226;&#20803;&#32032;&#22622;&#20837;q1&#30340;&#20027;&#38431;&#21015;&#20013;
</span>        q1.enqueue(x);
    }
    <span class="org-type">int</span> <span class="org-function-name">pop</span>() {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#25214;&#20986;&#25152;&#26377;q1&#20013;&#30340;&#20803;&#32032;&#25214;&#20986;&#65292;&#24182;&#22622;&#20837; q2&#20013;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#36820;&#22238;&#20803;&#32032;&#21518;&#65292;&#25226;q2&#30340;&#20803;&#32032;&#22622;&#22238;q1&#20013;
</span>        <span class="org-keyword">while</span> (q1.getSize() &gt; 1) {
            q2.enqueue(q1.dequeue());
        }
        <span class="org-type">int</span> <span class="org-variable-name">result</span> = q1.dequeue();
        <span class="org-keyword">while</span> ( <span class="org-negation-char">!</span>q2.empty()) {
            q1.enqueue(q2.dequeue());
        }
        <span class="org-keyword">return</span> result;
    }
    <span class="org-type">int</span> <span class="org-function-name">top</span>() {
        <span class="org-keyword">while</span> (q1.getSize() &gt; 1) {
            q2.enqueue(q1.dequeue());
        }
        <span class="org-type">int</span> <span class="org-variable-name">result</span> = q1.dequeue();
        q2.enqueue(result);
        <span class="org-keyword">while</span> (<span class="org-negation-char">!</span>q2.empty()) {
            q1.enqueue(q2.dequeue());
        }
        <span class="org-keyword">return</span> result;
    }
    <span class="org-type">bool</span> <span class="org-function-name">empty</span>() {
        <span class="org-keyword">return</span> q1.empty();
    }
};

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">MyStack</span> <span class="org-variable-name">intStk</span>;
    intStk.push(1);
    intStk.push(2);
    intStk.push(3);
    intStk.push(4);
    <span class="org-keyword">while</span> (<span class="org-negation-char">!</span>intStk.empty()) {
        cout &lt;&lt; intStk.top() &lt;&lt; <span class="org-string">" "</span>;
        intStk.pop();
    }
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
</section>
<section id="outline-container-h:601ecd66-8031-4834-bebd-57d1d757dcc9" class="outline-2">
<h2 id="h:601ecd66-8031-4834-bebd-57d1d757dcc9"><a href="#h:601ecd66-8031-4834-bebd-57d1d757dcc9">线性结构-串</a></h2>
<div class="outline-text-2" id="text-h:601ecd66-8031-4834-bebd-57d1d757dcc9">
</div>
<div id="outline-container-h:2c0c5d9b-960c-480e-b963-7b702968feb9" class="outline-3">
<h3 id="h:2c0c5d9b-960c-480e-b963-7b702968feb9"><a href="#h:2c0c5d9b-960c-480e-b963-7b702968feb9">串（概念篇）</a></h3>
<div class="outline-text-3" id="text-h:2c0c5d9b-960c-480e-b963-7b702968feb9">
<p>
串的拷贝、串的连接、串的应用
</p>
</div>
<div id="outline-container-h:a7913ee7-9581-4faf-8d80-6612051e9c69" class="outline-4">
<h4 id="h:a7913ee7-9581-4faf-8d80-6612051e9c69"><a href="#h:a7913ee7-9581-4faf-8d80-6612051e9c69">串的概念</a></h4>
<div class="outline-text-4" id="text-h:a7913ee7-9581-4faf-8d80-6612051e9c69">
<p>
串，又叫字符串，是由一系列字符组成的数据结构，用于表示文本或字符序列。在编程中，字符串通常用双引号括起来，如"Hello,World!"(当然，不同语言之间会有细微差别，比如有些语言使用单引号的)。
</p>


<figure id="org503bcf8">
<img src="././images/img-2025102410.png" alt="img-2025102410.png" width="50%">

</figure>

<p>
而实际在内存中存储的时候，字符串最后还会有一个'\0'的字符('\0'的ASCII的值为0)，它代表了这个串的结尾。
</p>
</div>
</div>
<div id="outline-container-h:b2e247d1-4372-4347-bdaa-0c88c85c328a" class="outline-4">
<h4 id="h:b2e247d1-4372-4347-bdaa-0c88c85c328a"><a href="#h:b2e247d1-4372-4347-bdaa-0c88c85c328a">获取串的长度</a></h4>
<div class="outline-text-4" id="text-h:b2e247d1-4372-4347-bdaa-0c88c85c328a">
<p>
字符串的长度是指字符串中包含的字符个数。一个每个语言都有内置方法来获取字符串的长度(注意:字符串长度是不包含最后一个'\0'的)。
</p>
</div>
</div>
<div id="outline-container-h:42eb1f95-218d-45ad-8b5c-6361f8967794" class="outline-4">
<h4 id="h:42eb1f95-218d-45ad-8b5c-6361f8967794"><a href="#h:42eb1f95-218d-45ad-8b5c-6361f8967794">串的拷贝</a></h4>
<div class="outline-text-4" id="text-h:42eb1f95-218d-45ad-8b5c-6361f8967794">
<p>
有时需要创建一个字符串的副本，而不修改原始字符串。一般可通通过遍历串的方式实现串的拷贝。
</p>


<figure id="org465864b">
<img src="././images/img-2025102411.gif" alt="img-2025102411.gif" width="50%">

</figure>
</div>
</div>
<div id="outline-container-h:f7f13194-b503-4ce1-9a81-134394479927" class="outline-4">
<h4 id="h:f7f13194-b503-4ce1-9a81-134394479927"><a href="#h:f7f13194-b503-4ce1-9a81-134394479927">串的比较</a></h4>
<div class="outline-text-4" id="text-h:f7f13194-b503-4ce1-9a81-134394479927">
<p>
串的比较是指比较两个串是否相等，一般可以采用遍历的方式逐个比较，当然一些语言提供了内置比较函数。
</p>
</div>
</div>
<div id="outline-container-h:11f41fb1-dbbe-4ee9-9021-669a6a07fb37" class="outline-4">
<h4 id="h:11f41fb1-dbbe-4ee9-9021-669a6a07fb37"><a href="#h:11f41fb1-dbbe-4ee9-9021-669a6a07fb37">串的拼接</a></h4>
<div class="outline-text-4" id="text-h:11f41fb1-dbbe-4ee9-9021-669a6a07fb37">
<p>
将两个串拼接在一起，一般是申请一块新的内存，新的内存的大小是两个需要拼接的字符串的长度之和加一，然后第一个串的字符挨个赋值到新的内存，再将第二个串的字符挨个赋值到新的内存，最后加上一个'\0'，就实现完毕了。
</p>
<div class="org-src-container">
<pre class="src src-text">&#20018;1 H e l l o , '\0'
&#20018;2 W o r l d ! '\0'
&#25340;&#25509;&#21518;&#30340;&#20018; H e l l o , W o r l d ! '\0'
</pre>
</div>
</div>
</div>
<div id="outline-container-h:41af551f-efc9-484a-b2c3-60ba118a12bd" class="outline-4">
<h4 id="h:41af551f-efc9-484a-b2c3-60ba118a12bd"><a href="#h:41af551f-efc9-484a-b2c3-60ba118a12bd">串的索引</a></h4>
<div class="outline-text-4" id="text-h:41af551f-efc9-484a-b2c3-60ba118a12bd">
<p>
可以使用索引来访问字符串中的特定字符。索引从0开始，表表示第一个字符的位置，依次递增。可以使用方括号[]并传入索引值来获取字符。
</p>

<div class="org-src-container">
<pre class="src src-text">0 1 2 3 4 5 6 7 8 9 10 11
H e l l o , W o r l d  ! '\0'
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:66b7bfed-9eeb-46be-ae2b-eb5d80e7a39e" class="outline-3">
<h3 id="h:66b7bfed-9eeb-46be-ae2b-eb5d80e7a39e"><a href="#h:66b7bfed-9eeb-46be-ae2b-eb5d80e7a39e">代码篇</a></h3>
<div class="outline-text-3" id="text-h:66b7bfed-9eeb-46be-ae2b-eb5d80e7a39e">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#define</span> <span class="org-variable-name">_CRT_SECURE_NO_WARNINGS</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;cstring&gt;</span> <span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#38469;&#19978;&#26159;C&#35821;&#35328;&#20013;&#30340;string.h&#65292;&#20250;&#29992;&#21040;&#23383;&#31526;&#20018;&#30456;&#20851;&#30340;&#20869;&#32622;&#20989;&#25968;
</span><span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;


<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#19968;&#20010;string&#30340;&#31867;
</span><span class="org-keyword">class</span> <span class="org-type">String</span> {
<span class="org-keyword">private</span>:
    <span class="org-type">char</span>* <span class="org-variable-name">str</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#34920;&#31034;&#21160;&#24577;&#20998;&#37197;&#30340;&#23383;&#31526;&#20018;&#30340;&#20869;&#23384;&#31354;&#38388;
</span>    <span class="org-type">size_t</span> <span class="org-variable-name">length</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#38271;&#24230;. size_t&#34920;&#31034;&#38271;&#24230;&#31867;&#22411;&#30340;&#31867;&#22411;
</span>
<span class="org-keyword">public</span>:
    <span class="org-function-name">String</span>();                             <span class="org-comment-delimiter">// </span><span class="org-comment">&#26500;&#36896;&#20989;&#25968;&#65292;&#21021;&#22987;&#21270;&#23383;&#31526;&#20018;&#20026;&#31354;
</span>    <span class="org-function-name">String</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">s</span>);                <span class="org-comment-delimiter">// </span><span class="org-comment">&#26500;&#36896;&#20989;&#25968;&#65292;&#20256;&#21442;&#26159;&#19968;&#20010;&#23383;&#31526;&#20018;&#24120;&#37327;
</span>    <span class="org-function-name">String</span>(<span class="org-keyword">const</span> <span class="org-type">String</span>&amp; <span class="org-variable-name">s</span>);              <span class="org-comment-delimiter">// </span><span class="org-comment">&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;
</span>    ~<span class="org-function-name">String</span>();
    <span class="org-type">size_t</span> <span class="org-function-name">getLength</span>() <span class="org-keyword">const</span>;             <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#23383;&#31526;&#20018;&#38271;&#24230;
</span>    <span class="org-type">char</span> <span class="org-keyword">operator</span><span class="org-function-name">[]</span> (<span class="org-type">size_t</span> <span class="org-variable-name">index</span>) <span class="org-keyword">const</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23383;&#31526;&#20018;&#30340;&#32034;&#24341;. &#29992;operator&#20570;&#36816;&#31639;&#31526;&#30340;&#37325;&#36733;[]
</span>    <span class="org-type">String</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span>(<span class="org-keyword">const</span> <span class="org-type">String</span>&amp; <span class="org-variable-name">s</span>);   <span class="org-comment-delimiter">// </span><span class="org-comment">&#36171;&#20540;&#36816;&#31639;&#31526;&#12290;&#29992;operator&#20570;&#36171;&#20540;&#36816;&#31639;&#31526;&#37325;&#36733;=
</span>    <span class="org-type">bool</span> <span class="org-keyword">operator</span><span class="org-function-name">==</span>(<span class="org-keyword">const</span> <span class="org-type">String</span>&amp; <span class="org-variable-name">s</span>) <span class="org-keyword">const</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#31561;&#20110;&#36816;&#31639;&#31526;
</span>    <span class="org-type">bool</span> <span class="org-keyword">operator</span><span class="org-function-name">!=</span>(<span class="org-keyword">const</span> <span class="org-type">String</span>&amp; <span class="org-variable-name">s</span>) <span class="org-keyword">const</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#19981;&#31561;&#20110;&#36816;&#31639;&#31526;
</span>    <span class="org-type">String</span> <span class="org-function-name">copy</span>() <span class="org-keyword">const</span>;                  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23383;&#31526;&#20018;&#30340;&#25335;&#36125;
</span>    <span class="org-type">String</span> <span class="org-keyword">operator</span><span class="org-function-name">+</span>(<span class="org-keyword">const</span> <span class="org-type">String</span>&amp; <span class="org-variable-name">s</span>) <span class="org-keyword">const</span>;    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25340;&#25509;&#23383;&#31526;&#20018;&#12290;&#37325;&#36733;+&#21152;&#21495;
</span>    <span class="org-keyword">friend</span> <span class="org-type">ostream</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">&lt;&lt;</span>(<span class="org-type">ostream</span>&amp; <span class="org-variable-name">out</span>, <span class="org-keyword">const</span> <span class="org-type">String</span>&amp; <span class="org-variable-name">s</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21451;&#20803;&#20989;&#25968;
</span>};

<span class="org-constant">String</span>::<span class="org-function-name">String</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#26500;&#36896;&#31354;&#23383;&#31526;&#20018;
</span>    length = 0;
    str = <span class="org-keyword">new</span> <span class="org-type">char</span>[1];
    str[0] = <span class="org-string">'\0'</span>;
}

<span class="org-constant">String</span>::<span class="org-function-name">String</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">s</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#19981;&#24076;&#26395;&#20256;&#36827;&#26469;&#30340;s&#26377;&#25913;&#21464;&#65292;&#25152;&#20197;&#21152;&#20102;const
</span>    length = strlen(s); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20351;&#29992;C&#35821;&#35328;&#30340;&#20869;&#32622;&#25509;&#21475;
</span>    str = <span class="org-keyword">new</span> <span class="org-type">char</span>[length + 1];
    strcpy(str, s);  <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;s&#20869;&#23481;&#20840;&#37096;&#25335;&#36125;&#21040;str&#20013;&#65292;&#30456;&#24403;&#20110;&#25226;&#23614;&#37096;&#30340;\0&#20063;&#25335;&#36125;&#36827;&#26469;
</span>}

<span class="org-constant">String</span>::<span class="org-function-name">String</span>(<span class="org-keyword">const</span> <span class="org-type">String</span>&amp; <span class="org-variable-name">s</span>) {
    length = s.length;
    str = <span class="org-keyword">new</span> <span class="org-type">char</span>[length + 1];
    strcpy(str, s.str);
}

<span class="org-constant">String</span>::~<span class="org-function-name">String</span>() {
    <span class="org-keyword">delete</span>[] str;
}

<span class="org-type">size_t</span> <span class="org-constant">String</span>::<span class="org-function-name">getLength</span>() <span class="org-keyword">const</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">const&#34920;&#31034;&#65292;&#22312;&#20989;&#25968;&#20013;&#19981;&#25913;&#21464;&#31867;&#30340;&#25104;&#21592;&#21464;&#37327;
</span>    <span class="org-keyword">return</span> length;
}

<span class="org-type">char</span> <span class="org-constant">String</span>::<span class="org-keyword">operator</span>[] (<span class="org-type">size_t</span> <span class="org-variable-name">index</span>) <span class="org-keyword">const</span> {
    <span class="org-keyword">return</span> str[index];
}

<span class="org-type">String</span>&amp; <span class="org-constant">String</span>::<span class="org-keyword">operator</span>=(<span class="org-keyword">const</span> <span class="org-type">String</span>&amp; <span class="org-variable-name">s</span>) {
    <span class="org-keyword">if</span> (<span class="org-keyword">this</span> != &amp;s) {
        <span class="org-keyword">delete</span>[] str;
        length = s.length;
        str = <span class="org-keyword">new</span> <span class="org-type">char</span>[length + 1];
        strcpy(str, s.str); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23383;&#31526;&#25335;&#36125;&#36827;&#26469;
</span>    }
    <span class="org-keyword">return</span> *<span class="org-keyword">this</span>;<span class="org-comment-delimiter">// </span><span class="org-comment">&#21491;&#20540;&#31561;&#20110;&#24038;&#20540;&#26102;&#65292;&#30452;&#25509;&#36820;&#22238;&#12290;&#21363;a=a;
</span>}

<span class="org-type">bool</span> <span class="org-constant">String</span>::<span class="org-keyword">operator</span>==(<span class="org-keyword">const</span> <span class="org-type">String</span>&amp; <span class="org-variable-name">s</span>) <span class="org-keyword">const</span> {
    <span class="org-keyword">return</span> strcmp(str, s.str) == 0;
}

<span class="org-type">bool</span> <span class="org-constant">String</span>::<span class="org-keyword">operator</span>!=(<span class="org-keyword">const</span> <span class="org-type">String</span>&amp; <span class="org-variable-name">s</span>) <span class="org-keyword">const</span> {
    <span class="org-keyword">return</span> strcmp(str, s.str);
}

<span class="org-type">String</span> <span class="org-constant">String</span>::<span class="org-function-name">copy</span>() <span class="org-keyword">const</span> {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#23383;&#31526;&#20018;&#30340;&#25335;&#36125;&#21644;&#36171;&#20540;&#26159;&#19968;&#20010;&#27010;&#24565;&#65292;&#30452;&#25509;&#35843;&#29992;&#23383;&#31526;&#20018;&#30340;&#36171;&#20540;&#23601;&#21487;&#20197;&#20102;
</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20808;&#25226;&#26412;&#36523;&#30340;&#23383;&#31526;&#20018;&#23545;&#35937;&#35299;&#24341;&#29992;&#20986;&#26469;&#33719;&#21462;&#21040;&#19968;&#20010;&#23545;&#35937;&#65292;&#20877;&#36171;&#20540;&#32473;s
</span>    <span class="org-type">String</span> <span class="org-variable-name">s</span> = *<span class="org-keyword">this</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#30456;&#24403;&#20110;String s(*this); &#35201;&#35843;&#29992;&#25335;&#36125;&#26500;&#24314;&#20989;&#25968;
</span>    <span class="org-comment-delimiter">//</span><span class="org-comment">printf("%p %p\n", s.str, this-&gt;str);
</span>    <span class="org-keyword">return</span> s;
}

<span class="org-type">String</span> <span class="org-constant">String</span>::<span class="org-keyword">operator</span>+(<span class="org-keyword">const</span> <span class="org-type">String</span>&amp; <span class="org-variable-name">s</span>) <span class="org-keyword">const</span> {
    <span class="org-type">String</span> <span class="org-variable-name">result</span>;
    result.length = length + s.length;
    result.str = <span class="org-keyword">new</span> <span class="org-type">char</span>[result.length + 1];
    strcpy(result.str, str); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;&#31532;&#19968;&#20010;&#23383;&#31526;&#20018;&#21363;string&#30340;&#20869;&#23384;&#25335;&#36125;&#21040;,result&#30340;str&#39318;&#22320;&#22336;&#20013;
</span>    strcat(result.str, s.str); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;s.str&#25335;&#36125;&#21040;string&#30340;&#32467;&#23614;
</span>    <span class="org-keyword">return</span> result;
}

<span class="org-type">ostream</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">&lt;&lt;</span>(<span class="org-type">ostream</span>&amp; <span class="org-variable-name">out</span>, <span class="org-keyword">const</span> <span class="org-type">String</span>&amp; <span class="org-variable-name">s</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36816;&#31639;&#31526;&#37325;&#36733;&#12290;&#29992;&#20110;&#23558;string&#31867;&#22411;&#30340;&#23545;&#35937;&#36755;&#20986;&#21040;ostream&#30340;&#36755;&#20986;&#27969;&#20013;&#65292;
</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22312;&#20989;&#25968;&#20307;&#20869;&#37096;&#65292;&#36890;&#36807;&#35843;&#29992;&#36755;&#20986;&#27969;&#23545;&#35937; out&#30340;&lt;&lt;&#25805;&#20316;&#31526; ,&#23558;s.str&#36755;&#20986;&#21040;&#36755;&#20986;&#27969;&#20013;
</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20989;&#25968;&#36820;&#22238;out&#30340;&#24341;&#29992;&#65292;&#36825;&#26679;&#23601;&#33021;&#23454;&#29616;&#36830;&#32493;&#36755;&#20986;&#30340;&#25928;&#26524;&#20102;
</span>    out &lt;&lt; s.str;
    <span class="org-keyword">return</span> out;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">String</span> <span class="org-variable-name">s</span>(<span class="org-string">"12345d"</span>);
    cout &lt;&lt; s &lt;&lt; endl;               <span class="org-comment-delimiter">// </span><span class="org-comment">12345d
</span>    cout &lt;&lt; s + <span class="org-string">"445"</span> &lt;&lt; endl;       <span class="org-comment-delimiter">// </span><span class="org-comment">12345d445
</span>    cout &lt;&lt; s[5] &lt;&lt; endl;            <span class="org-comment-delimiter">// </span><span class="org-comment">d
</span>    cout &lt;&lt; (s == <span class="org-string">"12345d"</span>) &lt;&lt; endl; <span class="org-comment-delimiter">// </span><span class="org-comment">1
</span>    cout &lt;&lt; (s != <span class="org-string">"12345d"</span>) &lt;&lt; endl; <span class="org-comment-delimiter">// </span><span class="org-comment">0
</span>    s = s + <span class="org-string">"asd"</span>;
    cout &lt;&lt; s &lt;&lt; endl;               <span class="org-comment-delimiter">// </span><span class="org-comment">12345dasd
</span>    <span class="org-type">String</span> <span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>, <span class="org-variable-name">c</span>;
    a = b = c = s;                   <span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#24335;&#36171;&#20540;
</span>    cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; s &lt;&lt; endl; <span class="org-comment-delimiter">// </span><span class="org-comment">12345dasd12345dasd12345dasd12345dasd
</span>    <span class="org-type">String</span> <span class="org-variable-name">x</span> = s.copy();
    cout &lt;&lt; x &lt;&lt; endl;               <span class="org-comment-delimiter">// </span><span class="org-comment">12345dasd
</span>
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-h:e3b6689f-c5a9-4510-a8d7-8120e5f063da" class="outline-3">
<h3 id="h:e3b6689f-c5a9-4510-a8d7-8120e5f063da"><a href="#h:e3b6689f-c5a9-4510-a8d7-8120e5f063da">实战篇</a></h3>
<div class="outline-text-3" id="text-h:e3b6689f-c5a9-4510-a8d7-8120e5f063da">
</div>
<div id="outline-container-h:234a1694-d4e1-4c0e-ac7f-5c11f86867e7" class="outline-4">
<h4 id="h:234a1694-d4e1-4c0e-ac7f-5c11f86867e7"><a href="#h:234a1694-d4e1-4c0e-ac7f-5c11f86867e7">ACM模式</a></h4>
<div class="outline-text-4" id="text-h:234a1694-d4e1-4c0e-ac7f-5c11f86867e7">
</div>
<div id="outline-container-h:1ce7d29d-c2de-4250-86b6-ab005df52485" class="outline-5">
<h5 id="h:1ce7d29d-c2de-4250-86b6-ab005df52485"><a href="#h:1ce7d29d-c2de-4250-86b6-ab005df52485">1.汉字统计</a></h5>
<div class="outline-text-5" id="text-h:1ce7d29d-c2de-4250-86b6-ab005df52485">
<p>
<a href="https://acm.hdu.edu.cn/showproblem.php?pid=2030">https://acm.hdu.edu.cn/showproblem.php?pid=2030</a>
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">char</span> <span class="org-variable-name">s</span>[500];
    <span class="org-type">int</span> <span class="org-variable-name">n</span>;
    cin &gt;&gt; n;
    getchar(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;&#22238;&#36710;&#32473;&#21507;&#25481;
</span>    <span class="org-keyword">while</span> (n--) {
        fgets(s, 500, stdin);
        <span class="org-type">int</span> <span class="org-variable-name">cnt</span> = 0;
        <span class="org-type">int</span> <span class="org-variable-name">len</span> = strlen(s);
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; len; ++i) {
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;&#27721;&#23383;&#65292;&#34917;&#30721;&#26368;&#39640;&#20301;&#26159;1
</span>            <span class="org-keyword">if</span> (s[i] &lt; 0) {
                ++cnt;
            }
        }
        cout &lt;&lt; cnt / 2 &lt;&lt; endl;
    }
    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
<p>
这段代码的目的是计算字符串中汉字的个数。在计算机中，汉字通常用多个字节表示（在GBK编码中为两个字节，在UTF-8编码中为三个字节）。这段代码假设使用GBK编码，因为GBK编码中汉字用两个字节表示，且每个字节的最高位为1（即字节值小于0）。
</p>

<p>
但是，需要注意的是，在C++中，char默认是有符号的，所以当读取到的字节值大于127时，会被解释为负数。因此，代码中通过检查s[i] &lt; 0来判断是否可能是汉字的一部分。
</p>
</div>
</div>
<div id="outline-container-h:6ec1405a-8d86-48e4-a578-6bbee20bde53" class="outline-5">
<h5 id="h:6ec1405a-8d86-48e4-a578-6bbee20bde53"><a href="#h:6ec1405a-8d86-48e4-a578-6bbee20bde53">2.首字母变大写</a></h5>
<div class="outline-text-5" id="text-h:6ec1405a-8d86-48e4-a578-6bbee20bde53">
<p>
<a href="https://acm.hdu.edu.cn/showproblem.php?pid=2026">https://acm.hdu.edu.cn/showproblem.php?pid=2026</a>
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;cstring&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#21028;&#26029;&#24403;&#21069;&#20301;&#32622;&#19981;&#26159;&#31354;&#26684;&#24182;&#19988;&#21069;&#19968;&#20010;&#20301;&#32622;&#26159;&#31354;&#26684;&#65292;&#25110;&#32773;&#21069;&#19968;&#20010;&#20301;&#32622;&#26159;-1&#65292;&#23601;&#25226;&#24403;&#21069;&#23383;&#27597;&#21464;&#22823;&#20889;
</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">AScii&#30721;&#30340;&#36716;&#25442;
</span>    <span class="org-type">char</span> <span class="org-variable-name">s</span>[110];
    <span class="org-keyword">while</span> (fgets(s, 110, stdin)) {
        <span class="org-type">int</span> <span class="org-variable-name">len</span> = strlen(s);
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; len; ++i) {
            <span class="org-keyword">if</span> (i == 0 || s[i - 1] == <span class="org-string">' '</span>) {
                <span class="org-keyword">if</span> (s[i] != <span class="org-string">' '</span>) {
                    <span class="org-keyword">if</span> (s[i] &gt;= <span class="org-string">'a'</span> &amp;&amp; s[i] &lt;= <span class="org-string">'z'</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#26159;&#21542;&#26159;&#23567;&#20889;&#23383;&#27597;&#65292;&#26159;&#21017;&#23567;&#20889;&#36716;&#22823;&#20889;
</span>                        s[i] -= <span class="org-string">'a'</span>;
                        s[i] += <span class="org-string">'A'</span>;
                    }
                }
            }
        }
        printf(<span class="org-string">"%s\n"</span>, s);
    }

    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-h:e1dfccfb-7f9b-40cf-92c4-521ab1878d04" class="outline-5">
<h5 id="h:e1dfccfb-7f9b-40cf-92c4-521ab1878d04"><a href="#h:e1dfccfb-7f9b-40cf-92c4-521ab1878d04">3.查找最大元素</a></h5>
<div class="outline-text-5" id="text-h:e1dfccfb-7f9b-40cf-92c4-521ab1878d04">
<p>
<a href="https://acm.hdu.edu.cn/showproblem.php?pid=2025">https://acm.hdu.edu.cn/showproblem.php?pid=2025</a>
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;string&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25214;&#21040;&#26368;&#22823;&#23383;&#31526;&#65292;&#21487;&#20197;&#21033;&#29992;&#26522;&#20030;
</span>    <span class="org-type">string</span> <span class="org-variable-name">s</span>;
    <span class="org-keyword">while</span> (cin &gt;&gt; s) {
        <span class="org-type">string</span> <span class="org-variable-name">ret</span> = <span class="org-string">""</span>;
        <span class="org-type">char</span> <span class="org-variable-name">maxc</span> = <span class="org-string">'a'</span>;
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; s.size(); ++i) {
            <span class="org-keyword">if</span> (s[i] &gt; maxc) {
                maxc = s[i];
            }
        }
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; s.size(); ++i) {
            ret = ret + s[i];        <span class="org-comment-delimiter">// </span><span class="org-comment">&#23383;&#31526;&#20018;&#30340;&#36830;&#25509;
</span>            <span class="org-keyword">if</span> (s[i] == maxc) {
                ret = ret + <span class="org-string">"(max)"</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23383;&#31526;&#20018;&#30340;&#36830;&#25509;
</span>            }
        }
        cout &lt;&lt; ret &lt;&lt; endl;
    }

    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:38743f20-a75a-4594-8ac9-0718004bce4e" class="outline-4">
<h4 id="h:38743f20-a75a-4594-8ac9-0718004bce4e"><a href="#h:38743f20-a75a-4594-8ac9-0718004bce4e">核心代码模式</a></h4>
<div class="outline-text-4" id="text-h:38743f20-a75a-4594-8ac9-0718004bce4e">
</div>
<div id="outline-container-h:3a22b860-bb99-453b-8a86-aa6bfe7b7791" class="outline-5">
<h5 id="h:3a22b860-bb99-453b-8a86-aa6bfe7b7791"><a href="#h:3a22b860-bb99-453b-8a86-aa6bfe7b7791">4.判断国际象棋棋盘中一个格子的颜色</a></h5>
<div class="outline-text-5" id="text-h:3a22b860-bb99-453b-8a86-aa6bfe7b7791">
<p>
<a href="https://leetcode.cn/problems/determine-color-of-a-chessboard-square/description/">https://leetcode.cn/problems/determine-color-of-a-chessboard-square/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#22352;&#26631; coordinates &#65292;&#23427;&#26159;&#19968;&#20010;&#23383;&#31526;&#20018;&#65292;&#34920;&#31034;&#22269;&#38469;&#35937;&#26827;&#26827;&#30424;&#20013;&#19968;&#20010;&#26684;&#23376;&#30340;&#22352;&#26631;&#12290;&#19979;&#22270;&#26159;&#22269;&#38469;&#35937;&#26827;&#26827;&#30424;&#31034;&#24847;&#22270;&#12290;

&#22914;&#26524;&#25152;&#32473;&#26684;&#23376;&#30340;&#39068;&#33394;&#26159;&#30333;&#33394;&#65292;&#35831;&#20320;&#36820;&#22238; true&#65292;&#22914;&#26524;&#26159;&#40657;&#33394;&#65292;&#35831;&#36820;&#22238; false &#12290;

&#32473;&#23450;&#22352;&#26631;&#19968;&#23450;&#20195;&#34920;&#22269;&#38469;&#35937;&#26827;&#26827;&#30424;&#19978;&#19968;&#20010;&#23384;&#22312;&#30340;&#26684;&#23376;&#12290;&#22352;&#26631;&#31532;&#19968;&#20010;&#23383;&#31526;&#26159;&#23383;&#27597;&#65292;&#31532;&#20108;&#20010;&#23383;&#31526;&#26159;&#25968;&#23383;&#12290;


&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;coordinates = "a1"
&#36755;&#20986;&#65306;false
&#35299;&#37322;&#65306;&#22914;&#19978;&#22270;&#26827;&#30424;&#25152;&#31034;&#65292;"a1" &#22352;&#26631;&#30340;&#26684;&#23376;&#26159;&#40657;&#33394;&#30340;&#65292;&#25152;&#20197;&#36820;&#22238; false &#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;coordinates = "h3"
&#36755;&#20986;&#65306;true
&#35299;&#37322;&#65306;&#22914;&#19978;&#22270;&#26827;&#30424;&#25152;&#31034;&#65292;"h3" &#22352;&#26631;&#30340;&#26684;&#23376;&#26159;&#30333;&#33394;&#30340;&#65292;&#25152;&#20197;&#36820;&#22238; true &#12290;

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;coordinates = "c7"
&#36755;&#20986;&#65306;false

&#25552;&#31034;&#65306;
coordinates.length == 2
'a' &lt;= coordinates[0] &lt;= 'h'
'1' &lt;= coordinates[1] &lt;= '8'
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">bool</span> <span class="org-function-name">squareIsWhite</span>(<span class="org-type">string</span> <span class="org-variable-name">coordinates</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">a b c d e f g h &#26159;&#27178;&#22352;&#26631;&#65292;12345678&#26159;&#32437;&#22352;&#26631;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;abcdefgh&#21464;&#25104;01234567; 12345678&#21464;&#25104;01234567
</span>        <span class="org-type">int</span> <span class="org-variable-name">x</span> = coordinates[0] - <span class="org-string">'a'</span>;
        <span class="org-type">int</span> <span class="org-variable-name">y</span> = coordinates[1] - <span class="org-string">'1'</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">x + y &#26159;&#22855;&#25968;&#26102;&#65292;&#26159;&#30333;&#33394;
</span>        <span class="org-keyword">return</span> (x + y) % 2 == 1;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:07ce264b-ce60-4d2f-963d-318d8e4e752e" class="outline-5">
<h5 id="h:07ce264b-ce60-4d2f-963d-318d8e4e752e"><a href="#h:07ce264b-ce60-4d2f-963d-318d8e4e752e">5.路径加密</a></h5>
<div class="outline-text-5" id="text-h:07ce264b-ce60-4d2f-963d-318d8e4e752e">
<p>
<a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/description/">https://leetcode.cn/problems/ti-huan-kong-ge-lcof/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#20551;&#23450;&#19968;&#27573;&#36335;&#24452;&#35760;&#20316;&#23383;&#31526;&#20018; path&#65292;&#20854;&#20013;&#20197; "." &#20316;&#20026;&#20998;&#38548;&#31526;&#12290;&#29616;&#38656;&#23558;&#36335;&#24452;&#21152;&#23494;&#65292;
&#21152;&#23494;&#26041;&#27861;&#20026;&#23558; path &#20013;&#30340;&#20998;&#38548;&#31526;&#26367;&#25442;&#20026;&#31354;&#26684; " "&#65292;&#35831;&#36820;&#22238;&#21152;&#23494;&#21518;&#30340;&#23383;&#31526;&#20018;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;path = "a.aef.qerf.bb"
&#36755;&#20986;&#65306;"a aef qerf bb"

&#38480;&#21046;&#65306;
0 &lt;= path.length &lt;= 10000
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">string</span> <span class="org-function-name">pathEncryption</span>(<span class="org-type">string</span> <span class="org-variable-name">path</span>) {
        <span class="org-type">int</span> <span class="org-variable-name">len</span> = path.size();
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt;len; ++i) {
            <span class="org-keyword">if</span>(path[i] == <span class="org-string">'.'</span>) {
                path[i] = <span class="org-string">' '</span>;
            }
        }
        <span class="org-keyword">return</span> path;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:ce2e696a-75d6-403c-88dc-5def0b8b3eef" class="outline-5">
<h5 id="h:ce2e696a-75d6-403c-88dc-5def0b8b3eef"><a href="#h:ce2e696a-75d6-403c-88dc-5def0b8b3eef">6.长度为三且各字符不同的子字符串</a></h5>
<div class="outline-text-5" id="text-h:ce2e696a-75d6-403c-88dc-5def0b8b3eef">
<p>
<a href="https://leetcode.cn/problems/substrings-of-size-three-with-distinct-characters/description/">https://leetcode.cn/problems/substrings-of-size-three-with-distinct-characters/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#22914;&#26524;&#19968;&#20010;&#23383;&#31526;&#20018;&#19981;&#21547;&#26377;&#20219;&#20309;&#37325;&#22797;&#23383;&#31526;&#65292;&#25105;&#20204;&#31216;&#36825;&#20010;&#23383;&#31526;&#20018;&#20026; &#22909; &#23383;&#31526;&#20018;&#12290;

&#32473;&#20320;&#19968;&#20010;&#23383;&#31526;&#20018; s &#65292;&#35831;&#20320;&#36820;&#22238; s &#20013;&#38271;&#24230;&#20026; 3 &#30340; &#22909;&#23376;&#23383;&#31526;&#20018; &#30340;&#25968;&#37327;&#12290;

&#27880;&#24847;&#65292;&#22914;&#26524;&#30456;&#21516;&#30340;&#22909;&#23376;&#23383;&#31526;&#20018;&#20986;&#29616;&#22810;&#27425;&#65292;&#27599;&#19968;&#27425;&#37117;&#24212;&#35813;&#34987;&#35760;&#20837;&#31572;&#26696;&#20043;&#20013;&#12290;

&#23376;&#23383;&#31526;&#20018; &#26159;&#19968;&#20010;&#23383;&#31526;&#20018;&#20013;&#36830;&#32493;&#30340;&#23383;&#31526;&#24207;&#21015;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;s = "xyzzaz"
&#36755;&#20986;&#65306;1
&#35299;&#37322;&#65306;&#24635;&#20849;&#26377; 4 &#20010;&#38271;&#24230;&#20026; 3 &#30340;&#23376;&#23383;&#31526;&#20018;&#65306;"xyz"&#65292;"yzz"&#65292;"zza" &#21644; "zaz" &#12290;
&#21807;&#19968;&#30340;&#38271;&#24230;&#20026; 3 &#30340;&#22909;&#23376;&#23383;&#31526;&#20018;&#26159; "xyz" &#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;s = "aababcabc"
&#36755;&#20986;&#65306;4
&#35299;&#37322;&#65306;&#24635;&#20849;&#26377; 7 &#20010;&#38271;&#24230;&#20026; 3 &#30340;&#23376;&#23383;&#31526;&#20018;&#65306;"aab"&#65292;"aba"&#65292;"bab"&#65292;"abc"&#65292;"bca"&#65292;"cab" &#21644; "abc" &#12290;
&#22909;&#23376;&#23383;&#31526;&#20018;&#21253;&#25324; "abc"&#65292;"bca"&#65292;"cab" &#21644; "abc" &#12290;

&#25552;&#31034;&#65306;
1 &lt;= s.length &lt;= 100
s &#21482;&#21253;&#21547;&#23567;&#20889;&#33521;&#25991;&#23383;&#27597;&#12290;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">countGoodSubstrings</span>(<span class="org-type">string</span> <span class="org-variable-name">s</span>) {
        <span class="org-type">int</span> <span class="org-variable-name">cnt</span> = 0;
        <span class="org-type">int</span> <span class="org-variable-name">len</span> = s.size();
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; len - 2; ++i) {
            <span class="org-type">int</span> <span class="org-variable-name">a</span> = s[i];
            <span class="org-type">int</span> <span class="org-variable-name">b</span> = s[i + 1];
            <span class="org-type">int</span> <span class="org-variable-name">c</span> = s[i + 2];
            <span class="org-keyword">if</span>(a != b &amp;&amp; b != c &amp; a != c) {
                ++cnt;
            }
        }
        <span class="org-keyword">return</span> cnt;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:80b5375e-b7e2-45c6-a09b-37f0a5763456" class="outline-5">
<h5 id="h:80b5375e-b7e2-45c6-a09b-37f0a5763456"><a href="#h:80b5375e-b7e2-45c6-a09b-37f0a5763456">7.速算机器人</a></h5>
<div class="outline-text-5" id="text-h:80b5375e-b7e2-45c6-a09b-37f0a5763456">
<p>
<a href="https://leetcode.cn/problems/nGK0Fy/description/">https://leetcode.cn/problems/nGK0Fy/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#23567;&#25187;&#22312;&#31179;&#26085;&#24066;&#38598;&#21457;&#29616;&#20102;&#19968;&#27454;&#36895;&#31639;&#26426;&#22120;&#20154;&#12290;&#24215;&#23478;&#23545;&#26426;&#22120;&#20154;&#35828;&#20986;&#20004;&#20010;&#25968;&#23383;&#65288;&#35760;&#20316; x &#21644; y&#65289;&#65292;&#35831;&#23567;&#25187;&#35828;&#20986;&#35745;&#31639;&#25351;&#20196;&#65306;

"A" &#36816;&#31639;&#65306;&#20351; x = 2 * x + y&#65307;
"B" &#36816;&#31639;&#65306;&#20351; y = 2 * y + x&#12290;
&#22312;&#26412;&#27425;&#28216;&#25103;&#20013;&#65292;&#24215;&#23478;&#35828;&#20986;&#30340;&#25968;&#23383;&#20026; x = 1 &#21644; y = 0&#65292;&#23567;&#25187;&#35828;&#20986;&#30340;&#35745;&#31639;&#25351;&#20196;&#35760;&#20316;&#20165;&#30001;&#22823;&#20889;&#23383;&#27597; A&#12289;B &#32452;&#25104;&#30340;&#23383;&#31526;&#20018; s&#65292;&#23383;&#31526;&#20018;&#20013;&#23383;&#31526;&#30340;&#39034;&#24207;&#34920;&#31034;&#35745;&#31639;&#39034;&#24207;&#65292;&#35831;&#36820;&#22238;&#26368;&#32456; x &#19982; y &#30340;&#21644;&#20026;&#22810;&#23569;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;s = "AB"

&#36755;&#20986;&#65306;4
&#35299;&#37322;&#65306; &#32463;&#36807;&#19968;&#27425; A &#36816;&#31639;&#21518;&#65292;x = 2, y = 0&#12290; &#20877;&#32463;&#36807;&#19968;&#27425; B &#36816;&#31639;&#65292;x = 2, y = 2&#12290; &#26368;&#32456; x &#19982; y &#20043;&#21644;&#20026; 4&#12290;

&#25552;&#31034;&#65306;
0 &lt;= s.length &lt;= 10
s &#30001; 'A' &#21644; 'B' &#32452;&#25104;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">calculate</span>(<span class="org-type">string</span> <span class="org-variable-name">s</span>) {
        <span class="org-type">int</span> <span class="org-variable-name">x</span> = 1, <span class="org-variable-name">y</span> = 0;
        <span class="org-type">int</span> <span class="org-variable-name">len</span> = s.size();
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; len; ++i) {
            <span class="org-keyword">if</span>(s[i] == <span class="org-string">'A'</span>){
                x = 2 * x + y;
            } <span class="org-keyword">else</span> {
                y = 2 * y + x;
            }
        }
        <span class="org-keyword">return</span> x + y;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:7288ccaa-780d-48b1-8293-ac8f80a3d10a" class="outline-5">
<h5 id="h:7288ccaa-780d-48b1-8293-ac8f80a3d10a"><a href="#h:7288ccaa-780d-48b1-8293-ac8f80a3d10a">8.执行操作后的变量值</a></h5>
<div class="outline-text-5" id="text-h:7288ccaa-780d-48b1-8293-ac8f80a3d10a">
<p>
<a href="https://leetcode.cn/problems/final-value-of-variable-after-performing-operations/description/">https://leetcode.cn/problems/final-value-of-variable-after-performing-operations/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#23384;&#22312;&#19968;&#31181;&#20165;&#25903;&#25345; 4 &#31181;&#25805;&#20316;&#21644; 1 &#20010;&#21464;&#37327; X &#30340;&#32534;&#31243;&#35821;&#35328;&#65306;

++X &#21644; X++ &#20351;&#21464;&#37327; X &#30340;&#20540; &#21152; 1
--X &#21644; X-- &#20351;&#21464;&#37327; X &#30340;&#20540; &#20943; 1
&#26368;&#21021;&#65292;X &#30340;&#20540;&#26159; 0

&#32473;&#20320;&#19968;&#20010;&#23383;&#31526;&#20018;&#25968;&#32452; operations &#65292;&#36825;&#26159;&#30001;&#25805;&#20316;&#32452;&#25104;&#30340;&#19968;&#20010;&#21015;&#34920;&#65292;&#36820;&#22238;&#25191;&#34892;&#25152;&#26377;&#25805;&#20316;&#21518;&#65292; X &#30340; &#26368;&#32456;&#20540; &#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;operations = ["--X","X++","X++"]
&#36755;&#20986;&#65306;1
&#35299;&#37322;&#65306;&#25805;&#20316;&#25353;&#19979;&#36848;&#27493;&#39588;&#25191;&#34892;&#65306;
&#26368;&#21021;&#65292;X = 0
--X&#65306;X &#20943; 1 &#65292;X =  0 - 1 = -1
X++&#65306;X &#21152; 1 &#65292;X = -1 + 1 =  0
X++&#65306;X &#21152; 1 &#65292;X =  0 + 1 =  1

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;operations = ["++X","++X","X++"]
&#36755;&#20986;&#65306;3
&#35299;&#37322;&#65306;&#25805;&#20316;&#25353;&#19979;&#36848;&#27493;&#39588;&#25191;&#34892;&#65306; 
&#26368;&#21021;&#65292;X = 0
++X&#65306;X &#21152; 1 &#65292;X = 0 + 1 = 1
++X&#65306;X &#21152; 1 &#65292;X = 1 + 1 = 2
X++&#65306;X &#21152; 1 &#65292;X = 2 + 1 = 3

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;operations = ["X++","++X","--X","X--"]
&#36755;&#20986;&#65306;0
&#35299;&#37322;&#65306;&#25805;&#20316;&#25353;&#19979;&#36848;&#27493;&#39588;&#25191;&#34892;&#65306;
&#26368;&#21021;&#65292;X = 0
X++&#65306;X &#21152; 1 &#65292;X = 0 + 1 = 1
++X&#65306;X &#21152; 1 &#65292;X = 1 + 1 = 2
--X&#65306;X &#20943; 1 &#65292;X = 2 - 1 = 1
X--&#65306;X &#20943; 1 &#65292;X = 1 - 1 = 0
 

&#25552;&#31034;&#65306;
1 &lt;= operations.length &lt;= 100
operations[i] &#23558;&#20250;&#26159; "++X"&#12289;"X++"&#12289;"--X" &#25110; "X--"
</pre>
</div>


<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">finalValueAfterOperations</span>(<span class="org-type">vector</span>&lt;<span class="org-type">string</span>&gt;&amp; <span class="org-variable-name">operations</span>) {
        <span class="org-type">int</span> <span class="org-variable-name">X</span> = 0;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; operations.size(); ++i) {
            <span class="org-type">string</span> <span class="org-variable-name">s</span> = operations[i];
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#21028;&#26029;s&#30340;&#31532;&#19968;&#20010;&#20301;&#32622;&#26159;&#21152;&#21495;&#36824;&#26159;&#20943;&#21495;
</span>            <span class="org-keyword">if</span>(s[1] == <span class="org-string">'+'</span>) {
                X++;
            }<span class="org-keyword">else</span> {
                X--;
            }
        }
        <span class="org-keyword">return</span> X;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:d85be20f-59b4-4612-89ce-31bddc0fc631" class="outline-5">
<h5 id="h:d85be20f-59b4-4612-89ce-31bddc0fc631"><a href="#h:d85be20f-59b4-4612-89ce-31bddc0fc631">9.IP 地址无效化</a></h5>
<div class="outline-text-5" id="text-h:d85be20f-59b4-4612-89ce-31bddc0fc631">
<p>
<a href="https://leetcode.cn/problems/defanging-an-ip-address/description/">https://leetcode.cn/problems/defanging-an-ip-address/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#26377;&#25928;&#30340; IPv4 &#22320;&#22336; address&#65292;&#36820;&#22238;&#36825;&#20010; IP &#22320;&#22336;&#30340;&#26080;&#25928;&#21270;&#29256;&#26412;&#12290;

&#25152;&#35859;&#26080;&#25928;&#21270; IP &#22320;&#22336;&#65292;&#20854;&#23454;&#23601;&#26159;&#29992; "[.]" &#20195;&#26367;&#20102;&#27599;&#20010; "."&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;address = "1.1.1.1"
&#36755;&#20986;&#65306;"1[.]1[.]1[.]1"

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;address = "255.100.50.0"
&#36755;&#20986;&#65306;"255[.]100[.]50[.]0"

&#25552;&#31034;&#65306;
&#32473;&#20986;&#30340; address &#26159;&#19968;&#20010;&#26377;&#25928;&#30340; IPv4 &#22320;&#22336;
</pre>
</div>


<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">string</span> <span class="org-function-name">defangIPaddr</span>(<span class="org-type">string</span> <span class="org-variable-name">address</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#36935;&#21040;.&#28857;&#21464;&#20026;[.]
</span>        <span class="org-type">string</span> <span class="org-variable-name">s</span> = <span class="org-string">""</span>;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; address.size(); ++i) {
            <span class="org-keyword">if</span>(address[i] == <span class="org-string">'.'</span>) {
                s = s + <span class="org-string">"[.]"</span>;
            }<span class="org-keyword">else</span> {
                s += address[i];
            }
        }
        <span class="org-keyword">return</span> s;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:c4c1d5e3-2e26-4a45-a716-bac31436f3f8" class="outline-5">
<h5 id="h:c4c1d5e3-2e26-4a45-a716-bac31436f3f8"><a href="#h:c4c1d5e3-2e26-4a45-a716-bac31436f3f8">10.统计星号</a></h5>
<div class="outline-text-5" id="text-h:c4c1d5e3-2e26-4a45-a716-bac31436f3f8">
<p>
<a href="https://leetcode.cn/problems/count-asterisks/description/">https://leetcode.cn/problems/count-asterisks/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#23383;&#31526;&#20018; s &#65292;&#27599; &#20004;&#20010; &#36830;&#32493;&#31446;&#32447; '|' &#20026; &#19968;&#23545; &#12290;
&#25442;&#35328;&#20043;&#65292;&#31532;&#19968;&#20010;&#21644;&#31532;&#20108;&#20010; '|' &#20026;&#19968;&#23545;&#65292;&#31532;&#19977;&#20010;&#21644;&#31532;&#22235;&#20010; '|' &#20026;&#19968;&#23545;&#65292;&#20197;&#27492;&#31867;&#25512;&#12290;

&#35831;&#20320;&#36820;&#22238; &#19981;&#22312; &#31446;&#32447;&#23545;&#20043;&#38388;&#65292;s &#20013; '*' &#30340;&#25968;&#30446;&#12290;

&#27880;&#24847;&#65292;&#27599;&#20010;&#31446;&#32447; '|' &#37117;&#20250; &#24688;&#22909; &#23646;&#20110;&#19968;&#20010;&#23545;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;s = "l|*e*et|c**o|*de|"
&#36755;&#20986;&#65306;2
&#35299;&#37322;&#65306;&#19981;&#22312;&#31446;&#32447;&#23545;&#20043;&#38388;&#30340;&#23383;&#31526;&#21152;&#31895;&#21152;&#26012;&#20307;&#21518;&#65292;&#24471;&#21040;&#23383;&#31526;&#20018;&#65306;"l|*e*et|c**o|*de|" &#12290;
&#31532;&#19968;&#21644;&#31532;&#20108;&#26465;&#31446;&#32447; '|' &#20043;&#38388;&#30340;&#23383;&#31526;&#19981;&#35745;&#20837;&#31572;&#26696;&#12290;
&#21516;&#26102;&#65292;&#31532;&#19977;&#26465;&#21644;&#31532;&#22235;&#26465;&#31446;&#32447; '|' &#20043;&#38388;&#30340;&#23383;&#31526;&#20063;&#19981;&#35745;&#20837;&#31572;&#26696;&#12290;
&#19981;&#22312;&#31446;&#32447;&#23545;&#20043;&#38388;&#24635;&#20849;&#26377; 2 &#20010;&#26143;&#21495;&#65292;&#25152;&#20197;&#25105;&#20204;&#36820;&#22238; 2 &#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;s = "iamprogrammer"
&#36755;&#20986;&#65306;0
&#35299;&#37322;&#65306;&#22312;&#36825;&#20010;&#20363;&#23376;&#20013;&#65292;s &#20013;&#27809;&#26377;&#26143;&#21495;&#12290;&#25152;&#20197;&#36820;&#22238; 0 &#12290;

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;s = "yo|uar|e**|b|e***au|tifu|l"
&#36755;&#20986;&#65306;5
&#35299;&#37322;&#65306;&#38656;&#35201;&#32771;&#34385;&#30340;&#23383;&#31526;&#21152;&#31895;&#21152;&#26012;&#20307;&#21518;&#65306;"yo|uar|e**|b|e***au|tifu|l" &#12290;&#19981;&#22312;&#31446;&#32447;&#23545;&#20043;&#38388;&#24635;&#20849;&#26377; 5 &#20010;&#26143;&#21495;&#12290;&#25152;&#20197;&#25105;&#20204;&#36820;&#22238; 5 &#12290;
 

&#25552;&#31034;&#65306;
1 &lt;= s.length &lt;= 1000
s &#21482;&#21253;&#21547;&#23567;&#20889;&#33521;&#25991;&#23383;&#27597;&#65292;&#31446;&#32447; '|' &#21644;&#26143;&#21495; '*' &#12290;
s &#21253;&#21547; &#20598;&#25968; &#20010;&#31446;&#32447; '|' &#12290;
</pre>
</div>


<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">countAsterisks</span>(<span class="org-type">string</span> <span class="org-variable-name">s</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#36941;&#21382;&#23383;&#31526;&#20018;&#23545;|&#36827;&#34892;&#20837;&#26632;&#21644;&#20986;&#26632;&#65292;&#21487;&#20197;&#29992;+-&#26469;&#34920;&#31034;&#12290;&#25110;&#32773;&#19968;&#30452;&#21152;&#20877;&#21028;&#26029;&#22855;&#20598;&#24615;
</span>        <span class="org-type">int</span> <span class="org-variable-name">sh</span> = 0; <span class="org-comment-delimiter">// </span><span class="org-comment">&#34920;&#31034;&#31446;&#32447;&#20986;&#29616;&#22855;&#25968;&#27425;&#36824;&#26159;&#20598;&#25968;&#27425;
</span>        <span class="org-type">int</span> <span class="org-variable-name">ret</span> = 0;
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; s.size(); ++i) {
            <span class="org-keyword">if</span>(s[i] == <span class="org-string">'|'</span>) {
                sh = sh + 1;
            }<span class="org-keyword">else</span> <span class="org-keyword">if</span>(s[i] == <span class="org-string">'*'</span>) {
                <span class="org-keyword">if</span>(sh % 2 == 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#20598;&#25968;&#26102;&#65292;&#26143;&#21495;&#21152;&#36827;&#26469;
</span>                    ret++;
                }
            }
        }
        <span class="org-keyword">return</span> ret;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:d343f858-fb2e-4cfd-a843-8bac6378927c" class="outline-5">
<h5 id="h:d343f858-fb2e-4cfd-a843-8bac6378927c"><a href="#h:d343f858-fb2e-4cfd-a843-8bac6378927c">11.分割平衡字符串</a></h5>
<div class="outline-text-5" id="text-h:d343f858-fb2e-4cfd-a843-8bac6378927c">
<p>
<a href="https://leetcode.cn/problems/split-a-string-in-balanced-strings/description/">https://leetcode.cn/problems/split-a-string-in-balanced-strings/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#24179;&#34913;&#23383;&#31526;&#20018; &#20013;&#65292;'L' &#21644; 'R' &#23383;&#31526;&#30340;&#25968;&#37327;&#26159;&#30456;&#21516;&#30340;&#12290;

&#32473;&#20320;&#19968;&#20010;&#24179;&#34913;&#23383;&#31526;&#20018; s&#65292;&#35831;&#20320;&#23558;&#23427;&#20998;&#21106;&#25104;&#23613;&#21487;&#33021;&#22810;&#30340;&#23376;&#23383;&#31526;&#20018;&#65292;&#24182;&#28385;&#36275;&#65306;

&#27599;&#20010;&#23376;&#23383;&#31526;&#20018;&#37117;&#26159;&#24179;&#34913;&#23383;&#31526;&#20018;&#12290;
&#36820;&#22238;&#21487;&#20197;&#36890;&#36807;&#20998;&#21106;&#24471;&#21040;&#30340;&#24179;&#34913;&#23383;&#31526;&#20018;&#30340; &#26368;&#22823;&#25968;&#37327; &#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;s = "RLRRLLRLRL"
&#36755;&#20986;&#65306;4
&#35299;&#37322;&#65306;s &#21487;&#20197;&#20998;&#21106;&#20026; "RL"&#12289;"RRLL"&#12289;"RL"&#12289;"RL" &#65292;&#27599;&#20010;&#23376;&#23383;&#31526;&#20018;&#20013;&#37117;&#21253;&#21547;&#30456;&#21516;&#25968;&#37327;&#30340; 'L' &#21644; 'R' &#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;s = "RLRRRLLRLL"
&#36755;&#20986;&#65306;2
&#35299;&#37322;&#65306;s &#21487;&#20197;&#20998;&#21106;&#20026; "RL"&#12289;"RRRLLRLL"&#65292;&#27599;&#20010;&#23376;&#23383;&#31526;&#20018;&#20013;&#37117;&#21253;&#21547;&#30456;&#21516;&#25968;&#37327;&#30340; 'L' &#21644; 'R' &#12290;
&#27880;&#24847;&#65292;s &#26080;&#27861;&#20998;&#21106;&#20026; "RL"&#12289;"RR"&#12289;"RL"&#12289;"LR"&#12289;"LL" &#22240;&#20026;&#31532; 2 &#20010;&#21644;&#31532; 5 &#20010;&#23376;&#23383;&#31526;&#20018;&#19981;&#26159;&#24179;&#34913;&#23383;&#31526;&#20018;&#12290;

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;s = "LLLLRRRR"
&#36755;&#20986;&#65306;1
&#35299;&#37322;&#65306;s &#21482;&#33021;&#20445;&#25345;&#21407;&#26679; "LLLLRRRR" &#12290;

&#25552;&#31034;&#65306;
2 &lt;= s.length &lt;= 1000
s[i] = 'L' &#25110; 'R'
s &#26159;&#19968;&#20010; &#24179;&#34913; &#23383;&#31526;&#20018;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">balancedStringSplit</span>(<span class="org-type">string</span> <span class="org-variable-name">s</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#36138;&#24515;&#24605;&#36335;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#36935;&#21040;L&#35745;&#25968;&#22120;&#21152;1&#65292;&#36935;&#21040;R&#35745;&#25968;&#22120;&#20943;1
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#35745;&#25968;&#22120;&#20026;0&#26102;&#65292;&#35828;&#26126;&#21069;&#38754;&#36941;&#21382;&#30340;&#37096;&#20998;&#65292;L&#21644;R&#30340;&#25968;&#37327;&#26159;&#30456;&#31561;&#30340;&#65292;&#36825;&#26102;&#20998;&#21106;
</span>        <span class="org-type">int</span> <span class="org-variable-name">cnt</span> = 0;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#35745;&#25968;&#22120;&#65292;&#34920;&#31034;L&#21644;R&#25968;&#37327;&#30340;&#24046;&#20540;
</span>        <span class="org-type">int</span> <span class="org-variable-name">ret</span> = 0;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; s.size(); ++i) {
            <span class="org-keyword">if</span> (s[i] == <span class="org-string">'L'</span>){
                ++cnt;
            }<span class="org-keyword">else</span> <span class="org-keyword">if</span> (s[i] == <span class="org-string">'R'</span>) {
                --cnt;
            }
            <span class="org-keyword">if</span>(cnt == 0) {
                ++ret;
            }
        }
        <span class="org-keyword">return</span> ret;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:ef42541d-8311-4f84-a24a-8fff67ebe8a2" class="outline-5">
<h5 id="h:ef42541d-8311-4f84-a24a-8fff67ebe8a2"><a href="#h:ef42541d-8311-4f84-a24a-8fff67ebe8a2">12.动态口令</a></h5>
<div class="outline-text-5" id="text-h:ef42541d-8311-4f84-a24a-8fff67ebe8a2">
<p>
<a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#26576;&#20844;&#21496;&#38376;&#31105;&#23494;&#30721;&#20351;&#29992;&#21160;&#24577;&#21475;&#20196;&#25216;&#26415;&#12290;&#21021;&#22987;&#23494;&#30721;&#20026;&#23383;&#31526;&#20018; password&#65292;&#23494;&#30721;&#26356;&#26032;&#22343;&#36981;&#24490;&#20197;&#19979;&#27493;&#39588;&#65306;

&#35774;&#23450;&#19968;&#20010;&#27491;&#25972;&#25968;&#30446;&#26631;&#20540; target
&#23558; password &#21069; target &#20010;&#23383;&#31526;&#25353;&#21407;&#39034;&#24207;&#31227;&#21160;&#33267;&#23383;&#31526;&#20018;&#26411;&#23614;
&#35831;&#36820;&#22238;&#26356;&#26032;&#21518;&#30340;&#23494;&#30721;&#23383;&#31526;&#20018;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;: password = "s3cur1tyC0d3", target = 4
&#36755;&#20986;: "r1tyC0d3s3cu"

&#31034;&#20363; 2&#65306;
&#36755;&#20837;: password = "lrloseumgh", target = 6
&#36755;&#20986;: "umghlrlose"

&#25552;&#31034;&#65306;
1 &lt;= target &lt; password.length &lt;= 10000
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">string</span> <span class="org-function-name">dynamicPassword</span>(<span class="org-type">string</span> <span class="org-variable-name">password</span>, <span class="org-type">int</span> <span class="org-variable-name">target</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;&#23383;&#31526;&#20018;password&#24819;&#35937;&#25104;&#19968;&#20010;&#29615;. &#24490;&#29615;&#21487;&#20197;&#29992;&#21462;&#27169;&#35299;&#20915;
</span>        <span class="org-type">string</span> <span class="org-variable-name">ret</span>;
        <span class="org-type">int</span> <span class="org-variable-name">n</span> = password.size();
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; ++i){
            ret = ret + password[(i + target) % n];
        }
        <span class="org-keyword">return</span> ret;
    }
};

<span class="org-comment-delimiter">// </span><span class="org-comment">12345 &#23558;1&#20010;&#23383;&#31526;&#31227;&#21160;&#21040;&#26411;&#23614;23451
</span><span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;2&#20010;&#23383;&#31526;&#31227;&#21160;&#21040;&#26411;&#23614;34512
</span><span class="org-comment-delimiter">// </span><span class="org-comment">45123
</span><span class="org-comment-delimiter">// </span><span class="org-comment">51234
</span><span class="org-comment-delimiter">// </span><span class="org-comment">12345</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-h:71c6caa1-a711-4ec8-877c-c3eb0fc1f5ff" class="outline-5">
<h5 id="h:71c6caa1-a711-4ec8-877c-c3eb0fc1f5ff"><a href="#h:71c6caa1-a711-4ec8-877c-c3eb0fc1f5ff">13.设计 Goal 解析器</a></h5>
<div class="outline-text-5" id="text-h:71c6caa1-a711-4ec8-877c-c3eb0fc1f5ff">
<p>
<a href="https://leetcode.cn/problems/goal-parser-interpretation/description/">https://leetcode.cn/problems/goal-parser-interpretation/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#35831;&#20320;&#35774;&#35745;&#19968;&#20010;&#21487;&#20197;&#35299;&#37322;&#23383;&#31526;&#20018; command &#30340; Goal &#35299;&#26512;&#22120; &#12290;command &#30001; "G"&#12289;"()" &#21644;/&#25110; "(al)" &#25353;&#26576;&#31181;&#39034;&#24207;&#32452;&#25104;&#12290;
Goal &#35299;&#26512;&#22120;&#20250;&#23558; "G" &#35299;&#37322;&#20026;&#23383;&#31526;&#20018; "G"&#12289;"()" &#35299;&#37322;&#20026;&#23383;&#31526;&#20018; "o" &#65292;
"(al)" &#35299;&#37322;&#20026;&#23383;&#31526;&#20018; "al" &#12290;&#28982;&#21518;&#65292;&#25353;&#21407;&#39034;&#24207;&#23558;&#32463;&#35299;&#37322;&#24471;&#21040;&#30340;&#23383;&#31526;&#20018;&#36830;&#25509;&#25104;&#19968;&#20010;&#23383;&#31526;&#20018;&#12290;

&#32473;&#20320;&#23383;&#31526;&#20018; command &#65292;&#36820;&#22238; Goal &#35299;&#26512;&#22120; &#23545; command &#30340;&#35299;&#37322;&#32467;&#26524;&#12290;
 

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;command = "G()(al)"
&#36755;&#20986;&#65306;"Goal"
&#35299;&#37322;&#65306;Goal &#35299;&#26512;&#22120;&#35299;&#37322;&#21629;&#20196;&#30340;&#27493;&#39588;&#22914;&#19979;&#25152;&#31034;&#65306;
G -&gt; G
() -&gt; o
(al) -&gt; al
&#26368;&#21518;&#36830;&#25509;&#24471;&#21040;&#30340;&#32467;&#26524;&#26159; "Goal"

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;command = "G()()()()(al)"
&#36755;&#20986;&#65306;"Gooooal"

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;command = "(al)G(al)()()G"
&#36755;&#20986;&#65306;"alGalooG"

&#25552;&#31034;&#65306;
1 &lt;= command.length &lt;= 100
command &#30001; "G"&#12289;"()" &#21644;/&#25110; "(al)" &#25353;&#26576;&#31181;&#39034;&#24207;&#32452;&#25104;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">string</span> <span class="org-function-name">interpret</span>(<span class="org-type">string</span> <span class="org-variable-name">command</span>) {
        <span class="org-type">string</span> <span class="org-variable-name">ret</span>;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; command.size(); ++i) {
            <span class="org-keyword">if</span> (command[i] == <span class="org-string">'G'</span>) {
                ret = ret + <span class="org-string">'G'</span>;
            }<span class="org-keyword">else</span> <span class="org-keyword">if</span> ( command[i] == <span class="org-string">'('</span> ) {
                <span class="org-keyword">if</span> ( command[i+1] == <span class="org-string">')'</span> ) {
                    ret = ret + <span class="org-string">'o'</span>;
                    i++;
                }<span class="org-keyword">else</span> {
                    ret = ret + <span class="org-string">"al"</span>;
                    i += 3;
                }
            }<span class="org-keyword">else</span> {
                ret = ret + <span class="org-string">'/'</span>;
            }
        }
        <span class="org-keyword">return</span> ret;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:ada1442e-6df2-409f-b396-0ae32b953ae3" class="outline-5">
<h5 id="h:ada1442e-6df2-409f-b396-0ae32b953ae3"><a href="#h:ada1442e-6df2-409f-b396-0ae32b953ae3">14.句子中的最多单词数</a></h5>
<div class="outline-text-5" id="text-h:ada1442e-6df2-409f-b396-0ae32b953ae3">
<p>
<a href="https://leetcode.cn/problems/maximum-number-of-words-found-in-sentences/description/">https://leetcode.cn/problems/maximum-number-of-words-found-in-sentences/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#19968;&#20010; &#21477;&#23376; &#30001;&#19968;&#20123; &#21333;&#35789; &#20197;&#21450;&#23427;&#20204;&#20043;&#38388;&#30340;&#21333;&#20010;&#31354;&#26684;&#32452;&#25104;&#65292;&#21477;&#23376;&#30340;&#24320;&#22836;&#21644;&#32467;&#23614;&#19981;&#20250;&#26377;&#22810;&#20313;&#31354;&#26684;&#12290;

&#32473;&#20320;&#19968;&#20010;&#23383;&#31526;&#20018;&#25968;&#32452; sentences &#65292;&#20854;&#20013; sentences[i] &#34920;&#31034;&#21333;&#20010; &#21477;&#23376; &#12290;

&#35831;&#20320;&#36820;&#22238;&#21333;&#20010;&#21477;&#23376;&#37324; &#21333;&#35789;&#30340;&#26368;&#22810;&#25968;&#30446; &#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;sentences = ["alice and bob love leetcode", "i think so too", "this is great thanks very much"]
&#36755;&#20986;&#65306;6
&#35299;&#37322;&#65306;
- &#31532;&#19968;&#20010;&#21477;&#23376; "alice and bob love leetcode" &#24635;&#20849;&#26377; 5 &#20010;&#21333;&#35789;&#12290;
- &#31532;&#20108;&#20010;&#21477;&#23376; "i think so too" &#24635;&#20849;&#26377; 4 &#20010;&#21333;&#35789;&#12290;
- &#31532;&#19977;&#20010;&#21477;&#23376; "this is great thanks very much" &#24635;&#20849;&#26377; 6 &#20010;&#21333;&#35789;&#12290;
&#25152;&#20197;&#65292;&#21333;&#20010;&#21477;&#23376;&#20013;&#26377;&#26368;&#22810;&#21333;&#35789;&#25968;&#30340;&#26159;&#31532;&#19977;&#20010;&#21477;&#23376;&#65292;&#24635;&#20849;&#26377; 6 &#20010;&#21333;&#35789;&#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;sentences = ["please wait", "continue to fight", "continue to win"]
&#36755;&#20986;&#65306;3
&#35299;&#37322;&#65306;&#21487;&#33021;&#26377;&#22810;&#20010;&#21477;&#23376;&#26377;&#30456;&#21516;&#21333;&#35789;&#25968;&#12290;
&#36825;&#20010;&#20363;&#23376;&#20013;&#65292;&#31532;&#20108;&#20010;&#21477;&#23376;&#21644;&#31532;&#19977;&#20010;&#21477;&#23376;&#65288;&#21152;&#31895;&#26012;&#20307;&#65289;&#26377;&#30456;&#21516;&#25968;&#30446;&#30340;&#21333;&#35789;&#25968;&#12290;

&#25552;&#31034;&#65306;
1 &lt;= sentences.length &lt;= 100
1 &lt;= sentences[i].length &lt;= 100
sentences[i] &#21482;&#21253;&#21547;&#23567;&#20889;&#33521;&#25991;&#23383;&#27597;&#21644; ' ' &#12290;
sentences[i] &#30340;&#24320;&#22836;&#21644;&#32467;&#23614;&#37117;&#27809;&#26377;&#31354;&#26684;&#12290;
sentences[i] &#20013;&#25152;&#26377;&#21333;&#35789;&#30001;&#21333;&#20010;&#31354;&#26684;&#38548;&#24320;&#12290;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">mostWordsFound</span>(<span class="org-type">vector</span>&lt;<span class="org-type">string</span>&gt;&amp; <span class="org-variable-name">sentences</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21477;&#23376;&#30340;&#24320;&#22836;&#21644;&#32467;&#23614;&#19981;&#20250;&#26377;&#22810;&#20313;&#31354;&#26684;&#12290;&#21482;&#35201;&#32479;&#35745;&#31354;&#26684;&#25968;&#23601;&#21487;&#20197;&#20102;&#65292;&#31354;&#26684;&#25968;&#26159;n&#65292;&#21333;&#35789;&#25968;n+1
</span>        <span class="org-type">int</span> <span class="org-variable-name">ret</span> = 0;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; sentences.size(); ++i) {
            <span class="org-type">int</span> <span class="org-variable-name">k</span> = 1;
            <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; sentences[i].size(); ++j) {
                <span class="org-keyword">if</span>(sentences[i][j] == <span class="org-string">' '</span>) {
                    ++k;
                }
            }
            ret = max(ret, k);
        }
        <span class="org-keyword">return</span> ret;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:8a3f8181-1817-4271-93f4-17a38f422635" class="outline-5">
<h5 id="h:8a3f8181-1817-4271-93f4-17a38f422635"><a href="#h:8a3f8181-1817-4271-93f4-17a38f422635">15.统计一致字符串的数目</a></h5>
<div class="outline-text-5" id="text-h:8a3f8181-1817-4271-93f4-17a38f422635">
<p>
<a href="https://leetcode.cn/problems/count-the-number-of-consistent-strings/description/">https://leetcode.cn/problems/count-the-number-of-consistent-strings/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#30001;&#19981;&#21516;&#23383;&#31526;&#32452;&#25104;&#30340;&#23383;&#31526;&#20018; allowed &#21644;&#19968;&#20010;&#23383;&#31526;&#20018;&#25968;&#32452; words &#12290;
&#22914;&#26524;&#19968;&#20010;&#23383;&#31526;&#20018;&#30340;&#27599;&#19968;&#20010;&#23383;&#31526;&#37117;&#22312; allowed &#20013;&#65292;&#23601;&#31216;&#36825;&#20010;&#23383;&#31526;&#20018;&#26159; &#19968;&#33268;&#23383;&#31526;&#20018; &#12290;

&#35831;&#20320;&#36820;&#22238; words &#25968;&#32452;&#20013; &#19968;&#33268;&#23383;&#31526;&#20018; &#30340;&#25968;&#30446;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;allowed = "ab", words = ["ad","bd","aaab","baa","badab"]
&#36755;&#20986;&#65306;2
&#35299;&#37322;&#65306;&#23383;&#31526;&#20018; "aaab" &#21644; "baa" &#37117;&#26159;&#19968;&#33268;&#23383;&#31526;&#20018;&#65292;&#22240;&#20026;&#23427;&#20204;&#21482;&#21253;&#21547;&#23383;&#31526; 'a' &#21644; 'b' &#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;allowed = "abc", words = ["a","b","c","ab","ac","bc","abc"]
&#36755;&#20986;&#65306;7
&#35299;&#37322;&#65306;&#25152;&#26377;&#23383;&#31526;&#20018;&#37117;&#26159;&#19968;&#33268;&#30340;&#12290;

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;allowed = "cad", words = ["cc","acd","b","ba","bac","bad","ac","d"]
&#36755;&#20986;&#65306;4
&#35299;&#37322;&#65306;&#23383;&#31526;&#20018; "cc"&#65292;"acd"&#65292;"ac" &#21644; "d" &#26159;&#19968;&#33268;&#23383;&#31526;&#20018;&#12290;

&#25552;&#31034;&#65306;
1 &lt;= words.length &lt;= 104
1 &lt;= allowed.length &lt;= 26
1 &lt;= words[i].length &lt;= 10
allowed &#20013;&#30340;&#23383;&#31526; &#20114;&#19981;&#30456;&#21516; &#12290;
words[i] &#21644; allowed &#21482;&#21253;&#21547;&#23567;&#20889;&#33521;&#25991;&#23383;&#27597;&#12290;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">countConsistentStrings</span>(<span class="org-type">string</span> <span class="org-variable-name">allowed</span>, <span class="org-type">vector</span>&lt;<span class="org-type">string</span>&gt;&amp; <span class="org-variable-name">words</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#26631;&#35760;allowed
</span>        <span class="org-type">int</span> <span class="org-variable-name">has</span>[256] = {0};
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; allowed.size(); ++i) {
            has[allowed[i]] = 1;
        }

        <span class="org-type">int</span> <span class="org-variable-name">sum</span> = 0;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; words.size(); ++i) {
            <span class="org-type">bool</span> <span class="org-variable-name">bfind</span> = <span class="org-constant">true</span>;
            <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; words[i].size(); ++j) {
                <span class="org-type">char</span> <span class="org-variable-name">c</span> = words[i][j];
                <span class="org-keyword">if</span>(has[c] == 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#27809;&#26377;&#20986;&#29616;&#36807;
</span>                    bfind = <span class="org-constant">false</span>;
                    <span class="org-keyword">break</span>;
                }
            }
            <span class="org-keyword">if</span>(bfind) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#35828;&#26126;allowed&#37117;&#22312;words[i]&#20013;
</span>                ++sum;
            }
        }
        <span class="org-keyword">return</span> sum;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:2404f376-f3f6-48e9-bdfb-275c0d12849b" class="outline-5">
<h5 id="h:2404f376-f3f6-48e9-bdfb-275c0d12849b"><a href="#h:2404f376-f3f6-48e9-bdfb-275c0d12849b">16.字符串的分数</a></h5>
<div class="outline-text-5" id="text-h:2404f376-f3f6-48e9-bdfb-275c0d12849b">
<p>
<a href="https://leetcode.cn/problems/score-of-a-string/description/">https://leetcode.cn/problems/score-of-a-string/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#23383;&#31526;&#20018; s &#12290;&#19968;&#20010;&#23383;&#31526;&#20018;&#30340; &#20998;&#25968; &#23450;&#20041;&#20026;&#30456;&#37051;&#23383;&#31526; ASCII &#30721;&#24046;&#20540;&#32477;&#23545;&#20540;&#30340;&#21644;&#12290;

&#35831;&#20320;&#36820;&#22238; s &#30340; &#20998;&#25968; &#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;s = "hello"
&#36755;&#20986;&#65306;13
&#35299;&#37322;&#65306;
s &#20013;&#23383;&#31526;&#30340; ASCII &#30721;&#20998;&#21035;&#20026;&#65306;'h' = 104 &#65292;'e' = 101 &#65292;'l' = 108 &#65292;'o' = 111 &#12290;
&#25152;&#20197; s &#30340;&#20998;&#25968;&#20026; |104 - 101| + |101 - 108| + |108 - 108| + |108 - 111| = 3 + 7 + 0 + 3 = 13 &#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;s = "zaz"
&#36755;&#20986;&#65306;50
&#35299;&#37322;&#65306;
s &#20013;&#23383;&#31526;&#30340; ASCII &#30721;&#20998;&#21035;&#20026;&#65306;'z' = 122 &#65292;'a' = 97 &#12290;
&#25152;&#20197; s &#30340;&#20998;&#25968;&#20026; |122 - 97| + |97 - 122| = 25 + 25 = 50 &#12290;


&#25552;&#31034;&#65306;
2 &lt;= s.length &lt;= 100
s &#21482;&#21253;&#21547;&#23567;&#20889;&#33521;&#25991;&#23383;&#27597;&#12290;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">scoreOfString</span>(<span class="org-type">string</span> <span class="org-variable-name">s</span>) {
        <span class="org-type">int</span> <span class="org-variable-name">ans</span> = 0;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 1; i &lt;s.size(); ++i){
            ans += abs(<span class="org-type">s</span>[i] - s[i-1]); 
        }
        <span class="org-keyword">return</span> ans;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:e99aa254-fa6b-44d5-a6a0-83673857b68b" class="outline-5">
<h5 id="h:e99aa254-fa6b-44d5-a6a0-83673857b68b"><a href="#h:e99aa254-fa6b-44d5-a6a0-83673857b68b">17.TinyURL 的加密与解密</a></h5>
<div class="outline-text-5" id="text-h:e99aa254-fa6b-44d5-a6a0-83673857b68b">
<p>
<a href="https://leetcode.cn/problems/encode-and-decode-tinyurl/">https://leetcode.cn/problems/encode-and-decode-tinyurl/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">TinyURL &#26159;&#19968;&#31181; URL &#31616;&#21270;&#26381;&#21153;&#65292; &#27604;&#22914;&#65306;&#24403;&#20320;&#36755;&#20837;&#19968;&#20010; URL https://leetcode.com/problems/design-tinyurl &#26102;&#65292;
&#23427;&#23558;&#36820;&#22238;&#19968;&#20010;&#31616;&#21270;&#30340;URL http://tinyurl.com/4e9iAk &#12290;&#35831;&#20320;&#35774;&#35745;&#19968;&#20010;&#31867;&#26469;&#21152;&#23494;&#19982;&#35299;&#23494; TinyURL &#12290;

&#21152;&#23494;&#21644;&#35299;&#23494;&#31639;&#27861;&#22914;&#20309;&#35774;&#35745;&#21644;&#36816;&#20316;&#26159;&#27809;&#26377;&#38480;&#21046;&#30340;&#65292;&#20320;&#21482;&#38656;&#35201;&#20445;&#35777;&#19968;&#20010; URL &#21487;&#20197;&#34987;&#21152;&#23494;&#25104;&#19968;&#20010; TinyURL &#65292;
&#24182;&#19988;&#36825;&#20010; TinyURL &#21487;&#20197;&#29992;&#35299;&#23494;&#26041;&#27861;&#24674;&#22797;&#25104;&#21407;&#26412;&#30340; URL &#12290;

&#23454;&#29616; Solution &#31867;&#65306;
Solution() &#21021;&#22987;&#21270; TinyURL &#31995;&#32479;&#23545;&#35937;&#12290;
String encode(String longUrl) &#36820;&#22238; longUrl &#23545;&#24212;&#30340; TinyURL &#12290;
String decode(String shortUrl) &#36820;&#22238; shortUrl &#21407;&#26412;&#30340; URL &#12290;&#39064;&#30446;&#25968;&#25454;&#20445;&#35777;&#32473;&#23450;&#30340; shortUrl &#26159;&#30001;&#21516;&#19968;&#20010;&#31995;&#32479;&#23545;&#35937;&#21152;&#23494;&#30340;&#12290;
 

&#31034;&#20363;&#65306;
&#36755;&#20837;&#65306;url = "https://leetcode.com/problems/design-tinyurl"
&#36755;&#20986;&#65306;"https://leetcode.com/problems/design-tinyurl"
&#35299;&#37322;&#65306;
Solution obj = new Solution();
string tiny = obj.encode(url); // &#36820;&#22238;&#21152;&#23494;&#21518;&#24471;&#21040;&#30340; TinyURL &#12290;
string ans = obj.decode(tiny); // &#36820;&#22238;&#35299;&#23494;&#21518;&#24471;&#21040;&#30340;&#21407;&#26412;&#30340; URL &#12290;
 

&#25552;&#31034;&#65306;
1 &lt;= url.length &lt;= 104
&#39064;&#30446;&#25968;&#25454;&#20445;&#35777; url &#26159;&#19968;&#20010;&#26377;&#25928;&#30340; URL
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:

    <span class="org-comment-delimiter">// </span><span class="org-comment">Encodes a URL to a shortened URL.
</span>    <span class="org-type">string</span> <span class="org-function-name">encode</span>(<span class="org-type">string</span> <span class="org-variable-name">longUrl</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#24322;&#25110;
</span>        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; longUrl.size(); ++i) {
            longUrl[i] ^= 5201314;
        }
        <span class="org-keyword">return</span> longUrl;
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">Decodes a shortened URL to its original URL.
</span>    <span class="org-type">string</span> <span class="org-function-name">decode</span>(<span class="org-type">string</span> <span class="org-variable-name">shortUrl</span>) {
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; shortUrl.size(); ++i) {
            shortUrl[i] ^= 5201314;
        }
        <span class="org-keyword">return</span> shortUrl;
    }
};

<span class="org-comment-delimiter">// </span><span class="org-comment">Your Solution object will be instantiated and called as such:
</span><span class="org-comment-delimiter">// </span><span class="org-comment">Solution solution;
</span><span class="org-comment-delimiter">// </span><span class="org-comment">solution.decode(solution.encode(url));</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-h:c2f75ee4-cc1a-44e6-8bae-a495fb4362d0" class="outline-5">
<h5 id="h:c2f75ee4-cc1a-44e6-8bae-a495fb4362d0"><a href="#h:c2f75ee4-cc1a-44e6-8bae-a495fb4362d0">18.查找包含给定字符的单词</a></h5>
<div class="outline-text-5" id="text-h:c2f75ee4-cc1a-44e6-8bae-a495fb4362d0">
<p>
<a href="https://leetcode.cn/problems/find-words-containing-character/">https://leetcode.cn/problems/find-words-containing-character/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#19979;&#26631;&#20174; 0 &#24320;&#22987;&#30340;&#23383;&#31526;&#20018;&#25968;&#32452; words &#21644;&#19968;&#20010;&#23383;&#31526; x &#12290;

&#35831;&#20320;&#36820;&#22238;&#19968;&#20010; &#19979;&#26631;&#25968;&#32452; &#65292;&#34920;&#31034;&#19979;&#26631;&#22312;&#25968;&#32452;&#20013;&#23545;&#24212;&#30340;&#21333;&#35789;&#21253;&#21547;&#23383;&#31526; x &#12290;

&#27880;&#24847; &#65292;&#36820;&#22238;&#30340;&#25968;&#32452;&#21487;&#20197;&#26159; &#20219;&#24847; &#39034;&#24207;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;words = ["leet","code"], x = "e"
&#36755;&#20986;&#65306;[0,1]
&#35299;&#37322;&#65306;"e" &#22312;&#20004;&#20010;&#21333;&#35789;&#20013;&#37117;&#20986;&#29616;&#20102;&#65306;"leet" &#21644; "code" &#12290;&#25152;&#20197;&#25105;&#20204;&#36820;&#22238;&#19979;&#26631; 0 &#21644; 1 &#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;words = ["abc","bcd","aaaa","cbc"], x = "a"
&#36755;&#20986;&#65306;[0,2]
&#35299;&#37322;&#65306;"a" &#22312; "abc" &#21644; "aaaa" &#20013;&#20986;&#29616;&#20102;&#65292;&#25152;&#20197;&#25105;&#20204;&#36820;&#22238;&#19979;&#26631; 0 &#21644; 2 &#12290;

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;words = ["abc","bcd","aaaa","cbc"], x = "z"
&#36755;&#20986;&#65306;[]
&#35299;&#37322;&#65306;"z" &#27809;&#26377;&#22312;&#20219;&#20309;&#21333;&#35789;&#20013;&#20986;&#29616;&#12290;&#25152;&#20197;&#25105;&#20204;&#36820;&#22238;&#31354;&#25968;&#32452;&#12290;


&#25552;&#31034;&#65306;
1 &lt;= words.length &lt;= 50
1 &lt;= words[i].length &lt;= 50
x &#26159;&#19968;&#20010;&#23567;&#20889;&#33521;&#25991;&#23383;&#27597;&#12290;
words[i] &#21482;&#21253;&#21547;&#23567;&#20889;&#33521;&#25991;&#23383;&#27597;&#12290;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-function-name">findWordsContaining</span>(<span class="org-type">vector</span>&lt;<span class="org-type">string</span>&gt;&amp; <span class="org-variable-name">words</span>, <span class="org-type">char</span> <span class="org-variable-name">x</span>) {
        <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">ans</span>;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; words.size(); ++i) {
            <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; words[i].size(); ++j) {
                <span class="org-keyword">if</span>(words[i][j] == x) {
                    ans.push_back(i);
                    <span class="org-keyword">break</span>;
                }
            }
        }
        <span class="org-keyword">return</span> ans;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:a2a9f98e-9268-4e24-870d-1679e1f25a03" class="outline-5">
<h5 id="h:a2a9f98e-9268-4e24-870d-1679e1f25a03"><a href="#h:a2a9f98e-9268-4e24-870d-1679e1f25a03">19.判别首字母缩略词</a></h5>
<div class="outline-text-5" id="text-h:a2a9f98e-9268-4e24-870d-1679e1f25a03">
<p>
<a href="https://leetcode.cn/problems/check-if-a-string-is-an-acronym-of-words/description/">https://leetcode.cn/problems/check-if-a-string-is-an-acronym-of-words/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#23383;&#31526;&#20018;&#25968;&#32452; words &#21644;&#19968;&#20010;&#23383;&#31526;&#20018; s &#65292;&#35831;&#20320;&#21028;&#26029; s &#26159;&#19981;&#26159; words &#30340; &#39318;&#23383;&#27597;&#32553;&#30053;&#35789; &#12290;

&#22914;&#26524;&#21487;&#20197;&#25353;&#39034;&#24207;&#20018;&#32852; words &#20013;&#27599;&#20010;&#23383;&#31526;&#20018;&#30340;&#31532;&#19968;&#20010;&#23383;&#31526;&#24418;&#25104;&#23383;&#31526;&#20018; s &#65292;&#21017;&#35748;&#20026; s &#26159; words &#30340;&#39318;&#23383;&#27597;&#32553;&#30053;&#35789;&#12290;
&#20363;&#22914;&#65292;"ab" &#21487;&#20197;&#30001; ["apple", "banana"] &#24418;&#25104;&#65292;&#20294;&#26159;&#26080;&#27861;&#20174; ["bear", "aardvark"] &#24418;&#25104;&#12290;

&#22914;&#26524; s &#26159; words &#30340;&#39318;&#23383;&#27597;&#32553;&#30053;&#35789;&#65292;&#36820;&#22238; true &#65307;&#21542;&#21017;&#65292;&#36820;&#22238; false &#12290;


&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;words = ["alice","bob","charlie"], s = "abc"
&#36755;&#20986;&#65306;true
&#35299;&#37322;&#65306;words &#20013; "alice"&#12289;"bob" &#21644; "charlie" &#30340;&#31532;&#19968;&#20010;&#23383;&#31526;&#20998;&#21035;&#26159; 'a'&#12289;'b' &#21644; 'c'&#12290;
&#22240;&#27492;&#65292;s = "abc" &#26159;&#39318;&#23383;&#27597;&#32553;&#30053;&#35789;&#12290; 

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;words = ["an","apple"], s = "a"
&#36755;&#20986;&#65306;false
&#35299;&#37322;&#65306;words &#20013; "an" &#21644; "apple" &#30340;&#31532;&#19968;&#20010;&#23383;&#31526;&#20998;&#21035;&#26159; 'a' &#21644; 'a'&#12290;
&#20018;&#32852;&#36825;&#20123;&#23383;&#31526;&#24418;&#25104;&#30340;&#39318;&#23383;&#27597;&#32553;&#30053;&#35789;&#26159; "aa" &#12290;
&#22240;&#27492;&#65292;s = "a" &#19981;&#26159;&#39318;&#23383;&#27597;&#32553;&#30053;&#35789;&#12290;

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;words = ["never","gonna","give","up","on","you"], s = "ngguoy"
&#36755;&#20986;&#65306;true
&#35299;&#37322;&#65306;&#20018;&#32852;&#25968;&#32452; words &#20013;&#27599;&#20010;&#23383;&#31526;&#20018;&#30340;&#31532;&#19968;&#20010;&#23383;&#31526;&#65292;&#24471;&#21040;&#23383;&#31526;&#20018; "ngguoy" &#12290;
&#22240;&#27492;&#65292;s = "ngguoy" &#26159;&#39318;&#23383;&#27597;&#32553;&#30053;&#35789;&#12290; 

&#25552;&#31034;&#65306;
1 &lt;= words.length &lt;= 100
1 &lt;= words[i].length &lt;= 10
1 &lt;= s.length &lt;= 100
words[i] &#21644; s &#30001;&#23567;&#20889;&#33521;&#25991;&#23383;&#27597;&#32452;&#25104;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">bool</span> <span class="org-function-name">isAcronym</span>(<span class="org-type">vector</span>&lt;<span class="org-type">string</span>&gt;&amp; <span class="org-variable-name">words</span>, <span class="org-type">string</span> <span class="org-variable-name">s</span>) {
       <span class="org-type">string</span> <span class="org-variable-name">t</span>  = <span class="org-string">""</span>;
       <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt;words.size(); ++i) {
        t += words[i][0];
       }
       <span class="org-keyword">return</span> t == s;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:cbdf3b09-dcad-437f-bd91-e2318346b1ac" class="outline-5">
<h5 id="h:cbdf3b09-dcad-437f-bd91-e2318346b1ac"><a href="#h:cbdf3b09-dcad-437f-bd91-e2318346b1ac">20.从字符串中移除星号</a></h5>
<div class="outline-text-5" id="text-h:cbdf3b09-dcad-437f-bd91-e2318346b1ac">
<p>
<a href="https://leetcode.cn/problems/removing-stars-from-a-string/">https://leetcode.cn/problems/removing-stars-from-a-string/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#21253;&#21547;&#33509;&#24178;&#26143;&#21495; * &#30340;&#23383;&#31526;&#20018; s &#12290;

&#22312;&#19968;&#27493;&#25805;&#20316;&#20013;&#65292;&#20320;&#21487;&#20197;&#65306;

&#36873;&#20013; s &#20013;&#30340;&#19968;&#20010;&#26143;&#21495;&#12290;
&#31227;&#38500;&#26143;&#21495; &#24038;&#20391; &#26368;&#36817;&#30340;&#37027;&#20010; &#38750;&#26143;&#21495; &#23383;&#31526;&#65292;&#24182;&#31227;&#38500;&#35813;&#26143;&#21495;&#33258;&#36523;&#12290;
&#36820;&#22238;&#31227;&#38500; &#25152;&#26377; &#26143;&#21495;&#20043;&#21518;&#30340;&#23383;&#31526;&#20018;&#12290;

&#27880;&#24847;&#65306;
&#29983;&#25104;&#30340;&#36755;&#20837;&#20445;&#35777;&#24635;&#26159;&#21487;&#20197;&#25191;&#34892;&#39064;&#38754;&#20013;&#25551;&#36848;&#30340;&#25805;&#20316;&#12290;
&#21487;&#20197;&#35777;&#26126;&#32467;&#26524;&#23383;&#31526;&#20018;&#26159;&#21807;&#19968;&#30340;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;s = "leet**cod*e"
&#36755;&#20986;&#65306;"lecoe"
&#35299;&#37322;&#65306;&#20174;&#24038;&#21040;&#21491;&#25191;&#34892;&#31227;&#38500;&#25805;&#20316;&#65306;
- &#36317;&#31163;&#31532; 1 &#20010;&#26143;&#21495;&#26368;&#36817;&#30340;&#23383;&#31526;&#26159; "leet**cod*e" &#20013;&#30340; 't' &#65292;s &#21464;&#20026; "lee*cod*e" &#12290;
- &#36317;&#31163;&#31532; 2 &#20010;&#26143;&#21495;&#26368;&#36817;&#30340;&#23383;&#31526;&#26159; "lee*cod*e" &#20013;&#30340; 'e' &#65292;s &#21464;&#20026; "lecod*e" &#12290;
- &#36317;&#31163;&#31532; 3 &#20010;&#26143;&#21495;&#26368;&#36817;&#30340;&#23383;&#31526;&#26159; "lecod*e" &#20013;&#30340; 'd' &#65292;s &#21464;&#20026; "lecoe" &#12290;
&#19981;&#23384;&#22312;&#20854;&#20182;&#26143;&#21495;&#65292;&#36820;&#22238; "lecoe" &#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;s = "erase*****"
&#36755;&#20986;&#65306;""
&#35299;&#37322;&#65306;&#25972;&#20010;&#23383;&#31526;&#20018;&#37117;&#20250;&#34987;&#31227;&#38500;&#65292;&#25152;&#20197;&#36820;&#22238;&#31354;&#23383;&#31526;&#20018;&#12290;


&#25552;&#31034;&#65306;
1 &lt;= s.length &lt;= 105
s &#30001;&#23567;&#20889;&#33521;&#25991;&#23383;&#27597;&#21644;&#26143;&#21495; * &#32452;&#25104;
s &#21487;&#20197;&#25191;&#34892;&#19978;&#36848;&#25805;&#20316;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">string</span> <span class="org-function-name">removeStars</span>(<span class="org-type">string</span> <span class="org-variable-name">s</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#32463;&#20856;&#30340;&#26632;&#12290;&#22238;&#28335;&#23601;&#35201;&#24819;&#21040;&#36882;&#24402;&#65292;&#36882;&#24402;&#23601;&#35201;&#24819;&#21040;&#26632;
</span>        <span class="org-type">string</span> <span class="org-variable-name">t</span> = <span class="org-string">""</span>;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; s.size(); ++i) {
            <span class="org-keyword">if</span>(s[i] == <span class="org-string">'*'</span>){
                t.pop_back(); <span class="org-comment-delimiter">// </span><span class="org-comment">string&#20013;pop_back &#23558;&#26368;&#21518;&#19968;&#20010;&#23383;&#31526;&#28165;&#25481;
</span>            }<span class="org-keyword">else</span> {
                t += s[i];
            }
        }
        <span class="org-keyword">return</span> t;
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-h:895e0c84-3df0-4824-ad4b-00d7818f8fb9" class="outline-5">
<h5 id="h:895e0c84-3df0-4824-ad4b-00d7818f8fb9"><a href="#h:895e0c84-3df0-4824-ad4b-00d7818f8fb9">21.删除字符串中的所有相邻重复项</a></h5>
<div class="outline-text-5" id="text-h:895e0c84-3df0-4824-ad4b-00d7818f8fb9">
<p>
<a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20986;&#30001;&#23567;&#20889;&#23383;&#27597;&#32452;&#25104;&#30340;&#23383;&#31526;&#20018; s&#65292;&#37325;&#22797;&#39033;&#21024;&#38500;&#25805;&#20316;&#20250;&#36873;&#25321;&#20004;&#20010;&#30456;&#37051;&#19988;&#30456;&#21516;&#30340;&#23383;&#27597;&#65292;&#24182;&#21024;&#38500;&#23427;&#20204;&#12290;

&#22312; s &#19978;&#21453;&#22797;&#25191;&#34892;&#37325;&#22797;&#39033;&#21024;&#38500;&#25805;&#20316;&#65292;&#30452;&#21040;&#26080;&#27861;&#32487;&#32493;&#21024;&#38500;&#12290;

&#22312;&#23436;&#25104;&#25152;&#26377;&#37325;&#22797;&#39033;&#21024;&#38500;&#25805;&#20316;&#21518;&#36820;&#22238;&#26368;&#32456;&#30340;&#23383;&#31526;&#20018;&#12290;&#31572;&#26696;&#20445;&#35777;&#21807;&#19968;&#12290;


&#31034;&#20363;&#65306;
&#36755;&#20837;&#65306;"abbaca"
&#36755;&#20986;&#65306;"ca"
&#35299;&#37322;&#65306;
&#20363;&#22914;&#65292;&#22312; "abbaca" &#20013;&#65292;&#25105;&#20204;&#21487;&#20197;&#21024;&#38500; "bb" &#30001;&#20110;&#20004;&#23383;&#27597;&#30456;&#37051;&#19988;&#30456;&#21516;&#65292;
&#36825;&#26159;&#27492;&#26102;&#21807;&#19968;&#21487;&#20197;&#25191;&#34892;&#21024;&#38500;&#25805;&#20316;&#30340;&#37325;&#22797;&#39033;&#12290;&#20043;&#21518;&#25105;&#20204;&#24471;&#21040;&#23383;&#31526;&#20018; "aaca"&#65292;
&#20854;&#20013;&#21448;&#21482;&#26377; "aa" &#21487;&#20197;&#25191;&#34892;&#37325;&#22797;&#39033;&#21024;&#38500;&#25805;&#20316;&#65292;&#25152;&#20197;&#26368;&#21518;&#30340;&#23383;&#31526;&#20018;&#20026; "ca"&#12290;

&#25552;&#31034;&#65306;
1 &lt;= s.length &lt;= 105
s &#20165;&#30001;&#23567;&#20889;&#33521;&#25991;&#23383;&#27597;&#32452;&#25104;&#12290;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">string</span> <span class="org-function-name">removeDuplicates</span>(<span class="org-type">string</span> <span class="org-variable-name">s</span>) {
        <span class="org-type">string</span> <span class="org-variable-name">t</span> = <span class="org-string">""</span>;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; s.size(); ++i) {
            <span class="org-keyword">if</span>(t.size() &gt; 0 &amp;&amp; t.back() == s[i]) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;t&#30340;&#26368;&#21518;&#19968;&#20010;&#23383;&#31526;&#21644;s[i]&#30456;&#31561;&#65292;&#21017;&#19968;&#30452;&#21024;&#38500;
</span>                t.pop_back();
            } <span class="org-keyword">else</span> {
                t += s[i];
            }
        }
        <span class="org-keyword">return</span> t;
    }
};
</pre>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="outline-container-h:0e99b34b-323e-4e38-9626-32f71f10813e" class="outline-2">
<h2 id="h:0e99b34b-323e-4e38-9626-32f71f10813e"><a href="#h:0e99b34b-323e-4e38-9626-32f71f10813e">树形结构-树</a></h2>
<div class="outline-text-2" id="text-h:0e99b34b-323e-4e38-9626-32f71f10813e">
</div>
<div id="outline-container-h:9414bebf-d8b2-4324-befb-221cff9f3d30" class="outline-3">
<h3 id="h:9414bebf-d8b2-4324-befb-221cff9f3d30"><a href="#h:9414bebf-d8b2-4324-befb-221cff9f3d30">树（概念篇）</a></h3>
<div class="outline-text-3" id="text-h:9414bebf-d8b2-4324-befb-221cff9f3d30">
<p>
树的增删改查、树的应用
</p>
</div>
<div id="outline-container-h:2972ad0a-0c7e-4a17-9d15-6f86661453d5" class="outline-4">
<h4 id="h:2972ad0a-0c7e-4a17-9d15-6f86661453d5"><a href="#h:2972ad0a-0c7e-4a17-9d15-6f86661453d5">树的概念</a></h4>
<div class="outline-text-4" id="text-h:2972ad0a-0c7e-4a17-9d15-6f86661453d5">
<p>
1、树的定义
</p>

<p>
树是n个结点的有限集合,n=0时为空树。当n大于0的时候,满足如下两个条件:
</p>
<ol class="org-ol">
<li>有且仅有一个特定的结点,称为根结点Root;</li>
<li>当n&gt;1时,其余结点分为m个互不相交的有限集合,T1、T2、T3、&#x2026;Tm,其中每一个TI又是一棵树,并且为Root的子树;</li>
</ol>


<figure id="org98a55d9">
<img src="././images/img-2025102412.png" alt="img-2025102412.png" width="50%">

</figure>

<p>
2、子树的定义
</p>
<ul class="org-ul">
<li>树的定义用到了递归的思想。即树的定义中,还用到了树的概念。</li>
<li>T1和T2就是a的子树,结点d、g、h、i组成的树又是结点b的子树。</li>
</ul>


<figure id="orgeaca833">
<img src="././images/img-2025102413.png" alt="img-2025102413.png" width="50%">

</figure>

<ul class="org-ul">
<li>子树的个数没有限制，但是它们一定是互不相交的，如下图这样的就不是树。即有个环就不是树。</li>
</ul>


<figure id="orgfa078f6">
<img src="././images/img-2025102414.png" alt="img-2025102414.png" width="50%">

</figure>

<p>
3、结点的定义
</p>
<ul class="org-ul">
<li>树的结点包含一个数据域和m个指针域，指针域用来指向它的子子树。结点的分类为:根结点、叶子结点、内部结点。结点拥有子树的个数，被称为结点的度，树中各个结点度的最大值，被称为树的度。</li>

<li>根结点：一棵树的根结点只有一个(图中红色结点)。</li>
<li>叶子结点：度为0的结点被称为叶子结点，叶子结点不能指向任何子树(图中黄色结点)。</li>
<li>内部结点：除了根结点和叶子结点以外的结点，都被称为内部结点(图中蓝色结点)。</li>
</ul>


<figure id="orgbaccca4">
<img src="././images/img-2025102415.png" alt="img-2025102415.png" width="50%">

</figure>

<p>
4、结点间关系
</p>
<ul class="org-ul">
<li>孩子结点：对于某个结点，它的子树的根结点被称为该节点的孩子特点。</li>
</ul>


<figure id="org1ddc39d">
<img src="././images/img-2025102416.png" alt="img-2025102416.png" width="50%">

</figure>

<ul class="org-ul">
<li>父结点：该结点被称为孩子结点的父结点</li>
</ul>


<figure id="org49c2c4e">
<img src="././images/img-2025102417.png" alt="img-2025102417.png" width="50%">

</figure>

<ul class="org-ul">
<li>兄弟结点：同一父结点下的孩子结点互相称为兄弟结点。</li>
</ul>


<figure id="org4f33d56">
<img src="././images/img-2025102418.png" alt="img-2025102418.png" width="50%">

</figure>

<p>
5、树的深度
</p>
<ul class="org-ul">
<li>结点的层次，从根结点开始记为第1层，如果某个结点在第层，则它的子树的根结点在第i+1层。树中结点的最大层次称为树的深度，如图所示，是一棵深度为4的树。</li>
</ul>


<figure id="orgbf2e23c">
<img src="././images/img-2025102419.png" alt="img-2025102419.png" width="50%">

</figure>

<p>
6、森林的定义
</p>
<ul class="org-ul">
<li>森林是m棵互不相交的树的集合。对于树的每个结点而言，其子树集合就是森林，如图所示，b和c两棵子树组成的集合就是一个森林。</li>
</ul>


<figure id="orgeb02e59">
<img src="././images/img-2025102420.png" alt="img-2025102420.png" width="50%">

</figure>
</div>
</div>
<div id="outline-container-h:c8bca72c-1e6a-4714-90d3-6d88ce511d6a" class="outline-4">
<h4 id="h:c8bca72c-1e6a-4714-90d3-6d88ce511d6a"><a href="#h:c8bca72c-1e6a-4714-90d3-6d88ce511d6a">树的数据结构表示</a></h4>
<div class="outline-text-4" id="text-h:c8bca72c-1e6a-4714-90d3-6d88ce511d6a">
<p>
1、结点id
</p>
<ul class="org-ul">
<li>为了方便树数据的读取和修改，我们一般用一个数字来代表树的结点，这个数字就是树的结点id，它是一个唯一id，每个树结点的结点id都是不同的。如图所示，每个结点都有个id作为标识。</li>
</ul>


<figure id="org9a50063">
<img src="././images/img-2025102421.png" alt="img-2025102421.png" width="50%">

</figure>

<p>
2、结点池
</p>
<ul class="org-ul">
<li>在处理树相关的问题时，结点一定是有限的，有时候也一定是确定的，比如一个问题给出的时候，给出一个n个结点的树，这个n必然是有上限的，所以我们可以事先将所有的结点存储在一个顺序表中，然后通过结点id索引的方式，快速获取到对应的结点。而这个顺序表就是结点池。</li>
<li>所以，根据结点id获取结点的这步操作，时间复杂度是0(1)的。</li>
</ul>

<p>
3、结点数据
</p>
<ul class="org-ul">
<li>树的结点数据可以是任意的，这样就可以处理任何情况下的问题，如图所示，树结点的数据的类型是字符类型(a、b、c、d、e、f、g、h、i)。</li>
</ul>


<figure id="org6324eda">
<img src="././images/img-2025102422.png" alt="img-2025102422.png" width="50%">

</figure>

<p>
4、孩子结点列表
</p>
<ul class="org-ul">
<li>每个结点都要保存一个孩子结点列表(叶子结点的孩子结点列表是空的)，注意这里所说的是列表，不是顺序表也不是链表，当然也不是特指Python中的list，而指的就是自然语义上的列表，我们可以用顺序表来实现对孩子结点的存储，也可以用链表来实现对孩子结点的存储。</li>
</ul>

<p>
5、添加树边
</p>
<ul class="org-ul">
<li>如图所示，两个绿色的箭头，分别代表的就是添加两条边(a-&gt;b、a-&gt;c)的过程。添加树边的过程，可以通过树的结点id先获取到实际的树结点，然后将孩子结点添加到父结点的孩子结点列表来完成。</li>
</ul>


<figure id="org284f4de">
<img src="././images/img-2025102423.png" alt="img-2025102423.png" width="50%">

</figure>

<p>
6、树的遍历
</p>
<ul class="org-ul">
<li>树的遍历的引入，让我们开始了解递归的概念，而树本身也是一种递归的数据结构，当然有关遍历的内容，我们会在后续学习算法的时候，进行深入理解，目前只需要明白递归可以用来遍历树这个数据结构即可。</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-h:12d759a5-23eb-401e-aedc-f5ecae20130b" class="outline-3">
<h3 id="h:12d759a5-23eb-401e-aedc-f5ecae20130b"><a href="#h:12d759a5-23eb-401e-aedc-f5ecae20130b">代码篇</a></h3>
<div class="outline-text-3" id="text-h:12d759a5-23eb-401e-aedc-f5ecae20130b">
<div class="org-src-container">
<pre class="src src-cpp">
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">&#30001;&#20110;&#26641;&#35201;&#23384;&#20648;&#23401;&#23376;&#21015;&#34920;&#65292;&#36825;&#20010;&#21015;&#34920;&#29992;&#38142;&#34920;&#26469;&#23454;&#29616;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt; <span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#20013;&#30340;&#20803;&#32032;&#21487;&#20197;&#33258;&#23450;&#20041;
</span><span class="org-keyword">struct</span> <span class="org-type">ListNode</span> {
    <span class="org-type">T</span> <span class="org-variable-name">data</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25968;&#25454;&#22495;
</span>    <span class="org-type">ListNode</span>* <span class="org-variable-name">next</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25351;&#38024;&#22495;
</span>    <span class="org-function-name">ListNode</span>(<span class="org-type">T</span> <span class="org-variable-name">d</span>) : data(d), next(<span class="org-constant">NULL</span>) {}
};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#26641;&#30340;&#32467;&#28857;&#12290;&#26641;&#20013;&#30340;&#32467;&#28857;&#20063;&#26159;&#27169;&#26495;&#21270;&#30340;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-keyword">struct</span> <span class="org-type">TreeNode</span> {
    <span class="org-type">T</span> <span class="org-variable-name">data</span>;
    <span class="org-type">ListNode</span>&lt; <span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* &gt;* <span class="org-variable-name">childrenHead</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#26159;&#20010;&#38142;&#34920;&#65292;&#38142;&#34920;&#20013;&#30340;&#31867;&#22411;&#26159; TreeNode&lt;T&gt;* &#30340;&#25351;&#38024;&#31867;&#22411;&#65292;T&#20195;&#34920;TreeNode&#20013;T&#25968;&#25454;&#22495;&#30340;&#31867;&#22411;
</span>
    <span class="org-function-name">TreeNode</span>() {
        childrenHead = <span class="org-constant">NULL</span>;
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#28155;&#21152;&#23376;&#32467;&#28857;&#20989;&#25968;. &#22836;&#25554;&#27861;
</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#38142;&#25509;&#30340;&#26159;&#25152;&#26377;&#30340;&#23376;&#32467;&#28857;&#65292;&#36825;&#26679;&#22312;&#25554;&#20837;&#26102;&#26159;O(1)&#26102;&#38388;&#22797;&#26434;&#24230;
</span>    <span class="org-type">void</span> <span class="org-function-name">AddChild</span>(<span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">node</span>) {
        <span class="org-type">ListNode</span>&lt; <span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* &gt;* <span class="org-variable-name">childNode</span> = <span class="org-keyword">new</span> ListNode&lt; <span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* &gt;(node);
        <span class="org-keyword">if</span> (childNode == <span class="org-constant">NULL</span>) {
            childrenHead = childNode;
        }
        <span class="org-keyword">else</span> {
            childNode-&gt;next = childrenHead;
            childrenHead = childNode;
        }
    }
};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#26641;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-keyword">class</span> <span class="org-type">Tree</span> {
<span class="org-keyword">private</span>:
    <span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">nodes</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26641;&#32467;&#28857;&#30340;&#32467;&#28857;&#38598;&#21512;&#12290;&#39034;&#24207;&#34920;
</span>    <span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">root</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#26681;&#32467;&#28857;&#25351;&#38024;
</span>
<span class="org-keyword">public</span>:
    <span class="org-function-name">Tree</span>();
    <span class="org-function-name">Tree</span>(<span class="org-type">int</span> <span class="org-variable-name">maxNodes</span>);                     <span class="org-comment-delimiter">// </span><span class="org-comment">&#26500;&#36896;&#20989;&#25968;&#65292;&#25351;&#23450;&#26368;&#22823;&#32467;&#28857;&#25968;
</span>    ~<span class="org-function-name">Tree</span>();                                <span class="org-comment-delimiter">// </span><span class="org-comment">&#26512;&#26500;&#20989;&#25968;
</span>    <span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-function-name">GetTreeNode</span>(<span class="org-type">int</span> <span class="org-variable-name">id</span>);       <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#21040;&#26641;&#32467;&#28857;
</span>    <span class="org-type">void</span> <span class="org-function-name">SetRoot</span>(<span class="org-type">int</span> <span class="org-variable-name">rootId</span>);               <span class="org-comment-delimiter">// </span><span class="org-comment">&#35774;&#32622;&#26681;&#32467;&#28857;
</span>    <span class="org-type">void</span> <span class="org-function-name">AddChild</span>(<span class="org-type">int</span> <span class="org-variable-name">parentId</span>, <span class="org-type">int</span> <span class="org-variable-name">sonId</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#22312;&#29238;&#32467;&#28857;&#21644;&#23376;&#32467;&#28857;&#20043;&#38388;&#36830;&#19968;&#26465;&#36793;
</span>    <span class="org-type">void</span> <span class="org-function-name">AssignData</span>(<span class="org-type">int</span> <span class="org-variable-name">nodeId</span>, <span class="org-type">T</span> <span class="org-variable-name">data</span>);    <span class="org-comment-delimiter">// </span><span class="org-comment">&#35774;&#32622;&#32467;&#28857;id&#30340;&#25968;&#25454;&#22495;
</span>    <span class="org-type">void</span> <span class="org-function-name">Print</span>(<span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">node</span> = <span class="org-constant">NULL</span>);   <span class="org-comment-delimiter">// </span><span class="org-comment">&#25171;&#21360;&#26641;&#65292;&#21033;&#29992;&#28145;&#24230;&#20248;&#20808;&#65292;&#40664;&#35748;&#20026;NULL&#34920;&#31034;&#20174;&#26681;&#32467;&#28857;&#25171;&#21360;
</span>};

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-constant">Tree</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">Tree</span>() {
    nodes = <span class="org-keyword">new</span> <span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;[100001];
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-constant">Tree</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">Tree</span>(<span class="org-type">int</span> <span class="org-variable-name">maxNodes</span>) {
    nodes = <span class="org-keyword">new</span> <span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;[<span class="org-constant">maxNodes</span>];
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-constant">Tree</span>&lt;<span class="org-type">T</span>&gt;::~<span class="org-function-name">Tree</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#19968;&#23450;&#26159;&#26500;&#24314;&#20989;&#25968;&#30340;&#36870;&#25805;&#20316;
</span>    <span class="org-keyword">delete</span>[] nodes;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-constant">Tree</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">GetTreeNode</span>(<span class="org-type">int</span> <span class="org-variable-name">id</span>) {
    <span class="org-keyword">return</span> &amp;nodes[id]; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36820;&#22238;&#23545;&#35937;&#30340;&#22320;&#22336;
</span>}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Tree</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">SetRoot</span>(<span class="org-type">int</span> <span class="org-variable-name">id</span>) {
    root = GetTreeNode(id); <span class="org-comment-delimiter">// </span><span class="org-comment">&#36890;&#36807;id&#21487;&#20197;&#25343;&#21040;&#23454;&#38469;&#30340;&#32467;&#28857;&#65292;&#20877;&#36171;&#20540;&#32473;&#25104;&#21592;&#21464;&#37327;root&#65292;root&#26159;&#26681;&#32467;&#28857;
</span>}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Tree</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">AddChild</span>(<span class="org-type">int</span> <span class="org-variable-name">parentId</span>, <span class="org-type">int</span> <span class="org-variable-name">sonId</span>) {
    <span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">parentNode</span> = GetTreeNode(parentId);
    <span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">sonNode</span> = GetTreeNode(sonId);
    parentNode-&gt;AddChild(sonNode);
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Tree</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">AssignData</span>(<span class="org-type">int</span> <span class="org-variable-name">nodeId</span>, <span class="org-type">T</span> <span class="org-variable-name">data</span>) {
    GetTreeNode(nodeId)-&gt;data = data;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Tree</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">Print</span>(<span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">node</span>) {
    <span class="org-keyword">if</span> (node == <span class="org-constant">NULL</span>) {
        node = root;
    }
    cout &lt;&lt; node-&gt;data;
    <span class="org-type">ListNode</span>&lt; <span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* &gt;* <span class="org-variable-name">tmp</span> = node-&gt;childrenHead;
    <span class="org-keyword">while</span> (tmp) {
        Print(tmp-&gt;data);
        tmp = tmp-&gt;next;
    }
}


<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#35774;&#32622;&#26641;&#30340;&#32467;&#28857;
</span>    <span class="org-type">Tree</span>&lt;<span class="org-type">char</span>&gt; <span class="org-variable-name">T</span>(9);
    T.SetRoot(0);
    T.AssignData(0, <span class="org-string">'a'</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#35774;&#32622;&#25968;&#25454;
</span>    T.AssignData(1, <span class="org-string">'b'</span>);
    T.AssignData(2, <span class="org-string">'c'</span>);
    T.AssignData(3, <span class="org-string">'d'</span>);
    T.AssignData(4, <span class="org-string">'e'</span>);
    T.AssignData(5, <span class="org-string">'f'</span>);
    T.AssignData(6, <span class="org-string">'g'</span>);
    T.AssignData(7, <span class="org-string">'h'</span>);
    T.AssignData(8, <span class="org-string">'i'</span>);

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#35774;&#32622;&#26641;&#30340;&#36793;
</span>    T.AddChild(0, 2); <span class="org-comment-delimiter">// </span><span class="org-comment">&#35774;&#32622;&#36793;
</span>    T.AddChild(0, 1);
    T.AddChild(1, 3);
    T.AddChild(2, 5);
    T.AddChild(2, 4);
    T.AddChild(3, 8);
    T.AddChild(3, 7);
    T.AddChild(3, 6);

    T.Print(); <span class="org-comment-delimiter">// </span><span class="org-comment">abdghicef
</span>    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-h:9959c363-1958-4a29-ad4a-cdf29ee6cbb6" class="outline-3">
<h3 id="h:9959c363-1958-4a29-ad4a-cdf29ee6cbb6"><a href="#h:9959c363-1958-4a29-ad4a-cdf29ee6cbb6">实战篇</a></h3>
<div class="outline-text-3" id="text-h:9959c363-1958-4a29-ad4a-cdf29ee6cbb6">
</div>
<div id="outline-container-h:8fedeeb1-a6e0-487f-9233-c2e119d2b77f" class="outline-4">
<h4 id="h:8fedeeb1-a6e0-487f-9233-c2e119d2b77f"><a href="#h:8fedeeb1-a6e0-487f-9233-c2e119d2b77f">核心代码模式</a></h4>
<div class="outline-text-4" id="text-h:8fedeeb1-a6e0-487f-9233-c2e119d2b77f">
</div>
<div id="outline-container-h:28a5de02-21fc-4cd9-ab30-e47efee39d6b" class="outline-5">
<h5 id="h:28a5de02-21fc-4cd9-ab30-e47efee39d6b"><a href="#h:28a5de02-21fc-4cd9-ab30-e47efee39d6b">1.判断根结点是否等于子结点之和</a></h5>
<div class="outline-text-5" id="text-h:28a5de02-21fc-4cd9-ab30-e47efee39d6b">
<p>
<a href="https://leetcode.cn/problems/root-equals-sum-of-children/">https://leetcode.cn/problems/root-equals-sum-of-children/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010; &#20108;&#21449;&#26641; &#30340;&#26681;&#32467;&#28857; root&#65292;&#35813;&#20108;&#21449;&#26641;&#30001;&#24688;&#22909; 3 &#20010;&#32467;&#28857;&#32452;&#25104;&#65306;&#26681;&#32467;&#28857;&#12289;&#24038;&#23376;&#32467;&#28857;&#21644;&#21491;&#23376;&#32467;&#28857;&#12290;

&#22914;&#26524;&#26681;&#32467;&#28857;&#20540;&#31561;&#20110;&#20004;&#20010;&#23376;&#32467;&#28857;&#20540;&#20043;&#21644;&#65292;&#36820;&#22238; true &#65292;&#21542;&#21017;&#36820;&#22238; false &#12290;


&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;root = [10,4,6]
&#36755;&#20986;&#65306;true
&#35299;&#37322;&#65306;&#26681;&#32467;&#28857;&#12289;&#24038;&#23376;&#32467;&#28857;&#21644;&#21491;&#23376;&#32467;&#28857;&#30340;&#20540;&#20998;&#21035;&#26159; 10 &#12289;4 &#21644; 6 &#12290;
&#30001;&#20110; 10 &#31561;&#20110; 4 + 6 &#65292;&#22240;&#27492;&#36820;&#22238; true &#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;root = [5,3,1]
&#36755;&#20986;&#65306;false
&#35299;&#37322;&#65306;&#26681;&#32467;&#28857;&#12289;&#24038;&#23376;&#32467;&#28857;&#21644;&#21491;&#23376;&#32467;&#28857;&#30340;&#20540;&#20998;&#21035;&#26159; 5 &#12289;3 &#21644; 1 &#12290;
&#30001;&#20110; 5 &#19981;&#31561;&#20110; 3 + 1 &#65292;&#22240;&#27492;&#36820;&#22238; false &#12290;

&#25552;&#31034;&#65306;
&#26641;&#21482;&#21253;&#21547;&#26681;&#32467;&#28857;&#12289;&#24038;&#23376;&#32467;&#28857;&#21644;&#21491;&#23376;&#32467;&#28857;
-100 &lt;= Node.val &lt;= 100
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">bool</span> <span class="org-function-name">checkTree</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-keyword">return</span> root-&gt;val ==
        root-&gt;left-&gt;val + root-&gt;right-&gt;val;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:3ed69a04-fd21-40d9-913e-18b39195556b" class="outline-5">
<h5 id="h:3ed69a04-fd21-40d9-913e-18b39195556b"><a href="#h:3ed69a04-fd21-40d9-913e-18b39195556b">2.二叉树的最大深度</a></h5>
<div class="outline-text-5" id="text-h:3ed69a04-fd21-40d9-913e-18b39195556b">
<p>
<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#23450;&#19968;&#20010;&#20108;&#21449;&#26641; root &#65292;&#36820;&#22238;&#20854;&#26368;&#22823;&#28145;&#24230;&#12290;

&#20108;&#21449;&#26641;&#30340; &#26368;&#22823;&#28145;&#24230; &#26159;&#25351;&#20174;&#26681;&#33410;&#28857;&#21040;&#26368;&#36828;&#21494;&#23376;&#33410;&#28857;&#30340;&#26368;&#38271;&#36335;&#24452;&#19978;&#30340;&#33410;&#28857;&#25968;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;root = [3,9,20,null,null,15,7]
&#36755;&#20986;&#65306;3

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;root = [1,null,2]
&#36755;&#20986;&#65306;2

&#25552;&#31034;&#65306;
&#26641;&#20013;&#33410;&#28857;&#30340;&#25968;&#37327;&#22312; [0, 104] &#21306;&#38388;&#20869;&#12290;
-100 &lt;= Node.val &lt;= 100
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">maxDepth</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#26368;&#22823;&#28145;&#24230;&#65306;&#20174;&#26681;&#32467;&#28857;&#21040;&#26368;&#36828;&#21494;&#23376;&#32467;&#28857;&#30340;&#32467;&#28857;&#25968;
</span>        <span class="org-keyword">if</span> (root == <span class="org-constant">NULL</span>) {
            <span class="org-keyword">return</span> 0;
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#24038;&#36793;&#26368;&#22823;&#28145;&#24230;&#19982;&#21491;&#36793;&#26368;&#22823;&#28145;&#24230;&#27604;&#36739;
</span>        <span class="org-type">int</span> <span class="org-variable-name">lmax</span> = maxDepth(root-&gt;left);
        <span class="org-type">int</span> <span class="org-variable-name">rmax</span> = maxDepth(root-&gt;right);
        <span class="org-keyword">return</span> 1 + max(lmax, rmax);
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:507e24a3-5157-4029-b067-2f79c7dcb33c" class="outline-5">
<h5 id="h:507e24a3-5157-4029-b067-2f79c7dcb33c"><a href="#h:507e24a3-5157-4029-b067-2f79c7dcb33c">3.计算二叉树的深度</a></h5>
<div class="outline-text-5" id="text-h:507e24a3-5157-4029-b067-2f79c7dcb33c">
<p>
<a href="https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/description/">https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#26576;&#20844;&#21496;&#26550;&#26500;&#20197;&#20108;&#21449;&#26641;&#24418;&#24335;&#35760;&#24405;&#65292;&#35831;&#36820;&#22238;&#35813;&#20844;&#21496;&#30340;&#23618;&#32423;&#25968;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;root = [1, 2, 2, 3, null, null, 5, 4, null, null, 4]
&#36755;&#20986;: 4
&#35299;&#37322;: &#19978;&#38754;&#31034;&#20363;&#20013;&#30340;&#20108;&#21449;&#26641;&#30340;&#26368;&#22823;&#28145;&#24230;&#26159; 4&#65292;
&#27839;&#30528;&#36335;&#24452; 1 -&gt; 2 -&gt; 3 -&gt; 4 &#25110; 1 -&gt; 2 -&gt; 5 -&gt; 4 &#21040;&#36798;&#21494;&#33410;&#28857;&#30340;&#26368;&#38271;&#36335;&#24452;&#19978;&#26377; 4 &#20010;&#33410;&#28857;&#12290;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-type">int</span> <span class="org-variable-name">maxDepth</span>;
    <span class="org-type">void</span> <span class="org-function-name">dfs</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>, <span class="org-type">int</span> <span class="org-variable-name">depth</span>) {
        <span class="org-keyword">if</span>(depth &gt; maxDepth){
            maxDepth = depth;
        }
        <span class="org-keyword">if</span>(root) {
            dfs(root-&gt;left, depth+1);
            dfs(root-&gt;right, depth+1);
        }
    }
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">calculateDepth</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        maxDepth = 0; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#21270;&#20026;0
</span>        dfs(root, 0);
        <span class="org-keyword">return</span> maxDepth;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:63849cd6-0228-41d2-9846-b29c5863cbd7" class="outline-5">
<h5 id="h:63849cd6-0228-41d2-9846-b29c5863cbd7"><a href="#h:63849cd6-0228-41d2-9846-b29c5863cbd7">4.计算布尔二叉树的值</a></h5>
<div class="outline-text-5" id="text-h:63849cd6-0228-41d2-9846-b29c5863cbd7">
<p>
<a href="https://leetcode.cn/problems/evaluate-boolean-binary-tree/">https://leetcode.cn/problems/evaluate-boolean-binary-tree/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#26869; &#23436;&#25972;&#20108;&#21449;&#26641; &#30340;&#26681;&#65292;&#36825;&#26869;&#26641;&#26377;&#20197;&#19979;&#29305;&#24449;&#65306;

&#21494;&#23376;&#33410;&#28857; &#35201;&#20040;&#20540;&#20026; 0 &#35201;&#20040;&#20540;&#20026; 1 &#65292;&#20854;&#20013; 0 &#34920;&#31034; False &#65292;1 &#34920;&#31034; True &#12290;
&#38750;&#21494;&#23376;&#33410;&#28857; &#35201;&#20040;&#20540;&#20026; 2 &#35201;&#20040;&#20540;&#20026; 3 &#65292;&#20854;&#20013; 2 &#34920;&#31034;&#36923;&#36753;&#25110; OR &#65292;3 &#34920;&#31034;&#36923;&#36753;&#19982; AND &#12290;
&#35745;&#31639; &#19968;&#20010;&#33410;&#28857;&#30340;&#20540;&#26041;&#24335;&#22914;&#19979;&#65306;

&#22914;&#26524;&#33410;&#28857;&#26159;&#20010;&#21494;&#23376;&#33410;&#28857;&#65292;&#37027;&#20040;&#33410;&#28857;&#30340; &#20540; &#20026;&#23427;&#26412;&#36523;&#65292;&#21363; True &#25110;&#32773; False &#12290;
&#21542;&#21017;&#65292;&#35745;&#31639; &#20004;&#20010;&#23401;&#23376;&#30340;&#33410;&#28857;&#20540;&#65292;&#28982;&#21518;&#23558;&#35813;&#33410;&#28857;&#30340;&#36816;&#31639;&#31526;&#23545;&#20004;&#20010;&#23401;&#23376;&#20540;&#36827;&#34892; &#36816;&#31639; &#12290;
&#36820;&#22238;&#26681;&#33410;&#28857; root &#30340;&#24067;&#23572;&#36816;&#31639;&#20540;&#12290;

&#23436;&#25972;&#20108;&#21449;&#26641; &#26159;&#27599;&#20010;&#33410;&#28857;&#26377; 0 &#20010;&#25110;&#32773; 2 &#20010;&#23401;&#23376;&#30340;&#20108;&#21449;&#26641;&#12290;

&#21494;&#23376;&#33410;&#28857; &#26159;&#27809;&#26377;&#23401;&#23376;&#30340;&#33410;&#28857;&#12290;
 

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;root = [2,1,3,null,null,0,1]
&#36755;&#20986;&#65306;true
&#35299;&#37322;&#65306;&#19978;&#22270;&#23637;&#31034;&#20102;&#35745;&#31639;&#36807;&#31243;&#12290;
AND &#19982;&#36816;&#31639;&#33410;&#28857;&#30340;&#20540;&#20026; False AND True = False &#12290;
OR &#36816;&#31639;&#33410;&#28857;&#30340;&#20540;&#20026; True OR False = True &#12290;
&#26681;&#33410;&#28857;&#30340;&#20540;&#20026; True &#65292;&#25152;&#20197;&#25105;&#20204;&#36820;&#22238; true &#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;root = [0]
&#36755;&#20986;&#65306;false
&#35299;&#37322;&#65306;&#26681;&#33410;&#28857;&#26159;&#21494;&#23376;&#33410;&#28857;&#65292;&#19988;&#20540;&#20026; false&#65292;&#25152;&#20197;&#25105;&#20204;&#36820;&#22238; false &#12290;

&#25552;&#31034;&#65306;
&#26641;&#20013;&#33410;&#28857;&#25968;&#30446;&#22312; [1, 1000] &#20043;&#38388;&#12290;
0 &lt;= Node.val &lt;= 3
&#27599;&#20010;&#33410;&#28857;&#30340;&#23401;&#23376;&#25968;&#20026; 0 &#25110; 2 &#12290;
&#21494;&#23376;&#33410;&#28857;&#30340;&#20540;&#20026; 0 &#25110; 1 &#12290;
&#38750;&#21494;&#23376;&#33410;&#28857;&#30340;&#20540;&#20026; 2 &#25110; 3 &#12290;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">bool</span> <span class="org-function-name">evaluateTree</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#36923;&#36753;&#25110; OR: &#21482;&#26377;&#24403;&#20457;&#20010;&#20540;&#37117;&#20026;&#20551;&#26102;&#25165;&#20026;&#20551;&#65307;&#36923;&#36753;&#19982; AND&#65306;&#21482;&#26377;&#24403;&#20457;&#20010;&#20540;&#37117;&#20026;&#30495;&#26102;&#25165;&#20026;&#30495;
</span>        <span class="org-keyword">if</span>(root == <span class="org-constant">NULL</span>) {
            <span class="org-keyword">return</span> <span class="org-constant">false</span>;
        }
        <span class="org-keyword">if</span>(root-&gt;val == 0 || root-&gt;val == 1) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#34920;&#31034;&#19968;&#23450;&#26159;&#21494;&#23376;&#32467;&#28857;
</span>            <span class="org-keyword">return</span> root-&gt;val == 1;
        }
        <span class="org-keyword">if</span>(root-&gt;val == 2) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#38750;&#21494;&#23376;&#33410;&#28857;
</span>            <span class="org-keyword">return</span> evaluateTree(root-&gt;left) || evaluateTree(root-&gt;right); 
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">root-&gt;val == 3
</span>        <span class="org-keyword">return</span> evaluateTree(root-&gt;left) &amp;&amp; evaluateTree(root-&gt;right);    
    }
};
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-h:9482bf2f-0bef-49ee-bca6-a06fe60adcb4" class="outline-3">
<h3 id="h:9482bf2f-0bef-49ee-bca6-a06fe60adcb4"><a href="#h:9482bf2f-0bef-49ee-bca6-a06fe60adcb4">应用篇</a></h3>
<div class="outline-text-3" id="text-h:9482bf2f-0bef-49ee-bca6-a06fe60adcb4">
</div>
<div id="outline-container-h:43ce7635-1fda-4e85-a61f-fa91609025a6" class="outline-4">
<h4 id="h:43ce7635-1fda-4e85-a61f-fa91609025a6"><a href="#h:43ce7635-1fda-4e85-a61f-fa91609025a6">剑网三中的应用</a></h4>
<div class="outline-text-4" id="text-h:43ce7635-1fda-4e85-a61f-fa91609025a6">
<p>
技能按键，把技能进行数据归类。
</p>

<div class="org-src-container">
<pre class="src src-text">- &#27743;&#28246;&#25216;&#33021;
  - &#27743;&#28246;&#36731;&#21151;
    - &#21518;&#25764;
    - &#25206;&#25671;&#30452;&#19978;
    - &#20940;&#23477;&#25597;&#32988;
    - &#29814;&#21488;&#26517;&#40548;
    - &#36814;&#39118;&#21152;&#28010;
  - &#28151;&#20803;&#27668;&#21151;
    - &#33258;&#32477;&#32463;&#33033;
    - &#20256;&#21151;
  - &#22522;&#30784;&#25307;&#24335;
    - &#22871;&#39532;
    - &#39569;&#24481;
    - &#21452;&#20154;&#21516;&#39569;
    - &#19979;&#39532;&#29301;&#34892;
    - &#31070;&#34892;&#21315;&#37324;
  - &#38450;&#36523;&#27494;&#33402;
    - &#22823;&#28448;&#20992;&#27861;
    - &#25171;&#22352;
    - &#34425;&#27668;&#38271;&#31354;
- &#38376;&#27966;&#25216;&#33021;
  - &#36196;&#26085;&#36718;
  - &#28872;&#26085;&#26025;
  - &#26080;&#26126;&#39746;&#38145;
  - &#20809;&#26126;&#30456;
- &#30334;&#25112;
  - &#19968;&#20992;&#28014;&#23576;
  - &#24040;&#29503;&#21128;&#23665;
</pre>
</div>

<p>
手游（端游技能移动到手机上）
</p>
<ul class="org-ul">
<li>基础招工只能拖2个</li>
<li>防身武艺只能拖1个</li>
</ul>

<p>
任意两点间有且仅有一条（简单）路径，就是我们数据结构中的树。
</p>
</div>
</div>
</div>
</section>
<section id="outline-container-h:356ea822-92bb-4659-a1c0-b2ddd39f2845" class="outline-2">
<h2 id="h:356ea822-92bb-4659-a1c0-b2ddd39f2845"><a href="#h:356ea822-92bb-4659-a1c0-b2ddd39f2845">树形结构-二叉树</a></h2>
<div class="outline-text-2" id="text-h:356ea822-92bb-4659-a1c0-b2ddd39f2845">
</div>
<div id="outline-container-h:7d50965d-1ca5-456d-9fbb-a51b09475cc0" class="outline-3">
<h3 id="h:7d50965d-1ca5-456d-9fbb-a51b09475cc0"><a href="#h:7d50965d-1ca5-456d-9fbb-a51b09475cc0">二叉树（概念篇）</a></h3>
<div class="outline-text-3" id="text-h:7d50965d-1ca5-456d-9fbb-a51b09475cc0">
<p>
二叉树的增删改查、二叉树的遍历、二叉树的应用
</p>
</div>
<div id="outline-container-h:d05a6b4a-970b-41f5-836b-89d634e86e9d" class="outline-4">
<h4 id="h:d05a6b4a-970b-41f5-836b-89d634e86e9d"><a href="#h:d05a6b4a-970b-41f5-836b-89d634e86e9d">二叉树的定义</a></h4>
<div class="outline-text-4" id="text-h:d05a6b4a-970b-41f5-836b-89d634e86e9d">
<p>
二叉树是n(n&gt;=0)个结点组成的有限集合，这个集合要么是空集(当n等于0时)，要么是由一个根结点和两棵互不相交的二叉树组成。其中这两棵互不相交的二叉树被称为根结点的左子树和右子树。
</p>

<p>
如图所示，2是1的左子树，3是1的右子树;同时，4和5分别是2的左右子树，6和7分别是3的左右子树。
</p>


<figure id="org5504388">
<img src="././images/img-2025102424.png" alt="img-2025102424.png" width="50%">

</figure>
</div>
</div>
<div id="outline-container-h:b170369d-1798-4ea6-9f1d-720f37bca7d7" class="outline-4">
<h4 id="h:b170369d-1798-4ea6-9f1d-720f37bca7d7"><a href="#h:b170369d-1798-4ea6-9f1d-720f37bca7d7">二叉树的特点</a></h4>
<div class="outline-text-4" id="text-h:b170369d-1798-4ea6-9f1d-720f37bca7d7">
<p>
二叉树是一种树，它有如下几个特征:
</p>
<ol class="org-ol">
<li>每个结点最多二棵子树，即每个结点的孩子结点个数为0、1、2。</li>
<li>这两棵子树是有顺序的，分别叫:左子树和右子树，就像方左手和右手一样，是不能颠倒的。</li>
<li>如果只有一棵子树的情况，也需要区分顺序，如图所示:</li>
</ol>


<figure id="org5f5e8c4">
<img src="././images/img-2025102425.png" alt="img-2025102425.png" width="30%">

<figcaption><span class="figure-number">Figure 1: </span>b为a的左子树</figcaption>
</figure>



<figure id="org6dc3abc">
<img src="././images/img-2025102426.png" alt="img-2025102426.png" width="30%">

<figcaption><span class="figure-number">Figure 2: </span>c为a的右子树</figcaption>
</figure>
</div>
</div>
<div id="outline-container-h:28d3294f-fe86-4c1a-990b-f39273c75f87" class="outline-4">
<h4 id="h:28d3294f-fe86-4c1a-990b-f39273c75f87"><a href="#h:28d3294f-fe86-4c1a-990b-f39273c75f87">特殊二叉树</a></h4>
<div class="outline-text-4" id="text-h:28d3294f-fe86-4c1a-990b-f39273c75f87">
<p>
1、斜树
</p>
<ul class="org-ul">
<li>所有结点都只有左子树的二叉树，被称为左斜树，像这样:</li>
</ul>


<figure id="orge2dfa23">
<img src="././images/img_20251024_143727.png" alt="img_20251024_143727.png" width="50%">

</figure>

<ul class="org-ul">
<li>所有结点都只有右子树的二叉树，被称为右斜树，像这样:</li>
</ul>


<figure id="orgf410328">
<img src="././images/img_20251024_143935.png" alt="img_20251024_143935.png" width="50%">

</figure>

<p>
斜树有点类似线性表，所以线性表可以理解为一种特殊形式的树。
</p>

<p>
2、满二叉树
</p>
<ul class="org-ul">
<li>对于一棵二叉树，如果它的所有根结点和内部结点都存在左右子树，且所有叶子结点都在同一层，这样的树就是满二叉树，像这样:</li>
</ul>


<figure id="org26f12e1">
<img src="././images/img_20251024_144238.png" alt="img_20251024_144238.png" width="50%">

</figure>

<p>
满二叉树有如下几个特点:
</p>
<ol class="org-ol">
<li>叶子结点一定在最后一层</li>
<li>非叶子结点的度为2</li>
<li>深度相同的二叉树中，满二叉树的结点个数最多，为2^h-1(其中h代表树的深度)</li>
</ol>

<p>
3、完全二叉树
</p>
<ul class="org-ul">
<li>对一棵具有n个结点的二叉树，按照层序进行编号，如果编号i的结点和同样深度的满二叉树中的编号i的结点在二叉树中，位置完全相同则被称为 完全二叉树。</li>
</ul>


<figure id="orgd0f8d3b">
<img src="././images/img_20251024_144552.png" alt="img_20251024_144552.png" width="50%">

</figure>

<p>
满二叉树一定是完全二叉树，而完全二叉树则不一定是满二叉树，完全二叉树有如下几个特点:
</p>
<ol class="org-ol">
<li>叶子结点只能出现在最下面两层</li>
<li>最下层的叶子结点，一定是集中在左边的连续位置，倒数第二层如果有叶子结点一定集中在右边的连续位置</li>
<li>如果某个结点度为1，则只有左子树，即不存在只有右子树的情况</li>
<li>同样结点数的二叉树，完全二叉树的深度最小如下图所示，就不是一棵完全二叉树，因为5号结点没有右子树，但是6号结点是有左子树的，不满足上述第2点。</li>
</ol>



<figure id="orgec7e853">
<img src="././images/img_20251024_144745.png" alt="img_20251024_144745.png" width="50%">

</figure>
</div>
</div>
<div id="outline-container-h:484bb238-c2fd-40a8-8381-dcc627984160" class="outline-4">
<h4 id="h:484bb238-c2fd-40a8-8381-dcc627984160"><a href="#h:484bb238-c2fd-40a8-8381-dcc627984160">二叉树的性质</a></h4>
<div class="outline-text-4" id="text-h:484bb238-c2fd-40a8-8381-dcc627984160">
<p>
以下性质对理解二叉树有很好的帮助，可以尝试自行证明。或许在后续遇到贪心相关问题时，需要用到这些证明。
</p>
<ol class="org-ol">
<li>二叉树的第 i(i&gt;=1)层上最多2^(i-1)个结点;</li>
<li>深度为h的二叉树至多2^h-1个结点;</li>
<li>n个结点的完全二叉树的深度为floor(log2n)+1(其中floor(x)代表对×取下整)</li>
</ol>
</div>
</div>
<div id="outline-container-h:034d398f-e950-46a4-8be5-30061235bb3a" class="outline-4">
<h4 id="h:034d398f-e950-46a4-8be5-30061235bb3a"><a href="#h:034d398f-e950-46a4-8be5-30061235bb3a">二叉树的顺序存储</a></h4>
<div class="outline-text-4" id="text-h:034d398f-e950-46a4-8be5-30061235bb3a">
<p>
二叉树的顺序存储就是指:利用顺序表对二叉树进行存储。结点的的存储位置即顺序表的索引，能够体现结点之间的逻辑关系比如父结点和孩子结点之间的关系，左右兄弟结点之间的关系等等。
</p>

<p>
1、完全二叉树
</p>
<ul class="org-ul">
<li>来看一棵完全二叉树，我们对它进行如下存储:</li>
</ul>


<figure id="org40f1896">
<img src="././images/img_20251024_144947.png" alt="img_20251024_144947.png" width="50%">

</figure>

<p>
编号代表了顺序表索引的绝对位置，映射后如下
</p>
<div class="org-src-container">
<pre class="src src-text">&#19979;&#26631;  0 1 2 3 4 5 6 7 8 9 10 11 12
data  - a b c d e f g h i j  k  l
</pre>
</div>

<p>
这里为了方便，我们把顺序表索引为0的位置给留空了。
</p>

<p>
这样一来，当知道某个结点在顺序表中的索引x，就可以知道它左右儿子的索引分别为2x和2x+1。反之，当知道某个结点的索引x，也能知道它父结点的索引为floor(x/2)。
</p>

<p>
2、非完全二叉树
</p>
<ul class="org-ul">
<li>对于非完全二叉树，只需要将对应不存在的结点设置为空即可</li>
</ul>


<figure id="org62d2484">
<img src="././images/img_20251024_145221.png" alt="img_20251024_145221.png" width="50%">

</figure>

<p>
编号代表了顺序表索引的绝对位置，映射后如下
</p>
<div class="org-src-container">
<pre class="src src-text">&#19979;&#26631; 0 1 2 3 4 5 6 7 8 9 10 11 12
data - a b c d e f g - - -  k  l
</pre>
</div>

<p>
3、稀疏二叉树
</p>
<ul class="org-ul">
<li>对于较为稀疏的二叉树，就会有如下情况出现。这时候如果用这种方式进行存储，就比较浪费内存了</li>
</ul>


<figure id="orgfdd1e87">
<img src="././images/img_20251024_145422.png" alt="img_20251024_145422.png" width="50%">

</figure>

<p>
编号代表了顺序表索引的绝对位置，映射后如下:
</p>
<div class="org-src-container">
<pre class="src src-text">&#19979;&#26631; 0 1 2 3 4 5 6 7 8 9 10 11 12
data - a b c d - - g h - -  -  -
</pre>
</div>

<p>
这种情况下，为了提升内存利用率，我们可以采用链表进行存储。
</p>
</div>
</div>
<div id="outline-container-h:5fb6ec6e-0dc5-4002-a7c8-0b4d233cfa22" class="outline-4">
<h4 id="h:5fb6ec6e-0dc5-4002-a7c8-0b4d233cfa22"><a href="#h:5fb6ec6e-0dc5-4002-a7c8-0b4d233cfa22">二叉树的链式存储</a></h4>
<div class="outline-text-4" id="text-h:5fb6ec6e-0dc5-4002-a7c8-0b4d233cfa22">
<p>
二叉树每个结点至多有两个孩子结点，所以对于每个结点设置一个数据域(data)和两个指针域(left和right)即可。指针域分别指向左孩子结点和右孩子结点。
</p>


<figure id="org7770933">
<img src="././images/img-2025102427.png" alt="img-2025102427.png" width="50%">

</figure>
</div>
</div>
<div id="outline-container-h:b73cd568-c769-42e3-a77e-caf1a8ac0f4d" class="outline-4">
<h4 id="h:b73cd568-c769-42e3-a77e-caf1a8ac0f4d"><a href="#h:b73cd568-c769-42e3-a77e-caf1a8ac0f4d">二叉树的遍历概念</a></h4>
<div class="outline-text-4" id="text-h:b73cd568-c769-42e3-a77e-caf1a8ac0f4d">
<p>
二叉树的遍历是指从根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点访问一次且仅被访问一次。
</p>

<p>
对于线性表的遍历，要么从头到尾，要么从尾到头，遍历方式较为单纯。但是树不一样，它的每个结点都有可能有两个孩子结点，所以遍历的顺序面临着不同的选择。
</p>

<p>
二叉树的常用遍历方法，有以下四种:前序遍历、中序遍历、后序遍历、层序遍历。
</p>


<figure id="orgabc0b2f">
<img src="././images/img_20251024_150023.png" alt="img_20251024_150023.png" width="50%">

</figure>

<div class="org-src-container">
<pre class="src src-text">&#19979;&#26631; 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
data - a b c d - e f g h -  -  -  -  i
</pre>
</div>
</div>
</div>
<div id="outline-container-h:2acc94ff-3e29-4df9-88f0-515beab0310b" class="outline-4">
<h4 id="h:2acc94ff-3e29-4df9-88f0-515beab0310b"><a href="#h:2acc94ff-3e29-4df9-88f0-515beab0310b">二叉树的前序遍历</a></h4>
<div class="outline-text-4" id="text-h:2acc94ff-3e29-4df9-88f0-515beab0310b">
<p>
如果二叉树为空则直接返回，否则先访问根结点，再递归前序遍遍历左子树，再递归前序遍历右子树。前序遍历的结果如下:abdghcefi
</p>


<figure id="org2de1e92">
<img src="././images/img_20251024_151438.png" alt="img_20251024_151438.png" width="50%">

</figure>
</div>
</div>
<div id="outline-container-h:d1644b56-d867-4f4f-a57b-77065bae1f96" class="outline-4">
<h4 id="h:d1644b56-d867-4f4f-a57b-77065bae1f96"><a href="#h:d1644b56-d867-4f4f-a57b-77065bae1f96">二叉树的中序遍历</a></h4>
<div class="outline-text-4" id="text-h:d1644b56-d867-4f4f-a57b-77065bae1f96">
<p>
如果二叉树为空则直接返回，否则先递归中序遍历左子树，再访问根结点，再递归中序遍历右子树。中序遍历的结果如下:gdhbaecif。
</p>


<figure id="orgb2a64df">
<img src="././images/img_20251024_151731.png" alt="img_20251024_151731.png" width="50%">

</figure>
</div>
</div>
<div id="outline-container-h:ac8cde68-7c60-4aad-ae18-236ddf1a1c8a" class="outline-4">
<h4 id="h:ac8cde68-7c60-4aad-ae18-236ddf1a1c8a"><a href="#h:ac8cde68-7c60-4aad-ae18-236ddf1a1c8a">二叉树的后序遍历</a></h4>
<div class="outline-text-4" id="text-h:ac8cde68-7c60-4aad-ae18-236ddf1a1c8a">
<p>
如果二叉树为空则直接返回，否则先递归后遍历左子树，再递归后序遍历右子树，再访问根结点。后序遍历的结果如下:ghdbeifca。
</p>


<figure id="org6ceb8f6">
<img src="././images/img_20251024_151859.png" alt="img_20251024_151859.png" width="50%">

</figure>
</div>
</div>
<div id="outline-container-h:6241171f-2b8d-417e-8ec4-970af3b85c18" class="outline-4">
<h4 id="h:6241171f-2b8d-417e-8ec4-970af3b85c18"><a href="#h:6241171f-2b8d-417e-8ec4-970af3b85c18">二叉树的层序遍历</a></h4>
<div class="outline-text-4" id="text-h:6241171f-2b8d-417e-8ec4-970af3b85c18">
<p>
如果二叉树为空直接返回，否则依次从树的第一层开始，从上至下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。图中二叉树层序遍历的结果为:abcdefghi。
</p>

<figure id="org511b38a">
<img src="././images/img-2025102428.png" alt="img-2025102428.png" width="50%">

</figure>
</div>
</div>
</div>
<div id="outline-container-h:ffeda76c-fc39-4701-885d-0b7bc2029feb" class="outline-3">
<h3 id="h:ffeda76c-fc39-4701-885d-0b7bc2029feb"><a href="#h:ffeda76c-fc39-4701-885d-0b7bc2029feb">代码篇</a></h3>
<div class="outline-text-3" id="text-h:ffeda76c-fc39-4701-885d-0b7bc2029feb">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">&#20108;&#21449;&#26641;&#32467;&#28857;&#30340;&#23450;&#20041;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-keyword">struct</span> <span class="org-type">TreeNode</span> {
    <span class="org-type">T</span> <span class="org-variable-name">val</span>;           <span class="org-comment-delimiter">// </span><span class="org-comment">&#23384;&#20648;&#26641;&#30340;&#32467;&#28857;&#30340;&#20540;
</span>    <span class="org-type">TreeNode</span>* <span class="org-variable-name">left</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#25351;&#21521;&#24038;&#23376;&#32467;&#28857;&#30340;&#25351;&#38024;
</span>    <span class="org-type">TreeNode</span>* <span class="org-variable-name">right</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25351;&#21521;&#21491;&#23376;&#32467;&#28857;&#30340;&#25351;&#38024;
</span>    <span class="org-function-name">TreeNode</span>() : val(0), left(<span class="org-constant">NULL</span>), right(<span class="org-constant">NULL</span>) {}
    <span class="org-function-name">TreeNode</span>(<span class="org-type">T</span> <span class="org-variable-name">x</span>) : val(x), left(<span class="org-constant">NULL</span>), right(<span class="org-constant">NULL</span>) {}
};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#20108;&#21449;&#26641;&#31867;&#30340;&#23450;&#20041;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-keyword">class</span> <span class="org-type">Tree</span> {
<span class="org-keyword">private</span>:
    <span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">nodes</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#34920;&#31034;&#25152;&#26377;&#32467;&#28857;&#30340;&#32467;&#28857;&#27744;
</span>    <span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">root</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#26681;&#32467;&#28857;
</span>    <span class="org-type">size_t</span> <span class="org-variable-name">nodeSize</span>;    <span class="org-comment-delimiter">// </span><span class="org-comment">&#24635;&#32467;&#28857;&#25968;
</span>
    <span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-function-name">Create</span>(<span class="org-type">T</span> <span class="org-variable-name">a</span>[], <span class="org-type">int</span> <span class="org-variable-name">size</span>, <span class="org-type">int</span> <span class="org-variable-name">nodeId</span>, <span class="org-type">T</span> <span class="org-variable-name">nullNode</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21019;&#24314;&#26641;
</span>    <span class="org-type">void</span> <span class="org-function-name">visit</span>(<span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">node</span>);   <span class="org-comment-delimiter">// </span><span class="org-comment">&#25171;&#21360;
</span>    <span class="org-type">void</span> <span class="org-function-name">preOrder</span>(<span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">node</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21069;&#24207;&#36941;&#21382;
</span>    <span class="org-type">void</span> <span class="org-function-name">inOrder</span>(<span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">node</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20013;&#24207;&#36941;&#21382;
</span>    <span class="org-type">void</span> <span class="org-function-name">postOrder</span>(<span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">node</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21518;&#24207;&#36941;&#21382;
</span><span class="org-keyword">public</span>:
    <span class="org-function-name">Tree</span>();
    <span class="org-function-name">Tree</span>(<span class="org-type">int</span> <span class="org-variable-name">maxNodes</span>);
    ~<span class="org-function-name">Tree</span>();
    <span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-function-name">GetTreeNode</span>(<span class="org-type">int</span> <span class="org-variable-name">id</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#26641;&#32467;&#28857;
</span>    <span class="org-type">void</span> <span class="org-function-name">CreateTree</span>(<span class="org-type">T</span> <span class="org-variable-name">a</span>[], <span class="org-type">int</span> <span class="org-variable-name">size</span>, <span class="org-type">T</span> <span class="org-variable-name">nullNode</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20256;&#20837;&#39034;&#24207;&#26641;&#65292;&#24418;&#25104;&#20108;&#21449;&#26641;
</span>    <span class="org-type">void</span> <span class="org-function-name">preOrderTraversal</span>(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21069;&#24207;&#36941;&#21382;, &#22806;&#37096;&#35843;&#29992;&#26102;&#65292;&#26681;&#32467;&#28857;&#19981;&#38656;&#35201;&#20851;&#24515;&#65292;&#25152;&#20197;&#19981;&#38656;&#35201;&#21442;&#25968;
</span>    <span class="org-type">void</span> <span class="org-function-name">inOrderTraversal</span>(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20013;&#24207;&#36941;&#21382;
</span>    <span class="org-type">void</span> <span class="org-function-name">postOrderTraversal</span>();<span class="org-comment-delimiter">// </span><span class="org-comment">&#21518;&#24207;&#36941;&#21382;
</span>};

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-constant">Tree</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">Tree</span>() {
    nodeSize = 100001;
    root = <span class="org-constant">NULL</span>;
    nodes = <span class="org-keyword">new</span> <span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;[<span class="org-constant">nodeSize</span>];
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-constant">Tree</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">Tree</span>(<span class="org-type">int</span> <span class="org-variable-name">maxNodes</span>) {
    nodeSize = maxNodes;
    root = <span class="org-constant">NULL</span>;
    nodes = <span class="org-keyword">new</span> <span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;[<span class="org-constant">nodeSize</span>];
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-constant">Tree</span>&lt;<span class="org-type">T</span>&gt;::~<span class="org-function-name">Tree</span>() {
    <span class="org-keyword">delete</span>[] nodes;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-constant">Tree</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">GetTreeNode</span>(<span class="org-type">int</span> <span class="org-variable-name">id</span>) {
    <span class="org-keyword">return</span> &amp;nodes[id];
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Tree</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">visit</span>(<span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">node</span>) {
    cout &lt;&lt; node-&gt;val; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25171;&#21360;&#20540;
</span>}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#21019;&#24314;&#26641;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-constant">Tree</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">Create</span>(<span class="org-type">T</span> <span class="org-variable-name">a</span>[], <span class="org-type">int</span> <span class="org-variable-name">size</span>, <span class="org-type">int</span> <span class="org-variable-name">nodeId</span>, <span class="org-type">T</span> <span class="org-variable-name">nullNode</span>) {
    <span class="org-keyword">if</span> (nodeId &gt;= size || a[nodeId] == nullNode) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#35828;&#26126;&#26159;&#31354;&#26641;
</span>        <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
    }
    <span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">nowNode</span> = GetTreeNode(nodeId);
    nowNode-&gt;val = a[nodeId];
    nowNode-&gt;left = Create(a, size, nodeId * 2, nullNode);
    nowNode-&gt;right = Create(a, size, nodeId * 2 + 1, nullNode);
    <span class="org-keyword">return</span> nowNode;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Tree</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">CreateTree</span>(<span class="org-type">T</span> <span class="org-variable-name">a</span>[], <span class="org-type">int</span> <span class="org-variable-name">size</span>, <span class="org-type">T</span> <span class="org-variable-name">nullNode</span>) {
    root = Create(a, size, 1, nullNode);
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Tree</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">preOrder</span>(<span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">node</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#21069;&#24207;&#36941;&#21382;&#65292;&#25171;&#21360;&#20540;&#65292;&#36882;&#24402;&#35843;&#29992;&#65292;&#20808;&#36941;&#21382;&#24038;&#23376;&#26641;&#65292;&#20877;&#36941;&#21382;&#21491;&#23376;&#26641;
</span>    <span class="org-keyword">if</span> (node) {
        visit(node);
        preOrder(node-&gt;left);
        preOrder(node-&gt;right);
    }
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Tree</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">preOrderTraversal</span>() {
    preOrder(root);
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Tree</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">inOrder</span>(<span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">node</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20013;&#24207;&#36941;&#21382;&#65292;&#36882;&#24402;&#35843;&#29992;&#65292;&#20808;&#36941;&#21382;&#24038;&#23376;&#26641;&#65292;&#20877;&#35775;&#38382;&#26681;&#32467;&#28857;&#65292;&#26368;&#21518;&#20877;&#36941;&#21382;&#21491;&#23376;&#26641;
</span>    <span class="org-keyword">if</span> (node) {
        inOrder(node-&gt;left);
        visit(node);
        inOrder(node-&gt;right);
    }
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Tree</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">inOrderTraversal</span>() {
    inOrder(root);
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Tree</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">postOrder</span>(<span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">node</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#21518;&#24207;&#36941;&#21382;&#65292;&#36882;&#24402;&#35843;&#29992;&#65292;&#20808;&#36941;&#21382;&#24038;&#23376;&#26641;&#65292;&#20877;&#36941;&#21382;&#21491;&#23376;&#26641;&#65292;&#26368;&#21518;&#20877;&#35775;&#38382;&#26681;&#32467;&#28857;
</span>    <span class="org-keyword">if</span> (node) {
        postOrder(node-&gt;left);
        postOrder(node-&gt;right);
        visit(node);
    }
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Tree</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">postOrderTraversal</span>() {
    postOrder(root);
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#31354;&#32467;&#28857;
</span>    <span class="org-keyword">const</span> <span class="org-type">char</span> <span class="org-variable-name">nullNode</span> = <span class="org-string">'-'</span>;
    <span class="org-type">char</span> <span class="org-variable-name">a</span>[15] = {
        nullNode, <span class="org-string">'a'</span>, <span class="org-string">'b'</span>, <span class="org-string">'c'</span>, <span class="org-string">'d'</span>,
        nullNode, <span class="org-string">'e'</span>, <span class="org-string">'f'</span>, <span class="org-string">'g'</span>, <span class="org-string">'h'</span>,
        nullNode, nullNode, nullNode, nullNode, <span class="org-string">'i'</span>
    };
    <span class="org-type">Tree</span>&lt;<span class="org-type">char</span>&gt; <span class="org-variable-name">T</span>(15);
    T.CreateTree(a, 15, nullNode);
    T.preOrderTraversal(); cout &lt;&lt; endl;
    T.inOrderTraversal(); cout &lt;&lt; endl;
    T.postOrderTraversal(); cout &lt;&lt; endl;


    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-h:3c7bc718-fc28-47bf-9d8d-70cd46c8268b" class="outline-3">
<h3 id="h:3c7bc718-fc28-47bf-9d8d-70cd46c8268b"><a href="#h:3c7bc718-fc28-47bf-9d8d-70cd46c8268b">实战篇</a></h3>
<div class="outline-text-3" id="text-h:3c7bc718-fc28-47bf-9d8d-70cd46c8268b">
</div>
<div id="outline-container-h:adae264e-4c42-4dd3-b9bf-691f5aa6544c" class="outline-4">
<h4 id="h:adae264e-4c42-4dd3-b9bf-691f5aa6544c"><a href="#h:adae264e-4c42-4dd3-b9bf-691f5aa6544c">核心代码模式</a></h4>
<div class="outline-text-4" id="text-h:adae264e-4c42-4dd3-b9bf-691f5aa6544c">
</div>
<div id="outline-container-h:755c6533-3c86-41ce-b531-0d5ce614eca5" class="outline-5">
<h5 id="h:755c6533-3c86-41ce-b531-0d5ce614eca5"><a href="#h:755c6533-3c86-41ce-b531-0d5ce614eca5">1.单值二叉树</a></h5>
<div class="outline-text-5" id="text-h:755c6533-3c86-41ce-b531-0d5ce614eca5">
<p>
<a href="https://leetcode.cn/problems/univalued-binary-tree/description/">https://leetcode.cn/problems/univalued-binary-tree/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#22914;&#26524;&#20108;&#21449;&#26641;&#27599;&#20010;&#33410;&#28857;&#37117;&#20855;&#26377;&#30456;&#21516;&#30340;&#20540;&#65292;&#37027;&#20040;&#35813;&#20108;&#21449;&#26641;&#23601;&#26159;&#21333;&#20540;&#20108;&#21449;&#26641;&#12290;

&#21482;&#26377;&#32473;&#23450;&#30340;&#26641;&#26159;&#21333;&#20540;&#20108;&#21449;&#26641;&#26102;&#65292;&#25165;&#36820;&#22238; true&#65307;&#21542;&#21017;&#36820;&#22238; false&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;[1,1,1,1,1,null,1]
&#36755;&#20986;&#65306;true

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;[2,2,2,5,2]
&#36755;&#20986;&#65306;false

&#25552;&#31034;&#65306;
&#32473;&#23450;&#26641;&#30340;&#33410;&#28857;&#25968;&#33539;&#22260;&#26159; [1, 100]&#12290;
&#27599;&#20010;&#33410;&#28857;&#30340;&#20540;&#37117;&#26159;&#25972;&#25968;&#65292;&#33539;&#22260;&#20026; [0, 99] &#12290;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp">
<span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">bool</span> <span class="org-function-name">isUnivalTree</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-keyword">if</span>(root == <span class="org-constant">NULL</span>) {
            <span class="org-keyword">return</span> <span class="org-constant">false</span>;
        }
        <span class="org-keyword">if</span>(root-&gt;left){
            <span class="org-keyword">if</span>(root-&gt;val != root-&gt;left-&gt;val){
                <span class="org-keyword">return</span> <span class="org-constant">false</span>;
            }
            <span class="org-keyword">if</span>(<span class="org-negation-char">!</span>isUnivalTree(root-&gt;left)) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#23376;&#26641;&#23384;&#22312;&#26102;&#65292;&#33258;&#24049;&#26159;&#21542;&#28385;&#36275;
</span>                <span class="org-keyword">return</span> <span class="org-constant">false</span>;
            }
        }
        <span class="org-keyword">if</span>(root-&gt;right){
            <span class="org-keyword">if</span>(root-&gt;val != root-&gt;right-&gt;val){
                <span class="org-keyword">return</span> <span class="org-constant">false</span>;
            }
            <span class="org-keyword">if</span>(<span class="org-negation-char">!</span>isUnivalTree(root-&gt;right)) {
                <span class="org-keyword">return</span> <span class="org-constant">false</span>;
            }
        }
        <span class="org-keyword">return</span> <span class="org-constant">true</span>;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:c3e6fee3-ba5d-4e17-8c3a-f5a49665d55f" class="outline-5">
<h5 id="h:c3e6fee3-ba5d-4e17-8c3a-f5a49665d55f"><a href="#h:c3e6fee3-ba5d-4e17-8c3a-f5a49665d55f">2.完全二叉树的节点个数</a></h5>
<div class="outline-text-5" id="text-h:c3e6fee3-ba5d-4e17-8c3a-f5a49665d55f">
<p>
<a href="https://leetcode.cn/problems/count-complete-tree-nodes/description/">https://leetcode.cn/problems/count-complete-tree-nodes/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#23436;&#20840;&#20108;&#21449;&#26641; &#30340;&#23450;&#20041;&#22914;&#19979;&#65306;&#22312;&#23436;&#20840;&#20108;&#21449;&#26641;&#20013;&#65292;&#38500;&#20102;&#26368;&#24213;&#23618;&#33410;&#28857;&#21487;&#33021;&#27809;&#22635;&#28385;&#22806;&#65292;
&#20854;&#20313;&#27599;&#23618;&#33410;&#28857;&#25968;&#37117;&#36798;&#21040;&#26368;&#22823;&#20540;&#65292;&#24182;&#19988;&#26368;&#19979;&#38754;&#19968;&#23618;&#30340;&#33410;&#28857;&#37117;&#38598;&#20013;&#22312;&#35813;&#23618;&#26368;&#24038;&#36793;&#30340;&#33509;&#24178;&#20301;&#32622;&#12290;
&#33509;&#26368;&#24213;&#23618;&#20026;&#31532; h &#23618;&#65288;&#20174;&#31532; 0 &#23618;&#24320;&#22987;&#65289;&#65292;&#21017;&#35813;&#23618;&#21253;&#21547; 1~ 2h &#20010;&#33410;&#28857;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;root = [1,2,3,4,5,6]
&#36755;&#20986;&#65306;6

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;root = []
&#36755;&#20986;&#65306;0

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;root = [1]
&#36755;&#20986;&#65306;1

&#25552;&#31034;&#65306;
&#26641;&#20013;&#33410;&#28857;&#30340;&#25968;&#30446;&#33539;&#22260;&#26159;[0, 5 * 104]
0 &lt;= Node.val &lt;= 5 * 104
&#39064;&#30446;&#25968;&#25454;&#20445;&#35777;&#36755;&#20837;&#30340;&#26641;&#26159; &#23436;&#20840;&#20108;&#21449;&#26641;
</pre>
</div>


<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">countNodes</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#20108;&#21449;&#26641;&#30340;&#32467;&#28857;&#20010;&#25968;&#21487;&#20197;&#29992;&#36882;&#24402;&#26469;&#35745;&#31639;
</span>        <span class="org-keyword">if</span> (root == <span class="org-constant">NULL</span>) {
            <span class="org-keyword">return</span> 0;
        }
        <span class="org-type">int</span> <span class="org-variable-name">lc</span> = countNodes(root-&gt;left);
        <span class="org-type">int</span> <span class="org-variable-name">rc</span> = countNodes(root-&gt;right);
        <span class="org-keyword">return</span> lc+rc+1;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:7c623dd6-7d3d-48fc-9231-293b670526ae" class="outline-5">
<h5 id="h:7c623dd6-7d3d-48fc-9231-293b670526ae"><a href="#h:7c623dd6-7d3d-48fc-9231-293b670526ae">3.二叉树的前序遍历</a></h5>
<div class="outline-text-5" id="text-h:7c623dd6-7d3d-48fc-9231-293b670526ae">
<p>
<a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">https://leetcode.cn/problems/binary-tree-preorder-traversal/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#20108;&#21449;&#26641;&#30340;&#26681;&#33410;&#28857; root &#65292;&#36820;&#22238;&#23427;&#33410;&#28857;&#20540;&#30340; &#21069;&#24207; &#36941;&#21382;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;root = [1,null,2,3]
&#36755;&#20986;&#65306;[1,2,3]
&#35299;&#37322;&#65306;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;root = [1,2,3,4,5,null,8,null,null,6,7,9]
&#36755;&#20986;&#65306;[1,2,4,5,6,7,3,8,9]
&#35299;&#37322;&#65306;

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;root = []
&#36755;&#20986;&#65306;[]

&#31034;&#20363; 4&#65306;
&#36755;&#20837;&#65306;root = [1]
&#36755;&#20986;&#65306;[1]

&#25552;&#31034;&#65306;
&#26641;&#20013;&#33410;&#28857;&#25968;&#30446;&#22312;&#33539;&#22260; [0, 100] &#20869;
-100 &lt;= Node.val &lt;= 100
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">ret</span>;
    <span class="org-type">void</span> <span class="org-function-name">preorder</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-keyword">if</span>(root) {
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#35775;&#38382;&#26681;&#33410;&#28857;&#20540;
</span>            ret.push_back(root-&gt;val);
            preorder(root-&gt;left);
            preorder(root-&gt;right);
        }
    }
<span class="org-keyword">public</span>:
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-function-name">preorderTraversal</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21069;&#24207;&#36941;&#21382;&#65306;&#20808;&#35775;&#38382;&#26681;&#33410;&#28857;&#65292;&#24038;&#23376;&#26641;&#65292;&#21491;&#23376;&#26641;
</span>        ret.clear();
        preorder(root);
        <span class="org-keyword">return</span> ret;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:08cf55e0-cb14-48b0-9848-6048d6af13f7" class="outline-5">
<h5 id="h:08cf55e0-cb14-48b0-9848-6048d6af13f7"><a href="#h:08cf55e0-cb14-48b0-9848-6048d6af13f7">4.二叉树的中序遍历</a></h5>
<div class="outline-text-5" id="text-h:08cf55e0-cb14-48b0-9848-6048d6af13f7">
<p>
<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">https://leetcode.cn/problems/binary-tree-inorder-traversal/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#23450;&#19968;&#20010;&#20108;&#21449;&#26641;&#30340;&#26681;&#33410;&#28857; root &#65292;&#36820;&#22238; &#23427;&#30340; &#20013;&#24207; &#36941;&#21382; &#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;root = [1,null,2,3]
&#36755;&#20986;&#65306;[1,3,2]

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;root = []
&#36755;&#20986;&#65306;[]

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;root = [1]
&#36755;&#20986;&#65306;[1]

&#25552;&#31034;&#65306;
&#26641;&#20013;&#33410;&#28857;&#25968;&#30446;&#22312;&#33539;&#22260; [0, 100] &#20869;
-100 &lt;= Node.val &lt;= 100
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">ret</span>;
    <span class="org-type">void</span> <span class="org-function-name">inOrder</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-keyword">if</span> (root) {
            inOrder(root-&gt;left);
            ret.push_back(root-&gt;val);
            inOrder(root-&gt;right);
        }
    }
<span class="org-keyword">public</span>:
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-function-name">inorderTraversal</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        ret.clear();
        inOrder(root);
        <span class="org-keyword">return</span> ret;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:b40627b6-888e-4509-ab3f-a058714423ea" class="outline-5">
<h5 id="h:b40627b6-888e-4509-ab3f-a058714423ea"><a href="#h:b40627b6-888e-4509-ab3f-a058714423ea">5.二叉树的后序遍历</a></h5>
<div class="outline-text-5" id="text-h:b40627b6-888e-4509-ab3f-a058714423ea">
<p>
<a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">https://leetcode.cn/problems/binary-tree-postorder-traversal/</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">ret</span>;
    <span class="org-type">void</span> <span class="org-function-name">postOrder</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-keyword">if</span>(root){
            postOrder(root-&gt;left);
            postOrder(root-&gt;right);
            ret.push_back(root-&gt;val);
        }
    }
<span class="org-keyword">public</span>:
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-function-name">postorderTraversal</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21518;&#24207;&#36941;&#21382;&#65306;&#24038;&#23376;&#26641;-&gt;&#21491;&#23376;&#26641;-&gt;&#26681;
</span>        ret.clear();
        postOrder(root);
        <span class="org-keyword">return</span> ret;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:a4e4efe4-860e-4ad2-ae5e-16e3dea8a2fb" class="outline-5">
<h5 id="h:a4e4efe4-860e-4ad2-ae5e-16e3dea8a2fb"><a href="#h:a4e4efe4-860e-4ad2-ae5e-16e3dea8a2fb">6.翻转二叉树</a></h5>
<div class="outline-text-5" id="text-h:a4e4efe4-860e-4ad2-ae5e-16e3dea8a2fb">
<p>
<a href="https://leetcode.cn/problems/invert-binary-tree/">https://leetcode.cn/problems/invert-binary-tree/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#26869;&#20108;&#21449;&#26641;&#30340;&#26681;&#33410;&#28857; root &#65292;&#32763;&#36716;&#36825;&#26869;&#20108;&#21449;&#26641;&#65292;&#24182;&#36820;&#22238;&#20854;&#26681;&#33410;&#28857;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;root = [4,2,7,1,3,6,9]
&#36755;&#20986;&#65306;[4,7,2,9,6,3,1]

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;root = [2,1,3]
&#36755;&#20986;&#65306;[2,3,1]

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;root = []
&#36755;&#20986;&#65306;[]

&#25552;&#31034;&#65306;
&#26641;&#20013;&#33410;&#28857;&#25968;&#30446;&#33539;&#22260;&#22312; [0, 100] &#20869;
-100 &lt;= Node.val &lt;= 100
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">TreeNode</span>* <span class="org-function-name">invertTree</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">3. root&#20026;&#31354;&#26102;
</span>        <span class="org-keyword">if</span>(root == <span class="org-constant">NULL</span>) {
            <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">1.&#32763;&#36716;&#23436;&#21518;&#65292;&#26681;&#33410;&#28857;&#36824;&#26159;&#23427;&#26412;&#36523;&#65292;&#25152;&#20197;return root
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">2. &#21457;&#29616;&#24038;&#23376;&#26641;&#21644;&#21491;&#23376;&#26641;&#20132;&#25442;
</span>        <span class="org-type">TreeNode</span>* <span class="org-variable-name">r</span> = invertTree(root-&gt;right);
        <span class="org-type">TreeNode</span>* <span class="org-variable-name">l</span> = invertTree(root-&gt;left);
        root-&gt;left = r;
        root-&gt;right = l;

        <span class="org-keyword">return</span> root;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:1ccaaeae-2540-4e3f-9ff1-7d469450367d" class="outline-5">
<h5 id="h:1ccaaeae-2540-4e3f-9ff1-7d469450367d"><a href="#h:1ccaaeae-2540-4e3f-9ff1-7d469450367d">7.从根到叶的二进制数之和</a></h5>
<div class="outline-text-5" id="text-h:1ccaaeae-2540-4e3f-9ff1-7d469450367d">
<p>
<a href="https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers/">https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#20986;&#19968;&#26869;&#20108;&#21449;&#26641;&#65292;&#20854;&#19978;&#27599;&#20010;&#32467;&#28857;&#30340;&#20540;&#37117;&#26159; 0 &#25110; 1 &#12290;&#27599;&#19968;&#26465;&#20174;&#26681;&#21040;&#21494;&#30340;&#36335;&#24452;&#37117;&#20195;&#34920;&#19968;&#20010;&#20174;&#26368;&#39640;&#26377;&#25928;&#20301;&#24320;&#22987;&#30340;&#20108;&#36827;&#21046;&#25968;&#12290;

&#20363;&#22914;&#65292;&#22914;&#26524;&#36335;&#24452;&#20026; 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1&#65292;&#37027;&#20040;&#23427;&#34920;&#31034;&#20108;&#36827;&#21046;&#25968; 01101&#65292;&#20063;&#23601;&#26159; 13 &#12290;
&#23545;&#26641;&#19978;&#30340;&#27599;&#19968;&#29255;&#21494;&#23376;&#65292;&#25105;&#20204;&#37117;&#35201;&#25214;&#20986;&#20174;&#26681;&#21040;&#35813;&#21494;&#23376;&#30340;&#36335;&#24452;&#25152;&#34920;&#31034;&#30340;&#25968;&#23383;&#12290;

&#36820;&#22238;&#36825;&#20123;&#25968;&#23383;&#20043;&#21644;&#12290;&#39064;&#30446;&#25968;&#25454;&#20445;&#35777;&#31572;&#26696;&#26159;&#19968;&#20010; 32 &#20301; &#25972;&#25968;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;root = [1,0,1,0,1,0,1]
&#36755;&#20986;&#65306;22
&#35299;&#37322;&#65306;(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;root = [0]
&#36755;&#20986;&#65306;0

&#25552;&#31034;&#65306;
&#26641;&#20013;&#30340;&#33410;&#28857;&#25968;&#22312; [1, 1000] &#33539;&#22260;&#20869;
Node.val &#20165;&#20026; 0 &#25110; 1 
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-type">int</span> <span class="org-variable-name">sum</span>;
    <span class="org-type">void</span> <span class="org-function-name">sumRoot</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>, <span class="org-type">int</span> <span class="org-variable-name">pre</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">pre&#34920;&#31034;&#20174;&#26681;&#33410;&#28857;&#21040;&#30446;&#21069;&#33410;&#28857;&#24471;&#21040;&#30340;&#20108;&#36827;&#21046;&#36716;&#20108;&#36827;&#21046;&#30340;&#20540;
</span>        <span class="org-keyword">if</span>(<span class="org-negation-char">!</span>root-&gt;left &amp;&amp; <span class="org-negation-char">!</span>root-&gt;right ){ <span class="org-comment-delimiter">// </span><span class="org-comment">&#35828;&#26126;&#26159;&#21494;&#23376;&#32467;&#28857;
</span>            sum += pre*2 + root-&gt;val; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24038;&#31227;1&#20301;&#65292;&#20877;&#21152;&#24403;&#21069;&#20540;
</span>            <span class="org-keyword">return</span>;
        }
        <span class="org-keyword">if</span>(root-&gt;left) {
            sumRoot(root-&gt;left, <span class="org-type">pre</span>*2 + root-&gt;val);
        }
        <span class="org-keyword">if</span>(root-&gt;right) {
            sumRoot(root-&gt;right, <span class="org-type">pre</span>*2 + root-&gt;val);
        }
    }
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">sumRootToLeaf</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        sum = 0;
        sumRoot(root, 0);
        <span class="org-keyword">return</span> sum;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:66d1a57b-6306-4018-98ba-d7bb77b116cb" class="outline-5">
<h5 id="h:66d1a57b-6306-4018-98ba-d7bb77b116cb"><a href="#h:66d1a57b-6306-4018-98ba-d7bb77b116cb">8.找出克隆二叉树中的相同节点</a></h5>
<div class="outline-text-5" id="text-h:66d1a57b-6306-4018-98ba-d7bb77b116cb">
<p>
<a href="https://leetcode.cn/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/description/">https://leetcode.cn/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#20004;&#26869;&#20108;&#21449;&#26641;&#65292;&#21407;&#22987;&#26641; original &#21644;&#20811;&#38534;&#26641; cloned&#65292;&#20197;&#21450;&#19968;&#20010;&#20301;&#20110;&#21407;&#22987;&#26641; original &#20013;&#30340;&#30446;&#26631;&#33410;&#28857; target&#12290;

&#20854;&#20013;&#65292;&#20811;&#38534;&#26641; cloned &#26159;&#21407;&#22987;&#26641; original &#30340;&#19968;&#20010; &#21103;&#26412; &#12290;

&#35831;&#25214;&#20986;&#22312;&#26641; cloned &#20013;&#65292;&#19982; target &#30456;&#21516; &#30340;&#33410;&#28857;&#65292;&#24182;&#36820;&#22238;&#23545;&#35813;&#33410;&#28857;&#30340;&#24341;&#29992;&#65288;&#22312; C/C++ &#31561;&#26377;&#25351;&#38024;&#30340;&#35821;&#35328;&#20013;&#36820;&#22238; &#33410;&#28857;&#25351;&#38024;&#65292;&#20854;&#20182;&#35821;&#35328;&#36820;&#22238;&#33410;&#28857;&#26412;&#36523;&#65289;&#12290;

&#27880;&#24847;&#65306;&#20320; &#19981;&#33021; &#23545;&#20004;&#26869;&#20108;&#21449;&#26641;&#65292;&#20197;&#21450; target &#33410;&#28857;&#36827;&#34892;&#26356;&#25913;&#12290;&#21482;&#33021; &#36820;&#22238;&#23545;&#20811;&#38534;&#26641; cloned &#20013;&#24050;&#26377;&#30340;&#33410;&#28857;&#30340;&#24341;&#29992;&#12290;

&#31034;&#20363; 1:
&#36755;&#20837;: tree = [7,4,3,null,null,6,19], target = 3
&#36755;&#20986;: 3
&#35299;&#37322;: &#19978;&#22270;&#30011;&#20986;&#20102;&#26641; original &#21644; cloned&#12290;target &#33410;&#28857;&#22312;&#26641; original &#20013;&#65292;&#29992;&#32511;&#33394;&#26631;&#35760;&#12290;&#31572;&#26696;&#26159;&#26641; cloned &#20013;&#30340;&#40644;&#39068;&#33394;&#30340;&#33410;&#28857;&#65288;&#20854;&#20182;&#31034;&#20363;&#31867;&#20284;&#65289;&#12290;

&#31034;&#20363; 2:
&#36755;&#20837;: tree = [7], target =  7
&#36755;&#20986;: 7

&#31034;&#20363; 3:
&#36755;&#20837;: tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4
&#36755;&#20986;: 4

&#25552;&#31034;&#65306;
&#26641;&#20013;&#33410;&#28857;&#30340;&#25968;&#37327;&#33539;&#22260;&#20026; [1, 104] &#12290;
&#21516;&#19968;&#26869;&#26641;&#20013;&#65292;&#27809;&#26377;&#20540;&#30456;&#21516;&#30340;&#33410;&#28857;&#12290;
target &#33410;&#28857;&#26159;&#26641; original &#20013;&#30340;&#19968;&#20010;&#33410;&#28857;&#65292;&#24182;&#19988;&#19981;&#20250;&#26159; null &#12290;
</pre>
</div>


<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */</span>

<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">TreeNode</span>* <span class="org-function-name">getTargetCopy</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">original</span>, <span class="org-type">TreeNode</span>* <span class="org-variable-name">cloned</span>, <span class="org-type">TreeNode</span>* <span class="org-variable-name">target</span>) {
        <span class="org-keyword">if</span>(original == target) {
            <span class="org-keyword">return</span> cloned;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36755;&#20986;&#30340;&#26159;&#33410;&#28857;&#22320;&#22336;
</span>        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">original == NULL
</span>        <span class="org-keyword">if</span>(original == <span class="org-constant">NULL</span>) {
            <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
        }

        <span class="org-keyword">if</span>(original-&gt;left) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#24038;&#23376;&#26641;&#38750;&#31354;&#26102;
</span>            <span class="org-type">TreeNode</span>* <span class="org-variable-name">t</span> = getTargetCopy(original-&gt;left, cloned-&gt;left, target);
            <span class="org-keyword">if</span>(t) {
                <span class="org-keyword">return</span> t;
            }
        }
        <span class="org-keyword">if</span>(original-&gt;right) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21491;&#23376;&#26641;&#38750;&#31354;&#26102;
</span>            <span class="org-type">TreeNode</span>* <span class="org-variable-name">t</span> = getTargetCopy(original-&gt;right, cloned-&gt;right, target);
            <span class="org-keyword">if</span>(t) {
                <span class="org-keyword">return</span> t;
            }
        }

        <span class="org-comment-delimiter">// </span><span class="org-comment">&#24038;&#21491;&#33410;&#28857;&#37117;&#19981;&#23384;&#22312;&#26102;&#65292;&#30452;&#25509;&#36820;&#22238;&#31354;
</span>        <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:f6fc6fb3-8245-42f2-8661-822a0b8b00d6" class="outline-5">
<h5 id="h:f6fc6fb3-8245-42f2-8661-822a0b8b00d6"><a href="#h:f6fc6fb3-8245-42f2-8661-822a0b8b00d6">9.层数最深叶子节点的和</a></h5>
<div class="outline-text-5" id="text-h:f6fc6fb3-8245-42f2-8661-822a0b8b00d6">
<p>
<a href="https://leetcode.cn/problems/deepest-leaves-sum/description/">https://leetcode.cn/problems/deepest-leaves-sum/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#26869;&#20108;&#21449;&#26641;&#30340;&#26681;&#33410;&#28857; root &#65292;&#35831;&#20320;&#36820;&#22238; &#23618;&#25968;&#26368;&#28145;&#30340;&#21494;&#23376;&#33410;&#28857;&#30340;&#21644; &#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;root = [1,2,3,4,5,null,6,7,null,null,null,null,8]
&#36755;&#20986;&#65306;15

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]
&#36755;&#20986;&#65306;19

&#25552;&#31034;&#65306;
&#26641;&#20013;&#33410;&#28857;&#25968;&#30446;&#22312;&#33539;&#22260; [1, 104] &#20043;&#38388;&#12290;
1 &lt;= Node.val &lt;= 100
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-type">int</span> <span class="org-variable-name">maxDepth</span>;
    <span class="org-type">void</span> <span class="org-function-name">getMaxDepth</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>, <span class="org-type">int</span> <span class="org-variable-name">dep</span>) {
        <span class="org-keyword">if</span>(root == <span class="org-constant">NULL</span>) {
            <span class="org-keyword">return</span>;
        }
        <span class="org-keyword">if</span> (dep &gt; maxDepth){
            maxDepth = dep;
        }
        getMaxDepth(root-&gt;left, dep+1);
        getMaxDepth(root-&gt;right, dep+1);
    }

    <span class="org-type">int</span> <span class="org-function-name">sumMaxDepth</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>, <span class="org-type">int</span> <span class="org-variable-name">dep</span>) {
        <span class="org-keyword">if</span>(root == <span class="org-constant">NULL</span>) {
            <span class="org-keyword">return</span> 0;
        }
        <span class="org-keyword">if</span> (dep == maxDepth){
            <span class="org-keyword">return</span> root-&gt;val;
        }
        <span class="org-keyword">return</span> sumMaxDepth(root-&gt;left, dep+1) + sumMaxDepth(root-&gt;right, dep+1);
    }

<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">deepestLeavesSum</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21494;&#23376;&#33410;&#28857;&#65306;&#27809;&#26377;&#24038;&#21491;&#23376;&#26641;&#12290;&#36825;&#37324;&#20026;7 5 8&#21495;
</span>        maxDepth = 0;
        getMaxDepth(root, 0);
        <span class="org-keyword">return</span> sumMaxDepth(root, 0);
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:373fe498-5853-42cc-b58a-cea6d269ad73" class="outline-5">
<h5 id="h:373fe498-5853-42cc-b58a-cea6d269ad73"><a href="#h:373fe498-5853-42cc-b58a-cea6d269ad73">10.最大二叉树</a></h5>
<div class="outline-text-5" id="text-h:373fe498-5853-42cc-b58a-cea6d269ad73">
<p>
<a href="https://leetcode.cn/problems/maximum-binary-tree/description/">https://leetcode.cn/problems/maximum-binary-tree/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#23450;&#19968;&#20010;&#19981;&#37325;&#22797;&#30340;&#25972;&#25968;&#25968;&#32452; nums &#12290; &#26368;&#22823;&#20108;&#21449;&#26641; &#21487;&#20197;&#29992;&#19979;&#38754;&#30340;&#31639;&#27861;&#20174; nums &#36882;&#24402;&#22320;&#26500;&#24314;:

&#21019;&#24314;&#19968;&#20010;&#26681;&#33410;&#28857;&#65292;&#20854;&#20540;&#20026; nums &#20013;&#30340;&#26368;&#22823;&#20540;&#12290;
&#36882;&#24402;&#22320;&#22312;&#26368;&#22823;&#20540; &#24038;&#36793; &#30340; &#23376;&#25968;&#32452;&#21069;&#32512;&#19978; &#26500;&#24314;&#24038;&#23376;&#26641;&#12290;
&#36882;&#24402;&#22320;&#22312;&#26368;&#22823;&#20540; &#21491;&#36793; &#30340; &#23376;&#25968;&#32452;&#21518;&#32512;&#19978; &#26500;&#24314;&#21491;&#23376;&#26641;&#12290;
&#36820;&#22238; nums &#26500;&#24314;&#30340; &#26368;&#22823;&#20108;&#21449;&#26641; &#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;nums = [3,2,1,6,0,5]
&#36755;&#20986;&#65306;[6,3,5,null,2,0,null,null,1]
&#35299;&#37322;&#65306;&#36882;&#24402;&#35843;&#29992;&#22914;&#19979;&#25152;&#31034;&#65306;
- [3,2,1,6,0,5] &#20013;&#30340;&#26368;&#22823;&#20540;&#26159; 6 &#65292;&#24038;&#36793;&#37096;&#20998;&#26159; [3,2,1] &#65292;&#21491;&#36793;&#37096;&#20998;&#26159; [0,5] &#12290;
    - [3,2,1] &#20013;&#30340;&#26368;&#22823;&#20540;&#26159; 3 &#65292;&#24038;&#36793;&#37096;&#20998;&#26159; [] &#65292;&#21491;&#36793;&#37096;&#20998;&#26159; [2,1] &#12290;
        - &#31354;&#25968;&#32452;&#65292;&#26080;&#23376;&#33410;&#28857;&#12290;
        - [2,1] &#20013;&#30340;&#26368;&#22823;&#20540;&#26159; 2 &#65292;&#24038;&#36793;&#37096;&#20998;&#26159; [] &#65292;&#21491;&#36793;&#37096;&#20998;&#26159; [1] &#12290;
            - &#31354;&#25968;&#32452;&#65292;&#26080;&#23376;&#33410;&#28857;&#12290;
            - &#21482;&#26377;&#19968;&#20010;&#20803;&#32032;&#65292;&#25152;&#20197;&#23376;&#33410;&#28857;&#26159;&#19968;&#20010;&#20540;&#20026; 1 &#30340;&#33410;&#28857;&#12290;
    - [0,5] &#20013;&#30340;&#26368;&#22823;&#20540;&#26159; 5 &#65292;&#24038;&#36793;&#37096;&#20998;&#26159; [0] &#65292;&#21491;&#36793;&#37096;&#20998;&#26159; [] &#12290;
        - &#21482;&#26377;&#19968;&#20010;&#20803;&#32032;&#65292;&#25152;&#20197;&#23376;&#33410;&#28857;&#26159;&#19968;&#20010;&#20540;&#20026; 0 &#30340;&#33410;&#28857;&#12290;
        - &#31354;&#25968;&#32452;&#65292;&#26080;&#23376;&#33410;&#28857;&#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;nums = [3,2,1]
&#36755;&#20986;&#65306;[3,null,2,null,1]

&#25552;&#31034;&#65306;
1 &lt;= nums.length &lt;= 1000
0 &lt;= nums[i] &lt;= 1000
nums &#20013;&#30340;&#25152;&#26377;&#25972;&#25968; &#20114;&#19981;&#30456;&#21516;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36820;&#22238;&#33410;&#28857;
</span>    <span class="org-type">TreeNode</span>* <span class="org-function-name">dfs</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>, <span class="org-type">int</span> <span class="org-variable-name">l</span>, <span class="org-type">int</span> <span class="org-variable-name">r</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#25968;&#32452;&#30340;l&#21040;r&#21306;&#38388;&#26500;&#24314;&#20986;&#26469;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">3. &#36882;&#24402;&#20986;&#21475;&#65292;&#31354;&#26641;&#26102;&#36820;&#22238;
</span>        <span class="org-keyword">if</span>(l &gt; r) {
            <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">2. &#27714;&#26368;&#22823;&#20540;
</span>        <span class="org-type">int</span> <span class="org-variable-name">maxIdx</span> = l;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = l+1; i &lt;= r; ++i) {
            <span class="org-keyword">if</span>(nums[i] &gt; nums[maxIdx]){
                maxIdx = i;
            }
        }

        <span class="org-comment-delimiter">// </span><span class="org-comment">1. &#26500;&#24314;root
</span>        <span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span> = <span class="org-keyword">new</span> <span class="org-type">TreeNode</span>();
        root-&gt;left = dfs(nums, l, maxIdx-1); <span class="org-comment-delimiter">// </span><span class="org-comment">&#22788;&#29702;&#24038;&#23376;&#26641;
</span>        root-&gt;right = dfs(nums, maxIdx+1, r); <span class="org-comment-delimiter">// </span><span class="org-comment">&#22788;&#29702;&#21491;&#23376;&#26641;
</span>        root-&gt;val = nums[maxIdx]; <span class="org-comment-delimiter">// </span><span class="org-comment">[l, r] &#37324;&#30340;&#26368;&#22823;&#20540;
</span>        <span class="org-keyword">return</span> root;
    }
<span class="org-keyword">public</span>:
    <span class="org-type">TreeNode</span>* <span class="org-function-name">constructMaximumBinaryTree</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>) {
        <span class="org-keyword">return</span> dfs(nums, 0, nums.size()-1);
    }
};
</pre>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="outline-container-h:673bbd99-7441-4440-af8e-9533c6fd5232" class="outline-2">
<h2 id="h:673bbd99-7441-4440-af8e-9533c6fd5232"><a href="#h:673bbd99-7441-4440-af8e-9533c6fd5232">树形结构-二叉搜索树</a></h2>
<div class="outline-text-2" id="text-h:673bbd99-7441-4440-af8e-9533c6fd5232">
</div>
<div id="outline-container-h:b2e6a607-6dde-4301-a60b-adc9a1ae588d" class="outline-3">
<h3 id="h:b2e6a607-6dde-4301-a60b-adc9a1ae588d"><a href="#h:b2e6a607-6dde-4301-a60b-adc9a1ae588d">二叉搜索树（概念篇）</a></h3>
<div class="outline-text-3" id="text-h:b2e6a607-6dde-4301-a60b-adc9a1ae588d">
<p>
二叉搜索树的增删改查、二叉搜索树的遍历
</p>
</div>
<div id="outline-container-h:49401b4b-d730-47c9-a9d4-0b9528ce798e" class="outline-4">
<h4 id="h:49401b4b-d730-47c9-a9d4-0b9528ce798e"><a href="#h:49401b4b-d730-47c9-a9d4-0b9528ce798e">二叉搜索树的概念</a></h4>
<div class="outline-text-4" id="text-h:49401b4b-d730-47c9-a9d4-0b9528ce798e">
<p>
1、定义
</p>

<p>
二叉搜索树(又称为二叉排序树，二叉查找树)，它满足如下四点性主质
</p>
<ol class="org-ol">
<li>空树是二叉搜索树;</li>
<li>若它的左子树不为空，则左子树上所有结点的值均小于它根结点的值;</li>
<li>若它的右子树不为空，则右子树上所有结点的值均大于它根结点的值;</li>
<li>它的左右子树均为二叉搜索树;</li>
</ol>


<figure id="org51bf0ff">
<img src="././images/img_20251024_152412.png" alt="img_20251024_152412.png" width="50%">

</figure>

<p>
如图所示，对于任何一棵子树而言，它的根结点的值一定大于左子对所有结点的值，且一定小于右子树所有结点的值。
</p>

<p>
2、用途
</p>
<ul class="org-ul">
<li>从二叉搜索树的定义可知，它的前提是二叉树，并且采用了递归的方式进行定义，它的结点间满足一个偏序关系，左子树根结点的值一定比父结点小，右子树根结点的值一定比父结点大。</li>
<li>正如它的名字所说，构造这样一棵树的目的是为了提高搜索的速度，如果对二叉搜索树进行中序遍历，我们可以发现，得到的序列是一个递增序列。</li>
</ul>


<figure id="org7957a47">
<img src="././images/img_20251024_152602.png" alt="img_20251024_152602.png" width="50%">

</figure>
</div>
</div>
<div id="outline-container-h:1ed6387e-94e1-4a04-a83c-2b17c4633b91" class="outline-4">
<h4 id="h:1ed6387e-94e1-4a04-a83c-2b17c4633b91"><a href="#h:1ed6387e-94e1-4a04-a83c-2b17c4633b91">二叉搜索树的链式存储</a></h4>
<div class="outline-text-4" id="text-h:1ed6387e-94e1-4a04-a83c-2b17c4633b91">
<p>
我们一般用孩子表示法来定义一棵二叉搜索树的结点。
</p>
<ol class="org-ol">
<li>二叉搜索树需要有一个结点值，也就是数据域，注意，这里的类型其实可以是任意类型，只要这种类型支持关系运算符的比较即可，本文为了把问题简单话，一律采用整数进行讲解。</li>
<li>二叉搜索树结点的左儿子结点的指针，没有左儿子结点时，值为空;</li>
<li>二叉搜索树结点的右儿子结点的指针，没有右儿子结点时，置为空;</li>
</ol>
</div>
</div>
<div id="outline-container-h:a699cf7b-8cdd-4190-bfc7-ef6333ce39c7" class="outline-4">
<h4 id="h:a699cf7b-8cdd-4190-bfc7-ef6333ce39c7"><a href="#h:a699cf7b-8cdd-4190-bfc7-ef6333ce39c7">二叉搜索树的结点查找</a></h4>
<div class="outline-text-4" id="text-h:a699cf7b-8cdd-4190-bfc7-ef6333ce39c7">
<p>
1、结点查找的概念
</p>
<ul class="org-ul">
<li>二叉搜索树的查找指的是:在树上查找某个数是否存在，存在正返回true，不存在返回false。</li>
</ul>

<p>
2、结点查找图解
</p>
<ul class="org-ul">
<li>如图所示，代表的是从一个二叉搜索树中查找一个值为3的结点。一开始，3比根结点5小，于是递归访问左子树;还是比子树的根结点4小，于是继续递归访问左子树;这时候比根结点2大，于是递归访问右子树，正好找到值为3的结点，回溯结束查找。</li>
</ul>


<figure id="org29e11bd">
<img src="././images/img-2025102429.gif" alt="img-2025102429.gif" width="50%">

</figure>

<p>
3、结点查找的步骤
</p>

<p>
对于要查找的数val，从根结点出发，总共四种情况依次判断:
</p>
<ul class="org-ul">
<li>第1步、若为空树，直接返回false;</li>
<li>第2步、val的值小于树根结点的值，说明 val对应的结点不在根结点，也不在右子树上，则递归返回左子树的查找结果;</li>
<li>第3步、val的值大于树根结点的值，说明 val对应的结点不不在根结点，也不在左子树上，则递归返回右子树的查找结果;</li>
<li>第4步、直接返回true(无须等于判定，因为不小于、不大于必然是等等于)</li>
</ul>
</div>
</div>
<div id="outline-container-h:59be9ada-1308-40ff-96c2-16e2e6536147" class="outline-4">
<h4 id="h:59be9ada-1308-40ff-96c2-16e2e6536147"><a href="#h:59be9ada-1308-40ff-96c2-16e2e6536147">二叉搜索树的结点插入</a></h4>
<div class="outline-text-4" id="text-h:59be9ada-1308-40ff-96c2-16e2e6536147">
<p>
1、结点插入的概念
</p>
<ul class="org-ul">
<li>二叉搜索树的插入指的是将给定的值生成结点后，插入到树上的某个位置，并且保持这棵树还是二叉搜索树</li>
</ul>

<p>
2、结点插入图解
</p>
<ul class="org-ul">
<li>如图所示，代表的是将一个值为3的结点插入到一个二叉搜索树中。一开始，3比根结点5小，于是递归插入左子树;还是比子树的根结点4小，于是继续递归插入左子树;这时候比根结点2大，于是递归插入右子树，右子树为空，则直接生成一个值为3的结点，回溯结束插入。</li>
</ul>


<figure id="org79cae2c">
<img src="././images/img-2025102430.gif" alt="img-2025102430.gif" width="50%">

</figure>

<p>
3、结点插入的步骤
</p>

<p>
对于要插入的数val，从根结点出发，总共四种情况依次判断:
</p>
<ul class="org-ul">
<li>第1步、若为空树，则创建一个值为val的结点并且返回;</li>
<li>第2步、val的值小于树根结点的值，那么插入位置一定在左子树，递归执行插入左子树的过程，并且返回插入结果作为新的左子树;</li>
<li>第3步、val的值大于树根结点的值，那么插入位置一定在右子树，递归执行插入右子树的过程，并且返回插入结果作为新的右子树;</li>
<li>第4步、直接返回当前树的根结点;</li>
</ul>
</div>
</div>
<div id="outline-container-h:739bd582-223b-433c-bebd-7f07222b35a8" class="outline-4">
<h4 id="h:739bd582-223b-433c-bebd-7f07222b35a8"><a href="#h:739bd582-223b-433c-bebd-7f07222b35a8">二叉搜索树的结点删除</a></h4>
<div class="outline-text-4" id="text-h:739bd582-223b-433c-bebd-7f07222b35a8">
<p>
1、结点删除的概念
</p>
<ul class="org-ul">
<li>二叉搜索树的删除指的是在树上删除给定值的结点。</li>
</ul>

<p>
2、结点删除图解
</p>
<ul class="org-ul">
<li>如图所示，下图展示的是，从这棵树删除根结点5的过程。首先先，由于它有左右儿子结点，所以这个过程，根结点并不是真正的删除。而是从右子树中找到最小的结点6，替换根结点，并且从根结点为7的子树中删除6的过程。由于6没有子结点所以这个过程就直接结束了。</li>
</ul>


<figure id="org0b68c6d">
<img src="././images/img-2025102431.gif" alt="img-2025102431.gif" width="50%">

</figure>

<p>
3、结点删除的步骤
</p>

<p>
删除值为val的结点的过程，从根结点出发，总共七种情况依次判断:
</p>
<ul class="org-ul">
<li>第1步、如果当前结点为空，则直接返回空树。</li>
<li>第2步、如果要删除的值小于当前结点的值，则递归调用左子树进行纪吉点的删除</li>
<li>第3步、如果要删除的值大于当前结点的值，则递归调用右子树进行纪吉点的删除</li>
<li>第4步、如果当前结点是一个叶子结点，即它没有左子树和右子子树，那么删除该结点，并且返回空树。</li>
<li>第5步、如果当前结点只有右子树而没有左子树，那么删除当前结点并将右子树返回。</li>
<li>第6步、如果当前结点只有左子树而没有右子树，那么删除当前结点并将左子树返回</li>
<li>第7步、如果当前结点既有左子树又有右子树，那么找到当前结点右子树中的最小值结点(即最左边的结点)，将当前结点的值替换为这个最小值结点的值，然后递归地删除右子树中该最小值结点。</li>
</ul>
</div>
</div>
<div id="outline-container-h:9f2a7960-7f8a-4f48-90c1-19c033d8b2c9" class="outline-4">
<h4 id="h:9f2a7960-7f8a-4f48-90c1-19c033d8b2c9"><a href="#h:9f2a7960-7f8a-4f48-90c1-19c033d8b2c9">二叉搜索树的总结</a></h4>
<div class="outline-text-4" id="text-h:9f2a7960-7f8a-4f48-90c1-19c033d8b2c9">
<p>
纵观二叉搜索树的查找、插入和删除。完全取决于二叉搜索树的形状，如果是完全二叉树或者接近完全二叉树，则这三个过程都是O(log n)的，如果是斜树，则三个过程近似操作线性表，为O(n)。
</p>


<figure id="orgc65b89b">
<img src="././images/img_20251024_153405.png" alt="img_20251024_153405.png" width="50%">

</figure>


<figure id="orgc052f5c">
<img src="././images/img_20251024_153457.png" alt="img_20251024_153457.png" width="50%">

</figure>
</div>
</div>
</div>
<div id="outline-container-h:312ef4b6-7533-4677-827e-d66f439c5c81" class="outline-3">
<h3 id="h:312ef4b6-7533-4677-827e-d66f439c5c81"><a href="#h:312ef4b6-7533-4677-827e-d66f439c5c81">代码篇</a></h3>
<div class="outline-text-3" id="text-h:312ef4b6-7533-4677-827e-d66f439c5c81">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#26641;&#30340;&#32467;&#28857;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt; <span class="org-comment-delimiter">// </span><span class="org-comment">&#33410;&#28857;&#20013;&#30340;&#25968;&#25454;&#31867;&#22411;&#26159;&#33258;&#23450;&#20041;&#30340;&#65292;&#25152;&#20197;&#29992;template&#27169;&#26495;
</span><span class="org-keyword">struct</span> <span class="org-type">TreeNode</span> {
    <span class="org-type">T</span> <span class="org-variable-name">val</span>;
    <span class="org-type">TreeNode</span>* <span class="org-variable-name">left</span>;
    <span class="org-type">TreeNode</span>* <span class="org-variable-name">right</span>;
    <span class="org-function-name">TreeNode</span>():val(0), left(<span class="org-constant">NULL</span>), right(<span class="org-constant">NULL</span>){}
    <span class="org-function-name">TreeNode</span>(<span class="org-type">T</span> <span class="org-variable-name">x</span>):val(x), left(<span class="org-constant">NULL</span>), right(<span class="org-constant">NULL</span>) {}
};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#20108;&#21449;&#25628;&#32034;&#26641;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-keyword">class</span> <span class="org-type">BinarySearchTree</span> {
<span class="org-keyword">private</span>:
    <span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">root</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22686;&#21024;&#26597;&#12289;&#36941;&#21382;&#22768;&#26126;
</span>    <span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-function-name">insertNode</span>(<span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">node</span>, <span class="org-type">T</span> <span class="org-variable-name">value</span>);
    <span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-function-name">removeNode</span>(<span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">node</span>, <span class="org-type">T</span> <span class="org-variable-name">value</span>);
    <span class="org-type">bool</span> <span class="org-function-name">searchNode</span>(<span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">node</span>, <span class="org-type">T</span> <span class="org-variable-name">value</span>);
    <span class="org-type">void</span> <span class="org-function-name">inOrder</span>(<span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">node</span>);  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20108;&#21449;&#25628;&#32034;&#26641;&#30340;&#20013;&#24207;&#36941;&#21382;&#26159;&#36882;&#22686;&#30340;&#24207;&#21015;&#65292;&#36890;&#36807;&#20123;&#20989;&#25968;&#21487;&#20197;&#30830;&#35748;&#26641;&#26159;&#21542;&#23545;&#30340;
</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25913;&#65306;&#20808;&#21024;&#38500;&#65292;&#20877;&#28155;&#21152;&#22238;&#26469;
</span><span class="org-keyword">public</span>:
    <span class="org-function-name">BinarySearchTree</span>(): root(<span class="org-constant">NULL</span>){}
    ~<span class="org-function-name">BinarySearchTree</span>();

    <span class="org-type">void</span> <span class="org-function-name">insert</span>(<span class="org-type">T</span> <span class="org-variable-name">value</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;&#26681;&#33410;&#28857;&#21487;&#20197;&#24320;&#22987;&#25554;&#20837;&#65292;&#26641;&#30340;&#26681;&#33410;&#28857;&#20250;&#21464;
</span>        root = insertNode(root, value);
    }
    <span class="org-type">void</span> <span class="org-function-name">remove</span>(<span class="org-type">T</span> <span class="org-variable-name">value</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;&#20174;root&#24320;&#22987;&#65292;&#26681;&#33410;&#28857;&#21487;&#33021;&#20250;&#21464;
</span>        root = removeNode(root, value);
    }
    <span class="org-type">bool</span> <span class="org-function-name">search</span>(<span class="org-type">T</span> <span class="org-variable-name">value</span>) {
        <span class="org-keyword">return</span> searchNode(root, value);
    }

    <span class="org-type">void</span> <span class="org-function-name">inOrderTraversal</span>() {
        inOrder(root);
        cout &lt;&lt; endl;
    }
};
<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-constant">BinarySearchTree</span>&lt;<span class="org-type">T</span>&gt;::~<span class="org-function-name">BinarySearchTree</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#26512;&#26500;&#65306;&#38144;&#27585;&#25972;&#20010;&#26641;
</span>    <span class="org-keyword">while</span> (root) {
        remove(root-&gt;val);
    }
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-constant">BinarySearchTree</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">insertNode</span>(<span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">node</span>, <span class="org-type">T</span> <span class="org-variable-name">value</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25554;&#20837;&#23454;&#38469;&#19978;&#26159;&#36882;&#24402;&#30340;&#36807;&#31243;
</span>    <span class="org-keyword">if</span> (node == <span class="org-constant">NULL</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#20026;&#31354;&#65292;&#26032;&#24314;&#20010;&#33410;&#28857;
</span>        <span class="org-keyword">return</span> <span class="org-keyword">new</span> TreeNode&lt;<span class="org-type">T</span>&gt;(value);
    }
    <span class="org-keyword">if</span> (value &lt; node-&gt;val) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#25554;&#21040;&#24038;&#23376;&#26641;&#65292;&#24182;&#35753;&#24038;&#23376;&#26641;&#26469;&#25215;&#25509;
</span>        node-&gt;left = insertNode(node-&gt;left, value);
    }
    <span class="org-keyword">else</span> <span class="org-keyword">if</span> (value &gt; node-&gt;val) {
        node-&gt;right = insertNode(node-&gt;right, value);
    }
    <span class="org-keyword">return</span> node; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#31561;&#20110;&#24403;&#21069;&#20540;&#30452;&#25509;&#36820;&#22238;
</span>}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-constant">BinarySearchTree</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">removeNode</span>(<span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">node</span>, <span class="org-type">T</span> <span class="org-variable-name">value</span>) {
    <span class="org-keyword">if</span> (node == <span class="org-constant">NULL</span>) {
        <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
    }
    <span class="org-keyword">if</span> (value &lt; node-&gt;val) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#23567;&#20110;&#24403;&#21069;&#20540;&#26102;&#65292;&#21435;&#24038;&#23376;&#26641;&#21024;&#38500;
</span>        node-&gt;left = removeNode(node-&gt;left, value);
    }
    <span class="org-keyword">else</span> <span class="org-keyword">if</span> (value &gt; node-&gt;val) {
        node-&gt;right = removeNode(node-&gt;right, value);
    }
    <span class="org-keyword">else</span> {<span class="org-comment-delimiter">// </span><span class="org-comment">&#31561;&#20110;&#24403;&#21069;&#33410;&#28857;&#20540;&#26102;
</span>        <span class="org-keyword">if</span> (node-&gt;left == <span class="org-constant">NULL</span> &amp;&amp; node-&gt;right == <span class="org-constant">NULL</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#26159;&#21494;&#23376;&#33410;&#28857;&#26102;&#65292;&#30452;&#25509;&#21024;&#38500;&#65292;&#36820;&#22238;&#31354;&#26641;
</span>            <span class="org-keyword">delete</span> node;
            <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
        }
        <span class="org-keyword">else</span> <span class="org-keyword">if</span> (node-&gt;left == <span class="org-constant">NULL</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21482;&#26377;&#21491;&#33410;&#28857;&#26102;&#65292;&#20808;&#20445;&#23384;&#21491;&#23376;&#26641;&#65292;&#21024;&#38500;&#24403;&#21069;&#33410;&#28857;
</span>            <span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">rightChild</span> = node-&gt;right;
            <span class="org-keyword">delete</span> node;
            <span class="org-keyword">return</span> rightChild;
        }
        <span class="org-keyword">else</span> <span class="org-keyword">if</span> (node-&gt;right == <span class="org-constant">NULL</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21482;&#26377;&#24038;&#33410;&#28857;&#26102;&#65292;&#20808;&#20445;&#23384;&#24038;&#23376;&#26641;&#65292;&#21024;&#38500;&#24403;&#21069;&#33410;&#28857;
</span>            <span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">leftChild</span> = node-&gt;left;
            <span class="org-keyword">delete</span> node;
            <span class="org-keyword">return</span> leftChild;
        }
        <span class="org-keyword">else</span> { 
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21363;&#26377;&#24038;&#21491;&#23376;&#26641;&#26102;&#65292;&#20808;&#25343;&#21040;&#21491;&#23376;&#26641;&#65292;&#22312;&#21491;&#23376;&#26641;&#20013;&#25214;&#21040;&#24038;&#23376;&#26641;&#65292;&#25214;&#26368;&#23567;&#30340;&#20540;
</span>            <span class="org-comment-delimiter">// </span><span class="org-comment">&#25214;&#21040;&#21518;&#65292;&#25226;&#24403;&#21069;&#33410;&#28857;&#20540;&#26367;&#25442;&#65292;&#21024;&#38500;&#21491;&#33410;&#28857;
</span>            <span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">replacement</span> = node-&gt;right;
            <span class="org-keyword">while</span> (replacement-&gt;left) {
                replacement = replacement-&gt;left;
            }
            node-&gt;val = replacement-&gt;val;
            node-&gt;right = removeNode(node-&gt;right, replacement-&gt;val);
        }
    }
    <span class="org-keyword">return</span> node;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">bool</span> <span class="org-constant">BinarySearchTree</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">searchNode</span>(<span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">node</span>, <span class="org-type">T</span> <span class="org-variable-name">value</span>) {
    <span class="org-keyword">if</span> (node == <span class="org-constant">NULL</span>) {
        <span class="org-keyword">return</span> <span class="org-constant">false</span>;
    }

    <span class="org-keyword">if</span> (value &lt; node-&gt;val) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#23567;&#20110;&#24403;&#21069;&#20540;&#26102;&#65292;&#21435;&#24038;&#23376;&#26641;&#26597;
</span>        <span class="org-keyword">return</span> searchNode(node-&gt;left, value); 
    }<span class="org-keyword">else</span> <span class="org-keyword">if</span> (value &gt; node-&gt;val) {
        <span class="org-keyword">return</span> searchNode(node-&gt;right, value);
    }
    <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#31561;&#20110;&#24403;&#21069;&#33410;&#28857;&#20540;&#26102;&#65292;&#36820;&#22238;true
</span>}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">void</span> <span class="org-constant">BinarySearchTree</span>&lt;<span class="org-type">T</span>&gt;::<span class="org-function-name">inOrder</span>(<span class="org-type">TreeNode</span>&lt;<span class="org-type">T</span>&gt;* <span class="org-variable-name">node</span>) {
    <span class="org-keyword">if</span> (node) {
        inOrder(node-&gt;left);
        cout &lt;&lt; node-&gt;val &lt;&lt; <span class="org-string">','</span>;
        inOrder(node-&gt;right);
    }
}


<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">BinarySearchTree</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">bst</span>;

    bst.insert(50);
    bst.insert(30);
    bst.insert(70);
    bst.insert(40);
    bst.insert(80);
    bst.insert(80);
    bst.insert(80);
    bst.insert(60);
    bst.insert(100);

    bst.inOrderTraversal();
    cout &lt;&lt; bst.search(9090) &lt;&lt; endl;
    cout &lt;&lt; bst.search(100) &lt;&lt; endl;
    bst.remove(70);
    bst.inOrderTraversal();
    bst.insert(65);
    bst.inOrderTraversal();

    <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-text">30,40,50,60,70,80,100,                                                                                                  
0                                                                                                                       
1                                                                                                                       
30,40,50,60,80,100,                                                                                                     
30,40,50,60,65,80,100,  
</pre>
</div>
</div>
</div>
<div id="outline-container-h:f7407e44-af55-4e32-a9a3-dcecc493726c" class="outline-3">
<h3 id="h:f7407e44-af55-4e32-a9a3-dcecc493726c"><a href="#h:f7407e44-af55-4e32-a9a3-dcecc493726c">实战篇</a></h3>
<div class="outline-text-3" id="text-h:f7407e44-af55-4e32-a9a3-dcecc493726c">
</div>
<div id="outline-container-h:9342cda1-674f-4c4c-9100-9b1f76c67668" class="outline-4">
<h4 id="h:9342cda1-674f-4c4c-9100-9b1f76c67668"><a href="#h:9342cda1-674f-4c4c-9100-9b1f76c67668">核心代码模式</a></h4>
<div class="outline-text-4" id="text-h:9342cda1-674f-4c4c-9100-9b1f76c67668">
</div>
<div id="outline-container-h:c79e8f82-a6db-4d1b-83fe-e6c442d03f81" class="outline-5">
<h5 id="h:c79e8f82-a6db-4d1b-83fe-e6c442d03f81"><a href="#h:c79e8f82-a6db-4d1b-83fe-e6c442d03f81">1.二叉搜索树中的搜索</a></h5>
<div class="outline-text-5" id="text-h:c79e8f82-a6db-4d1b-83fe-e6c442d03f81">
<p>
<a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/description/">https://leetcode.cn/problems/search-in-a-binary-search-tree/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#23450;&#20108;&#21449;&#25628;&#32034;&#26641;&#65288;BST&#65289;&#30340;&#26681;&#33410;&#28857; root &#21644;&#19968;&#20010;&#25972;&#25968;&#20540; val&#12290;

&#20320;&#38656;&#35201;&#22312; BST &#20013;&#25214;&#21040;&#33410;&#28857;&#20540;&#31561;&#20110; val &#30340;&#33410;&#28857;&#12290; &#36820;&#22238;&#20197;&#35813;&#33410;&#28857;&#20026;&#26681;&#30340;&#23376;&#26641;&#12290; &#22914;&#26524;&#33410;&#28857;&#19981;&#23384;&#22312;&#65292;&#21017;&#36820;&#22238; null &#12290;


&#31034;&#20363; 1:
&#36755;&#20837;&#65306;root = [4,2,7,1,3], val = 2
&#36755;&#20986;&#65306;[2,1,3]

&#31034;&#20363; 2:
&#36755;&#20837;&#65306;root = [4,2,7,1,3], val = 5
&#36755;&#20986;&#65306;[]

&#25552;&#31034;&#65306;
&#26641;&#20013;&#33410;&#28857;&#25968;&#22312; [1, 5000] &#33539;&#22260;&#20869;
1 &lt;= Node.val &lt;= 107
root &#26159;&#20108;&#21449;&#25628;&#32034;&#26641;
1 &lt;= val &lt;= 107
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">TreeNode</span>* <span class="org-function-name">searchBST</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>, <span class="org-type">int</span> <span class="org-variable-name">val</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#35753;val&#19982;&#26641;&#26681;&#33410;&#28857;&#27604;&#36739;&#65292;&#23567;&#20110;&#21435;&#24038;&#23376;&#26641;&#25214;&#65292;&#22823;&#20110;&#21435;&#21491;&#23376;&#26641;&#25214;&#65292;&#31561;&#20110;&#21017;&#36820;&#22238;&#33410;&#28857;
</span>        <span class="org-keyword">if</span>(root == <span class="org-constant">NULL</span>) {
            <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
        }
        <span class="org-keyword">if</span> (val &lt; root-&gt;val) {
            <span class="org-keyword">return</span> searchBST(root-&gt;left, val);
        } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (val &gt; root-&gt;val) {
            <span class="org-keyword">return</span> searchBST(root-&gt;right, val);
        }
        <span class="org-keyword">return</span> root; 
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:a0e9cb6d-15d7-4c56-9f0a-cbf955e30d60" class="outline-5">
<h5 id="h:a0e9cb6d-15d7-4c56-9f0a-cbf955e30d60"><a href="#h:a0e9cb6d-15d7-4c56-9f0a-cbf955e30d60">2.二叉搜索树的范围和</a></h5>
<div class="outline-text-5" id="text-h:a0e9cb6d-15d7-4c56-9f0a-cbf955e30d60">
<p>
<a href="https://leetcode.cn/problems/range-sum-of-bst/description/">https://leetcode.cn/problems/range-sum-of-bst/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#23450;&#20108;&#21449;&#25628;&#32034;&#26641;&#30340;&#26681;&#32467;&#28857; root&#65292;&#36820;&#22238;&#20540;&#20301;&#20110;&#33539;&#22260; [low, high] &#20043;&#38388;&#30340;&#25152;&#26377;&#32467;&#28857;&#30340;&#20540;&#30340;&#21644;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;root = [10,5,15,3,7,null,18], low = 7, high = 15
&#36755;&#20986;&#65306;32

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10
&#36755;&#20986;&#65306;23

&#25552;&#31034;&#65306;
&#26641;&#20013;&#33410;&#28857;&#25968;&#30446;&#22312;&#33539;&#22260; [1, 2 * 104] &#20869;
1 &lt;= Node.val &lt;= 105
1 &lt;= low &lt;= high &lt;= 105
&#25152;&#26377; Node.val &#20114;&#19981;&#30456;&#21516;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">rangeSumBST</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>, <span class="org-type">int</span> <span class="org-variable-name">low</span>, <span class="org-type">int</span> <span class="org-variable-name">high</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;&#20219;&#20309;&#19968;&#20010;&#25968;&#65292;&#24038;&#23376;&#26641;&#28385;&#36275;&#26465;&#20214;&#30340;&#21644;&#35745;&#31639;&#20986;&#26469;&#65292;&#21516;&#26679;&#21491;&#23376;&#26641;&#30340;&#21644;&#35745;&#31639;&#20986;&#26469;&#65292;&#28982;&#21518;&#26681;&#33410;&#28857;&#26412;&#36523;&#65292;&#36820;&#22238;&#21644;
</span>        <span class="org-keyword">if</span>(root == <span class="org-constant">NULL</span>) {
            <span class="org-keyword">return</span> 0;
        }
        <span class="org-type">int</span> <span class="org-variable-name">sum</span> = 0;
        <span class="org-keyword">if</span>(low &lt;=root-&gt;val &amp;&amp; root-&gt;val &lt;= high) {
            sum += root-&gt;val;
        }
        sum += rangeSumBST(root-&gt;left, low, high);
        sum += rangeSumBST(root-&gt;right, low, high);
        <span class="org-keyword">return</span> sum;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:c70791b1-5aa3-4a07-b881-eb7bb36d9d88" class="outline-5">
<h5 id="h:c70791b1-5aa3-4a07-b881-eb7bb36d9d88"><a href="#h:c70791b1-5aa3-4a07-b881-eb7bb36d9d88">3.将有序数组转换为二叉搜索树</a></h5>
<div class="outline-text-5" id="text-h:c70791b1-5aa3-4a07-b881-eb7bb36d9d88">
<p>
<a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#25972;&#25968;&#25968;&#32452; nums &#65292;&#20854;&#20013;&#20803;&#32032;&#24050;&#32463;&#25353; &#21319;&#24207; &#25490;&#21015;&#65292;&#35831;&#20320;&#23558;&#20854;&#36716;&#25442;&#20026;&#19968;&#26869; &#24179;&#34913; &#20108;&#21449;&#25628;&#32034;&#26641;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;nums = [-10,-3,0,5,9]
&#36755;&#20986;&#65306;[0,-3,9,-10,null,5]
&#35299;&#37322;&#65306;[0,-10,5,null,-3,null,9] &#20063;&#23558;&#34987;&#35270;&#20026;&#27491;&#30830;&#31572;&#26696;&#65306;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;nums = [1,3]
&#36755;&#20986;&#65306;[3,1]
&#35299;&#37322;&#65306;[1,null,3] &#21644; [3,1] &#37117;&#26159;&#39640;&#24230;&#24179;&#34913;&#20108;&#21449;&#25628;&#32034;&#26641;&#12290;

&#25552;&#31034;&#65306;
1 &lt;= nums.length &lt;= 104
-104 &lt;= nums[i] &lt;= 104
nums &#25353; &#20005;&#26684;&#36882;&#22686; &#39034;&#24207;&#25490;&#21015;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-type">TreeNode</span>* <span class="org-function-name">sortedArray</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>, <span class="org-type">int</span> <span class="org-variable-name">l</span>, <span class="org-type">int</span> <span class="org-variable-name">r</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21019;&#24314;&#25968;&#32452;&#65292;l, r&#34920;&#31034;&#25968;&#32452;&#30340;&#21306;&#38388;
</span>        <span class="org-keyword">if</span>(l &gt; r) {
            <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
        }
        <span class="org-type">int</span> <span class="org-variable-name">mid</span> = (l + r)/2; <span class="org-comment-delimiter">// </span><span class="org-comment">&#19979;&#26631;&#23545;&#24212;&#30340;&#20540;
</span>        <span class="org-type">TreeNode</span>* <span class="org-variable-name">node</span> = <span class="org-keyword">new</span> <span class="org-type">TreeNode</span>(<span class="org-type">nums</span>[mid]);
        node-&gt;left = sortedArray(<span class="org-type">nums</span>, l, mid-1); <span class="org-comment-delimiter">// </span><span class="org-comment">&#24038;&#36793;&#37096;&#20998;
</span>        node-&gt;right = sortedArray(<span class="org-type">nums</span>, mid+1, r); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21491;&#36793;&#37096;&#20998;
</span>        <span class="org-keyword">return</span> node;
    }
<span class="org-keyword">public</span>:
    <span class="org-type">TreeNode</span>* <span class="org-function-name">sortedArrayToBST</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#24179;&#34913;&#20108;&#21449;&#26641;&#65306;&#25351;&#35813;&#26641;&#25152;&#26377;&#33410;&#28857;&#30340;&#24038;&#21491;&#23376;&#26641;&#30340;&#39640;&#24230;&#30456;&#24046;&#19981;&#36229;&#36807; 1
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21482;&#35201;&#27599;&#27425;&#25214;&#19968;&#20010;&#25968;&#32452;&#30340;&#32456;&#28857;&#65292;&#25226;&#23427;&#30340;&#32456;&#28857;&#24038;&#36793;&#21464;&#25104;&#26641;&#65292;&#21491;&#36793;&#21464;&#25104;&#26641;&#65292;&#20877;&#36882;&#24402;&#21019;&#24314;
</span>        <span class="org-keyword">return</span> sortedArray(<span class="org-type">nums</span>, 0, nums.size()-1);
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:44ba654a-bd2f-4f23-af4e-ea9ac942c0dc" class="outline-5">
<h5 id="h:44ba654a-bd2f-4f23-af4e-ea9ac942c0dc"><a href="#h:44ba654a-bd2f-4f23-af4e-ea9ac942c0dc">4.验证二叉搜索树</a></h5>
<div class="outline-text-5" id="text-h:44ba654a-bd2f-4f23-af4e-ea9ac942c0dc">
<p>
<a href="https://leetcode.cn/problems/validate-binary-search-tree/description/">https://leetcode.cn/problems/validate-binary-search-tree/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#20108;&#21449;&#26641;&#30340;&#26681;&#33410;&#28857; root &#65292;&#21028;&#26029;&#20854;&#26159;&#21542;&#26159;&#19968;&#20010;&#26377;&#25928;&#30340;&#20108;&#21449;&#25628;&#32034;&#26641;&#12290;

&#26377;&#25928; &#20108;&#21449;&#25628;&#32034;&#26641;&#23450;&#20041;&#22914;&#19979;&#65306;

&#33410;&#28857;&#30340;&#24038;&#23376;&#26641;&#21482;&#21253;&#21547; &#20005;&#26684;&#23567;&#20110; &#24403;&#21069;&#33410;&#28857;&#30340;&#25968;&#12290;
&#33410;&#28857;&#30340;&#21491;&#23376;&#26641;&#21482;&#21253;&#21547; &#20005;&#26684;&#22823;&#20110; &#24403;&#21069;&#33410;&#28857;&#30340;&#25968;&#12290;
&#25152;&#26377;&#24038;&#23376;&#26641;&#21644;&#21491;&#23376;&#26641;&#33258;&#36523;&#24517;&#39035;&#20063;&#26159;&#20108;&#21449;&#25628;&#32034;&#26641;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;root = [2,1,3]
&#36755;&#20986;&#65306;true

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;root = [5,1,4,null,null,3,6]
&#36755;&#20986;&#65306;false
&#35299;&#37322;&#65306;&#26681;&#33410;&#28857;&#30340;&#20540;&#26159; 5 &#65292;&#20294;&#26159;&#21491;&#23376;&#33410;&#28857;&#30340;&#20540;&#26159; 4 &#12290;

&#25552;&#31034;&#65306;
&#26641;&#20013;&#33410;&#28857;&#25968;&#30446;&#33539;&#22260;&#22312;[1, 104] &#20869;
-231 &lt;= Node.val &lt;= 231 - 1
</pre>
</div>


<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">ret</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#32467;&#26524;&#25968;&#32452;&#65292;&#23384;&#20648;&#20102;&#20013;&#24207;&#36941;&#21382;&#30340;&#32467;&#26524;
</span>    <span class="org-type">void</span> <span class="org-function-name">inOrder</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-keyword">if</span>(root) {
            inOrder(root-&gt;left);
            <span class="org-comment-delimiter">// </span><span class="org-comment">... &#25226;&#26681;&#32467;&#28857;&#30340;&#20540;&#25918;&#20837;&#32467;&#26524;&#25968;&#32452;&#20013;
</span>            ret.push_back(root-&gt;val);
            inOrder(root-&gt;right);
        }
    }
<span class="org-keyword">public</span>:
    <span class="org-type">bool</span> <span class="org-function-name">isValidBST</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#20013;&#24207;&#36941;&#21382;&#19968;&#23450;&#30340;&#26159;&#21333;&#35843;&#36882;&#22686;&#24207;&#21015;&#65292;&#21028;&#23450;&#20803;&#32032;
</span>        ret.clear();
        inOrder(root);
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 1; i &lt; ret.size(); ++i) {
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#21028;&#26029;&#26159;&#21542;&#21333;&#35843;&#36882;&#22686;
</span>            <span class="org-keyword">if</span>(ret[i] &lt;= ret[i-1]) {
                <span class="org-keyword">return</span> <span class="org-constant">false</span>;
            }
        }
        <span class="org-keyword">return</span> <span class="org-constant">true</span>;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:c3c4c673-329d-4687-a8a9-5d47f4d8cbc3" class="outline-5">
<h5 id="h:c3c4c673-329d-4687-a8a9-5d47f4d8cbc3"><a href="#h:c3c4c673-329d-4687-a8a9-5d47f4d8cbc3">5.递增顺序搜索树(重要)</a></h5>
<div class="outline-text-5" id="text-h:c3c4c673-329d-4687-a8a9-5d47f4d8cbc3">
<p>
<a href="https://leetcode.cn/problems/NYBBNL/description/">https://leetcode.cn/problems/NYBBNL/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#26869;&#20108;&#21449;&#25628;&#32034;&#26641;&#65292;&#35831; &#25353;&#20013;&#24207;&#36941;&#21382; &#23558;&#20854;&#37325;&#26032;&#25490;&#21015;&#20026;&#19968;&#26869;&#36882;&#22686;&#39034;&#24207;&#25628;&#32034;&#26641;&#65292;
&#20351;&#26641;&#20013;&#26368;&#24038;&#36793;&#30340;&#33410;&#28857;&#25104;&#20026;&#26641;&#30340;&#26681;&#33410;&#28857;&#65292;&#24182;&#19988;&#27599;&#20010;&#33410;&#28857;&#27809;&#26377;&#24038;&#23376;&#33410;&#28857;&#65292;&#21482;&#26377;&#19968;&#20010;&#21491;&#23376;&#33410;&#28857;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;root = [5,3,6,2,4,null,8,1,null,null,null,7,9]
&#36755;&#20986;&#65306;[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;root = [5,1,7]
&#36755;&#20986;&#65306;[1,null,5,null,7]

&#25552;&#31034;&#65306;
&#26641;&#20013;&#33410;&#28857;&#25968;&#30340;&#21462;&#20540;&#33539;&#22260;&#26159; [1, 100]
0 &lt;= Node.val &lt;= 1000
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">ret</span>;
    <span class="org-type">void</span> <span class="org-function-name">inorder</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-keyword">if</span>(root){
            inorder(root-&gt;left);
            ret.push_back(root-&gt;val);
            inorder(root-&gt;right);
        }
    }
<span class="org-keyword">public</span>:
    <span class="org-type">TreeNode</span>* <span class="org-function-name">increasingBST</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#20108;&#21449;&#26641;&#19968;&#23450;&#26159;&#21333;&#35843;&#36882;&#22686;&#30340;&#65292;&#21487;&#20197;&#20808;&#25226;&#23427;&#20013;&#24207;&#36941;&#21382;&#23384;&#20648;&#21040;vector&#20013;&#65292;&#28982;&#21518;&#36890;&#36807;vector&#26500;&#36896;&#38142;&#34920;
</span>        ret.clear();
        inorder(root);
        <span class="org-type">TreeNode</span>* <span class="org-variable-name">head</span> = <span class="org-keyword">new</span> <span class="org-type">TreeNode</span>(-1);
        <span class="org-type">TreeNode</span>* <span class="org-variable-name">curr</span> = head;    <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#24403;&#21069;&#30340;&#28216;&#26631;
</span>        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; ret.size(); ++i) {
            <span class="org-type">TreeNode</span>* <span class="org-variable-name">t</span> = <span class="org-keyword">new</span> <span class="org-type">TreeNode</span>(<span class="org-type">ret</span>[i]);
            curr-&gt;right = t;
            curr = t;
        }
        <span class="org-keyword">return</span> head-&gt;right;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:948287a7-8abf-4254-acaa-aa371fe940ba" class="outline-5">
<h5 id="h:948287a7-8abf-4254-acaa-aa371fe940ba"><a href="#h:948287a7-8abf-4254-acaa-aa371fe940ba">6.递增顺序搜索树迭代</a></h5>
<div class="outline-text-5" id="text-h:948287a7-8abf-4254-acaa-aa371fe940ba">
<p>
<a href="https://leetcode.cn/problems/increasing-order-search-tree/description/">https://leetcode.cn/problems/increasing-order-search-tree/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-type">TreeNode</span>* <span class="org-variable-name">curr</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#34920;&#31034;&#24403;&#21069;&#38142;&#34920;&#30340;&#28216;&#26631;
</span>    <span class="org-type">void</span> <span class="org-function-name">inorder</span> (<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-keyword">if</span> (root) {
            inorder(root-&gt;left);

            curr-&gt;right = root;
            curr-&gt;left = <span class="org-constant">nullptr</span>;
            curr = root;  <span class="org-comment-delimiter">// </span><span class="org-comment">curr&#21521;&#21069;&#36208;
</span>            
            inorder(root-&gt;right);
        }

    }
<span class="org-keyword">public</span>:
    <span class="org-type">TreeNode</span>* <span class="org-function-name">increasingBST</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-type">TreeNode</span>* <span class="org-variable-name">head</span> = <span class="org-keyword">new</span> <span class="org-type">TreeNode</span>(-1);
        curr = head;
        inorder(root);
        <span class="org-keyword">return</span> head-&gt;right;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:d80416dc-4ec6-4d3b-af14-e35bc433d4f0" class="outline-5">
<h5 id="h:d80416dc-4ec6-4d3b-af14-e35bc433d4f0"><a href="#h:d80416dc-4ec6-4d3b-af14-e35bc433d4f0">7.二叉搜索树的最小绝对差</a></h5>
<div class="outline-text-5" id="text-h:d80416dc-4ec6-4d3b-af14-e35bc433d4f0">
<p>
<a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/">https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#20108;&#21449;&#25628;&#32034;&#26641;&#30340;&#26681;&#33410;&#28857; root &#65292;&#36820;&#22238; &#26641;&#20013;&#20219;&#24847;&#20004;&#19981;&#21516;&#33410;&#28857;&#20540;&#20043;&#38388;&#30340;&#26368;&#23567;&#24046;&#20540; &#12290;

&#24046;&#20540;&#26159;&#19968;&#20010;&#27491;&#25968;&#65292;&#20854;&#25968;&#20540;&#31561;&#20110;&#20004;&#20540;&#20043;&#24046;&#30340;&#32477;&#23545;&#20540;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;root = [4,2,6,1,3]
&#36755;&#20986;&#65306;1

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;root = [1,0,48,null,null,12,49]
&#36755;&#20986;&#65306;1

&#25552;&#31034;&#65306;
&#26641;&#20013;&#33410;&#28857;&#30340;&#25968;&#30446;&#33539;&#22260;&#26159; [2, 104]
0 &lt;= Node.val &lt;= 105
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-type">int</span> <span class="org-variable-name">pre</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#35760;&#24405;&#21069;&#19968;&#20010;&#25968;&#26159;&#22810;&#23569;
</span>    <span class="org-type">int</span> <span class="org-variable-name">ret</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#32467;&#26524;
</span>    <span class="org-type">void</span> <span class="org-function-name">inorder</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-keyword">if</span>(root) {
            inorder(root-&gt;left);
            ret = min(ret, (root-&gt;val - pre)); <span class="org-comment-delimiter">// </span><span class="org-comment">&#30456;&#37051;&#20004;&#25968;&#24046;
</span>            pre = root-&gt;val;
            inorder(root-&gt;right);
        }
    }
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">getMinimumDifference</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#22240;&#20026;&#26159;&#20108;&#21449;&#26641;&#65292;&#25152;&#20197;&#21487;&#20197;&#36890;&#36807;&#20013;&#24207;&#36941;&#21382;&#24471;&#21040;&#21333;&#35843;&#36882;&#22686;&#30340;&#24207;&#21015;&#12290;&#20004;&#20010;&#25968;&#30340;&#24046;&#20540;&#19968;&#23450;&#21457;&#29983;&#22312;&#30456;&#37051;&#20457;&#25968;
</span>        pre = -10000000; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#21270;&#20026;&#38750;&#24120;&#23567;&#30340;&#25968;
</span>        ret = 10000000;
        inorder(root);
        <span class="org-keyword">return</span> ret;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:be3cc70d-066d-42e4-a143-4c22e729d883" class="outline-5">
<h5 id="h:be3cc70d-066d-42e4-a143-4c22e729d883"><a href="#h:be3cc70d-066d-42e4-a143-4c22e729d883">8.两数之和 IV - 输入二叉搜索树</a></h5>
<div class="outline-text-5" id="text-h:be3cc70d-066d-42e4-a143-4c22e729d883">
<div class="org-src-container">
<pre class="src src-text">&#32473;&#23450;&#19968;&#20010;&#20108;&#21449;&#25628;&#32034;&#26641; root &#21644;&#19968;&#20010;&#30446;&#26631;&#32467;&#26524; k&#65292;&#22914;&#26524;&#20108;&#21449;&#25628;&#32034;&#26641;&#20013;&#23384;&#22312;&#20004;&#20010;&#20803;&#32032;&#19988;&#23427;&#20204;&#30340;&#21644;&#31561;&#20110;&#32473;&#23450;&#30340;&#30446;&#26631;&#32467;&#26524;&#65292;&#21017;&#36820;&#22238; true&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;: root = [5,3,6,2,4,null,7], k = 9
&#36755;&#20986;: true

&#31034;&#20363; 2&#65306;
&#36755;&#20837;: root = [5,3,6,2,4,null,7], k = 28
&#36755;&#20986;: false

&#25552;&#31034;:
&#20108;&#21449;&#26641;&#30340;&#33410;&#28857;&#20010;&#25968;&#30340;&#33539;&#22260;&#26159;  [1, 104].
-104 &lt;= Node.val &lt;= 104
&#39064;&#30446;&#25968;&#25454;&#20445;&#35777;&#65292;&#36755;&#20837;&#30340; root &#26159;&#19968;&#26869; &#26377;&#25928; &#30340;&#20108;&#21449;&#25628;&#32034;&#26641;
-105 &lt;= k &lt;= 105
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">ret</span>;
    <span class="org-type">void</span> <span class="org-function-name">inorder</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-keyword">if</span> (root) {
            inorder(root-&gt;left);
            ret.push_back(root-&gt;val);
            inorder(root-&gt;right);
        }
    }
<span class="org-keyword">public</span>:
    <span class="org-type">bool</span> <span class="org-function-name">findTarget</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>, <span class="org-type">int</span> <span class="org-variable-name">k</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#38024;&#23545;&#20457;&#20010;&#24050;&#32463;&#25490;&#22909;&#24207;&#30340;&#26641;&#65292;&#21487;&#20197;&#29992;&#21452;&#25351;&#38024;&#26469;&#20570;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#20808;&#20013;&#24207;&#36941;&#21382;
</span>        ret.clear();
        inorder(root);
        <span class="org-type">int</span> <span class="org-variable-name">l</span> = 0, <span class="org-variable-name">r</span> = ret.size() -1;
        <span class="org-keyword">while</span>(l &lt; r) {
            <span class="org-type">int</span> <span class="org-variable-name">sum</span> = ret[l] + ret[r];
            <span class="org-keyword">if</span>(sum &gt; k) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#27492;&#26102;&#65292;&#21491;&#25351;&#38024;&#21521;&#24038;&#31227;&#21160;
</span>                --r;
            }<span class="org-keyword">else</span> <span class="org-keyword">if</span>(sum &lt; k ) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#27492;&#26102;&#65292;&#24038;&#25351;&#38024;&#21521;&#21491;&#31227;&#21160;
</span>                ++l;
            }<span class="org-keyword">else</span> {
                <span class="org-keyword">return</span> <span class="org-constant">true</span>;
            }
        }
        <span class="org-keyword">return</span> <span class="org-constant">false</span>;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:04b0778f-ad21-4434-8a0d-90bd801499fa" class="outline-5">
<h5 id="h:04b0778f-ad21-4434-8a0d-90bd801499fa"><a href="#h:04b0778f-ad21-4434-8a0d-90bd801499fa">9.二叉搜索树中的众数</a></h5>
<div class="outline-text-5" id="text-h:04b0778f-ad21-4434-8a0d-90bd801499fa">
<p>
<a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">https://leetcode.cn/problems/find-mode-in-binary-search-tree/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#21547;&#37325;&#22797;&#20540;&#30340;&#20108;&#21449;&#25628;&#32034;&#26641;&#65288;BST&#65289;&#30340;&#26681;&#33410;&#28857; root &#65292;&#25214;&#20986;&#24182;&#36820;&#22238; BST &#20013;&#30340;&#25152;&#26377; &#20247;&#25968;&#65288;&#21363;&#65292;&#20986;&#29616;&#39057;&#29575;&#26368;&#39640;&#30340;&#20803;&#32032;&#65289;&#12290;

&#22914;&#26524;&#26641;&#20013;&#26377;&#19981;&#27490;&#19968;&#20010;&#20247;&#25968;&#65292;&#21487;&#20197;&#25353; &#20219;&#24847;&#39034;&#24207; &#36820;&#22238;&#12290;

&#20551;&#23450; BST &#28385;&#36275;&#22914;&#19979;&#23450;&#20041;&#65306;

&#32467;&#28857;&#24038;&#23376;&#26641;&#20013;&#25152;&#21547;&#33410;&#28857;&#30340;&#20540; &#23567;&#20110;&#31561;&#20110; &#24403;&#21069;&#33410;&#28857;&#30340;&#20540;
&#32467;&#28857;&#21491;&#23376;&#26641;&#20013;&#25152;&#21547;&#33410;&#28857;&#30340;&#20540; &#22823;&#20110;&#31561;&#20110; &#24403;&#21069;&#33410;&#28857;&#30340;&#20540;
&#24038;&#23376;&#26641;&#21644;&#21491;&#23376;&#26641;&#37117;&#26159;&#20108;&#21449;&#25628;&#32034;&#26641;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;root = [1,null,2,2]
&#36755;&#20986;&#65306;[2]

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;root = [0]
&#36755;&#20986;&#65306;[0]

&#25552;&#31034;&#65306;
&#26641;&#20013;&#33410;&#28857;&#30340;&#25968;&#30446;&#22312;&#33539;&#22260; [1, 104] &#20869;
-105 &lt;= Node.val &lt;= 105
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">ret</span>;
    <span class="org-type">int</span> <span class="org-variable-name">pre</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20013;&#24207;&#36941;&#21382;&#21069;&#19968;&#20010;&#25968;&#65292;&#21021;&#22987;&#21270;&#20026;&#38750;&#24120;&#23567;&#30340;&#25968;
</span>    <span class="org-type">int</span> <span class="org-variable-name">cnt</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#35745;&#25968;&#22120;&#65292;&#21644;&#24403;&#21069;&#25968;&#30456;&#31561;&#30340;&#25968;&#24635;&#20849;&#20986;&#29616;&#27425;&#25968;
</span>    <span class="org-type">int</span> <span class="org-variable-name">maxCnt</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26368;&#22810;&#20986;&#29616;&#30340;&#27425;&#25968;
</span>    <span class="org-type">void</span> <span class="org-function-name">visit</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-keyword">if</span>(root-&gt;val == pre) {
           ++cnt; 
        }<span class="org-keyword">else</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#19981;&#30456;&#31561;&#65292;pre&#25913;&#20026;&#24403;&#21069;&#25968;&#65292;cnt&#21464;&#20026;1
</span>            pre = root-&gt;val;
            cnt = 1;
        }
        <span class="org-keyword">if</span>(cnt &gt; maxCnt) {
            maxCnt = cnt;
            ret.clear();
            ret.push_back(root-&gt;val);
        }<span class="org-keyword">else</span> <span class="org-keyword">if</span> (cnt == maxCnt) {
            ret.push_back(root-&gt;val);
        }
    }

    <span class="org-type">void</span> <span class="org-function-name">inorder</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-keyword">if</span>(root) {
            inorder(root-&gt;left);
            visit(root);
            inorder(root-&gt;right);
        }
    }
<span class="org-keyword">public</span>:
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-function-name">findMode</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#30456;&#31561;&#30340;&#25968;&#19968;&#23450;&#26159;&#30456;&#37051;&#30340;
</span>        ret.clear();
        pre = -100000; 
        maxCnt = cnt = 0; <span class="org-comment-delimiter">// </span><span class="org-comment">&#37117;&#21021;&#22987;&#21270;&#20026;0
</span>        inorder(root);

        <span class="org-keyword">return</span> ret;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:15ed2412-1ae7-405f-9b72-50cfd4099ad3" class="outline-5">
<h5 id="h:15ed2412-1ae7-405f-9b72-50cfd4099ad3"><a href="#h:15ed2412-1ae7-405f-9b72-50cfd4099ad3">10.恢复二叉搜索树</a></h5>
<div class="outline-text-5" id="text-h:15ed2412-1ae7-405f-9b72-50cfd4099ad3">
<p>
<a href="https://leetcode.cn/problems/recover-binary-search-tree/">https://leetcode.cn/problems/recover-binary-search-tree/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#20108;&#21449;&#25628;&#32034;&#26641;&#30340;&#26681;&#33410;&#28857; root &#65292;&#35813;&#26641;&#20013;&#30340; &#24688;&#22909; &#20004;&#20010;&#33410;&#28857;&#30340;&#20540;&#34987;&#38169;&#35823;&#22320;&#20132;&#25442;&#12290;&#35831;&#22312;&#19981;&#25913;&#21464;&#20854;&#32467;&#26500;&#30340;&#24773;&#20917;&#19979;&#65292;&#24674;&#22797;&#36825;&#26869;&#26641; &#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;root = [1,3,null,null,2]
&#36755;&#20986;&#65306;[3,1,null,null,2]
&#35299;&#37322;&#65306;3 &#19981;&#33021;&#26159; 1 &#30340;&#24038;&#23401;&#23376;&#65292;&#22240;&#20026; 3 &gt; 1 &#12290;&#20132;&#25442; 1 &#21644; 3 &#20351;&#20108;&#21449;&#25628;&#32034;&#26641;&#26377;&#25928;&#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;root = [3,1,4,null,null,2]
&#36755;&#20986;&#65306;[2,1,4,null,null,3]
&#35299;&#37322;&#65306;2 &#19981;&#33021;&#22312; 3 &#30340;&#21491;&#23376;&#26641;&#20013;&#65292;&#22240;&#20026; 2 &lt; 3 &#12290;&#20132;&#25442; 2 &#21644; 3 &#20351;&#20108;&#21449;&#25628;&#32034;&#26641;&#26377;&#25928;&#12290;

&#25552;&#31034;&#65306;
&#26641;&#19978;&#33410;&#28857;&#30340;&#25968;&#30446;&#22312;&#33539;&#22260; [2, 1000] &#20869;
-231 &lt;= Node.val &lt;= 231 - 1
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-type">vector</span>&lt;<span class="org-type">TreeNode</span>*&gt; <span class="org-variable-name">ret</span>;
    <span class="org-type">void</span> <span class="org-function-name">inorder</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-keyword">if</span>(root) {
            inorder(root-&gt;left);
            ret.push_back(root);
            inorder(root-&gt;right);
        }
    }
<span class="org-keyword">public</span>:
    <span class="org-comment-delimiter">// </span><span class="org-comment">1 2 7 4 5 6 3
</span>    <span class="org-type">void</span> <span class="org-function-name">recoverTree</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        ret.clear();
        inorder(root);
        <span class="org-type">TreeNode</span>* <span class="org-variable-name">x</span> = <span class="org-constant">NULL</span>;
        <span class="org-type">TreeNode</span>* <span class="org-variable-name">y</span> = <span class="org-constant">NULL</span>;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; ret.size()-1; ++i) {
            <span class="org-keyword">if</span>(ret[i]-&gt;val &gt; ret[i+1]-&gt;val) {
                y = ret[i+1];
                <span class="org-keyword">if</span>(x == <span class="org-constant">NULL</span>) {
                    x = ret[i];
                }
            }
        }
        <span class="org-keyword">if</span>(<span class="org-type">x</span> &amp;&amp; <span class="org-variable-name">y</span>) {
            <span class="org-type">int</span> <span class="org-variable-name">tmp</span> = x-&gt;val;
            x-&gt;val = y-&gt;val;
            y-&gt;val = tmp;
        }
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:e56d5970-2e26-44ae-8d97-edfc2dd7a2e0" class="outline-5">
<h5 id="h:e56d5970-2e26-44ae-8d97-edfc2dd7a2e0"><a href="#h:e56d5970-2e26-44ae-8d97-edfc2dd7a2e0">11.删除二叉搜索树中的节点</a></h5>
<div class="outline-text-5" id="text-h:e56d5970-2e26-44ae-8d97-edfc2dd7a2e0">
<p>
<a href="https://leetcode.cn/problems/delete-node-in-a-bst/description/">https://leetcode.cn/problems/delete-node-in-a-bst/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#23450;&#19968;&#20010;&#20108;&#21449;&#25628;&#32034;&#26641;&#30340;&#26681;&#33410;&#28857; root &#21644;&#19968;&#20010;&#20540; key&#65292;&#21024;&#38500;&#20108;&#21449;&#25628;&#32034;&#26641;&#20013;&#30340; key &#23545;&#24212;&#30340;&#33410;&#28857;&#65292;
&#24182;&#20445;&#35777;&#20108;&#21449;&#25628;&#32034;&#26641;&#30340;&#24615;&#36136;&#19981;&#21464;&#12290;&#36820;&#22238;&#20108;&#21449;&#25628;&#32034;&#26641;&#65288;&#26377;&#21487;&#33021;&#34987;&#26356;&#26032;&#65289;&#30340;&#26681;&#33410;&#28857;&#30340;&#24341;&#29992;&#12290;

&#19968;&#33324;&#26469;&#35828;&#65292;&#21024;&#38500;&#33410;&#28857;&#21487;&#20998;&#20026;&#20004;&#20010;&#27493;&#39588;&#65306;

&#39318;&#20808;&#25214;&#21040;&#38656;&#35201;&#21024;&#38500;&#30340;&#33410;&#28857;&#65307;
&#22914;&#26524;&#25214;&#21040;&#20102;&#65292;&#21024;&#38500;&#23427;&#12290;

&#31034;&#20363; 1:
&#36755;&#20837;&#65306;root = [5,3,6,2,4,null,7], key = 3
&#36755;&#20986;&#65306;[5,4,6,2,null,null,7]
&#35299;&#37322;&#65306;&#32473;&#23450;&#38656;&#35201;&#21024;&#38500;&#30340;&#33410;&#28857;&#20540;&#26159; 3&#65292;&#25152;&#20197;&#25105;&#20204;&#39318;&#20808;&#25214;&#21040; 3 &#36825;&#20010;&#33410;&#28857;&#65292;&#28982;&#21518;&#21024;&#38500;&#23427;&#12290;
&#19968;&#20010;&#27491;&#30830;&#30340;&#31572;&#26696;&#26159; [5,4,6,2,null,null,7], &#22914;&#19979;&#22270;&#25152;&#31034;&#12290;
&#21478;&#19968;&#20010;&#27491;&#30830;&#31572;&#26696;&#26159; [5,2,6,null,4,null,7]&#12290;

&#31034;&#20363; 2:
&#36755;&#20837;: root = [5,3,6,2,4,null,7], key = 0
&#36755;&#20986;: [5,3,6,2,4,null,7]
&#35299;&#37322;: &#20108;&#21449;&#26641;&#19981;&#21253;&#21547;&#20540;&#20026; 0 &#30340;&#33410;&#28857;

&#31034;&#20363; 3:
&#36755;&#20837;: root = [], key = 0
&#36755;&#20986;: []

&#25552;&#31034;:
&#33410;&#28857;&#25968;&#30340;&#33539;&#22260; [0, 104].
-105 &lt;= Node.val &lt;= 105
&#33410;&#28857;&#20540;&#21807;&#19968;
root &#26159;&#21512;&#27861;&#30340;&#20108;&#21449;&#25628;&#32034;&#26641;
-105 &lt;= key &lt;= 105
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-type">int</span> <span class="org-function-name">findMin</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-keyword">if</span>(root-&gt;left) {
            <span class="org-keyword">return</span> findMin(root-&gt;left);
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#24038;&#23376;&#26641;&#27809;&#26377;&#65292;&#35828;&#26126;&#24403;&#21069;&#33410;&#28857;&#30340;&#20540;&#23601;&#26159;&#26368;&#23567;&#20540;
</span>        <span class="org-keyword">return</span> root-&gt;val;
    }

    <span class="org-type">TreeNode</span>* <span class="org-function-name">delRoot</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-keyword">if</span>(root-&gt;left == <span class="org-constant">NULL</span>) {
            <span class="org-type">TreeNode</span>* <span class="org-variable-name">delNode</span> = root;        <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#19968;&#20010;&#35201;&#21024;&#38500;&#30340;&#33410;&#28857;
</span>            <span class="org-type">TreeNode</span>* <span class="org-variable-name">retNode</span> = root-&gt;right; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36820;&#22238;&#30340;&#33410;&#28857;
</span>            <span class="org-keyword">delete</span> delNode;                  <span class="org-comment-delimiter">// </span><span class="org-comment">&#28165;&#29702;&#20869;&#23384;
</span>            <span class="org-keyword">return</span> retNode;
        }<span class="org-keyword">else</span> <span class="org-keyword">if</span> (root-&gt;right == <span class="org-constant">NULL</span>) {
            <span class="org-type">TreeNode</span>* <span class="org-variable-name">delNode</span> = root;        <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#19968;&#20010;&#35201;&#21024;&#38500;&#30340;&#33410;&#28857;
</span>            <span class="org-type">TreeNode</span>* <span class="org-variable-name">retNode</span> = root-&gt;left;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36820;&#22238;&#30340;&#33410;&#28857;, &#24038;&#23376;&#26641;&#35201;&#32487;&#25215;
</span>            <span class="org-keyword">delete</span> delNode;                  <span class="org-comment-delimiter">// </span><span class="org-comment">&#28165;&#29702;&#20869;&#23384;
</span>            <span class="org-keyword">return</span> retNode;
        }<span class="org-keyword">else</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#37117;&#38750;&#31354;
</span>            <span class="org-type">TreeNode</span>* <span class="org-variable-name">retNode</span> = <span class="org-keyword">new</span> <span class="org-type">TreeNode</span>(0);
            retNode-&gt;val = findMin(root-&gt;right); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21491;&#23376;&#26641;&#20013;&#30340;&#26368;&#23567;&#30340;&#20540;
</span>            retNode-&gt;right = deleteNode(root-&gt;right, retNode-&gt;val); <span class="org-comment-delimiter">// </span><span class="org-comment">&#22312;&#21491;&#23376;&#26641;&#20013;&#21024;&#38500;&#23567;&#26368;&#20540;&#65292;&#24182;&#36820;&#22238;&#21491;&#23376;&#26641;
</span>            retNode-&gt;left = root-&gt;left;
            <span class="org-keyword">return</span> retNode;
        }
        <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
    }
<span class="org-keyword">public</span>:
    <span class="org-type">TreeNode</span>* <span class="org-function-name">deleteNode</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>, <span class="org-type">int</span> <span class="org-variable-name">key</span>) {
        <span class="org-keyword">if</span>(root == <span class="org-constant">NULL</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;&#31354;&#26641;&#65292;&#19981;&#38656;&#35201;&#21024;&#38500;
</span>            <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
        }
        <span class="org-keyword">if</span>(key &lt; root-&gt;val) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#27492;&#26102;&#65292;&#22312;&#24038;&#23376;&#26641;&#21024;&#38500;
</span>            root-&gt;left = deleteNode(root-&gt;left, key);
        }<span class="org-keyword">else</span> <span class="org-keyword">if</span> (key &gt; root-&gt;val) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#27492;&#26102;&#65292;&#22312;&#21491;&#23376;&#26641;&#36827;&#34892;&#21024;&#38500;
</span>            root-&gt;right = deleteNode(root-&gt;right, key);
        }<span class="org-keyword">else</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">key == root-&gt;val&#26102;&#65292;&#20174;&#26681;&#33410;&#28857;&#21024;&#38500;
</span>            <span class="org-keyword">return</span> delRoot(root);
        }
        <span class="org-keyword">return</span> root;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:164f0d0c-4afe-4bf9-b7eb-3e64b5d766a9" class="outline-5">
<h5 id="h:164f0d0c-4afe-4bf9-b7eb-3e64b5d766a9"><a href="#h:164f0d0c-4afe-4bf9-b7eb-3e64b5d766a9">12.寻找二叉搜索树中的目标节点</a></h5>
<div class="outline-text-5" id="text-h:164f0d0c-4afe-4bf9-b7eb-3e64b5d766a9">
<p>
<a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#26576;&#20844;&#21496;&#32452;&#32455;&#26550;&#26500;&#20197;&#20108;&#21449;&#25628;&#32034;&#26641;&#24418;&#24335;&#35760;&#24405;&#65292;&#33410;&#28857;&#20540;&#20026;&#22788;&#20110;&#35813;&#32844;&#20301;&#30340;&#21592;&#24037;&#32534;&#21495;&#12290;&#35831;&#36820;&#22238;&#31532; cnt &#22823;&#30340;&#21592;&#24037;&#32534;&#21495;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;root = [7, 3, 9, 1, 5], cnt = 2
       7
      / \
     3   9
    / \
   1   5
&#36755;&#20986;&#65306;7

&#31034;&#20363; 2&#65306;
&#36755;&#20837;: root = [10, 5, 15, 2, 7, null, 20, 1, null, 6, 8], cnt = 4
       10
      / \
     5   15
    / \    \
   2   7    20
  /   / \ 
 1   6   8
&#36755;&#20986;: 8

&#25552;&#31034;&#65306;
1 &#8804; cnt &#8804; &#20108;&#21449;&#25628;&#32034;&#26641;&#20803;&#32032;&#20010;&#25968;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">order</span>;
    <span class="org-type">void</span> <span class="org-function-name">inorder</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>) {
        <span class="org-keyword">if</span>(root){
            inorder(root-&gt;left);
            order.push_back(root-&gt;val);
            inorder(root-&gt;right);
        }
    }
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">findTargetNode</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>, <span class="org-type">int</span> <span class="org-variable-name">cnt</span>) {
        order.clear();
        inorder(root);
        <span class="org-type">int</span> <span class="org-variable-name">n</span> = order.size();
        <span class="org-comment-delimiter">// </span><span class="org-comment">cnt = 1   n - 1
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">cnt = 2   n - 2
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">cnt = 3   n - 3
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">cnt = cnt   n - cnt
</span>        <span class="org-keyword">return</span> order[n - cnt];
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:67b22e1d-9202-4900-9d96-d64f6b37b3ad" class="outline-5">
<h5 id="h:67b22e1d-9202-4900-9d96-d64f6b37b3ad"><a href="#h:67b22e1d-9202-4900-9d96-d64f6b37b3ad">13.前序遍历构造二叉搜索树</a></h5>
<div class="outline-text-5" id="text-h:67b22e1d-9202-4900-9d96-d64f6b37b3ad">
<p>
<a href="https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/description/">https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#23450;&#19968;&#20010;&#25972;&#25968;&#25968;&#32452;&#65292;&#23427;&#34920;&#31034;BST(&#21363; &#20108;&#21449;&#25628;&#32034;&#26641; )&#30340; &#20808;&#24207;&#36941;&#21382; &#65292;&#26500;&#36896;&#26641;&#24182;&#36820;&#22238;&#20854;&#26681;&#12290;

&#20445;&#35777; &#23545;&#20110;&#32473;&#23450;&#30340;&#27979;&#35797;&#29992;&#20363;&#65292;&#24635;&#26159;&#26377;&#21487;&#33021;&#25214;&#21040;&#20855;&#26377;&#32473;&#23450;&#38656;&#27714;&#30340;&#20108;&#21449;&#25628;&#32034;&#26641;&#12290;

&#20108;&#21449;&#25628;&#32034;&#26641; &#26159;&#19968;&#26869;&#20108;&#21449;&#26641;&#65292;&#20854;&#20013;&#27599;&#20010;&#33410;&#28857;&#65292; Node.left &#30340;&#20219;&#20309;&#21518;&#20195;&#30340;&#20540; &#20005;&#26684;&#23567;&#20110; Node.val , Node.right &#30340;&#20219;&#20309;&#21518;&#20195;&#30340;&#20540; &#20005;&#26684;&#22823;&#20110; Node.val&#12290;

&#20108;&#21449;&#26641;&#30340; &#21069;&#24207;&#36941;&#21382; &#39318;&#20808;&#26174;&#31034;&#33410;&#28857;&#30340;&#20540;&#65292;&#28982;&#21518;&#36941;&#21382;Node.left&#65292;&#26368;&#21518;&#36941;&#21382;Node.right&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;preorder = [8,5,1,7,10,12]
&#36755;&#20986;&#65306;[8,5,10,1,7,null,12]

&#31034;&#20363; 2:
&#36755;&#20837;: preorder = [1,3]
&#36755;&#20986;: [1,null,3]

&#25552;&#31034;&#65306;
1 &lt;= preorder.length &lt;= 100
1 &lt;= preorder[i] &lt;= 10^8
preorder &#20013;&#30340;&#20540; &#20114;&#19981;&#30456;&#21516;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#26500;&#24314;&#20108;&#21449;&#25628;&#32034;&#26641;. &#36882;&#24402;&#26500;&#24314;
</span>    <span class="org-type">TreeNode</span>* <span class="org-function-name">doConstructBST</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">preorder</span>, <span class="org-type">int</span> <span class="org-variable-name">l</span> , <span class="org-type">int</span> <span class="org-variable-name">r</span>) {
        <span class="org-keyword">if</span>(l &gt; r) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#27492;&#26102;&#65292;&#32943;&#23450;&#20026;&#31354;&#26641;
</span>            <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
        }
        <span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span> = <span class="org-keyword">new</span> <span class="org-type">TreeNode</span>();
        root-&gt;val = preorder[l];
        <span class="org-comment-delimiter">// </span><span class="org-comment">2.&#30830;&#23450;&#24038;&#21491;&#36793;&#30028;
</span>        <span class="org-type">int</span> <span class="org-variable-name">i</span>;
        <span class="org-keyword">for</span>(i = l+1; i &lt;= r; ++i){
            <span class="org-keyword">if</span>(preorder[i] &gt; root-&gt;val) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#25214;&#21040;&#31532;&#19968;&#20010;&#22823;&#20110;root-&gt;val&#30340;&#20540;
</span>                <span class="org-keyword">break</span>;
            }
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">1. &#20808;&#20889;&#24038;&#21491;&#23376;&#26641;&#30340;&#26500;&#36896;&#26041;&#27861;
</span>        root-&gt;left = doConstructBST(preorder, l+1, i-1); <span class="org-comment-delimiter">// </span><span class="org-comment">&#24038;&#23376;&#26641;
</span>        root-&gt;right = doConstructBST(preorder, i , r);   <span class="org-comment-delimiter">// </span><span class="org-comment">&#21491;&#23376;&#26641;
</span>        <span class="org-keyword">return</span> root;
    }
<span class="org-keyword">public</span>:
    <span class="org-type">TreeNode</span>* <span class="org-function-name">bstFromPreorder</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">preorder</span>) {
        <span class="org-keyword">return</span> doConstructBST(preorder, 0, preorder.size()-1);
    }
};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#20808;&#24207;&#36941;&#21382; 8 5 1 7 10 12</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-h:a83b2ec4-720f-4b48-ac71-8176fe150054" class="outline-5">
<h5 id="h:a83b2ec4-720f-4b48-ac71-8176fe150054"><a href="#h:a83b2ec4-720f-4b48-ac71-8176fe150054">14.二叉搜索树中的插入操作</a></h5>
<div class="outline-text-5" id="text-h:a83b2ec4-720f-4b48-ac71-8176fe150054">
<p>
<a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/">https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#23450;&#20108;&#21449;&#25628;&#32034;&#26641;&#65288;BST&#65289;&#30340;&#26681;&#33410;&#28857; root &#21644;&#35201;&#25554;&#20837;&#26641;&#20013;&#30340;&#20540; value &#65292;&#23558;&#20540;&#25554;&#20837;&#20108;&#21449;&#25628;&#32034;&#26641;&#12290; 
&#36820;&#22238;&#25554;&#20837;&#21518;&#20108;&#21449;&#25628;&#32034;&#26641;&#30340;&#26681;&#33410;&#28857;&#12290; &#36755;&#20837;&#25968;&#25454; &#20445;&#35777; &#65292;&#26032;&#20540;&#21644;&#21407;&#22987;&#20108;&#21449;&#25628;&#32034;&#26641;&#20013;&#30340;&#20219;&#24847;&#33410;&#28857;&#20540;&#37117;&#19981;&#21516;&#12290;

&#27880;&#24847;&#65292;&#21487;&#33021;&#23384;&#22312;&#22810;&#31181;&#26377;&#25928;&#30340;&#25554;&#20837;&#26041;&#24335;&#65292;&#21482;&#35201;&#26641;&#22312;&#25554;&#20837;&#21518;&#20173;&#20445;&#25345;&#20026;&#20108;&#21449;&#25628;&#32034;&#26641;&#21363;&#21487;&#12290; &#20320;&#21487;&#20197;&#36820;&#22238; &#20219;&#24847;&#26377;&#25928;&#30340;&#32467;&#26524; &#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;root = [4,2,7,1,3], val = 5
&#36755;&#20986;&#65306;[4,2,7,1,3,5]
&#35299;&#37322;&#65306;&#21478;&#19968;&#20010;&#28385;&#36275;&#39064;&#30446;&#35201;&#27714;&#21487;&#20197;&#36890;&#36807;&#30340;&#26641;&#26159;&#65306;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;root = [40,20,60,10,30,50,70], val = 25
&#36755;&#20986;&#65306;[40,20,60,10,30,50,70,null,null,25]

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
&#36755;&#20986;&#65306;[4,2,7,1,3,5]

&#25552;&#31034;&#65306;
&#26641;&#20013;&#30340;&#33410;&#28857;&#25968;&#23558;&#22312; [0, 104]&#30340;&#33539;&#22260;&#20869;&#12290;
-108 &lt;= Node.val &lt;= 108
&#25152;&#26377;&#20540; Node.val &#26159; &#29420;&#19968;&#26080;&#20108; &#30340;&#12290;
-108 &lt;= val &lt;= 108
&#20445;&#35777; val &#22312;&#21407;&#22987;BST&#20013;&#19981;&#23384;&#22312;&#12290;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-doc">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     </span><span class="org-doc"><span class="org-doc-markup">TreeNode()</span></span><span class="org-doc"> : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
<span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">TreeNode</span>* <span class="org-function-name">insertIntoBST</span>(<span class="org-type">TreeNode</span>* <span class="org-variable-name">root</span>, <span class="org-type">int</span> <span class="org-variable-name">val</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">3. &#36882;&#24402;&#20986;&#21475;&#65292;&#26641;&#20026;&#31354;&#26102;&#36820;&#22238;&#26032;&#29983;&#25104;&#30340;&#33410;&#28857;
</span>        <span class="org-keyword">if</span> (root == <span class="org-constant">NULL</span>) {
            <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">TreeNode</span>(val);
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">1. &#35201;&#25554;&#20837;&#30340;&#25968;&#22823;&#20110;&#26681;&#33410;&#28857;&#30340;&#25968;&#65292;&#37027;&#20040;&#19968;&#23450;&#22312;&#21491;&#33410;&#28857;&#19978;&#12290;&#21453;&#20043;&#24038;&#33410;&#28857;&#12290;&#27809;&#26377;&#30456;&#31561;&#24773;&#20917;
</span>        <span class="org-keyword">if</span> (val &gt; root-&gt;val) {
            <span class="org-comment-delimiter">// </span><span class="org-comment">2. &#26356;&#26032;&#24038;&#21491;&#23376;&#26641;
</span>            root-&gt;right = insertIntoBST(root-&gt;right, val);
        }<span class="org-keyword">else</span> <span class="org-keyword">if</span> (val &lt; root-&gt;val) {
            root-&gt;left = insertIntoBST(root-&gt;left, val);
        }
        <span class="org-keyword">return</span> root;
        
    }
};
</pre>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="outline-container-h:4b19da01-b627-4148-8c99-1a7a1a905d3e" class="outline-2">
<h2 id="h:4b19da01-b627-4148-8c99-1a7a1a905d3e"><a href="#h:4b19da01-b627-4148-8c99-1a7a1a905d3e">图形结构-图</a></h2>
<div class="outline-text-2" id="text-h:4b19da01-b627-4148-8c99-1a7a1a905d3e">
</div>
<div id="outline-container-h:4cfaa8e3-05b1-49c7-b774-381c5b74de99" class="outline-3">
<h3 id="h:4cfaa8e3-05b1-49c7-b774-381c5b74de99"><a href="#h:4cfaa8e3-05b1-49c7-b774-381c5b74de99">图（概念篇）</a></h3>
<div class="outline-text-3" id="text-h:4cfaa8e3-05b1-49c7-b774-381c5b74de99">
<p>
图的应用场景
</p>
</div>
<div id="outline-container-h:33826fcb-3256-4880-b9ad-ca2770090486" class="outline-4">
<h4 id="h:33826fcb-3256-4880-b9ad-ca2770090486"><a href="#h:33826fcb-3256-4880-b9ad-ca2770090486">图的定义</a></h4>
<div class="outline-text-4" id="text-h:33826fcb-3256-4880-b9ad-ca2770090486">
<p>
图(Graph)是由顶点的有穷非空集合和顶点之间边的集合组成我，通常表示为:G(V，E)，其中G表示一个图，V是图G中顶点的集合，E是图G中边的集合。
</p>

<p>
线性表中我们把数据元素叫元素，树中将数据元素叫结点，图中数据元素，我们则称之为顶点。
</p>
</div>
</div>
<div id="outline-container-h:247c95a2-b0a2-4f51-b4dd-7b8454509a57" class="outline-4">
<h4 id="h:247c95a2-b0a2-4f51-b4dd-7b8454509a57"><a href="#h:247c95a2-b0a2-4f51-b4dd-7b8454509a57">有向图和无向图</a></h4>
<div class="outline-text-4" id="text-h:247c95a2-b0a2-4f51-b4dd-7b8454509a57">
<p>
图可以分为有向图和无向图。有向图中的边具有方向，从一个顶点指向另一个顶点，表示一个单向关系。无向图中的边没有方向，连接两个顶点，表示双向关系。
</p>
</div>
<div id="outline-container-h:021580e2-0cbd-489f-9771-6765b993177a" class="outline-5">
<h5 id="h:021580e2-0cbd-489f-9771-6765b993177a"><a href="#h:021580e2-0cbd-489f-9771-6765b993177a">无向边和无向图</a></h5>
<div class="outline-text-5" id="text-h:021580e2-0cbd-489f-9771-6765b993177a">
<p>
如果两个顶点间的边没有方向，则称这条边为无向边，如果图中任意两个顶点之间的边都是无向边，则这个图被称为无向图。
</p>
</div>
</div>
<div id="outline-container-h:b17f81f1-9114-4e25-834b-37ef823a591b" class="outline-5">
<h5 id="h:b17f81f1-9114-4e25-834b-37ef823a591b"><a href="#h:b17f81f1-9114-4e25-834b-37ef823a591b">有向边和有向图</a></h5>
<div class="outline-text-5" id="text-h:b17f81f1-9114-4e25-834b-37ef823a591b">
<p>
如果两个顶点之间的边是有方向的，则被称为有向边，也被称为弧(有向边的起点叫弧头，终点叫弧尾)，如果图中任意两个顶点之间的遍都是有向边，则这个图被称为有向图
</p>
</div>
</div>
</div>
<div id="outline-container-h:537dbb09-e547-4d39-92d8-4d61024e6b7b" class="outline-4">
<h4 id="h:537dbb09-e547-4d39-92d8-4d61024e6b7b"><a href="#h:537dbb09-e547-4d39-92d8-4d61024e6b7b">稀疏图和稠密图</a></h4>
<div class="outline-text-4" id="text-h:537dbb09-e547-4d39-92d8-4d61024e6b7b">
<p>
根据图中边的数量，图可以分为稀疏图和稠密图。稀疏图中边的数量相对较少，顶点之间的连接比较稀疏。稠密图中边的数量较多，顶点之间的连接较为紧密。
</p>
</div>
</div>
<div id="outline-container-h:9d3acf4c-88fe-416f-94ec-bf9aebacc80c" class="outline-4">
<h4 id="h:9d3acf4c-88fe-416f-94ec-bf9aebacc80c"><a href="#h:9d3acf4c-88fe-416f-94ec-bf9aebacc80c">完全图</a></h4>
<div class="outline-text-4" id="text-h:9d3acf4c-88fe-416f-94ec-bf9aebacc80c">
<p>
完全图是指每个顶点都与其他顶点直接相连的图。对于有向图，完全图要求每个顶点都有有向边指向其他顶点，并且每个顶点也接受其他顶点的有向边。
</p>
</div>
</div>
<div id="outline-container-h:d8eb12d4-1183-4276-9576-1776f8a4c676" class="outline-4">
<h4 id="h:d8eb12d4-1183-4276-9576-1776f8a4c676"><a href="#h:d8eb12d4-1183-4276-9576-1776f8a4c676">简单图</a></h4>
<div class="outline-text-4" id="text-h:d8eb12d4-1183-4276-9576-1776f8a4c676">
<p>
简单图是指图中没有自循环(边的起始顶点和结束顶点相同)和多重边(两个顶点之间存在多条边)的图。
</p>
</div>
</div>
<div id="outline-container-h:cbe3076a-a883-4b98-a1c0-c116beed5828" class="outline-4">
<h4 id="h:cbe3076a-a883-4b98-a1c0-c116beed5828"><a href="#h:cbe3076a-a883-4b98-a1c0-c116beed5828">度</a></h4>
<div class="outline-text-4" id="text-h:cbe3076a-a883-4b98-a1c0-c116beed5828">
<p>
度是图中顶点的一个重要概念，它表示某个顶点与其他顶点直接相连的边的数量。对于有向图，度分为入度和出度，分别表示指向该顶点的边数和从该顶点指出的边数。
</p>
</div>
</div>
<div id="outline-container-h:4f540212-7cae-4e5d-ac29-6c5be088a0a1" class="outline-4">
<h4 id="h:4f540212-7cae-4e5d-ac29-6c5be088a0a1"><a href="#h:4f540212-7cae-4e5d-ac29-6c5be088a0a1">权</a></h4>
<div class="outline-text-4" id="text-h:4f540212-7cae-4e5d-ac29-6c5be088a0a1">
<p>
权是指图中边的附加信息，可以表示边的权重、距离、成本等。
</p>
</div>
</div>
<div id="outline-container-h:cba21b7d-331c-497e-afb9-70973ac9db37" class="outline-4">
<h4 id="h:cba21b7d-331c-497e-afb9-70973ac9db37"><a href="#h:cba21b7d-331c-497e-afb9-70973ac9db37">路径</a></h4>
<div class="outline-text-4" id="text-h:cba21b7d-331c-497e-afb9-70973ac9db37">
<p>
路径是图中一系列连续的边，连接了两个顶点。路径可以是有向的或无向的。相关算法就是求两个顶点之间的
最短路径。比如Dijkstra、Bellman-Ford、Floyd、Dijkstra+Heap0、SPFA都是求最短路径的算法。
</p>
</div>
</div>
<div id="outline-container-h:30fd2044-5f74-4b76-b7f0-77c648f7ee29" class="outline-4">
<h4 id="h:30fd2044-5f74-4b76-b7f0-77c648f7ee29"><a href="#h:30fd2044-5f74-4b76-b7f0-77c648f7ee29">连通图和连通分量</a></h4>
<div class="outline-text-4" id="text-h:30fd2044-5f74-4b76-b7f0-77c648f7ee29">
<p>
连通图是指图中任意两个顶点之间都存在一条路径。如果图可以划分为多个子图，使得子图内部的顶点相互连通，而子图之间没有连接，那么这些子图就称为连通分量。
</p>

<p>
在有向图中，如果对于任意两个顶点a和b，从a到b和从b到a都存在路径，则称它为强连通图，有向图中的极大强连通子图被称为这个有向图的强连通分量。
</p>
<ul class="org-ul">
<li>极大，表示没办法再引入一个节点使得它有更大的连通子图。</li>
</ul>
</div>
</div>
<div id="outline-container-h:b487f2a5-35e4-4199-b460-98871568ccf7" class="outline-4">
<h4 id="h:b487f2a5-35e4-4199-b460-98871568ccf7"><a href="#h:b487f2a5-35e4-4199-b460-98871568ccf7">生成树</a></h4>
<div class="outline-text-4" id="text-h:b487f2a5-35e4-4199-b460-98871568ccf7">
<p>
生成树是连通图的一个子图，它是一棵树(没有循环的连通图)，，并且包含了图中的所有顶点。生成树可以用于图的遍历、最小生成树等问题的解决。常见的最小生成树算法有Kruscal和Prim，其中Kruscal用到了并查集。
</p>

<p>
学习图算法时，自然就会把这些概念学会。
</p>
</div>
</div>
</div>
</section>
<section id="outline-container-h:2883167f-5804-4998-9411-7cb21f14b01c" class="outline-2">
<h2 id="h:2883167f-5804-4998-9411-7cb21f14b01c"><a href="#h:2883167f-5804-4998-9411-7cb21f14b01c">图形结构-邻接矩阵</a></h2>
<div class="outline-text-2" id="text-h:2883167f-5804-4998-9411-7cb21f14b01c">
</div>
<div id="outline-container-h:6d188199-ae4f-4b6e-b7f3-246c27548b93" class="outline-3">
<h3 id="h:6d188199-ae4f-4b6e-b7f3-246c27548b93"><a href="#h:6d188199-ae4f-4b6e-b7f3-246c27548b93">邻接矩阵（概念篇）</a></h3>
<div class="outline-text-3" id="text-h:6d188199-ae4f-4b6e-b7f3-246c27548b93">
<p>
邻接矩阵的应用场景
</p>
</div>
<div id="outline-container-h:605aaf69-c613-47a0-968c-ef7c54b4bcc9" class="outline-4">
<h4 id="h:605aaf69-c613-47a0-968c-ef7c54b4bcc9"><a href="#h:605aaf69-c613-47a0-968c-ef7c54b4bcc9">邻接矩阵的概念</a></h4>
<div class="outline-text-4" id="text-h:605aaf69-c613-47a0-968c-ef7c54b4bcc9">
<p>
由于图是由顶点和边(或弧)两部分组成的。顶点可以用一个一维的顺序表来存储，但是边(或弧)由于是顶点与顶点之间的关系，一维搞不定，所以可以考虑用一个二维的顺序表来存储，而二维的顺序表就是一个矩阵。
</p>

<p>
对于一个有n个顶点的图G，邻接矩阵是一个 n x n 的方阵(方阵就是行列数相等的矩阵)。对于邻接矩阵而言，不需要去考虑是有向的还是无向的，统一都可以理解成有向的，因为有向图可以兼容无向图，对于无向图而言，只不过这个矩阵是按照主对角线对称的，因为A到B有边，则必然B到A有边。
</p>

<p>
对带权图和无权图，邻接矩阵的表示略有差别，接下来我们分别来讨论。
</p>
</div>
</div>
<div id="outline-container-h:83a602d2-f5dd-4e0f-83f0-c79d3cea8cd3" class="outline-4">
<h4 id="h:83a602d2-f5dd-4e0f-83f0-c79d3cea8cd3"><a href="#h:83a602d2-f5dd-4e0f-83f0-c79d3cea8cd3">无权图的邻接矩阵</a></h4>
<div class="outline-text-4" id="text-h:83a602d2-f5dd-4e0f-83f0-c79d3cea8cd3">
<p>
对于一个 n x n 图中，采用一个 n x n 的方阵adj[n][n]，在这样一个矩阵里:
</p>
<ol class="org-ol">
<li>矩阵的行和列都对应图中的一个顶点。</li>
<li>如果顶点A到顶点B有一条边(这里是单向的)，则对应矩阵单元为1</li>
<li>如果顶点A到顶点B没有边(这里同样是单向的)，则对应的矩阵单元就为0</li>
</ol>

<p>
例如，对于一个有四个顶点的无权图，首先需要有一个顺序表来存储所有的顶点的(A，B，C，D)，图的邻接矩阵如下:
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">A</td>
<td class="org-right">B</td>
<td class="org-right">C</td>
<td class="org-right">D</td>
</tr>

<tr>
<td class="org-left">A</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">B</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">C</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">D</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>


<p>
从这个矩阵中我们可以看出，A能够到B、D，B能够到A、C，C能够到B、D，D能够到A、C。如图所示:
</p>


<figure id="orgf506a9e">
<img src="././images/img-2025102432.png" alt="img-2025102432.png" width="50%">

</figure>

<p>
简单解释一下，对于矩阵的主对角线的值adj[0][0]、adj[1][1]、adj[2][2]、adj[3][3]全为0，因为这个图中，不存在顶点自己到自己的边，adj[0][1]=1是因为A到B的边存在，而adj[2][0]=0是是因为C到A的边不存在。对于无向图而言，它的邻接矩阵是一个对称矩阵。
</p>

<p>
有了这个矩阵，我们就可以很容易地知道图中的信息。
</p>
<ol class="org-ol">
<li>我们要判定任意两顶点之间是否有边就非常容易。</li>
<li>我们要知道某个顶点的度，其实就是这个顶点在邻接矩阵中i行的元素之和</li>
<li>求顶点i的所有邻接点就是将矩阵中第1行元素扫描一遍，arc[i][j]为1就是邻接点。</li>
</ol>
</div>
</div>
<div id="outline-container-h:6f95e758-dd65-4891-bfda-c73643a287e1" class="outline-4">
<h4 id="h:6f95e758-dd65-4891-bfda-c73643a287e1"><a href="#h:6f95e758-dd65-4891-bfda-c73643a287e1">带权图的邻接矩阵</a></h4>
<div class="outline-text-4" id="text-h:6f95e758-dd65-4891-bfda-c73643a287e1">
<p>
在带权图的邻接矩阵中，每个矩阵元素表示一个有向边的权值。如果不存在从一个节点到另一个节点的边，则通常将其表示为特殊的值，如0，-1或无穷。
</p>

<p>
假设有一个有向带权图，它有4个顶点(A，B，C，D)，边及其权重如下:
</p>
<ul class="org-ul">
<li>边A-&gt;B的权重是3</li>
<li>边A-&gt;C的权重是7</li>
<li>边B-&gt;A的权重是4</li>
<li>边B-&gt;D的权重是1</li>
<li>边C-&gt;D的权重是2</li>
<li>边D-&gt;A的权重是1</li>
</ul>

<p>
我们可以将这个有向带权图表示为以下的邻接矩阵:
</p>
<div class="org-src-container">
<pre class="src src-text">  A B C D
A 0 3 7 0
B 4 0 0 1
C 0 0 0 2
D 1 0 0 0
</pre>
</div>

<p>
在这个矩阵中，行表示起始顶点，列表示目标顶点。矩阵元素的值代表起始顶点到目标顶点的边的权重。如果没有边存在，我们用0来表示。例如，第一行表示从A到各点的边的权重，可以看出有从A到B的边，权重为3，有从A到C的边，权重为7，没有从A出发到达D的边，所以为0。
</p>

<p>
当然，什么情况下不能用0来代表边不存在的情况?
</p>

<p>
大多数情况下边权是正值，但个别时候真的有可能就是0，甚至有可能是负值。因此必须要用一个不可能的值来代表不存在。
</p>
</div>
</div>
<div id="outline-container-h:8c685456-d3ec-4bca-afa3-8cbe0c3712c8" class="outline-4">
<h4 id="h:8c685456-d3ec-4bca-afa3-8cbe0c3712c8"><a href="#h:8c685456-d3ec-4bca-afa3-8cbe0c3712c8">邻接矩阵的优点</a></h4>
<div class="outline-text-4" id="text-h:8c685456-d3ec-4bca-afa3-8cbe0c3712c8">
<ol class="org-ol">
<li>简单直观:邻接矩阵是一个二维顺序表，通过矩阵中的元素值可以直接表示顶点之间的连接关系，非常直观和易于理解。</li>
<li>存储效率高:对于小型图，邻接矩阵的存储效率较高，因为它可以一次性存储所有顶点之间的连接关系，不需要额外的空间来存储边的信息。</li>
<li>算法实现简单:许多图算法可以通过邻接矩阵进行简单而高效的实现，例如遍历图、检测连通性等。</li>
</ol>
</div>
</div>
<div id="outline-container-h:4f4a3242-f3a3-48ff-8722-b75d2724fdc2" class="outline-4">
<h4 id="h:4f4a3242-f3a3-48ff-8722-b75d2724fdc2"><a href="#h:4f4a3242-f3a3-48ff-8722-b75d2724fdc2">邻接矩阵的缺点</a></h4>
<div class="outline-text-4" id="text-h:4f4a3242-f3a3-48ff-8722-b75d2724fdc2">
<ol class="org-ol">
<li>空间复杂度高:对于大型图，邻接矩阵的空间复杂度较高，因为它需要存储一个 n x n 的矩阵，这可能导致存储空间的浪费和效率问题。</li>
<li>不适合稀疏图:邻接矩阵对于稀疏图(即图中大部分顶点之间没有连接)的表示效率较低，因为它会浪费大量的存储空间来存储零元素。</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-h:d7bd4997-b05d-4f66-ac55-e22ae3ac0a78" class="outline-3">
<h3 id="h:d7bd4997-b05d-4f66-ac55-e22ae3ac0a78"><a href="#h:d7bd4997-b05d-4f66-ac55-e22ae3ac0a78">代码篇</a></h3>
<div class="outline-text-3" id="text-h:d7bd4997-b05d-4f66-ac55-e22ae3ac0a78">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-preprocessor">#define</span> <span class="org-variable-name">inf</span> -1 <span class="org-comment-delimiter">// </span><span class="org-comment">inf &#23450;&#20041;&#19968;&#20010;&#26080;&#31351;, -1 &#34920;&#31034;&#20004;&#20010;&#39030;&#28857;&#27809;&#26377;&#36793;&#30340;&#24773;&#20917;
</span>
<span class="org-keyword">class</span> <span class="org-type">Graph</span> {
<span class="org-keyword">private</span>:
    <span class="org-type">int</span> <span class="org-variable-name">vertices</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22270;&#30340;&#39030;&#28857;&#20010;&#25968;
</span>    <span class="org-type">int</span>** <span class="org-variable-name">edges</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#25351;&#38024;&#25968;&#32452;&#65292;&#20063;&#26159;&#20010;&#20108;&#32500;&#25968;&#32452;&#65292;&#34920;&#31034;&#22270;&#30340;&#37051;&#25509;&#30697;&#38453;
</span>
<span class="org-keyword">public</span>:
    <span class="org-function-name">Graph</span>(<span class="org-type">int</span> <span class="org-variable-name">vertices</span>);  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21442;&#25968;&#26159;&#39030;&#28857;&#30340;&#20010;&#25968;
</span>    ~<span class="org-function-name">Graph</span>();
    <span class="org-type">void</span> <span class="org-function-name">addEdge</span>(<span class="org-type">int</span> <span class="org-variable-name">u</span>, <span class="org-type">int</span> <span class="org-variable-name">v</span>, <span class="org-type">int</span> <span class="org-variable-name">w</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#22686;&#21152;&#19968;&#26465;u&#21040;v&#30340;&#36793;&#65292;w&#20195;&#34920;&#36793;&#30340;&#26435;
</span>    <span class="org-type">void</span> <span class="org-function-name">printGraph</span>();
};

<span class="org-constant">Graph</span>::<span class="org-function-name">Graph</span>(<span class="org-type">int</span> <span class="org-variable-name">vertices</span>) {
    <span class="org-keyword">this</span>-&gt;vertices = vertices;
    edges = <span class="org-keyword">new</span> <span class="org-type">int</span>* [<span class="org-constant">vertices</span>]; <span class="org-comment-delimiter">// </span><span class="org-comment">edges&#25351;&#21521;&#19968;&#20010;&#20108;&#32473;&#25968;&#32452;&#65292;&#25968;&#32452;&#27599;&#20010;&#20803;&#32032;&#37117;&#26159;&#25351;&#38024;&#65292;&#38271;&#24230;&#20026;&#39030;&#28857;&#20010;&#25968;
</span>    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; vertices; ++i) {
        edges[i] = <span class="org-keyword">new</span> <span class="org-type">int</span>[vertices];
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; vertices; ++j) {
            edges[i][j] = inf;
        }
    }
}

<span class="org-constant">Graph</span>::~<span class="org-function-name">Graph</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#28165;&#29702;&#20803;&#32032;&#20869;&#23384;&#65292;&#20877;&#28165;&#29702;&#26412;&#36523;&#20869;&#23384;
</span>    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; vertices; ++i) {
        <span class="org-keyword">delete</span>[] edges[i];
    }
    <span class="org-keyword">delete</span>[] edges;
}

<span class="org-type">void</span> <span class="org-constant">Graph</span>::<span class="org-function-name">addEdge</span>(<span class="org-type">int</span> <span class="org-variable-name">u</span>, <span class="org-type">int</span> <span class="org-variable-name">v</span>, <span class="org-type">int</span> <span class="org-variable-name">w</span>) {
    edges[u][v] = w;
}

<span class="org-type">void</span> <span class="org-constant">Graph</span>::<span class="org-function-name">printGraph</span>() {
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; vertices; ++i) {
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; vertices; ++j) {
            cout &lt;&lt; edges[i][j] &lt;&lt; <span class="org-string">" "</span>;
        }
        cout &lt;&lt; endl;
    } 
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;5&#20010;&#39030;&#28857;&#30340;&#22270;
</span>    <span class="org-type">int</span> <span class="org-variable-name">vertices</span> = 5; 
    <span class="org-type">Graph</span> <span class="org-variable-name">graph</span>(vertices);

    graph.addEdge(0, 1, 1); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;&#39030;&#28857;0&#21040;&#39030;&#28857;1&#65292;&#22686;&#21152;&#19968;&#20010;&#26435;&#20026;1&#30340;&#36793;
</span>    graph.addEdge(0, 2, 3);
    graph.addEdge(1, 2, 2);
    graph.addEdge(2, 3, 7);
    graph.addEdge(3, 4, 9);
    graph.addEdge(4, 0, 4);
    graph.addEdge(4, 2, 5); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;&#39030;&#28857;4&#21040;&#39030;&#28857;2&#65292;&#22686;&#21152;&#19968;&#20010;&#26435;&#20026;5&#30340;&#36793;
</span>
    graph.printGraph();

    <span class="org-keyword">return</span> 0;
}

<span class="org-comment-delimiter">/*</span><span class="org-comment">
-1 1 3 -1 -1
-1 -1 2 -1 -1
-1 -1 -1 7 -1
-1 -1 -1 -1 9
4 -1 5 -1 -1
</span><span class="org-comment-delimiter">*/</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-h:ad30a6c7-98e3-43ed-b7a7-914f51cc1343" class="outline-3">
<h3 id="h:ad30a6c7-98e3-43ed-b7a7-914f51cc1343"><a href="#h:ad30a6c7-98e3-43ed-b7a7-914f51cc1343">实战篇</a></h3>
<div class="outline-text-3" id="text-h:ad30a6c7-98e3-43ed-b7a7-914f51cc1343">
</div>
<div id="outline-container-h:67a9d68d-4c2b-4e9b-9e65-d9b4bf0bd6c9" class="outline-4">
<h4 id="h:67a9d68d-4c2b-4e9b-9e65-d9b4bf0bd6c9"><a href="#h:67a9d68d-4c2b-4e9b-9e65-d9b4bf0bd6c9">1.传递信息</a></h4>
<div class="outline-text-4" id="text-h:67a9d68d-4c2b-4e9b-9e65-d9b4bf0bd6c9">
<p>
<a href="https://leetcode.cn/problems/chuan-di-xin-xi/">https://leetcode.cn/problems/chuan-di-xin-xi/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#23567;&#26379;&#21451; A &#22312;&#21644; ta &#30340;&#23567;&#20249;&#20276;&#20204;&#29609;&#20256;&#20449;&#24687;&#28216;&#25103;&#65292;&#28216;&#25103;&#35268;&#21017;&#22914;&#19979;&#65306;

&#26377; n &#21517;&#29609;&#23478;&#65292;&#25152;&#26377;&#29609;&#23478;&#32534;&#21495;&#20998;&#21035;&#20026; 0 &#65374; n-1&#65292;&#20854;&#20013;&#23567;&#26379;&#21451; A &#30340;&#32534;&#21495;&#20026; 0
&#27599;&#20010;&#29609;&#23478;&#37117;&#26377;&#22266;&#23450;&#30340;&#33509;&#24178;&#20010;&#21487;&#20256;&#20449;&#24687;&#30340;&#20854;&#20182;&#29609;&#23478;&#65288;&#20063;&#21487;&#33021;&#27809;&#26377;&#65289;&#12290;&#20256;&#20449;&#24687;&#30340;&#20851;&#31995;&#26159;&#21333;&#21521;&#30340;&#65288;&#27604;&#22914; A &#21487;&#20197;&#21521; B &#20256;&#20449;&#24687;&#65292;&#20294; B &#19981;&#33021;&#21521; A &#20256;&#20449;&#24687;&#65289;&#12290;
&#27599;&#36718;&#20449;&#24687;&#24517;&#39035;&#38656;&#35201;&#20256;&#36882;&#32473;&#21478;&#19968;&#20010;&#20154;&#65292;&#19988;&#20449;&#24687;&#21487;&#37325;&#22797;&#32463;&#36807;&#21516;&#19968;&#20010;&#20154;
&#32473;&#23450;&#24635;&#29609;&#23478;&#25968; n&#65292;&#20197;&#21450;&#25353; [&#29609;&#23478;&#32534;&#21495;,&#23545;&#24212;&#21487;&#20256;&#36882;&#29609;&#23478;&#32534;&#21495;] &#20851;&#31995;&#32452;&#25104;&#30340;&#20108;&#32500;&#25968;&#32452; relation&#12290;
&#36820;&#22238;&#20449;&#24687;&#20174;&#23567; A (&#32534;&#21495; 0 ) &#32463;&#36807; k &#36718;&#20256;&#36882;&#21040;&#32534;&#21495;&#20026; n-1 &#30340;&#23567;&#20249;&#20276;&#22788;&#30340;&#26041;&#26696;&#25968;&#65307;&#33509;&#19981;&#33021;&#21040;&#36798;&#65292;&#36820;&#22238; 0&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3
&#36755;&#20986;&#65306;3
&#35299;&#37322;&#65306;&#20449;&#24687;&#20174;&#23567; A &#32534;&#21495; 0 &#22788;&#24320;&#22987;&#65292;&#32463; 3 &#36718;&#20256;&#36882;&#65292;&#21040;&#36798;&#32534;&#21495; 4&#12290;&#20849;&#26377; 3 &#31181;&#26041;&#26696;&#65292;&#20998;&#21035;&#26159; 0-&gt;2-&gt;0-&gt;4&#65292; 0-&gt;2-&gt;1-&gt;4&#65292; 0-&gt;2-&gt;3-&gt;4&#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;n = 3, relation = [[0,2],[2,1]], k = 2
&#36755;&#20986;&#65306;0
&#35299;&#37322;&#65306;&#20449;&#24687;&#19981;&#33021;&#20174;&#23567; A &#22788;&#32463;&#36807; 2 &#36718;&#20256;&#36882;&#21040;&#32534;&#21495; 2

&#38480;&#21046;&#65306;
2 &lt;= n &lt;= 10
1 &lt;= k &lt;= 5
1 &lt;= relation.length &lt;= 90, &#19988; relation[i].length == 2
0 &lt;= relation[i][0],relation[i][1] &lt; n &#19988; relation[i][0] != relation[i][1]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-type">int</span> <span class="org-variable-name">matrix</span>[10][10]; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#37051;&#25509;&#30697;&#38453;
</span>    <span class="org-type">int</span> <span class="org-variable-name">N</span>;
    
    <span class="org-type">int</span> <span class="org-function-name">dfs</span>(<span class="org-type">int</span> <span class="org-variable-name">u</span>, <span class="org-type">int</span> <span class="org-variable-name">k</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;u&#20986;&#21457;&#32463;&#36807;&#22810;&#23569;&#26465;&#36793;&#21040;&#36798;N-1&#30340;&#26041;&#26696;&#25968;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">1. &#36882;&#24402;&#20986;&#21475;
</span>        <span class="org-keyword">if</span>(k == 0) {
            <span class="org-keyword">if</span> (u == N-1) {
                <span class="org-keyword">return</span> 1;
            }
            <span class="org-keyword">return</span> 0;
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#26522;&#20030;&#20013;&#36716;&#28857;
</span>        <span class="org-type">int</span> <span class="org-variable-name">sum</span> = 0;
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; N; ++i) {
            <span class="org-keyword">if</span>(matrix[u][i]) {
                sum += dfs(i, k-1);
            }
        }
        <span class="org-keyword">return</span> sum;
    }
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">numWays</span>(<span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-type">vector</span>&lt;<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&gt;&amp; <span class="org-variable-name">relation</span>, <span class="org-type">int</span> <span class="org-variable-name">k</span>) {
        N = n;
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;&#36793;&#34920;&#31034;&#27861;&#21464;&#20026;&#37051;&#25509;&#30697;&#38453;&#34920;&#31034;&#27861;
</span>        memset(matrix, 0, <span class="org-keyword">sizeof</span>(matrix)); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#21270;&#37051;&#25509;&#30697;&#38453;&#65292;0&#34920;&#31034;&#20219;&#24847;&#20004;&#28857;&#20043;&#38388;&#27809;&#26377;&#36830;&#25509;&#20851;&#31995;
</span>        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; relation.size(); ++i) {
            <span class="org-type">int</span> <span class="org-variable-name">a</span> = relation[i][0];
            <span class="org-type">int</span> <span class="org-variable-name">b</span> = relation[i][1];
            matrix[a][b] = 1;
        }
        <span class="org-keyword">return</span> dfs(0, k); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;0&#36825;&#20010;&#28857;&#20986;&#21457;&#32463;&#36807;k&#27493;&#65292;&#21040;&#36798;N-1&#30340;&#26041;&#26696;&#25968;
</span>    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:8ef9d5aa-f90a-49c5-89b2-cd80020f13dd" class="outline-4">
<h4 id="h:8ef9d5aa-f90a-49c5-89b2-cd80020f13dd"><a href="#h:8ef9d5aa-f90a-49c5-89b2-cd80020f13dd">2.省份数量</a></h4>
<div class="outline-text-4" id="text-h:8ef9d5aa-f90a-49c5-89b2-cd80020f13dd">
<p>
<a href="https://leetcode.cn/problems/number-of-provinces/">https://leetcode.cn/problems/number-of-provinces/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#26377; n &#20010;&#22478;&#24066;&#65292;&#20854;&#20013;&#19968;&#20123;&#24444;&#27492;&#30456;&#36830;&#65292;&#21478;&#19968;&#20123;&#27809;&#26377;&#30456;&#36830;&#12290;&#22914;&#26524;&#22478;&#24066; a &#19982;&#22478;&#24066; b &#30452;&#25509;&#30456;&#36830;&#65292;
&#19988;&#22478;&#24066; b &#19982;&#22478;&#24066; c &#30452;&#25509;&#30456;&#36830;&#65292;&#37027;&#20040;&#22478;&#24066; a &#19982;&#22478;&#24066; c &#38388;&#25509;&#30456;&#36830;&#12290;

&#30465;&#20221; &#26159;&#19968;&#32452;&#30452;&#25509;&#25110;&#38388;&#25509;&#30456;&#36830;&#30340;&#22478;&#24066;&#65292;&#32452;&#20869;&#19981;&#21547;&#20854;&#20182;&#27809;&#26377;&#30456;&#36830;&#30340;&#22478;&#24066;&#12290;

&#32473;&#20320;&#19968;&#20010; n x n &#30340;&#30697;&#38453; isConnected &#65292;&#20854;&#20013; isConnected[i][j] = 1 &#34920;&#31034;&#31532; i &#20010;&#22478;&#24066;&#21644;
&#31532; j &#20010;&#22478;&#24066;&#30452;&#25509;&#30456;&#36830;&#65292;&#32780; isConnected[i][j] = 0 &#34920;&#31034;&#20108;&#32773;&#19981;&#30452;&#25509;&#30456;&#36830;&#12290;

&#36820;&#22238;&#30697;&#38453;&#20013; &#30465;&#20221; &#30340;&#25968;&#37327;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;isConnected = [[1,1,0],[1,1,0],[0,0,1]]
&#36755;&#20986;&#65306;2

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;isConnected = [[1,0,0],[0,1,0],[0,0,1]]
&#36755;&#20986;&#65306;3

&#25552;&#31034;&#65306;
1 &lt;= n &lt;= 200
n == isConnected.length
n == isConnected[i].length
isConnected[i][j] &#20026; 1 &#25110; 0
isConnected[i][i] == 1
isConnected[i][j] == isConnected[j][i]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-type">bool</span> <span class="org-variable-name">color</span>[201];
    <span class="org-type">int</span> <span class="org-variable-name">count</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#30465;&#20221;&#25968;&#37327;
</span>    <span class="org-type">int</span> <span class="org-variable-name">n</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#24635;&#20849;&#22810;&#23569;&#20010;&#28857;&#65292;&#21363;&#37051;&#25509;&#30697;&#38453;&#30340;&#22823;&#23567;
</span>
    <span class="org-type">void</span> <span class="org-function-name">dfs</span>(<span class="org-type">vector</span>&lt;<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&gt;&amp; <span class="org-variable-name">isConnected</span>, <span class="org-type">int</span> <span class="org-variable-name">u</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">u&#34920;&#31034;&#24403;&#21069;&#35775;&#38382;&#21738;&#20010;&#39030;&#28857;
</span>        <span class="org-keyword">if</span>(color[u]) {                                  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#20043;&#21069;&#35775;&#38382;&#36807;&#20102;&#65292;&#23601;&#36820;&#22238;
</span>            <span class="org-keyword">return</span>;
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#27809;&#26377;&#35775;&#38382;&#23601;&#35775;&#38382;&#23427;&#65292;&#22914;&#26524;u&#21040;i&#26377;&#36793;&#65292;&#23601;&#35775;&#38382;i&#36825;&#20010;&#39030;&#28857;
</span>        color[u] = <span class="org-constant">true</span>;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; ++i) {
            <span class="org-keyword">if</span>(isConnected[u][i]) { 
                dfs(isConnected, i);
            }
        }
    }
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">findCircleNum</span>(<span class="org-type">vector</span>&lt;<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&gt;&amp; <span class="org-variable-name">isConnected</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#29992;&#26579;&#33394;&#27861;&#26469;&#20570;
</span>        n = isConnected.size();
        count = 0;                           <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#21270;&#20026;0
</span>        memset(color, <span class="org-constant">false</span>, <span class="org-keyword">sizeof</span>(color)); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#19968;&#27573;&#20869;&#23384;&#22359;&#35774;&#32622;&#20026;&#29305;&#23450;&#30340;&#20540;&#12290;&#23558;color&#21021;&#22987;&#21270;&#20026;false
</span>        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n ; ++i ) {
            <span class="org-keyword">if</span>(color[i] == <span class="org-constant">false</span>) {          <span class="org-comment-delimiter">// </span><span class="org-comment">&#34920;&#31034;&#36825;&#20010;&#39030;&#28857;&#27809;&#26377;&#34987;&#35775;&#38382;&#36807;&#65292;&#23601;&#35201;&#35775;&#38382;&#23427;
</span>                dfs(isConnected, i);
                ++count;                     <span class="org-comment-delimiter">// </span><span class="org-comment">&#23436;&#25104;&#19968;&#27425;DFS&#65292;&#30465;&#20221;&#25968;&#37327;+1
</span>            }
        }
        <span class="org-keyword">return</span> count;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:f9a869b3-ad59-4914-be33-843b686cd822" class="outline-4">
<h4 id="h:f9a869b3-ad59-4914-be33-843b686cd822"><a href="#h:f9a869b3-ad59-4914-be33-843b686cd822">3.判断二分图</a></h4>
<div class="outline-text-4" id="text-h:f9a869b3-ad59-4914-be33-843b686cd822">
<p>
<a href="https://leetcode.cn/problems/is-graph-bipartite/">https://leetcode.cn/problems/is-graph-bipartite/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#23384;&#22312;&#19968;&#20010; &#26080;&#21521;&#22270; &#65292;&#22270;&#20013;&#26377; n &#20010;&#33410;&#28857;&#12290;&#20854;&#20013;&#27599;&#20010;&#33410;&#28857;&#37117;&#26377;&#19968;&#20010;&#20171;&#20110; 0 &#21040; n - 1 &#20043;&#38388;&#30340;&#21807;&#19968;&#32534;&#21495;&#12290;&#32473;
&#20320;&#19968;&#20010;&#20108;&#32500;&#25968;&#32452; graph &#65292;&#20854;&#20013; graph[u] &#26159;&#19968;&#20010;&#33410;&#28857;&#25968;&#32452;&#65292;&#30001;&#33410;&#28857; u &#30340;&#37051;&#25509;&#33410;&#28857;&#32452;&#25104;&#12290;&#24418;&#24335;&#19978;&#65292;
&#23545;&#20110; graph[u] &#20013;&#30340;&#27599;&#20010; v &#65292;&#37117;&#23384;&#22312;&#19968;&#26465;&#20301;&#20110;&#33410;&#28857; u &#21644;&#33410;&#28857; v &#20043;&#38388;&#30340;&#26080;&#21521;&#36793;&#12290;&#35813;&#26080;&#21521;&#22270;&#21516;&#26102;&#20855;&#26377;&#20197;&#19979;&#23646;&#24615;&#65306;

&#19981;&#23384;&#22312;&#33258;&#29615;&#65288;graph[u] &#19981;&#21253;&#21547; u&#65289;&#12290;
&#19981;&#23384;&#22312;&#24179;&#34892;&#36793;&#65288;graph[u] &#19981;&#21253;&#21547;&#37325;&#22797;&#20540;&#65289;&#12290;
&#22914;&#26524; v &#22312; graph[u] &#20869;&#65292;&#37027;&#20040; u &#20063;&#24212;&#35813;&#22312; graph[v] &#20869;&#65288;&#35813;&#22270;&#26159;&#26080;&#21521;&#22270;&#65289;
&#36825;&#20010;&#22270;&#21487;&#33021;&#19981;&#26159;&#36830;&#36890;&#22270;&#65292;&#20063;&#23601;&#26159;&#35828;&#20004;&#20010;&#33410;&#28857; u &#21644; v &#20043;&#38388;&#21487;&#33021;&#19981;&#23384;&#22312;&#19968;&#26465;&#36830;&#36890;&#24444;&#27492;&#30340;&#36335;&#24452;&#12290;
&#20108;&#20998;&#22270; &#23450;&#20041;&#65306;&#22914;&#26524;&#33021;&#23558;&#19968;&#20010;&#22270;&#30340;&#33410;&#28857;&#38598;&#21512;&#20998;&#21106;&#25104;&#20004;&#20010;&#29420;&#31435;&#30340;&#23376;&#38598; A &#21644; B &#65292;&#24182;&#20351;&#22270;&#20013;&#30340;&#27599;&#19968;&#26465;&#36793;&#30340;&#20004;&#20010;&#33410;&#28857;&#19968;&#20010;&#26469;&#33258; A &#38598;&#21512;&#65292;&#19968;&#20010;&#26469;&#33258; B &#38598;&#21512;&#65292;&#23601;&#23558;&#36825;&#20010;&#22270;&#31216;&#20026; &#20108;&#20998;&#22270; &#12290;

&#22914;&#26524;&#22270;&#26159;&#20108;&#20998;&#22270;&#65292;&#36820;&#22238; true &#65307;&#21542;&#21017;&#65292;&#36820;&#22238; false &#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;graph = [[1,2,3],[0,2],[0,1,3],[0,2]]
&#36755;&#20986;&#65306;false
&#35299;&#37322;&#65306;&#19981;&#33021;&#23558;&#33410;&#28857;&#20998;&#21106;&#25104;&#20004;&#20010;&#29420;&#31435;&#30340;&#23376;&#38598;&#65292;&#20197;&#20351;&#27599;&#26465;&#36793;&#37117;&#36830;&#36890;&#19968;&#20010;&#23376;&#38598;&#20013;&#30340;&#19968;&#20010;&#33410;&#28857;&#19982;&#21478;&#19968;&#20010;&#23376;&#38598;&#20013;&#30340;&#19968;&#20010;&#33410;&#28857;&#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;graph = [[1,3],[0,2],[1,3],[0,2]]
&#36755;&#20986;&#65306;true
&#35299;&#37322;&#65306;&#21487;&#20197;&#23558;&#33410;&#28857;&#20998;&#25104;&#20004;&#32452;: {0, 2} &#21644; {1, 3} &#12290;

&#25552;&#31034;&#65306;
graph.length == n
1 &lt;= n &lt;= 100
0 &lt;= graph[u].length &lt; n
0 &lt;= graph[u][i] &lt;= n - 1
graph[u] &#19981;&#20250;&#21253;&#21547; u
graph[u] &#30340;&#25152;&#26377;&#20540; &#20114;&#19981;&#30456;&#21516;
&#22914;&#26524; graph[u] &#21253;&#21547; v&#65292;&#37027;&#20040; graph[v] &#20063;&#20250;&#21253;&#21547; u
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-type">int</span> <span class="org-variable-name">color</span>[101];
    <span class="org-type">int</span> <span class="org-variable-name">matrix</span>[101][101]; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#19968;&#20010;&#37051;&#25509;&#30697;&#38453;
</span>
<span class="org-keyword">public</span>:
    <span class="org-type">bool</span> <span class="org-function-name">isBipartite</span>(<span class="org-type">vector</span>&lt;<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&gt;&amp; <span class="org-variable-name">graph</span>) {
        memset(color, -1, <span class="org-keyword">sizeof</span>(color));
        memset(matrix, 0, <span class="org-keyword">sizeof</span>(matrix)); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#21270;&#65292;&#20219;&#24847;&#20004;&#28857;&#26159;&#27809;&#26377;&#36793;&#30340;
</span>        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; graph.size(); ++i) {
            <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; graph[i].size(); ++j) {
                <span class="org-type">int</span> <span class="org-variable-name">u</span> = i;             <span class="org-comment-delimiter">// </span><span class="org-comment">&#39030;&#28857;
</span>                <span class="org-type">int</span> <span class="org-variable-name">v</span> = graph[i][j];   <span class="org-comment-delimiter">// </span><span class="org-comment">&#30456;&#37051;&#30340;&#36793;
</span>                matrix[u][v] = 1;      <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#37051;&#25509;&#34920;&#36716;&#25104;&#37051;&#25509;&#30697;&#38453;
</span>            }
        }
        <span class="org-type">int</span> <span class="org-variable-name">n</span> = graph.size();
        <span class="org-keyword">while</span> (1) {
            <span class="org-type">int</span> <span class="org-variable-name">u</span> = -1;
            <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; ++i) {
                <span class="org-keyword">if</span>(color[i] == -1) {
                    u = i;
                    <span class="org-keyword">break</span>;
                }
            }
            <span class="org-keyword">if</span>(u == -1) {
                <span class="org-keyword">break</span>;
            }
            color[u] = 0;
            <span class="org-type">queue</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">q</span>;
            q.push(u);
            <span class="org-keyword">while</span>(<span class="org-negation-char">!</span>q.empty()) {
                u = q.front();
                q.pop();
                <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; ++i) {
                    <span class="org-type">int</span> <span class="org-variable-name">v</span> = i;
                    <span class="org-keyword">if</span>(matrix[u][v] == 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#27809;&#26377;&#36793;&#26102;&#65292;&#19981;&#33021;&#35775;&#38382;
</span>                        <span class="org-keyword">continue</span>;
                    }
                    <span class="org-keyword">if</span>(color[v] != -1) {
                        <span class="org-keyword">if</span>(color[v] == color[u]) {
                            <span class="org-keyword">return</span> <span class="org-constant">false</span>;
                        }
                    }<span class="org-keyword">else</span> {
                        color[v] = 1 - color[u];
                        q.push(v);
                    }
                }
            }
        }
        <span class="org-keyword">return</span> <span class="org-constant">true</span>;
    }
};
</pre>
</div>
</div>
</div>
</div>
</section>
<section id="outline-container-h:c594ba4a-347f-4171-b1ec-b9386a3c2472" class="outline-2">
<h2 id="h:c594ba4a-347f-4171-b1ec-b9386a3c2472"><a href="#h:c594ba4a-347f-4171-b1ec-b9386a3c2472">图形结构-邻接表</a></h2>
<div class="outline-text-2" id="text-h:c594ba4a-347f-4171-b1ec-b9386a3c2472">
</div>
<div id="outline-container-h:43e05dd8-f6bd-4730-9b51-2a6d7505a40c" class="outline-3">
<h3 id="h:43e05dd8-f6bd-4730-9b51-2a6d7505a40c"><a href="#h:43e05dd8-f6bd-4730-9b51-2a6d7505a40c">邻接表（概念篇）</a></h3>
<div class="outline-text-3" id="text-h:43e05dd8-f6bd-4730-9b51-2a6d7505a40c">
<p>
邻接表的应用场景
</p>
</div>
<div id="outline-container-h:85646b11-a09a-4488-b79b-9b897a469ba8" class="outline-4">
<h4 id="h:85646b11-a09a-4488-b79b-9b897a469ba8"><a href="#h:85646b11-a09a-4488-b79b-9b897a469ba8">邻接表的概念</a></h4>
<div class="outline-text-4" id="text-h:85646b11-a09a-4488-b79b-9b897a469ba8">
<p>
邻接表是一种表示图的数据结构。邻接表的主要概念是:对于图中的每个顶点，维护一个由与其相邻的顶点组成的列表。这个列表可以用数组、链表或其他数据结构来实现。
</p>

<p>
实际上，邻接表可以用于有向图、无向图、带权图、无权图。这里只考虑无权图的情况，带权图只需要多存储一个数据就可以了，大家可以举一反三，触类旁通。
</p>
</div>
</div>
<div id="outline-container-h:637ff9e0-7950-4367-86ea-06790cb59af0" class="outline-4">
<h4 id="h:637ff9e0-7950-4367-86ea-06790cb59af0"><a href="#h:637ff9e0-7950-4367-86ea-06790cb59af0">邻接表的顺序表存储</a></h4>
<div class="outline-text-4" id="text-h:637ff9e0-7950-4367-86ea-06790cb59af0">
<p>
在C语言的静态数组中，如果要实现邻接表，一般图中的点的数量控制在1000左右的量级，是比较合适的，如果在大一点，存储会产生问题。
</p>

<p>
在C++中，有vector这种柔性数组，所以可以支持百万的量级。当然，也可以用C语言的静态数组来模拟实现一个C++中的柔性数组。
</p>

<p>
这里不讨论柔性数组的情况，只考虑1000量级的情况，如下:
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#define</span> <span class="org-variable-name">maxn</span> 1010
<span class="org-type">int</span> <span class="org-variable-name">adjSize</span>[maxn];
<span class="org-type">int</span> <span class="org-variable-name">adj</span>[maxn][maxn];
</pre>
</div>

<p>
其中adjSize[i]代表从i出发，能够直接到达的点的数量;
</p>

<p>
而adj[i][j]代表从i出发，能够到达的第 j 个顶点;
</p>

<p>
在一个n个顶点的图上，由于任何一个顶点最多都有n-1个顶点相连，所以在C语言中，定义时必然要定义成二维数组，空间复杂度就是O(n^2)，对于一个稀疏图来说，数组实实现，浪费空间严重，建议采用链表实现。
</p>
</div>
</div>
<div id="outline-container-h:98e27aeb-1ca0-47d5-a4e5-7c03e507e320" class="outline-4">
<h4 id="h:98e27aeb-1ca0-47d5-a4e5-7c03e507e320"><a href="#h:98e27aeb-1ca0-47d5-a4e5-7c03e507e320">邻接表的链表存储</a></h4>
<div class="outline-text-4" id="text-h:98e27aeb-1ca0-47d5-a4e5-7c03e507e320">
<p>
用链表来实现邻接表，实际上就是对于每个顶点，它能够到达的顶点，都被存储在以它为头结点的链表上。
</p>


<figure id="org4791600">
<img src="././images/img-2025102433.png" alt="img-2025102433.png" width="50%">

</figure>

<p>
对于如上的图，存储的就是四个链表:
</p>
<div class="org-src-container">
<pre class="src src-text">0 -&gt; 3 -&gt; 2 -&gt; NULL
1 -&gt; 0 -&gt; NULL
2 -&gt; NULL
3 -&gt; 1 -&gt; NULL
</pre>
</div>

<p>
这就是用链表表示的邻接表。注意:这里实际上每个链表的头结点是存储在一个顺序表中的，所以严格意义上来说是顺序表+链表的实现。
</p>
</div>
</div>
<div id="outline-container-h:52462698-da5c-4d22-92cc-b0a346be41b7" class="outline-4">
<h4 id="h:52462698-da5c-4d22-92cc-b0a346be41b7"><a href="#h:52462698-da5c-4d22-92cc-b0a346be41b7">邻接表的应用</a></h4>
<div class="outline-text-4" id="text-h:52462698-da5c-4d22-92cc-b0a346be41b7">
<p>
邻接表一般应用在图的遍历算法，比如深度优先搜索、广度优先搜索。更加具体的，应用在最短路上，比如Dijkstra、Bellman-Ford、SPFA;以及最小生成树，比如Kruskal、Priim;还有拓扑排序、强连通分量、网络流、二分图最大匹配等等问题。
</p>
</div>
</div>
<div id="outline-container-h:9a2399fe-d5a3-4ec8-b5a8-d956e544be19" class="outline-4">
<h4 id="h:9a2399fe-d5a3-4ec8-b5a8-d956e544be19"><a href="#h:9a2399fe-d5a3-4ec8-b5a8-d956e544be19">邻接表的优点</a></h4>
<div class="outline-text-4" id="text-h:9a2399fe-d5a3-4ec8-b5a8-d956e544be19">
<p>
邻接表表示法的优点主要有空间效率、遍历效率。
</p>
<ol class="org-ol">
<li>空间利用率高: 邻接表通常比邻接矩阵更节省空间，尤其是对于稀疏图。因为邻接表仅需要存储实际存在的边，而邻接矩阵需要存储所有的边。</li>
<li>遍历速度: 邻接表表示法在遍历与某个顶点相邻的所有顶点时，时间复杂度与顶点的度成正比。对于稀疏图，这比邻接矩阵表示法的时间复杂度要低。</li>
</ol>
</div>
</div>
<div id="outline-container-h:9388a511-2f2e-4a06-aa64-63c11068f22f" class="outline-4">
<h4 id="h:9388a511-2f2e-4a06-aa64-63c11068f22f"><a href="#h:9388a511-2f2e-4a06-aa64-63c11068f22f">邻接表的缺点</a></h4>
<div class="outline-text-4" id="text-h:9388a511-2f2e-4a06-aa64-63c11068f22f">
<ol class="org-ol">
<li>不适合存储稠密图: 对于稠密图(即图中边的数量接近于n^2)，导致每个顶点的边列表过长，从而降低</li>
<li>代码复杂: 相比于邻接矩阵，实现代码会更加复杂一些。</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-h:0befef9f-0b32-42d8-bfe0-cb22f5250e1f" class="outline-3">
<h3 id="h:0befef9f-0b32-42d8-bfe0-cb22f5250e1f"><a href="#h:0befef9f-0b32-42d8-bfe0-cb22f5250e1f">代码篇</a></h3>
<div class="outline-text-3" id="text-h:0befef9f-0b32-42d8-bfe0-cb22f5250e1f">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-keyword">class</span> <span class="org-type">Graph</span> {
<span class="org-keyword">private</span>:
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36793;&#33410;&#28857;&#32467;&#26500;&#20307;
</span>    <span class="org-keyword">struct</span> <span class="org-type">EdgeNode</span> {
        <span class="org-type">int</span> <span class="org-variable-name">vertex</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#20195;&#34920;&#24359;&#23614;&#30340;&#39030;&#28857;&#32534;&#21495;
</span>        <span class="org-type">int</span> <span class="org-variable-name">weight</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#20195;&#34920;&#36793;&#26435;
</span>        <span class="org-type">EdgeNode</span>* <span class="org-variable-name">next</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25351;&#21521;&#19979;&#19968;&#26465;&#36793;&#30340;&#25351;&#38024;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21516;&#19968;&#20010;&#24359;&#22836;&#30340;&#25152;&#26377;&#36793;&#37117;&#26159;&#38142;&#25509;&#22312;&#19968;&#24352;&#38142;&#34920;&#19978;&#30340;&#65292;&#25152;&#20197;&#19981;&#29992;&#23384;&#20648;&#24359;&#22836;
</span>    };
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#39030;&#28857;&#30340;&#33410;&#28857;&#32467;&#26500;&#20307;
</span>    <span class="org-keyword">struct</span> <span class="org-type">VertexNode</span> {
        <span class="org-type">int</span> <span class="org-variable-name">vertex</span>;           <span class="org-comment-delimiter">// </span><span class="org-comment">&#39030;&#28857;&#20449;&#24687;
</span>        <span class="org-type">EdgeNode</span>* <span class="org-variable-name">firstEdge</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#25351;&#21521;&#30340;&#26159;EdgeNode&#20018;&#36215;&#26469;&#30340;&#38142;&#34920;&#30340;&#22836;&#25351;&#38024;
</span>    };

    <span class="org-type">int</span> <span class="org-variable-name">vertices</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">&#39030;&#28857;&#22836;&#30340;&#24635;&#25968;
</span>    <span class="org-type">VertexNode</span>* <span class="org-variable-name">nodes</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20195;&#34920;&#25968;&#32452;&#65292;&#25968;&#32452;&#20013;&#27599;&#20010;&#20803;&#32032;&#26159;&#39030;&#28857;&#33410;&#28857;&#65292;&#37319;&#29992;&#21160;&#24577;&#20998;&#37197;&#20869;&#23384;&#65292;&#25152;&#20197;&#23450;&#20041;&#25104;&#25351;&#38024;
</span>
<span class="org-keyword">public</span>:
    <span class="org-function-name">Graph</span>(<span class="org-type">int</span> <span class="org-variable-name">vertices</span>);               <span class="org-comment-delimiter">// </span><span class="org-comment">&#22836;&#30340;&#21019;&#24314;
</span>    ~<span class="org-function-name">Graph</span>();                          <span class="org-comment-delimiter">// </span><span class="org-comment">&#22836;&#30340;&#38144;&#27585;
</span>    <span class="org-type">void</span> <span class="org-function-name">addEdge</span>(<span class="org-type">int</span> <span class="org-variable-name">u</span>, <span class="org-type">int</span> <span class="org-variable-name">v</span>, <span class="org-type">int</span> <span class="org-variable-name">w</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#28155;&#21152;&#36793;&#65292;&#20195;&#34920;u&#21040;v&#30340;&#36793;&#65292;&#26435;&#20026;w
</span>    <span class="org-type">void</span> <span class="org-function-name">printGraph</span>();                 <span class="org-comment-delimiter">// </span><span class="org-comment">&#25171;&#21360;&#22270;&#30340;&#20449;&#24687;
</span>};

<span class="org-constant">Graph</span>::<span class="org-function-name">Graph</span>(<span class="org-type">int</span> <span class="org-variable-name">vertices</span>) {
    <span class="org-keyword">this</span>-&gt;vertices = vertices;
    nodes = <span class="org-keyword">new</span> <span class="org-type">VertexNode</span>[vertices]; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21160;&#24577;&#20998;&#37197;&#20869;&#23384;&#65292;&#21019;&#24314;&#39030;&#28857;&#25968;&#32452;
</span>    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; vertices; i++) {
        nodes[i].vertex = i;           <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#21270;&#39030;&#28857;&#20449;&#24687;
</span>        nodes[i].firstEdge = <span class="org-constant">NULL</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#21270;&#36793;&#25351;&#38024;&#20026;&#31354;
</span>    }
}

<span class="org-constant">Graph</span>::~<span class="org-function-name">Graph</span>() {
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; vertices; ++i) {
        <span class="org-type">EdgeNode</span>* <span class="org-variable-name">curr</span> = nodes[i].firstEdge; <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#38142;&#34920;&#22836;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#36890;&#36807;&#36941;&#21382;&#38142;&#34920;&#37322;&#25918;&#27599;&#20010;&#36793;&#33410;&#28857;
</span>        <span class="org-keyword">while</span> (curr) {
            <span class="org-type">EdgeNode</span>* <span class="org-variable-name">temp</span> = curr;
            curr = curr-&gt;next;
            <span class="org-keyword">delete</span> temp;
        }
    }
    <span class="org-keyword">delete</span>[] nodes; <span class="org-comment-delimiter">// </span><span class="org-comment">&#37322;&#25918;&#39030;&#28857;&#25968;&#32452;
</span>}

<span class="org-type">void</span> <span class="org-constant">Graph</span>::<span class="org-function-name">addEdge</span>(<span class="org-type">int</span> <span class="org-variable-name">u</span>, <span class="org-type">int</span> <span class="org-variable-name">v</span>, <span class="org-type">int</span> <span class="org-variable-name">w</span>) {
    <span class="org-type">EdgeNode</span>* <span class="org-variable-name">newEdge</span> = <span class="org-keyword">new</span> <span class="org-type">EdgeNode</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21019;&#24314;&#26032;&#30340;&#36793;&#33410;&#28857;
</span>    newEdge-&gt;vertex = v;              <span class="org-comment-delimiter">// </span><span class="org-comment">&#35774;&#32622;&#24359;&#23614;&#39030;&#28857;
</span>    newEdge-&gt;weight = w;              <span class="org-comment-delimiter">// </span><span class="org-comment">&#35774;&#32622;&#36793;&#26435;
</span>    newEdge-&gt;next = nodes[u].firstEdge; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#26032;&#36793;&#25554;&#20837;&#21040;&#38142;&#34920;&#22836;&#37096;
</span>    nodes[u].firstEdge = newEdge;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#26356;&#26032;&#38142;&#34920;&#22836;&#25351;&#38024;
</span>}

<span class="org-type">void</span> <span class="org-constant">Graph</span>::<span class="org-function-name">printGraph</span>() {
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; vertices; ++i) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#20808;&#25171;&#21360;&#24359;&#22836;&#65292;&#20063;&#23601;&#26159;&#39030;&#28857;&#20449;&#24687;
</span>        <span class="org-type">EdgeNode</span>* <span class="org-variable-name">curr</span> = nodes[i].firstEdge;
        cout &lt;&lt; <span class="org-string">"Vertex"</span> &lt;&lt; i &lt;&lt; <span class="org-string">": "</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#25171;&#21360;&#24359;&#23614;&#21644;&#26435;
</span>        <span class="org-keyword">while</span> (curr) {
            cout &lt;&lt; curr-&gt;vertex &lt;&lt; <span class="org-string">"("</span> &lt;&lt; curr-&gt;weight &lt;&lt; <span class="org-string">")"</span>;
            curr = curr-&gt;next;
        }
        cout &lt;&lt; endl;
    }
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">Graph</span> <span class="org-variable-name">graph</span>(5);
    graph.addEdge(0, 1, 4); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21152;&#20837;&#24359;&#22836;&#20026;0&#65292; &#24359;&#23614;&#20026;1&#65292;&#26435;&#37325;&#20026;4&#30340;&#36793;
</span>    graph.addEdge(0, 2, 2);
    graph.addEdge(1, 2, 3);
    graph.addEdge(2, 3, 4);
    graph.addEdge(3, 4, 2);

    graph.printGraph();
    <span class="org-keyword">return</span>  0;
}

<span class="org-comment-delimiter">/*</span><span class="org-comment">
Vertex0: 2(2)1(4)
Vertex1: 2(3)
Vertex2: 3(4)
Vertex3: 4(2)
Vertex4:
</span><span class="org-comment-delimiter">*/</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-h:efb22c33-603f-4c19-8c83-a1aec57e3dff" class="outline-3">
<h3 id="h:efb22c33-603f-4c19-8c83-a1aec57e3dff"><a href="#h:efb22c33-603f-4c19-8c83-a1aec57e3dff">实战篇</a></h3>
<div class="outline-text-3" id="text-h:efb22c33-603f-4c19-8c83-a1aec57e3dff">
</div>
<div id="outline-container-h:3a5c2cd3-7e75-40f5-bc2f-ad676fa540d4" class="outline-4">
<h4 id="h:3a5c2cd3-7e75-40f5-bc2f-ad676fa540d4"><a href="#h:3a5c2cd3-7e75-40f5-bc2f-ad676fa540d4">1.传递信息</a></h4>
<div class="outline-text-4" id="text-h:3a5c2cd3-7e75-40f5-bc2f-ad676fa540d4">
<p>
<a href="https://leetcode.cn/problems/chuan-di-xin-xi/">https://leetcode.cn/problems/chuan-di-xin-xi/</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">edges</span>[10]; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#37051;&#25509;&#34920;
</span>    <span class="org-type">int</span> <span class="org-variable-name">N</span>;
    
    <span class="org-type">int</span> <span class="org-function-name">dfs</span>(<span class="org-type">int</span> <span class="org-variable-name">u</span>, <span class="org-type">int</span> <span class="org-variable-name">k</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;u&#20986;&#21457;&#32463;&#36807;&#22810;&#23569;&#26465;&#36793;&#21040;&#36798;N-1&#30340;&#26041;&#26696;&#25968;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">1. &#36882;&#24402;&#20986;&#21475;
</span>        <span class="org-keyword">if</span>(k == 0) {
            <span class="org-keyword">if</span> (u == N-1) {
                <span class="org-keyword">return</span> 1;
            }
            <span class="org-keyword">return</span> 0;
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#26522;&#20030;&#20013;&#36716;&#28857;
</span>        <span class="org-type">int</span> <span class="org-variable-name">sum</span> = 0;
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; edges[u].size(); ++i) {
            <span class="org-type">int</span> <span class="org-variable-name">v</span> = edges[u][i]; <span class="org-comment-delimiter">// </span><span class="org-comment">edges[u] &#30340;&#31532;i&#26465;&#36793;&#23545;&#24212;&#30340;&#39030;&#28857;
</span>            sum += dfs(v, k-1);
        }
        <span class="org-keyword">return</span> sum;
    }
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">numWays</span>(<span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-type">vector</span>&lt;<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&gt;&amp; <span class="org-variable-name">relation</span>, <span class="org-type">int</span> <span class="org-variable-name">k</span>) {
        N = n;
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;&#36793;&#34920;&#31034;&#27861;&#21464;&#20026;&#37051;&#25509;&#34920;&#34920;&#31034;&#27861;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#21270;&#37051;&#25509;&#34920;
</span>        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; N; ++i) {
            edges[i].clear();
        }
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; relation.size(); ++i) {
            <span class="org-type">int</span> <span class="org-variable-name">a</span> = relation[i][0];
            <span class="org-type">int</span> <span class="org-variable-name">b</span> = relation[i][1];
            edges[a].push_back(b);
        }
        <span class="org-keyword">return</span> dfs(0, k); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;0&#36825;&#20010;&#28857;&#20986;&#21457;&#32463;&#36807;k&#27493;&#65292;&#21040;&#36798;N-1&#30340;&#26041;&#26696;&#25968;
</span>    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:1e26d03e-f4b6-4716-aa08-728116e67d0e" class="outline-4">
<h4 id="h:1e26d03e-f4b6-4716-aa08-728116e67d0e"><a href="#h:1e26d03e-f4b6-4716-aa08-728116e67d0e">2.省份数量</a></h4>
<div class="outline-text-4" id="text-h:1e26d03e-f4b6-4716-aa08-728116e67d0e">
<p>
<a href="https://leetcode.cn/problems/number-of-provinces/description/">https://leetcode.cn/problems/number-of-provinces/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">edges</span>[201]; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#37051;&#25509;&#34920;
</span>    <span class="org-type">bool</span> <span class="org-variable-name">color</span>[201];
    <span class="org-type">int</span> <span class="org-variable-name">count</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#30465;&#20221;&#25968;&#37327;
</span>    <span class="org-type">int</span> <span class="org-variable-name">n</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#24635;&#20849;&#22810;&#23569;&#20010;&#28857;&#65292;&#21363;&#37051;&#25509;&#30697;&#38453;&#30340;&#22823;&#23567;
</span>
    <span class="org-type">void</span> <span class="org-function-name">dfs</span>(<span class="org-type">int</span> <span class="org-variable-name">u</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">u&#34920;&#31034;&#24403;&#21069;&#35775;&#38382;&#21738;&#20010;&#39030;&#28857;
</span>        <span class="org-keyword">if</span>(color[u]) {                                  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#20043;&#21069;&#35775;&#38382;&#36807;&#20102;&#65292;&#23601;&#36820;&#22238;
</span>            <span class="org-keyword">return</span>;
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#27809;&#26377;&#35775;&#38382;&#23601;&#35775;&#38382;&#23427;&#65292;&#22914;&#26524;u&#21040;i&#26377;&#36793;&#65292;&#23601;&#35775;&#38382;i&#36825;&#20010;&#39030;&#28857;
</span>        color[u] = <span class="org-constant">true</span>;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt;edges[u].size(); ++i) {
            dfs(<span class="org-type">edges</span>[u][i]);
        }
    }
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">findCircleNum</span>(<span class="org-type">vector</span>&lt;<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&gt;&amp; <span class="org-variable-name">isConnected</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#29992;&#26579;&#33394;&#27861;&#26469;&#20570;
</span>        n = isConnected.size();
        count = 0;                           <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#21270;&#20026;0
</span>        memset(color, <span class="org-constant">false</span>, <span class="org-keyword">sizeof</span>(color)); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#19968;&#27573;&#20869;&#23384;&#22359;&#35774;&#32622;&#20026;&#29305;&#23450;&#30340;&#20540;&#12290;&#23558;color&#21021;&#22987;&#21270;&#20026;false
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#21270;&#37051;&#25509;&#34920;
</span>        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; ++i) {
            edges[i].clear();
        }
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; ++i) {
            <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; n; ++j) {
                <span class="org-keyword">if</span>(isConnected[i][j] == 1) {
                    edges[i].push_back(j);
                }
            }
        }
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n ; ++i ) {
            <span class="org-keyword">if</span>(color[i] == <span class="org-constant">false</span>) {          <span class="org-comment-delimiter">// </span><span class="org-comment">&#34920;&#31034;&#36825;&#20010;&#39030;&#28857;&#27809;&#26377;&#34987;&#35775;&#38382;&#36807;&#65292;&#23601;&#35201;&#35775;&#38382;&#23427;
</span>                dfs(i);
                ++count;                     <span class="org-comment-delimiter">// </span><span class="org-comment">&#23436;&#25104;&#19968;&#27425;DFS&#65292;&#30465;&#20221;&#25968;&#37327;+1
</span>            }
        }
        <span class="org-keyword">return</span> count;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:c614bafe-02de-49f4-b173-f38b3f93d972" class="outline-4">
<h4 id="h:c614bafe-02de-49f4-b173-f38b3f93d972"><a href="#h:c614bafe-02de-49f4-b173-f38b3f93d972">3.判断二分图</a></h4>
<div class="outline-text-4" id="text-h:c614bafe-02de-49f4-b173-f38b3f93d972">
<p>
<a href="https://leetcode.cn/problems/is-graph-bipartite/">https://leetcode.cn/problems/is-graph-bipartite/</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
    <span class="org-type">int</span> <span class="org-variable-name">color</span>[101];


<span class="org-keyword">public</span>:
    <span class="org-type">bool</span> <span class="org-function-name">isBipartite</span>(<span class="org-type">vector</span>&lt;<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&gt;&amp; <span class="org-variable-name">graph</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#30475;&#26377;&#27809;&#26377;&#22855;&#25968;&#33410;&#28857;&#30340;&#29615;&#65292;&#22914;  0 2 3&#25104;&#29615;&#20102;&#23601;&#19981;&#26159;&#20108;&#20998;&#22270;&#12290;&#20063;&#23601;&#26159;&#22914;&#20309;&#21028;&#26029;&#22270;&#20013;&#26377;&#22855;&#25968;&#33410;&#28857;&#30340;&#29615;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#26579;&#33394;&#65292;&#31532;&#19968;&#20010;&#35775;&#38382;&#30340;&#28857;&#26579;&#32418;&#33394;&#65292;&#30456;&#37051;&#30340;&#28857;&#26579;&#40657;&#33394;&#65292;&#20877;&#40657;&#33394;&#28857;&#25226;&#30456;&#37051;&#28857;&#26579;&#32418;&#33394;&#65292;&#22914;&#26377;&#30456;&#37051;&#40657;&#33394;&#28857;&#23601;&#19981;&#21512;&#27861;&#65292;&#36339;&#20986;&#26579;&#33394;&#12290;
</span>        memset(color, -1, <span class="org-keyword">sizeof</span>(color));   <span class="org-comment-delimiter">// </span><span class="org-comment">-1 &#34920;&#31034;&#19968;&#24320;&#22987;&#27809;&#26377;&#20219;&#20309;&#26579;&#33394;
</span>        <span class="org-type">int</span> <span class="org-variable-name">n</span> = graph.size();               <span class="org-comment-delimiter">// </span><span class="org-comment">&#25152;&#26377;&#39030;&#28857;&#20010;&#25968;&#12290;graph&#26159;&#37051;&#25509;&#34920;
</span>        <span class="org-keyword">while</span> (1) {
            <span class="org-type">int</span> <span class="org-variable-name">u</span> = -1;
            <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; ++i) {
                <span class="org-keyword">if</span>(color[i] == -1) {        <span class="org-comment-delimiter">// </span><span class="org-comment">&#25214;&#21040;&#27809;&#34987;&#26579;&#33394;&#30340;&#28857;&#65292;
</span>                    u = i;
                    <span class="org-keyword">break</span>;
                }
            }
            <span class="org-keyword">if</span>(u == -1) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#35828;&#26126;&#25152;&#26377;&#28857;&#37117;&#34987;&#26579;&#33394;&#36807;&#20102;
</span>                <span class="org-keyword">break</span>;
            }
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#26579;&#33394;
</span>            color[u] = 0; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25214;&#21040;&#27809;&#26377;&#34987;&#26579;&#33394;&#30340;&#28857;&#65292;&#32479;&#19968;&#26579;&#25104;&#32418;&#33394; 0
</span>            <span class="org-type">queue</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">q</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36741;&#21161;&#38431;&#21015;&#65292;&#23558;u&#25918;&#20837;&#38431;&#21015;
</span>            q.push(u);
            <span class="org-keyword">while</span>(<span class="org-negation-char">!</span>q.empty()) {
                <span class="org-comment-delimiter">// </span><span class="org-comment">&#25343;&#38431;&#39318;&#20803;&#32032;&#12290;&#38431;&#21015;&#26159;&#20808;&#36827;&#20808;&#20986;&#30340;&#25968;&#25454;&#32467;&#26500;
</span>                u = q.front();  
                q.pop();
                <span class="org-comment-delimiter">// </span><span class="org-comment">&#36941;&#21382;&#21644;u&#30456;&#37051;&#30340;&#25152;&#26377;&#30340;&#28857;
</span>                <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; graph[u].size(); ++i) {
                    <span class="org-type">int</span> <span class="org-variable-name">v</span> = graph[u][i];           <span class="org-comment-delimiter">// </span><span class="org-comment">&#23384;&#20648;&#21644;u&#30456;&#37051;&#30340;&#31532;i&#20010;&#39030;&#28857;
</span>                    <span class="org-keyword">if</span>(color[v] != -1) {           <span class="org-comment-delimiter">// </span><span class="org-comment">!= -1 &#35828;&#26126;&#24050;&#32463;&#34987;&#26579;&#33394;&#36807;&#20102;&#65292;
</span>                        <span class="org-keyword">if</span>(color[v] == color[u]) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#30456;&#21516;&#65292;&#24517;&#28982;&#23384;&#22312;&#22855;&#29615;
</span>                            <span class="org-keyword">return</span> <span class="org-constant">false</span>;
                        }
                    }<span class="org-keyword">else</span> {
                        color[v] = 1 - color[u];   <span class="org-comment-delimiter">// </span><span class="org-comment">v&#30340;&#39068;&#33394;&#21464;&#25104;u&#30340;&#39068;&#33394;&#30456;&#21453;&#25968;
</span>                        q.push(v);                 <span class="org-comment-delimiter">// </span><span class="org-comment">&#25918;&#21040;&#38431;&#21015;&#23614;&#32487;&#32493;&#24490;&#29615;
</span>                    }
                }
            }
        }
        <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25152;&#26377;&#28857;&#37117;&#34987;&#26579;&#33394;&#65292;&#35828;&#26126;&#23427;&#23601;&#26159;&#20010;&#20108;&#20998;&#22270;
</span>    }
};
</pre>
</div>
</div>
</div>
</div>
</section>
<section id="outline-container-h:3bb59632-f537-4a02-9565-dacd49f79c49" class="outline-2">
<h2 id="h:3bb59632-f537-4a02-9565-dacd49f79c49"><a href="#h:3bb59632-f537-4a02-9565-dacd49f79c49">散列结构-哈希表</a></h2>
<div class="outline-text-2" id="text-h:3bb59632-f537-4a02-9565-dacd49f79c49">
</div>
<div id="outline-container-h:118a0a8f-dfa0-4105-b454-b72a8703dfc3" class="outline-3">
<h3 id="h:118a0a8f-dfa0-4105-b454-b72a8703dfc3"><a href="#h:118a0a8f-dfa0-4105-b454-b72a8703dfc3">哈希表（概念篇）</a></h3>
<div class="outline-text-3" id="text-h:118a0a8f-dfa0-4105-b454-b72a8703dfc3">
<p>
哈希表的增删改查、哈希表的应用场景
</p>
</div>
<div id="outline-container-h:a7291b2f-e7e3-4ff9-ba36-f423ab0a2a8d" class="outline-4">
<h4 id="h:a7291b2f-e7e3-4ff9-ba36-f423ab0a2a8d"><a href="#h:a7291b2f-e7e3-4ff9-ba36-f423ab0a2a8d">查找算法概述</a></h4>
<div class="outline-text-4" id="text-h:a7291b2f-e7e3-4ff9-ba36-f423ab0a2a8d">
<p>
当我们在一个链表或者顺序表中，查找一个数据元素是否存在的时候，唯一的方法就是遍历整个线性表，这种方法称为 <b>线性枚举</b> ，时间复杂度O(n)。
</p>

<p>
如果顺序表是有序的情况下，可以采用折半的方式进行查找，此所谓 <b>二分枚举</b> ，时间复杂度O(logn)。
</p>

<p>
那么是否存在更加快速的查找方式呢?让我们来学习一种新的数据结构&#x2013;哈希表。
</p>


<figure id="orgf71ee26">
<img src="././images/img-2025102434.png" alt="img-2025102434.png" width="50%">

</figure>

<p>
哈希表实际上是把一个关键字通过哈希函数变成哈希值，再映射到一个数组中。
</p>
</div>
</div>
<div id="outline-container-h:bb1f3579-1698-46f9-a2b8-97ad0240d062" class="outline-4">
<h4 id="h:bb1f3579-1698-46f9-a2b8-97ad0240d062"><a href="#h:bb1f3579-1698-46f9-a2b8-97ad0240d062">哈希表的概念</a></h4>
<div class="outline-text-4" id="text-h:bb1f3579-1698-46f9-a2b8-97ad0240d062">
<p>
哈希表又叫散列表，我们需要把查找的数据通过一个函数映射，找到存储数据的位置，这个过程被称为哈希。需要查找的数据本身被称为关键字，通过函数映射将关键字变成哈希值的过程，这里的函数被称为哈希函数。
</p>

<p>
生成哈希值的过程可能产生冲突，需要进行冲突解决（如3 和 6与3取模都是0），解决完冲突以后，实际存储数据的位置被称为哈希地址。通俗的说，它就是一个数组下标，存储所有这些数据的表，就被称为哈希表。
</p>

<p>
为了方便索引，哈希表底层实现结构是一个顺序表，每个位置被称为一个槽，存储一个键值对。以下就是一个长度为8的哈希表。 
</p>

<div class="org-src-container">
<pre class="src src-text">0 1 2 3 4 5 6 7
</pre>
</div>
</div>
</div>
<div id="outline-container-h:94caccaf-f564-4026-b509-9e9ab1c00db9" class="outline-4">
<h4 id="h:94caccaf-f564-4026-b509-9e9ab1c00db9"><a href="#h:94caccaf-f564-4026-b509-9e9ab1c00db9">键值对的概念</a></h4>
<div class="outline-text-4" id="text-h:94caccaf-f564-4026-b509-9e9ab1c00db9">
<p>
键值对由键和值组成，键和值都可以是任意类型(比如整型、浮点型、浮点型、字符串、类等等)。
</p>

<p>
哈希表的实现过程中，我们需要通过一些手段将一个非整型的键转换成整数，也就是哈希值，从而通过0(1)的时间快速索引到它对应在哈希表中哪个位置。
</p>

<p>
而将一个非整形的关键字转换成整型的手段，就是哈希函数。
</p>
</div>
</div>
<div id="outline-container-h:06ff36a8-9628-4764-89f8-1c7ee08f93d6" class="outline-4">
<h4 id="h:06ff36a8-9628-4764-89f8-1c7ee08f93d6"><a href="#h:06ff36a8-9628-4764-89f8-1c7ee08f93d6">哈希函数的概念</a></h4>
<div class="outline-text-4" id="text-h:06ff36a8-9628-4764-89f8-1c7ee08f93d6">
<p>
哈希函数可以理解为小学课本上的那个函数y=f(x)，这里的f(x)就是哈希函数。x是键，y是哈希值。好的哈希函数应该具备两个特征:(1)单射;(2)雪崩效应。
</p>


<figure id="orgbbca199">
<img src="././images/img-2025102435.png" alt="img-2025102435.png" width="50%">

</figure>

<p>
单射很容易理解，图(a)中已知哈希值y，键x可能有两种情况，不是一个单射。图(b)中已知哈希值y，键x一定是唯一确定的，所以它是单射。
</p>

<p>
雪崩效应是为了让哈希值，更加符合随机分布的原则，哈希表中的的键分布的越随机，利用率越高，效率也越高。
</p>
</div>
</div>
<div id="outline-container-h:6eff32a0-a1d5-4d92-a1de-0abf66f80326" class="outline-4">
<h4 id="h:6eff32a0-a1d5-4d92-a1de-0abf66f80326"><a href="#h:6eff32a0-a1d5-4d92-a1de-0abf66f80326">哈希冲突的概念</a></h4>
<div class="outline-text-4" id="text-h:6eff32a0-a1d5-4d92-a1de-0abf66f80326">
<p>
哈希函数在生成哈希值的过程中，如果产生不同的关键字得到相同的哈希值，就被称为哈希冲突。
</p>
</div>
</div>
<div id="outline-container-h:d69f1895-36e3-4264-82bc-f7aa47efa138" class="outline-4">
<h4 id="h:d69f1895-36e3-4264-82bc-f7aa47efa138"><a href="#h:d69f1895-36e3-4264-82bc-f7aa47efa138">常用的哈希函数</a></h4>
<div class="outline-text-4" id="text-h:d69f1895-36e3-4264-82bc-f7aa47efa138">
<p>
1、直接定址法
</p>
<ul class="org-ul">
<li>直接定址法就是键本身就是哈希值，表示成函数就是f(x)=x，例如计数排序的原理，采用的就是直接定址法。由于哈希值是需要映射到顺序表中作为索引的，所以直接定地让法只能处理数据量较小的且为非负整数的键。</li>
</ul>

<p>
2、平方取中法
</p>
<ul class="org-ul">
<li>平方取中法就是对键进行平方运算，再取中间的某几位作为哈希值。例如对于键1314平方后得到1726596，取中间三位作为哈希值，即265。平方取中法比较适合于不清楚健的分布，且位数不是很大的情况</li>
</ul>

<p>
3、折叠法
</p>
<ul class="org-ul">
<li>折叠法是将关键字分割成位数相等的几部分，然后再进行求和，得到一个哈希值。例如，对于关键字5201314，将它分为四组，并且相加得到52+01+31+4=88，这个就是哈希值。</li>
</ul>

<p>
4、除留余数法
</p>
<ul class="org-ul">
<li>除留余数法，就是键的值模上哈希表长度，表示成函数f(x):xmodm，其中m代表了哈希表的长度。这种方法，不仅可以对关键字取模，也可以在平方取中法、折叠法之后再取双模。例如，对于一个长度为4的哈希表，可以将关键字模4得到哈希值。而这个方法也是我们要重点介绍的方法。</li>
</ul>


<figure id="orge2a36fa">
<img src="././images/img-2025102436.png" alt="img-2025102436.png" width="50%">

</figure>

<p>
5、位与法
</p>
<ul class="org-ul">
<li>哈希表的长度一般选择2的幂。</li>
<li>因为我们知道，取模运算是比较耗时的，而位运算相对较高效选择2的幂作为哈希表长度，可以将取模运算转换成二进制位与，令m等于2的k次，它的二进制表示是这样的</li>
</ul>

\begin{equation*}
m = \underbrace{(1000 \dots 000)_2} _\text{k}
  \end{equation*}

<ul class="org-ul">
<li>任何一个数模上m，就相当于取了m的二进制的低k位，像这样:</li>
</ul>

\begin{equation*}
m - 1 = \underbrace{(111 \dots 111)_2} _\text{k}
  \end{equation*}

<ul class="org-ul">
<li>所以和位与m-1的效果是一样的，像这样(注意，这里是C/C+-+的语法糖):</li>
</ul>

\begin{equation*}
x \% S == x  \& ( S - 1 )
  \end{equation*}

<ul class="org-ul">
<li>除了直接定址法，其他方法都可能导致哈希冲突，接下来我们讨论哈希冲突的解决方案。</li>
</ul>
</div>
</div>
<div id="outline-container-h:717b4b0d-306f-4d02-a1a7-24f7f57baa07" class="outline-4">
<h4 id="h:717b4b0d-306f-4d02-a1a7-24f7f57baa07"><a href="#h:717b4b0d-306f-4d02-a1a7-24f7f57baa07">哈希冲突的解决方案</a></h4>
<div class="outline-text-4" id="text-h:717b4b0d-306f-4d02-a1a7-24f7f57baa07">
<p>
解决哈希冲突的主要两种方法是开放地址法和 链地址法，无论是开放地址法，还是链地址法，都可以实现哈希表，我们只需要选择其中一种即可。
</p>

<p>
一般一些开源代码实现中，采用的是链地址法，而竞赛或者刷题想要快速实现一个哈希表，采用开放地址法会更加容易实现。
</p>

<p>
1、开放定址法
</p>
<ul class="org-ul">
<li>开放定址法就是一旦发生冲突，就去寻找下一个空的地址，只要哈希表足够大，总能找到一个空的位置，并且记录下来作为它的哈希值，公式如下:</li>
</ul>
\begin{equation*}
f_i(x)=(f(x)+d_i) mod \ m
  \end{equation*}

<ul class="org-ul">
<li>这里的di是一个数列，可以是常数列(1，1，1， &#x2026;，1)，也可以是等差数列(1，2，3，&#x2026;m-1)。</li>
</ul>


<figure id="org4026739">
<img src="././images/img-2025102437.gif" alt="img-2025102437.gif" width="50%">

</figure>

<ul class="org-ul">
<li>上图中采用的是，哈希函数算法是除留余数法采用的哈希冲突，解决方案是开放定址法。</li>

<li>哈希表的每个数据就是一个键，插入之前需要先进行查找，女如果找到的位置未被插入则执行插入，否则找到下一个未被插入的位置进行插入。</li>

<li>总共插入了6个数据，分别为:11、12、13、20、19、28。</li>
<li>这种方法需要注意的是:当插入数据超过哈希表长度时，不能再执行插入，否则会造成死循环。</li>
</ul>

<p>
2、链地址法
</p>
<ul class="org-ul">
<li>当产生冲突后，我们也可以选择不换位置，还是在原来的位置置，只是把哈希值相同的用链表串联起来，这种方法被称为链地址法。</li>
</ul>


<figure id="org6eec972">
<img src="././images/img-2025102438.gif" alt="img-2025102438.gif" width="50%">

</figure>

<ul class="org-ul">
<li>上图中采用的哈希函数算法是除留余数法，采用的哈希冲突解决方案是链地址法</li>
<li>哈希表的每个数据，保留了一个链表头结点和尾结点，插入之前需要先进行查找，如果找到的位置链表非空，则插入尾结点，并且更新尾结点。否则生成一个新的链表头结点和尾结点。</li>
<li>总共插入了6个数据:分别为:11、12、13、20、19、28。</li>
</ul>
</div>
</div>
<div id="outline-container-h:2e62b104-73d6-4832-bd0d-54aba15f3d55" class="outline-4">
<h4 id="h:2e62b104-73d6-4832-bd0d-54aba15f3d55"><a href="#h:2e62b104-73d6-4832-bd0d-54aba15f3d55">哈希表的初始化</a></h4>
<div class="outline-text-4" id="text-h:2e62b104-73d6-4832-bd0d-54aba15f3d55">
<p>
给定一个大小n，申请一个n个元素的数组，元素类型是哈希表键值对。
</p>
</div>
</div>
<div id="outline-container-h:e0587536-6a8a-48cc-8f68-950e6bb8a778" class="outline-4">
<h4 id="h:e0587536-6a8a-48cc-8f68-950e6bb8a778"><a href="#h:e0587536-6a8a-48cc-8f68-950e6bb8a778">哈希表的元素插入</a></h4>
<div class="outline-text-4" id="text-h:e0587536-6a8a-48cc-8f68-950e6bb8a778">
<p>
给定元素，利用哈希函数计算它的哈希值，对数组长度n取模以后，找到合适的位置，遍历这个位置上的链表，如果发现没有键值对相等的元素，则插入这个链表。
</p>
</div>
</div>
<div id="outline-container-h:a2c37701-66c2-4dfd-9138-b51ef72f1403" class="outline-4">
<h4 id="h:a2c37701-66c2-4dfd-9138-b51ef72f1403"><a href="#h:a2c37701-66c2-4dfd-9138-b51ef72f1403">哈希表的元素删除</a></h4>
<div class="outline-text-4" id="text-h:a2c37701-66c2-4dfd-9138-b51ef72f1403">
<p>
给定元素，利用哈希函数计算它的哈希值，对数组长度n取模以后，找到合适的位置，遍历这个位置上的链表，如果发现有键值对相等的元素，则从链表上进行删除。
</p>
</div>
</div>
<div id="outline-container-h:ecc07ee3-824e-4e9c-8634-9d7bc84802a1" class="outline-4">
<h4 id="h:ecc07ee3-824e-4e9c-8634-9d7bc84802a1"><a href="#h:ecc07ee3-824e-4e9c-8634-9d7bc84802a1">哈希表的元素查找</a></h4>
<div class="outline-text-4" id="text-h:ecc07ee3-824e-4e9c-8634-9d7bc84802a1">
<p>
给定元素，利用哈希函数计算它的哈希值，对数组长度n取模以后，找到合适的位置，遍历这个位置上的链表，如果发现有键值对相等的元素，返回true;否则，返回false。
</p>
</div>
</div>
</div>
<div id="outline-container-h:37411b00-5e26-418e-b3ba-550b4c044b86" class="outline-3">
<h3 id="h:37411b00-5e26-418e-b3ba-550b4c044b86"><a href="#h:37411b00-5e26-418e-b3ba-550b4c044b86">代码篇</a></h3>
<div class="outline-text-3" id="text-h:37411b00-5e26-418e-b3ba-550b4c044b86">
</div>
<div id="outline-container-h:7bd020b7-b151-4fa4-9909-2512a457ce7a" class="outline-4">
<h4 id="h:7bd020b7-b151-4fa4-9909-2512a457ce7a"><a href="#h:7bd020b7-b151-4fa4-9909-2512a457ce7a">1.哈希表</a></h4>
<div class="outline-text-4" id="text-h:7bd020b7-b151-4fa4-9909-2512a457ce7a">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">&#21704;&#24076;&#20989;&#25968;&#65306;&#37319;&#29992;&#21462;&#27169;&#26041;&#24335;&#12290; &#21704;&#24076;&#20914;&#31361;&#65306;&#37319;&#29992;&#38142;&#22320;&#22336;&#27861;&#35299;&#20915;&#12290;
</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#21704;&#24076;&#33410;&#28857;&#31867;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">KeyType</span>, <span class="org-keyword">typename</span> <span class="org-type">ValueType</span>&gt;
<span class="org-keyword">class</span> <span class="org-type">HashNode</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">KeyType</span> <span class="org-variable-name">key</span>;
    <span class="org-type">ValueType</span> <span class="org-variable-name">value</span>;
    <span class="org-type">HashNode</span>* <span class="org-variable-name">next</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25351;&#21521;&#19979;&#19968;&#20010;&#33410;&#28857;&#30340;&#25351;&#38024;
</span>
    <span class="org-function-name">HashNode</span>(<span class="org-keyword">const</span> <span class="org-type">KeyType</span>&amp; <span class="org-variable-name">key</span>, <span class="org-keyword">const</span> <span class="org-type">ValueType</span>&amp; <span class="org-variable-name">value</span>) {
        <span class="org-keyword">this</span>-&gt;key = key;
        <span class="org-keyword">this</span>-&gt;value = value;
        <span class="org-keyword">this</span>-&gt;next = <span class="org-constant">NULL</span>;
    }
};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#21704;&#24076;&#34920;&#27169;&#26495;&#31867;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">KeyType</span>, <span class="org-keyword">typename</span> <span class="org-type">ValueType</span>&gt;
<span class="org-keyword">class</span> <span class="org-type">HashTable</span> {
<span class="org-keyword">private</span>:
    <span class="org-type">int</span> <span class="org-variable-name">size</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21704;&#24076;&#34920;&#25968;&#32452;&#30340;&#22823;&#23567;
</span>    <span class="org-type">HashNode</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;** <span class="org-variable-name">table</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23384;&#20648;&#21704;&#24076;&#34920;&#33410;&#28857;&#30340;&#25968;&#32452;&#12290;
</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25968;&#32452;&#26159;&#21160;&#24577;&#20998;&#37197;&#30340;&#65292;&#24182;&#19988;&#27599;&#20010;&#25968;&#32452;&#20803;&#32032;&#26159;&#19968;&#20010;&#25351;&#21521;&#38142;&#34920;&#22836;&#33410;&#28857;&#30340;&#25351;&#38024;&#65292;&#25152;&#20197;table&#26159;&#19968;&#20010;&#20108;&#32423;&#25351;&#38024;&#12290;
</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#21704;&#24076;&#20989;&#25968;&#65292;&#20256;&#36827;&#26469;&#30340;&#38190;&#19981;&#33021;&#34987;&#25913;&#21464;&#65292;&#19981;&#33021;&#25913;&#21464;&#25104;&#21592;&#21464;&#37327;
</span>    <span class="org-type">int</span> <span class="org-function-name">hash</span>(<span class="org-keyword">const</span> <span class="org-type">KeyType</span>&amp; <span class="org-variable-name">key</span>) <span class="org-keyword">const</span> {
        <span class="org-type">int</span> <span class="org-variable-name">hashkey</span> = key % size; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21462;&#27169;&#36816;&#31639;
</span>        <span class="org-keyword">if</span> (hashkey &lt; 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22788;&#29702;&#36127;&#25968;&#38190;&#20540;
</span>            hashkey += size;
        }
        <span class="org-keyword">return</span> hashkey;
    }

<span class="org-keyword">public</span>:
    <span class="org-function-name">HashTable</span>(<span class="org-type">int</span> <span class="org-variable-name">size</span>=256);
    ~<span class="org-function-name">HashTable</span>();
    <span class="org-type">void</span> <span class="org-function-name">insert</span>(<span class="org-keyword">const</span> <span class="org-type">KeyType</span>&amp; <span class="org-variable-name">key</span>, <span class="org-keyword">const</span> <span class="org-type">ValueType</span>&amp; <span class="org-variable-name">value</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25554;&#20837;&#30340;&#38190;&#21644;&#20540;&#19981;&#33021;&#20462;&#25913;&#65292;&#37319;&#29992;&#38190;&#20540;&#26412;&#20307;&#25152;&#20197;&#20351;&#29992;const&#24341;&#29992;
</span>    <span class="org-type">void</span> <span class="org-function-name">remove</span>(<span class="org-keyword">const</span> <span class="org-type">KeyType</span>&amp; <span class="org-variable-name">key</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;&#25351;&#23450;&#38190;&#30340;&#33410;&#28857;
</span>    <span class="org-type">bool</span> <span class="org-function-name">find</span>(<span class="org-keyword">const</span> <span class="org-type">KeyType</span>&amp; <span class="org-variable-name">key</span>, <span class="org-type">ValueType</span>&amp; <span class="org-variable-name">value</span>) <span class="org-keyword">const</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26597;&#25214;&#25351;&#23450;&#38190;&#30340;&#33410;&#28857;&#65292;&#24182;&#36820;&#22238;&#23545;&#24212;&#30340;&#20540;
</span>};

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">KeyType</span>, <span class="org-keyword">typename</span> <span class="org-type">ValueType</span>&gt;
<span class="org-constant">HashTable</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;::<span class="org-function-name">HashTable</span>(<span class="org-type">int</span> <span class="org-variable-name">size</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#40664;&#35748;&#30340;&#22823;&#23567;&#21435;&#25481;&#65292;&#22240;&#20026;&#22312;&#31867;&#30340;&#22768;&#26126;&#20013;&#26377;&#20102;
</span>    <span class="org-keyword">this</span>-&gt;size = size;
    table = <span class="org-keyword">new</span> <span class="org-type">HashNode</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;* [<span class="org-constant">size</span>]; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21160;&#24577;&#20998;&#37197;&#25968;&#32452;
</span>    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; size; ++i) {
        <span class="org-keyword">this</span>-&gt;table[i] = <span class="org-constant">NULL</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#21270;&#27599;&#20010;&#38142;&#34920;&#22836;&#25351;&#38024;&#20026;NULL
</span>    }
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">KeyType</span>, <span class="org-keyword">typename</span> <span class="org-type">ValueType</span>&gt;
<span class="org-constant">HashTable</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;::~<span class="org-function-name">HashTable</span>() {
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; size; ++i) {
        <span class="org-keyword">if</span> (table[i]) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#38142;&#34920;&#38750;&#31354;
</span>            <span class="org-type">HashNode</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;* <span class="org-variable-name">current</span> = table[i];
            <span class="org-keyword">while</span> (current) {
                <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;&#24403;&#21069;&#33410;&#28857;&#30340;&#21518;&#19968;&#33410;&#28857;&#20445;&#23384;&#22312;next&#20013;
</span>                <span class="org-type">HashNode</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;* <span class="org-variable-name">next</span> = current-&gt;next;
                <span class="org-keyword">delete</span> current; <span class="org-comment-delimiter">// </span><span class="org-comment">&#28165;&#29702;&#24403;&#21069;&#33410;&#28857;&#20869;&#23384;
</span>                current = next; <span class="org-comment-delimiter">// </span><span class="org-comment">&#32487;&#32493;&#22788;&#29702;&#19979;&#19968;&#33410;&#28857;
</span>            }
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#28165;&#29702;&#23436;&#27605;&#65292;&#23558;&#38142;&#34920;&#22836;&#25351;&#38024;&#35774;&#20026;NULL
</span>            table[i] = <span class="org-constant">NULL</span>;
        }
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">table&#26412;&#36523;&#28165;&#29702;&#25481;
</span>    <span class="org-keyword">delete</span>[] table;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">KeyType</span>, <span class="org-keyword">typename</span> <span class="org-type">ValueType</span>&gt;
<span class="org-type">void</span> <span class="org-constant">HashTable</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;::<span class="org-function-name">insert</span>(<span class="org-keyword">const</span> <span class="org-type">KeyType</span>&amp; <span class="org-variable-name">key</span>, <span class="org-keyword">const</span> <span class="org-type">ValueType</span>&amp; <span class="org-variable-name">value</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#35745;&#31639;&#21704;&#24076;&#32034;&#24341;&#65292;&#20877;&#21033;&#29992;&#25552;&#20379;&#30340;&#38190;&#21644;&#20540;&#21019;&#24314;&#26032;&#33410;&#28857;
</span>    <span class="org-type">int</span> <span class="org-variable-name">index</span> = hash(key);
    <span class="org-type">HashNode</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;* <span class="org-variable-name">now</span> = <span class="org-keyword">new</span> HashNode&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;(key, value);
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#23545;&#24212;&#30340;&#38142;&#34920;&#20026;&#31354;&#65292;&#30452;&#25509;&#23558;&#26032;&#33410;&#28857;&#20316;&#20026;&#38142;&#34920;&#22836;&#33410;&#28857;; &#21542;&#21017;&#29992;&#22836;&#25554;&#27861;&#25554;&#20837;&#26032;&#33410;&#28857;
</span>    <span class="org-keyword">if</span> (table[index] == <span class="org-constant">NULL</span>) {
        table[index] = now;
    }
    <span class="org-keyword">else</span> {
        now-&gt;next = table[index];
        table[index] = now;
    }

}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">KeyType</span>, <span class="org-keyword">typename</span> <span class="org-type">ValueType</span>&gt;
<span class="org-type">void</span> <span class="org-constant">HashTable</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;::<span class="org-function-name">remove</span>(<span class="org-keyword">const</span> <span class="org-type">KeyType</span>&amp; <span class="org-variable-name">key</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36890;&#36807;&#38190;&#33719;&#21462;&#32034;&#24341;,&#28982;&#21518;&#21028;&#26029;&#38142;&#34920;&#26159;&#21542;&#20026;&#31354;
</span>    <span class="org-type">int</span> <span class="org-variable-name">index</span> = hash(key);
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#23384;&#22312;&#65292;&#21017;&#38656;&#35201;&#21028;&#26029;&#35201;&#21024;&#38500;&#30340;&#38190;&#26159;&#21542;&#21644;&#38142;&#34920;&#22836;&#30456;&#31561;
</span>    <span class="org-keyword">if</span> (table[index]) {
        <span class="org-keyword">if</span> (table[index]-&gt;key == key) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#30456;&#31561;&#65292;&#21017;&#21024;&#38500;&#38142;&#34920;&#22836;&#65292;&#23558;&#21518;&#32487;&#33410;&#28857;&#20316;&#20026;&#26032;&#38142;&#34920;&#22836;
</span>            <span class="org-type">HashNode</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;* <span class="org-variable-name">next</span> = table[index]-&gt;next;
            <span class="org-keyword">delete</span> table[index];
            table[index] = next;
        }
        <span class="org-keyword">else</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#19981;&#30456;&#31561;&#65292;&#25226;&#22836;&#33410;&#28857;&#32531;&#23384;&#21040;current&#20013;&#65292;&#36941;&#21382;&#38142;&#34920;
</span>            <span class="org-type">HashNode</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;* <span class="org-variable-name">current</span> = table[index];
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#21518;&#32487;&#33410;&#28857;&#19981;&#20026;&#31354;&#65292;&#21518;&#32487;&#33410;&#28857;&#30340;&#38190;&#19981;&#31561;&#20110;key&#65292;&#32487;&#32493;&#36941;&#21382;&#65292;&#30456;&#31561;&#21017;&#36339;&#20986;
</span>            <span class="org-keyword">while</span> (current-&gt;next &amp;&amp; current-&gt;next-&gt;key != key) {
                current = current-&gt;next;
            }
            <span class="org-comment-delimiter">// </span><span class="org-comment">current&#30340;&#21518;&#32487;&#33410;&#28857;&#23601;&#26159;&#35201;&#21024;&#38500;&#30340;&#33410;&#28857;&#65292;&#23558;&#35201;&#21024;&#38500;&#30340;&#33410;&#28857;&#30340;&#21518;&#32487;&#33410;&#28857;&#20445;&#23384;
</span>            <span class="org-keyword">if</span> (current-&gt;next) {
                <span class="org-type">HashNode</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;* <span class="org-variable-name">next</span> = current-&gt;next-&gt;next;
                <span class="org-keyword">delete</span> current-&gt;next;
                current-&gt;next = next; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36171;&#20540;&#32473;current-&gt;next
</span>            }
        }
    }

}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">KeyType</span>, <span class="org-keyword">typename</span> <span class="org-type">ValueType</span>&gt;
<span class="org-type">bool</span> <span class="org-constant">HashTable</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;::<span class="org-function-name">find</span>(<span class="org-keyword">const</span> <span class="org-type">KeyType</span>&amp; <span class="org-variable-name">key</span>, <span class="org-type">ValueType</span>&amp; <span class="org-variable-name">value</span>) <span class="org-keyword">const</span> {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36890;&#36807;&#38190;&#33719;&#21462;&#32034;&#24341;
</span>    <span class="org-type">int</span> <span class="org-variable-name">index</span> = hash(key);
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#21028;&#26029;&#38142;&#34920;&#26159;&#21542;&#23384;&#22312;&#65292;&#19981;&#23384;&#22312;&#30452;&#25509;&#36820;&#22238;false
</span>    <span class="org-keyword">if</span> (table[index]) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21028;&#26029;&#38190;&#26159;&#21542;&#22312;&#38142;&#34920;&#22836;
</span>        <span class="org-keyword">if</span> (table[index]-&gt;key == key) {
            value = table[index]-&gt;value;
            <span class="org-keyword">return</span> <span class="org-constant">true</span>;
        }
        <span class="org-keyword">else</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#19981;&#22312;&#38142;&#34920;&#22836;&#65292;&#30452;&#25509;&#29992;&#21024;&#38500;&#33410;&#28857;&#30340;&#20195;&#30721;
</span>            <span class="org-type">HashNode</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;* <span class="org-variable-name">current</span> = table[index];
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#21518;&#32487;&#33410;&#28857;&#19981;&#20026;&#31354;&#65292;&#21518;&#32487;&#33410;&#28857;&#30340;&#38190;&#19981;&#31561;&#20110;key&#65292;&#32487;&#32493;&#36941;&#21382;&#65292;&#30456;&#31561;&#21017;&#36339;&#20986;
</span>            <span class="org-keyword">while</span> (current-&gt;next &amp;&amp; current-&gt;next-&gt;key != key) {
                current = current-&gt;next;
            }
            <span class="org-comment-delimiter">// </span><span class="org-comment">current-&gt;next&#19981;&#20026;&#31354;&#65292;&#19968;&#23450;&#26159;&#23427;&#30340;&#38190;&#21644;&#20256;&#21442;&#30340;&#38190;&#30456;&#31561;&#30340;&#33410;&#28857;
</span>            <span class="org-keyword">if</span> (current-&gt;next) {
                value = current-&gt;next-&gt;value;
                <span class="org-keyword">return</span> <span class="org-constant">true</span>;
            }
        }
    }
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#24314;&#31435;&#38190;&#20026;int&#65292;&#20540;&#20026;char&#30340;&#21704;&#24076;&#34920;
</span>    <span class="org-type">HashTable</span>&lt;<span class="org-type">int</span>, <span class="org-type">char</span>&gt; <span class="org-variable-name">h</span>(1000);
    h.insert(1, <span class="org-string">'a'</span>);
    h.insert(2, <span class="org-string">'b'</span>);
    h.insert(3, <span class="org-string">'c'</span>);
    h.insert(41012012, <span class="org-string">'d'</span>);

    <span class="org-type">char</span> <span class="org-variable-name">val</span>;
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>h.find(43, val)) {
        cout &lt;&lt; <span class="org-string">"43 not found"</span> &lt;&lt; endl;
    }

    <span class="org-keyword">if</span> (h.find(41012012, val)) {
        cout &lt;&lt; <span class="org-string">"41012012 found, value is "</span> &lt;&lt; val &lt;&lt; endl;
    }

    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-h:444dc625-3407-4f6b-8d15-d225d4d3fbe7" class="outline-4">
<h4 id="h:444dc625-3407-4f6b-8d15-d225d4d3fbe7"><a href="#h:444dc625-3407-4f6b-8d15-d225d4d3fbe7">2.哈希计数器</a></h4>
<div class="outline-text-4" id="text-h:444dc625-3407-4f6b-8d15-d225d4d3fbe7">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">&#21704;&#24076;&#20989;&#25968;&#65306;&#37319;&#29992;&#21462;&#27169;&#26041;&#24335;&#12290; &#21704;&#24076;&#20914;&#31361;&#65306;&#37319;&#29992;&#38142;&#22320;&#22336;&#27861;&#35299;&#20915;&#12290;
</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#21704;&#24076;&#33410;&#28857;&#31867;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">KeyType</span>, <span class="org-keyword">typename</span> <span class="org-type">ValueType</span>&gt;
<span class="org-keyword">class</span> <span class="org-type">HashNode</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">KeyType</span> <span class="org-variable-name">key</span>;
    <span class="org-type">ValueType</span> <span class="org-variable-name">value</span>;
    <span class="org-type">HashNode</span>* <span class="org-variable-name">next</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25351;&#21521;&#19979;&#19968;&#20010;&#33410;&#28857;&#30340;&#25351;&#38024;
</span>
    <span class="org-function-name">HashNode</span>(<span class="org-keyword">const</span> <span class="org-type">KeyType</span>&amp; <span class="org-variable-name">key</span>, <span class="org-keyword">const</span> <span class="org-type">ValueType</span>&amp; <span class="org-variable-name">value</span>) {
        <span class="org-keyword">this</span>-&gt;key = key;
        <span class="org-keyword">this</span>-&gt;value = value;
        <span class="org-keyword">this</span>-&gt;next = <span class="org-constant">NULL</span>;
    }
};

<span class="org-comment-delimiter">// </span><span class="org-comment">&#21704;&#24076;&#34920;&#27169;&#26495;&#31867;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">KeyType</span>, <span class="org-keyword">typename</span> <span class="org-type">ValueType</span>&gt;
<span class="org-keyword">class</span> <span class="org-type">HashTable</span> {
<span class="org-keyword">private</span>:
    <span class="org-type">int</span> <span class="org-variable-name">size</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21704;&#24076;&#34920;&#25968;&#32452;&#30340;&#22823;&#23567;
</span>    <span class="org-type">HashNode</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;** <span class="org-variable-name">table</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23384;&#20648;&#21704;&#24076;&#34920;&#33410;&#28857;&#30340;&#25968;&#32452;&#12290;
</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25968;&#32452;&#26159;&#21160;&#24577;&#20998;&#37197;&#30340;&#65292;&#24182;&#19988;&#27599;&#20010;&#25968;&#32452;&#20803;&#32032;&#26159;&#19968;&#20010;&#25351;&#21521;&#38142;&#34920;&#22836;&#33410;&#28857;&#30340;&#25351;&#38024;&#65292;&#25152;&#20197;table&#26159;&#19968;&#20010;&#20108;&#32423;&#25351;&#38024;&#12290;
</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#21704;&#24076;&#20989;&#25968;&#65292;&#20256;&#36827;&#26469;&#30340;&#38190;&#19981;&#33021;&#34987;&#25913;&#21464;&#65292;&#19981;&#33021;&#25913;&#21464;&#25104;&#21592;&#21464;&#37327;
</span>    <span class="org-type">int</span> <span class="org-function-name">hash</span>(<span class="org-keyword">const</span> <span class="org-type">KeyType</span>&amp; <span class="org-variable-name">key</span>) <span class="org-keyword">const</span> {
        <span class="org-type">int</span> <span class="org-variable-name">hashkey</span> = key % size; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21462;&#27169;&#36816;&#31639;
</span>        <span class="org-keyword">if</span> (hashkey &lt; 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22788;&#29702;&#36127;&#25968;&#38190;&#20540;
</span>            hashkey += size;
        }
        <span class="org-keyword">return</span> hashkey;
    }

<span class="org-keyword">public</span>:
    <span class="org-function-name">HashTable</span>(<span class="org-type">int</span> <span class="org-variable-name">size</span>=256);
    ~<span class="org-function-name">HashTable</span>();
    <span class="org-type">void</span> <span class="org-function-name">insert</span>(<span class="org-keyword">const</span> <span class="org-type">KeyType</span>&amp; <span class="org-variable-name">key</span>, <span class="org-keyword">const</span> <span class="org-type">ValueType</span>&amp; <span class="org-variable-name">value</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25554;&#20837;&#30340;&#38190;&#21644;&#20540;&#19981;&#33021;&#20462;&#25913;&#65292;&#37319;&#29992;&#38190;&#20540;&#26412;&#20307;&#25152;&#20197;&#20351;&#29992;const&#24341;&#29992;
</span>    <span class="org-type">void</span> <span class="org-function-name">remove</span>(<span class="org-keyword">const</span> <span class="org-type">KeyType</span>&amp; <span class="org-variable-name">key</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;&#25351;&#23450;&#38190;&#30340;&#33410;&#28857;
</span>    <span class="org-type">bool</span> <span class="org-function-name">find</span>(<span class="org-keyword">const</span> <span class="org-type">KeyType</span>&amp; <span class="org-variable-name">key</span>, <span class="org-type">ValueType</span>&amp; <span class="org-variable-name">value</span>) <span class="org-keyword">const</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26597;&#25214;&#25351;&#23450;&#38190;&#30340;&#33410;&#28857;&#65292;&#24182;&#36820;&#22238;&#23545;&#24212;&#30340;&#20540;
</span>};

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">KeyType</span>, <span class="org-keyword">typename</span> <span class="org-type">ValueType</span>&gt;
<span class="org-constant">HashTable</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;::<span class="org-function-name">HashTable</span>(<span class="org-type">int</span> <span class="org-variable-name">size</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#40664;&#35748;&#30340;&#22823;&#23567;&#21435;&#25481;&#65292;&#22240;&#20026;&#22312;&#31867;&#30340;&#22768;&#26126;&#20013;&#26377;&#20102;
</span>    <span class="org-keyword">this</span>-&gt;size = size;
    table = <span class="org-keyword">new</span> <span class="org-type">HashNode</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;* [<span class="org-constant">size</span>]; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21160;&#24577;&#20998;&#37197;&#25968;&#32452;
</span>    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; size; ++i) {
        <span class="org-keyword">this</span>-&gt;table[i] = <span class="org-constant">NULL</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#21270;&#27599;&#20010;&#38142;&#34920;&#22836;&#25351;&#38024;&#20026;NULL
</span>    }
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">KeyType</span>, <span class="org-keyword">typename</span> <span class="org-type">ValueType</span>&gt;
<span class="org-constant">HashTable</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;::~<span class="org-function-name">HashTable</span>() {
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; size; ++i) {
        <span class="org-keyword">if</span> (table[i]) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#38142;&#34920;&#38750;&#31354;
</span>            <span class="org-type">HashNode</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;* <span class="org-variable-name">current</span> = table[i];
            <span class="org-keyword">while</span> (current) {
                <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;&#24403;&#21069;&#33410;&#28857;&#30340;&#21518;&#19968;&#33410;&#28857;&#20445;&#23384;&#22312;next&#20013;
</span>                <span class="org-type">HashNode</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;* <span class="org-variable-name">next</span> = current-&gt;next;
                <span class="org-keyword">delete</span> current; <span class="org-comment-delimiter">// </span><span class="org-comment">&#28165;&#29702;&#24403;&#21069;&#33410;&#28857;&#20869;&#23384;
</span>                current = next; <span class="org-comment-delimiter">// </span><span class="org-comment">&#32487;&#32493;&#22788;&#29702;&#19979;&#19968;&#33410;&#28857;
</span>            }
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#28165;&#29702;&#23436;&#27605;&#65292;&#23558;&#38142;&#34920;&#22836;&#25351;&#38024;&#35774;&#20026;NULL
</span>            table[i] = <span class="org-constant">NULL</span>;
        }
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">table&#26412;&#36523;&#28165;&#29702;&#25481;
</span>    <span class="org-keyword">delete</span>[] table;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">KeyType</span>, <span class="org-keyword">typename</span> <span class="org-type">ValueType</span>&gt;
<span class="org-type">void</span> <span class="org-constant">HashTable</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;::<span class="org-function-name">insert</span>(<span class="org-keyword">const</span> <span class="org-type">KeyType</span>&amp; <span class="org-variable-name">key</span>, <span class="org-keyword">const</span> <span class="org-type">ValueType</span>&amp; <span class="org-variable-name">value</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#35745;&#31639;&#21704;&#24076;&#32034;&#24341;&#65292;&#20877;&#21033;&#29992;&#25552;&#20379;&#30340;&#38190;&#21644;&#20540;&#21019;&#24314;&#26032;&#33410;&#28857;
</span>    <span class="org-type">int</span> <span class="org-variable-name">index</span> = hash(key);
    <span class="org-type">HashNode</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;* <span class="org-variable-name">now</span> = <span class="org-keyword">new</span> HashNode&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;(key, value);
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#23545;&#24212;&#30340;&#38142;&#34920;&#20026;&#31354;&#65292;&#30452;&#25509;&#23558;&#26032;&#33410;&#28857;&#20316;&#20026;&#38142;&#34920;&#22836;&#33410;&#28857;; &#21542;&#21017;&#29992;&#22836;&#25554;&#27861;&#25554;&#20837;&#26032;&#33410;&#28857;
</span>    <span class="org-keyword">if</span> (table[index] == <span class="org-constant">NULL</span>) {
        table[index] = now;
    }
    <span class="org-keyword">else</span> {
        now-&gt;next = table[index];
        table[index] = now;
    }

}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">KeyType</span>, <span class="org-keyword">typename</span> <span class="org-type">ValueType</span>&gt;
<span class="org-type">void</span> <span class="org-constant">HashTable</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;::<span class="org-function-name">remove</span>(<span class="org-keyword">const</span> <span class="org-type">KeyType</span>&amp; <span class="org-variable-name">key</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36890;&#36807;&#38190;&#33719;&#21462;&#32034;&#24341;,&#28982;&#21518;&#21028;&#26029;&#38142;&#34920;&#26159;&#21542;&#20026;&#31354;
</span>    <span class="org-type">int</span> <span class="org-variable-name">index</span> = hash(key);
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#38142;&#34920;&#23384;&#22312;&#65292;&#21017;&#38656;&#35201;&#21028;&#26029;&#35201;&#21024;&#38500;&#30340;&#38190;&#26159;&#21542;&#21644;&#38142;&#34920;&#22836;&#30456;&#31561;
</span>    <span class="org-keyword">if</span> (table[index]) {
        <span class="org-keyword">if</span> (table[index]-&gt;key == key) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#30456;&#31561;&#65292;&#21017;&#21024;&#38500;&#38142;&#34920;&#22836;&#65292;&#23558;&#21518;&#32487;&#33410;&#28857;&#20316;&#20026;&#26032;&#38142;&#34920;&#22836;
</span>            <span class="org-type">HashNode</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;* <span class="org-variable-name">next</span> = table[index]-&gt;next;
            <span class="org-keyword">delete</span> table[index];
            table[index] = next;
        }
        <span class="org-keyword">else</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#19981;&#30456;&#31561;&#65292;&#25226;&#22836;&#33410;&#28857;&#32531;&#23384;&#21040;current&#20013;&#65292;&#36941;&#21382;&#38142;&#34920;
</span>            <span class="org-type">HashNode</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;* <span class="org-variable-name">current</span> = table[index];
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#21518;&#32487;&#33410;&#28857;&#19981;&#20026;&#31354;&#65292;&#21518;&#32487;&#33410;&#28857;&#30340;&#38190;&#19981;&#31561;&#20110;key&#65292;&#32487;&#32493;&#36941;&#21382;&#65292;&#30456;&#31561;&#21017;&#36339;&#20986;
</span>            <span class="org-keyword">while</span> (current-&gt;next &amp;&amp; current-&gt;next-&gt;key != key) {
                current = current-&gt;next;
            }
            <span class="org-comment-delimiter">// </span><span class="org-comment">current&#30340;&#21518;&#32487;&#33410;&#28857;&#23601;&#26159;&#35201;&#21024;&#38500;&#30340;&#33410;&#28857;&#65292;&#23558;&#35201;&#21024;&#38500;&#30340;&#33410;&#28857;&#30340;&#21518;&#32487;&#33410;&#28857;&#20445;&#23384;
</span>            <span class="org-keyword">if</span> (current-&gt;next) {
                <span class="org-type">HashNode</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;* <span class="org-variable-name">next</span> = current-&gt;next-&gt;next;
                <span class="org-keyword">delete</span> current-&gt;next;
                current-&gt;next = next; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36171;&#20540;&#32473;current-&gt;next
</span>            }
        }
    }

}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">KeyType</span>, <span class="org-keyword">typename</span> <span class="org-type">ValueType</span>&gt;
<span class="org-type">bool</span> <span class="org-constant">HashTable</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;::<span class="org-function-name">find</span>(<span class="org-keyword">const</span> <span class="org-type">KeyType</span>&amp; <span class="org-variable-name">key</span>, <span class="org-type">ValueType</span>&amp; <span class="org-variable-name">value</span>) <span class="org-keyword">const</span> {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36890;&#36807;&#38190;&#33719;&#21462;&#32034;&#24341;
</span>    <span class="org-type">int</span> <span class="org-variable-name">index</span> = hash(key);
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#21028;&#26029;&#38142;&#34920;&#26159;&#21542;&#23384;&#22312;&#65292;&#19981;&#23384;&#22312;&#30452;&#25509;&#36820;&#22238;false
</span>    <span class="org-keyword">if</span> (table[index]) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21028;&#26029;&#38190;&#26159;&#21542;&#22312;&#38142;&#34920;&#22836;
</span>        <span class="org-keyword">if</span> (table[index]-&gt;key == key) {
            value = table[index]-&gt;value;
            <span class="org-keyword">return</span> <span class="org-constant">true</span>;
        }
        <span class="org-keyword">else</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#19981;&#22312;&#38142;&#34920;&#22836;&#65292;&#30452;&#25509;&#29992;&#21024;&#38500;&#33410;&#28857;&#30340;&#20195;&#30721;
</span>            <span class="org-type">HashNode</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">ValueType</span>&gt;* <span class="org-variable-name">current</span> = table[index];
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#21518;&#32487;&#33410;&#28857;&#19981;&#20026;&#31354;&#65292;&#21518;&#32487;&#33410;&#28857;&#30340;&#38190;&#19981;&#31561;&#20110;key&#65292;&#32487;&#32493;&#36941;&#21382;&#65292;&#30456;&#31561;&#21017;&#36339;&#20986;
</span>            <span class="org-keyword">while</span> (current-&gt;next &amp;&amp; current-&gt;next-&gt;key != key) {
                current = current-&gt;next;
            }
            <span class="org-comment-delimiter">// </span><span class="org-comment">current-&gt;next&#19981;&#20026;&#31354;&#65292;&#19968;&#23450;&#26159;&#23427;&#30340;&#38190;&#21644;&#20256;&#21442;&#30340;&#38190;&#30456;&#31561;&#30340;&#33410;&#28857;
</span>            <span class="org-keyword">if</span> (current-&gt;next) {
                value = current-&gt;next-&gt;value;
                <span class="org-keyword">return</span> <span class="org-constant">true</span>;
            }
        }
    }
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#21704;&#24076;&#35745;&#25968;&#22120;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">KeyType</span>&gt;
<span class="org-keyword">class</span> <span class="org-type">HashCounter</span> {
<span class="org-keyword">private</span>:
    <span class="org-type">int</span>* <span class="org-variable-name">counter</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">&#35745;&#25968;&#22120;&#30340;&#32531;&#23384;&#27744;
</span>    <span class="org-type">int</span> <span class="org-variable-name">counterIndex</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#30446;&#24405;&#29992;&#20102;&#22810;&#23569;&#20010;&#35745;&#25968;&#22120;
</span>    <span class="org-type">int</span> <span class="org-variable-name">counterSize</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#35745;&#25968;&#22120;&#24635;&#25968;
</span>    <span class="org-type">HashTable</span>&lt;<span class="org-type">KeyType</span>, <span class="org-type">int</span>&gt;* <span class="org-variable-name">hash</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21704;&#24076;&#34920;&#65292;&#38190;&#20026;&#21704;&#24076;&#35745;&#25968;&#22120;&#30340;&#38190;&#65292;&#20540;&#20026;counter&#25968;&#32452;&#30340;&#19979;&#26631;
</span>
<span class="org-keyword">public</span>:
    <span class="org-function-name">HashCounter</span>(<span class="org-type">int</span> <span class="org-variable-name">size</span>=256);
    ~<span class="org-function-name">HashCounter</span>();
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#37325;&#32622;&#35745;&#25968;&#22120;
</span>    <span class="org-type">void</span> <span class="org-function-name">reset</span>();
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#32473;&#23450;&#30340;&#38190;&#20570;&#33258;&#22686;
</span>    <span class="org-type">int</span> <span class="org-function-name">add</span>(<span class="org-keyword">const</span> <span class="org-type">KeyType</span>&amp; <span class="org-variable-name">key</span>);
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#32473;&#23450;&#30340;&#38190;&#20570;&#33258;&#20943;
</span>    <span class="org-type">int</span> <span class="org-function-name">sub</span>(<span class="org-keyword">const</span> <span class="org-type">KeyType</span>&amp; <span class="org-variable-name">key</span>);
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#32473;&#23450;&#38190;&#30340;&#35745;&#25968;&#20540;
</span>    <span class="org-type">int</span> <span class="org-function-name">get</span>(<span class="org-keyword">const</span> <span class="org-type">KeyType</span>&amp; <span class="org-variable-name">key</span>);
};

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">KeyType</span>&gt;
<span class="org-constant">HashCounter</span>&lt;<span class="org-type">KeyType</span>&gt;::<span class="org-function-name">HashCounter</span>(<span class="org-type">int</span> <span class="org-variable-name">size</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#35774;&#32622;&#35745;&#25968;&#22120;&#22823;&#23567;&#12289;&#21021;&#22987;&#21270;&#24050;&#32463;&#29992;&#36807;&#30340;&#35745;&#25968;&#22120;&#20026;0&#12289;&#29983;&#25104;&#35745;&#25968;&#22120;&#25968;&#32452;
</span>    counterSize = size;
    counterIndex = 0;
    counter = <span class="org-keyword">new</span> <span class="org-type">int</span>[counterSize];
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#21704;&#24076;&#34920;&#32622;&#20026;&#31354;&#65292;&#37325;&#26032;&#30003;&#35831;&#20869;&#23384;&#31354;&#38388;
</span>    hash = <span class="org-constant">NULL</span>;
    reset();
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">KeyType</span>&gt;
<span class="org-constant">HashCounter</span>&lt;<span class="org-type">KeyType</span>&gt;::~<span class="org-function-name">HashCounter</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#26512;&#26500;&#25481;&#35745;&#25968;&#22120;&#25968;&#32452;&#21450;&#21704;&#24076;&#34920;&#20869;&#23384;
</span>    <span class="org-keyword">delete</span>[] counter;
    <span class="org-keyword">if</span> (hash) {
        <span class="org-keyword">delete</span> hash;
        hash = <span class="org-constant">NULL</span>;
    }
}

<span class="org-comment-delimiter">// </span><span class="org-comment">&#37325;&#32622;&#35745;&#25968;&#22120;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">KeyType</span>&gt;
<span class="org-type">void</span> <span class="org-constant">HashCounter</span>&lt;<span class="org-type">KeyType</span>&gt;::<span class="org-function-name">reset</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#21028;&#26029;&#21704;&#24076;&#34920;&#26159;&#21542;&#23384;&#22312;&#65292;&#23384;&#22312;&#21017;&#28165;&#29702;&#20043;&#21069;&#30340;&#20869;&#23384;&#24182;&#25226;&#25351;&#38024;&#32622;&#20026;&#31354;
</span>    <span class="org-keyword">if</span> (hash) {
        <span class="org-keyword">delete</span> hash;
        hash = <span class="org-constant">NULL</span>;
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#26032;&#24314;&#21704;&#24076;&#34920;&#65292;&#38271;&#24230;&#21644;&#35745;&#25968;&#22120;&#38271;&#24230;&#19968;&#33268;
</span>    hash = <span class="org-keyword">new</span> HashTable&lt;<span class="org-type">KeyType</span>, <span class="org-type">int</span>&gt;(counterSize);
    counterIndex = 0;
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;&#25152;&#26377;&#35745;&#25968;&#22120;&#37117;&#28165;&#38646;
</span>    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; counterSize; ++i) {
        counter[i] = 0;
    }
}


<span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#32473;&#23450;&#30340;&#38190;&#20570;&#33258;&#22686;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">KeyType</span>&gt;
<span class="org-type">int</span> <span class="org-constant">HashCounter</span>&lt;<span class="org-type">KeyType</span>&gt;::<span class="org-function-name">add</span>(<span class="org-keyword">const</span> <span class="org-type">KeyType</span>&amp; <span class="org-variable-name">key</span>) {
    <span class="org-type">int</span> <span class="org-variable-name">idx</span>;
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>hash-&gt;find(key, idx)) {
        idx = counterIndex++;
        hash-&gt;insert(key, idx);
    }
    <span class="org-keyword">return</span> ++counter[idx];
}


<span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#32473;&#23450;&#30340;&#38190;&#20570;&#33258;&#20943;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">KeyType</span>&gt;
<span class="org-type">int</span> <span class="org-constant">HashCounter</span>&lt;<span class="org-type">KeyType</span>&gt;::<span class="org-function-name">sub</span>(<span class="org-keyword">const</span> <span class="org-type">KeyType</span>&amp; <span class="org-variable-name">key</span>) {
    <span class="org-type">int</span> <span class="org-variable-name">idx</span>;
    <span class="org-keyword">if</span> (hash-&gt;find(key, idx)) {
        <span class="org-keyword">return</span> --counter[idx];
    }
    <span class="org-keyword">return</span> 0;
}


<span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#32473;&#23450;&#38190;&#30340;&#35745;&#25968;&#20540;
</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">KeyType</span>&gt;
<span class="org-type">int</span> <span class="org-constant">HashCounter</span>&lt;<span class="org-type">KeyType</span>&gt;::<span class="org-function-name">get</span>(<span class="org-keyword">const</span> <span class="org-type">KeyType</span>&amp; <span class="org-variable-name">key</span>) {
    <span class="org-type">int</span> <span class="org-variable-name">idx</span>;
    <span class="org-keyword">if</span> (hash-&gt;find(key, idx)) {
        <span class="org-keyword">return</span> counter[idx];
    }
    <span class="org-keyword">return</span> 0;
}


<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">HashCounter</span>&lt;<span class="org-type">long</span> <span class="org-type">long</span>&gt; <span class="org-variable-name">hc</span>(1000);
    hc.add(14);
    hc.add(14);
    hc.add(14);
    hc.add(14);
    hc.add(14);
    hc.sub(14);
    cout &lt;&lt; hc.get(14) &lt;&lt; endl;

    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-h:73360bba-d969-47ce-b775-4df897ae4667" class="outline-4">
<h4 id="h:73360bba-d969-47ce-b775-4df897ae4667"><a href="#h:73360bba-d969-47ce-b775-4df897ae4667">3.C++中的哈希表实现(unordered_map)</a></h4>
<div class="outline-text-4" id="text-h:73360bba-d969-47ce-b775-4df897ae4667">
<p>
在C++中用 <code>unordered_map</code> 代表哈希表
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;string&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;unordered_map&gt;</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
    <span class="org-type">unordered_map</span>&lt;<span class="org-type">string</span>, <span class="org-type">int</span>&gt; <span class="org-variable-name">hash</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#21704;&#24076;&#34920;&#25554;&#20837;
</span>    <span class="org-type">hash</span>[<span class="org-string">"Aaaa"</span>] = 6;
    <span class="org-type">hash</span>[<span class="org-string">"XXXX"</span>] = 9;

    
    cout &lt;&lt; hash[<span class="org-string">"Aaaa"</span>] &lt;&lt; endl; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26597;
</span>    <span class="org-type">hash</span>[<span class="org-string">"Aaaa"</span>]++;               <span class="org-comment-delimiter">// </span><span class="org-comment">&#25913;
</span>    cout &lt;&lt; hash[<span class="org-string">"Aaaa"</span>] &lt;&lt; endl;

   
    <span class="org-type">hash</span>[<span class="org-string">"Aaaa"</span>] = 5;             <span class="org-comment-delimiter">// </span><span class="org-comment">&#25913;
</span>    hash.erase(<span class="org-string">"Aaaa"</span>);           <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#65292;&#25226;&#38190;&#25830;&#38500;
</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#26597;&#65292;&#21028;&#26029;&#38190;&#21542;&#22312;&#21704;&#24076;&#20013;
</span>    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#25214;&#21040;&#36820;&#22238;&#19968;&#20010;&#36845;&#20195;&#22120;&#65292;&#25214;&#19981;&#21040;&#36820;&#22238;hash.end()
</span>    <span class="org-keyword">if</span> (hash.find(<span class="org-string">"Aaaa"</span>) != hash.end()) {
        cout &lt;&lt; <span class="org-string">"find"</span> &lt;&lt; endl;
    }

    <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:812d4b94-1aea-4529-b2ac-39b9430e8613" class="outline-3">
<h3 id="h:812d4b94-1aea-4529-b2ac-39b9430e8613"><a href="#h:812d4b94-1aea-4529-b2ac-39b9430e8613">实战篇</a></h3>
<div class="outline-text-3" id="text-h:812d4b94-1aea-4529-b2ac-39b9430e8613">
</div>
<div id="outline-container-h:eff5605f-8bd7-47b3-ba03-82db3053e103" class="outline-4">
<h4 id="h:eff5605f-8bd7-47b3-ba03-82db3053e103"><a href="#h:eff5605f-8bd7-47b3-ba03-82db3053e103">核心代码模式</a></h4>
<div class="outline-text-4" id="text-h:eff5605f-8bd7-47b3-ba03-82db3053e103">
</div>
<div id="outline-container-h:8609e5e8-c280-4cf6-9b4b-e0fa998034e8" class="outline-5">
<h5 id="h:8609e5e8-c280-4cf6-9b4b-e0fa998034e8"><a href="#h:8609e5e8-c280-4cf6-9b4b-e0fa998034e8">1.消失的数字</a></h5>
<div class="outline-text-5" id="text-h:8609e5e8-c280-4cf6-9b4b-e0fa998034e8">
<p>
<a href="https://leetcode.cn/problems/missing-number-lcci/">https://leetcode.cn/problems/missing-number-lcci/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#25968;&#32452;nums&#21253;&#21547;&#20174;0&#21040;n&#30340;&#25152;&#26377;&#25972;&#25968;&#65292;&#20294;&#20854;&#20013;&#32570;&#20102;&#19968;&#20010;&#12290;&#35831;&#32534;&#20889;&#20195;&#30721;&#25214;&#20986;&#37027;&#20010;&#32570;&#22833;&#30340;&#25972;&#25968;&#12290;&#20320;&#26377;&#21150;&#27861;&#22312;O(n)&#26102;&#38388;&#20869;&#23436;&#25104;&#21527;&#65311;

&#27880;&#24847;&#65306;&#26412;&#39064;&#30456;&#23545;&#20070;&#19978;&#21407;&#39064;&#31245;&#20316;&#25913;&#21160;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;[3,0,1]
&#36755;&#20986;&#65306;2

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;[9,6,4,2,3,5,7,0,1]
&#36755;&#20986;&#65306;8
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">missingNumber</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#20351;&#29992;&#21704;&#24076;&#34920;&#26469;&#20570;
</span>        <span class="org-type">unordered_map</span>&lt;<span class="org-type">int</span>, <span class="org-type">int</span>&gt; <span class="org-variable-name">hash</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">int&#21040;int&#30340;&#38190;&#20540;&#23545;&#65292;&#38190;&#20195;&#34920;&#25968;&#25454;&#20013;&#27599;&#20010;&#20803;&#32032;&#65292;&#20540;&#20195;&#34920;&#25968;&#23383;&#26377;&#27809;&#26377;&#20986;&#29616;&#36807;&#12290;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#36941;&#21382;&#25968;&#32452;&#65292;&#25226;&#25968;&#23383;&#25554;&#20837;&#21040;hash&#20013;
</span>        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; nums.size(); ++i) {
            <span class="org-type">hash</span>[ nums[i] ] = 1;
        }
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; ; ++i) {
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#25214;&#21040;&#36820;&#22238;&#19968;&#20010;&#36845;&#20195;&#22120;&#65292;&#25214;&#19981;&#21040;&#36820;&#22238;hash.end()
</span>            <span class="org-keyword">if</span>(hash.find(i) == hash.end()) {
                <span class="org-keyword">return</span> i; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25214;&#19981;&#21040;&#30452;&#25509;&#36820;&#22238;i
</span>            }
        }
        <span class="org-keyword">return</span> -1;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:4f40c329-aaf8-472c-a836-2313b468ed15" class="outline-5">
<h5 id="h:4f40c329-aaf8-472c-a836-2313b468ed15"><a href="#h:4f40c329-aaf8-472c-a836-2313b468ed15">2.缺失的第一个正数</a></h5>
<div class="outline-text-5" id="text-h:4f40c329-aaf8-472c-a836-2313b468ed15">
<p>
<a href="https://leetcode.cn/problems/first-missing-positive/description/">https://leetcode.cn/problems/first-missing-positive/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#26410;&#25490;&#24207;&#30340;&#25972;&#25968;&#25968;&#32452; nums &#65292;&#35831;&#20320;&#25214;&#20986;&#20854;&#20013;&#27809;&#26377;&#20986;&#29616;&#30340;&#26368;&#23567;&#30340;&#27491;&#25972;&#25968;&#12290;

&#35831;&#20320;&#23454;&#29616;&#26102;&#38388;&#22797;&#26434;&#24230;&#20026; O(n) &#24182;&#19988;&#21482;&#20351;&#29992;&#24120;&#25968;&#32423;&#21035;&#39069;&#22806;&#31354;&#38388;&#30340;&#35299;&#20915;&#26041;&#26696;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;nums = [1,2,0]
&#36755;&#20986;&#65306;3
&#35299;&#37322;&#65306;&#33539;&#22260; [1,2] &#20013;&#30340;&#25968;&#23383;&#37117;&#22312;&#25968;&#32452;&#20013;&#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;nums = [3,4,-1,1]
&#36755;&#20986;&#65306;2
&#35299;&#37322;&#65306;1 &#22312;&#25968;&#32452;&#20013;&#65292;&#20294; 2 &#27809;&#26377;&#12290;

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;nums = [7,8,9,11,12]
&#36755;&#20986;&#65306;1
&#35299;&#37322;&#65306;&#26368;&#23567;&#30340;&#27491;&#25968; 1 &#27809;&#26377;&#20986;&#29616;&#12290;

&#25552;&#31034;&#65306;
1 &lt;= nums.length &lt;= 105
-231 &lt;= nums[i] &lt;= 231 - 1
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">firstMissingPositive</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>) {
        <span class="org-type">unordered_map</span>&lt;<span class="org-type">int</span>, <span class="org-type">bool</span>&gt; <span class="org-variable-name">hash</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#38190;&#20195;&#34920;&#25968;&#25454;&#20013;&#27599;&#20010;&#20803;&#32032;&#65292;&#20540;&#20195;&#34920;&#25968;&#23383;&#26377;&#27809;&#26377;&#20986;&#29616;&#36807;
</span>        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i&lt; nums.size(); ++i) {
            <span class="org-type">hash</span>[ nums[i] ] = <span class="org-constant">true</span>;
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#27809;&#26377;&#20986;&#29616;&#30340;&#26368;&#23567;&#30340;&#27491;&#25972;&#25968;&#12290;&#37027;&#20040;&#20174;1&#24320;&#22987;&#36941;&#21382;
</span>        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 1;; ++i) {
            <span class="org-keyword">if</span>(hash.find(i) == hash.end()) {
                <span class="org-keyword">return</span> i;
            }
        }
        <span class="org-keyword">return</span> -1;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:a0d73fd8-ecbd-4766-b09b-81a69c4e4bf3" class="outline-5">
<h5 id="h:a0d73fd8-ecbd-4766-b09b-81a69c4e4bf3"><a href="#h:a0d73fd8-ecbd-4766-b09b-81a69c4e4bf3">3.点名</a></h5>
<div class="outline-text-5" id="text-h:a0d73fd8-ecbd-4766-b09b-81a69c4e4bf3">
<p>
<a href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/description/">https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#26576;&#29677;&#32423; n &#20301;&#21516;&#23398;&#30340;&#23398;&#21495;&#20026; 0 ~ n-1&#12290;&#28857;&#21517;&#32467;&#26524;&#35760;&#24405;&#20110;&#21319;&#24207;&#25968;&#32452; records&#12290;&#20551;&#23450;&#20165;&#26377;&#19968;&#20301;&#21516;&#23398;&#32570;&#24109;&#65292;&#35831;&#36820;&#22238;&#20182;&#30340;&#23398;&#21495;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;records = [0,1,2,3,5]
&#36755;&#20986;&#65306;4

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;records = [0, 1, 2, 3, 4, 5, 6, 8]
&#36755;&#20986;&#65306;7

&#25552;&#31034;&#65306;
1 &lt;= records.length &lt;= 10000
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">takeAttendance</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">records</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#25918;&#20837;&#21704;&#24076;&#34920;&#65292;&#36941;&#21382;&#36825;&#20123;&#25968;&#65292;&#22914;&#26524;&#27809;&#26377;&#21017;&#36820;&#22238;&#36825;&#20010;&#25968;
</span>        <span class="org-type">unordered_map</span>&lt;<span class="org-type">int</span>, <span class="org-type">bool</span>&gt; <span class="org-variable-name">hash</span>;
        <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; records.size(); ++i) {
            <span class="org-type">hash</span>[ records[i] ] = <span class="org-constant">true</span>;
        }
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; ; ++i) {
            <span class="org-keyword">if</span> (hash.find(i) == hash.end()) {
                <span class="org-keyword">return</span> i;
            }
        }
        <span class="org-keyword">return</span> -1;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:7b51733e-92d4-4dc3-af52-66b5dacae62b" class="outline-5">
<h5 id="h:7b51733e-92d4-4dc3-af52-66b5dacae62b"><a href="#h:7b51733e-92d4-4dc3-af52-66b5dacae62b">4.丢失的数字</a></h5>
<div class="outline-text-5" id="text-h:7b51733e-92d4-4dc3-af52-66b5dacae62b">
<p>
<a href="https://leetcode.cn/problems/missing-number/description/">https://leetcode.cn/problems/missing-number/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#23450;&#19968;&#20010;&#21253;&#21547; [0, n] &#20013; n &#20010;&#25968;&#30340;&#25968;&#32452; nums &#65292;&#25214;&#20986; [0, n] &#36825;&#20010;&#33539;&#22260;&#20869;&#27809;&#26377;&#20986;&#29616;&#22312;&#25968;&#32452;&#20013;&#30340;&#37027;&#20010;&#25968;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;nums = [3,0,1]
&#36755;&#20986;&#65306;2
&#35299;&#37322;&#65306;n = 3&#65292;&#22240;&#20026;&#26377; 3 &#20010;&#25968;&#23383;&#65292;&#25152;&#20197;&#25152;&#26377;&#30340;&#25968;&#23383;&#37117;&#22312;&#33539;&#22260; [0,3] &#20869;&#12290;2 &#26159;&#20002;&#22833;&#30340;&#25968;&#23383;&#65292;&#22240;&#20026;&#23427;&#27809;&#26377;&#20986;&#29616;&#22312; nums &#20013;&#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;nums = [0,1]
&#36755;&#20986;&#65306;2
&#35299;&#37322;&#65306;n = 2&#65292;&#22240;&#20026;&#26377; 2 &#20010;&#25968;&#23383;&#65292;&#25152;&#20197;&#25152;&#26377;&#30340;&#25968;&#23383;&#37117;&#22312;&#33539;&#22260; [0,2] &#20869;&#12290;2 &#26159;&#20002;&#22833;&#30340;&#25968;&#23383;&#65292;&#22240;&#20026;&#23427;&#27809;&#26377;&#20986;&#29616;&#22312; nums &#20013;&#12290;

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;nums = [9,6,4,2,3,5,7,0,1]
&#36755;&#20986;&#65306;8
&#35299;&#37322;&#65306;n = 9&#65292;&#22240;&#20026;&#26377; 9 &#20010;&#25968;&#23383;&#65292;&#25152;&#20197;&#25152;&#26377;&#30340;&#25968;&#23383;&#37117;&#22312;&#33539;&#22260; [0,9] &#20869;&#12290;8 &#26159;&#20002;&#22833;&#30340;&#25968;&#23383;&#65292;&#22240;&#20026;&#23427;&#27809;&#26377;&#20986;&#29616;&#22312; nums &#20013;&#12290;

&#25552;&#31034;&#65306;
n == nums.length
1 &lt;= n &lt;= 104
0 &lt;= nums[i] &lt;= n
nums &#20013;&#30340;&#25152;&#26377;&#25968;&#23383;&#37117; &#29420;&#19968;&#26080;&#20108;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">missingNumber</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>) {
        <span class="org-type">unordered_map</span>&lt;<span class="org-type">int</span>, <span class="org-type">bool</span>&gt; <span class="org-variable-name">hash</span>;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; nums.size(); ++i) {
            <span class="org-type">hash</span>[nums[i]] = <span class="org-constant">true</span>;
        }
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; ; ++i) {
            <span class="org-keyword">if</span>(hash.find(i) == hash.end()) {
                <span class="org-keyword">return</span> i;
            }
        }
        <span class="org-keyword">return</span> -1;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:abe72e93-92bb-4fcb-9c54-9cef37547dda" class="outline-5">
<h5 id="h:abe72e93-92bb-4fcb-9c54-9cef37547dda"><a href="#h:abe72e93-92bb-4fcb-9c54-9cef37547dda">5.寻找文件副本</a></h5>
<div class="outline-text-5" id="text-h:abe72e93-92bb-4fcb-9c54-9cef37547dda">
<p>
<a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#35774;&#22791;&#20013;&#23384;&#26377; n &#20010;&#25991;&#20214;&#65292;&#25991;&#20214; id &#35760;&#20110;&#25968;&#32452; documents&#12290;&#33509;&#25991;&#20214; id &#30456;&#21516;&#65292;&#21017;&#23450;&#20041;&#20026;&#35813;&#25991;&#20214;&#23384;&#22312;&#21103;&#26412;&#12290;&#35831;&#36820;&#22238;&#20219;&#19968;&#23384;&#22312;&#21103;&#26412;&#30340;&#25991;&#20214; id&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;documents = [2, 5, 3, 0, 5, 0]
&#36755;&#20986;&#65306;0 &#25110; 5

&#25552;&#31034;&#65306;
0 &#8804; documents[i] &#8804; n-1
2 &lt;= n &lt;= 100000
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">findRepeatDocument</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">documents</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#36941;&#21382;&#25968;&#32452;&#25554;&#20837;&#21040;&#21704;&#24076;&#34920;&#20013;&#65292;&#25554;&#20837;&#20043;&#21069;&#21028;&#26029;
</span>        <span class="org-type">unordered_map</span>&lt;<span class="org-type">int</span>, <span class="org-type">bool</span>&gt; <span class="org-variable-name">hash</span>;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; documents.size(); ++i) {
            <span class="org-keyword">if</span>(hash.find(<span class="org-type">documents</span>[i]) != hash.end()) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#25214;&#21040;&#20102;&#65292;&#30452;&#25509;&#36820;&#22238;documents
</span>                <span class="org-keyword">return</span> documents[i];
            }
            <span class="org-type">hash</span>[documents[i]] = <span class="org-constant">true</span>;
        }
        <span class="org-keyword">return</span> 0;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:bdf41192-2385-47d8-b4a2-d7dd2129695c" class="outline-5">
<h5 id="h:bdf41192-2385-47d8-b4a2-d7dd2129695c"><a href="#h:bdf41192-2385-47d8-b4a2-d7dd2129695c">6.分糖果</a></h5>
<div class="outline-text-5" id="text-h:bdf41192-2385-47d8-b4a2-d7dd2129695c">
<p>
<a href="https://leetcode.cn/problems/distribute-candies/">https://leetcode.cn/problems/distribute-candies/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">Alice &#26377; n &#26522;&#31958;&#65292;&#20854;&#20013;&#31532; i &#26522;&#31958;&#30340;&#31867;&#22411;&#20026; candyType[i] &#12290;Alice &#27880;&#24847;&#21040;&#22905;&#30340;&#20307;&#37325;&#27491;&#22312;&#22686;&#38271;&#65292;&#25152;&#20197;&#21069;&#21435;&#25308;&#35775;&#20102;&#19968;&#20301;&#21307;&#29983;&#12290;

&#21307;&#29983;&#24314;&#35758; Alice &#35201;&#23569;&#25668;&#20837;&#31958;&#20998;&#65292;&#21482;&#21507;&#25481;&#22905;&#25152;&#26377;&#31958;&#30340; n / 2 &#21363;&#21487;&#65288;n &#26159;&#19968;&#20010;&#20598;&#25968;&#65289;&#12290;
Alice &#38750;&#24120;&#21916;&#27426;&#36825;&#20123;&#31958;&#65292;&#22905;&#24819;&#35201;&#22312;&#36981;&#24490;&#21307;&#29983;&#24314;&#35758;&#30340;&#24773;&#20917;&#19979;&#65292;&#23613;&#21487;&#33021;&#21507;&#21040;&#26368;&#22810;&#19981;&#21516;&#31181;&#31867;&#30340;&#31958;&#12290;

&#32473;&#20320;&#19968;&#20010;&#38271;&#24230;&#20026; n &#30340;&#25972;&#25968;&#25968;&#32452; candyType &#65292;&#36820;&#22238;&#65306; Alice &#22312;&#20165;&#21507;&#25481; n / 2 &#26522;&#31958;&#30340;&#24773;&#20917;&#19979;&#65292;&#21487;&#20197;&#21507;&#21040;&#31958;&#30340; &#26368;&#22810; &#31181;&#31867;&#25968;&#12290;


&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;candyType = [1,1,2,2,3,3]
&#36755;&#20986;&#65306;3
&#35299;&#37322;&#65306;Alice &#21482;&#33021;&#21507; 6 / 2 = 3 &#26522;&#31958;&#65292;&#30001;&#20110;&#21482;&#26377; 3 &#31181;&#31958;&#65292;&#22905;&#21487;&#20197;&#27599;&#31181;&#21507;&#19968;&#26522;&#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;candyType = [1,1,2,3]
&#36755;&#20986;&#65306;2
&#35299;&#37322;&#65306;Alice &#21482;&#33021;&#21507; 4 / 2 = 2 &#26522;&#31958;&#65292;&#19981;&#31649;&#22905;&#36873;&#25321;&#21507;&#30340;&#31181;&#31867;&#26159; [1,2]&#12289;[1,3] &#36824;&#26159; [2,3]&#65292;&#22905;&#21482;&#33021;&#21507;&#21040;&#20004;&#31181;&#19981;&#21516;&#31867;&#30340;&#31958;&#12290;

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;candyType = [6,6,6,6]
&#36755;&#20986;&#65306;1
&#35299;&#37322;&#65306;Alice &#21482;&#33021;&#21507; 4 / 2 = 2 &#26522;&#31958;&#65292;&#23613;&#31649;&#22905;&#33021;&#21507; 2 &#26522;&#65292;&#20294;&#21482;&#33021;&#21507;&#21040; 1 &#31181;&#31958;&#12290;
 

&#25552;&#31034;&#65306;
n == candyType.length
2 &lt;= n &lt;= 104
n &#26159;&#19968;&#20010;&#20598;&#25968;
-105 &lt;= candyType[i] &lt;= 105
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">distributeCandies</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">candyType</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#26816;&#26597;candyType &#26377;&#22810;&#23569;&#31181;&#31867;
</span>        <span class="org-type">unordered_map</span>&lt;<span class="org-type">int</span>, <span class="org-type">bool</span>&gt; <span class="org-variable-name">hash</span>;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; candyType.size(); ++i) {
            <span class="org-type">hash</span>[ candyType[i] ] = <span class="org-constant">true</span>;
        }
        <span class="org-keyword">return</span> min(hash.size(), candyType.size()/2);
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:8f86a9d8-c2cf-4eb9-a420-aa16dcc6635a" class="outline-5">
<h5 id="h:8f86a9d8-c2cf-4eb9-a420-aa16dcc6635a"><a href="#h:8f86a9d8-c2cf-4eb9-a420-aa16dcc6635a">7.两数之和</a></h5>
<div class="outline-text-5" id="text-h:8f86a9d8-c2cf-4eb9-a420-aa16dcc6635a">
<p>
<a href="https://leetcode.cn/problems/two-sum/description/">https://leetcode.cn/problems/two-sum/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#23450;&#19968;&#20010;&#25972;&#25968;&#25968;&#32452; nums &#21644;&#19968;&#20010;&#25972;&#25968;&#30446;&#26631;&#20540; target&#65292;&#35831;&#20320;&#22312;&#35813;&#25968;&#32452;&#20013;&#25214;&#20986; &#21644;&#20026;&#30446;&#26631;&#20540; target  &#30340;&#37027; &#20004;&#20010; &#25972;&#25968;&#65292;&#24182;&#36820;&#22238;&#23427;&#20204;&#30340;&#25968;&#32452;&#19979;&#26631;&#12290;

&#20320;&#21487;&#20197;&#20551;&#35774;&#27599;&#31181;&#36755;&#20837;&#21482;&#20250;&#23545;&#24212;&#19968;&#20010;&#31572;&#26696;&#65292;&#24182;&#19988;&#20320;&#19981;&#33021;&#20351;&#29992;&#20004;&#27425;&#30456;&#21516;&#30340;&#20803;&#32032;&#12290;

&#20320;&#21487;&#20197;&#25353;&#20219;&#24847;&#39034;&#24207;&#36820;&#22238;&#31572;&#26696;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;nums = [2,7,11,15], target = 9
&#36755;&#20986;&#65306;[0,1]
&#35299;&#37322;&#65306;&#22240;&#20026; nums[0] + nums[1] == 9 &#65292;&#36820;&#22238; [0, 1] &#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;nums = [3,2,4], target = 6
&#36755;&#20986;&#65306;[1,2]

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;nums = [3,3], target = 6
&#36755;&#20986;&#65306;[0,1]

&#25552;&#31034;&#65306;
2 &lt;= nums.length &lt;= 104
-109 &lt;= nums[i] &lt;= 109
-109 &lt;= target &lt;= 109
&#21482;&#20250;&#23384;&#22312;&#19968;&#20010;&#26377;&#25928;&#31572;&#26696;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-function-name">twoSum</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>, <span class="org-type">int</span> <span class="org-variable-name">target</span>) {
        <span class="org-type">unordered_map</span>&lt;<span class="org-type">int</span>, <span class="org-type">int</span>&gt; <span class="org-variable-name">hash</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20540;&#20026;int&#65292;&#23384;&#19979;&#26631;
</span>        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; nums.size(); ++i) {
            <span class="org-keyword">auto</span> <span class="org-variable-name">p</span> = hash.find(target - nums[i]);
            <span class="org-keyword">if</span> (p != hash.end()) {
                <span class="org-keyword">return</span> {i, p-&gt;second}; <span class="org-comment-delimiter">// </span><span class="org-comment">&#33719;&#21462;&#38190;&#20540;&#23545;&#20013;&#30340;&#20540;
</span>            }
            <span class="org-type">hash</span>[ nums[i] ] = i;
        }
        <span class="org-keyword">return</span> {}; <span class="org-comment-delimiter">// </span><span class="org-comment">&#27809;&#26377;&#25214;&#21040;&#36820;&#22238;&#31354;
</span>    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:0119d5f0-258c-4c95-81dd-1ec582a4c178" class="outline-5">
<h5 id="h:0119d5f0-258c-4c95-81dd-1ec582a4c178"><a href="#h:0119d5f0-258c-4c95-81dd-1ec582a4c178">8.字符串中的第一个唯一字符</a></h5>
<div class="outline-text-5" id="text-h:0119d5f0-258c-4c95-81dd-1ec582a4c178">
<p>
<a href="https://leetcode.cn/problems/first-unique-character-in-a-string/">https://leetcode.cn/problems/first-unique-character-in-a-string/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#23450;&#19968;&#20010;&#23383;&#31526;&#20018; s &#65292;&#25214;&#21040; &#23427;&#30340;&#31532;&#19968;&#20010;&#19981;&#37325;&#22797;&#30340;&#23383;&#31526;&#65292;&#24182;&#36820;&#22238;&#23427;&#30340;&#32034;&#24341; &#12290;&#22914;&#26524;&#19981;&#23384;&#22312;&#65292;&#21017;&#36820;&#22238; -1 &#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;: s = "leetcode"
&#36755;&#20986;: 0

&#31034;&#20363; 2:
&#36755;&#20837;: s = "loveleetcode"
&#36755;&#20986;: 2

&#31034;&#20363; 3:
&#36755;&#20837;: s = "aabb"
&#36755;&#20986;: -1

&#25552;&#31034;:
1 &lt;= s.length &lt;= 105
s &#21482;&#21253;&#21547;&#23567;&#20889;&#23383;&#27597;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">firstUniqChar</span>(<span class="org-type">string</span> <span class="org-variable-name">s</span>) {
        <span class="org-type">int</span> <span class="org-variable-name">count</span>[256];
        memset(count, 0, <span class="org-keyword">sizeof</span>(count));
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; s.size(); ++i) {
            count[ s[i] ]++;
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#36941;&#21382;&#23383;&#31526;&#65292;&#21028;&#26029;
</span>        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; s.size(); ++i) {
            <span class="org-keyword">if</span>( count[s[i]] == 1) {
                <span class="org-keyword">return</span> i;
            }
        }
        <span class="org-keyword">return</span> -1;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:27c640f8-ab2d-4db3-bb72-72d8bc381bb6" class="outline-5">
<h5 id="h:27c640f8-ab2d-4db3-bb72-72d8bc381bb6"><a href="#h:27c640f8-ab2d-4db3-bb72-72d8bc381bb6">9.招式拆解 II</a></h5>
<div class="outline-text-5" id="text-h:27c640f8-ab2d-4db3-bb72-72d8bc381bb6">
<p>
<a href="https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#26576;&#22871;&#36830;&#25307;&#21160;&#20316;&#35760;&#20316;&#20165;&#30001;&#23567;&#20889;&#23383;&#27597;&#32452;&#25104;&#30340;&#24207;&#21015; arr&#65292;&#20854;&#20013; arr[i] &#31532; i &#20010;&#25307;&#24335;&#30340;&#21517;&#23383;&#12290;
&#35831;&#36820;&#22238;&#31532;&#19968;&#20010;&#21482;&#20986;&#29616;&#19968;&#27425;&#30340;&#25307;&#24335;&#21517;&#31216;&#65292;&#22914;&#19981;&#23384;&#22312;&#35831;&#36820;&#22238;&#31354;&#26684;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;arr = "abbccdeff"
&#36755;&#20986;&#65306;'a'

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;arr = "ccdd"
&#36755;&#20986;&#65306;' '

&#38480;&#21046;&#65306;
0 &lt;= arr.length &lt;= 50000
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">char</span> <span class="org-function-name">dismantlingAction</span>(<span class="org-type">string</span> <span class="org-variable-name">arr</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#36941;&#21382;&#23383;&#31526;&#20018;&#24182;&#25918;&#20837;&#21704;&#24076;&#34920;&#20013;&#65292;&#32479;&#35745;
</span>        <span class="org-type">int</span> <span class="org-variable-name">count</span>[256] = {0}; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#21270;&#20026;0
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">memset(count, 0, sizeof(count));
</span>        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; arr.size(); ++i) {
            count[ arr[i] ]++;
        }
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; arr.size(); ++i) {
            <span class="org-keyword">if</span> (count[arr[i]] == 1) {
                <span class="org-keyword">return</span> arr[i];
            }
        }
        <span class="org-keyword">return</span> <span class="org-string">' '</span>;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:2104cc9f-f02b-4ca6-a4e5-d3b881b663d2" class="outline-5">
<h5 id="h:2104cc9f-f02b-4ca6-a4e5-d3b881b663d2"><a href="#h:2104cc9f-f02b-4ca6-a4e5-d3b881b663d2">10.两个相同字符之间的最长子字符串</a></h5>
<div class="outline-text-5" id="text-h:2104cc9f-f02b-4ca6-a4e5-d3b881b663d2">
<p>
<a href="https://leetcode.cn/problems/largest-substring-between-two-equal-characters/">https://leetcode.cn/problems/largest-substring-between-two-equal-characters/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#23383;&#31526;&#20018; s&#65292;&#35831;&#20320;&#36820;&#22238; &#20004;&#20010;&#30456;&#21516;&#23383;&#31526;&#20043;&#38388;&#30340;&#26368;&#38271;&#23376;&#23383;&#31526;&#20018;&#30340;&#38271;&#24230; &#65292;
&#35745;&#31639;&#38271;&#24230;&#26102;&#19981;&#21547;&#36825;&#20004;&#20010;&#23383;&#31526;&#12290;&#22914;&#26524;&#19981;&#23384;&#22312;&#36825;&#26679;&#30340;&#23376;&#23383;&#31526;&#20018;&#65292;&#36820;&#22238; -1 &#12290;

&#23376;&#23383;&#31526;&#20018; &#26159;&#23383;&#31526;&#20018;&#20013;&#30340;&#19968;&#20010;&#36830;&#32493;&#23383;&#31526;&#24207;&#21015;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;s = "aa"
&#36755;&#20986;&#65306;0
&#35299;&#37322;&#65306;&#26368;&#20248;&#30340;&#23376;&#23383;&#31526;&#20018;&#26159;&#20004;&#20010; 'a' &#20043;&#38388;&#30340;&#31354;&#23376;&#23383;&#31526;&#20018;&#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;s = "abca"
&#36755;&#20986;&#65306;2
&#35299;&#37322;&#65306;&#26368;&#20248;&#30340;&#23376;&#23383;&#31526;&#20018;&#26159; "bc" &#12290;

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;s = "cbzxy"
&#36755;&#20986;&#65306;-1
&#35299;&#37322;&#65306;s &#20013;&#19981;&#23384;&#22312;&#20986;&#29616;&#20986;&#29616;&#20004;&#27425;&#30340;&#23383;&#31526;&#65292;&#25152;&#20197;&#36820;&#22238; -1 &#12290;

&#31034;&#20363; 4&#65306;
&#36755;&#20837;&#65306;s = "cabbac"
&#36755;&#20986;&#65306;4
&#35299;&#37322;&#65306;&#26368;&#20248;&#30340;&#23376;&#23383;&#31526;&#20018;&#26159; "abba" &#65292;&#20854;&#20182;&#30340;&#38750;&#26368;&#20248;&#35299;&#21253;&#25324; "bb" &#21644; "" &#12290;

&#25552;&#31034;&#65306;
1 &lt;= s.length &lt;= 300
s &#21482;&#21547;&#23567;&#20889;&#33521;&#25991;&#23383;&#27597;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">maxLengthBetweenEqualCharacters</span>(<span class="org-type">string</span> <span class="org-variable-name">s</span>) {
        <span class="org-type">int</span> <span class="org-variable-name">hash</span>[256]; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#26377;256&#20010;&#25968;&#23383;&#30340;&#21704;&#24076;&#25968;&#32452;
</span>        <span class="org-type">int</span> <span class="org-variable-name">maxv</span> = -1;
        memset(<span class="org-type">hash</span>, -1, <span class="org-keyword">sizeof</span>(<span class="org-type">hash</span>));
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt;s.size(); ++i) {
            <span class="org-keyword">if</span>(<span class="org-type">hash</span>[ s[i] ] == -1) {
                <span class="org-type">hash</span>[ s[i] ] = i;
            }<span class="org-keyword">else</span> {
                <span class="org-type">int</span> <span class="org-variable-name">x</span> = i - hash[s[i]] - 1;
                maxv = max(maxv, x);
            }
        }
        <span class="org-keyword">return</span> maxv;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:b5801f8a-196e-4873-acce-36c5c5feba5f" class="outline-5">
<h5 id="h:b5801f8a-196e-4873-acce-36c5c5feba5f"><a href="#h:b5801f8a-196e-4873-acce-36c5c5feba5f">11.好数对的数目</a></h5>
<div class="outline-text-5" id="text-h:b5801f8a-196e-4873-acce-36c5c5feba5f">
<p>
<a href="https://leetcode.cn/problems/number-of-good-pairs/">https://leetcode.cn/problems/number-of-good-pairs/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#25972;&#25968;&#25968;&#32452; nums &#12290;

&#22914;&#26524;&#19968;&#32452;&#25968;&#23383; (i,j) &#28385;&#36275; nums[i] == nums[j] &#19988; i &lt; j &#65292;&#23601;&#21487;&#20197;&#35748;&#20026;&#36825;&#26159;&#19968;&#32452; &#22909;&#25968;&#23545; &#12290;

&#36820;&#22238;&#22909;&#25968;&#23545;&#30340;&#25968;&#30446;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;nums = [1,2,3,1,1,3]
&#36755;&#20986;&#65306;4
&#35299;&#37322;&#65306;&#26377; 4 &#32452;&#22909;&#25968;&#23545;&#65292;&#20998;&#21035;&#26159; (0,3), (0,4), (3,4), (2,5) &#65292;&#19979;&#26631;&#20174; 0 &#24320;&#22987;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;nums = [1,1,1,1]
&#36755;&#20986;&#65306;6
&#35299;&#37322;&#65306;&#25968;&#32452;&#20013;&#30340;&#27599;&#32452;&#25968;&#23383;&#37117;&#26159;&#22909;&#25968;&#23545;

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;nums = [1,2,3]
&#36755;&#20986;&#65306;0

&#25552;&#31034;&#65306;
1 &lt;= nums.length &lt;= 100
1 &lt;= nums[i] &lt;= 100
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">numIdenticalPairs</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#36941;&#21382;&#21040;&#31532;i&#25968;&#30446;&#26102;&#65292;&#21482;&#35201;&#30693;&#36947;&#21069;&#38754;&#26377;&#22810;&#23569;&#21644;&#23427;&#30456;&#31561;&#30340;&#25968;&#65292;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#24182;&#19988;&#23558;&#32479;&#35745;&#32467;&#26524;&#35760;&#24405;&#21040;sum&#21464;&#37327;&#20013;&#12290;&#21033;&#29992;&#21704;&#24076;&#34920;&#36827;&#34892;&#35745;&#25968;
</span>
        <span class="org-type">unordered_map</span>&lt;<span class="org-type">int</span>, <span class="org-type">int</span>&gt; <span class="org-variable-name">count</span>;
        <span class="org-type">int</span> <span class="org-variable-name">sum</span> = 0;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; nums.size(); ++i) {
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#20808;&#25214;&#36825;&#20010;&#25968;&#22312;&#20043;&#21069;&#20986;&#29616;&#30340;&#27425;&#25968;&#32047;&#21152;&#21040;sum&#19978;
</span>            <span class="org-comment-delimiter">// </span><span class="org-comment">&#24182;&#19988;&#29616;&#22312;&#36825;&#20010;&#27425;&#25968;&#20877;&#21152;1&#27425;&#65292;&#22240;&#20026;&#36825;&#20010;&#25968;&#21448;&#20986;&#29616;&#20102;&#19968;&#27425;
</span>            sum += count[nums[i]];
            count[nums[i]]++;
        }
        <span class="org-keyword">return</span> sum;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:55d5d37c-18d5-4255-b815-b1eec3264e57" class="outline-5">
<h5 id="h:55d5d37c-18d5-4255-b815-b1eec3264e57"><a href="#h:55d5d37c-18d5-4255-b815-b1eec3264e57">12.在长度 2N 的数组中找出重复 N 次的元素</a></h5>
<div class="outline-text-5" id="text-h:55d5d37c-18d5-4255-b815-b1eec3264e57">
<p>
<a href="https://leetcode.cn/problems/n-repeated-element-in-size-2n-array/">https://leetcode.cn/problems/n-repeated-element-in-size-2n-array/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#25972;&#25968;&#25968;&#32452; nums &#65292;&#35813;&#25968;&#32452;&#20855;&#26377;&#20197;&#19979;&#23646;&#24615;&#65306;

nums.length == 2 * n.
nums &#21253;&#21547; n + 1 &#20010; &#19981;&#21516;&#30340; &#20803;&#32032;
nums &#20013;&#24688;&#26377;&#19968;&#20010;&#20803;&#32032;&#37325;&#22797; n &#27425;
&#25214;&#20986;&#24182;&#36820;&#22238;&#37325;&#22797;&#20102; n &#27425;&#30340;&#37027;&#20010;&#20803;&#32032;&#12290;


&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;nums = [1,2,3,3]
&#36755;&#20986;&#65306;3

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;nums = [2,1,2,5,3,2]
&#36755;&#20986;&#65306;2

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;nums = [5,1,5,2,5,3,5,4]
&#36755;&#20986;&#65306;5

&#25552;&#31034;&#65306;
2 &lt;= n &lt;= 5000
nums.length == 2 * n
0 &lt;= nums[i] &lt;= 104
nums &#30001; n + 1 &#20010; &#19981;&#21516;&#30340; &#20803;&#32032;&#32452;&#25104;&#65292;&#19988;&#20854;&#20013;&#19968;&#20010;&#20803;&#32032;&#24688;&#22909;&#37325;&#22797; n &#27425;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">repeatedNTimes</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#36941;&#21382;&#36825;&#20010;&#25968;&#32452;&#25554;&#20837;&#21040;&#21704;&#24076;&#34920;&#20013;&#36827;&#34892;&#36941;&#21382;&#65292;
</span>        <span class="org-comment-delimiter">// </span><span class="org-comment">&#20877;&#36941;&#21382;&#25214;&#21040;&#35745;&#25968;&#20026;n&#30340;&#20803;&#32032;&#23601;&#21487;&#20197;&#20102;
</span>        
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#20803;&#32032;&#35745;&#25968;
</span>        <span class="org-type">unordered_map</span>&lt;<span class="org-type">int</span>, <span class="org-type">int</span>&gt; <span class="org-variable-name">count</span>;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; nums.size(); ++i) {
            count[ nums[i] ]++;
        }

        
        <span class="org-type">int</span> <span class="org-variable-name">n</span> = nums.size()/2;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt;nums.size(); ++i) {
            <span class="org-keyword">if</span>(count[nums[i]] == n) {
                <span class="org-keyword">return</span> nums[i];
            }
        }
        <span class="org-keyword">return</span> -1;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:f3430040-faff-42e7-b3f5-e996c41cb910" class="outline-5">
<h5 id="h:f3430040-faff-42e7-b3f5-e996c41cb910"><a href="#h:f3430040-faff-42e7-b3f5-e996c41cb910">13.独一无二的出现次数</a></h5>
<div class="outline-text-5" id="text-h:f3430040-faff-42e7-b3f5-e996c41cb910">
<p>
<a href="https://leetcode.cn/problems/unique-number-of-occurrences/">https://leetcode.cn/problems/unique-number-of-occurrences/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#25972;&#25968;&#25968;&#32452; arr&#65292;&#22914;&#26524;&#27599;&#20010;&#25968;&#30340;&#20986;&#29616;&#27425;&#25968;&#37117;&#26159;&#29420;&#19968;&#26080;&#20108;&#30340;&#65292;&#23601;&#36820;&#22238; true&#65307;&#21542;&#21017;&#36820;&#22238; false&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;arr = [1,2,2,1,1,3]
&#36755;&#20986;&#65306;true
&#35299;&#37322;&#65306;&#22312;&#35813;&#25968;&#32452;&#20013;&#65292;1 &#20986;&#29616;&#20102; 3 &#27425;&#65292;2 &#20986;&#29616;&#20102; 2 &#27425;&#65292;3 &#21482;&#20986;&#29616;&#20102; 1 &#27425;&#12290;&#27809;&#26377;&#20004;&#20010;&#25968;&#30340;&#20986;&#29616;&#27425;&#25968;&#30456;&#21516;&#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;arr = [1,2]
&#36755;&#20986;&#65306;false

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;arr = [-3,0,1,-3,1,1,1,-3,10,0]
&#36755;&#20986;&#65306;true

&#25552;&#31034;&#65306;
1 &lt;= arr.length &lt;= 1000
-1000 &lt;= arr[i] &lt;= 1000
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">bool</span> <span class="org-function-name">uniqueOccurrences</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">arr</span>) {
        <span class="org-type">unordered_map</span>&lt;<span class="org-type">int</span>, <span class="org-type">int</span>&gt; <span class="org-variable-name">count</span>;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt;arr.size(); ++i) {
            count[ arr[i] ]++;
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21453;&#21521;&#26144;&#23556;
</span>        <span class="org-type">unordered_map</span>&lt;<span class="org-type">int</span>, <span class="org-type">int</span>&gt; <span class="org-variable-name">hash</span>;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; arr.size(); ++i) {
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#25343;&#21040;&#27425;&#25968;&#65292;&#24182;&#25226;&#36825;&#20010;&#27425;&#25968;&#29992;&#21704;&#24076;&#35760;&#24405;
</span>            <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#25214;&#19981;&#21040;&#21464;&#25104;arr[i]&#65307;&#22914;&#26524;&#25214;&#21040;&#21017;&#21028;&#26029;hash[x] &#26159;&#21542;&#20026;arr[i]
</span>            <span class="org-comment-delimiter">// </span><span class="org-comment">&#19981;&#31561;&#20110;arr[i]&#65292;&#35828;&#26126;&#20986;&#29616;&#36825;&#20010;&#25968;&#30340;&#27425;&#25968;&#33267;&#23569;2&#20010;&#12290;&#36820;&#22238;false
</span>            <span class="org-type">int</span> <span class="org-variable-name">x</span> = count[arr[i]];
            <span class="org-keyword">if</span>(hash.find(x) == hash.end()) {
                <span class="org-type">hash</span>[x] = arr[i];
            } <span class="org-keyword">else</span> {
                <span class="org-keyword">if</span>(<span class="org-type">hash</span>[x] != arr[i]) {
                    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
                }
            }
        }
        <span class="org-keyword">return</span> <span class="org-constant">true</span>;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:912f1d67-57cc-4796-9fb7-c1b0129ec2a3" class="outline-5">
<h5 id="h:912f1d67-57cc-4796-9fb7-c1b0129ec2a3"><a href="#h:912f1d67-57cc-4796-9fb7-c1b0129ec2a3">14.找出数组中的所有孤独数字</a></h5>
<div class="outline-text-5" id="text-h:912f1d67-57cc-4796-9fb7-c1b0129ec2a3">
<p>
<a href="https://leetcode.cn/problems/find-all-lonely-numbers-in-the-array/description/">https://leetcode.cn/problems/find-all-lonely-numbers-in-the-array/description/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#25972;&#25968;&#25968;&#32452; nums &#12290;&#22914;&#26524;&#25968;&#23383; x &#22312;&#25968;&#32452;&#20013;&#20165;&#20986;&#29616; &#19968;&#27425; &#65292;
&#19988;&#27809;&#26377; &#30456;&#37051; &#25968;&#23383;&#65288;&#21363;&#65292;x + 1 &#21644; x - 1&#65289;&#20986;&#29616;&#22312;&#25968;&#32452;&#20013;&#65292;&#21017;&#35748;&#20026;&#25968;&#23383; x &#26159; &#23396;&#29420;&#25968;&#23383; &#12290;

&#36820;&#22238; nums &#20013;&#30340; &#25152;&#26377; &#23396;&#29420;&#25968;&#23383;&#12290;&#20320;&#21487;&#20197;&#25353; &#20219;&#20309;&#39034;&#24207; &#36820;&#22238;&#31572;&#26696;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;nums = [10,6,5,8]
&#36755;&#20986;&#65306;[10,8]
&#35299;&#37322;&#65306;
- 10 &#26159;&#19968;&#20010;&#23396;&#29420;&#25968;&#23383;&#65292;&#22240;&#20026;&#23427;&#21482;&#20986;&#29616;&#19968;&#27425;&#65292;&#24182;&#19988; 9 &#21644; 11 &#27809;&#26377;&#22312; nums &#20013;&#20986;&#29616;&#12290;
- 8 &#26159;&#19968;&#20010;&#23396;&#29420;&#25968;&#23383;&#65292;&#22240;&#20026;&#23427;&#21482;&#20986;&#29616;&#19968;&#27425;&#65292;&#24182;&#19988; 7 &#21644; 9 &#27809;&#26377;&#22312; nums &#20013;&#20986;&#29616;&#12290;
- 5 &#19981;&#26159;&#19968;&#20010;&#23396;&#29420;&#25968;&#23383;&#65292;&#22240;&#20026; 6 &#20986;&#29616;&#22312; nums &#20013;&#65292;&#21453;&#20043;&#20134;&#28982;&#12290;
&#22240;&#27492;&#65292;nums &#20013;&#30340;&#23396;&#29420;&#25968;&#23383;&#26159; [10, 8] &#12290;
&#27880;&#24847;&#65292;&#20063;&#21487;&#20197;&#36820;&#22238; [8, 10] &#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;nums = [1,3,5,3]
&#36755;&#20986;&#65306;[1,5]
&#35299;&#37322;&#65306;
- 1 &#26159;&#19968;&#20010;&#23396;&#29420;&#25968;&#23383;&#65292;&#22240;&#20026;&#23427;&#21482;&#20986;&#29616;&#19968;&#27425;&#65292;&#24182;&#19988; 0 &#21644; 2 &#27809;&#26377;&#22312; nums &#20013;&#20986;&#29616;&#12290;
- 5 &#26159;&#19968;&#20010;&#23396;&#29420;&#25968;&#23383;&#65292;&#22240;&#20026;&#23427;&#21482;&#20986;&#29616;&#19968;&#27425;&#65292;&#24182;&#19988; 4 &#21644; 6 &#27809;&#26377;&#22312; nums &#20013;&#20986;&#29616;&#12290;
- 3 &#19981;&#26159;&#19968;&#20010;&#23396;&#29420;&#25968;&#23383;&#65292;&#22240;&#20026;&#23427;&#20986;&#29616;&#20004;&#27425;&#12290;
&#22240;&#27492;&#65292;nums &#20013;&#30340;&#23396;&#29420;&#25968;&#23383;&#26159; [1, 5] &#12290;
&#27880;&#24847;&#65292;&#20063;&#21487;&#20197;&#36820;&#22238; [5, 1] &#12290;

&#25552;&#31034;&#65306;
1 &lt;= nums.length &lt;= 105
0 &lt;= nums[i] &lt;= 106
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-function-name">findLonely</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>) {
        <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">ret</span>;
        <span class="org-type">unordered_map</span>&lt;<span class="org-type">int</span>, <span class="org-type">int</span>&gt; <span class="org-variable-name">count</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#25968;&#23383;&#20986;&#29616;&#27425;&#25968;&#35745;&#25968;
</span>        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; nums.size(); ++i) {
            count[ nums[i] ]++;
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#26816;&#26597;&#20986;&#29616;&#19968;&#27425;&#19988;&#30340;&#28385;&#36275;&#26465;&#20214;&#30340;&#25968;&#65292;&#21152;&#20837;&#21040;&#25968;&#32452;&#20013;
</span>        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; nums.size(); ++i) {
            <span class="org-type">int</span> <span class="org-variable-name">x</span> = nums[i];
            <span class="org-type">int</span> <span class="org-variable-name">l</span> = x -1;
            <span class="org-type">int</span> <span class="org-variable-name">r</span> = x + 1;
            <span class="org-keyword">if</span>(count[x] == 1 &amp;&amp; count[l] == 0 &amp;&amp; count[r] == 0) {
                ret.push_back(x);
            }
        }
        <span class="org-keyword">return</span> ret;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:59df4f91-b32b-4ebd-bbb6-b05126556ae3" class="outline-5">
<h5 id="h:59df4f91-b32b-4ebd-bbb6-b05126556ae3"><a href="#h:59df4f91-b32b-4ebd-bbb6-b05126556ae3">15.单词频率</a></h5>
<div class="outline-text-5" id="text-h:59df4f91-b32b-4ebd-bbb6-b05126556ae3">
<p>
<a href="https://leetcode.cn/problems/words-frequency-lcci/description/">https://leetcode.cn/problems/words-frequency-lcci/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#35774;&#35745;&#19968;&#20010;&#26041;&#27861;&#65292;&#25214;&#20986;&#20219;&#24847;&#25351;&#23450;&#21333;&#35789;&#22312;&#19968;&#26412;&#20070;&#20013;&#30340;&#20986;&#29616;&#39057;&#29575;&#12290;

&#20320;&#30340;&#23454;&#29616;&#24212;&#35813;&#25903;&#25345;&#22914;&#19979;&#25805;&#20316;&#65306;
WordsFrequency(book)&#26500;&#36896;&#20989;&#25968;&#65292;&#21442;&#25968;&#20026;&#23383;&#31526;&#20018;&#25968;&#32452;&#26500;&#25104;&#30340;&#19968;&#26412;&#20070;
get(word)&#26597;&#35810;&#25351;&#23450;&#21333;&#35789;&#22312;&#20070;&#20013;&#20986;&#29616;&#30340;&#39057;&#29575;

&#31034;&#20363;&#65306;
WordsFrequency wordsFrequency = new WordsFrequency({"i", "have", "an", "apple", "he", "have", "a", "pen"});
wordsFrequency.get("you"); //&#36820;&#22238;0&#65292;"you"&#27809;&#26377;&#20986;&#29616;&#36807;
wordsFrequency.get("have"); //&#36820;&#22238;2&#65292;"have"&#20986;&#29616;2&#27425;
wordsFrequency.get("an"); //&#36820;&#22238;1
wordsFrequency.get("apple"); //&#36820;&#22238;1
wordsFrequency.get("pen"); //&#36820;&#22238;1

&#25552;&#31034;&#65306;
book[i]&#20013;&#21482;&#21253;&#21547;&#23567;&#20889;&#23383;&#27597;
1 &lt;= book.length &lt;= 100000
1 &lt;= book[i].length &lt;= 10
get&#20989;&#25968;&#30340;&#35843;&#29992;&#27425;&#25968;&#19981;&#20250;&#36229;&#36807;100000
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">WordsFrequency</span> {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#19968;&#20010;&#35745;&#25968;&#22120;
</span>    <span class="org-type">unordered_map</span>&lt;<span class="org-type">string</span>, <span class="org-type">int</span>&gt; <span class="org-variable-name">count</span>;
<span class="org-keyword">public</span>:
    <span class="org-function-name">WordsFrequency</span>(<span class="org-type">vector</span>&lt;<span class="org-type">string</span>&gt;&amp; <span class="org-variable-name">book</span>) {
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; book.size(); ++i) {
            count[book[i]]++;
        }
    }
    
    <span class="org-type">int</span> <span class="org-function-name">get</span>(<span class="org-type">string</span> <span class="org-variable-name">word</span>) {
        <span class="org-keyword">return</span> count[word];
    }
};

<span class="org-doc">/**
 * Your WordsFrequency object will be instantiated and called as such:
 * WordsFrequency* obj = new WordsFrequency(book);
 * int param_1 = obj-&gt;get(word);
 */</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-h:ae721dfe-a2bc-4df1-8b4f-02f5e9ed338f" class="outline-5">
<h5 id="h:ae721dfe-a2bc-4df1-8b4f-02f5e9ed338f"><a href="#h:ae721dfe-a2bc-4df1-8b4f-02f5e9ed338f">16.人口最多的年份</a></h5>
<div class="outline-text-5" id="text-h:ae721dfe-a2bc-4df1-8b4f-02f5e9ed338f">
<p>
<a href="https://leetcode.cn/problems/maximum-population-year/">https://leetcode.cn/problems/maximum-population-year/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#20108;&#32500;&#25972;&#25968;&#25968;&#32452; logs &#65292;&#20854;&#20013;&#27599;&#20010; logs[i] = [birthi, deathi] &#34920;&#31034;&#31532; i &#20010;&#20154;&#30340;&#20986;&#29983;&#21644;&#27515;&#20129;&#24180;&#20221;&#12290;

&#24180;&#20221; x &#30340; &#20154;&#21475; &#23450;&#20041;&#20026;&#36825;&#19968;&#24180;&#26399;&#38388;&#27963;&#30528;&#30340;&#20154;&#30340;&#25968;&#30446;&#12290;&#31532; i &#20010;&#20154;&#34987;&#35745;&#20837;&#24180;&#20221; x 
&#30340;&#20154;&#21475;&#38656;&#35201;&#28385;&#36275;&#65306;x &#22312;&#38381;&#21306;&#38388; [birthi, deathi - 1] &#20869;&#12290;&#27880;&#24847;&#65292;&#20154;&#19981;&#24212;&#24403;&#35745;&#20837;&#20182;&#20204;&#27515;&#20129;&#24403;&#24180;&#30340;&#20154;&#21475;&#20013;&#12290;

&#36820;&#22238; &#20154;&#21475;&#26368;&#22810; &#19988; &#26368;&#26089; &#30340;&#24180;&#20221;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;logs = [[1993,1999],[2000,2010]]
&#36755;&#20986;&#65306;1993
&#35299;&#37322;&#65306;&#20154;&#21475;&#26368;&#22810;&#20026; 1 &#65292;&#32780; 1993 &#26159;&#20154;&#21475;&#20026; 1 &#30340;&#26368;&#26089;&#24180;&#20221;&#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;logs = [[1950,1961],[1960,1971],[1970,1981]]
&#36755;&#20986;&#65306;1960
&#35299;&#37322;&#65306; 
&#20154;&#21475;&#26368;&#22810;&#20026; 2 &#65292;&#20998;&#21035;&#20986;&#29616;&#22312; 1960 &#21644; 1970 &#12290;
&#20854;&#20013;&#26368;&#26089;&#24180;&#20221;&#26159; 1960 &#12290;

&#25552;&#31034;&#65306;
1 &lt;= logs.length &lt;= 100
1950 &lt;= birthi &lt; deathi &lt;= 2050
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">maximumPopulation</span>(<span class="org-type">vector</span>&lt;<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&gt;&amp; <span class="org-variable-name">logs</span>) {
        <span class="org-type">int</span> <span class="org-variable-name">count</span>[2051] = {0};
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt;logs.size(); ++i) {
            <span class="org-type">int</span> <span class="org-variable-name">b</span> = logs[i][0];
            <span class="org-type">int</span> <span class="org-variable-name">d</span> = logs[i][1] - 1;
            <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = b; j &lt;= d; ++j) {
                count[j]++;
            }
        }
        <span class="org-type">int</span> <span class="org-variable-name">max</span> = 1950;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 1950; i &lt;= 2050; ++i) {
            <span class="org-keyword">if</span> (count[i] &gt; count[max]) {
                max = i;
            }
        }
        <span class="org-keyword">return</span> max;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:a0f18f27-aa16-4f7e-9464-c5651f0caf75" class="outline-5">
<h5 id="h:a0f18f27-aa16-4f7e-9464-c5651f0caf75"><a href="#h:a0f18f27-aa16-4f7e-9464-c5651f0caf75">17.盒子中小球的最大数量</a></h5>
<div class="outline-text-5" id="text-h:a0f18f27-aa16-4f7e-9464-c5651f0caf75">
<p>
<a href="https://leetcode.cn/problems/maximum-number-of-balls-in-a-box/">https://leetcode.cn/problems/maximum-number-of-balls-in-a-box/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#20320;&#22312;&#19968;&#23478;&#29983;&#20135;&#23567;&#29699;&#30340;&#29609;&#20855;&#21378;&#24037;&#20316;&#65292;&#26377; n &#20010;&#23567;&#29699;&#65292;&#32534;&#21495;&#20174; lowLimit &#24320;&#22987;&#65292;
&#21040; highLimit &#32467;&#26463;&#65288;&#21253;&#25324; lowLimit &#21644; highLimit &#65292;&#21363; n == highLimit - lowLimit + 1&#65289;&#12290;&#21478;&#26377;&#26080;&#38480;&#25968;&#37327;&#30340;&#30418;&#23376;&#65292;&#32534;&#21495;&#20174; 1 &#21040; infinity &#12290;

&#20320;&#30340;&#24037;&#20316;&#26159;&#23558;&#27599;&#20010;&#23567;&#29699;&#25918;&#20837;&#30418;&#23376;&#20013;&#65292;&#20854;&#20013;&#30418;&#23376;&#30340;&#32534;&#21495;&#24212;&#24403;&#31561;&#20110;&#23567;&#29699;&#32534;&#21495;&#19978;&#27599;&#20301;&#25968;&#23383;&#30340;&#21644;&#12290;
&#20363;&#22914;&#65292;&#32534;&#21495; 321 &#30340;&#23567;&#29699;&#24212;&#24403;&#25918;&#20837;&#32534;&#21495; 3 + 2 + 1 = 6 &#30340;&#30418;&#23376;&#65292;&#32780;&#32534;&#21495; 10 &#30340;&#23567;&#29699;&#24212;&#24403;&#25918;&#20837;&#32534;&#21495; 1 + 0 = 1 &#30340;&#30418;&#23376;&#12290;

&#32473;&#20320;&#20004;&#20010;&#25972;&#25968; lowLimit &#21644; highLimit &#65292;&#36820;&#22238;&#25918;&#26377;&#26368;&#22810;&#23567;&#29699;&#30340;&#30418;&#23376;&#20013;&#30340;&#23567;&#29699;&#25968;&#37327;&#12290;&#22914;&#26524;&#26377;&#22810;&#20010;&#30418;&#23376;&#37117;&#28385;&#36275;&#25918;&#26377;&#26368;&#22810;&#23567;&#29699;&#65292;&#21482;&#38656;&#36820;&#22238;&#20854;&#20013;&#20219;&#19968;&#30418;&#23376;&#30340;&#23567;&#29699;&#25968;&#37327;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;lowLimit = 1, highLimit = 10
&#36755;&#20986;&#65306;2
&#35299;&#37322;&#65306;
&#30418;&#23376;&#32534;&#21495;&#65306;1 2 3 4 5 6 7 8 9 10 11 ...
&#23567;&#29699;&#25968;&#37327;&#65306;2 1 1 1 1 1 1 1 1 0  0  ...
&#32534;&#21495; 1 &#30340;&#30418;&#23376;&#25918;&#26377;&#26368;&#22810;&#23567;&#29699;&#65292;&#23567;&#29699;&#25968;&#37327;&#20026; 2 &#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;lowLimit = 5, highLimit = 15
&#36755;&#20986;&#65306;2
&#35299;&#37322;&#65306;
&#30418;&#23376;&#32534;&#21495;&#65306;1 2 3 4 5 6 7 8 9 10 11 ...
&#23567;&#29699;&#25968;&#37327;&#65306;1 1 1 1 2 2 1 1 1 0  0  ...
&#32534;&#21495; 5 &#21644; 6 &#30340;&#30418;&#23376;&#25918;&#26377;&#26368;&#22810;&#23567;&#29699;&#65292;&#27599;&#20010;&#30418;&#23376;&#20013;&#30340;&#23567;&#29699;&#25968;&#37327;&#37117;&#26159; 2 &#12290;

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;lowLimit = 19, highLimit = 28
&#36755;&#20986;&#65306;2
&#35299;&#37322;&#65306;
&#30418;&#23376;&#32534;&#21495;&#65306;1 2 3 4 5 6 7 8 9 10 11 12 ...
&#23567;&#29699;&#25968;&#37327;&#65306;0 1 1 1 1 1 1 1 1 2  0  0  ...
&#32534;&#21495; 10 &#30340;&#30418;&#23376;&#25918;&#26377;&#26368;&#22810;&#23567;&#29699;&#65292;&#23567;&#29699;&#25968;&#37327;&#20026; 2 &#12290;

&#25552;&#31034;&#65306;
1 &lt;= lowLimit &lt;= highLimit &lt;= 105
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">countBalls</span>(<span class="org-type">int</span> <span class="org-variable-name">lowLimit</span>, <span class="org-type">int</span> <span class="org-variable-name">highLimit</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#27169;&#25311;&#25968;&#23383;&#20301;&#27714;&#21644;&#12290; lowLimit &lt;= highLimit &lt;= 10^5&#65292;&#25968;&#23383;&#26368;&#22823;&#24773;&#20917;&#26159;5&#20010;9&#65292;5X9=45
</span>        <span class="org-type">int</span> <span class="org-variable-name">count</span>[46] = {0};
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = lowLimit; i &lt;= highLimit; ++i) {
            <span class="org-type">int</span> <span class="org-variable-name">x</span> = i;
            <span class="org-type">int</span> <span class="org-variable-name">sum</span> = 0;
            <span class="org-keyword">while</span>(x) {
                sum += x%10;
                x /= 10;
            }
            count[sum]++;
        }
        <span class="org-type">int</span> <span class="org-variable-name">max</span> = 0;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 1; i &lt;=45; ++i) {
            <span class="org-keyword">if</span>(count[i] &gt; max) {
                max = count[i];
            }
        }
        <span class="org-keyword">return</span> max; 
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:005d2468-3242-41f5-9692-28a6f1e57e56" class="outline-5">
<h5 id="h:005d2468-3242-41f5-9692-28a6f1e57e56"><a href="#h:005d2468-3242-41f5-9692-28a6f1e57e56">18.最大字符串配对数目</a></h5>
<div class="outline-text-5" id="text-h:005d2468-3242-41f5-9692-28a6f1e57e56">
<p>
<a href="https://leetcode.cn/problems/find-maximum-number-of-string-pairs/">https://leetcode.cn/problems/find-maximum-number-of-string-pairs/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#19979;&#26631;&#20174; 0 &#24320;&#22987;&#30340;&#25968;&#32452; words &#65292;&#25968;&#32452;&#20013;&#21253;&#21547; &#20114;&#19981;&#30456;&#21516; &#30340;&#23383;&#31526;&#20018;&#12290;

&#22914;&#26524;&#23383;&#31526;&#20018; words[i] &#19982;&#23383;&#31526;&#20018; words[j] &#28385;&#36275;&#20197;&#19979;&#26465;&#20214;&#65292;&#25105;&#20204;&#31216;&#23427;&#20204;&#21487;&#20197;&#21305;&#37197;&#65306;

&#23383;&#31526;&#20018; words[i] &#31561;&#20110; words[j] &#30340;&#21453;&#36716;&#23383;&#31526;&#20018;&#12290;
0 &lt;= i &lt; j &lt; words.length
&#35831;&#20320;&#36820;&#22238;&#25968;&#32452; words &#20013;&#30340; &#26368;&#22823; &#21305;&#37197;&#25968;&#30446;&#12290;

&#27880;&#24847;&#65292;&#27599;&#20010;&#23383;&#31526;&#20018;&#26368;&#22810;&#21305;&#37197;&#19968;&#27425;&#12290;
 

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;words = ["cd","ac","dc","ca","zz"]
&#36755;&#20986;&#65306;2
&#35299;&#37322;&#65306;&#22312;&#27492;&#31034;&#20363;&#20013;&#65292;&#25105;&#20204;&#21487;&#20197;&#36890;&#36807;&#20197;&#19979;&#26041;&#24335;&#21305;&#37197; 2 &#23545;&#23383;&#31526;&#20018;&#65306;
- &#25105;&#20204;&#23558;&#31532; 0 &#20010;&#23383;&#31526;&#20018;&#19982;&#31532; 2 &#20010;&#23383;&#31526;&#20018;&#21305;&#37197;&#65292;&#22240;&#20026; word[0] &#30340;&#21453;&#36716;&#23383;&#31526;&#20018;&#26159; "dc" &#24182;&#19988;&#31561;&#20110; words[2]&#12290;
- &#25105;&#20204;&#23558;&#31532; 1 &#20010;&#23383;&#31526;&#20018;&#19982;&#31532; 3 &#20010;&#23383;&#31526;&#20018;&#21305;&#37197;&#65292;&#22240;&#20026; word[1] &#30340;&#21453;&#36716;&#23383;&#31526;&#20018;&#26159; "ca" &#24182;&#19988;&#31561;&#20110; words[3]&#12290;
&#21487;&#20197;&#35777;&#26126;&#26368;&#22810;&#21305;&#37197;&#25968;&#30446;&#26159; 2 &#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;words = ["ab","ba","cc"]
&#36755;&#20986;&#65306;1
&#35299;&#37322;&#65306;&#22312;&#27492;&#31034;&#20363;&#20013;&#65292;&#25105;&#20204;&#21487;&#20197;&#36890;&#36807;&#20197;&#19979;&#26041;&#24335;&#21305;&#37197; 1 &#23545;&#23383;&#31526;&#20018;&#65306;
- &#25105;&#20204;&#23558;&#31532; 0 &#20010;&#23383;&#31526;&#20018;&#19982;&#31532; 1 &#20010;&#23383;&#31526;&#20018;&#21305;&#37197;&#65292;&#22240;&#20026; words[1] &#30340;&#21453;&#36716;&#23383;&#31526;&#20018; "ab" &#19982; words[0] &#30456;&#31561;&#12290;
&#21487;&#20197;&#35777;&#26126;&#26368;&#22810;&#21305;&#37197;&#25968;&#30446;&#26159; 1 &#12290;

&#31034;&#20363; 3&#65306;
&#36755;&#20837;&#65306;words = ["aa","ab"]
&#36755;&#20986;&#65306;0
&#35299;&#37322;&#65306;&#36825;&#20010;&#20363;&#23376;&#20013;&#65292;&#26080;&#27861;&#21305;&#37197;&#20219;&#20309;&#23383;&#31526;&#20018;&#12290;

&#25552;&#31034;&#65306;
1 &lt;= words.length &lt;= 50
words[i].length == 2
words &#21253;&#21547;&#30340;&#23383;&#31526;&#20018;&#20114;&#19981;&#30456;&#21516;&#12290;
words[i] &#21482;&#21253;&#21547;&#23567;&#20889;&#33521;&#25991;&#23383;&#27597;&#12290;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">maximumNumberOfStringPairs</span>(<span class="org-type">vector</span>&lt;<span class="org-type">string</span>&gt;&amp; <span class="org-variable-name">words</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#29992; i j &#26522;&#20030;&#65292;&#26102;&#38388;&#22797;&#26434;&#24230;&#20026;O(n^2) &#65292;&#24341;&#29992;&#21704;&#24076;&#26102;&#38388;&#22797;&#26434;&#24230;O(n)
</span>        <span class="org-type">unordered_map</span>&lt;<span class="org-type">string</span>, <span class="org-type">int</span>&gt; <span class="org-variable-name">cnt</span>;
        <span class="org-type">int</span> <span class="org-variable-name">ans</span> = 0;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; words.size(); ++i) {
            <span class="org-type">string</span>&amp; <span class="org-variable-name">s</span> = words[i];
            ans += cnt[s];                <span class="org-comment-delimiter">// </span><span class="org-comment">1. &#21704;&#24076;&#34920;&#30340;&#20803;&#32032;&#26597;&#25214;
</span>            cnt[s]--;                     <span class="org-comment-delimiter">// </span><span class="org-comment">2. &#21704;&#24076;&#34920;&#30340;&#20803;&#32032;&#21024;&#38500;
</span>            reverse(s.begin(), s.end());
            cnt[s]++;                     <span class="org-comment-delimiter">// </span><span class="org-comment">3. &#21704;&#24076;&#34920;&#30340;&#20803;&#32032;&#25554;&#20837;
</span>        }
        <span class="org-keyword">return</span> ans;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:b0142e19-e02f-48b2-b826-3fbfe6140171" class="outline-5">
<h5 id="h:b0142e19-e02f-48b2-b826-3fbfe6140171"><a href="#h:b0142e19-e02f-48b2-b826-3fbfe6140171">19.两个字符串的排列差</a></h5>
<div class="outline-text-5" id="text-h:b0142e19-e02f-48b2-b826-3fbfe6140171">
<p>
<a href="https://leetcode.cn/problems/permutation-difference-between-two-strings/description/">https://leetcode.cn/problems/permutation-difference-between-two-strings/description/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#20004;&#20010;&#23383;&#31526;&#20018; s &#21644; t&#65292;&#27599;&#20010;&#23383;&#31526;&#20018;&#20013;&#30340;&#23383;&#31526;&#37117;&#19981;&#37325;&#22797;&#65292;&#19988; t &#26159; s &#30340;&#19968;&#20010;&#25490;&#21015;&#12290;

&#25490;&#21015;&#24046; &#23450;&#20041;&#20026; s &#21644; t &#20013;&#27599;&#20010;&#23383;&#31526;&#22312;&#20004;&#20010;&#23383;&#31526;&#20018;&#20013;&#20301;&#32622;&#30340;&#32477;&#23545;&#24046;&#20540;&#20043;&#21644;&#12290;

&#36820;&#22238; s &#21644; t &#20043;&#38388;&#30340; &#25490;&#21015;&#24046; &#12290;


&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;s = "abc", t = "bac"
&#36755;&#20986;&#65306;2
&#35299;&#37322;&#65306;
&#23545;&#20110; s = "abc" &#21644; t = "bac"&#65292;&#25490;&#21015;&#24046;&#26159;&#65306;
"a" &#22312; s &#20013;&#30340;&#20301;&#32622;&#19982;&#22312; t &#20013;&#30340;&#20301;&#32622;&#20043;&#24046;&#30340;&#32477;&#23545;&#20540;&#12290;
"b" &#22312; s &#20013;&#30340;&#20301;&#32622;&#19982;&#22312; t &#20013;&#30340;&#20301;&#32622;&#20043;&#24046;&#30340;&#32477;&#23545;&#20540;&#12290;
"c" &#22312; s &#20013;&#30340;&#20301;&#32622;&#19982;&#22312; t &#20013;&#30340;&#20301;&#32622;&#20043;&#24046;&#30340;&#32477;&#23545;&#20540;&#12290;
&#21363;&#65292;s &#21644; t &#30340;&#25490;&#21015;&#24046;&#31561;&#20110; |0 - 1| + |1 - 0| + |2 - 2| = 2&#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;s = "abcde", t = "edbac"
&#36755;&#20986;&#65306;12
&#35299;&#37322;&#65306; s &#21644; t &#30340;&#25490;&#21015;&#24046;&#31561;&#20110; |0 - 3| + |1 - 2| + |2 - 4| + |3 - 1| + |4 - 0| = 12&#12290;

&#25552;&#31034;&#65306;
1 &lt;= s.length &lt;= 26
&#27599;&#20010;&#23383;&#31526;&#22312; s &#20013;&#26368;&#22810;&#20986;&#29616;&#19968;&#27425;&#12290;
t &#26159; s &#30340;&#19968;&#20010;&#25490;&#21015;&#12290;
s &#20165;&#30001;&#23567;&#20889;&#33521;&#25991;&#23383;&#27597;&#32452;&#25104;&#12290;
</pre>
</div>


<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">int</span> <span class="org-function-name">findPermutationDifference</span>(<span class="org-type">string</span> <span class="org-variable-name">s</span>, <span class="org-type">string</span> <span class="org-variable-name">t</span>) {
        <span class="org-type">int</span> <span class="org-variable-name">index</span>[256];
        memset(index, -1, <span class="org-keyword">sizeof</span>(index));
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; s.size(); ++i) {
            <span class="org-type">char</span> <span class="org-variable-name">c</span> = s[i];
            index[c] = i; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;&#23383;&#31526;s[i]&#65292;&#36890;&#36807;index[s[i]]&#23601;&#33021;&#25214;&#21040;&#23427;&#22312;s&#20013;&#30340;&#19979;&#26631;
</span>        }
        <span class="org-type">int</span> <span class="org-variable-name">ans</span> = 0;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; t.size(); ++i) {
            <span class="org-type">char</span> <span class="org-variable-name">c</span> = t[i];
            ans += abs(i - index[c]);
        }
        <span class="org-keyword">return</span> ans;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:ba482be2-9aaa-42cc-b408-df98193024b2" class="outline-5">
<h5 id="h:ba482be2-9aaa-42cc-b408-df98193024b2"><a href="#h:ba482be2-9aaa-42cc-b408-df98193024b2">20.找出缺失和重复的数字</a></h5>
<div class="outline-text-5" id="text-h:ba482be2-9aaa-42cc-b408-df98193024b2">
<p>
<a href="https://leetcode.cn/problems/find-missing-and-repeated-values/">https://leetcode.cn/problems/find-missing-and-repeated-values/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#19979;&#26631;&#20174; 0 &#24320;&#22987;&#30340;&#20108;&#32500;&#25972;&#25968;&#30697;&#38453; grid&#65292;&#22823;&#23567;&#20026; n * n &#65292;&#20854;&#20013;&#30340;&#20540;&#22312; [1, n2] &#33539;&#22260;&#20869;&#12290;
&#38500;&#20102; a &#20986;&#29616; &#20004;&#27425;&#65292;b &#32570;&#22833; &#20043;&#22806;&#65292;&#27599;&#20010;&#25972;&#25968;&#37117; &#24688;&#22909;&#20986;&#29616;&#19968;&#27425; &#12290;

&#20219;&#21153;&#26159;&#25214;&#20986;&#37325;&#22797;&#30340;&#25968;&#23383;a &#21644;&#32570;&#22833;&#30340;&#25968;&#23383; b &#12290;

&#36820;&#22238;&#19968;&#20010;&#19979;&#26631;&#20174; 0 &#24320;&#22987;&#12289;&#38271;&#24230;&#20026; 2 &#30340;&#25972;&#25968;&#25968;&#32452; ans &#65292;&#20854;&#20013; ans[0] &#31561;&#20110; a &#65292;ans[1] &#31561;&#20110; b &#12290;


&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;grid = [[1,3],[2,2]]
&#36755;&#20986;&#65306;[2,4]
&#35299;&#37322;&#65306;&#25968;&#23383; 2 &#37325;&#22797;&#65292;&#25968;&#23383; 4 &#32570;&#22833;&#65292;&#25152;&#20197;&#31572;&#26696;&#26159; [2,4] &#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;grid = [[9,1,7],[8,9,2],[3,4,6]]
&#36755;&#20986;&#65306;[9,5]
&#35299;&#37322;&#65306;&#25968;&#23383; 9 &#37325;&#22797;&#65292;&#25968;&#23383; 5 &#32570;&#22833;&#65292;&#25152;&#20197;&#31572;&#26696;&#26159; [9,5] &#12290;

&#25552;&#31034;&#65306;
2 &lt;= n == grid.length == grid[i].length &lt;= 50
1 &lt;= grid[i][j] &lt;= n * n
&#23545;&#20110;&#25152;&#26377;&#28385;&#36275;1 &lt;= x &lt;= n * n &#30340; x &#65292;&#24688;&#22909;&#23384;&#22312;&#19968;&#20010; x &#19982;&#30697;&#38453;&#20013;&#30340;&#20219;&#20309;&#25104;&#21592;&#37117;&#19981;&#30456;&#31561;&#12290;
&#23545;&#20110;&#25152;&#26377;&#28385;&#36275;1 &lt;= x &lt;= n * n &#30340; x &#65292;&#24688;&#22909;&#23384;&#22312;&#19968;&#20010; x &#19982;&#30697;&#38453;&#20013;&#30340;&#20004;&#20010;&#25104;&#21592;&#30456;&#31561;&#12290;
&#38500;&#19978;&#36848;&#30340;&#20004;&#20010;&#20043;&#22806;&#65292;&#23545;&#20110;&#25152;&#26377;&#28385;&#36275;1 &lt;= x &lt;= n * n &#30340; x &#65292;&#37117;&#24688;&#22909;&#23384;&#22312;&#19968;&#23545; i, j &#28385;&#36275; 0 &lt;= i, j &lt;= n - 1 &#19988; grid[i][j] == x &#12290;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-function-name">findMissingAndRepeatedValues</span>(<span class="org-type">vector</span>&lt;<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&gt;&amp; <span class="org-variable-name">grid</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#25152;&#26377;&#20986;&#29616;&#30340;&#25968;&#23383;&#26144;&#23556;&#21040;&#21704;&#24076;&#34920;&#20013; 50*50 = 2500&#65292;
</span>        <span class="org-type">int</span> <span class="org-variable-name">hash</span>[2501] = {0};
        <span class="org-type">int</span> <span class="org-variable-name">n</span> = grid.size();
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; ++i) {
            <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; grid[i].size(); ++j) {
                <span class="org-type">hash</span>[ grid[i][j] ]++;
            }
        }
        <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">ans</span>;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 1; i &lt;= n*n; ++i) {
            <span class="org-keyword">if</span>(<span class="org-type">hash</span>[i] == 2) {
                ans.push_back(i);
            }
        }
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 1; i &lt;= n*n; ++i) {
            <span class="org-keyword">if</span> (<span class="org-type">hash</span>[i] == 0) {
                ans.push_back(i);
            }
        }
        <span class="org-keyword">return</span> ans;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:b2328e94-9875-49aa-86ad-b833ead14e9a" class="outline-5">
<h5 id="h:b2328e94-9875-49aa-86ad-b833ead14e9a"><a href="#h:b2328e94-9875-49aa-86ad-b833ead14e9a">21.判断句子是否为全字母句</a></h5>
<div class="outline-text-5" id="text-h:b2328e94-9875-49aa-86ad-b833ead14e9a">
<div class="org-src-container">
<pre class="src src-text">&#20840;&#23383;&#27597;&#21477; &#25351;&#21253;&#21547;&#33521;&#35821;&#23383;&#27597;&#34920;&#20013;&#27599;&#20010;&#23383;&#27597;&#33267;&#23569;&#19968;&#27425;&#30340;&#21477;&#23376;&#12290;

&#32473;&#20320;&#19968;&#20010;&#20165;&#30001;&#23567;&#20889;&#33521;&#25991;&#23383;&#27597;&#32452;&#25104;&#30340;&#23383;&#31526;&#20018; sentence &#65292;&#35831;&#20320;&#21028;&#26029; sentence &#26159;&#21542;&#20026; &#20840;&#23383;&#27597;&#21477; &#12290;

&#22914;&#26524;&#26159;&#65292;&#36820;&#22238; true &#65307;&#21542;&#21017;&#65292;&#36820;&#22238; false &#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;sentence = "thequickbrownfoxjumpsoverthelazydog"
&#36755;&#20986;&#65306;true
&#35299;&#37322;&#65306;sentence &#21253;&#21547;&#33521;&#35821;&#23383;&#27597;&#34920;&#20013;&#27599;&#20010;&#23383;&#27597;&#33267;&#23569;&#19968;&#27425;&#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;sentence = "leetcode"
&#36755;&#20986;&#65306;false

&#25552;&#31034;&#65306;
1 &lt;= sentence.length &lt;= 1000
sentence &#30001;&#23567;&#20889;&#33521;&#35821;&#23383;&#27597;&#32452;&#25104;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">bool</span> <span class="org-function-name">checkIfPangram</span>(<span class="org-type">string</span> <span class="org-variable-name">sentence</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#23450;&#20041;&#23383;&#27597;&#21704;&#24076;&#65292;&#36941;&#21382;sentence,&#23384;&#22312;&#23383;&#27597;&#23450;&#20041;&#20026;true
</span>        <span class="org-type">bool</span> <span class="org-variable-name">hash</span>[256] = {<span class="org-constant">false</span>};
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; sentence.size(); ++i) {
            <span class="org-type">hash</span>[sentence[i]] = <span class="org-constant">true</span>;
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#36941;&#21382;a-z&#65292;&#37117;&#23384;&#22312;&#36820;&#22238;true
</span>        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = <span class="org-string">'a'</span>; i &lt;= <span class="org-string">'z'</span>; ++i) {
            <span class="org-keyword">if</span>(<span class="org-type">hash</span>[i] == <span class="org-constant">false</span>) {
                <span class="org-keyword">return</span> <span class="org-constant">false</span>;
            }
        }
        <span class="org-keyword">return</span> <span class="org-constant">true</span>;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:a104f5f2-1850-43d6-82d5-6e2ce7df6c9e" class="outline-5">
<h5 id="h:a104f5f2-1850-43d6-82d5-6e2ce7df6c9e"><a href="#h:a104f5f2-1850-43d6-82d5-6e2ce7df6c9e">22.第一个出现两次的字母</a></h5>
<div class="outline-text-5" id="text-h:a104f5f2-1850-43d6-82d5-6e2ce7df6c9e">
<p>
<a href="https://leetcode.cn/problems/first-letter-to-appear-twice/">https://leetcode.cn/problems/first-letter-to-appear-twice/</a>
</p>

<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#30001;&#23567;&#20889;&#33521;&#25991;&#23383;&#27597;&#32452;&#25104;&#30340;&#23383;&#31526;&#20018; s &#65292;&#35831;&#20320;&#25214;&#20986;&#24182;&#36820;&#22238;&#31532;&#19968;&#20010;&#20986;&#29616; &#20004;&#27425; &#30340;&#23383;&#27597;&#12290;

&#27880;&#24847;&#65306;
&#22914;&#26524; a &#30340; &#31532;&#20108;&#27425; &#20986;&#29616;&#27604; b &#30340; &#31532;&#20108;&#27425; &#20986;&#29616;&#22312;&#23383;&#31526;&#20018;&#20013;&#30340;&#20301;&#32622;&#26356;&#38752;&#21069;&#65292;&#21017;&#35748;&#20026;&#23383;&#27597; a &#22312;&#23383;&#27597; b &#20043;&#21069;&#20986;&#29616;&#20004;&#27425;&#12290;
s &#21253;&#21547;&#33267;&#23569;&#19968;&#20010;&#20986;&#29616;&#20004;&#27425;&#30340;&#23383;&#27597;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;s = "abccbaacz"
&#36755;&#20986;&#65306;"c"
&#35299;&#37322;&#65306;
&#23383;&#27597; 'a' &#22312;&#19979;&#26631; 0 &#12289;5 &#21644; 6 &#22788;&#20986;&#29616;&#12290;
&#23383;&#27597; 'b' &#22312;&#19979;&#26631; 1 &#21644; 4 &#22788;&#20986;&#29616;&#12290;
&#23383;&#27597; 'c' &#22312;&#19979;&#26631; 2 &#12289;3 &#21644; 7 &#22788;&#20986;&#29616;&#12290;
&#23383;&#27597; 'z' &#22312;&#19979;&#26631; 8 &#22788;&#20986;&#29616;&#12290;
&#23383;&#27597; 'c' &#26159;&#31532;&#19968;&#20010;&#20986;&#29616;&#20004;&#27425;&#30340;&#23383;&#27597;&#65292;&#22240;&#20026;&#22312;&#25152;&#26377;&#23383;&#27597;&#20013;&#65292;'c' &#31532;&#20108;&#27425;&#20986;&#29616;&#30340;&#19979;&#26631;&#26159;&#26368;&#23567;&#30340;&#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;s = "abcdd"
&#36755;&#20986;&#65306;"d"
&#35299;&#37322;&#65306;
&#21482;&#26377;&#23383;&#27597; 'd' &#20986;&#29616;&#20004;&#27425;&#65292;&#25152;&#20197;&#36820;&#22238; 'd' &#12290;

&#25552;&#31034;&#65306;
2 &lt;= s.length &lt;= 100
s &#30001;&#23567;&#20889;&#33521;&#25991;&#23383;&#27597;&#32452;&#25104;
s &#21253;&#21547;&#33267;&#23569;&#19968;&#20010;&#37325;&#22797;&#23383;&#27597;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">char</span> <span class="org-function-name">repeatedCharacter</span>(<span class="org-type">string</span> <span class="org-variable-name">s</span>) {
        <span class="org-type">int</span> <span class="org-variable-name">hash</span>[256] = {0}; <span class="org-comment-delimiter">// </span><span class="org-comment">&#40664;&#35748;&#25152;&#26377;&#23383;&#27597;&#20986;&#29616;0&#27425;
</span>        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; s.size(); ++i) {
            <span class="org-type">char</span> <span class="org-variable-name">c</span> = s[i];
            ++hash[c];
            <span class="org-keyword">if</span>(<span class="org-type">hash</span>[c] == 2) {
                <span class="org-keyword">return</span> c;
            }
        }
        <span class="org-keyword">return</span> -1;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:e1bd16d4-c1fb-4b26-b479-207f61ca216d" class="outline-5">
<h5 id="h:e1bd16d4-c1fb-4b26-b479-207f61ca216d"><a href="#h:e1bd16d4-c1fb-4b26-b479-207f61ca216d">23.找出不同元素数目差数组</a></h5>
<div class="outline-text-5" id="text-h:e1bd16d4-c1fb-4b26-b479-207f61ca216d">
<p>
<a href="https://leetcode.cn/problems/find-the-distinct-difference-array/">https://leetcode.cn/problems/find-the-distinct-difference-array/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#19979;&#26631;&#20174; 0 &#24320;&#22987;&#30340;&#25968;&#32452; nums &#65292;&#25968;&#32452;&#38271;&#24230;&#20026; n &#12290;

nums &#30340; &#19981;&#21516;&#20803;&#32032;&#25968;&#30446;&#24046; &#25968;&#32452;&#21487;&#20197;&#29992;&#19968;&#20010;&#38271;&#24230;&#20026; n &#30340;&#25968;&#32452; diff &#34920;&#31034;&#65292;
&#20854;&#20013; diff[i] &#31561;&#20110;&#21069;&#32512; nums[0, ..., i] &#20013;&#19981;&#21516;&#20803;&#32032;&#30340;&#25968;&#30446; &#20943;&#21435; &#21518;&#32512; nums[i + 1, ..., n - 1] &#20013;&#19981;&#21516;&#20803;&#32032;&#30340;&#25968;&#30446;&#12290;

&#36820;&#22238; nums &#30340; &#19981;&#21516;&#20803;&#32032;&#25968;&#30446;&#24046; &#25968;&#32452;&#12290;

&#27880;&#24847; nums[i, ..., j] &#34920;&#31034; nums &#30340;&#19968;&#20010;&#20174;&#19979;&#26631; i &#24320;&#22987;&#21040;&#19979;&#26631; j &#32467;&#26463;&#30340;&#23376;&#25968;&#32452;&#65288;&#21253;&#21547;&#19979;&#26631; i &#21644; j &#23545;&#24212;&#20803;&#32032;&#65289;&#12290;
&#29305;&#21035;&#38656;&#35201;&#35828;&#26126;&#30340;&#26159;&#65292;&#22914;&#26524; i &gt; j &#65292;&#21017; nums[i, ..., j] &#34920;&#31034;&#19968;&#20010;&#31354;&#23376;&#25968;&#32452;&#12290;


&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;nums = [1,2,3,4,5]
&#36755;&#20986;&#65306;[-3,-1,1,3,5]
&#35299;&#37322;&#65306;
&#23545;&#20110; i = 0&#65292;&#21069;&#32512;&#20013;&#26377; 1 &#20010;&#19981;&#21516;&#30340;&#20803;&#32032;&#65292;&#32780;&#22312;&#21518;&#32512;&#20013;&#26377; 4 &#20010;&#19981;&#21516;&#30340;&#20803;&#32032;&#12290;&#22240;&#27492;&#65292;diff[0] = 1 - 4 = -3 &#12290;
&#23545;&#20110; i = 1&#65292;&#21069;&#32512;&#20013;&#26377; 2 &#20010;&#19981;&#21516;&#30340;&#20803;&#32032;&#65292;&#32780;&#22312;&#21518;&#32512;&#20013;&#26377; 3 &#20010;&#19981;&#21516;&#30340;&#20803;&#32032;&#12290;&#22240;&#27492;&#65292;diff[1] = 2 - 3 = -1 &#12290;
&#23545;&#20110; i = 2&#65292;&#21069;&#32512;&#20013;&#26377; 3 &#20010;&#19981;&#21516;&#30340;&#20803;&#32032;&#65292;&#32780;&#22312;&#21518;&#32512;&#20013;&#26377; 2 &#20010;&#19981;&#21516;&#30340;&#20803;&#32032;&#12290;&#22240;&#27492;&#65292;diff[2] = 3 - 2 = 1 &#12290;
&#23545;&#20110; i = 3&#65292;&#21069;&#32512;&#20013;&#26377; 4 &#20010;&#19981;&#21516;&#30340;&#20803;&#32032;&#65292;&#32780;&#22312;&#21518;&#32512;&#20013;&#26377; 1 &#20010;&#19981;&#21516;&#30340;&#20803;&#32032;&#12290;&#22240;&#27492;&#65292;diff[3] = 4 - 1 = 3 &#12290;
&#23545;&#20110; i = 4&#65292;&#21069;&#32512;&#20013;&#26377; 5 &#20010;&#19981;&#21516;&#30340;&#20803;&#32032;&#65292;&#32780;&#22312;&#21518;&#32512;&#20013;&#26377; 0 &#20010;&#19981;&#21516;&#30340;&#20803;&#32032;&#12290;&#22240;&#27492;&#65292;diff[4] = 5 - 0 = 5 &#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;nums = [3,2,3,4,2]
&#36755;&#20986;&#65306;[-2,-1,0,2,3]
&#35299;&#37322;&#65306;
&#23545;&#20110; i = 0&#65292;&#21069;&#32512;&#20013;&#26377; 1 &#20010;&#19981;&#21516;&#30340;&#20803;&#32032;&#65292;&#32780;&#22312;&#21518;&#32512;&#20013;&#26377; 3 &#20010;&#19981;&#21516;&#30340;&#20803;&#32032;&#12290;&#22240;&#27492;&#65292;diff[0] = 1 - 3 = -2 &#12290;
&#23545;&#20110; i = 1&#65292;&#21069;&#32512;&#20013;&#26377; 2 &#20010;&#19981;&#21516;&#30340;&#20803;&#32032;&#65292;&#32780;&#22312;&#21518;&#32512;&#20013;&#26377; 3 &#20010;&#19981;&#21516;&#30340;&#20803;&#32032;&#12290;&#22240;&#27492;&#65292;diff[1] = 2 - 3 = -1 &#12290;
&#23545;&#20110; i = 2&#65292;&#21069;&#32512;&#20013;&#26377; 2 &#20010;&#19981;&#21516;&#30340;&#20803;&#32032;&#65292;&#32780;&#22312;&#21518;&#32512;&#20013;&#26377; 2 &#20010;&#19981;&#21516;&#30340;&#20803;&#32032;&#12290;&#22240;&#27492;&#65292;diff[2] = 2 - 2 = 0 &#12290;
&#23545;&#20110; i = 3&#65292;&#21069;&#32512;&#20013;&#26377; 3 &#20010;&#19981;&#21516;&#30340;&#20803;&#32032;&#65292;&#32780;&#22312;&#21518;&#32512;&#20013;&#26377; 1 &#20010;&#19981;&#21516;&#30340;&#20803;&#32032;&#12290;&#22240;&#27492;&#65292;diff[3] = 3 - 1 = 2 &#12290;
&#23545;&#20110; i = 4&#65292;&#21069;&#32512;&#20013;&#26377; 3 &#20010;&#19981;&#21516;&#30340;&#20803;&#32032;&#65292;&#32780;&#22312;&#21518;&#32512;&#20013;&#26377; 0 &#20010;&#19981;&#21516;&#30340;&#20803;&#32032;&#12290;&#22240;&#27492;&#65292;diff[4] = 3 - 0 = 3 &#12290; 

&#25552;&#31034;&#65306;
1 &lt;= n == nums.length &lt;= 50
1 &lt;= nums[i] &lt;= 50
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-function-name">distinctDifferenceArray</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>) {
        <span class="org-type">unordered_map</span>&lt;<span class="org-type">int</span>, <span class="org-type">int</span>&gt; <span class="org-variable-name">mp</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#32479;&#35745;&#25152;&#26377;&#30340;&#25968;
</span>        <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">ret</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#21069;&#32512;&#19981;&#21516;&#20803;&#32032;&#30340;&#25968;&#30446;
</span>        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; nums.size(); ++i) {
            <span class="org-comment-delimiter">// </span><span class="org-comment">&#25554;&#20837;&#21040;&#21704;&#24076;&#34920;&#20013;
</span>            <span class="org-type">int</span> <span class="org-variable-name">x</span> = nums[i];
            mp[x] = 1;
            ret.push_back(mp.size());
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;&#21518;&#36941;&#21382;&#65292;&#21069;&#32512; - &#21518;&#32512;&#19981;&#21516;&#20803;&#32032;&#25968;&#30446;
</span>        mp.clear();
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = nums.size()-1; i &gt;= 1; --i) {
            <span class="org-type">int</span> <span class="org-variable-name">x</span> = nums[i];
            mp[x] = 1;
            ret[i-1] -= mp.size();
        }
        <span class="org-keyword">return</span> ret;
    }
};
</pre>
</div>
</div>
</div>
<div id="outline-container-h:1bc56e88-12b5-494b-9e98-fb9847c977a3" class="outline-5">
<h5 id="h:1bc56e88-12b5-494b-9e98-fb9847c977a3"><a href="#h:1bc56e88-12b5-494b-9e98-fb9847c977a3">24.查询数组中元素的出现位置</a></h5>
<div class="outline-text-5" id="text-h:1bc56e88-12b5-494b-9e98-fb9847c977a3">
<p>
<a href="https://leetcode.cn/problems/find-occurrences-of-an-element-in-an-array/">https://leetcode.cn/problems/find-occurrences-of-an-element-in-an-array/</a>
</p>
<div class="org-src-container">
<pre class="src src-text">&#32473;&#20320;&#19968;&#20010;&#25972;&#25968;&#25968;&#32452; nums &#65292;&#19968;&#20010;&#25972;&#25968;&#25968;&#32452; queries &#21644;&#19968;&#20010;&#25972;&#25968; x &#12290;

&#23545;&#20110;&#27599;&#20010;&#26597;&#35810; queries[i] &#65292;&#20320;&#38656;&#35201;&#25214;&#21040; nums &#20013;&#31532; queries[i] &#20010; x &#30340;&#20301;&#32622;&#65292;
&#24182;&#36820;&#22238;&#23427;&#30340;&#19979;&#26631;&#12290;&#22914;&#26524;&#25968;&#32452;&#20013; x &#30340;&#20986;&#29616;&#27425;&#25968;&#23569;&#20110; queries[i] &#65292;&#35813;&#26597;&#35810;&#30340;&#31572;&#26696;&#20026; -1 &#12290;

&#35831;&#20320;&#36820;&#22238;&#19968;&#20010;&#25972;&#25968;&#25968;&#32452; answer &#65292;&#21253;&#21547;&#25152;&#26377;&#26597;&#35810;&#30340;&#31572;&#26696;&#12290;

&#31034;&#20363; 1&#65306;
&#36755;&#20837;&#65306;nums = [1,3,1,7], queries = [1,3,2,4], x = 1
&#36755;&#20986;&#65306;[0,-1,2,-1]
&#35299;&#37322;&#65306;
&#31532; 1 &#20010;&#26597;&#35810;&#65292;&#31532;&#19968;&#20010; 1 &#20986;&#29616;&#22312;&#19979;&#26631; 0 &#22788;&#12290;
&#31532; 2 &#20010;&#26597;&#35810;&#65292;nums &#20013;&#21482;&#26377;&#20004;&#20010; 1 &#65292;&#25152;&#20197;&#31572;&#26696;&#20026; -1 &#12290;
&#31532; 3 &#20010;&#26597;&#35810;&#65292;&#31532;&#20108;&#20010; 1 &#20986;&#29616;&#22312;&#19979;&#26631; 2 &#22788;&#12290;
&#31532; 4 &#20010;&#26597;&#35810;&#65292;nums &#20013;&#21482;&#26377;&#20004;&#20010; 1 &#65292;&#25152;&#20197;&#31572;&#26696;&#20026; -1 &#12290;

&#31034;&#20363; 2&#65306;
&#36755;&#20837;&#65306;nums = [1,2,3], queries = [10], x = 5
&#36755;&#20986;&#65306;[-1]
&#35299;&#37322;&#65306;
&#31532; 1 &#20010;&#26597;&#35810;&#65292;nums &#20013;&#27809;&#26377; 5 &#65292;&#25152;&#20197;&#31572;&#26696;&#20026; -1 &#12290;

&#25552;&#31034;&#65306;
1 &lt;= nums.length, queries.length &lt;= 105
1 &lt;= queries[i] &lt;= 105
1 &lt;= nums[i], x &lt;= 104
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Solution</span> {
<span class="org-keyword">public</span>:
    <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-function-name">occurrencesOfElement</span>(<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">nums</span>, <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt;&amp; <span class="org-variable-name">queries</span>, <span class="org-type">int</span> <span class="org-variable-name">x</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#32479;&#35745;&#26377;&#22810;&#23569;&#20010;x, &#32479;&#35745;&#31532;i&#20010;&#20803;&#32032;&#25968;&#20986;&#29616;&#27425;&#25968;&#65292;&#24182;&#23558;&#20854;&#20301;&#32622;&#39044;&#20808;&#23384;&#22312;&#25968;&#32452;&#20013;
</span>        <span class="org-type">int</span> <span class="org-variable-name">cnt</span> = 0;
        <span class="org-type">int</span> <span class="org-variable-name">pos</span>[100001]; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20301;&#32622;&#25968;&#32452;
</span>        memset(<span class="org-type">pos</span>, -1, <span class="org-keyword">sizeof</span>(<span class="org-type">pos</span>));
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; nums.size(); ++i) {
            <span class="org-keyword">if</span>(nums[i] == x) {
                pos[++cnt] = i; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23384;&#20648;&#20986;&#29616;&#27425;&#25968;&#23545;&#24212;&#30340;&#19979;&#26631;
</span>            }
        }
        <span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">ans</span>;
        <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; queries.size(); ++i) {
            ans.push_back(<span class="org-type">pos</span>[ queries[i] ]);
        }
        <span class="org-keyword">return</span> ans;
    }
};
</pre>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="outline-container-h:cb95ecd6-42dc-4744-bc00-d146b99b526d" class="outline-2">
<h2 id="h:cb95ecd6-42dc-4744-bc00-d146b99b526d"><a href="#h:cb95ecd6-42dc-4744-bc00-d146b99b526d">蓝桥杯学习路线</a></h2>
<div class="outline-text-2" id="text-h:cb95ecd6-42dc-4744-bc00-d146b99b526d">
<ul class="org-ul">
<li>程序 = 数据结构+算法</li>
<li>常见的数据结构：线性表+树+图，其他的都是这三者的衍生</li>
</ul>

<p>
其实任何一种数据结构就是一个容器，对这个容器执行增删改查的过程就是算法。
算法的本质就是想办法把增删改查的过程变得更加高效。要么空间换时间，要么时间换空间。
所以除了一些基于数学的算法，大部分的算法都是依附于数据结构的，两者是相辅相成的。
没有数据结构的基础，算法会难上一个台阶。在学习数据结构过程中是在为算法打基础的过程。
</p>

<p>
蓝桥杯学习路线
入门篇（大学C组）
</p>
<ul class="org-ul">
<li>基础数据结构和相关算法
<ol class="org-ol">
<li>线性表
<ul class="org-ul">
<li>存储结构
<ul class="org-ul">
<li>顺序表</li>
<li>单向链表</li>
</ul></li>
<li>逻辑结构
<ul class="org-ul">
<li>栈   深度优先搜索的基础</li>
<li>队列 广度优先搜索的基础</li>
<li>栈 &amp;&amp; 队列</li>
</ul></li>
<li>串 特殊的顺序表，全称为字符串</li>
<li>排序入门 O(n^2)
<ul class="org-ul">
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
</ul></li>
<li>枚举 把所有的情况都例举出来</li>
<li>高精度
<ul class="org-ul">
<li>在计算中很多数据存储时，如整数有上限是2^31-1，如何表示更大的整数? 可以用一个数组或者说字符串来表示数字的每一位，然后把它存在一个数组中，再去进行计算。</li>
<li>精度表示数是多少位，高精度是说这个数的位数非常高。</li>
</ul></li>
</ul></li>
<li>树
<ul class="org-ul">
<li>树</li>
<li>二叉树
<ul class="org-ul">
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层序遍历</li>
</ul></li>
<li>二叉搜索树</li>
<li>二分查找</li>
</ul></li>
<li>图
<ul class="org-ul">
<li>图的存储
<ul class="org-ul">
<li>邻接矩阵</li>
<li>邻接表</li>
</ul></li>
<li>基础搜索
<ul class="org-ul">
<li>深度优先搜索 dfs</li>
<li>广度优先搜索 bfs</li>
</ul></li>
<li>基础动态规划  就是给定一个数组，数组相关的简单的用一维能解决的动态规划</li>
</ul></li>
<li>哈希表 O(1)</li>
</ol></li>
<li>入门数学
<ol class="org-ol">
<li>四则运算</li>
<li>自然数</li>
<li>实复数</li>
<li>公式  一些等差数列求和、等比数列求和</li>
<li>数列</li>
<li>找规律</li>
<li>阶乘</li>
<li>幂</li>
<li>对数</li>
<li>坐标系</li>
<li>解析几何</li>
</ol></li>
<li>其它算法
<ol class="org-ol">
<li>贪心   局部的最优解它是全局的最优解</li>
<li>模拟  按照题目要求去做</li>
</ol></li>
</ul>

<p>
进阶篇（大学B组）
</p>
<ul class="org-ul">
<li>进阶数据结构和相关算法
<ol class="org-ol">
<li>线性表
<ul class="org-ul">
<li>双向链表</li>
<li>单调栈  单调递增或单调递减</li>
<li>单调队列</li>
<li>排序进阶
<ul class="org-ul">
<li>归并排序 给定两个数组变成一个数组</li>
<li>快速排序</li>
<li>计数排序</li>
<li>桶排序</li>
<li>堆排序  是选择排序的进阶</li>
<li>基数排序 应用在后缀数组中</li>
</ul></li>
<li>字符串匹配
<ul class="org-ul">
<li>KMP 应用很少，记5遍以上</li>
<li>字符串哈希（滚动哈希） 其实是高精度取模把字符串映射到int64里</li>
<li>manacher（马拉车） 解决回文串问题</li>
</ul></li>
</ul></li>
<li>树
<ul class="org-ul">
<li>堆  是一颗完全二叉树，根节点的值一定比左右子树或者孩子的值大或者小的</li>
<li>树状数组 解决单点更新、成段求和</li>
<li>线段树 解决一些区间问题</li>
<li>字典树 解决前缀匹配问题</li>
<li>并查集 解决集合问题</li>
<li>平衡树（能够使用系统提供的有序集合）</li>
</ul></li>
<li>图
<ul class="org-ul">
<li>进阶搜索
<ul class="org-ul">
<li>剪枝</li>
<li>双向广搜</li>
<li>记忆化搜索  实际上是动态规划的过程</li>
<li>迭代加深</li>
<li>启发式搜索</li>
</ul></li>
<li>进阶动态规划
<ul class="org-ul">
<li>0/1 背包</li>
<li>完全背包</li>
<li>多重背包</li>
<li>分组背包</li>
<li>树形DP 是依赖背包的一种分形，在树上进行动态规划</li>
<li>ST表  解决RMQ问题的，稀疏表</li>
<li>数位DP 学习一到二周</li>
<li>区间DP</li>
<li>状压DP</li>
<li>斜率优化DP</li>
<li>数据结构优化（单调栈/单调队列/树状数组/线段树）</li>
</ul></li>
<li>经典图算法
<ul class="org-ul">
<li>拓扑排序</li>
<li>最小生成树
<ul class="org-ul">
<li>prim 是贪心的思路</li>
<li>Kruscal 是并查集的思路</li>
</ul></li>
<li>最短路
<ul class="org-ul">
<li>Dijkstra</li>
<li>Bellman-Ford</li>
<li>Floyd</li>
<li>SPFA</li>
<li>Dijkstra + Heap</li>
</ul></li>
<li>差分约束系统</li>
<li>欧拉回路 一体化问题</li>
<li>二分图最大匹配</li>
<li>强连通分量</li>
<li>双连通分量（割边、割点）</li>
<li>DFS序</li>
<li>最近公公祖先</li>
</ul></li>
</ul></li>
</ol></li>
<li>进阶数学
<ol class="org-ol">
<li>排列组合</li>
<li>二项式定理</li>
<li>容斥原理</li>
<li>鸽巢原理</li>
<li>矩阵运算</li>
<li>初等数论
<ul class="org-ul">
<li>素数</li>
<li>素数筛选</li>
<li>因式分解</li>
<li>gcd</li>
<li>lcm</li>
<li>模</li>
<li>二分快速幂</li>
<li>线性同余</li>
<li>逆元</li>
</ul></li>
<li>高斯消元</li>
<li>计算几何
<ul class="org-ul">
<li>叉乘</li>
<li>线段判交</li>
<li>凸包</li>
<li>点在多边形内</li>
<li>半平面交</li>
<li>模拟退火</li>
</ul></li>
</ol></li>
</ul>

<p>
骨灰篇（研究生及大学A组）
</p>
<ul class="org-ul">
<li>骨灰数据结构和相关算法
<ol class="org-ol">
<li>线性表
<ul class="org-ul">
<li>字符串
<ul class="org-ul">
<li>AC自动机 每个学习二到三周</li>
<li>扩展KMP</li>
<li>后缀数组</li>
<li>后缀自动机</li>
<li>回文自动机</li>
</ul></li>
</ul></li>
<li>树
<ul class="org-ul">
<li>树链剖分</li>
<li>二维线段树</li>
<li>二维/三维树状数组</li>
<li>平衡树实现</li>
<li>可持久化数据结构（主席树）</li>
<li>树套树</li>
<li>动态树</li>
</ul></li>
<li>图
<ul class="org-ul">
<li>网络流
<ul class="org-ul">
<li>Edmond-Karp</li>
<li>Dinic</li>
<li>ISAP</li>
<li>HLPP</li>
</ul></li>
<li>一般图匹配</li>
</ul></li>
</ol></li>
<li>骨灰数学
<ol class="org-ol">
<li>初等数论
<ul class="org-ul">
<li>欧拉函数</li>
<li>欧拉定理</li>
<li>中国剩余定理</li>
<li>同余方程</li>
</ul></li>
<li>生成函数</li>
<li>莫比乌斯反演</li>
<li>快速傅立叶变换</li>
</ol></li>
</ul>


<p>
刷题：<a href="https://www.lanqiao.cn/problems/?first_category_id=1">蓝桥云课</a>
</p>
</div>
</section>
</div>
<div id="postamble" class="status">
    <div class=bar data-astro-cid-p3givckg>
        <div class=list data-astro-cid-p3givckg>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=simple-icons:gnuemacs height=1em viewBox="0 0 24 24" width=1em>
                    <title>emacs</title>
                    <symbol id=ai:simple-icons:gnuemacs>
                        <path d="M12 24C5.448 24 .118 18.617.118 12S5.448 0 12 0s11.882 5.383 11.882 12S18.552 24 12 24zM12 .661C5.813.661.779 5.748.779 12S5.813 23.339 12 23.339S23.221 18.253 23.221 12S18.187.661 12 .661zM8.03 20.197s.978.069 2.236-.042c.51-.045 2.444-.235 3.891-.552c0 0 1.764-.377 2.707-.725c.987-.364 1.524-.673 1.766-1.11c-.011-.09.074-.408-.381-.599c-1.164-.488-2.514-.4-5.185-.457c-2.962-.102-3.948-.598-4.472-.997c-.503-.405-.25-1.526 1.907-2.513c1.086-.526 5.345-1.496 5.345-1.496c-1.434-.709-4.109-1.955-4.659-2.224c-.482-.236-1.254-.591-1.421-1.021c-.19-.413.448-.768.804-.87c1.147-.331 2.766-.536 4.24-.56c.741-.012.861-.059.861-.059c1.022-.17 1.695-.869 1.414-1.976c-.252-1.13-1.579-1.795-2.84-1.565c-1.188.217-4.05 1.048-4.05 1.048c3.539-.031 4.131.028 4.395.398c.156.218-.071.518-1.015.672c-1.027.168-3.163.37-3.163.37c-2.049.122-3.492.13-3.925 1.046c-.283.599.302 1.129.558 1.46c1.082 1.204 2.646 1.853 3.652 2.331c.379.18 1.49.52 1.49.52c-3.265-.18-5.619.823-7.001 1.977c-1.562 1.445-.871 3.168 2.33 4.228c1.891.626 2.828.921 5.648.667c1.661-.09 1.923-.036 1.939.1c.023.192-1.845.669-2.355.816c-1.298.374-4.699 1.129-4.716 1.133z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:simple-icons:gnuemacs></use>
                </svg>
                <div class="content left" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Emacs</p>
                </div>
            </span>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=simple-icons:org height=1em viewBox="0 0 24 24" width=1em>
                    <title>org-mode</title>
                    <symbol id=ai:simple-icons:org>
                        <path d="M17.169 0c-.566.004-2.16 3.312-3.376 5.94a2.19 2.19 0 0 1-.408-1.267c-.03-.582-1.089.237-.936 1.275c-.068-.035-1.26.227-1.26.23c-.23-.93-.802-1.618-1.15-.563c-.701 1.663-.88 2.984.115 4.585c-.908 4.058-6.948 6.053-6.32 9.33c.175.004 1.634 3.48 6.337 2.057c5.557-1.577 8.624 2.116 8.978 2.375c.52.526-1.348-4.573-5.302-6.865c-2.339-1.276-.87-3.474-.703-4.25c0 0 1.874 1.312 3.232-.692c1.227.316 2.05-.224 3.105.158c.64.28 3.336.11 2.334-1.396c-.148.129.07.27-.075.46c-.043.056-.128.232-.408.315c-.314.149-.83.27-1.43-.37c-.434-.32-.748-.04-.992-.063c.152-.098.577-.315 1.264-.315c.388 0 .594.336.854.338c.174 0 .685-.262.787-.365c.63-.41.697-.278 1.012-.905c.17-.759-.215-.92-.332-1.129c-.032-.483-.436-.67-.919-.326c-1.106-.198-2.192-.105-2.728-.15c-1.175-.164-2.153-.786-2.153-.786c.143-.19.075-.6-.842-.628c-.315-.104-.45-.2-.745-.307c.61-1.37.674-2.007 1.418-4.004c.261-1.053 1.039-2.685.643-2.682zm-4.297 8.093c.03-.086.443.138.952.176c.395.03.805.048 1.296-.025c.03-.005.172.095-.15.194c-.02.01-.062-.01-.065.196c0 .022-.01.04-.02.046c-.15.152-.708.223-1.065.1c-.436-.17-.482-.316-.517-.443c-.305-.147-.47-.123-.43-.244zM9.685 10.2C8.86 9 8.929 8.36 8.96 7.256C7.961 8.288 6.855 8.3 5.18 8.58c-1.299.234-3.657 2.447-4.025 4.742c-.043.608-.08 2.183.424 3.498c.492 1.13.828 1.727 1.844 2.335c-.882-3.169 5.296-5.33 6.263-8.955z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:simple-icons:org></use>
                </svg>
                <div class="content left" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Orgmode</p>
                </div>
            </span>
            <a href=/donations.html class=entry data-astro-cid-p3givckg>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=simple-icons:astro height=1em viewBox="0 0 24 24" width=1em>
                    <title>Donations</title>
                    <symbol id=ai:simple-icons:astro>
                        <path d="M8.358 20.162c-1.186-1.07-1.532-3.316-1.038-4.944c.856 1.026 2.043 1.352 3.272 1.535c1.897.283 3.76.177 5.522-.678c.202-.098.388-.229.608-.36c.166.473.209.95.151 1.437c-.14 1.185-.738 2.1-1.688 2.794c-.38.277-.782.525-1.175.787c-1.205.804-1.531 1.747-1.078 3.119l.044.148a3.158 3.158 0 0 1-1.407-1.188a3.31 3.31 0 0 1-.544-1.815c-.004-.32-.004-.642-.048-.958c-.106-.769-.472-1.113-1.161-1.133c-.707-.02-1.267.411-1.415 1.09c-.012.053-.028.104-.045.165h.002zm-5.961-4.445s3.24-1.575 6.49-1.575l2.451-7.565c.092-.366.36-.614.662-.614c.302 0 .57.248.662.614l2.45 7.565c3.85 0 6.491 1.575 6.491 1.575L16.088.727C15.93.285 15.663 0 15.303 0H8.697c-.36 0-.615.285-.784.727l-5.516 14.99z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:simple-icons:astro></use>
                </svg>
                <div class="content left" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>打赏</p>
                </div>
            </span>
            </a>
            <span class=entry data-astro-cid-p3givckg>
                <svg xmlns="http://www.w3.org/2000/svg" class=heading data-astro-cid-p3givckg data-icon=simple-icons:copyright width="1em" height="1em" viewBox="0 0 24 24">
                    <title>Copyright</title>
                    <path fill="currentColor" d="M19 2a3 3 0 0 1 3 3v14a3 3 0 0 1-3 3H5a3 3 0 0 1-3-3V5a3 3 0 0 1 3-3zm-5 5h-4a1 1 0 0 0-1 1l.007.117A1 1 0 0 0 10 9h3v5a1 1 0 0 1-1.993.117L11 14a1 1 0 0 0-2 0a3 3 0 0 0 6 0V8a1 1 0 0 0-1-1" />
                    <use xlink:href=#ai:simple-icons:copyright></use>
                </svg>
                <div class="content left" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>© 2025 Jasper Hsu</p>
                </div>
            </span>
        </div>
        <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ class="list license" data-astro-cid-p3givckg>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=fa6-brands:creative-commons height=1em viewBox="0 0 496 512" width=0.97em>
                    <title>Creative Commons</title>
                    <symbol id=ai:fa6-brands:creative-commons>
                        <path d="m245.83 214.87l-33.22 17.28c-9.43-19.58-25.24-19.93-27.46-19.93c-22.13 0-33.22 14.61-33.22 43.84c0 23.57 9.21 43.84 33.22 43.84c14.47 0 24.65-7.09 30.57-21.26l30.55 15.5c-6.17 11.51-25.69 38.98-65.1 38.98c-22.6 0-73.96-10.32-73.96-77.05c0-58.69 43-77.06 72.63-77.06c30.72-.01 52.7 11.95 65.99 35.86zm143.05 0l-32.78 17.28c-9.5-19.77-25.72-19.93-27.9-19.93c-22.14 0-33.22 14.61-33.22 43.84c0 23.55 9.23 43.84 33.22 43.84c14.45 0 24.65-7.09 30.54-21.26l31 15.5c-2.1 3.75-21.39 38.98-65.09 38.98c-22.69 0-73.96-9.87-73.96-77.05c0-58.67 42.97-77.06 72.63-77.06c30.71-.01 52.58 11.95 65.56 35.86zM247.56 8.05C104.74 8.05 0 123.11 0 256.05c0 138.49 113.6 248 247.56 248c129.93 0 248.44-100.87 248.44-248c0-137.87-106.62-248-248.44-248zm.87 450.81c-112.54 0-203.7-93.04-203.7-202.81c0-105.42 85.43-203.27 203.72-203.27c112.53 0 202.82 89.46 202.82 203.26c-.01 121.69-99.68 202.82-202.84 202.82z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:fa6-brands:creative-commons></use>
                </svg>
                <div class="content right" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Creative Commons</p>
                </div>
            </span>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=fa6-brands:creative-commons-by height=1em viewBox="0 0 496 512" width=0.97em>
                    <title>Attribute</title>
                    <symbol id=ai:fa6-brands:creative-commons-by>
                        <path d="M314.9 194.4v101.4h-28.3v120.5h-77.1V295.9h-28.3V194.4c0-4.4 1.6-8.2 4.6-11.3c3.1-3.1 6.9-4.7 11.3-4.7H299c4.1 0 7.8 1.6 11.1 4.7c3.1 3.2 4.8 6.9 4.8 11.3zm-101.5-63.7c0-23.3 11.5-35 34.5-35s34.5 11.7 34.5 35c0 23-11.5 34.5-34.5 34.5s-34.5-11.5-34.5-34.5zM247.6 8C389.4 8 496 118.1 496 256c0 147.1-118.5 248-248.4 248C113.6 504 0 394.5 0 256C0 123.1 104.7 8 247.6 8zm.8 44.7C130.2 52.7 44.7 150.6 44.7 256c0 109.8 91.2 202.8 203.7 202.8c103.2 0 202.8-81.1 202.8-202.8c.1-113.8-90.2-203.3-202.8-203.3z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:fa6-brands:creative-commons-by></use>
                </svg>
                <div class="content right" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Attribute</p>
                </div>
            </span>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=fa6-brands:creative-commons-nc height=1em viewBox="0 0 496 512" width=0.97em>
                    <title>Noncommercial</title>
                    <symbol id=ai:fa6-brands:creative-commons-nc>
                        <path d="M247.6 8C387.4 8 496 115.9 496 256c0 147.2-118.5 248-248.4 248C113.1 504 0 393.2 0 256C0 123.1 104.7 8 247.6 8zM55.8 189.1c-7.4 20.4-11.1 42.7-11.1 66.9c0 110.9 92.1 202.4 203.7 202.4c122.4 0 177.2-101.8 178.5-104.1l-93.4-41.6c-7.7 37.1-41.2 53-68.2 55.4v38.1h-28.8V368c-27.5-.3-52.6-10.2-75.3-29.7l34.1-34.5c31.7 29.4 86.4 31.8 86.4-2.2c0-6.2-2.2-11.2-6.6-15.1c-14.2-6-1.8-.1-219.3-97.4zM248.4 52.3c-38.4 0-112.4 8.7-170.5 93l94.8 42.5c10-31.3 40.4-42.9 63.8-44.3v-38.1h28.8v38.1c22.7 1.2 43.4 8.9 62 23L295 199.7c-42.7-29.9-83.5-8-70 11.1c53.4 24.1 43.8 19.8 93 41.6l127.1 56.7c4.1-17.4 6.2-35.1 6.2-53.1c0-57-19.8-105-59.3-143.9c-39.3-39.9-87.2-59.8-143.6-59.8z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:fa6-brands:creative-commons-nc></use>
                </svg>
                <div class="content right" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Noncommercial</p>
                </div>
            </span>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=fa6-brands:creative-commons-sa height=1em viewBox="0 0 496 512" width=0.97em>
                    <title>Share Alike</title>
                    <symbol id=ai:fa6-brands:creative-commons-sa>
                        <path d="M247.6 8C389.4 8 496 118.1 496 256c0 147.1-118.5 248-248.4 248C113.6 504 0 394.5 0 256C0 123.1 104.7 8 247.6 8zm.8 44.7C130.2 52.7 44.7 150.6 44.7 256c0 109.8 91.2 202.8 203.7 202.8c103.2 0 202.8-81.1 202.8-202.8c.1-113.8-90.2-203.3-202.8-203.3zM137.7 221c13-83.9 80.5-95.7 108.9-95.7c99.8 0 127.5 82.5 127.5 134.2c0 63.6-41 132.9-128.9 132.9c-38.9 0-99.1-20-109.4-97h62.5c1.5 30.1 19.6 45.2 54.5 45.2c23.3 0 58-18.2 58-82.8c0-82.5-49.1-80.6-56.7-80.6c-33.1 0-51.7 14.6-55.8 43.8h18.2l-49.2 49.2l-49-49.2h19.4z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:fa6-brands:creative-commons-sa></use>
                </svg>
                <div class="content right" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Share Alike</p>
                </div>
            </span>
        </a>
    </div>
<!--
<script type="text/javascript" src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script type="text/javascript" src="https://unpkg.com/@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
<script type="text/javascript" src="https://unpkg.com/bootstrap@5.2.1/dist/js/bootstrap.min.js"></script>
<div id="back-to-top" class=""><svg viewBox="0 0 24 24"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path></svg></div>
-->
</div>
</body>
</html>
