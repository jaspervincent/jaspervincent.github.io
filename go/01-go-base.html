<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>GO: GO语言基础知识</title>
<meta name="description" content="Go语言基础知识" />
<meta name="keywords" content="计算机, 编程, GO" />
<meta name="generator" content="Org Mode" />
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="me" href="https://emacs.ch/@jasperhsu">
<meta name="google-adsense-account" content="ca-pub-1741779893655624">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1741779893655624" crossorigin="anonymous"></script>
<!-- from -->
<!--
<style>#back-to-top{background:#000;-webkit-border-radius:50%;-moz-border-radius:50%;border-radius:50%;bottom:20px;-webkit-box-shadow:0 2px 5px 0 rgba(0,0,0,.26);-moz-box-shadow:0 2px 5px 0 rgba(0,0,0,.26);box-shadow:0 2px 5px 0 rgba(0,0,0,.26);color:#fff;cursor:pointer;display:block;height:56px;opacity:1;outline:0;position:fixed;right:20px;-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none;-webkit-transition:bottom .2s,opacity .2s;-o-transition:bottom .2s,opacity .2s;-moz-transition:bottom .2s,opacity .2s;transition:bottom .2s,opacity .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:56px;z-index:1}#back-to-top svg{display:block;fill:currentColor;height:24px;margin:16px auto 0;width:24px}#back-to-top.hidden{bottom:-56px;opacity:0}</style>
-->
<link rel="stylesheet" href="/static/aandds.com/css/main.css">
<link rel="stylesheet" href="/static/aandds.com/css/drollery.min.css">
<script type="text/javascript" src="/static/aandds.com/js/main.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">GO: GO语言基础知识</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org4535df9">基础4大件</a>
<ul>
<li><a href="#org173adc1">语言本身学习</a></li>
<li><a href="#orgdb0dbb5">基础4大件</a></li>
<li><a href="#orgf281a39">应用与编程实践</a></li>
<li><a href="#org2ef0411">linux环境编程</a></li>
</ul>
</li>
<li><a href="#org9ffd088">环境安装</a>
<ul>
<li><a href="#orgde73c86">go语言安装</a></li>
<li><a href="#org7b15b9a">ide工具</a>
<ul>
<li><a href="#org9eb50b2">goland</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgda2754b">基础语法</a>
<ul>
<li><a href="#org00d0ec8">变量、常量、类型</a>
<ul>
<li><a href="#org4681582">变量定义</a></li>
<li><a href="#org1c66281">内建变量类型</a>
<ul>
<li><a href="#org2928b2d">验证欧拉公式</a></li>
<li><a href="#org93ec7a0">强制类型转换</a></li>
</ul>
</li>
<li><a href="#orga65882b">常量和枚举</a>
<ul>
<li><a href="#org2cdc3c0">常量定义</a></li>
<li><a href="#org6804d96">使用常量定义枚举类型</a></li>
<li><a href="#orgda1f781">范例</a></li>
</ul>
</li>
<li><a href="#orga3d5952">变量定义要点</a></li>
</ul>
</li>
<li><a href="#org7f3050e">流程控制</a>
<ul>
<li><a href="#org0c5f472">条件语句-if-switch</a>
<ul>
<li><a href="#org04e1b8a">选择结构if</a></li>
<li><a href="#orgbe3a582">switch</a></li>
</ul>
</li>
<li><a href="#orgd5e989e">循环语句-for-range</a>
<ul>
<li><a href="#org1fdd0a0">for</a></li>
<li><a href="#org36b5f43">range</a></li>
</ul>
</li>
<li><a href="#org81f0d54">基本语法要点回顾</a></li>
</ul>
</li>
<li><a href="#org318da25">函数</a>
<ul>
<li><a href="#org157d454">函数定义</a></li>
<li><a href="#org7b07e65">有参数</a></li>
<li><a href="#orga568d8e">函数可返回多个值</a>
<ul>
<li><a href="#org1a8225f">返回值起名字</a></li>
<li><a href="#orge4491a9">忽略某返回值</a></li>
<li><a href="#orgf4a68c2">多返回值使用场景</a></li>
</ul>
</li>
<li><a href="#org60d93d5">函数作为函数参数</a></li>
<li><a href="#orgf142b84">可变参数列表</a></li>
<li><a href="#org071839f">函数语法要点回顾</a></li>
</ul>
</li>
<li><a href="#org03d974a">指针</a>
<ul>
<li><a href="#org91e87c1">参数传递</a>
<ul>
<li><a href="#org704b3fc">go语言使用值传递？引用传递？</a></li>
<li><a href="#orgd26e90c">值传递-普通变量做函数参数</a></li>
<li><a href="#orge4d90aa">引用传递-指针做函数参数</a></li>
<li><a href="#org40936e0">对象-传递</a></li>
</ul>
</li>
<li><a href="#org54edbbd">范例：交换2个变量的值</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8260e70">内建容器</a>
<ul>
<li><a href="#org995d92c">数组</a>
<ul>
<li><a href="#org90500b0">遍历数组-for-range</a>
<ul>
<li><a href="#orgcabc8d4">for</a></li>
<li><a href="#org5a7467d">range</a></li>
<li><a href="#org57d24fd">为什么要用range</a></li>
</ul>
</li>
<li><a href="#orgecd30e3">数组是值类型</a></li>
</ul>
</li>
<li><a href="#org2c18f4d">Slice 切片</a>
<ul>
<li><a href="#orga47594e">范例：验证slice是对数组的view视图</a></li>
<li><a href="#org72a6bc7">reslice切片再切片</a></li>
<li><a href="#orgc87a1d5">Slice的扩展</a>
<ul>
<li><a href="#org41983c7">Slice的实现</a></li>
</ul>
</li>
<li><a href="#org0e512d5">向Slice添加元素</a></li>
<li><a href="#org050ecc8">slice的其它操作</a>
<ul>
<li><a href="#org1e30f80">创建slice</a></li>
<li><a href="#org8aa8d38">内建copy函数</a></li>
<li><a href="#orgc7cb16b">切片元素删除</a></li>
<li><a href="#org3f38ea5">切片去重</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org369d76d">map</a>
<ul>
<li><a href="#org7093988">map定义</a></li>
<li><a href="#orgad72f11">map的操作</a></li>
<li><a href="#org9fd0197">map的遍历</a></li>
<li><a href="#org439b052">map的key</a></li>
<li><a href="#org626c531">范例：寻找最长不含有重复字符的子串长度(leetcode)</a></li>
</ul>
</li>
<li><a href="#org504e575">字符串</a>
<ul>
<li><a href="#orgc8c15bc">rune相当于go的char</a>
<ul>
<li><a href="#org70cbb1a">如何利用rune</a></li>
</ul>
</li>
<li><a href="#orge58698e">其他字符操作</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge46ca2f">面向对象</a>
<ul>
<li><a href="#orge2842e0">结构体和方法</a>
<ul>
<li><a href="#orgc66dc24">结构的定义</a></li>
<li><a href="#org24dd58b">结构体的创建</a></li>
<li><a href="#orgaa3e3d5">结构创建在堆上还是栈上？</a></li>
<li><a href="#orge318e57">为结构定义方法</a>
<ul>
<li><a href="#orge48a3c8">使用指针作为方法的接收者</a></li>
</ul>
</li>
<li><a href="#org6d63011">值接收者 vs 指针接收者的选择</a></li>
</ul>
</li>
<li><a href="#orgba1e322">包和封装</a>
<ul>
<li><a href="#orgc1872ac">封装</a></li>
<li><a href="#org73cea0c">包</a></li>
</ul>
</li>
<li><a href="#orgf95e889">扩展已有类型</a>
<ul>
<li><a href="#orge6b10df">定义别名</a></li>
<li><a href="#orgc0c2787">使用组合</a></li>
<li><a href="#orge21b9d1">使用内嵌来扩展已有类型</a></li>
<li><a href="#org28e03a9">小结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb3ec00d">项目管理</a>
<ul>
<li><a href="#org3c5e50c">依赖管理</a></li>
<li><a href="#org33a35a3">GOPATH和GOVENDOR</a>
<ul>
<li><a href="#org9612985">GOPATH</a></li>
<li><a href="#org852c000">GOVENDOR</a></li>
</ul>
</li>
<li><a href="#orgd7cbf79">go mod的使用</a></li>
<li><a href="#org9a27a66">目录的整理</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<ul class="org-ul">
<li>TAGS: <a href="./index.html">GO</a></li>
</ul>
<section id="outline-container-org4535df9" class="outline-2">
<h2 id="org4535df9">基础4大件</h2>
<div class="outline-text-2" id="text-org4535df9">
<p>
比语言本身重要
</p>
<ul class="org-ul">
<li>数据结构和算法
数据结构：字符串、链表、二叉树、堆、栈、队列、哈希
算法：查找、排序、动态规划
刷leetcode题目
<ul class="org-ul">
<li>书籍
c/c++ 《大话数据结构》 java 《算法》
找工作 《剑指offer》</li>
</ul></li>
<li>计算机网络
tcp/ip协议栈
<ul class="org-ul">
<li>书籍
《TCP/IP详解》</li>
</ul></li>
<li>操作系统
进程、内存
<ul class="org-ul">
<li>书籍
《深入理解操作系统》</li>
</ul></li>
<li>设计模式
<ul class="org-ul">
<li>23种设计模式
单例、工厂、代理、策略模式、模板方法</li>
<li>书籍
《大话设计模式》</li>
</ul></li>
</ul>

<p>
c/c++学习路线参考：
造轮子语言，特点：性能好、粒度细、偏底层
后台开发比较多
</p>
</div>
<div id="outline-container-org173adc1" class="outline-3">
<h3 id="org173adc1">语言本身学习</h3>
<div class="outline-text-3" id="text-org173adc1">
<ul class="org-ul">
<li>c语言基础，最重要的指针和内存管理
书籍
<ul class="org-ul">
<li>《C Primer Plus》</li>
<li>进阶《C和指针》、《C专家编程》</li>
</ul></li>
<li>c++ 对c的扩充
面向对象特性、泛型、模板</li>
</ul>
</div>
</div>
<div id="outline-container-orgdb0dbb5" class="outline-3">
<h3 id="orgdb0dbb5">基础4大件</h3>
<div class="outline-text-3" id="text-orgdb0dbb5">
<p>
数据结构和算、计算机网络、操作系统、设计模式
</p>
</div>
</div>
<div id="outline-container-orgf281a39" class="outline-3">
<h3 id="orgf281a39">应用与编程实践</h3>
<div class="outline-text-3" id="text-orgf281a39">
<p>
涉及到工具、编程环境、具体的编程实践
</p>
<ul class="org-ul">
<li>linux操作系统学习
书籍：《鸟哥linux私房菜》 《linux就该这么学》</li>
<li><p>
编译和调试工具
编译：
</p>
<ul class="org-ul">
<li>编译工具：gcc</li>
<li>编译动作make: makefile会写</li>
</ul>
<p>
调试：
</p>
<ul class="org-ul">
<li>调试工具：gdb</li>
</ul>
<p>
书籍：
</p>
<ul class="org-ul">
<li>官方gcc文档</li>
<li>《debugging with gdb》中文版</li>
<li>《跟我一起写makefile》 陈皓</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org2ef0411" class="outline-3">
<h3 id="org2ef0411">linux环境编程</h3>
<div class="outline-text-3" id="text-org2ef0411">
<ul class="org-ul">
<li>linux系统编程</li>
<li>多线程编程</li>
<li>网络编程</li>
</ul>
<p>
书籍：《Uninx环境高级编程》、《Linux高性能服务器编程》、《POSIX多线程程序设计》
</p>
</div>
</div>
</section>
<section id="outline-container-org9ffd088" class="outline-2">
<h2 id="org9ffd088">环境安装</h2>
<div class="outline-text-2" id="text-org9ffd088">
</div>
<div id="outline-container-orgde73c86" class="outline-3">
<h3 id="orgde73c86">go语言安装</h3>
<div class="outline-text-3" id="text-orgde73c86">
<ul class="org-ul">
<li>官网：<a href="https://go.dev/">https://go.dev/</a></li>
<li>国内下载：<a href="https://studygolang.com/dl">https://studygolang.com/dl</a></li>
<li><p>
国内镜像：<a href="https://goproxy.cn">https://goproxy.cn</a>
go 1.13以上
</p>
<div class="org-src-container">
<pre class="src src-sh">go env -w <span style="color: #a0522d;">GO111MODULE</span>=on
go env -w <span style="color: #a0522d;">GOPROXY</span>=https://goproxy.cn,direct
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org7b15b9a" class="outline-3">
<h3 id="org7b15b9a">ide工具</h3>
<div class="outline-text-3" id="text-org7b15b9a">
<ul class="org-ul">
<li>goland/Intellij Idea+go插件</li>
<li>vscode</li>
</ul>
</div>
<div id="outline-container-org9eb50b2" class="outline-4">
<h4 id="org9eb50b2">goland</h4>
<div class="outline-text-4" id="text-org9eb50b2">
<p>
最新版
</p>
<ul class="org-ul">
<li>go mod的配置
新建项目
<ul class="org-ul">
<li>选"Go Modules(vgo)"</li>
</ul></li>
</ul>
<div class="org-src-container">
<pre class="src src-sh">Location src/learngo
GOROOT &#23433;&#35013;&#20301;&#32622;
Proxy https://goproxy.cn,direct
</pre>
</div>
<ul class="org-ul">
<li>File Watcher和goimports的配置
插件：安装File Watche
tools：选择 File Watcher点击“+”添加goimports，直接保存就好
这样保存文件时就会自动格式化文件</li>
<li>运行方式配置
一个包只包含一个main函数
如果运行不了，可以选择单文件运行，选择右上角三角“edit configrations” &#x2013; “run kind”改成file</li>
<li><p>
快捷键
配置成一样可以在多个 ide工具中使用
preferences&#x2013;keymap搜索
</p>
<div class="org-src-container">
<pre class="src src-sh">&#21024;&#38500;&#19968;&#34892; Delete line
&#22238;&#36864; Navigate Back
&#21069;&#36827; Navigate forward
&#36339;&#36716;&#21040;&#23450;&#20041; Navigate Declaration
</pre>
</div></li>
</ul>
</div>
</div>
</div>
</section>
<section id="outline-container-orgda2754b" class="outline-2">
<h2 id="orgda2754b">基础语法</h2>
<div class="outline-text-2" id="text-orgda2754b">
<p>
25个关键字
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">用途</th>
<th scope="col" class="org-left">关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">程序声明</td>
<td class="org-left">import, package</td>
</tr>

<tr>
<td class="org-left">程序实体声明和定义</td>
<td class="org-left">chan, const, func, interface, map, struct, type, var</td>
</tr>

<tr>
<td class="org-left">程序流利控制</td>
<td class="org-left">go, select, break, case, continue, default, defer, else</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">fallthrough, for, goto, if, range, return, switch</td>
</tr>
</tbody>
</table>

<p>
30个预定义名字
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">用途</th>
<th scope="col" class="org-left">预定义名字</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">内建常量</td>
<td class="org-left">true, false, iota, nil</td>
</tr>

<tr>
<td class="org-left">内建类型</td>
<td class="org-left">(u)int, (u)int8, (u)int16, (u)int32, (u)int64, uintptr</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">byte, rune</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">float32, float64, complex64, complex128</td>
</tr>

<tr>
<td class="org-left">内建函数</td>
<td class="org-left">make, len, cap, new, append, copy, close, delete</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">complex, real, imag</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">panic, recover</td>
</tr>
</tbody>
</table>
</div>
<div id="outline-container-org00d0ec8" class="outline-3">
<h3 id="org00d0ec8">变量、常量、类型</h3>
<div class="outline-text-3" id="text-org00d0ec8">
</div>
<div id="outline-container-org4681582" class="outline-4">
<h4 id="org4681582">变量定义</h4>
<div class="outline-text-4" id="text-org4681582">
<p>
使用var关键字
</p>
<ul class="org-ul">
<li>`var a, b, c bool`</li>
<li>`var s1, s2 string = "hello", "world"`</li>
<li>可放在函数内，或直接放在包内</li>
<li>使用var()集中定义变量</li>
</ul>

<p>
让编译器自动决定类型
</p>
<ul class="org-ul">
<li>`var a, b, i, s1, s2 = true, false, 3, "hello", "world"`</li>
</ul>

<p>
使用 `:=` 定义变量
</p>
<ul class="org-ul">
<li>`a, b, i, s1, s2 := true, false, 3, "hello", "world"`</li>
<li>只能在函数内使用</li>
</ul>

<p>
范例：变量的定义
</p>
<div class="org-src-container">
<pre class="src src-sh">package main

<span style="color: #0000ff;">import</span> (
        <span style="color: #8b2252;">"fmt"</span>
)

//&#20989;&#25968;&#22806;&#23450;&#20041;&#21464;&#37327;
//&#22806;&#38754;&#23450;&#20041;&#26102;&#19981;&#29992; :=
//&#20316;&#29992;&#22495;&#65306;&#21253;&#20869;&#37096;&#30340;&#21464;&#37327;
// var <span style="color: #a0522d;">aa</span> = 33
// var <span style="color: #a0522d;">ss</span> = <span style="color: #8b2252;">"kkk"</span>
// var <span style="color: #a0522d;">bb</span> = true
<span style="color: #0000ff;">var</span> (
        <span style="color: #a0522d;">aa</span> = 33
        <span style="color: #a0522d;">ss</span> = <span style="color: #8b2252;">"kkk"</span>
        <span style="color: #a0522d;">bb</span> = true
)


func variableZeroValue() {
        var a int
        var s string
        fmt.Printf(<span style="color: #8b2252;">"%d, %q\n"</span>, a, s)
}

func variableInitialValue() {
        var a, b <span style="color: #a0522d;">int</span> = 3, 5
        var s <span style="color: #a0522d;">string</span> = <span style="color: #8b2252;">"abc"</span>
        fmt.Println(a, b, s)
}

func variableTypeDeduction() {
        // &#19981;&#35268;&#23450;&#31867;&#22411;&#21487;&#20197;&#20889;&#22312;&#19968;&#34892;&#33258;&#21160;&#21028;&#26029;
        var a, b, c, <span style="color: #a0522d;">s</span> = 3, 5, true, <span style="color: #8b2252;">"def"</span>
        fmt.Println(a, b, c, s)
}

func variableShorter() {
        //&#20351;&#29992; := &#25928;&#26524;&#21644;&#19978;&#38754;&#26159;&#19968;&#26679;&#30340;&#65292;&#26356;&#21152;&#31616;&#21333;&#12290;&#21482;&#22312;&#31532;&#19968;&#27425;&#20351;&#29992;&#26102;&#29992;:=
        a, b, c, s := 3, 5, true, <span style="color: #8b2252;">"def"</span>
        fmt.Println(a, b, c, s)
}

func main() {
        fmt.Println(<span style="color: #8b2252;">"hh"</span>)
        variableZeroValue()
        variableInitialValue()
        variableTypeDeduction()
        variableShorter()
        fmt.Println(aa,ss,bb)
}

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#25191;&#34892;
</span>PS D:\project\goproject\src\test&gt; go run main.go
hh
0, <span style="color: #8b2252;">""</span>
3 5 abc
3 5 true def
3 5 true def
33 kkk true
</pre>
</div>
</div>
</div>
<div id="outline-container-org1c66281" class="outline-4">
<h4 id="org1c66281">内建变量类型</h4>
<div class="outline-text-4" id="text-org1c66281">
<ul class="org-ul">
<li>bool, string</li>
<li>(u)int, (u)int8, (u)int16, (u)int32, (u)int64, uintptr
有u是无符号整数，没有u是有符号整数，uintptr 存储指针</li>
<li>byte, rune
1字节长度的byte坑比较多，多用rune 32位</li>
<li>float32, float64, complex64, complex128</li>
</ul>
</div>
<div id="outline-container-org2928b2d" class="outline-5">
<h5 id="org2928b2d">验证欧拉公式</h5>
<div class="outline-text-5" id="text-org2928b2d">
<p>
初中数学、高等数学
</p>
<div class="org-src-container">
<pre class="src src-sh">package main

<span style="color: #0000ff;">import</span> (
        <span style="color: #8b2252;">"fmt"</span>
        <span style="color: #8b2252;">"math"</span>
        <span style="color: #8b2252;">"math/cmplx"</span>
)

// func euler() {
//      c := 3 + 4i
//      fmt.Println(cmplx.Abs(c)) // 5
// }

func euler() {
        //fmt.Println(cmplx.Pow(math.E, 1i * math.Pi) + 1) //&#24213;&#25968;math.E&#65292;&#25351;&#25968;i * math.Pi &#32467;&#26524;(0+1.2246467991473515e-16i)
        fmt.Printf(<span style="color: #8b2252;">"%.f\n"</span>, cmplx.Exp( 1i * math.Pi) + 1) //(0+0i)
}

func main() {
        euler()
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org93ec7a0" class="outline-5">
<h5 id="org93ec7a0">强制类型转换</h5>
<div class="outline-text-5" id="text-org93ec7a0">
<ul class="org-ul">
<li>类型转换是强制的。如下面求三角形边长</li>
<li>`var a, b int = 3, 4`</li>
<li>`var c int = math.Sqrt(a*a + b*b)` 错</li>
<li>`var c int = int(math.Sqrt(float64(a*a + b*b)))`</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga65882b" class="outline-4">
<h4 id="orga65882b">常量和枚举</h4>
<div class="outline-text-4" id="text-orga65882b">
</div>
<div id="outline-container-org2cdc3c0" class="outline-5">
<h5 id="org2cdc3c0">常量定义</h5>
<div class="outline-text-5" id="text-org2cdc3c0">
<ul class="org-ul">
<li>`const filename = "abc.txt"`</li>
<li>const数值可作为各种类型使用</li>
<li>`const a, b = 3 4` 不写类型，即可当int也可当float使用</li>
<li>`var c int = int(math.Sqrt(a*a + b*b))`</li>
</ul>
</div>
</div>
<div id="outline-container-org6804d96" class="outline-5">
<h5 id="org6804d96">使用常量定义枚举类型</h5>
<div class="outline-text-5" id="text-org6804d96">
<ul class="org-ul">
<li>普通枚举类型</li>
<li>自增枚举类型</li>
</ul>
</div>
</div>
<div id="outline-container-orgda1f781" class="outline-5">
<h5 id="orgda1f781">范例</h5>
<div class="outline-text-5" id="text-orgda1f781">
<div class="org-src-container">
<pre class="src src-sh">package main

<span style="color: #0000ff;">import</span> (
        <span style="color: #8b2252;">"fmt"</span>
)

func consts() {
        const (
                <span style="color: #a0522d;">filename</span> = <span style="color: #8b2252;">"abc.txt"</span>
                a, <span style="color: #a0522d;">b</span>     = 3, 4 // &#21487;&#20197;&#26159;int&#25110;float
        )
        var c <span style="color: #a0522d;">int</span> = int(math.Sqrt(a*a + b*b))
        fmt.Println(filename, c) // abc.txt 5
}

func enums() {
        const (
                <span style="color: #a0522d;">cpp</span> = iota
                _   //&#33258;&#22686;
                python
                golang
                javascript
        )

        // iota&#21442;&#19982;&#36816;&#31639;
        const (
                <span style="color: #a0522d;">b</span> = 1 &lt;&lt; (10 * iota) //&#20301;&#31227;10*iota&#20301;
                kb
                mb
                gb
                tb
                pb
        )

        fmt.Println(cpp, javascript, python, golang) //0 4 2 3
        fmt.Println(b, kb, mb, gb, tb, pb) //1 1024 1048576 1073741824 1099511627776 1125899906842624
}

func main() {
        consts()
        enums()
}

</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orga3d5952" class="outline-4">
<h4 id="orga3d5952">变量定义要点</h4>
<div class="outline-text-4" id="text-orga3d5952">
<ul class="org-ul">
<li>变量类型写在变量后面，其它语言是反的</li>
<li>编译器可推测变量类型</li>
<li>没有char，只有rune且是32位的</li>
<li>原生支持复数类型</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7f3050e" class="outline-3">
<h3 id="org7f3050e">流程控制</h3>
<div class="outline-text-3" id="text-org7f3050e">
</div>
<div id="outline-container-org0c5f472" class="outline-4">
<h4 id="org0c5f472">条件语句-if-switch</h4>
<div class="outline-text-4" id="text-org0c5f472">
</div>
<div id="outline-container-org04e1b8a" class="outline-5">
<h5 id="org04e1b8a">选择结构if</h5>
<div class="outline-text-5" id="text-org04e1b8a">
</div>
<ul class="org-ul">
<li><a id="org3b5e04a"></a>结构1 if else<br>
<div class="outline-text-6" id="text-org3b5e04a">
<div class="org-src-container">
<pre class="src src-sh">func bounded(v int) int {
        <span style="color: #a020f0;">if</span> v &gt; 100 {
                <span style="color: #a020f0;">return</span> 100
        } <span style="color: #a020f0;">else if</span> v &lt; 0 {
                <span style="color: #a020f0;">return</span> 0
        } <span style="color: #a020f0;">else</span> {
                <span style="color: #a020f0;">return</span> v
        }
}
</pre>
</div>
<ul class="org-ul">
<li>if条件里是不需要括号的</li>
</ul>
</div>
</li>
<li><a id="org13a7fd1"></a>结构2 条件里赋值<br>
<div class="outline-text-6" id="text-org13a7fd1">
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #a020f0;">if</span> contents, err := ioutil.ReadFile(filename); <span style="color: #a0522d;">err</span> == nil {
    fmt.Println(string(contents))
} <span style="color: #a020f0;">else</span> {
    fmt.Println(<span style="color: #8b2252;">"cannot print file contenets:"</span>, err)
}
</pre>
</div>
<ul class="org-ul">
<li>if的条件里可以赋值</li>
<li>if的条件里赋值的变量作用域就在这个if语句里</li>
</ul>

<p>
范例：if条件里赋值
</p>
<div class="org-src-container">
<pre class="src src-sh">package main

<span style="color: #0000ff;">import</span> (
        <span style="color: #8b2252;">"fmt"</span>
        <span style="color: #8b2252;">"io/ioutil"</span>)


func main() {
        const <span style="color: #a0522d;">filename</span> = <span style="color: #8b2252;">"abc.txt"</span>
        <span style="color: #a020f0;">if</span> contents, err := ioutil.ReadFile(filename); <span style="color: #a0522d;">err</span> == nil {
                fmt.Println(string(contents))
        } <span style="color: #a020f0;">else</span> {
                fmt.Println(<span style="color: #8b2252;">"cannot print file contenets:"</span>, err)
        }
}
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgbe3a582" class="outline-5">
<h5 id="orgbe3a582">switch</h5>
<div class="outline-text-5" id="text-orgbe3a582">
</div>
<ul class="org-ul">
<li><a id="orga16a94b"></a>结构1 有表达式<br>
<div class="outline-text-6" id="text-orga16a94b">
<div class="org-src-container">
<pre class="src src-bash">func eval(a, b int, op string) int {
        var result int
        switch op {
        <span style="color: #a020f0;">case</span> <span style="color: #8b2252;">"+"</span>:
                <span style="color: #a0522d;">result</span> = a + b
        <span style="color: #a020f0;">case</span> <span style="color: #8b2252;">"-"</span>:
                <span style="color: #a0522d;">result</span> = a - b
        <span style="color: #a020f0;">case</span> <span style="color: #8b2252;">"*"</span>:
                <span style="color: #a0522d;">result</span> = a * b
        <span style="color: #a020f0;">case</span> <span style="color: #8b2252;">"/"</span>:
                <span style="color: #a0522d;">result</span> = a / b
        default:
                panic(<span style="color: #8b2252;">"unsupported operator:"</span> + op)
        }
        <span style="color: #a020f0;">return</span> result
}
</pre>
</div>
<ul class="org-ul">
<li>switch会自动break，除非使用fallthrough</li>
</ul>
</div>
</li>
<li><a id="orge5b4426"></a>结构2 switch后可以没有表达式<br>
<div class="outline-text-6" id="text-orge5b4426">
<div class="org-src-container">
<pre class="src src-sh">func grade(score int) string {
        g := <span style="color: #8b2252;">""</span>
        switch {
        <span style="color: #a020f0;">case</span> score &lt; 0 || score &gt; 100:
                panic(fmt.Sprintf(<span style="color: #8b2252;">"Wrong score: %d"</span>, score))
        <span style="color: #a020f0;">case</span> score &lt; 60:
                <span style="color: #a0522d;">g</span> = <span style="color: #8b2252;">"F"</span>
        <span style="color: #a020f0;">case</span> score &lt; 80:
                <span style="color: #a0522d;">g</span> = <span style="color: #8b2252;">"C"</span>
        <span style="color: #a020f0;">case</span> score &lt; 90:
                <span style="color: #a0522d;">g</span> = <span style="color: #8b2252;">"B"</span>
        <span style="color: #a020f0;">case</span> score &lt;= 100:
                <span style="color: #a0522d;">g</span> = <span style="color: #8b2252;">"A"</span>
        }
        <span style="color: #a020f0;">return</span> g
}
</pre>
</div>
<ul class="org-ul">
<li>switch后可以没有表达式</li>
</ul>

<p>
范例：switch后可以没有表达式
</p>
<div class="org-src-container">
<pre class="src src-sh">package main

<span style="color: #0000ff;">import</span> (
        <span style="color: #8b2252;">"fmt"</span>
)

func grade(score int) string {
        g := <span style="color: #8b2252;">""</span>
        switch {
        <span style="color: #a020f0;">case</span> score &lt; 0 || score &gt; 100:
                panic(fmt.Sprintf(<span style="color: #8b2252;">"Wrong score: %d"</span>, score))
        <span style="color: #a020f0;">case</span> score &lt; 60:
                <span style="color: #a0522d;">g</span> = <span style="color: #8b2252;">"F"</span>
        <span style="color: #a020f0;">case</span> score &lt; 80:
                <span style="color: #a0522d;">g</span> = <span style="color: #8b2252;">"C"</span>
        <span style="color: #a020f0;">case</span> score &lt; 90:
                <span style="color: #a0522d;">g</span> = <span style="color: #8b2252;">"B"</span>
        <span style="color: #a020f0;">case</span> score &lt;= 100:
                <span style="color: #a0522d;">g</span> = <span style="color: #8b2252;">"A"</span>
        }
        <span style="color: #a020f0;">return</span> g
}

func main() {
        fmt.Println(
                grade(0),
                grade(59),
                grade(60),
                grade(82),
                grade(99),
                grade(100),
                //grade(101),
        )
}

</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgd5e989e" class="outline-4">
<h4 id="orgd5e989e">循环语句-for-range</h4>
<div class="outline-text-4" id="text-orgd5e989e">
</div>
<div id="outline-container-org1fdd0a0" class="outline-5">
<h5 id="org1fdd0a0">for</h5>
<div class="outline-text-5" id="text-org1fdd0a0">
</div>
<ul class="org-ul">
<li><a id="orgf869d59"></a>结构1 初始条件，结束条件，递增表达式<br>
<div class="outline-text-6" id="text-orgf869d59">
<div class="org-src-container">
<pre class="src src-sh">sum := 0
<span style="color: #a020f0;">for</span> i := 1; i &lt;= 100; i++ {
        <span style="color: #a0522d;">sum</span> += i
}
</pre>
</div>
<ul class="org-ul">
<li>for条件里不需要括号</li>
<li>for的条件里可以省略初始条件，结束条件，递增表达式</li>
</ul>
</div>
</li>
<li><a id="org5fa9884"></a>结构2 初始条件省略，结束条件，递增表达式<br>
<div class="outline-text-6" id="text-org5fa9884">
<div class="org-src-container">
<pre class="src src-sh">func convertToBin(n int) string {
        // &#19981;&#26029;&#21462;&#27169;&#38500;2
        result := <span style="color: #8b2252;">""</span>
        <span style="color: #a020f0;">for</span> ; n &gt; 0; <span style="color: #a0522d;">n</span> /= 2 {
                lsb := n % 2 // &#21462;&#20986;&#26368;&#20302;&#20301;
                <span style="color: #a0522d;">result</span> = strconv.Itoa(lsb) + result // &#25972;&#25968;&#36716;&#23383;&#31526;&#20018;
        }

        <span style="color: #a020f0;">return</span> result
}
</pre>
</div>
<ul class="org-ul">
<li>省略初始条件，相当于while</li>
</ul>

<p>
范例：整数转2进制
</p>
<div class="org-src-container">
<pre class="src src-sh">package main

<span style="color: #0000ff;">import</span> (
        <span style="color: #8b2252;">"fmt"</span>
        <span style="color: #8b2252;">"strconv"</span>
)


func convertToBin(n int) string {
        // &#19981;&#26029;&#21462;&#27169;&#38500;2
        result := <span style="color: #8b2252;">""</span>
        <span style="color: #a020f0;">for</span> ; n &gt; 0; <span style="color: #a0522d;">n</span> /= 2 {
                lsb := n % 2 // &#21462;&#20986;&#26368;&#20302;&#20301;
                <span style="color: #a0522d;">result</span> = strconv.Itoa(lsb) + result // &#25972;&#25968;&#36716;&#23383;&#31526;&#20018;
        }

        <span style="color: #a020f0;">return</span> result
}

func main() {
        fmt.Println(
                convertToBin(5), // 101
                convertToBin(13), // 1011 --&gt; 1101
        )
}
</pre>
</div>
</div>
</li>
<li><a id="orge7eb7c5"></a>结构3 初始条件、递增表达式省略，结束条件<br>
<div class="outline-text-6" id="text-orge7eb7c5">
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #a020f0;">for</span> scanner.Scan() {
    fmt.Println(scanner.Text())
}
</pre>
</div>
<ul class="org-ul">
<li>省略初始条件，相当于while</li>
</ul>

<p>
范例：只有结束条件
</p>
<div class="org-src-container">
<pre class="src src-sh">package main

<span style="color: #0000ff;">import</span> (
        <span style="color: #8b2252;">"bufio"</span>
        <span style="color: #8b2252;">"fmt"</span>
        <span style="color: #8b2252;">"os"</span>
)

// for&#30465;&#30053;&#36882;&#22686;&#26465;&#20214;
func printFile(filename string) {
        file, err := os.Open(filename) // &#19968;&#34892;&#34892;&#35835;&#25991;&#20214;
        <span style="color: #a020f0;">if</span> err != nil {
                panic(err)
        }

        scanner := bufio.NewScanner(file)

        <span style="color: #a020f0;">for</span> scanner.Scan() {
                fmt.Println(scanner.Text())
        }
}

func main() {
        printFile(<span style="color: #8b2252;">"abc.txt"</span>)
}
</pre>
</div>
</div>
</li>
<li><a id="org2dbe57d"></a>结构4 都省略掉<br>
<div class="outline-text-6" id="text-org2dbe57d">
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #a020f0;">for</span> {
    fmt.Println(<span style="color: #8b2252;">"abc"</span>)
}
</pre>
</div>
<ul class="org-ul">
<li>无限循环
很多并发编程都需要死循环，所以死循环表达方式如此简单</li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org36b5f43" class="outline-5">
<h5 id="org36b5f43">range</h5>
<div class="outline-text-5" id="text-org36b5f43">
<p>
迭代
关键字 range会返回两个值，第一个返回值是元素的数组下标，第二个返回值是元素的值
</p>
<div class="org-src-container">
<pre class="src src-sh">package main

import <span style="color: #8b2252;">"fmt"</span>

func main() {
  str := <span style="color: #8b2252;">"abc"</span>
  //&#36890;&#36807;for&#25171;&#21360;&#27599;&#20010;&#23383;&#31526;
  <span style="color: #a020f0;">for</span> i := 0; i &lt; len(str); i++ {
    fmt.Printf(<span style="color: #8b2252;">"str[%d]=%c\n"</span>, i, str[i])
  }

  //&#36845;&#20195;&#25171;&#21360;&#27599;&#20010;&#20803;&#32032;&#65292;&#40664;&#35748;&#36820;&#22238;2&#20010;&#20540;; &#19968;&#20010;&#26159;&#20803;&#32032;&#20301;&#32622;&#65292;&#19968;&#20010;&#26159;&#20803;&#32032;&#26412;&#36523;
  <span style="color: #a020f0;">for</span> i, data := range str {
    fmt.Printf(<span style="color: #8b2252;">"str[%d] = %c\n"</span>, i, data)
  }

  <span style="color: #a020f0;">for</span> i := range str { //&#31532;2&#20010;&#36820;&#22238;&#20540;&#65292;&#40664;&#35748;&#20002;&#24323;&#65292;&#36820;&#22238;&#20803;&#32032;&#20301;&#32622;(&#19979;&#26631;)
    fmt.Printf(<span style="color: #8b2252;">"str[%d] = %c\n"</span>, i, str[i])
  }

  <span style="color: #a020f0;">for</span> i, _ := range str { //&#31532;2&#20010;&#36820;&#22238;&#20540;&#65292;&#40664;&#35748;&#20002;&#24323;&#65292;&#36820;&#22238;&#20803;&#32032;&#20301;&#32622;(&#19979;&#26631;)
    fmt.Printf(<span style="color: #8b2252;">"str[%d] = %c\n"</span>, i, str[i])
  }
}

&#32467;&#26524;&#65306;
<span style="color: #a0522d;">str</span>[0]=a
<span style="color: #a0522d;">str</span>[1]=b
<span style="color: #a0522d;">str</span>[2]=c
<span style="color: #a0522d;">str</span>[0] = a
<span style="color: #a0522d;">str</span>[1] = b
<span style="color: #a0522d;">str</span>[2] = c
<span style="color: #a0522d;">str</span>[0] = a
<span style="color: #a0522d;">str</span>[1] = b
<span style="color: #a0522d;">str</span>[2] = c
<span style="color: #a0522d;">str</span>[0] = a
<span style="color: #a0522d;">str</span>[1] = b
<span style="color: #a0522d;">str</span>[2] = c
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org81f0d54" class="outline-4">
<h4 id="org81f0d54">基本语法要点回顾</h4>
<div class="outline-text-4" id="text-org81f0d54">
<ul class="org-ul">
<li>for,if后面的条件没有括号</li>
<li>if 条件里也可以定义变量</li>
<li>没有while</li>
<li>switch不需要break，也可以直接switch多条件</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org318da25" class="outline-3">
<h3 id="org318da25">函数</h3>
<div class="outline-text-3" id="text-org318da25">
</div>
<div id="outline-container-org157d454" class="outline-4">
<h4 id="org157d454">函数定义</h4>
<div class="outline-text-4" id="text-org157d454">
<div class="org-src-container">
<pre class="src src-sh">func funcName(a, b int, op string) int {
//function body
}
&#20989;&#25968;&#21517;&#22312;&#21069;&#65292;&#31867;&#22411;&#22312;&#21518;
</pre>
</div>
<ul class="org-ul">
<li>无参数和无返回值</li>
<li>有参数无返回值
<ul class="org-ul">
<li>普通参数列表</li>
<li>不定参数类型、传递</li>
<li>函数作为函数参数（函数调用）</li>
</ul></li>
<li>无参数有返回值</li>
<li>函数可返回多个值</li>
<li>有参有返回值</li>
</ul>
</div>
</div>
<div id="outline-container-org7b07e65" class="outline-4">
<h4 id="org7b07e65">有参数</h4>
<div class="outline-text-4" id="text-org7b07e65">
<p>
同类型的参数可以用逗号合并，如`a int, b int == a, b int`
</p>

<p>
范例：
</p>
<div class="org-src-container">
<pre class="src src-sh">package main

import <span style="color: #8b2252;">"fmt"</span>

func eval(a, b int, op string) int {
    switch op {
    <span style="color: #a020f0;">case</span> <span style="color: #8b2252;">"+"</span>:
        <span style="color: #a020f0;">return</span> a + b
    <span style="color: #a020f0;">case</span> <span style="color: #8b2252;">"-"</span>:
        <span style="color: #a020f0;">return</span> a - b
    <span style="color: #a020f0;">case</span> <span style="color: #8b2252;">"*"</span>:
        <span style="color: #a020f0;">return</span> a * b
    <span style="color: #a020f0;">case</span> <span style="color: #8b2252;">"/"</span>:
        <span style="color: #a020f0;">return</span> a / b
    default:
        panic(<span style="color: #8b2252;">"unsupported operation:"</span> + op)
    }
}

func main() {
    fmt.Println(<span style="color: #483d8b;">eval</span>(3, 4, <span style="color: #8b2252;">"*"</span>))
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orga568d8e" class="outline-4">
<h4 id="orga568d8e">函数可返回多个值</h4>
<div class="outline-text-4" id="text-orga568d8e">
<div class="org-src-container">
<pre class="src src-sh">// &#24102;&#20313;&#38500;&#27861; 13 / <span style="color: #a0522d;">3</span> = 4 ... 1
func div(a, b int) (int, int) {
    <span style="color: #a020f0;">return</span> a / b, a % b
}
</pre>
</div>
</div>
<div id="outline-container-org1a8225f" class="outline-5">
<h5 id="org1a8225f">返回值起名字</h5>
<div class="outline-text-5" id="text-org1a8225f">
<div class="org-src-container">
<pre class="src src-sh">func div(a, b int) (q, r int) {
    <span style="color: #a0522d;">q</span> = a / b
    <span style="color: #a0522d;">r</span> = a % b
    <span style="color: #a020f0;">return</span>
}
</pre>
</div>
<ul class="org-ul">
<li>函数返回多个值时，可以起名字；但仅用于非常简单的函数
避免函数长了找不到返回位置</li>
<li>是否起名字对于调用者没有区别</li>
</ul>

<p>
范例：多返回值起名字
</p>
<div class="org-src-container">
<pre class="src src-sh">func div(a, b int) (q, r int) { //q&#21830;&#65292;r&#20313;&#25968;
    <span style="color: #a020f0;">return</span> a / b, a % b
}

func main() {
    q, r := div(14, 3)
    fmt.Println(q, r)
}

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#36824;&#21487;&#20197;&#36825;&#26679;&#20889;
</span>func div(a, b int) (q, r int) { //q&#21830;&#65292;r&#20313;&#25968;
    <span style="color: #a0522d;">q</span> = a / b
    <span style="color: #a0522d;">r</span> = a % b
    <span style="color: #a020f0;">return</span>
}
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#22914;&#26524;&#20989;&#25968;&#20307;&#27604;&#36739;&#38271;&#65292;&#19981;&#22909;&#25214;&#21040;&#21738;&#34892;&#32473;q&#12289;r&#36171;&#20540;&#65292;&#36825;&#31181;&#26041;&#27861;&#19981;&#22826;&#22909;&#65292;&#24314;&#35758;&#29992;&#19978;&#38754;&#30340;&#26041;&#27861;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orge4491a9" class="outline-5">
<h5 id="orge4491a9">忽略某返回值</h5>
<div class="outline-text-5" id="text-orge4491a9">
<p>
使用下划线`_`
</p>
<ul class="org-ul">
<li>`q, _ := div(14, 3)`</li>
</ul>
</div>
</div>
<div id="outline-container-orgf4a68c2" class="outline-5">
<h5 id="orgf4a68c2">多返回值使用场景</h5>
<div class="outline-text-5" id="text-orgf4a68c2">
<ul class="org-ul">
<li>用于err，调用者来具体处理err</li>
</ul>

<p>
范例：多返回值err场景
</p>
<div class="org-src-container">
<pre class="src src-sh">func eval(a, b int, op string) (int, error) {
    switch op {
    <span style="color: #a020f0;">case</span> <span style="color: #8b2252;">"+"</span>:
        <span style="color: #a020f0;">return</span> a + b, nil
    <span style="color: #a020f0;">case</span> <span style="color: #8b2252;">"-"</span>:
        <span style="color: #a020f0;">return</span> a - b, nil
    <span style="color: #a020f0;">case</span> <span style="color: #8b2252;">"*"</span>:
        <span style="color: #a020f0;">return</span> a * b, nil
    <span style="color: #a020f0;">case</span> <span style="color: #8b2252;">"/"</span>:
        <span style="color: #a020f0;">return</span> a / b, nil
    default:
        <span style="color: #a020f0;">return</span> 0, fmt.Errorf(<span style="color: #8b2252;">"unsupported operation: %s"</span>, op)
    }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org60d93d5" class="outline-4">
<h4 id="org60d93d5">函数作为函数参数</h4>
<div class="outline-text-4" id="text-org60d93d5">
<div class="org-src-container">
<pre class="src src-sh">func apply(op func(int, int) int, a, b int) int {
    fmt.Printf(<span style="color: #8b2252;">"Calling funciton %s with args"</span>+
        <span style="color: #8b2252;">"(%d, %d)"</span>, runtime.FuncForPC(reflect.ValueOf(op).Pointer()).Name(),
        a, b)
    <span style="color: #a020f0;">return</span> op(a, b)
}
</pre>
</div>
<p>
go语言是函数式编程的语言，函数是一等公民。
函数参数、函数体内都可以有函数。
</p>

<p>
范例：函数作为函数参数
</p>
<div class="org-src-container">
<pre class="src src-sh">func apply(op func(int, int) int, a, b int) int {
    //&#21033;&#29992;&#21453;&#23556;&#30830;&#35748;op&#20989;&#25968;&#26159;&#35843;&#29992;&#21738;&#20010;&#20989;&#25968;
    p := reflect.ValueOf(op).Pointer() // &#33719;&#24471;&#20989;&#25968;&#30340;&#25351;&#38024;
    opName := runtime.FuncForPC(p).Name()
    fmt.Printf(<span style="color: #8b2252;">"Calling funciton %s with args"</span>+
        <span style="color: #8b2252;">"(%d, %d)\n"</span>, opName, a, b)

    <span style="color: #a020f0;">return</span> op(a, b)
}

func pow(a, b int) int {
    <span style="color: #a020f0;">return</span> int(math.Pow(float64(a), float64(b)))
}

func main() {
    fmt.Println(apply(pow, 3, 4)) // &#32467;&#26524;&#65306;Calling funciton main.pow with args(3, 4)81
}

//pow&#21478;&#22806;&#23450;&#20041;&#19968;&#20010;&#20989;&#25968;&#24456;&#21507;&#21147;&#65292;&#36825;&#37324;&#30452;&#25509;&#20889;main&#37324;&#65292;&#20889;&#25104;&#21311;&#21517;&#20989;&#25968;&#12290;&#21363;&#38381;&#21253;
func main() {
    fmt.Println(apply(
        func(a int, b int) int {
            <span style="color: #a020f0;">return</span> int(math.Pow(float64(a), float64(b)))
        }, 3, 4)) // &#32467;&#26524;&#65306;Calling funciton main.main.func1 with args(3, 4)81
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf142b84" class="outline-4">
<h4 id="orgf142b84">可变参数列表</h4>
<div class="outline-text-4" id="text-orgf142b84">
<div class="org-src-container">
<pre class="src src-sh">func sum(numbers ...int) int {
    s := 0
    <span style="color: #a020f0;">for</span> i := range numbers {
        <span style="color: #a0522d;">s</span> += numbers[i]
    }
    <span style="color: #a020f0;">return</span> s
}

func main() {
    fmt.Println(sum(1, 2, 3, 4, 5)) // 15
}

</pre>
</div>

<ul class="org-ul">
<li>一定(只能)放在形参中的最后一个参数</li>
<li>传递的实参可以是0或多个</li>
<li>可变参数传递 `全部传递myfunc(args&#x2026;) 部分值传递 myfunc2(args[2:]&#x2026;) `</li>
<li>应用场景结构体中</li>
</ul>
</div>
</div>
<div id="outline-container-org071839f" class="outline-4">
<h4 id="org071839f">函数语法要点回顾</h4>
<div class="outline-text-4" id="text-org071839f">
<ul class="org-ul">
<li>返回值类型写在最后面</li>
<li>可以返回多个值</li>
<li>函数可作为参数</li>
<li>没有默认参数、可选参数</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org03d974a" class="outline-3">
<h3 id="org03d974a">指针</h3>
<div class="outline-text-3" id="text-org03d974a">
<div class="org-src-container">
<pre class="src src-sh">var a <span style="color: #a0522d;">int</span> = 2
var pa *<span style="color: #a0522d;">int</span> = &amp;a
*<span style="color: #a0522d;">pa</span> = 3
<span style="color: #0000ff;">fmt.Println</span>(a)
</pre>
</div>
<p>
pa是一个对a的指针，c语言是`int*`代表指针，go语言是`*int`
</p>
<ul class="org-ul">
<li>操作符 "&amp;" 取变量地址，"*"通过指针访问目标对象</li>
<li>不支持指针运算，不支持 "-&gt;"运算符，直接用"." 点来访问目标成员</li>
</ul>
</div>
<div id="outline-container-org91e87c1" class="outline-4">
<h4 id="org91e87c1">参数传递</h4>
<div class="outline-text-4" id="text-org91e87c1">
<p>
是值传递？还是引用传递？
c/c++即可值传递，又可以引用传递，java/python绝大部分是引用传递除了系统的自建类型以外
</p>

<p>
范例：c++中值传递和引用传递
</p>
<div class="org-src-container">
<pre class="src src-sh">void pass_by_val(int a) { //&#20540;&#20256;&#36882;
    a++;
}

void pass_by_ref(int&amp; a) { //&#24341;&#29992;&#20256;&#36882;
    a++;
}

int main() {
    int <span style="color: #a0522d;">a</span> = 3;

    pass_by_val(a);
    printf(<span style="color: #8b2252;">"After pass_by_val: %d\n"</span>, a);

    pass_by_ref(a);
    printf(<span style="color: #8b2252;">"After pass_by_ref: %d\n"</span>, a);
}

//&#32467;&#26524;
After pass_by_val: 3
After pass_by_ref: 4
</pre>
</div>
<p>
值传递做了一份拷贝，原值不变
引用传递做了引用，调的值会被改变
</p>
</div>
<div id="outline-container-org704b3fc" class="outline-5">
<h5 id="org704b3fc">go语言使用值传递？引用传递？</h5>
<div class="outline-text-5" id="text-org704b3fc">
<ul class="org-ul">
<li>go语言只有值传递一种方式，但有指针来做配合</li>
</ul>
</div>
</div>
<div id="outline-container-orgd26e90c" class="outline-5">
<h5 id="orgd26e90c">值传递-普通变量做函数参数</h5>
<div class="outline-text-5" id="text-orgd26e90c">
<p>
变量复制一份
</p>

<p>
范例： 值传递-普通变量做函数参数
</p>
<div class="org-src-container">
<pre class="src src-sh">var a int

func f(a int)

a -- a
a&#21464;&#37327;&#25335;&#36125;&#19968;&#20221;&#32473;f&#20989;&#25968;&#65292;&#21407;a&#21464;&#37327;&#20540;&#19981;&#34987;&#25913;&#21464;
</pre>
</div>
</div>
</div>
<div id="outline-container-orge4d90aa" class="outline-5">
<h5 id="orge4d90aa">引用传递-指针做函数参数</h5>
<div class="outline-text-5" id="text-orge4d90aa">
<p>
指针传递做了引用传递的效果
</p>

<p>
范例：引用传递-指针做函数参
</p>
<div class="org-src-container">
<pre class="src src-sh">var a int

func f(pa *int)

&amp;a -- pa
    |
    a
a&#20570;&#19968;&#20010;&#22320;&#22336;&amp;a&#20256;&#36882;&#32473;f&#20989;&#25968;&#65292;&amp;a&#21644;pa&#21516;&#26102;&#25351;&#21521;&#21464;&#37327;a&#65292;&#22914;&#26524;&#22312;f&#20989;&#25968;&#20013;&#20462;&#25913;
pa&#25351;&#21521;&#30340;&#20869;&#23481;&#65292;&#37027;&#20040;a&#30340;&#20540;&#20063;&#20250;&#21464;&#12290;
</pre>
</div>
</div>
</div>
<div id="outline-container-org40936e0" class="outline-5">
<h5 id="org40936e0">对象-传递</h5>
<div class="outline-text-5" id="text-org40936e0">
<p>
可以值传递，也可以指针传递。用哪种方式传递，在后面对象封装时，讲述如何把cache封装值类型或指针类型
</p>

<p>
范例：cache做为值传递类型
</p>
<div class="org-src-container">
<pre class="src src-sh">var cache Cache

func f(cache Cache)

cache&#23545;&#35937;&#30340;&#32467;&#26500;&#65292;&#19968;&#33324;&#19981;&#24102;&#26377;data&#65292;&#36890;&#24120;&#26159;&#25351;&#21521;data&#30340;&#25351;&#38024;pData

<span style="color: #0000ff;">cahe</span>(pDdata)  --- cahe(pData)
               |
              data
&#25335;&#36125;&#20102;&#19968;&#20221;cache&#32473;f&#20989;&#25968;&#65292;&#21516;&#26679;&#26377;&#19968;&#20221;pData&#25351;&#38024;&#65292;&#36825;&#20457;&#20010;pData&#37117;&#25351;&#21521;&#21516;&#19968;&#20010;data
</pre>
</div>
<p>
如果cache中同时维护了一些状态，就不能做为值传递类型，这时就传cache指针过去。
</p>
</div>
</div>
</div>
<div id="outline-container-org54edbbd" class="outline-4">
<h4 id="org54edbbd">范例：交换2个变量的值</h4>
<div class="outline-text-4" id="text-org54edbbd">
<div class="org-src-container">
<pre class="src src-sh">func swap(a, b *int) {
    *a, *<span style="color: #a0522d;">b</span> = *b, *a
}

func main() {
    a, b := 3, 4
    swap(&amp;a, &amp;b)
    fmt.Println(a, b)  //4 3
}
</pre>
</div>
<p>
swap函数中a,b做为指针，b指向的内容被换成a，a指向的内容被换成b，这样就完成了交换。
不过还有一种做法
</p>

<p>
在编程中更佳希望的是不可变量，`swap(&amp;a, &amp;b)`把指针取地址传进去看上去不太舒服，可以这样做
</p>
<div class="org-src-container">
<pre class="src src-sh">func swap(a, b int) (int, int) {
    <span style="color: #a020f0;">return</span> b, a // &#25226;&#20132;&#25442;&#30340;&#32467;&#26524;&#36820;&#22238;&#20986;&#21435;
}

func main() {
    a, b := 3, 4
    a, <span style="color: #a0522d;">b</span> = swap(a, b)  // a, b &#21435;&#25509;&#20989;&#25968;&#30340;&#36820;&#22238;&#20540;
    fmt.Println(a, b)  // 4 3
}
</pre>
</div>
<p>
swap函数把交换的结果返回出去`return b, a`，调用swap函数可以a,b来接住他们`a, b = swap(a, b)`
上面这种swap的定义方法才是更好的。
</p>
</div>
</div>
</div>
</section>
<section id="outline-container-org8260e70" class="outline-2">
<h2 id="org8260e70">内建容器</h2>
<div class="outline-text-2" id="text-org8260e70">
<p>
基础语法可以写一些简单的代码片段，如10进制数转2进制数。
这里讲述复杂的数据结构，包括数组、切片、容器介绍
</p>
<div class="org-src-container">
<pre class="src src-sh">package main

func main() {
    cache := make(map[string]string)
    <span style="color: #a0522d;">cache</span>[<span style="color: #8b2252;">"name"</span>] = <span style="color: #8b2252;">"abc"</span>
}
</pre>
</div>
</div>
<div id="outline-container-org995d92c" class="outline-3">
<h3 id="org995d92c">数组</h3>
<div class="outline-text-3" id="text-org995d92c">
<p>
{}*** 数组定义
</p>
<div class="org-src-container">
<pre class="src src-sh">var arr1 [5]int
arr2 := [3]int{1, 3, 5}
arr3 := [...]int{2, 4, 6, 8, 10} // &#32534;&#35793;&#22120;&#25968;&#26377;&#20960;&#20010;int
var grid [4][5]int  // 4&#34892;5&#21015;&#25968;&#32452;
</pre>
</div>

<ul class="org-ul">
<li>数量写在类型前面</li>
<li>`&#x2026;`是让编译器来数有几个该数据</li>
<li>多维数组`[]`方括号写在前面。如，`[4][5]int`代表4个长度为5的int</li>
</ul>
</div>
<div id="outline-container-org90500b0" class="outline-4">
<h4 id="org90500b0">遍历数组-for-range</h4>
<div class="outline-text-4" id="text-org90500b0">
</div>
<div id="outline-container-orgcabc8d4" class="outline-5">
<h5 id="orgcabc8d4">for</h5>
<div class="outline-text-5" id="text-orgcabc8d4">
<div class="org-src-container">
<pre class="src src-sh">arr3 := [...]int{2, 4, 6, 8, 10} // &#23450;&#20041;&#25968;&#32452;

<span style="color: #a020f0;">for</span> i :=0; i &lt; len(arr3); i++ { // &#36941;&#21382;&#25968;&#32452;
    fmt.Println(arr3[i])
}
</pre>
</div>
<p>
一般遍历数组使用range关键字
</p>
</div>
</div>
<div id="outline-container-org5a7467d" class="outline-5">
<h5 id="org5a7467d">range</h5>
<div class="outline-text-5" id="text-org5a7467d">
<div class="org-src-container">
<pre class="src src-sh">arr3 := [...]int{2, 4, 6, 8, 10}

<span style="color: #a020f0;">for</span> i := range arr3 {  // &#21482;&#35201;&#19979;&#26631;
    fmt.Println(arr3[i])
}

<span style="color: #a020f0;">for</span> i, v := range arr3 {  // i&#20026;&#25968;&#32452;&#19979;&#26631;&#65292; v&#20026;&#19979;&#26631;&#23545;&#24212;&#30340;&#20540;
    fmt.Println(i, v)
}

<span style="color: #a020f0;">for</span> _, v := range arr3 {  // &#21482;&#35201;&#20540;, _&#20195;&#34920;&#24573;&#30053;
    fmt.Println(v)
}
</pre>
</div>
<ul class="org-ul">
<li>可通过`_`下划线来省略变量</li>
<li>不仅range，任何地方都可通过`_`来省略变量</li>
<li>只要i，可写成 `for i := range numbers`</li>
</ul>

<p>
范例：取数组中最大的值
</p>
<div class="org-src-container">
<pre class="src src-sh">arr3 := [...]int{2, 4, 6, 8, 10} // &#32534;&#35793;&#22120;&#25968;&#26377;&#20960;&#20010;int

maxi := -1
maxValue := -1
<span style="color: #a020f0;">for</span> i, v := range arr3 {
    <span style="color: #a020f0;">if</span> v &gt; maxValue {
        maxi, <span style="color: #a0522d;">maxValue</span> = i ,v
    }
}
<span style="color: #0000ff;">fmt.Println</span>(maxi, maxValue)
</pre>
</div>

<p>
范例：数组中数据求和
</p>
<div class="org-src-container">
<pre class="src src-sh">sum := 0
<span style="color: #a020f0;">for</span> _, v := range numbers {
        <span style="color: #a0522d;">sum</span> += v
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org57d24fd" class="outline-5">
<h5 id="org57d24fd">为什么要用range</h5>
<div class="outline-text-5" id="text-org57d24fd">
<ul class="org-ul">
<li>意义明确，美观</li>
<li>c++ 没有类似能力</li>
<li>java/python: 只能for each value, 不能同时获取i, v</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgecd30e3" class="outline-4">
<h4 id="orgecd30e3">数组是值类型</h4>
<div class="outline-text-4" id="text-orgecd30e3">
<div class="org-src-container">
<pre class="src src-sh">func printArray(arr [5]int) {
    <span style="color: #a0522d;">arr</span>[0] = 100
}

func printArrayPtr(arr *[5]int) {
    <span style="color: #a0522d;">arr</span>[0] = 100 // &#21487;&#20197;&#19981;&#29992;&#20889;(*arr)
}

func main() {
    // &#23450;&#20041;&#25968;&#32452;
    var arr1 [5]int
    arr2 := [3]int{1, 3, 5}
    arr3 := [...]int{2, 4, 6, 8, 10} // &#32534;&#35793;&#22120;&#25968;&#26377;&#20960;&#20010;int
    var grid [4][5]int  // 4&#34892;5&#21015;&#25968;&#32452;


    printArray(arr1)
    printArray(arr3)
    // printArray(arr2) //&#25253;&#38169; arr2&#21644;[5]int&#26159;&#19981;&#21516;&#30340;&#31867;&#22411;

    // &#25968;&#32452;&#25351;&#38024;&#30340;&#26041;&#27861;
    printArrayPtr(&amp;arr1)
    printArrayPtr(&amp;arr3)

    fmt.Println(<span style="color: #8b2252;">"arr1, arr3"</span>)
    fmt.Println(arr1, arr3)  // [100 0 0 0 0] [100 4 6 8 10]
}
</pre>
</div>
<ul class="org-ul">
<li>`[10]int`和`[20]int`是不同类型</li>
<li>调用`func f(arr [10]int)`会 <b>拷贝</b> 数组</li>
<li>在go语言中一般不直接使用数组，而是用切片。</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2c18f4d" class="outline-3">
<h3 id="org2c18f4d">Slice 切片</h3>
<div class="outline-text-3" id="text-org2c18f4d">
<div class="org-src-container">
<pre class="src src-sh">arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7}
s := arr[2:6]

<span style="color: #a0522d;">s</span>[0] = 100
</pre>
</div>
<ul class="org-ul">
<li>s就是数组arr的切片，值为`[2 3 4 5]`</li>
<li>`[2:6]`半开半闭区间，2是包含进去的，6是不包括进去的</li>
<li>slice本身是没有数据的，是对底层数组的一个view视图。</li>
<li>arr值变为`[0 1 10 3 4 5 6 7]`</li>
</ul>
</div>
<div id="outline-container-orga47594e" class="outline-4">
<h4 id="orga47594e">范例：验证slice是对数组的view视图</h4>
<div class="outline-text-4" id="text-orga47594e">
<div class="org-src-container">
<pre class="src src-sh">func updateSlice(s []int) {
    <span style="color: #a0522d;">s</span>[0] = 100
}

func main() {
    arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7}
    s1 := arr[2:]
    fmt.Println(<span style="color: #8b2252;">"s1 ="</span>, s1) // <span style="color: #a0522d;">s1</span> = [2 3 4 5 6 7]
    s2 := arr[:]
    fmt.Println(<span style="color: #8b2252;">"s2 ="</span>, s2) // <span style="color: #a0522d;">s2</span> = [0 1 2 3 4 5 6 7]

    fmt.Println(<span style="color: #8b2252;">"After updateSlice(s1)"</span>)
    updateSlice(s1)
    fmt.Println(s1) // [100 3 4 5 6 7]
    fmt.Println(arr) //[0 1 100 3 4 5 6 7]

    fmt.Println(<span style="color: #8b2252;">"After updateSlice(s2)"</span>)
    updateSlice(s2)
    fmt.Println(s2) // [100 1 100 3 4 5 6 7]
    fmt.Println(arr) // [100 1 100 3 4 5 6 7]
}
</pre>
</div>
<p>
数组范例中，使用slice来实现
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#22312;go&#35821;&#35328;&#20013;&#19968;&#33324;&#19981;&#30452;&#25509;&#20351;&#29992;&#25968;&#32452;&#65292;&#32780;&#26159;&#29992;&#20999;&#29255;
</span><span style="color: #0000ff;">printArrayPtr</span>(&amp;arr1) &#21487;&#25913;&#25104;  printArrayPtr(arr1[:])
<span style="color: #0000ff;">printArrayPtr</span>(arr *[5]int) &#21487;&#25913;&#25104; printArrayPtr(arr *[5]int)
</pre>
</div>
</div>
</div>
<div id="outline-container-org72a6bc7" class="outline-4">
<h4 id="org72a6bc7">reslice切片再切片</h4>
<div class="outline-text-4" id="text-org72a6bc7">
<div class="org-src-container">
<pre class="src src-sh">s := arr[2:6]
<span style="color: #a0522d;">s</span> = s[:3]
<span style="color: #a0522d;">s</span> = s[1:]
<span style="color: #a0522d;">s</span> = arr[:]
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc87a1d5" class="outline-4">
<h4 id="orgc87a1d5">Slice的扩展</h4>
<div class="outline-text-4" id="text-orgc87a1d5">
<div class="org-src-container">
<pre class="src src-sh">arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7}
s1 := arr[2:6]
s2 := s1[3:5]
</pre>
</div>
<ul class="org-ul">
<li>s1的值为？ s2的值为？</li>
<li>`s1 = [2 3 4 5]    s2 = [5 6]`</li>
</ul>


<figure id="orgcd6a243">
<img src="./images/slice-extending.png" alt="Zoomed image." width="800px">

<figcaption><span class="figure-number">Figure 1: </span>扩展的slice，与底层数组关系</figcaption>
</figure>

<ul class="org-ul">
<li>底层的数组arr是0, 1, 2, 3, 4, 5, 6, 7</li>
<li>操作s1 := arr[2:6]后，取到2, 3, 4, 5。映射到s1的下标就是0, 1, 2, 3。s1里因为是对底层arr的view，下标不是到3就结束了，到以后会打印4, 5，但直接用s1[4], s1[5]是看不见的，但它还是知道s1下面有下标4, 5两个元素的。</li>
<li>操作s2 := s1[3:5]后，就取了s1下标3和4的值5，6。</li>
</ul>
</div>
<div id="outline-container-org41983c7" class="outline-5">
<h5 id="org41983c7">Slice的实现</h5>
<div class="outline-text-5" id="text-org41983c7">

<figure id="org6367b1a">
<img src="./images/slice-active.jpg" alt="Zoomed image." width="800px">

<figcaption><span class="figure-number">Figure 2: </span>Slice的实现系</figcaption>
</figure>
<ul class="org-ul">
<li>slice底层有个array，array像上面这样涂成了3种颜色</li>
<li>slice中有ptr指向slice开头的元素</li>
<li>slice中有len说明slice的长度，当取下标大于等于len的值时就报错，下标越界</li>
<li>slice中有cap(capacity)说明下面整个array从ptr开始到结束整个的长度</li>
<li>slice实现其实就有这3个ptr,len,cap变量就能区别于array，扩展时只要不超过capacity就好</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7}
s1 := arr[2:6]
s2 := s1[3:5]
</pre>
</div>
<ul class="org-ul">
<li>slice可以向后扩展，不可以向前扩展</li>
<li>`s[i]`不可以超越`len(s)`，向后扩展不可以超越底层数组`cap(s)`</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org0e512d5" class="outline-4">
<h4 id="org0e512d5">向Slice添加元素</h4>
<div class="outline-text-4" id="text-org0e512d5">
<div class="org-src-container">
<pre class="src src-sh">arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7}
s1 := arr[2:6]
s2 := s1[3:5]
s3 := append(s2, 10)
s4 := append(s3, 11)
s5 := append(s4, 12)
</pre>
</div>
<ul class="org-ul">
<li>s3, s4, s5的值为？arr的值为？
<ul class="org-ul">
<li>`s3, s4, s5= [5 6 10] [5 6 10 11] [5 6 10 11 12]`</li>
<li>`arr = [0 1 2 3 4 5 6 10]`</li>
</ul></li>
<li>添加元素时如果超越cap，系统会重新分配更大的底层数组
<ul class="org-ul">
<li>如果原来的arr有人用就还在，如果没人用就会被垃圾回收掉</li>
</ul></li>
<li>由于值传递的关系，必须接收append的返回值</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">package main

import <span style="color: #8b2252;">"fmt"</span>

func updateSlice(s []int) {
    <span style="color: #a0522d;">s</span>[0] = 100
}

func main() {
    arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7}
    fmt.Println(<span style="color: #8b2252;">"arr[2:6] ="</span>, arr[2:6]) // arr[2:6] = [2 3 4 5]
    fmt.Println(<span style="color: #8b2252;">"arr[:6] ="</span>, arr[:6])   // arr[:6] = [0 1 2 3 4 5]
    s1 := arr[2:]
    fmt.Println(<span style="color: #8b2252;">"s1 ="</span>, s1) // <span style="color: #a0522d;">arr</span>[2:] = [2 3 4 5 6 7]
    s2 := arr[:]
    fmt.Println(<span style="color: #8b2252;">"s2 ="</span>, s2) // <span style="color: #a0522d;">arr</span>[:] = [0 1 2 3 4 5 6 7]

    //&#39564;&#35777;slice&#26159;&#24213;&#23618;array&#30340;&#19968;&#20010;&#35270;&#22270;
    fmt.Println(<span style="color: #8b2252;">"After updateSlice(s1)"</span>)
    updateSlice(s1)
    fmt.Println(s1)  // [100 3 4 5 6 7]
    fmt.Println(arr) //[0 1 100 3 4 5 6 7]

    fmt.Println(<span style="color: #8b2252;">"After updateSlice(s2)"</span>)
    updateSlice(s2)
    fmt.Println(s2)  // [100 1 100 3 4 5 6 7]
    fmt.Println(arr) // [100 1 100 3 4 5 6 7]

    fmt.Println(<span style="color: #8b2252;">"Reslice"</span>)
    fmt.Println(s2) // [100 1 100 3 4 5 6 7]
    <span style="color: #a0522d;">s2</span> = s2[:5]
    fmt.Println(s2) // [100 1 100 3 4]
    <span style="color: #a0522d;">s2</span> = s2[2:]
    fmt.Println(s2) // [100 3 4]
    <span style="color: #a0522d;">s2</span> = arr[:]
    fmt.Println(s2) // [100 1 100 3 4 5 6 7]

    fmt.Println(<span style="color: #8b2252;">"Extending slice"</span>)
    <span style="color: #a0522d;">arr</span>[0], arr[2] = 0, 2
    <span style="color: #a0522d;">s1</span> = arr[2:6]             // [2 3 4 5]
    <span style="color: #a0522d;">s2</span> = s1[3:5]              // &#21462;&#30340;&#26159;[s1[3], s1[4]] &#65292;&#21487;s1[4]&#19981;&#22312;s1&#37324;&#38754;&#65292;&#30452;&#25509;&#21462;s1[4]&#26159;&#21462;&#19981;&#20986;&#30340;
    fmt.Println(<span style="color: #8b2252;">"arr ="</span>, arr) // <span style="color: #a0522d;">arr</span> = [0 1 2 3 4 5 6 7]
    fmt.Printf(<span style="color: #8b2252;">"s1=%v, len(s1)=%d, cap(s1)=%d\n"</span>,
        s1, len(s1), cap(s1)) // <span style="color: #a0522d;">s1</span>=[2 3 4 5], len(s1)=4, cap(s1)=6
    fmt.Printf(<span style="color: #8b2252;">"s2=%v, len(s2)=%d, cap(s2)=%d\n"</span>,
        s2, len(s2), cap(s2)) // <span style="color: #a0522d;">s2</span>=[5 6], len(s2)=2, cap(s2)=3

    // &#21521;Slice&#28155;&#21152;&#20803;&#32032;
    s3 := append(s2, 10)
    s4 := append(s3, 11)
    s5 := append(s4, 12)
    fmt.Println(<span style="color: #8b2252;">"s3, s4, s5="</span>, s3, s4, s5) // s3, s4, <span style="color: #a0522d;">s5</span>= [5 6 10] [5 6 10 11] [5 6 10 11 12]
    // s4 and s5 no longer view arr
    fmt.Println(<span style="color: #8b2252;">"arr ="</span>, arr) // <span style="color: #a0522d;">arr</span> = [0 1 2 3 4 5 6 10]
    // s4, s5&#26159;&#26032;&#30340;array&#65292;&#25226;arr&#25335;&#36125;&#36807;&#21435;&#65292;&#26032;arr&#38271;&#24230;&#20250;&#35774;&#32622;&#30340;&#26356;&#38271;&#20123;
}

</pre>
</div>
</div>
</div>
<div id="outline-container-org050ecc8" class="outline-4">
<h4 id="org050ecc8">slice的其它操作</h4>
<div class="outline-text-4" id="text-org050ecc8">
</div>
<div id="outline-container-org1e30f80" class="outline-5">
<h5 id="org1e30f80">创建slice</h5>
<div class="outline-text-5" id="text-org1e30f80">
<div class="org-src-container">
<pre class="src src-sh">var s []int // Zero value for slice is nil&#65292;&#21487;&#20197;&#34987;append
s1 := []int{2, 4, 6, 8}
s2 := make([]int, 16)  // &#38271;&#24230;16&#30340;slice, &#23481;&#37327;&#20063;&#20026;16
s3 := make([]int, 10, 32)  // &#38271;&#24230;16&#30340;slice&#65292;&#23481;&#37327;32
</pre>
</div>
<p>
范例：创建slice
</p>
<div class="org-src-container">
<pre class="src src-sh">package main

import <span style="color: #8b2252;">"fmt"</span>

func printSlice(s []int) {
        fmt.Printf(<span style="color: #8b2252;">"len=%d, cap=%d\n"</span>, len(s), cap(s))
}

func main() {
        fmt.Println(<span style="color: #8b2252;">"Creating slice"</span>)
        // &#19968;&#33324;array&#19981;&#29992;&#23450;&#20041;&#65292;&#30452;&#25509;&#21019;&#24314;slice
        var s []int // Zero value for slice is nil&#65292;&#21487;&#20197;&#34987;append

        <span style="color: #a020f0;">for</span> i := 0; i &lt; 100; i++ {
                printSlice(s)
                <span style="color: #a0522d;">s</span> = append(s, 2*i+1)
        }
        fmt.Println(s)

        // &#20854;&#23427;&#21019;&#24314;slice&#26041;&#27861;
        s1 := []int{2, 4, 6, 8}
        fmt.Println(s1) // [2 4 6 8]

        s2 := make([]int, 16)  // &#38271;&#24230;16&#30340;slice
        s3 := make([]int, 10, 32)  // &#38271;&#24230;16&#30340;slice&#65292;&#23481;&#37327;32
        fmt.Printf(<span style="color: #8b2252;">"%v, len=%d, cap=%d\n"</span>, s2, len(s2), cap(s2)) // [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], <span style="color: #a0522d;">len</span>=16, <span style="color: #a0522d;">cap</span>=16
        fmt.Printf(<span style="color: #8b2252;">"%v, len=%d, cap=%d\n"</span>, s3, len(s3), cap(s3)) //[0 0 0 0 0 0 0 0 0 0], <span style="color: #a0522d;">len</span>=10, <span style="color: #a0522d;">cap</span>=32
}

<span style="color: #a0522d;">len</span>=0, <span style="color: #a0522d;">cap</span>=0
<span style="color: #a0522d;">len</span>=1, <span style="color: #a0522d;">cap</span>=1
<span style="color: #a0522d;">len</span>=2, <span style="color: #a0522d;">cap</span>=2
<span style="color: #a0522d;">len</span>=3, <span style="color: #a0522d;">cap</span>=4
<span style="color: #a0522d;">len</span>=4, <span style="color: #a0522d;">cap</span>=4
<span style="color: #a0522d;">len</span>=5, <span style="color: #a0522d;">cap</span>=8
<span style="color: #a0522d;">len</span>=6, <span style="color: #a0522d;">cap</span>=8
<span style="color: #a0522d;">len</span>=7, <span style="color: #a0522d;">cap</span>=8
<span style="color: #a0522d;">len</span>=8, <span style="color: #a0522d;">cap</span>=8
<span style="color: #a0522d;">len</span>=9, <span style="color: #a0522d;">cap</span>=16
...
<span style="color: #a0522d;">len</span>=16, <span style="color: #a0522d;">cap</span>=16
<span style="color: #a0522d;">len</span>=17, <span style="color: #a0522d;">cap</span>=32
...
<span style="color: #a0522d;">len</span>=32, <span style="color: #a0522d;">cap</span>=32
<span style="color: #a0522d;">len</span>=33, <span style="color: #a0522d;">cap</span>=64
...
<span style="color: #a0522d;">len</span>=64, <span style="color: #a0522d;">cap</span>=64
<span style="color: #a0522d;">len</span>=65, <span style="color: #a0522d;">cap</span>=128
...
<span style="color: #a0522d;">len</span>=99, <span style="color: #a0522d;">cap</span>=128
</pre>
</div>
</div>
</div>
<div id="outline-container-org8aa8d38" class="outline-5">
<h5 id="org8aa8d38">内建copy函数</h5>
<div class="outline-text-5" id="text-org8aa8d38">
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #0000ff;">copy</span>(dstSlice, srcSlice)
</pre>
</div>
<p>
函数copy 在两个 slice 间复制数据，复制长度以 len 小为准备， 两个slice 可指向同一底层数组。
将 srcslice 复制到 dstslice
</p>

<p>
范例：内建copy函数
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #0000ff;">fmt.Println</span>(<span style="color: #8b2252;">"Copying slice"</span>)
// s1 := []int{2, 4, 6, 8}
// s2 := make([]int, 16)
<span style="color: #0000ff;">copy</span>(s2, s1)
<span style="color: #0000ff;">fmt.Println</span>(s2) // [2 4 6 8 0 0 0 0 0 0 0 0 0 0 0 0]
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc7cb16b" class="outline-5">
<h5 id="orgc7cb16b">切片元素删除</h5>
<div class="outline-text-5" id="text-orgc7cb16b">
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #0000ff;">fmt.Println</span>(<span style="color: #8b2252;">"Deleting elements from slice"</span>)
// &#31995;&#32479;&#27809;&#26377;&#20869;&#24314;&#20989;&#25968;
// &#21024;&#38500;&#20013;&#38388;&#30340;&#20803;&#32032;
<span style="color: #a0522d;">s2</span> = append(s2[:3], s2[4:]...) // &#21487;&#21464;&#21442;&#25968;&#29992;s2[4:]... &#25110;1,2,3,4
<span style="color: #0000ff;">fmt.Println</span>(s2) // [2 4 6 0 0 0 0 0 0 0 0 0 0 0 0] <span style="color: #a0522d;">len</span>=15, <span style="color: #a0522d;">cap</span>=16

<span style="color: #0000ff;">fmt.Println</span>(<span style="color: #8b2252;">"Popping from front/back"</span>)
// s2 := [2 4 6 0 0 0 0 0 0 0 0 0 0 0 0] <span style="color: #a0522d;">len</span>=15, <span style="color: #a0522d;">cap</span>=16
// &#21024;&#38500;&#22836;&#23614;&#30340;&#20803;&#32032;
front := s2[0]
<span style="color: #a0522d;">s2</span> = s2[1:]
tail := s2[len(s2) - 1]
<span style="color: #a0522d;">s2</span> = s2[:len(s2) - 1]
<span style="color: #0000ff;">fmt.Println</span>(front, tail) // 2, 0
<span style="color: #0000ff;">fmt.Println</span>(s2) // [4 6 0 0 0 0 0 0 0 0 0 0 0]
</pre>
</div>
</div>
</div>
<div id="outline-container-org3f38ea5" class="outline-5">
<h5 id="org3f38ea5">切片去重</h5>
<div class="outline-text-5" id="text-org3f38ea5">
<div class="org-src-container">
<pre class="src src-sh">func RemoveRep(s []int) []int {
    start := time.Now()
    result := []int{}
    m := make(map[int]bool) //map&#30340;&#20540;&#19981;&#37325;&#35201;
    <span style="color: #a020f0;">for</span> _, v := range s {
        <span style="color: #a020f0;">if</span> _, ok := m[v]; !ok {
            <span style="color: #a0522d;">result</span> = append(result, v)
            <span style="color: #a0522d;">m</span>[v] = true
        }
    }
    fmt.Println(<span style="color: #8b2252;">"&#33457;&#36153;&#26102;&#38388;:"</span>, fmt.Sprintf(<span style="color: #8b2252;">"%vms"</span>, (time.Now().UnixNano()-start.UnixNano())/1e+6))
    <span style="color: #a020f0;">return</span> result
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org369d76d" class="outline-3">
<h3 id="org369d76d">map</h3>
<div class="outline-text-3" id="text-org369d76d">
</div>
<div id="outline-container-org7093988" class="outline-4">
<h4 id="org7093988">map定义</h4>
<div class="outline-text-4" id="text-org7093988">
<div class="org-src-container">
<pre class="src src-sh">m := map[string]string {
    <span style="color: #8b2252;">"name"</span>: <span style="color: #8b2252;">"abc"</span>,
    <span style="color: #8b2252;">"course"</span>: <span style="color: #8b2252;">"golang"</span>,
}
</pre>
</div>
<ul class="org-ul">
<li>`map[K]V, map[K1]map[K2]V`  普通map和复合map，其中`map[K1]`的值为`map[K2]V`</li>
</ul>
</div>
</div>
<div id="outline-container-orgad72f11" class="outline-4">
<h4 id="orgad72f11">map的操作</h4>
<div class="outline-text-4" id="text-orgad72f11">
<ul class="org-ul">
<li>创建：`make(map[string]int)`</li>
<li>获取元素：`m[key]`</li>
<li>key不存在时，获得Value类型的初始值</li>
<li>用`value, ok := m[key]`来判断是否存在key</li>
<li>用内建delete函数删除一个key</li>
</ul>

<p>
范例：map操作
</p>
<div class="org-src-container">
<pre class="src src-sh">func main() {
    m := map[string]string{
        <span style="color: #8b2252;">"name"</span>:   <span style="color: #8b2252;">"abc"</span>,
        <span style="color: #8b2252;">"course"</span>: <span style="color: #8b2252;">"golang"</span>,
    }

    m2 := make(map[string]int)  // <span style="color: #a0522d;">m2</span> == empty map

    var m3 map[string]int // <span style="color: #a0522d;">m3</span> == nil

    fmt.Println(m, m2, m3) // map[course:golang name:abc] map[] map[]
    // <span style="color: #a0522d;">m3</span> == nil, <span style="color: #a0522d;">m2</span> == empty map  go&#35821;&#35328;&#30340;nil&#26159;&#21487;&#20197;&#21442;&#19982;&#36816;&#31639;&#30340;

    fmt.Println(<span style="color: #8b2252;">"Getting values"</span>)
    courseName:= m[<span style="color: #8b2252;">"course"</span>]
    fmt.Println(courseName)
    sssName, ok := m[<span style="color: #8b2252;">"sss"</span>]
    fmt.Println(sssName, ok) // key&#19981;&#23384;&#22312;&#26102;&#36820;&#22238;&#31354;&#20018;&#65292;zero value, &#21028;&#26029;key&#26159;&#21542;&#23384;&#22312;&#65292;&#36820;&#22238;false,true
    <span style="color: #a020f0;">if</span> sssName, ok := m[<span style="color: #8b2252;">"sss"</span>]; ok {
        fmt.Println(sssName, ok)
    } <span style="color: #a020f0;">else</span> {
        fmt.Println(<span style="color: #8b2252;">"Key does not exist"</span>) // Key does not exist
    }

    fmt.Println(<span style="color: #8b2252;">"Deleting values"</span>)
    name, ok := m[<span style="color: #8b2252;">"name"</span>]
    fmt.Println(name, ok) // abc true
    delete(m, <span style="color: #8b2252;">"name"</span>)
    name, <span style="color: #a0522d;">ok</span> = m[<span style="color: #8b2252;">"name"</span>]
    fmt.Println(name, ok) //  false
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org9fd0197" class="outline-4">
<h4 id="org9fd0197">map的遍历</h4>
<div class="outline-text-4" id="text-org9fd0197">
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #0000ff;">fmt.Println</span>(<span style="color: #8b2252;">"Traversing map"</span>)
<span style="color: #a020f0;">for</span> k, v := range m { // for k:= range m { &#36824;&#21487;&#20197; for _, v := range m {
    fmt.Println(k, v)
}
//key&#22312;map&#20013;&#26159;&#26080;&#24207;&#30340;
</pre>
</div>
<ul class="org-ul">
<li>使用range遍历key，或者遍历key，value对</li>
<li>不保证遍历顺序，如需顺序，需要手动对key排序，key加到slice对slice排序</li>
<li>使用len获得元素个数</li>
</ul>
</div>
</div>
<div id="outline-container-org439b052" class="outline-4">
<h4 id="org439b052">map的key</h4>
<div class="outline-text-4" id="text-org439b052">
<p>
什么类型能做为map的key？
</p>
<ul class="org-ul">
<li>map使用哈希表，必须可以比较相等</li>
<li>除了slice, map, function的内建类型都可以作为key</li>
<li>struct类型不包含上述字段，也可作为key</li>
</ul>

<p>
map的用途非常广泛，下面举一个复杂的示例
</p>
</div>
</div>
<div id="outline-container-org626c531" class="outline-4">
<h4 id="org626c531">范例：寻找最长不含有重复字符的子串长度(leetcode)</h4>
<div class="outline-text-4" id="text-org626c531">
<p>
<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/</a>
</p>
<ul class="org-ul">
<li>abcabcbb -&gt; abc 3</li>
<li>bbbb -&gt; b 1</li>
<li>pwwkew -&gt; wke 3</li>
</ul>

<p>
一个字符串，假设从左向右扫描一遍就可以了，这时假设扫描到x位置，看到一个字母x。
</p>
<ul class="org-ul">
<li>先记录一个start，表示当前找到的最长不含有重复字符的子串的开始，当前有效答案的开始
至少能保证start到x之前的子串是不含有重复字符的</li>
<li>看到x，就要去看从start到x-1位置之间有没有x
<ul class="org-ul">
<li>记录`lastoccurred[x]`表示x最后出现的位置，最后出现的位置我们问map，它会有2种情况
<ul class="org-ul">
<li>`lastOccurred[x]`不存在在，或者出现在`start`之前，那么就无需操作</li>
<li>`lastOccurred[x]`出现在start和x中间，就不能做为最长子串了，就更新start，把start指向`lastOccurred[x] + 1`的位置</li>
</ul></li>
</ul></li>
</ul>
<p>
思路：对于每个字母x
</p>
<ul class="org-ul">
<li>`lastOccurred[x]`不存在，或者小于`&lt; start`无需操作</li>
<li>`lastoccurred[x] &gt;= start`，则更新start, start指向到`lastoccurred[x] + 1`的位置</li>
<li>更新`lastoccurred[x]`，更新`maxLength`</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">package main

import <span style="color: #8b2252;">"fmt"</span>

func lengthOfNonRepeatingSubStr(s string) int {
        lastOccurred := make(map[byte]int) // &#27599;&#20010;&#23383;&#27597;&#26368;&#21518;&#20986;&#29616;&#30340;&#20301;&#32622;
        start := 0                         // &#24403;&#21069;&#25214;&#21040;&#30340;&#26368;&#38271;&#19981;&#21547;&#26377;&#23383;&#31526;&#30340;&#23376;&#20018;&#24320;&#22987;
        maxLength := 0                     // &#37325;&#22797;&#23376;&#20018;&#30340;&#26368;&#22823;&#38271;&#24230;
        // &#36941;&#21382;&#23383;&#31526;&#20018;
        <span style="color: #a020f0;">for</span> i, ch := range []byte(s) {

                <span style="color: #a020f0;">if</span> lastI, ok := lastOccurred[ch]; ok &amp;&amp; lastI &gt;= start { // lastOccurred[ch]&#21487;&#33021;&#26159;&#19981;&#23384;&#22312;&#30340;&#23427;&#30340;&#20540;&#26159;0&#65292;0&#21442;&#19982;&#19979;&#38754;&#30340;&#36816;&#31639;&#26159;&#19981;&#23545;&#30340;
                        <span style="color: #a0522d;">start</span> = lastOccurred[ch] + 1
                }

                <span style="color: #a020f0;">if</span> i-start+1 &gt; maxLength { // &#26356;&#26032;maxLength
                        <span style="color: #a0522d;">maxLength</span> = i - start + 1
                }

                <span style="color: #a0522d;">lastOccurred</span>[ch] = i
        }

        <span style="color: #a020f0;">return</span> maxLength
}

func main() {
        fmt.Println(
                lengthOfNonRepeatingSubStr(<span style="color: #8b2252;">"abcabcbb"</span>)) // 3
        fmt.Println(
                lengthOfNonRepeatingSubStr(<span style="color: #8b2252;">"bbbb"</span>)) // 1

}

</pre>
</div>
<p>
对于汉字，用rune
</p>
</div>
</div>
</div>
<div id="outline-container-org504e575" class="outline-3">
<h3 id="org504e575">字符串</h3>
<div class="outline-text-3" id="text-org504e575">
</div>
<div id="outline-container-orgc8c15bc" class="outline-4">
<h4 id="orgc8c15bc">rune相当于go的char</h4>
<div class="outline-text-4" id="text-orgc8c15bc">
<p>
go语言处理中文的关键就在于理解rune类型。rune相当于go的char
</p>
</div>
<div id="outline-container-org70cbb1a" class="outline-5">
<h5 id="org70cbb1a">如何利用rune</h5>
<div class="outline-text-5" id="text-org70cbb1a">
<div class="org-src-container">
<pre class="src src-sh">package main

<span style="color: #0000ff;">import</span> (
        <span style="color: #8b2252;">"fmt"</span>
        <span style="color: #8b2252;">"unicode/utf8"</span>
)

func main() {
        s := <span style="color: #8b2252;">"Yes&#25105;&#29233;&#20114;&#32852;&#32593;"</span>        // UTF-8 &#21487;&#21464;&#38271;&#32534;&#30721;
        fmt.Println(len(s), s) // &#23383;&#31526;&#20018;&#38271;&#24230; 18

        // &#26597;&#30475;s&#21407;&#22987;&#23383;&#33410;&#65292;&#30475;&#26159;&#22914;&#20309;&#23384;&#20648;&#30340;
        fmt.Printf(<span style="color: #8b2252;">"%X\n"</span>, []byte(s)) // 596573E68891E788B1E4BA92E88194E7BD91
        <span style="color: #a020f0;">for</span> _, b := range []byte(s) {
                fmt.Printf(<span style="color: #8b2252;">"%X "</span>, b) // &#25105;&#26159;UTF-8&#32534;&#30721; E6 88 91
        }
        fmt.Println() // &#21487;&#20197;&#30475;&#21040;&#27599;&#20010;&#20013;&#25991;&#21344;3&#20010;&#23383;&#33410;&#65292;&#33521;&#25991;&#23383;&#27597;&#21344;1&#20010;&#23383;&#33410;&#65292;&#36825;&#26159;UTF-8 &#21487;&#21464;&#38271;&#32534;&#30721;

        <span style="color: #a020f0;">for</span> i, ch := range s { // ch is a rune &#12290;
                fmt.Printf(<span style="color: #8b2252;">"(%d %X) "</span>, i, ch) // unicode&#32534;&#30721;&#65292;&#25105;&#26159;4&#20010;&#23383;&#33410; (3 6211)&#65292;&#21482;&#26377;&#21518;&#38754;2&#20010;&#23383;&#33410;&#26159;&#26377;&#23383;&#30340;
        }
        fmt.Println()
        // &#23558;string&#20570;utf-8&#30340;&#35299;&#30721;&#65292;&#35299;&#20986;&#26469;&#27599;&#19968;&#20010;&#23383;&#31526;&#36716;unicode&#65292;&#20877;&#23558;unicode&#25918;&#21040;rune&#31867;&#22411;&#20013;

        // &#21033;&#29992;utf-8&#24211;&#24110;&#21161;&#29702;&#35299;string
        fmt.Println(<span style="color: #8b2252;">"Rune count:"</span>,
                utf8.RuneCountInString(s)) // Rune count: 8

        bytes := []byte(s) // &#25343;&#21040;s&#30340;&#23383;&#33410;

        <span style="color: #a020f0;">for</span> len(bytes) &gt; 0 {
                ch, size := utf8.DecodeRune(bytes) // &#25343;&#21040;&#23383;&#31526;&#21644;&#38271;&#24230; &#20989;&#25968;&#35299;&#30721;p&#24320;&#22987;&#20301;&#32622;&#30340;&#31532;&#19968;&#20010;utf-8&#32534;&#30721;&#30340;&#30721;&#20540;&#65292;&#36820;&#22238;&#35813;&#30721;&#20540;&#21644;&#32534;&#30721;&#30340;&#23383;&#33410;&#25968;&#12290;
                <span style="color: #a0522d;">bytes</span> = bytes[size:]
                fmt.Printf(<span style="color: #8b2252;">"%c "</span>, ch)
        }
        fmt.Println()

        <span style="color: #a020f0;">for</span> i, ch := range []rune(s) { // &#36716;&#25104;rune&#30340;silce&#23601;&#33021;&#33719;&#21462;&#23545;&#24212;&#20013;&#25991;&#19979;&#26631;&#20540;
                fmt.Printf(<span style="color: #8b2252;">"(%d %c) "</span>, i, ch)
        }
}

<span style="color: #b22222;"># </span><span style="color: #b22222;">&#36755;&#20986;
</span>PS D:\project\goproject\src\test&gt; go run .\strings.go
18 Yes&#25105;&#29233;&#20114;&#32852;&#32593;
596573E68891E788B1E4BA92E88194E7BD91
59 65 73 E6 88 91 E7 88 B1 E4 BA 92 E8 81 94 E7 BD 91
(0 59) (1 65) (2 73) (3 6211) (6 7231) (9 4E92) (12 8054) (15 7F51)
Rune count: 8
Y e s &#25105; &#29233; &#20114; &#32852; &#32593;
(0 Y) (1 e) (2 s) (3 &#25105;) (4 &#29233;) (5 &#20114;) (6 &#32852;) (7 &#32593;)
</pre>
</div>

<ul class="org-ul">
<li>使用range遍历pos，rune对
下标值英文是连续的，中文下标值每次都加3，加3的值对我们用处不大</li>
<li>使用utf8.RunecountInString获得字符数量</li>
<li>使用len只能获得字节数</li>
<li>使用`[]byte`获得字节</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge58698e" class="outline-4">
<h4 id="orge58698e">其他字符操作</h4>
<div class="outline-text-4" id="text-orge58698e">
<ul class="org-ul">
<li>Filds, Split, Join
Filds认空格的，Split按分割符分割，Join把slice字符串拼接</li>
<li>Contains, Index
Contains判断是否包含子串，Index查找子串所在字符位置</li>
<li>Repeat, Replace
重复，替换</li>
<li>ToLower, ToUpper</li>
<li>Trim, TrimRight, TrimLeft
Trim首尾去除字符</li>
</ul>
</div>
</div>
</div>
</section>
<section id="outline-container-orge46ca2f" class="outline-2">
<h2 id="orge46ca2f">面向对象</h2>
<div class="outline-text-2" id="text-orge46ca2f">
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #483d8b;">type</span> TreeNode struct {
    Left, Right *TreeNode
    Value int
}

<span style="color: #0000ff;">func</span> (root *TreeNode) traverse() {
    <span style="color: #a020f0;">if</span> <span style="color: #a0522d;">root</span> == nil {
         <span style="color: #a020f0;">return</span>
    }

    root.Left.traverse()
    fmt.Print(root.Value)
    root.Right.traverse()
}

</pre>
</div>

<p>
使用面向对象，我们能够从代码片段做出一些更佳大的系统来，面向对象能做出这些大型系统的零部件。
比如上面TreeNode就是一个零部分，还给TreeNode定义了一个travese方法。
</p>

<ul class="org-ul">
<li>go语言仅支持封装，不支持继承和多态
在c/c++中继承和多态理解起来都比较麻烦，用起来也有限制，go语言设计者看到了这些，继承和多态用接口来做，面向接口编程</li>
<li>go语言没有class，只有struct</li>
</ul>
</div>
<div id="outline-container-orge2842e0" class="outline-3">
<h3 id="orge2842e0">结构体和方法</h3>
<div class="outline-text-3" id="text-orge2842e0">
</div>
<div id="outline-container-orgc66dc24" class="outline-4">
<h4 id="orgc66dc24">结构的定义</h4>
<div class="outline-text-4" id="text-orgc66dc24">
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #483d8b;">type</span> TreeNode struct {
    Left, Right *TreeNode
    value int
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org24dd58b" class="outline-4">
<h4 id="org24dd58b">结构体的创建</h4>
<div class="outline-text-4" id="text-org24dd58b">
<div class="org-src-container">
<pre class="src src-sh">root := treeNode{value: 3}
root.Left = &amp;treeNode{}
root.Right = &amp;treeNode{nil, nil, 5}
root.Right.Left = new(treeNode)
</pre>
</div>
<ul class="org-ul">
<li><p>
不论地址还是结构本身，一律使用"."来访问成员
go语言提供了以上多种创建方法不需要有构造函数的方法。如果要控制其构造可以加“工厂函数”
“工厂函数”就是一些普通的函数
</p>

<div class="org-src-container">
<pre class="src src-sh">func creatNode(value int) *TreeNode {
    <span style="color: #a020f0;">return</span> &amp;TreeNode{value: value} // &#23616;&#37096;&#21464;&#37327;&#20063;&#20250;&#36820;&#22238;&#32473;&#21035;&#20154;&#29992;&#30340;&#12290;&#22914;&#22312;c++&#20013;&#23601;&#19981;&#34892;
}

root.Left.Right = creatNode(2) // &#21033;&#29992;&#33258;&#23450;&#20041;&#24037;&#21378;&#20989;&#25968;&#26500;&#36896;&#32467;&#26500;
</pre>
</div></li>
<li>使用自定义工厂函数</li>
<li>注意返回了局部变量的地址</li>
</ul>

<p>
范例：结构的创建
</p>
<div class="org-src-container">
<pre class="src src-sh">package main

import <span style="color: #8b2252;">"fmt"</span>

<span style="color: #483d8b;">type</span> treeNode struct {

    value       int
    left, right *treeNode
}

func creatNode(value int) *treeNode {
    <span style="color: #a020f0;">return</span> &amp;treeNode{value: value}
}

func main() {
    // &#32467;&#26500;&#20307;&#30340;&#21019;&#24314;
    var root treeNode //{0 &lt;nil&gt; &lt;nil&gt;}

    <span style="color: #a0522d;">root</span> = treeNode{value: 3}
    root.left = &amp;treeNode{}
    root.right = &amp;treeNode{5, nil, nil}
    root.right.left = new(treeNode) // root.right&#21518;&#20063;&#21487;&#20197;&#29992;<span style="color: #8b2252;">"."</span>&#28857;&#21495;&#65292;
    root.left.right = creatNode(2) // &#21033;&#29992;&#33258;&#23450;&#20041;&#24037;&#21378;&#20989;&#25968;&#26500;&#36896;&#32467;&#26500;

    nodes := []treeNode { // &#22312;slice&#20013;&#21487;&#20197;&#30465;&#30053;treeNode&#23383;&#20889;&#27861;
        {value: 3},
        {},
        {6, nil, &amp;root},
    }
    fmt.Println(nodes) // [{3 &lt;nil&gt; &lt;nil&gt;} {0 &lt;nil&gt; &lt;nil&gt;} {6 &lt;nil&gt; 0xc000004078}]
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgaa3e3d5" class="outline-4">
<h4 id="orgaa3e3d5">结构创建在堆上还是栈上？</h4>
<div class="outline-text-4" id="text-orgaa3e3d5">
<p>
像c++局部变量是分布在栈上的，函数退出局部变量就会被立即销毁，如果要传出去必须在堆上分配，堆上分配必须手动释放。
像java几乎所有都分配在堆上的，必须有垃圾回收机制
</p>

<p>
go语言结构创建在堆上还是栈上？
</p>
<ul class="org-ul">
<li>不需要知道
编译器自动判断</li>
</ul>
</div>
</div>
<div id="outline-container-orge318e57" class="outline-4">
<h4 id="orge318e57">为结构定义方法</h4>
<div class="outline-text-4" id="text-orge318e57">
<p>
有个接收者
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #0000ff;">func</span> (node TreeNode) <span style="color: #483d8b;">print</span>() {
    fmt.Print(node.value)
}
</pre>
</div>
<ul class="org-ul">
<li>显示定义和命令名方法接收者
函数前面“()”括号是接收者，接收者的类型和名字都是显示定义的</li>
</ul>
</div>
<div id="outline-container-orge48a3c8" class="outline-5">
<h5 id="orge48a3c8">使用指针作为方法的接收者</h5>
<div class="outline-text-5" id="text-orge48a3c8">
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #0000ff;">func</span> (node *TreeNode) setValue(value int) {
    node.Value = value
}
</pre>
</div>

<ul class="org-ul">
<li>只有使用指针才可以改变结构内容</li>
<li>nil指针也可以调用方法</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#32467;&#26500;&#20307;&#26159;nil&#25351;&#38024;&#20063;&#21487;&#20197;&#35843;&#29992;&#26041;&#27861;
</span><span style="color: #483d8b;">type</span> treeNode struct {
    value       int
    left, right *treeNode
}

<span style="color: #0000ff;">func</span> (node treeNode) <span style="color: #483d8b;">print</span>() {
    fmt.Print(node.value, <span style="color: #8b2252;">" "</span>)
}

<span style="color: #0000ff;">func</span> (node *treeNode) setValue(value int) {
    <span style="color: #a020f0;">if</span> <span style="color: #a0522d;">node</span> == nil {
        fmt.Println(<span style="color: #8b2252;">"Setting value to nil node. Ignored."</span>)
        <span style="color: #a020f0;">return</span> // &#22914;&#26524;node&#26159;nil&#25351;&#38024;&#65292;&#25343;&#20869;&#37096;&#20540;&#26159;&#25343;&#19981;&#21040;&#30340;&#65292;&#20250;&#25253;&#38169;&#65292;&#25152;&#20197;&#35201;return&#36820;&#22238;
    }
    node.value = value
}

func main() {

    var pRoot *treeNode
    pRoot.setValue(200) // &#32467;&#26500;&#20307;&#26159;nil&#25351;&#38024;&#20063;&#21487;&#20197;&#35843;&#29992;&#26041;&#27861;
    <span style="color: #a0522d;">pRoot</span> = &amp;root
    pRoot.setValue(300)
    pRoot.print()
}
</pre>
</div>

<p>
范例：为结构定义方法
</p>
<div class="org-src-container">
<pre class="src src-sh">package main

import <span style="color: #8b2252;">"fmt"</span>

<span style="color: #483d8b;">type</span> treeNode struct {

    value       int
    left, right *treeNode
}

// &#23450;&#20041;&#32467;&#26500;&#30340;&#26041;&#27861;
<span style="color: #0000ff;">func</span> (node treeNode) <span style="color: #483d8b;">print</span>() { //&#20540;&#20256;&#36882; &#22312;&#20989;&#25968;&#21069;&#38754;&#28155;&#21152;&#20102;(node treeNode)&#25509;&#25910;&#32773;&#65292;&#21644;print(node treeNode)&#30456;&#24403;
    fmt.Print(node.value, <span style="color: #8b2252;">" "</span>)
}

<span style="color: #0000ff;">func</span> (node *treeNode) setValue(value int) { // &#24341;&#29992;&#20256;&#36882;
    node.value = value
}

func creatNode(value int) *treeNode {
    <span style="color: #a020f0;">return</span> &amp;treeNode{value: value}
}

func main() {
    // &#32467;&#26500;&#20307;&#30340;&#21019;&#24314;
    var root treeNode //{0 &lt;nil&gt; &lt;nil&gt;}

    <span style="color: #a0522d;">root</span> = treeNode{value: 3}
    root.left = &amp;treeNode{}
    root.right = &amp;treeNode{5, nil, nil}
    root.right.left = new(treeNode) // root.right&#21518;&#20063;&#21487;&#20197;&#29992;<span style="color: #8b2252;">"."</span>&#28857;&#21495;&#65292;
    root.left.right = creatNode(2) // &#21033;&#29992;&#33258;&#23450;&#20041;&#24037;&#21378;&#20989;&#25968;&#26500;&#36896;&#32467;&#26500;

    // &#32467;&#26500;&#26041;&#27861;&#30340;&#20351;&#29992;
    root.print() // 3 &#20854;&#20013;print&#26159;&#20010;&#20989;&#25968;&#65292;&#23427;&#19981;&#26159;&#26080;&#21442;&#30340;&#65292;&#23427;&#26377;&#20010;&#25509;&#25910;&#32773;root

    root.right.left.setValue(4) // setValue&#20989;&#25968;&#20250;&#25226;&#25509;&#25910;&#32773;root.right.left&#30340;&#22320;&#22336;&#20570;&#21442;&#25968;&#20256;&#36882;&#36807;&#21435;
    root.right.left.print() // print&#20989;&#25968;&#20250;&#25226;&#25509;&#25910;&#32773;root.right.left&#35299;&#26512;&#20986;&#26469;&#25335;&#36125;&#19968;&#20221;&#20570;&#21442;&#25968;&#20256;&#36882;&#36807;&#21435;
    fmt.Println()

    root.print()  // &#20540;&#20256;&#36882;
    root.setValue(100) // &#24341;&#29992;&#20256;&#36882;&#65292;&#25351;&#38024;&#24341;&#29992;

    pRoot := &amp;root
    pRoot.print()
    pRoot.setValue(200)
    pRoot.print()
}
</pre>
</div>

<p>
范例：遍历树
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #0000ff;">func</span> (node *treeNode) traverse() {
    <span style="color: #a020f0;">if</span> <span style="color: #a0522d;">node</span> == nil { // &#21028;&#26029; &#31354;&#26641; &#30340;&#24773;&#20917;
        <span style="color: #a020f0;">return</span>
    }

    node.left.traverse() //&#20808;&#36941;&#21382;&#24038;&#23376;&#26641; &#20351;&#29992;traverse&#20989;&#25968;&#23558;&#25509;&#25910;&#32773;node.left&#20570;&#20026;&#21442;&#25968;&#20256;&#36882;&#36807;&#21435;
    node.print()
    node.right.traverse() // &#36941;&#21382;&#21491;&#23376;&#26641;
}

<span style="color: #0000ff;">root.traverse</span>()
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org6d63011" class="outline-4">
<h4 id="org6d63011">值接收者 vs 指针接收者的选择</h4>
<div class="outline-text-4" id="text-org6d63011">
<ul class="org-ul">
<li>要改变内容必须使用指针接收者
值接收者只是个拷贝</li>
<li>结构过大也考虑使用指针接收者 (性能问题)</li>
<li>一致性：如果有指针接收者，最好都是指针接收者（建议，这样看起来简单些，不混乱）</li>
</ul>

<p>
和其它语言比怎样？
</p>
<ul class="org-ul">
<li>值接收者 是go语言特有
指针接收者其它语言都有，c++ dec指针，python的self</li>
<li>值/指针接收者均可接收值/指针</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgba1e322" class="outline-3">
<h3 id="orgba1e322">包和封装</h3>
<div class="outline-text-3" id="text-orgba1e322">
<p>
定义完方法后，我们得看看怎么将这些方法封装
</p>
</div>
<div id="outline-container-orgc1872ac" class="outline-4">
<h4 id="orgc1872ac">封装</h4>
<div class="outline-text-4" id="text-orgc1872ac">
<p>
方法有些可见有些可见，有些不可见，如何实现
</p>

<ul class="org-ul">
<li>名字一般使用CamelCase
go语言是通过函数的命名来做的，一般使用CamelCase，而不使用全小写的"_"下划线形式</li>
<li>首字母大写：public  公用</li>
<li>首字母小写：private 私有</li>
</ul>
<p>
public/private是针对包来说的
</p>
</div>
</div>
<div id="outline-container-org73cea0c" class="outline-4">
<h4 id="org73cea0c">包</h4>
<div class="outline-text-4" id="text-org73cea0c">
<p>
还记得每个程序上方都要写`package main`，这就是包。包远远不只main，main只是个入口
真正的代码都要写在各自的包里面。
</p>

<p>
包是如何分的？
</p>
<ul class="org-ul">
<li>每个目录一个包
包名不一定和目录名一样，但每个目录只能有一个包</li>
<li>main包包含可执行入口
里面有一个main函数</li>
<li>为结构定义的方法必须放在同一个包内，但可以是不同的文件</li>
</ul>

<p>
范例：包的使用
</p>
<div class="org-src-container">
<pre class="src src-sh">&#9492;&#9472;tree
    &#9474;  traversal.go // tree&#21253;&#65292;&#38656;&#35201;&#22806;&#37096;&#24341;&#29992;&#30340;&#26041;&#27861;&#12289;&#21464;&#37327;&#23601;&#22823;&#20889;
    &#9474;  tree.go      // tree&#21253;
    &#9474;
    &#9492;&#9472;entry          // main&#21253;&#30446;&#24405;
            entry.go // &#24341;&#29992;tree&#21253;&#20989;&#25968;&#65292;&#24341;&#29992;tree.TreeNode&#19981;&#29992;&#37325;&#22797;&#21253;&#21517;&#65292;&#32467;&#26500;&#20307;&#21487;&#25913;&#20026;Node&#65292;tree.Node&#24341;&#29992;&#23601;&#22909;

<span style="color: #b22222;"># </span><span style="color: #b22222;">entry.go&#20869;&#23481;
</span>package main

import <span style="color: #8b2252;">"test/tree"</span>

func main() {
    // &#32467;&#26500;&#20307;&#30340;&#21019;&#24314;
    var root tree.Node //{0 &lt;nil&gt; &lt;nil&gt;}

    <span style="color: #a0522d;">root</span> = tree.Node{Value: 3}
    root.Left = &amp;tree.Node{}
    root.Right = &amp;tree.Node{5, nil, nil}
    root.Right.Left = new(tree.Node) // root.right&#21518;&#20063;&#21487;&#20197;&#29992;<span style="color: #8b2252;">"."</span>&#28857;&#21495;&#65292;
    root.Left.Right = tree.CreatNode(2)  // &#21033;&#29992;&#33258;&#23450;&#20041;&#24037;&#21378;&#20989;&#25968;&#26500;&#36896;&#32467;&#26500;
    // &#32467;&#26500;&#26041;&#27861;&#30340;&#20351;&#29992;
    root.Print()                // 3 &#20854;&#20013;print&#26159;&#20010;&#20989;&#25968;&#65292;&#23427;&#19981;&#26159;&#26080;&#21442;&#30340;&#65292;&#23427;&#26377;&#20010;&#25509;&#25910;&#32773;root
    root.Right.Left.SetValue(4) // setValue&#20989;&#25968;&#20250;&#25226;&#25509;&#25910;&#32773;root.right.left&#30340;&#22320;&#22336;&#20570;&#21442;&#25968;&#20256;&#36882;&#36807;&#21435;

    root.Traverse()
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf95e889" class="outline-3">
<h3 id="orgf95e889">扩展已有类型</h3>
<div class="outline-text-3" id="text-orgf95e889">
<p>
如何扩充系统类型或者别人的类型
有2种方法
</p>
<ul class="org-ul">
<li>定义别名</li>
<li>使用组合</li>
</ul>
</div>
<div id="outline-container-orge6b10df" class="outline-4">
<h4 id="orge6b10df">定义别名</h4>
<div class="outline-text-4" id="text-orge6b10df">
<p>
范例：实现一个队列
</p>
<div class="org-src-container">
<pre class="src src-sh">package queue

<span style="color: #483d8b;">type</span> Queue []int // &#23450;&#20041;&#21035;&#21517;&#65292;&#25193;&#23637;&#24050;&#26377;&#31867;&#22411;

<span style="color: #0000ff;">func</span> (q *Queue) Push(v int) {
    *<span style="color: #a0522d;">q</span> = append(*q, v)
}

<span style="color: #0000ff;">func</span> (q *Queue) Pop() int {
    head := (*q)[0]
    *<span style="color: #a0522d;">q</span> = (*q)[1:]
    <span style="color: #a020f0;">return</span> head
}

<span style="color: #0000ff;">func</span> (q *Queue) IsEmpty() bool {
    <span style="color: #a020f0;">return</span> len(*q) == 0
}

<span style="color: #b22222;">#</span><span style="color: #b22222;">main&#21253;
</span>func main() {
    q := queue.Queue{1}

    q.Push(2)
    q.Push(3)
    fmt.Println(q.Pop())
    fmt.Println(q.Pop())
    fmt.Println(q.IsEmpty())
    fmt.Println(q.Pop())
    fmt.Println(q.IsEmpty())
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc0c2787" class="outline-4">
<h4 id="orgc0c2787">使用组合</h4>
<div class="outline-text-4" id="text-orgc0c2787">
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #0000ff;">import</span> (
    <span style="color: #8b2252;">"fmt"</span>
    <span style="color: #8b2252;">"test/tree"</span>
)

<span style="color: #483d8b;">type</span> myTreeNode struct { // &#37319;&#29992;&#32452;&#21512;&#26041;&#24335;&#65292;&#25193;&#23637;&#24050;&#26377;&#31867;&#22411;
    node *tree.Node
}

// &#23450;&#20041;&#19968;&#20010;&#21518;&#32493;&#36941;&#21382;&#30340;&#20989;&#25968;
<span style="color: #0000ff;">func</span> (myNode *myTreeNode) postOrder() {
    <span style="color: #a020f0;">if</span> <span style="color: #a0522d;">myNode</span> == nil || myNode.node == nil {
        <span style="color: #a020f0;">return</span>
    }

    left := myTreeNode{myNode.node.Left}
    right := myTreeNode{myNode.node.Right}

    left.postOrder()
    right.postOrder()
    myNode.node.Print()
}

myRoot := myTreeNode{&amp;root}
</pre>
</div>
</div>
</div>
<div id="outline-container-orge21b9d1" class="outline-4">
<h4 id="orge21b9d1">使用内嵌来扩展已有类型</h4>
<div class="outline-text-4" id="text-orge21b9d1">
<p>
使用embedding(内嵌)方式扩展已有类型
</p>

<p>
范例：
</p>
<div class="org-src-container">
<pre class="src src-sh">package main

<span style="color: #0000ff;">import</span> (
    <span style="color: #8b2252;">"fmt"</span>
    <span style="color: #8b2252;">"test/tree"</span>
)

<span style="color: #483d8b;">type</span> myTreeNode struct {
    // node *tree.Node
    *tree.Node // Embedding &#20869;&#23884;&#31867;&#22411;&#65292;&#21487;&#20197;&#25226;node&#23383;&#27573;&#30465;&#25481;&#12290;&#22909;&#22788;&#26159;&#36825;&#20010;&#26159;&#20010;&#35821;&#27861;&#22530;&#33021;&#30465;&#19979;&#20195;&#30721;&#37327;&#65292;&#30475;&#36215;&#26469;&#31616;&#27905;&#20123;
    // &#40664;&#35748;&#30340;&#21517;&#23383;&#26159;tree.&#21518;&#38754;&#28857;&#20986;&#30340;&#19996;&#35199;&#12290;&#36825;&#37324;&#26159;Node
    // &#30456;&#24403;&#20110;&#25226;tree.Node&#30340;&#25104;&#21592;&#21464;&#37327;&#20840;&#37117;&#25289;&#20986;&#26469;&#65292;&#38138;&#22312;myTreeNode&#30340;&#32467;&#26500;&#37324;&#12290;
    // &#37324;&#38754;&#30340;&#21464;&#37327;&#21644;&#26041;&#27861;&#37117;&#33021;&#30452;&#25509;<span style="color: #8b2252;">"."</span>&#28857;&#20986;&#26469;&#20351;&#29992;
}


<span style="color: #0000ff;">func</span> (myNode *myTreeNode) postOrder() {
    <span style="color: #a020f0;">if</span> <span style="color: #a0522d;">myNode</span> == nil || myNode.Node == nil {
        <span style="color: #a020f0;">return</span>
    }

    left := myTreeNode{myNode.Left}
    right := myTreeNode{myNode.Right}

    left.postOrder()
    right.postOrder()
    myNode.Print()
}

// &#37325;&#36733;&#20989;&#25968;
<span style="color: #0000ff;">func</span> (myNode *myTreeNode) Traverse() {
    fmt.Println(<span style="color: #8b2252;">"This method is shadowed"</span>)
}

func main() {
    root := myTreeNode{&amp;tree.Node{Value: 3}} // &#30452;&#25509;&#25226;tree.Node&#20013;&#30340;&#21464;&#37327;&#21644;&#26041;&#27861;&#37117;&#33021;&#25289;&#19978;&#26469;
    root.Left = &amp;tree.Node{}
    root.Right = &amp;tree.Node{5, nil, nil}
    root.Right.Left = new(tree.Node)
    root.Left.Right = tree.CreatNode(2)
    root.Right.Left.SetValue(4)

    fmt.Print(<span style="color: #8b2252;">"In-order traversal: "</span>)
    root.Traverse() // &#37325;&#36733;&#20102;&#20989;&#25968;
    root.Node.Traverse() // &#20351;&#29992;&#21407;&#22987;&#36941;&#21382;

    fmt.Print(<span style="color: #8b2252;">"\nMy own post-order traversal: "</span>)
    root.postOrder()
    fmt.Println()

    //&#23376;&#31867;&#36171;&#20540;&#32473;&#22522;&#31867;&#26159;&#36890;&#36807;&#25509;&#21475;&#23454;&#29616;&#30340;&#65292;&#19981;&#26159;&#36890;&#36807;&#31867;&#30340;&#32487;&#25215;&#26469;&#23454;&#29616;&#30340;
    var baseRoot *tree.Node
    baseRoot := &amp;root // &#25253;&#38169;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org28e03a9" class="outline-4">
<h4 id="org28e03a9">小结</h4>
<div class="outline-text-4" id="text-org28e03a9">
<p>
如何扩充系统类型或者别人的类型
</p>
<ul class="org-ul">
<li>定义别名：最简单
再转成使用组合就要改很多代码，不能从别名到组合做无缝转换</li>
<li>使用组合：最常用</li>
<li>使用内嵌：需要省下许多代码时，考虑使用
是个语法堂能省下代码量，看起来简洁些。
写代码熟练的人比较能看懂，新手看没那么直观</li>
</ul>
</div>
</div>
</div>
</section>
<section id="outline-container-orgb3ec00d" class="outline-2">
<h2 id="orgb3ec00d">项目管理</h2>
<div class="outline-text-2" id="text-orgb3ec00d">
</div>
<div id="outline-container-org3c5e50c" class="outline-3">
<h3 id="org3c5e50c">依赖管理</h3>
<div class="outline-text-3" id="text-org3c5e50c">
<ul class="org-ul">
<li>依赖的概念</li>
<li>依赖管理经历的三个阶段 GOPATH, GOVENDOR, go mod</li>
</ul>
</div>
</div>
<div id="outline-container-org33a35a3" class="outline-3">
<h3 id="org33a35a3">GOPATH和GOVENDOR</h3>
<div class="outline-text-3" id="text-org33a35a3">
</div>
<div id="outline-container-org9612985" class="outline-4">
<h4 id="org9612985">GOPATH</h4>
<div class="outline-text-4" id="text-org9612985">
<ul class="org-ul">
<li>默认在`~/go(unix, linux), %USERPROFILE%\go(windows)`</li>
</ul>

<p>
所有项目都放在GOPATH/src下，自己的项目第三方依赖都在这里，会导致项目非常大
</p>

<p>
范例：使用GOPATH管理依赖
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #483d8b;">export</span> <span style="color: #a0522d;">GO111MODULE</span>=off
<span style="color: #483d8b;">export</span> <span style="color: #a0522d;">GOPATH</span>=~/tmp/goproject
</pre>
</div>
<p>
项目依赖会从GOROOT，GOPATH中找
</p>
</div>
</div>
<div id="outline-container-org852c000" class="outline-4">
<h4 id="org852c000">GOVENDOR</h4>
<div class="outline-text-4" id="text-org852c000">
<ul class="org-ul">
<li>每个项目有自己的vendor目录，存放第三方库</li>
<li>大量第三方依赖管理工具：glide, dep, go dep, &#x2026;</li>
</ul>

<p>
范例：使用GOPATH管理依赖，并在项目目录中创建vendor目录，存放不同版本的依赖
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #483d8b;">export</span> <span style="color: #a0522d;">GO111MODULE</span>=off
<span style="color: #483d8b;">export</span> <span style="color: #a0522d;">GOPATH</span>=~/tmp/goproject
</pre>
</div>
<p>
项目依赖会从GOROOT，GOPATH，vendor tree中找
</p>
</div>
</div>
</div>
<div id="outline-container-orgd7cbf79" class="outline-3">
<h3 id="orgd7cbf79">go mod的使用</h3>
<div class="outline-text-3" id="text-orgd7cbf79">
<p>
go 11版本加入了go mod
</p>
<ul class="org-ul">
<li>由go命令统一管理，用户不必关心目录结构</li>
<li>初始化`go mod init [name]`</li>
<li>增加依赖：`go get` 或者在代码文件中写`import "依赖地址"`</li>
<li>更新依赖：`go get [@v&#x2026;],  go mod tidy`</li>
<li>升级到最新：`go get -u`</li>
<li>将旧项目迁移到go mod：`go mod init, go build ./&#x2026;`</li>
</ul>

<p>
go mod 命令
</p>
<div class="org-src-container">
<pre class="src src-sh">go mod download : &#19979;&#36733;&#20381;&#36182;&#21253;&#21040;&#26412;&#22320;&#65288;&#40664;&#35748;&#20026; GOPATH/pkg/mod &#30446;&#24405;&#65289;
go mod edit : &#32534;&#36753; go.mod &#25991;&#20214;
go mod graph  : &#25171;&#21360;&#27169;&#22359;&#20381;&#36182;&#22270;
go mod init : &#21021;&#22987;&#21270;&#24403;&#21069;&#25991;&#20214;&#22841;&#65292;&#21019;&#24314; go.mod &#25991;&#20214;
go mod tidy : &#22686;&#21152;&#32570;&#23569;&#30340;&#21253;&#65292;&#21024;&#38500;&#26080;&#29992;&#30340;&#21253;
go mod vendor : &#23558;&#20381;&#36182;&#22797;&#21046;&#21040; vendor &#30446;&#24405;&#19979;
go mod verify : &#26657;&#39564;&#20381;&#36182;
go mod why :  &#35299;&#37322;&#20026;&#20160;&#20040;&#38656;&#35201;&#20381;&#36182;
go clean  -modcache : &#28165;&#38500;&#25152;&#26377;mod&#21450;&#32531;&#23384;
</pre>
</div>
</div>
</div>
<div id="outline-container-org9a27a66" class="outline-3">
<h3 id="org9a27a66">目录的整理</h3>
<div class="outline-text-3" id="text-org9a27a66">
<p>
包使用原则
</p>
<ul class="org-ul">
<li>每个main函数都在单独的目录中</li>
</ul>
</div>
</div>
</section>
</div>
<div id="postamble" class="status">
    <div class=bar data-astro-cid-p3givckg>
        <div class=list data-astro-cid-p3givckg>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=simple-icons:gnuemacs height=1em viewBox="0 0 24 24" width=1em>
                    <title>emacs</title>
                    <symbol id=ai:simple-icons:gnuemacs>
                        <path d="M12 24C5.448 24 .118 18.617.118 12S5.448 0 12 0s11.882 5.383 11.882 12S18.552 24 12 24zM12 .661C5.813.661.779 5.748.779 12S5.813 23.339 12 23.339S23.221 18.253 23.221 12S18.187.661 12 .661zM8.03 20.197s.978.069 2.236-.042c.51-.045 2.444-.235 3.891-.552c0 0 1.764-.377 2.707-.725c.987-.364 1.524-.673 1.766-1.11c-.011-.09.074-.408-.381-.599c-1.164-.488-2.514-.4-5.185-.457c-2.962-.102-3.948-.598-4.472-.997c-.503-.405-.25-1.526 1.907-2.513c1.086-.526 5.345-1.496 5.345-1.496c-1.434-.709-4.109-1.955-4.659-2.224c-.482-.236-1.254-.591-1.421-1.021c-.19-.413.448-.768.804-.87c1.147-.331 2.766-.536 4.24-.56c.741-.012.861-.059.861-.059c1.022-.17 1.695-.869 1.414-1.976c-.252-1.13-1.579-1.795-2.84-1.565c-1.188.217-4.05 1.048-4.05 1.048c3.539-.031 4.131.028 4.395.398c.156.218-.071.518-1.015.672c-1.027.168-3.163.37-3.163.37c-2.049.122-3.492.13-3.925 1.046c-.283.599.302 1.129.558 1.46c1.082 1.204 2.646 1.853 3.652 2.331c.379.18 1.49.52 1.49.52c-3.265-.18-5.619.823-7.001 1.977c-1.562 1.445-.871 3.168 2.33 4.228c1.891.626 2.828.921 5.648.667c1.661-.09 1.923-.036 1.939.1c.023.192-1.845.669-2.355.816c-1.298.374-4.699 1.129-4.716 1.133z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:simple-icons:gnuemacs></use>
                </svg>
                <div class="content left" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Emacs</p>
                </div>
            </span>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=simple-icons:org height=1em viewBox="0 0 24 24" width=1em>
                    <title>org-mode</title>
                    <symbol id=ai:simple-icons:org>
                        <path d="M17.169 0c-.566.004-2.16 3.312-3.376 5.94a2.19 2.19 0 0 1-.408-1.267c-.03-.582-1.089.237-.936 1.275c-.068-.035-1.26.227-1.26.23c-.23-.93-.802-1.618-1.15-.563c-.701 1.663-.88 2.984.115 4.585c-.908 4.058-6.948 6.053-6.32 9.33c.175.004 1.634 3.48 6.337 2.057c5.557-1.577 8.624 2.116 8.978 2.375c.52.526-1.348-4.573-5.302-6.865c-2.339-1.276-.87-3.474-.703-4.25c0 0 1.874 1.312 3.232-.692c1.227.316 2.05-.224 3.105.158c.64.28 3.336.11 2.334-1.396c-.148.129.07.27-.075.46c-.043.056-.128.232-.408.315c-.314.149-.83.27-1.43-.37c-.434-.32-.748-.04-.992-.063c.152-.098.577-.315 1.264-.315c.388 0 .594.336.854.338c.174 0 .685-.262.787-.365c.63-.41.697-.278 1.012-.905c.17-.759-.215-.92-.332-1.129c-.032-.483-.436-.67-.919-.326c-1.106-.198-2.192-.105-2.728-.15c-1.175-.164-2.153-.786-2.153-.786c.143-.19.075-.6-.842-.628c-.315-.104-.45-.2-.745-.307c.61-1.37.674-2.007 1.418-4.004c.261-1.053 1.039-2.685.643-2.682zm-4.297 8.093c.03-.086.443.138.952.176c.395.03.805.048 1.296-.025c.03-.005.172.095-.15.194c-.02.01-.062-.01-.065.196c0 .022-.01.04-.02.046c-.15.152-.708.223-1.065.1c-.436-.17-.482-.316-.517-.443c-.305-.147-.47-.123-.43-.244zM9.685 10.2C8.86 9 8.929 8.36 8.96 7.256C7.961 8.288 6.855 8.3 5.18 8.58c-1.299.234-3.657 2.447-4.025 4.742c-.043.608-.08 2.183.424 3.498c.492 1.13.828 1.727 1.844 2.335c-.882-3.169 5.296-5.33 6.263-8.955z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:simple-icons:org></use>
                </svg>
                <div class="content left" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Orgmode</p>
                </div>
            </span>
            <a href=/donations.html class=entry data-astro-cid-p3givckg>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=simple-icons:astro height=1em viewBox="0 0 24 24" width=1em>
                    <title>Donations</title>
                    <symbol id=ai:simple-icons:astro>
                        <path d="M8.358 20.162c-1.186-1.07-1.532-3.316-1.038-4.944c.856 1.026 2.043 1.352 3.272 1.535c1.897.283 3.76.177 5.522-.678c.202-.098.388-.229.608-.36c.166.473.209.95.151 1.437c-.14 1.185-.738 2.1-1.688 2.794c-.38.277-.782.525-1.175.787c-1.205.804-1.531 1.747-1.078 3.119l.044.148a3.158 3.158 0 0 1-1.407-1.188a3.31 3.31 0 0 1-.544-1.815c-.004-.32-.004-.642-.048-.958c-.106-.769-.472-1.113-1.161-1.133c-.707-.02-1.267.411-1.415 1.09c-.012.053-.028.104-.045.165h.002zm-5.961-4.445s3.24-1.575 6.49-1.575l2.451-7.565c.092-.366.36-.614.662-.614c.302 0 .57.248.662.614l2.45 7.565c3.85 0 6.491 1.575 6.491 1.575L16.088.727C15.93.285 15.663 0 15.303 0H8.697c-.36 0-.615.285-.784.727l-5.516 14.99z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:simple-icons:astro></use>
                </svg>
                <div class="content left" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>打赏</p>
                </div>
            </span>
            </a>
            <span class=entry data-astro-cid-p3givckg>
                <svg xmlns="http://www.w3.org/2000/svg" class=heading data-astro-cid-p3givckg data-icon=simple-icons:copyright width="1em" height="1em" viewBox="0 0 24 24">
                    <title>Copyright</title>
                    <path fill="currentColor" d="M19 2a3 3 0 0 1 3 3v14a3 3 0 0 1-3 3H5a3 3 0 0 1-3-3V5a3 3 0 0 1 3-3zm-5 5h-4a1 1 0 0 0-1 1l.007.117A1 1 0 0 0 10 9h3v5a1 1 0 0 1-1.993.117L11 14a1 1 0 0 0-2 0a3 3 0 0 0 6 0V8a1 1 0 0 0-1-1" />
                    <use xlink:href=#ai:simple-icons:copyright></use>
                </svg>
                <div class="content left" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>© 2025 Jasper Hsu</p>
                </div>
            </span>
        </div>
        <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ class="list license" data-astro-cid-p3givckg>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=fa6-brands:creative-commons height=1em viewBox="0 0 496 512" width=0.97em>
                    <title>Creative Commons</title>
                    <symbol id=ai:fa6-brands:creative-commons>
                        <path d="m245.83 214.87l-33.22 17.28c-9.43-19.58-25.24-19.93-27.46-19.93c-22.13 0-33.22 14.61-33.22 43.84c0 23.57 9.21 43.84 33.22 43.84c14.47 0 24.65-7.09 30.57-21.26l30.55 15.5c-6.17 11.51-25.69 38.98-65.1 38.98c-22.6 0-73.96-10.32-73.96-77.05c0-58.69 43-77.06 72.63-77.06c30.72-.01 52.7 11.95 65.99 35.86zm143.05 0l-32.78 17.28c-9.5-19.77-25.72-19.93-27.9-19.93c-22.14 0-33.22 14.61-33.22 43.84c0 23.55 9.23 43.84 33.22 43.84c14.45 0 24.65-7.09 30.54-21.26l31 15.5c-2.1 3.75-21.39 38.98-65.09 38.98c-22.69 0-73.96-9.87-73.96-77.05c0-58.67 42.97-77.06 72.63-77.06c30.71-.01 52.58 11.95 65.56 35.86zM247.56 8.05C104.74 8.05 0 123.11 0 256.05c0 138.49 113.6 248 247.56 248c129.93 0 248.44-100.87 248.44-248c0-137.87-106.62-248-248.44-248zm.87 450.81c-112.54 0-203.7-93.04-203.7-202.81c0-105.42 85.43-203.27 203.72-203.27c112.53 0 202.82 89.46 202.82 203.26c-.01 121.69-99.68 202.82-202.84 202.82z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:fa6-brands:creative-commons></use>
                </svg>
                <div class="content right" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Creative Commons</p>
                </div>
            </span>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=fa6-brands:creative-commons-by height=1em viewBox="0 0 496 512" width=0.97em>
                    <title>Attribute</title>
                    <symbol id=ai:fa6-brands:creative-commons-by>
                        <path d="M314.9 194.4v101.4h-28.3v120.5h-77.1V295.9h-28.3V194.4c0-4.4 1.6-8.2 4.6-11.3c3.1-3.1 6.9-4.7 11.3-4.7H299c4.1 0 7.8 1.6 11.1 4.7c3.1 3.2 4.8 6.9 4.8 11.3zm-101.5-63.7c0-23.3 11.5-35 34.5-35s34.5 11.7 34.5 35c0 23-11.5 34.5-34.5 34.5s-34.5-11.5-34.5-34.5zM247.6 8C389.4 8 496 118.1 496 256c0 147.1-118.5 248-248.4 248C113.6 504 0 394.5 0 256C0 123.1 104.7 8 247.6 8zm.8 44.7C130.2 52.7 44.7 150.6 44.7 256c0 109.8 91.2 202.8 203.7 202.8c103.2 0 202.8-81.1 202.8-202.8c.1-113.8-90.2-203.3-202.8-203.3z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:fa6-brands:creative-commons-by></use>
                </svg>
                <div class="content right" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Attribute</p>
                </div>
            </span>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=fa6-brands:creative-commons-nc height=1em viewBox="0 0 496 512" width=0.97em>
                    <title>Noncommercial</title>
                    <symbol id=ai:fa6-brands:creative-commons-nc>
                        <path d="M247.6 8C387.4 8 496 115.9 496 256c0 147.2-118.5 248-248.4 248C113.1 504 0 393.2 0 256C0 123.1 104.7 8 247.6 8zM55.8 189.1c-7.4 20.4-11.1 42.7-11.1 66.9c0 110.9 92.1 202.4 203.7 202.4c122.4 0 177.2-101.8 178.5-104.1l-93.4-41.6c-7.7 37.1-41.2 53-68.2 55.4v38.1h-28.8V368c-27.5-.3-52.6-10.2-75.3-29.7l34.1-34.5c31.7 29.4 86.4 31.8 86.4-2.2c0-6.2-2.2-11.2-6.6-15.1c-14.2-6-1.8-.1-219.3-97.4zM248.4 52.3c-38.4 0-112.4 8.7-170.5 93l94.8 42.5c10-31.3 40.4-42.9 63.8-44.3v-38.1h28.8v38.1c22.7 1.2 43.4 8.9 62 23L295 199.7c-42.7-29.9-83.5-8-70 11.1c53.4 24.1 43.8 19.8 93 41.6l127.1 56.7c4.1-17.4 6.2-35.1 6.2-53.1c0-57-19.8-105-59.3-143.9c-39.3-39.9-87.2-59.8-143.6-59.8z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:fa6-brands:creative-commons-nc></use>
                </svg>
                <div class="content right" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Noncommercial</p>
                </div>
            </span>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=fa6-brands:creative-commons-sa height=1em viewBox="0 0 496 512" width=0.97em>
                    <title>Share Alike</title>
                    <symbol id=ai:fa6-brands:creative-commons-sa>
                        <path d="M247.6 8C389.4 8 496 118.1 496 256c0 147.1-118.5 248-248.4 248C113.6 504 0 394.5 0 256C0 123.1 104.7 8 247.6 8zm.8 44.7C130.2 52.7 44.7 150.6 44.7 256c0 109.8 91.2 202.8 203.7 202.8c103.2 0 202.8-81.1 202.8-202.8c.1-113.8-90.2-203.3-202.8-203.3zM137.7 221c13-83.9 80.5-95.7 108.9-95.7c99.8 0 127.5 82.5 127.5 134.2c0 63.6-41 132.9-128.9 132.9c-38.9 0-99.1-20-109.4-97h62.5c1.5 30.1 19.6 45.2 54.5 45.2c23.3 0 58-18.2 58-82.8c0-82.5-49.1-80.6-56.7-80.6c-33.1 0-51.7 14.6-55.8 43.8h18.2l-49.2 49.2l-49-49.2h19.4z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:fa6-brands:creative-commons-sa></use>
                </svg>
                <div class="content right" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Share Alike</p>
                </div>
            </span>
        </a>
    </div>
<!--
<script type="text/javascript" src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script type="text/javascript" src="https://unpkg.com/@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
<script type="text/javascript" src="https://unpkg.com/bootstrap@5.2.1/dist/js/bootstrap.min.js"></script>
<div id="back-to-top" class=""><svg viewBox="0 0 24 24"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path></svg></div>
-->
</div>
</body>
</html>
