<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Architect: 架构师</title>
<meta name="generator" content="Org Mode" />
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="me" href="https://emacs.ch/@jasperhsu">
<meta name="google-adsense-account" content="ca-pub-1741779893655624">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1741779893655624" crossorigin="anonymous"></script>
<!-- from -->
<!--
<style>#back-to-top{background:#000;-webkit-border-radius:50%;-moz-border-radius:50%;border-radius:50%;bottom:20px;-webkit-box-shadow:0 2px 5px 0 rgba(0,0,0,.26);-moz-box-shadow:0 2px 5px 0 rgba(0,0,0,.26);box-shadow:0 2px 5px 0 rgba(0,0,0,.26);color:#fff;cursor:pointer;display:block;height:56px;opacity:1;outline:0;position:fixed;right:20px;-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none;-webkit-transition:bottom .2s,opacity .2s;-o-transition:bottom .2s,opacity .2s;-moz-transition:bottom .2s,opacity .2s;transition:bottom .2s,opacity .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:56px;z-index:1}#back-to-top svg{display:block;fill:currentColor;height:24px;margin:16px auto 0;width:24px}#back-to-top.hidden{bottom:-56px;opacity:0}</style>
-->
<link rel="stylesheet" href="/static/aandds.com/css/main.css">
<link rel="stylesheet" href="/static/aandds.com/css/drollery.min.css">
<script type="text/javascript" src="/static/aandds.com/js/main.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">Architect: 架构师</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#h:fd5cb987-da07-4083-a278-46e7bf4f81aa">开篇词：Get技术人进阶技巧</a>
<ul>
<li><a href="#h:72f0c36f-211f-438a-a1ea-85b09626cdc6">教程内容</a></li>
<li><a href="#h:4fda3ffa-7387-4737-955d-43428be95b0a">为什么学架构</a>
<ul>
<li><a href="#h:48d2aca1-c6b9-4855-996f-fc92545b5dd8">优秀的架构师特点</a></li>
<li><a href="#h:0bb49648-d05c-4bc4-aabe-e2baefa975e5">软件架构的知识体系</a></li>
<li><a href="#h:f8303e84-408e-4add-9f11-cedf3fba328e">教程目的</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:93bf4462-2313-4492-a514-d8c24e9fbd99">第01讲：大型架构的演进之路</a>
<ul>
<li><a href="#h:107091cd-c383-4ab8-87bc-409f97d4f5b9">大型互联网系统的特点</a>
<ul>
<li><a href="#h:97df54dd-2948-4a5e-b719-01a56132f84f">高并发和大流量</a></li>
<li><a href="#h:ddcbf451-9e4d-4ddb-a498-7e98576336ae">高可用</a></li>
<li><a href="#h:7ae4769e-f2da-4ab6-baf7-07d77b198485">海量的数据存储</a></li>
<li><a href="#h:476d23cf-6d13-453a-8a3d-17a2cfd23bff">用户分布广泛，网络情况复杂</a></li>
<li><a href="#h:51c77679-7fc6-43b9-b18c-6f9b2b39a2f1">安全环境恶劣</a></li>
<li><a href="#h:850673a0-8d8c-40f0-b7ba-c380c345aeff">需求变化快，发布频繁</a></li>
</ul>
</li>
<li><a href="#h:048b7b6e-abdb-4aea-b9c4-32a1301c4ce6">系统处理能力提升的两种途径</a>
<ul>
<li><a href="#h:a4289309-aedf-4438-abe6-6dd64e59c428">垂直伸缩</a></li>
<li><a href="#h:ba66e68c-efe1-42df-af5b-b4d329ace9dd">水平伸缩</a></li>
<li><a href="#h:9167f330-e097-4e28-89f6-fc296a72fc47">垂直伸缩的局限</a></li>
</ul>
</li>
<li><a href="#h:2f0012e9-dc1a-42de-af53-88318c996d59">大型互联网架构演化进程</a>
<ul>
<li><a href="#h:985cc459-3270-44bb-9387-c6049b5e0ef5">单机系统</a></li>
<li><a href="#h:562940f9-46f8-4ad2-8883-ac7371ba23c8">缓存</a></li>
<li><a href="#h:8597c0f0-e5cf-4de2-ac07-343154f652be">反向代理和 CDN 加速</a></li>
<li><a href="#h:ecaca706-d140-463a-a3de-237cb1fcfaf8">分布式文件系统和分布式数据库系统</a></li>
<li><a href="#h:a23a070f-448b-46fd-a4ce-04f763c2842f">消息队列与分布式服务</a></li>
<li><a href="#h:9acd4c8f-d0ad-47d8-85d2-79d27173dee7">总结回顾</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:1fbe3d16-8b33-40cb-a70c-6ab1fb5b6bf4"><b><code>第02讲：架构核心技术之分布式缓存(重要)</code></b></a>
<ul>
<li><a href="#h:efe6b289-9727-4608-9a36-29442cd1aaec">缓存知识架构图</a></li>
<li><a href="#h:066305cf-420e-4081-b241-a632a628badf">缓存的特点</a>
<ul>
<li><a href="#h:99f8885d-7dc8-4925-8c87-e15262c3d945">缓存提高性能的优势</a></li>
<li><a href="#h:448eb2bd-1a0c-44c5-a217-5328daeaa6bb">缓存数据存储（Hash 表）</a></li>
</ul>
</li>
<li><a href="#h:725639a6-c481-41d0-8646-1c1350f4774c">缓存的关键指标&#x2013;命中率</a>
<ul>
<li><a href="#h:3c9d3336-64a5-40b1-8c5f-15dfaebd4de3">缓存键集合大小</a></li>
<li><a href="#h:d3235a1d-b211-40cf-a972-f5de4fcecfce">缓存内存空间大小</a></li>
<li><a href="#h:a2083bb7-4ef7-42ea-8eda-28981fd78c70">缓存对象生存时间（缓存寿命）</a></li>
</ul>
</li>
<li><a href="#h:a70d1b91-a735-4bd7-861d-faa11885f447">缓存的主要类型</a>
<ul>
<li><a href="#h:52aef660-4b00-4079-9d3a-a2a58a7e22ab">代理缓存</a></li>
<li><a href="#h:d7d9dd95-4978-4e3e-a084-e58a0db64029">反向代理缓存</a></li>
<li><a href="#h:e974937a-d22a-4f05-b319-916b8b1df43f">内容分发网络 CDN 缓存</a></li>
<li><a href="#h:e726a75b-300e-447c-8a01-3a0547437647">通读缓存(read-through)</a></li>
<li><a href="#h:e03adc2f-9b73-420a-ba37-ca78feaae6cc">旁路缓存(cache-aside)</a></li>
</ul>
</li>
<li><a href="#h:e3a764d4-423f-4b9c-9344-ca94a79d9cdc">合理使用缓存对象</a>
<ul>
<li><a href="#h:7d859ddb-f7ce-4dc2-900d-f02eeaabb6e1">注意频繁修改的数据</a></li>
<li><a href="#h:699e4814-f461-439b-96d9-0513d2de075e">注意没有热点的访问数据</a></li>
<li><a href="#h:87b39706-2d89-4774-9d1b-f0ca4f430cf6">注意数据不一致和脏读</a></li>
<li><a href="#h:6ff2ae59-b9fc-4c1a-96f0-52201f53250a">注意缓存雪崩</a></li>
</ul>
</li>
<li><a href="#h:fda1f7d2-6df3-4567-80aa-943b517b1fd0">分布式对象缓存</a>
<ul>
<li><a href="#h:6b952811-3e2e-48c6-92e3-e370007ebcc7">一致性哈希算法</a></li>
</ul>
</li>
<li><a href="#h:a6926cf9-c52a-4ecf-a3fe-73d494d5d8e0">总结回顾</a></li>
</ul>
</li>
<li><a href="#h:e50841de-b583-479d-ac76-a8bd3a13d856">第03讲：架构核心技术之分布式消息队列</a>
<ul>
<li><a href="#h:8b2abc90-36bf-40df-af31-43314e62ddf3">同步调用与异步调用</a>
<ul>
<li><a href="#h:483c998c-5447-49b7-8595-06f836486768">同步调用</a></li>
<li><a href="#h:5545f7a2-8d6c-4a3b-94a0-9c9125078bc6">异步调用</a></li>
</ul>
</li>
<li><a href="#h:8e8e2848-85fc-4669-8313-66978c293d40">消息队列构建异步调用架构</a>
<ul>
<li><a href="#h:dca7dcb3-2750-4c26-ac04-0e5f7fb7642f">消息生产者</a></li>
<li><a href="#h:ed45db84-a30e-43a4-9bdb-312def9d5636">消息队列</a></li>
<li><a href="#h:6e5a86fb-237a-4d45-acbb-cd92397351a1">消息消费者</a></li>
<li><a href="#h:739b5fce-08da-45e6-9c8a-388ea8576c12">点对点模型</a></li>
<li><a href="#h:6d82b2db-8604-48a9-b540-c33917dca57f">发布订阅模型</a></li>
<li><a href="#h:10bc7dae-c8a1-485e-9ace-2e78771fad41">两种模型对比</a></li>
</ul>
</li>
<li><a href="#h:e6ca488f-45f9-4af8-8d78-a194398a41f4">消息队列的好处</a>
<ul>
<li><a href="#h:7cb56cbf-65f3-4beb-a0d3-1d2a5eb0c9b0">异步处理</a></li>
<li><a href="#h:8592c31e-55ef-4ea7-bc16-b812c48cebe5">易伸缩</a></li>
<li><a href="#h:92a4193b-cae1-4454-a5f2-d203276f4470">使峰值平缓</a></li>
<li><a href="#h:4bbbfcfc-5955-4a11-887a-bc086a24930f">失败隔离及自我修复</a></li>
<li><a href="#h:61373d15-c3db-4b8b-bde8-53aa71dc58ad">解耦</a></li>
</ul>
</li>
<li><a href="#h:1fe270f1-1ce9-4c8d-9e31-dadcf036885c">消息队列相关挑战</a>
<ul>
<li><a href="#h:44cdd863-cef6-4e09-9580-428488b785ff">消息无序</a></li>
<li><a href="#h:dc665827-fd28-4416-9a6c-d092cde945e7">息重新入队列</a></li>
<li><a href="#h:2f4d1a91-99b5-495e-81ca-9c1b7bc6591e">竞态条件</a></li>
<li><a href="#h:b9cc588f-8225-44d6-9aad-cce4ca63aeb4">复杂度风险</a></li>
</ul>
</li>
<li><a href="#h:6deed4aa-3d65-48ed-8433-22453d6eab25">消息队列的反模式</a>
<ul>
<li><a href="#h:a5662fc3-b970-4620-8454-e727aef4a369">阻塞式调用</a></li>
<li><a href="#h:46ef5a10-abed-47fd-82e8-a59abbd29946">耦合生产者和消费者</a></li>
<li><a href="#h:7a317e2b-5643-48e9-af53-672202681b58">缺少坏消息处理</a></li>
</ul>
</li>
<li><a href="#h:b691f97e-19aa-47e3-8973-0b92abfd3930">常用消息队列产品</a></li>
<li><a href="#h:682f4489-9d00-4dec-81f4-1d029b771748">总结回顾</a></li>
</ul>
</li>
<li><a href="#h:16165a6f-4100-4b9f-88b1-359771cbe09f">第04讲：架构核心技术之分布式数据存储</a>
<ul>
<li><a href="#h:ab1f05b0-b2ce-40ea-a4ea-ed8f0bdbf52e">MySQL 数据库复制</a>
<ul>
<li><a href="#h:adaf4510-755f-4547-9968-a80038556f05">主从复制</a></li>
<li><a href="#h:c013be74-c4de-44a3-b9bd-6897ff0284b5">一主多从复制</a></li>
<li><a href="#h:9569c9c0-fb23-4f9e-9c92-a9f9ef6e681c">一主多从复制的优点</a></li>
<li><a href="#h:c8997c9c-d035-4d4c-95b9-35b30b43ac86">主主复制</a></li>
<li><a href="#h:4e824aee-eaa7-4970-98cb-f4b55459e11a">MySQL 复制的注意事项</a></li>
</ul>
</li>
<li><a href="#h:64e38f44-2638-47b6-8f26-58e5f6902cf3">数据分片</a>
<ul>
<li><a href="#h:86914a18-8671-4578-ac72-83164dc91eaf">数据分片的目标</a></li>
<li><a href="#h:0fac6f68-5bf3-4add-af06-43a873010bd7">数据分片的特点</a></li>
<li><a href="#h:a7119310-079b-450a-b45d-f8b9c5fba3d9">数据分片的原理与实现</a></li>
<li><a href="#h:b4812e7f-a0b2-4293-9a5f-f597d91564a1">分片数据库的伸缩扩容</a></li>
</ul>
</li>
<li><a href="#h:f8ef1ca2-5f24-4739-8d4b-31b6778e4e65">数据库部署方案</a>
<ul>
<li><a href="#h:069491ba-fc6f-47d4-846d-7515cdc4b812">单一服务和单一数据库</a></li>
<li><a href="#h:c75adc92-8a2d-435f-8755-ceea412d6d8c">主从复制</a></li>
<li><a href="#h:dcadbdd9-2a1b-47e0-89b2-8e6a7d08e3e6">业务分库</a></li>
<li><a href="#h:4c935190-46b4-4a1e-ae65-b3538bad9568">综合部署</a></li>
</ul>
</li>
<li><a href="#h:352b1c5a-63ab-4288-8283-c7bcb5c9c5ca">NoSQL 数据库</a>
<ul>
<li><a href="#h:dbe146a2-bfb1-4477-b64e-45c1b9d04108">CAP 原理与数据一致性</a></li>
<li><a href="#h:c7eb2483-54a5-471f-91d9-905b27ff939d">一致性冲突解决方案</a></li>
</ul>
</li>
<li><a href="#h:a1353c67-ba2d-401e-a01f-12cae46fe8d3">总结回顾</a></li>
</ul>
</li>
<li><a href="#h:8d9841ab-4901-4093-b73b-d188932a67a9">第05讲：架构核心技术之微服务</a>
<ul>
<li><a href="#h:9c175ec2-ba65-4b12-bb20-02ccc3affe92">单体系统的困难</a>
<ul>
<li><a href="#h:342ed803-a80c-477c-89a8-3800d7622ef5"><b>编译、部署困难</b></a></li>
<li><a href="#h:68c974ed-938f-4a3e-aca5-ba1e1579ff5f">代码分支管理困难</a></li>
<li><a href="#h:1332f3d4-6c12-458a-9bea-01abb5c04680">数据库连接耗尽</a></li>
<li><a href="#h:a34de140-423b-4adb-8294-d2bb0146f19c">新增业务困难</a></li>
<li><a href="#h:30acd41e-9f9f-4f66-8c5a-8c9824cb6384">发布困难</a></li>
</ul>
</li>
<li><a href="#h:f5684cbb-bf4c-489a-8725-bb8574dbfda7">微服务架构</a>
<ul>
<li><a href="#h:86d74b6a-627a-46d7-9997-66a215cc481f">微服务架构-Dubbo</a></li>
<li><a href="#h:79c4a87a-0f0b-4b2f-b5af-120d1f584e6d">微服务框架-Spring Cloud</a></li>
<li><a href="#h:65af7d05-7abf-46e0-9cb3-548ea1da43ac">微服务架构策略</a></li>
</ul>
</li>
<li><a href="#h:4898f728-3d2d-46a9-8251-e2caa50cf83a">微服务的使用模式</a>
<ul>
<li><a href="#h:f01ee855-b3bb-4649-8dac-be0064052f53">事件溯源</a></li>
<li><a href="#h:dbc222bc-ab1b-46bf-8bbf-2673ec1b26d5">命令与查询职责隔离（CQRS）</a></li>
<li><a href="#h:11cd98ba-9857-4943-8beb-c120660fc7ed">断路器</a></li>
<li><a href="#h:16d9be04-e99b-41e8-9b2b-5caacd6d187c">超时</a></li>
</ul>
</li>
<li><a href="#h:cbed1d17-268c-402c-bf13-c3cd5e4b9ebc">总结回顾</a></li>
</ul>
</li>
<li><a href="#h:28383032-6446-4e00-8b3e-be747cb50e66">第06讲：高性能系统架构设计</a>
<ul>
<li><a href="#h:3ce26044-80f1-4722-ac18-3f4fc84be540">系统性能测试</a></li>
<li><a href="#h:c36d91d4-3694-44aa-bc13-cf7c3ee8c765">客观性能指标</a>
<ul>
<li><a href="#h:a968b598-d411-4d19-b7a9-2a22d15d8bda">响应时间</a></li>
<li><a href="#h:03bcb58b-e30a-4690-8f85-a7a88821c78a">并发数</a></li>
<li><a href="#h:21802ea6-5b0e-4dd8-b32c-5f8968e83898">吞吐量</a></li>
<li><a href="#h:c04a0225-0e44-48f7-9484-589e96082504">性能计数器</a></li>
</ul>
</li>
<li><a href="#h:d2ddf5c0-ec56-43a0-93f0-1eade9275922">性能测试方法</a>
<ul>
<li><a href="#h:0ca09449-c0a2-416c-81e2-0944c8fce72e">性能测试</a></li>
<li><a href="#h:4d1a9d9a-52d8-4391-a38c-a438cbb541b1">负载测试</a></li>
<li><a href="#h:969bc395-9b34-4045-897a-5f4c3bab94bc">压力测试</a></li>
<li><a href="#h:a0117191-d25e-4a33-9386-51155b9be0f8">稳定性测试</a></li>
</ul>
</li>
<li><a href="#h:629d9fb3-5d03-4617-9c36-c75e253a21a9">性能特性曲线</a>
<ul>
<li><a href="#h:e0442e59-efc8-42f0-b48d-00d2ef9f56af">吞吐量特性曲线</a></li>
<li><a href="#h:cac7ab51-a9da-47ae-bc90-2a68fadab756">响应时间特性曲线</a></li>
</ul>
</li>
<li><a href="#h:d194c978-0413-420c-bd80-59b3c2a1b82f">系统性能优化</a>
<ul>
<li><a href="#h:066b23b6-5fb6-4450-8e51-3b5a93be604a">分层优化系统性能</a>
<ul>
<li><a href="#h:cc0665d7-4903-4636-a267-31d98ae439d3">第一层是机房与骨干网络的性能优化</a></li>
<li><a href="#h:7a3bbbc3-0e92-4e08-a5f4-bc0ce64aa11a">第二层是对服务器内的硬件进行优化</a></li>
<li><a href="#h:217108fb-3508-4f5d-9be7-4875c58b12ac">硬件与服务器性能优化再下面一层，是操作系统的性能优化</a></li>
<li><a href="#h:bd0998c5-03d6-4f25-9374-d329dc7060e5">第四层是虚拟机的性能优化</a></li>
<li><a href="#h:9b402a6f-0d83-42c3-9644-dd2bddcc9690">在虚拟机之下是基础组件的性能优化</a></li>
<li><a href="#h:ce84fc8e-ca89-4097-8a98-657aa8349015">在基础组件性能优化之下才是软件架构性能优化</a></li>
<li><a href="#h:6bbd3dfd-896c-4d2e-8f09-5b5b77c0d04c">在性能优化的最底层才是软件代码的性能优化</a></li>
</ul>
</li>
<li><a href="#h:b638c589-c0d6-4324-8708-63f90a3cd786">性能优化案例</a></li>
</ul>
</li>
<li><a href="#h:0900ffb7-0fc1-48bb-b5e1-04ed62dd2420">总结回顾</a></li>
</ul>
</li>
<li><a href="#h:2f7567d0-86b7-42d7-aa46-5af72ce197ff">第07讲：高可用系统架构设计</a>
<ul>
<li><a href="#h:f02e2e5e-9298-440a-b2f6-9bc96e314e04">系统高可用的挑战</a></li>
<li><a href="#h:c726b294-24d4-411b-b80e-97c803ee2a9f">互联网应用可用性的度量</a>
<ul>
<li><a href="#h:8923cd60-2a7f-4eaa-9e4c-7b4742185b1e">故障分类</a></li>
<li><a href="#h:5d03bce9-9cc9-41c3-9989-836a88bd119c">故障处理流程和故障时间</a></li>
</ul>
</li>
<li><a href="#h:5a44e343-5993-4b46-a094-5a2b82efbc4c">大型系统高可用的一般策略</a>
<ul>
<li><a href="#h:a8c463aa-65b0-4d3d-b831-9b1d242be508">负载均衡</a></li>
<li><a href="#h:6619d25f-68a0-494c-8405-72da8919715f">负载均衡实现方法</a></li>
<li><a href="#h:56f3af95-8566-4c87-b04f-771f90646702">数据库复制与失效转移</a></li>
<li><a href="#h:d51933b8-b9c1-48eb-a3c6-e42f6610d2f8">消息队列隔离</a></li>
<li><a href="#h:e018fd58-8d06-4a19-98f9-170ce70a25ac">限流和降级</a></li>
<li><a href="#h:2dee68fe-d20d-47ed-9558-e7f92734e719">异地多活机房架构</a></li>
</ul>
</li>
<li><a href="#h:752f3220-bf19-4f41-beb4-3307bdc1cbe1">高可用运维</a>
<ul>
<li><a href="#h:e42e1703-b8ff-4c0e-b270-4ff3aace088a">自动化测试</a></li>
<li><a href="#h:12050e85-8178-4d50-8eda-009621fa96d6">自动化监控</a></li>
<li><a href="#h:80fb2374-9b81-4113-aa8d-b9ab20069d17">预发布</a></li>
<li><a href="#h:2eb6cd3f-503b-47ef-94cd-f7934a67595c">灰度发布</a></li>
</ul>
</li>
<li><a href="#h:6034da0d-2f2e-42af-8c1f-351d21b0f64d">总结回顾</a></li>
</ul>
</li>
<li><a href="#h:e690dc67-4e4b-4a31-aea4-5255830193aa">第08讲：系统的安全架构设计</a>
<ul>
<li><a href="#h:9c394548-be4d-4647-a79a-af68ac7b7f6a">Web 攻击与防护</a>
<ul>
<li><a href="#h:4ba226f7-6ef3-46be-994f-1bb05cf09a9b">XSS 攻击</a></li>
<li><a href="#h:b7497e71-afe9-4655-aa0c-f2b63942884f">XSS 攻击防御</a></li>
<li><a href="#h:ce2e6419-13b6-4dab-9cfd-5dc987973ac2">SQL 注入攻击</a></li>
<li><a href="#h:18333c6f-ef43-4a8b-9117-bb746f5bde95">SQL 攻击防御</a></li>
<li><a href="#h:730701e7-d683-4c30-ad3f-cdfd320c10b0">CSRF 攻击</a></li>
<li><a href="#h:6f4b14c8-6872-46d6-b427-1c42662eab4a">CSRF 攻击防御</a></li>
<li><a href="#h:b94e8d00-7000-420a-92c5-3ef6bd7cb08e">Web 应用防火墙</a></li>
</ul>
</li>
<li><a href="#h:6ebbb268-46c7-4aa0-9cc6-c84324baa6c6">信息加解密</a>
<ul>
<li><a href="#h:53b1d872-2663-4365-864a-8ce60ef0c161">单向散列加密</a></li>
<li><a href="#h:2a1d2a9a-89cb-460e-80f8-411aaa645e39">对称加密</a></li>
<li><a href="#h:43d3b844-a82f-4275-887d-a54cb1d4b516">非对称加密</a></li>
</ul>
</li>
<li><a href="#h:5d8b6f1c-1e6e-4078-9a56-ae0b8376a007">信息过滤与反垃圾</a>
<ul>
<li><a href="#h:790fb3fe-8a27-4e85-b48f-a4d1f77d52c8">分类算法</a></li>
<li><a href="#h:70a56721-b775-43b6-bbe1-e8318609574d">布隆过滤器</a></li>
</ul>
</li>
<li><a href="#h:5a3aa948-8af7-42bd-ade2-06bd8fe7da21">总结回顾</a></li>
</ul>
</li>
<li><a href="#h:4739bef2-a008-4efe-a974-9154dc326a8e">第09讲：架构实战案例分析</a>
<ul>
<li><a href="#h:ab1990c2-c844-448f-82c9-1e5ca2fa958e">初创互联网公司架构演化案例</a>
<ul>
<li><a href="#h:bcc3fc08-7877-4b53-9443-cc5e371f0c35">万级日订单级别架构</a></li>
<li><a href="#h:a40c6891-25aa-48c3-8003-e6d8a8f329cb">十万级日订单级别架构</a></li>
<li><a href="#h:585e1efc-0671-415e-9f47-11070b4f59d4">百万级日订单级别架构</a></li>
</ul>
</li>
<li><a href="#h:2583d131-2e4a-496c-b8b7-1dcaf6868451">分布式存储系统 Doris 架构案例</a>
<ul>
<li><a href="#h:bd8723cc-a506-485e-acd9-ed0ca9e2656d">Doris 设计目标</a></li>
<li><a href="#h:46d04933-e537-48d6-a01b-10becac843e9">Doris 的整体架构</a></li>
<li><a href="#h:1ca6e171-5a00-4d9e-bdb0-f0ae2a4a8556">Doris 数据分区架构与分区算法</a></li>
<li><a href="#h:d3796a26-e293-4950-ad89-4dc095b5eec2">Doris 调用时序</a></li>
<li><a href="#h:d59740b8-62cb-4817-9ac3-8af537f1d9be">Doris 高可用架构</a></li>
</ul>
</li>
<li><a href="#h:1d9a7a4d-0bcb-4a47-bb6c-238c8f33f9a6">反应式编程框架 Flower 架构案例</a>
<ul>
<li><a href="#h:555f8208-81b4-41e5-8af5-3ca801f1d83e">反应式系统特性</a></li>
<li><a href="#h:9a94c18f-b0a2-403a-9fb9-de1e50562a79">Flower 设计目标</a></li>
<li><a href="#h:6e9ed776-1a22-4253-84b4-b030f2d665a9">Flower 重构前后性能对比</a></li>
<li><a href="#h:186a3b89-88ee-46a2-ae76-5c4322ca6f56">Flower 提升系统性能原理</a></li>
<li><a href="#h:471febcf-43e4-41c3-9db0-4c6f95a09862">AKKA Actor</a></li>
<li><a href="#h:7acd212e-3f3a-40be-b393-8416b72ee69c">Flower 核心模块架构</a></li>
<li><a href="#h:8ccdd5f5-c6c3-4f4b-a528-df8efb13e949">Flower 分布式架构</a></li>
</ul>
</li>
<li><a href="#h:1ab4271b-02aa-4392-819e-5e96a83a5f8c">总结回顾</a></li>
</ul>
</li>
<li><a href="#h:c11957d0-e98b-4848-90b3-225c0bbcd72a">第10讲：致未来的架构师</a>
<ul>
<li><a href="#h:0790fbb5-983e-4dbd-bea9-e2db53699a11">技术人的进阶路径</a>
<ul>
<li><a href="#h:3fe0a341-e247-4be7-9c85-90518df1d9f3">0 级-&#x2013;&#x2014;普通程序员</a></li>
<li><a href="#h:d08a9d2d-bd45-4a5d-98b4-f73135e9ee97">1级-&#x2013;&#x2014;团队的影响者</a></li>
<li><a href="#h:6a10ea85-e1a2-4a08-8bd0-7d1505f5a577">2 级-&#x2013;&#x2014;公司的影响者</a></li>
<li><a href="#h:84156318-b9d8-4a2a-b6de-6e9a079764a8">3 级-&#x2013;&#x2014;全国影响者</a></li>
<li><a href="#h:923cf490-2da7-4d05-9bd7-de59175705b1">4 级-&#x2013;&#x2014;全球影响者</a></li>
<li><a href="#h:f15753f8-ea9f-4732-a52d-df3609cc8886">5级-&#x2013;&#x2014;关键开创者</a></li>
<li><a href="#h:8060f2d0-91ce-4bbb-a8fc-1527b377038b">6 级-&#x2013;&#x2014;领域开创者</a></li>
<li><a href="#h:84b8dcbe-834f-4348-87e6-efb5b5d90cb3">7 级-&#x2013;&#x2014;行业开创者</a></li>
<li><a href="#h:cd6734d9-f7a0-4c75-89f6-92af8ec3cf96">进阶路径</a></li>
</ul>
</li>
<li><a href="#h:429ca313-cd66-47f1-afbd-ecc3463ac34a">如何逐步成为技术专家</a>
<ul>
<li><a href="#h:0c88ecc1-237b-4e4a-a888-709e5437cbc7">勇于承担责任</a></li>
<li><a href="#h:31d63bb8-91de-4744-9e83-bda530d09580">在实践中保持技能</a></li>
<li><a href="#h:b4fafb02-84c9-4449-8571-b78344016f11">警惕银弹陷阱，关注问题场景</a></li>
</ul>
</li>
<li><a href="#h:b036d8fb-f4b9-4e9b-8cd2-1e1eafef8af2">架构师阅读清单</a>
<ul>
<li><a href="#h:1cc8794c-f6fd-4962-9217-d8022cefc41b">《Effective Java中文版》</a></li>
<li><a href="#h:0b533caf-39a1-429f-9b8c-3b1e5d87fdd6">《设计模式》</a></li>
<li><a href="#h:ceb818a3-4c2e-42c4-b68b-2605e2703325">《敏捷软件开发-&#x2013;&#x2014;原则模式与实践》</a></li>
<li><a href="#h:441bc4da-8a7b-4ba9-8032-24b5a89c5a96">《企业应用架构模式》</a></li>
<li><a href="#h:4cc2acef-c19e-4091-ab85-e8450e58979a">《卓有成效的管理者》</a></li>
</ul>
</li>
<li><a href="#h:2abd0819-7c3c-40ba-bd02-fc65ae719337">总结回顾</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<ul class="org-ul">
<li>TAGS: <a href="../index.html">Architect</a></li>
</ul>

<p>
<b>12436字</b>
</p>

<p>
架构师修炼
</p>

<style>  
  /* 设置按钮样式 */  
    .play-button {  
    position: fixed; /* 固定位置 */  
    right: 50%; /* 距离右侧10像素 */  
    bottom: 70%; /* 距离底部10像素 */  
    padding: 10px 20px;  
    z-index: 999; /* 确保按钮显示在其他内容之上 */  
  }  
</style> 

<script>
(function() {

  soundFiles = [
      "https://media.xyzcdn.net/lkpzzeFvlF8nFE3pkp4QBdSgJ0aw.m4a",
      "https://media.xyzcdn.net/FtfnQMt2onR4NpMmUtZEZx2lkxBY.m4a",
      "https://media.xyzcdn.net/luPrzAM4PAHFfsL3zaWq917cKpWe.m4a",
      "https://media.xyzcdn.net/lkKSYfM0cjQRs7Kkgq_Cr_lK1_rP.m4a",
      "https://media.xyzcdn.net/lvxktq5IoqCYLrvQxON6Kg8HB85V.m4a",
      "https://media.xyzcdn.net/lmEN5okB2dcPxtZh4aX2kVQMdKK7.m4a",
      "https://media.xyzcdn.net/ltgm6-yKGMWZvXUdYdVwA4HTlAu2.m4a",
      "https://media.xyzcdn.net/loEJDdOQrDTtcoyeCtDahMTQW6-J.m4a",
      "https://media.xyzcdn.net/lu-sdPh9zUcue0l1XVrBtkITtxUP.m4a",
      "https://media.xyzcdn.net/lrw9aOOfY-L0qEQaqH1Gi57tWb9Y.m4a",
      "https://media.xyzcdn.net/lnMgJjicveR3Usd5KbuOGV1sz3tf.m4a",
      "aa"

    ],
    soundText = {
      // architect
      "https://media.xyzcdn.net/lkpzzeFvlF8nFE3pkp4QBdSgJ0aw.m4a": "00-Get技术人进阶技巧",
      "https://media.xyzcdn.net/FtfnQMt2onR4NpMmUtZEZx2lkxBY.m4a": "01-技术人进阶技巧",
      "https://media.xyzcdn.net/luPrzAM4PAHFfsL3zaWq917cKpWe.m4a": "02-架构核心技术之分布式缓存",
      "https://media.xyzcdn.net/lkKSYfM0cjQRs7Kkgq_Cr_lK1_rP.m4a": "03-架构核心技术之分布式消息队列",
      "https://media.xyzcdn.net/lvxktq5IoqCYLrvQxON6Kg8HB85V.m4a": "04-架构核心技术之分布式数据存储",
      "https://media.xyzcdn.net/lmEN5okB2dcPxtZh4aX2kVQMdKK7.m4a": "05-架构核心技术之微服务",
      "https://media.xyzcdn.net/ltgm6-yKGMWZvXUdYdVwA4HTlAu2.m4a": "06-高性能系统架构设计",
      "https://media.xyzcdn.net/loEJDdOQrDTtcoyeCtDahMTQW6-J.m4a": "07-高可用系统架构设计",
      "https://media.xyzcdn.net/lu-sdPh9zUcue0l1XVrBtkITtxUP.m4a": "08-系统的安全架构设计",
      "https://media.xyzcdn.net/lrw9aOOfY-L0qEQaqH1Gi57tWb9Y.m4a": "09-架构实战案例分析",
      "https://media.xyzcdn.net/lnMgJjicveR3Usd5KbuOGV1sz3tf.m4a": "10-致未来的架构师",
      "cc": "cc"

    };

  window.doSound = function(which) {
    stopAllAudios();
    document.getElementById("dummy" + which)
      .innerHTML = "<input type=\"button\" value=\"播放\" onclick=\"playSound('soud_" + which + "')\">" + "<font color=\"red\">&lt;--" + soundText[soundFiles[which]] + "</font>"
      +
      "<audio id=\"soud_" + which + "\" src=\"" + soundFiles[which] + "\" controls autoplay preload=\"none\" style=\"display: block;\"></audio>";
    document.getElementById("text")
      .innerHTML = "<p class=\"play-button\"><input type=\"button\" value=\"播放\" id=\"all\" onclick=\"playSound('soud_" + which + "')\">" + "<label for=\"all\"><font color=\"red\">&lt;--" + soundText[soundFiles[which]] + "</font></label></p>";
  };
})();

function stopAllAudios() {
  // 获取所有audio元素  
  var audioElements = document.getElementsByTagName('audio');

  // 遍历所有audio元素并停止播放  
  for (var i = 0; i < audioElements.length; i++) {
    // 检查audio元素是否正在播放  
    if (!audioElements[i].paused) {
      audioElements[i].pause(); // 停止播放  
    }
  }
}

function playSound(which) {

  var audio = document.getElementById(which);
  if (audio.paused) { //如果音频是暂停状态
    stopAllAudios();
    audio.load; //加载音频文件
    audio.play(); //播放
  } else { //否则，也就是说音频是播放状态
    audio.pause(); //就暂停
  }
}
</script>
<span id="text"></span>
<section id="outline-container-h:fd5cb987-da07-4083-a278-46e7bf4f81aa" class="outline-2">
<h2 id="h:fd5cb987-da07-4083-a278-46e7bf4f81aa">开篇词：Get技术人进阶技巧</h2>
<div class="outline-text-2" id="text-h:fd5cb987-da07-4083-a278-46e7bf4f81aa">
<form><input type="button" value="音频" onclick="doSound(0); return false;"></form>
<span id="dummy0"></span>

<p>
不是架构师学架构有什么用？其实，架构可以说是无处不在，每个技术人甚至每个人都应该懂一些架构。
</p>

<p>
为什么呢？所谓的 <b>架构其实是一种思维方式，是整体与部分之间的关系，以及关键细节的设计与规划</b> 。习惯了架构的思维，你 <b>可以从更高的层次去思考，对所做的事做出更正确的决定</b> 。
</p>


<p>
大家有想过吗，为什么起点差不多，有的人走着走着就走到前面了，有的人走着走着就落到后面了？原因当然有很多，但是其中一个重要原因就是，那些走到前面的人会更清楚自己要成为什么样的人并对自己的生活和工作有意无意地进行过架构设计，比如大学是关注社团活动还是关注学业成绩；实习重心是放在夯实理论上还是实践经验上；毕业之后是去外包公司还是去互联网公司，工作后是走技术路线还是管理路线，工作中主动寻找一些有挑战性的任务，还是被动接受上级的安排等等。这些关键的细节都会影响你的职业生涯甚至决定如何度过自己的一生。而如何把这些关键的细节规划与设计好，如何把各个环节和它们之间的关系梳理好了，就需要用到“架构思维”。
</p>

<p>
如果你有架构思维，主动了解自己的工作在整体中的位置和作用，比如说参加一个大系统开发的时候，你熟知自己所做的模块在大系统中的位置，知道该模块和其他重要组成部分之间的关系，进而研究使用更合适的技术和解决方案，并影响团队和项目向更好的方向发展，那你会脱颖而出成为前一种人，获得更好的职业机会，并收获更美好的人生。
</p>
</div>
<div id="outline-container-h:72f0c36f-211f-438a-a1ea-85b09626cdc6" class="outline-3">
<h3 id="h:72f0c36f-211f-438a-a1ea-85b09626cdc6">教程内容</h3>
<div class="outline-text-3" id="text-h:72f0c36f-211f-438a-a1ea-85b09626cdc6">
<ul class="org-ul">
<li>章节1：互联网架构的前世今生</li>
<li>章节2-5：互联网架构的关键技术：缓存、异步、分布</li>
<li>章节6-8：互联网架构的核心要素：性能、可用、安全</li>
<li>章节9：架构设计案例：系统、框架、数据库</li>
<li>章节10：架构师的成长、搞定问题的攻略</li>
</ul>
</div>
</div>
<div id="outline-container-h:4fda3ffa-7387-4737-955d-43428be95b0a" class="outline-3">
<h3 id="h:4fda3ffa-7387-4737-955d-43428be95b0a">为什么学架构</h3>
<div class="outline-text-3" id="text-h:4fda3ffa-7387-4737-955d-43428be95b0a">
<p>
每个工程师都应该懂架构；要知道优秀架构师的必备技能、架构知识体系和学习路径。
</p>


<p>
正式进入章节1之前，我先帮大家明确两个问题。第一，优秀的架构师都具备哪些特点？第二，想学好架构要从哪几方面入手？
</p>
</div>
<div id="outline-container-h:48d2aca1-c6b9-4855-996f-fc92545b5dd8" class="outline-4">
<h4 id="h:48d2aca1-c6b9-4855-996f-fc92545b5dd8">优秀的架构师特点</h4>
<div class="outline-text-4" id="text-h:48d2aca1-c6b9-4855-996f-fc92545b5dd8">
<ul class="org-ul">
<li><p>
强烈的好奇心
</p>

<p>
除了对软件技术本身，他们对世界上很多事情都保持着强烈的好奇心，不管是 宇宙太空，还是生活中一些有趣的事情。强烈的好奇心，能够让他们敏锐地发 现有潜力的重要的新技术。
</p></li>

<li><p>
敏锐的业务嗅觉
</p>

<p>
我们做工程技术和做科学研究是不同的，做工程技术最终一定是要服务于实际业务的，是要产生实际价值的，是要赚钱的。那么，业务需要什么样的技术点，业务需要什么样的功能，业务需要什么样的好技术来实现，这些都需要有敏锐的业务嗅觉。
</p></li>

<li><p>
扎实的技术基础
</p>

<p>
基本功一定要扎实，比如说，操作系统、数据结构，数据库原理，编程语言和算法原理，设计模式和设计原则等等。只有这些软件技术的基础知识都学扎实了，你才能够构建起敏锐的技术嗅觉，才能够构建起自己坚实的技术体系。
</p></li>

<li><p>
出色的编程能力
</p>

<p>
很多人认为软件架构师不需要编程，虽然架构本身也许不需要编程，但是架构师一定要有出色的编程能力，一定要能够写优秀的代码，这样才能够对架构中那些最敏感的技术点保持敏锐的技术嗅觉，能够抓住软件的关键点，不会在纷繁复杂的问题中迷失方向。
</p></li>

<li><p>
对主流技术产品和模式的深刻领悟
</p>

<p>
架构师不是凭空进行架构设计的，是站在巨人的肩膀上的，是在现有的其他优秀架构基础之上进一步设计出符合自己业务特点的架构系统来。那么，这要求你要对主流的技术产品和模式是如何设计的，相关的业务系统的模式有哪些，使用的技术方案有哪些，有深刻地领悟。只有在领悟的基础之上，去思考自己的业务特点，取其精华去其糟粕，做最好的匹配和改进，才能够设计出属于自己的优秀的系统。
</p></li>
</ul>
</div>
</div>
<div id="outline-container-h:0bb49648-d05c-4bc4-aabe-e2baefa975e5" class="outline-4">
<h4 id="h:0bb49648-d05c-4bc4-aabe-e2baefa975e5">软件架构的知识体系</h4>
<div class="outline-text-4" id="text-h:0bb49648-d05c-4bc4-aabe-e2baefa975e5">
<p>
给你提供一个学习路径。大体上来说包含这三部分的内容
</p>

<ul class="org-ul">
<li>基础：数据结构、操作系统原理、算法能力、设计模式</li>
<li>技术：缓存、异步、分布式存储、微服务</li>
<li>架构：高可用、高性能、安全性</li>
</ul>

<p>
第一部分就是基础，我前面说过架构师一定要有扎实的技术基础和编程能力，这里面包括数据结构、操作系统、算法应用、设计模式等一切拥有优秀编程能力所应该熟知的软件基础知识。
</p>

<p>
第二部分是技术，如何使用优秀的技术产品去构建你的系统，这些技术产品各自的优缺点、原理、特点是什么，都要深刻的掌握和领悟。对于大型互联网系统而言，主要包括缓存、异步、分布式存储、微服务等。
</p>

<p>
第三部分是架构设计，架构设计需要考虑的点主要包括高可用、高性能、安全性三部分。
</p>
</div>
</div>
<div id="outline-container-h:f8303e84-408e-4add-9f11-cedf3fba328e" class="outline-4">
<h4 id="h:f8303e84-408e-4add-9f11-cedf3fba328e">教程目的</h4>
<div class="outline-text-4" id="text-h:f8303e84-408e-4add-9f11-cedf3fba328e">
<p>
虽然基础是一个需要长期积累和积淀的过程，可能需要几年甚至十几年时间去慢慢提升，但是“技术能力”和“架构思维”却是可以短时间内进行提升的，这与本教程的设置初衷不谋而合。
</p>
</div>
</div>
</div>
</section>
<section id="outline-container-h:93bf4462-2313-4492-a514-d8c24e9fbd99" class="outline-2">
<h2 id="h:93bf4462-2313-4492-a514-d8c24e9fbd99">第01讲：大型架构的演进之路</h2>
<div class="outline-text-2" id="text-h:93bf4462-2313-4492-a514-d8c24e9fbd99">
<form><input type="button" value="音频" onclick="doSound(1); return false;"></form>
<span id="dummy1"></span>

<blockquote>
<ol class="org-ol">
<li>大型互联网系统的特点</li>
<li>系统处理能力提升的两种途径</li>
<li>大型互联网系统架构演化过程</li>
</ol>
</blockquote>

<p>
主要包含三部分内容。
</p>

<ul class="org-ul">
<li><p>
第一部分是大型互联网系统的特点
</p>

<p>
分析大型互联网有哪些特点和挑战，它们是现在一些技术和架构方案产生的原因。
</p></li>

<li><p>
第二部分是系统处理能力提升的两种途径
</p>

<p>
提供了两种面对挑战的解决思路。
</p></li>

<li><p>
第三部分是大型互联网系统架构演化过程
</p>

<p>
这个过程几乎包含了现在所有主要的互联网架构的考量点、技术方案、要解决的问题等，是整个互联网系统架构的一个综述，可以了解互联网架构的全貌。
</p></li>
</ul>
</div>
<div id="outline-container-h:107091cd-c383-4ab8-87bc-409f97d4f5b9" class="outline-3">
<h3 id="h:107091cd-c383-4ab8-87bc-409f97d4f5b9">大型互联网系统的特点</h3>
<div class="outline-text-3" id="text-h:107091cd-c383-4ab8-87bc-409f97d4f5b9">
<ul class="org-ul">
<li>高并发、大流量</li>
<li>高可用</li>
<li>海量数据</li>
<li>用户分布广泛，网络情况复杂</li>
<li>安全环境恶劣</li>
<li>需求快速变更，发布频繁</li>
</ul>
</div>
<div id="outline-container-h:97df54dd-2948-4a5e-b719-01a56132f84f" class="outline-4">
<h4 id="h:97df54dd-2948-4a5e-b719-01a56132f84f">高并发和大流量</h4>
<div class="outline-text-4" id="text-h:97df54dd-2948-4a5e-b719-01a56132f84f">
<p>
大型互联网需要面对高并发的访问用户，比如在天猫“双11”的时候，一分钟之内，有超过一千万的独立用户访问整个天猫系统，大规模的并发用户访问会对系统的处理能力造成巨大的冲击，系统必须 <b>要有足够强的处理能力</b> 才能够满足。同时有这么多用户来访问，产生了巨大的访问流量，对 <b>系统的抗压能力</b> 形成了考验。
</p>
</div>
</div>
<div id="outline-container-h:ddcbf451-9e4d-4ddb-a498-7e98576336ae" class="outline-4">
<h4 id="h:ddcbf451-9e4d-4ddb-a498-7e98576336ae">高可用</h4>
<div class="outline-text-4" id="text-h:ddcbf451-9e4d-4ddb-a498-7e98576336ae">
<p>
<b>大型互联网系统必须要 7×24 小时不间断地提供服务</b> ，和传统软件系统不同，银行或者是电信甚至零售业，它们都有下班时间，下了班以后可以对系统进行停机维护和升级发布，但是互联网没有下班时间，所以一直要保持高可用，7×24 小时永不间断。为了保证系统的高可用，必须要进行特别的系统架构设计。
</p>
</div>
</div>
<div id="outline-container-h:7ae4769e-f2da-4ab6-baf7-07d77b198485" class="outline-4">
<h4 id="h:7ae4769e-f2da-4ab6-baf7-07d77b198485">海量的数据存储</h4>
<div class="outline-text-4" id="text-h:7ae4769e-f2da-4ab6-baf7-07d77b198485">
<p>
因为互联网需要满足大量的用户使用，所以这些用户会产生很多的数据，需要对这些数据进行重组和管理。除了用户提交的数据，互联网还会采集很多其它的数据，包括一些用户行为的数据、第三方的数据以及网络爬虫获取的数据，通过 <b>大数据技术对这些数据做进一步分析， 对用户进行更精准的营销和服务，以发现新的业务增长点</b> 。
</p>
</div>
</div>
<div id="outline-container-h:476d23cf-6d13-453a-8a3d-17a2cfd23bff" class="outline-4">
<h4 id="h:476d23cf-6d13-453a-8a3d-17a2cfd23bff">用户分布广泛，网络情况复杂</h4>
<div class="outline-text-4" id="text-h:476d23cf-6d13-453a-8a3d-17a2cfd23bff">
<p>
互联网是为全球用户提供服务的，用户分布范围广，各地的网络情况千差万别，为了使所有用户能够得到统一的良好的体验，需要对系统架构进行相关的设计。
</p>
</div>
</div>
<div id="outline-container-h:51c77679-7fc6-43b9-b18c-6f9b2b39a2f1" class="outline-4">
<h4 id="h:51c77679-7fc6-43b9-b18c-6f9b2b39a2f1">安全环境恶劣</h4>
<div class="outline-text-4" id="text-h:51c77679-7fc6-43b9-b18c-6f9b2b39a2f1">
<p>
因为互联网是 <b>开放</b> 的，所以互联网站很容易就会 *受到攻击*。
</p>
</div>
</div>
<div id="outline-container-h:850673a0-8d8c-40f0-b7ba-c380c345aeff" class="outline-4">
<h4 id="h:850673a0-8d8c-40f0-b7ba-c380c345aeff">需求变化快，发布频繁</h4>
<div class="outline-text-4" id="text-h:850673a0-8d8c-40f0-b7ba-c380c345aeff">
<p>
和传统的软件版本发布频率比， <b>互联网产品为了快速适应市场，满足用户需求，发布频率是非常高的</b> 。比如 Office 这样的产品发布版本是以年为单位的，而大型网站的产品发布一般是以周为单位的，每个星期都会发布新的版本来更新产品特性。
</p>
</div>
</div>
</div>
<div id="outline-container-h:048b7b6e-abdb-4aea-b9c4-32a1301c4ce6" class="outline-3">
<h3 id="h:048b7b6e-abdb-4aea-b9c4-32a1301c4ce6">系统处理能力提升的两种途径</h3>
<div class="outline-text-3" id="text-h:048b7b6e-abdb-4aea-b9c4-32a1301c4ce6">
<p>
因为互联网主要面对的技术挑战就是用户量不断上升产生的并发访问压力以及数据存储压力，所以系统需要更强的处理能力才能解决这些问题。那么如何解决这些问题？主要有两种途径。
</p>

<ul class="org-ul">
<li>垂直伸缩</li>
<li>水平伸缩</li>
</ul>
</div>
<div id="outline-container-h:a4289309-aedf-4438-abe6-6dd64e59c428" class="outline-4">
<h4 id="h:a4289309-aedf-4438-abe6-6dd64e59c428">垂直伸缩</h4>
<div class="outline-text-4" id="text-h:a4289309-aedf-4438-abe6-6dd64e59c428">
<p>
所谓的 <b>垂直伸缩就是提升单台服务器的处理能力</b> ，比如说用更快频率、更多核的 CPU，用更大的内存，用更快的网卡，用更多的磁盘组成一台服务器，使单台服务器的处理能力得到提升，通过这种手段提升系统的处理能力。
</p>
</div>
</div>
<div id="outline-container-h:ba66e68c-efe1-42df-af5b-b4d329ace9dd" class="outline-4">
<h4 id="h:ba66e68c-efe1-42df-af5b-b4d329ace9dd">水平伸缩</h4>
<div class="outline-text-4" id="text-h:ba66e68c-efe1-42df-af5b-b4d329ace9dd">
<p>
所谓的水平伸缩，是说 <b>不提升单机的处理能力，并不使用更昂贵的、更快的、更厉害的硬件，而是使用更多的服务器，将这些服务器构成一个分布式集群</b> 。这个集群统一对外提供服务，来提高系统整体的处理能力。
</p>
</div>
</div>
<div id="outline-container-h:9167f330-e097-4e28-89f6-fc296a72fc47" class="outline-4">
<h4 id="h:9167f330-e097-4e28-89f6-fc296a72fc47">垂直伸缩的局限</h4>
<div class="outline-text-4" id="text-h:9167f330-e097-4e28-89f6-fc296a72fc47">
<pre class="example" id="org71ccc97">
&lt;----传统软件企业（慢用"垂直伸缩"） --互联网出现--  互联网行业（多用"水平伸缩"） 
</pre>

<p>
在大型互联网出现之前，传统的软件，比如银行、电信这些企业的软件系统，主要是使用垂直伸缩这种手段实现系统能力提升的，先是提升服务器的硬件水平，就像我们刚才说的，提升 CPU 的能力、提升网卡的能力、提升内存和磁盘的能力。当某种类型的服务器能力提升到了瓶颈以后，就会用更强大的服务器，比如说从服务器升级到小型机，从小型机提升到中型机，从中型机提升到大型机，服务器越来越强大，处理能力也越来越强大，当然价格也越来越昂贵，运维越来越复杂。
</p>

<p>
而在互联网行业中多采用水平伸缩的手段。这主要是因为 <b>垂直伸缩有一些缺点</b> 。
</p>


<figure id="org0d9abca">
<img src="./images/img_20240301_205524.png" alt="img_20240301_205524.png" width="80%">

</figure>

<ol class="org-ol">
<li><p>
当垂直伸缩达到一定程度以后，继续增加计算需要花费更多的钱。
</p>

<p>
如果你服务器的内存条没有插满，这个时候你插一条内存不会花费太多的钱。但是如果内存条已经插满了，你想要更强大的容量、更大内存空间，就需要购买更强大的服务器对整体进行升级，这个时候就需要花更多的钱。而从服务器到小型机，到中型机，再到大型机，每一次这种硬件的升级，都意味着成本数十倍的增加。
</p></li>

<li><p>
垂直伸缩是有物理极限的。
</p>

<p>
单单一台机器的处理能力是有极限的，即使是大型机，也有自己的物理极限，它不可能无限地伸缩下去。相对于硬件的极限，互联网的用户需求几乎是没有极限的。更何况到了物联网时代，数据产生的速度和对系统处理能力的要求更是成千上万倍的增加。
</p></li>

<li><p>
操作系统的设计或者应用程序的设计制约着垂直伸缩。
</p>

<p>
因为垂直伸缩就意味着程序在单一服务器上运行，那么这个程序应用以及操作系统要相应具备管理这么庞大的计算资源的能力。要使用这些计算资源，就需要应用程序本身去管理、调度这些资源，这对应用程序以及操作系统的设计提出了极大的挑战。并且，我们知道，应用程序的核心价值是处理业务逻辑，从而满足用户需求，如果应用程序里有大量的代码是去管理系统资源的，必然导致应用程序复杂度提高，难以开发和维护。
</p></li>
</ol>


<p>
与之相比，水平伸缩就没有这些问题。采用水平伸缩，只要架构合理，能够将服务器添加到集群中，你的系统是可以始终正常运行的。它没有极限，成本也不会在某个临界点突然增加。甚至，逐渐增加服务器，获得更强的计算处理能力，还比以前的服务器更便宜，因为硬件的价格总是在不断下降的。
</p>

<p>
同时，你的应用程序虽然是为单一服务器而设计的，但水平伸缩只是让程序部署在更多的服务器上，并不需要对应用程序进行太多的改变，应用程序不会受到硬件制约。
</p>

<p>
但是要让更多的服务器构成一个整体，需要在架构上进行设计，让这些服务器成为整体系统中的一个部分，把它们有效地组织起来，统一提升系统的处理能力。
</p>
</div>
</div>
</div>
<div id="outline-container-h:2f0012e9-dc1a-42de-af53-88318c996d59" class="outline-3">
<h3 id="h:2f0012e9-dc1a-42de-af53-88318c996d59">大型互联网架构演化进程</h3>
<div class="outline-text-3" id="text-h:2f0012e9-dc1a-42de-af53-88318c996d59">
<p>
下面我们通过大型互联网系统架构的演进过程，来详细讲解如何通过水平伸缩方式逐步提升系统处理能力。
</p>


<p>
这个过程看起来像是一个业务演进过程，也是用户量不断增长的过程。实际上驱动大型互联网的技术发展的就是不断增加的用户量。数据量随着用户量的增加而增加，导致并发访问压力持续增大，产生了一系列技术挑战。为了应对这些挑战，要不断地增强系统的技术处理能力，优化系统的架构，如下所示。
</p>

<ul class="org-ul">
<li>少量用户：单机系统</li>
<li>万级用户：数据库与应用分离</li>
<li>十万级用户：使用缓存改善性能、应用服务集群化</li>
<li>百万级用户：使用反向代理和 CDN 加速响应、数据库读写分离</li>
<li>千万级用户：使用分布式文件系统和分布式数据库系统</li>
<li>亿级用户：使用搜索引擎、NoSQL、消息队列与分布式服务</li>
</ul>


<p>
最早的时候是单机系统，这时候可以满足少量用户的使用；随着数据量提升，需要进行应用服务器与数据库分离，这时候可以满足万级用户的使用；再然后需要通过分布式缓存和服务器集群提升系统性能，可以满足十万级的用户；之后需要进行反向代理，CDN 加速，还需要数据库读写分离，以满足百万用户级的访问；随着数据量爆发式增长，使用分布式文件系统和分布式数据库系统，以满足千万级用户的访问；最后使用搜索引擎、NoSQL、消息队列、分布式服务等更复杂的技术方案，以满足亿级用户的访问。
</p>
</div>
<div id="outline-container-h:985cc459-3270-44bb-9387-c6049b5e0ef5" class="outline-4">
<h4 id="h:985cc459-3270-44bb-9387-c6049b5e0ef5">单机系统</h4>
<div class="outline-text-4" id="text-h:985cc459-3270-44bb-9387-c6049b5e0ef5">
<p>
先来看单机系统，在最早的时候，系统因为用户量比较少，可能只是有限的几个用户，这个阶段系统主要是 <code>用来验证技术以及业务模式是否可行</code> ，系统也不需要太复杂，只需要具备有限的几个主要功能。应用程序开发完以后，部署在应用服务器上，一个应用访问自己服务器上的数据库，访问自己服务器的文件系统，如下所示，这就构成了一个单机系统，这个系统就可以满足少量用户使用了。
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#24212;&#29992;&#26381;&#21153;&#22120;
</span>
&#24212;&#29992;&#31243;&#24207;
1. &#35775;&#38382;&#25991;&#20214;
2. &#35775;&#38382;&#25968;&#25454;&#24211;
</pre>
</div>

<p>
如果这个系统被证明是可行的、有价值的、好用的，比如 Google 的搜索引擎系统，会逐渐吸引其他用户，造成用户访问增长。Google 最早就是部署在斯坦福的实验室里面，给实验室的同学和老师使用的。这些同学和老师使用后发现 Google 的搜索引擎比以前的搜索引擎（比如说像 Yahoo 这样的搜索引擎）要好用的多，这个消息很快就扩散出去了，整个斯坦福大学的老师同学可能都会过来访问这个服务器。这时候 <code>服务器就不能够承受访问压力</code> 了，需要进行第一次升级-&#x2013;&#x2014; <code>数据库与应用分离</code> 。数据库与应用分离如下所示，而前面单机的时候，数据库和应用程序是部署在一起的。
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b22222;"># </span><span style="color: #b22222;">&#24212;&#29992;&#26381;&#21153;&#22120;
</span>&#24212;&#29992;&#31243;&#24207; <span style="color: #b22222;">#</span><span style="color: #b22222;">&#35775;&#38382;&#25991;&#20214;&#21644;&#25968;&#25454;&#24211;
</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#25991;&#20214;&#26381;&#21153;&#22120;
</span>&#25991;&#20214;

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#25968;&#25454;&#26381;&#21153;&#22120;
</span>&#25968;&#25454;&#24211;
</pre>
</div>
</div>
</div>
<div id="outline-container-h:562940f9-46f8-4ad2-8883-ac7371ba23c8" class="outline-4">
<h4 id="h:562940f9-46f8-4ad2-8883-ac7371ba23c8">缓存</h4>
<div class="outline-text-4" id="text-h:562940f9-46f8-4ad2-8883-ac7371ba23c8">
<ul class="org-ul">
<li>分布式缓存</li>
<li>本地缓存</li>
</ul>

<p>
进行第一次分离的时候，应用程序、数据库、文件系统分别部署在不同的服务器
上，从1 台服务器变成了 3 台服务器，那么相应的处理能力就提升了 3 倍。这
种分离几乎是不需要技术成本的，只需要把数据库文件系统进行远程部署和远程
访问就可以了，这个时候的处理能力提升了3 倍。
</p>

<p>
然而 <code>随着用户进一步的增加</code> ，更多的用户过来访，3 台服务器也不能够承受这样的压力了，那么就需要 <code>使用缓存改善性能</code> ，如下图所示。
</p>


<figure id="org0f24759">
<img src="./images/img_20240301_212511.png" alt="img_20240301_212511.png" width="80%">

</figure>


<p>
缓存分为 <code>分布式缓存</code> 和 <code>本地缓存</code> 两种。
</p>

<p>
分布式缓存可以构建一个集群存储更多的缓存数据。 <code>通过使用缓存应用程序不需要访问数据库</code> 。
</p>
<ul class="org-ul">
<li>因为数据库的数据是存储在磁盘上的，访问数据库需要花费更多的时间；而缓存中的数据是存储在内存中的， <code>访问时间更短</code> 。</li>
<li>另一方面，数据库中的数据以原始数据的形式存在，而缓存中的数据是以结果形数据存在，比如已经构建的某个对象缓存的是就这个对象，不需要进行对象的计算，这样就 <code>减少了计算的时间同时也减少了 CPU 的压力</code> 。</li>
</ul>

<p>
这样不管是通过对计算资源的节约，还是访问时间的节约都会有比较在的提升。通过使用缓存可以极大的提升性能。
</p>


<figure id="org06c394e">
<img src="./images/img_20240302_000342.png" alt="img_20240302_000342.png" width="80%">

</figure>


<p>
虽然通过数据分离可以使用缓存加快系统的响应时间减少系统计算压力，但是 <code>随着用户的增加，应用服务器可能成为瓶颈</code> ；一台应用服务器连接大并发量用户的访问可能成为瓶颈点，这时就是需要对应用服务器升级。解决方法就是 <code>通过负载均衡服务器将应用服务部署为一个集群，添加更多的应用服务器来处理用户的访问</code> 。
</p>

<p>
虽然可以通过负载均衡服务器不断地增加应用服务器为更多的用户提供系统访问服务，但是这个时候 <code>数据库再一次成为系统的瓶颈点</code> 。因为大量的用户访问 <code>主要操作都会落在数据库上</code> ，虽然缓存可以缓存一部分数据库读操作，但是还有一部分读操作在缓存中是找不到的，还是需要访问数据库。单一的数据库不能承担重大的访问压力，这时候的解决办法就是 <code>数据库读写分离</code> ，如下图所示。
</p>



<figure id="org82106ab">
<img src="./images/img_20240301_223140.png" alt="img_20240301_223140.png" width="80%">

</figure>


<p>
将一个数据库通过数据复制的方式分裂为俩个数据库，主数据主要负责数据的写操作，所有的写操作都复制到从数据库上，保证从数据库上的数据和主数据库上的数据一致；而从数据库主要提供数据的读操作。
</p>

<p>
通过这样一种手段， <code>将一台数据库服务器水平伸缩成两台数据库服务器，可以提供更强大的数据处理能力</code> 。
</p>
</div>
</div>
<div id="outline-container-h:8597c0f0-e5cf-4de2-ac07-343154f652be" class="outline-4">
<h4 id="h:8597c0f0-e5cf-4de2-ac07-343154f652be">反向代理和 CDN 加速</h4>
<div class="outline-text-4" id="text-h:8597c0f0-e5cf-4de2-ac07-343154f652be">
<p>
在对数据库做读写分离以后，要想更进一步增加系统的处理能力，需要使用 <code>反向代理和 CDN 加速</code> ，如下图所示。
</p>



<figure id="orgee14809">
<img src="./images/img_20240301_223655.png" alt="img_20240301_223655.png" width="80%">

</figure>

<p>
所谓的 <code>CDN 是指距离用户最近的一个服务器</code> ，当访问一个互联网应用的时候，我们的访问请求并不是直接到达互联网站的数据中心的，而是通过运营服务商进行数据转发的。那么在进行数据转发的时候，最好已经有我们想要访问的数据，这样就不需要访问互联网数据中心了。这个服务就叫作 CDN 服务。
</p>

<p>
CDN 服务就是部署在网络运营商机房里的离用户最近的一个服务器，用户请求先到这里查询有没有用户需要的数据，如果有，就从 CDN 直接返回，如果没有，再通过 CDN 进一步访问网站的数据中心，得到数据后再缓存到 CDN 供其他用户访问或下一次访问，所以 <code>CDN 的本质还是一个缓存</code> 。
</p>

<p>
<code>用户请求到达网站的数据中心后，也不是直接请求应用服务器，依然是查找一次缓存，这个缓存叫作反向代理服务器</code> 。
</p>

<p>
反向代理服务器是指 <code>通过反向代理的方式代理整个网站的请求服务</code> ，先在反向代理服务器中查找是否有用户请求的数据，如果有，就从反向代理服务器直接返回；如果没有，再去请求应用服务器。 <code>通过这样的 CDN 和反向代理两级缓存，可以返回绝大部分用户请求的网络数据，极大地减少应用服务器的负载压力，提升服务器数据中心的处理能力，响应更多的用户并发处理请求</code> 。
</p>
</div>
</div>
<div id="outline-container-h:ecaca706-d140-463a-a3de-237cb1fcfaf8" class="outline-4">
<h4 id="h:ecaca706-d140-463a-a3de-237cb1fcfaf8">分布式文件系统和分布式数据库系统</h4>
<div class="outline-text-4" id="text-h:ecaca706-d140-463a-a3de-237cb1fcfaf8">
<p>
更进一步思考，虽然 CDN 和反向代理已经缓存了大量的用户数据，返回了大量的用户请求，但是随着用户量的增加，还是有很多的用户请求会到达数据中心。这个时候 <code>文件系统和数据库系统依然会成为瓶颈点</code> 。
</p>

<p>
那么如何解决这个瓶颈点？解决方案主要是 <code>分布式的文件系统</code> 和 <code>分布式的数据库系统</code> 。如下图所示。
</p>


<figure id="org1062dcd">
<img src="./images/img_20240301_224538.png" alt="img_20240301_224538.png" width="80%">

</figure>


<p>
所谓的 <code>分布式文件系统就是通过一组服务器集群统一对外提供文件服务</code> 。像淘宝的商品图片服务以及 Facebook 这样的相册服务，每天都有大量的用户上传大量的图片，那么如何管理这些海量的文件图片？这就要使用一个分布式的文件服务器系统。
</p>

<p>
随着 <code>数据量逐渐增加</code> ，前面讲的主从数据库也不能够承受这么大的访问压力和存储容量要求，那么就需要 <code>对数据库做进一步水平伸缩</code> ，使用分布式的数据库。即 <code>通过数据分片的方式，将一张表的数据分布在多个物理服务器上，以减少单一数据库的服务器访问压力</code> 。通过这样的手段可以进一步提升系统的处理能力。
</p>
</div>
</div>
<div id="outline-container-h:a23a070f-448b-46fd-a4ce-04f763c2842f" class="outline-4">
<h4 id="h:a23a070f-448b-46fd-a4ce-04f763c2842f">消息队列与分布式服务</h4>
<div class="outline-text-4" id="text-h:a23a070f-448b-46fd-a4ce-04f763c2842f">
<p>
最后，随着用户量进一步增加，要想实现更强大的计算处理能力，可以使用的技术手段有：
</p>

<ul class="org-ul">
<li>分布式消息队列服务</li>
<li>搜索引擎</li>
<li>NoSQL</li>
<li>通过分布式服务，将可复用的业务分离开来，部署在不同的服务器集群上</li>
</ul>

<p>
用户量增加，除了意味着用户对系统的访问压力增加，还伴随着业务复杂度增加。 <code>使用分布式消息队列和分布式的服务，主要解决的就是业务增加时系统的复杂度问题</code> 。如下图所示。
</p>


<figure id="orgaf2d52a">
<img src="./images/img_20240301_225039.png" alt="img_20240301_225039.png" width="80%">

</figure>

<p>
随着业务的增加，很多的业务都有一些重复的服务功能需要复用，这时候使用分布式的服务去解决服务的复用问题。而不同的服务、不同的应用之间，它们的耦合关系会使得系统更加复杂，这时候使用分布式消息队列服务，将不同的应用服务器进行解耦，通过消息进行连接，而不是服务调用的方式或者应用调用的方式进行连接，使它们之间的关系变得低耦合，使服务变得更加简单，使系统的处理能力和扩容能力变得更加的强大。
</p>
</div>
</div>
<div id="outline-container-h:9acd4c8f-d0ad-47d8-85d2-79d27173dee7" class="outline-4">
<h4 id="h:9acd4c8f-d0ad-47d8-85d2-79d27173dee7">总结回顾</h4>
<div class="outline-text-4" id="text-h:9acd4c8f-d0ad-47d8-85d2-79d27173dee7">
<pre class="example" id="orgaec1271">
大型互联网系统的挑战--&gt;提升系统处理能力的两种手段--&gt;单机系统到分布式系统--&gt;使用各种
缓存--&gt;分布式存储--&gt;微服务与异步架构
</pre>

<p>
大型互联网系统的挑战主要包括：
</p>

<ul class="org-ul">
<li>高并发和大流量请求的挑战</li>
<li>高可用的挑战</li>
<li>海量数据的挑战</li>
<li>网络情况复杂、安全性差的挑战</li>
<li>以及需求快速变更、发布频繁的挑战</li>
</ul>

<p>
为了应对这样的挑战，需要提升系统的处理能力。处理能力提升有两种手段，
</p>
<ul class="org-ul">
<li>一种是垂直伸缩</li>
<li>一种是水平伸缩。</li>
</ul>

<p>
垂直伸缩有自身的局限性，所以在互联网企业中主要使用的手段是水平伸缩。
</p>

<p>
水平伸缩的原理就是不断地增加服务器以提高系统的处理能力。而如何添加新服务器，使新的服务器和原有的服务器构成一个完整的整体对外提供服务，就是互联网架构的主要技术挑战和技术内容。
</p>

<p>
在应对挑战的过程中，互联网架构主要的应对方法，就是 <code>从单机系统到分布式系统</code> 。即通过服务器拆分的方式，系统架构从单机系统一个服务器变成很多个服务器。这是整个发展思路以及发展过程。
</p>

<p>
其中最主要的发展阶段包括：
</p>

<ul class="org-ul">
<li>使用分布式的缓存，提高系统的访问特性，减少数据存储的压力；</li>

<li>使用负载均衡，提供更多的应用服务器提高系统计算处理能力；</li>

<li>使用分布式存储，提供更多的服务器，分摊数据的读写压力；</li>

<li><p>
使用微服务与异步架构，使系统变得更加低耦合，使应用业务变得更加可复用，提升业务处理能力，从而支撑起一个大型网站系统架构。
</p>

<p>
本节技术架构演化提到的各种技术，比如分布式缓存，异步架构，分布式数据库，分布式微服务架构，高性能、高可用、安全的系统架构和案例分析等，都会在后续章节中详细阐述。
</p></li>
</ul>
</div>
</div>
</div>
</section>
<section id="outline-container-h:1fbe3d16-8b33-40cb-a70c-6ab1fb5b6bf4" class="outline-2">
<h2 id="h:1fbe3d16-8b33-40cb-a70c-6ab1fb5b6bf4"><b><code>第02讲：架构核心技术之分布式缓存(重要)</code></b></h2>
<div class="outline-text-2" id="text-h:1fbe3d16-8b33-40cb-a70c-6ab1fb5b6bf4">
<form><input type="button" value="音频" onclick="doSound(2); return false;"></form>
<span id="dummy2"></span>

<blockquote>
<ol class="org-ol">
<li>缓存特点</li>
<li>缓存的主要类型</li>
<li>使用缓存注意事项</li>
<li>分布式对象缓存</li>
</ol>
</blockquote>

<p>
本章节的主题是分布式缓存。
</p>
</div>
<div id="outline-container-h:efe6b289-9727-4608-9a36-29442cd1aaec" class="outline-3">
<h3 id="h:efe6b289-9727-4608-9a36-29442cd1aaec">缓存知识架构图</h3>
<div class="outline-text-3" id="text-h:efe6b289-9727-4608-9a36-29442cd1aaec">
<p>
缓存是架构设计中一个重要的手段。
</p>

<p>
缓存的主要 <b>特点</b> :
</p>
<ul class="org-ul">
<li>技术比较简单</li>
<li>对性能提升的效果又很显著</li>
</ul>

<p>
所以缓存在很多地方都会被用到。
</p>

<p>
使用缓存需要注意几个 <b>关键指标</b> ：
</p>
<ul class="org-ul">
<li>缓存键集合大小</li>
<li>缓存空间的大小</li>
<li>缓存的使用寿命</li>
</ul>

<p>
这三个指标决定了缓存的有效性、缓存的使用效率、缓存实现的效果。
</p>

<p>
缓存的 <b>类型</b> 主要有
</p>
<ul class="org-ul">
<li>代理缓存</li>
<li>反向代理缓存</li>
<li>CDN 缓存</li>
<li>对象缓存</li>
</ul>

<p>
缓存知识图谱如下图所示。
</p>


<figure id="org515bc62">
<img src="./images/CgotOV13Eh2AUjPjAAEIXLhmsGo317.png" alt="CgotOV13Eh2AUjPjAAEIXLhmsGo317.png" width="80%">

</figure>


<p>
不是所有的数据都适合使用缓存， <b>使用缓存的时候需要注意</b> 以下几点。
</p>

<ul class="org-ul">
<li>数据频繁修改，这类数据使用缓存效果比较差。</li>

<li>数据没有热点，这类数据缓存的命中率比较差。</li>

<li>数据不一致，因为缓存的数据和数据库的数据是不同步的，可能存在数据不一致的情况，如果业务场景对数据一致性要求非常高，这个时候使用缓存也要注意。</li>

<li>缓存雪崩，当缓存崩溃的时候，可能会导致整个系统的崩溃，这也是使用缓存中要注意的一个事项。</li>
</ul>

<p>
在架构中使用最多的，也是关注最多的是分布式缓存。 <b>分布式缓存</b> 最重要的几个技术点是：
</p>

<ul class="org-ul">
<li>分布式对象缓存的架构</li>
<li>分布式对象缓存的访问模型</li>
<li>分布式缓存中一个重要的算法-&#x2014;一致性哈希算法。</li>
</ul>
</div>
</div>
<div id="outline-container-h:066305cf-420e-4081-b241-a632a628badf" class="outline-3">
<h3 id="h:066305cf-420e-4081-b241-a632a628badf">缓存的特点</h3>
<div class="outline-text-3" id="text-h:066305cf-420e-4081-b241-a632a628badf">
<p>
缓存的主要特点：
</p>

<ul class="org-ul">
<li>技术简单</li>

<li>性能提升显著</li>

<li>应用场景多</li>
</ul>

<p>
缓存可以被很容易地添加到现有的应用中，不需要复杂的架构技术。在现有的系统中使用缓存，该系统所受到的影响和要做出的调整是非常小的，但是使用缓存以后性能提升却非常明显。因此，使用缓存的场景非常多。不仅在系统架构中，在计算机的整个体系结构中缓存几乎是无处不在的。
</p>

<p>
比如，CPU 中就有缓存，在 CPU 固件里就有 cache，当 CPU进行计算的时候， 它并不总是每次都去内存中读取数据，而是预加载一部分指令和数据到cache 里 面，也就是 CPU 的缓存里面，CPU 核心计算取的数据其实大多数是 CPU缓存中的数据。
</p>

<p>
再比如，操作系统的文件缓存。操作系统对磁盘进行操作的时候，它也会对数据进行缓存，以加快操作系统访问磁盘文件数据的速度。
</p>

<p>
还有就是数据库的查询缓存，数据库本身也会对一些数据表进行缓存。比如对索引的结构 B+ 树进行缓存，对一些热点的数据记录也要进行缓存，以加快应用程序的访问速度。
</p>

<p>
在外部应用系统中，比较常用的有 DNS 客户端缓存、HTTP 浏览器缓存、HTTP 代理和反向代理缓存、CDN 缓存，以及各种类型的对象缓存，对象缓存常用的比如 Redis、Memcached 等等。
</p>
</div>
<div id="outline-container-h:99f8885d-7dc8-4925-8c87-e15262c3d945" class="outline-4">
<h4 id="h:99f8885d-7dc8-4925-8c87-e15262c3d945">缓存提高性能的优势</h4>
<div class="outline-text-4" id="text-h:99f8885d-7dc8-4925-8c87-e15262c3d945">
<p>
缓存是架构性能优化的最重要的手段，使用缓存来提升系统性能主要有三方面优势。
</p>

<ol class="org-ol">
<li>第一个方面是缓存的数据 <code>来自于内存</code> ，访问速度更快。我们知道数据从内存中读取要 <code>比磁盘上读取速度会更快</code> ，所以使用缓存从内存中读取数据会使系统获得更快的响应性能，系统的访问速度会更快，处理速度也会更快。</li>

<li>第二个方面是缓存中存储的数据形态通常是 <code>最终的结果形态</code> ，减少资源消耗。比如说，我们缓存一个网页、一个对象，这些数据通常是我们计算过的结果。从缓存中读取数据跟从磁盘中或者数据库中直接读取数据不同，从数据库中读取的数据要进行加工处理，生成我们最终的结果，而从缓存中读取的数据通常都是直接的最终结果。因此，使用缓存中的数据可以 <code>减少CPU 的资源消耗，不需要进行中间的计算</code> ，可以进一步提高响应的特性。</li>

<li>第三个方面是使用缓存可以 <code>降低</code> 数据库磁盘或者网络的 <code>负载压力</code> 。不需要从 外部的IO 设备中去读取数据，这些数据直接从本地缓存或内存中读取，减少IO设备的访问压力。我们知道 IO设备是最容易出现瓶颈的地方，减少这些设备的访问压力、负载压力，可以 <code>更好地提升整个系统的处理能力</code> 。</li>
</ol>
</div>
</div>
<div id="outline-container-h:448eb2bd-1a0c-44c5-a217-5328daeaa6bb" class="outline-4">
<h4 id="h:448eb2bd-1a0c-44c5-a217-5328daeaa6bb">缓存数据存储（Hash 表）</h4>
<div class="outline-text-4" id="text-h:448eb2bd-1a0c-44c5-a217-5328daeaa6bb">
<p>
缓存是存储在内存中的，那么如何从内存中快速获取一个数据呢？
</p>

<p>
缓存使用的数据结构主要是哈希（Hash）表。我们看一下哈希表实现的机制。哈希表最终的存储形式通常是一个顺序表，也就是一个数组结构。数组结构的特点是在内存中连续存储分配。那么，当我们要在哈希表中存储一个数据的时候，哈希表通常是以key、value 这样的数据结构进行存储的。当我们把一个 key、value 数据结构存储在一个哈希表中的时候，主要的存储过程大致如下图所示。       
</p>


<figure id="orgc2d4733">
<img src="./images/CgoB5l13VbiAHhPSAABoymphrNs072.png" alt="CgoB5l13VbiAHhPSAABoymphrNs072.png" width="80%">

</figure>

<p>
首先，我们拿到 key、value 数据结构，在上图的例子中，key 是字符串 abc，value 是字符串 hello，我们先计算 key 的哈希值，比如字符串 abc 的 hashcode 算出来是 101 这样一个整型值。往下，计算哈希值 101 对应的 hash 表索引就要对 8 取模。此处 8 指什么？哈希表真正的物理存储是一个数组，我们建的哈希表长度是 8，如上图所示。101 对 8 取模余 5，这个 5 就是数组下标的索引值，我们就可以把 abc hello 这样一个 key、value 值存储在下标为 5 的数组记录中。这一步是最关键的，通常我们所谓的 <code>哈希算法</code> 也就是指这一步， <code>即如何把一个哈希值转换成在数组中对应的位置</code> 。这个例子我们使用的是余数哈希，实践中最常用的也是余数哈希。
</p>

<p>
将来，当我们要进行数据读取的时候，只要给定 key abc，还是用这样一个算法过程，先求取它的 hash code 101，然后再对 8 取模。因为数组的长度不变，对 8 取模以后依然是余 5，那么我们到数字下标中去找 5 的这个位置，就可以找到前面存储进去的 abc 对应的 value 值。
</p>

<p>
通过哈希表可以使整个数据存储或检索效率 <code>时间复杂都是 O(1)</code> 。所以即使存储非常大的几百万上千万的数据量，通过哈希表也可以非常快地进行数据的查找和读写。通过这种手段缓存可以获得较快的读写访问特性，比数据库中的读写速度要快得多。
</p>
</div>
</div>
</div>
<div id="outline-container-h:725639a6-c481-41d0-8646-1c1350f4774c" class="outline-3">
<h3 id="h:725639a6-c481-41d0-8646-1c1350f4774c">缓存的关键指标&#x2013;命中率</h3>
<div class="outline-text-3" id="text-h:725639a6-c481-41d0-8646-1c1350f4774c">
<ul class="org-ul">
<li>缓存是否有效依赖于能多少次重用同一个缓存响应业务请求， <code>这个度量指标</code> 被称作 <code>缓存命中率</code></li>
<li>若查询一个缓存，十次查询九次能够得到正确的结果，那么它的 <code>命中率是 90%</code></li>
<li>影响缓存 <code>命中率的 3 个重要因素</code> ：缓存键集合大小、内存空间和缓存寿命</li>
</ul>

<p>
影响缓存特性的一个关键指标是缓存的命中率。缓存的主要特点是一次写入多次读出，通过这种手段减少对数据库的使用，尽快从缓存中读取数据，提高性能。所以 <code>缓存是否有效，主要就是看它一次写进去的缓存能不能够多次去读出来响应业务的请求，这个判断指标就叫作缓存的命中率</code> 。
</p>

<p>
缓存命中率怎么算呢？查询得到正确缓存结果除以总的查询次数，得到的比值就是缓存命中率，比如说 <code>十次查询九次都能够得到缓存的正确结果，命中率就是 90%</code> 。
</p>


<p>
影响 <code>缓存命中率的主要因素有三个</code> ，分别是：
</p>

<ul class="org-ul">
<li>缓存键集合大小</li>

<li>内存空间大小</li>

<li>缓存的寿命</li>
</ul>
</div>
<div id="outline-container-h:3c9d3336-64a5-40b1-8c5f-15dfaebd4de3" class="outline-4">
<h4 id="h:3c9d3336-64a5-40b1-8c5f-15dfaebd4de3">缓存键集合大小</h4>
<div class="outline-text-4" id="text-h:3c9d3336-64a5-40b1-8c5f-15dfaebd4de3">
<p>
缓存中的每个对象都是通过缓存键进行识别的。刚才 abc hello 这个例子里 abc 就是一个缓存的键，键是缓存中唯一的识别符，定位一个对象的唯一方式就是对缓存键进行精确的匹配。
</p>

<p>
比如说我们想缓存每个商品的在线商品信息，就需要使用商品 ID 作为缓存键。换句话说，缓存键空间是你的应用能够生成的所有键的数量。从统计数字上看，应用生成的唯一键越多，重用的机会越小。比如说根据 IP 地址缓存天气数据，可能需要 40 多亿个键。但是如果基于国家缓存天气数据，那么只需要几百个缓存键就够了，全世界也不过就几百个国家。
</p>

<p>
所以要尽可能减少缓存键的数量，键的数量越少，缓存的效率越高。设计缓存的时候要关注缓存键是如何进行设计的，它的整个的集合范围，限定在一个既能够高效使用，又可以减少它的数量，这个时候缓存的性能是最好的。
</p>
</div>
</div>
<div id="outline-container-h:d3235a1d-b211-40cf-a972-f5de4fcecfce" class="outline-4">
<h4 id="h:d3235a1d-b211-40cf-a972-f5de4fcecfce">缓存内存空间大小</h4>
<div class="outline-text-4" id="text-h:d3235a1d-b211-40cf-a972-f5de4fcecfce">
<p>
缓存可以使用的内存空间决定了缓存对象平均大小和缓存对象的数量。因为缓存通常是存储在内存中的，缓存对象可用的内存空间相对来说比较昂贵，而且受到严格限制。
</p>

<p>
如果想缓存更多的对象，就需要先删除老的对象，再添加新的对象。而这些老的对象被删除掉，就会影响到缓存的命中率。所以物理上缓存的空间越大，缓存的对象越多，缓存的命中率也就越高。
</p>
</div>
</div>
<div id="outline-container-h:a2083bb7-4ef7-42ea-8eda-28981fd78c70" class="outline-4">
<h4 id="h:a2083bb7-4ef7-42ea-8eda-28981fd78c70">缓存对象生存时间（缓存寿命）</h4>
<div class="outline-text-4" id="text-h:a2083bb7-4ef7-42ea-8eda-28981fd78c70">
<p>
缓存对象的生存时间称为 TTL。对象缓存的时间越长，被重用的可能性就越高。使缓存失效的方法有两种：
</p>
<ul class="org-ul">
<li>一种是超时失效</li>
<li>一种是清除失效，也就是实时清除。</li>
</ul>


<figure id="org9e11482">
<img src="./images/CgotOV13Eh6AeZaQAABY4_ZmeQk831.png" alt="CgotOV13Eh6AeZaQAABY4_ZmeQk831.png">

</figure>

<p>
所谓的超时失效是在构建缓存，即写缓存的时候，每个缓存对象都设置一个超时时间，在超时之前访问缓存就会返回缓存的数据，而一旦超时，缓存就失效了，这时候再访问缓存，就会返回空。
</p>

<p>
而实时清除是说，当有缓存对象更新的时候，直接通知缓存将已经被更新了的数据进行清除。清除了以后，应用程序下一次访问这个缓存对象键的时候，就不得不到数据库中去查找读取，这个时候就会得到最新的数据，因为更新总是更新在数据库里的。
</p>

<p>
还有一种，虽然时间上还没有失效但是新的对象要写入缓存，而内存空间不够了，这个时候就需要将一些老的缓存对象清理掉，为新的缓存对象腾出空间。
</p>

<p>
内存空间清除主要使用的算法是 LRU 算法，LRU 算法就是最近最久未用算法，也就是说清除那些最近最久没有被访问过的对象。这个算法使用链表结构实现的，所有的缓存对象都放在同一个链表上。当一个对象被访问的时候，就把这个对象移到整个链表的头部。当需要通过 LRU 算法清除那些最近最久未用对象的时候，只需要从队列的尾部进行查找，越是在队列尾部的，越是最近最久没有被访问过的，也就是优先清除的，腾出的内存空间让新对象加入进来。
</p>
</div>
</div>
</div>
<div id="outline-container-h:a70d1b91-a735-4bd7-861d-faa11885f447" class="outline-3">
<h3 id="h:a70d1b91-a735-4bd7-861d-faa11885f447">缓存的主要类型</h3>
<div class="outline-text-3" id="text-h:a70d1b91-a735-4bd7-861d-faa11885f447">
</div>
<div id="outline-container-h:52aef660-4b00-4079-9d3a-a2a58a7e22ab" class="outline-4">
<h4 id="h:52aef660-4b00-4079-9d3a-a2a58a7e22ab">代理缓存</h4>
<div class="outline-text-4" id="text-h:52aef660-4b00-4079-9d3a-a2a58a7e22ab">
<p>
代理缓存是在应用程序端的代理，缓存在客户端端的，代理客户端访问互联网。它的主要作用是互联网访问代理。但是同时因为他代理了所有的客户端 HTTP 请求，所以它可以进行页面缓存，如果有一些其他的客户端已经访问过这个网页，那么当新的客户端连接的时候，就可以通过代理缓存中的数据直接返回，避免对数据中心的访问。
</p>


<figure id="org854968a">
<img src="./images/CgotOV13VcWAYl8OAAC1Z4DMJ1E846.png" alt="CgotOV13VcWAYl8OAAC1Z4DMJ1E846.png">

</figure>

<p>
代理缓存是存在客户端一端的缓存，我们无法进行管理。所以代理缓存虽然存在，但是通常不作为我们系统架构中的一部分，我们能够管理的是反向代理缓存。
</p>
</div>
</div>
<div id="outline-container-h:d7d9dd95-4978-4e3e-a084-e58a0db64029" class="outline-4">
<h4 id="h:d7d9dd95-4978-4e3e-a084-e58a0db64029">反向代理缓存</h4>
<div class="outline-text-4" id="text-h:d7d9dd95-4978-4e3e-a084-e58a0db64029">

<figure id="org5340ffb">
<img src="./images/CgoB5l13VcuAQoUeAACKaiIOlJc476.png" alt="CgoB5l13VcuAQoUeAACKaiIOlJc476.png">

</figure>

<p>
代理缓存是代理用户上网的，而反向代理则是代理数据中心输出的，是反向代理的。所以反向代理缓存是存在于系统数据中心里的，它是数据中心的统一入口，代理整个数据中心其他服务器的应用处理。
</p>

<p>
用户通过互联网连接到数据中心的时候，连接的通常是一个反向代理服务器，反向代理服务器根据用户的请求，在本地的反向代理缓存中查找是否有用户请求的数据，如果有就直接返回这个数据，如果没有再把这个请求向下继续转发，请求后面的应用服务器去处理生成数据。
</p>

<p>
反向代理缓存可以多层反向代理缓存的形式出现。因为我们的应用服务器也是经过分层的，在处理的前端通常是一个前端服务器，后面有 Web 服务器，之后有应用服务器，再后还有其他的各类服务器。在这样一个分层的服务器结构里，我们可以对每一层的服务器都进行反向代理缓存。
</p>

<p>
如下图所示，前端 Web 服务器和 Web 服务器分为两层，用户请求接入的时候，先接入前端 Web 服务器，其上可以加一层反向代理服务器来代理前端 Web 服务器的 HTTP 请求。如果用户请求的数据已经包含在这个反向代理服务器中，就可以直接返回；如果没有，就再把 HTTP 请求提交给前端 Web 服务器，前端 Web 服务器会把请求发给后面的 Web 服务器。在 Web 服务器和前端 Web 服务器之间还可以再加一层反向代理服务器。如果前端 Web 服务器的请求在这一层的反向代理服务器中存在，那么这一层反向代理服务器可以直接将数据返还；如果不存在，再将请求下发给 Web 服务器。
</p>


<figure id="orga878f0d">
<img src="./images/CgotOV13VnaAfPm9AAC46bZcN0w341.png" alt="CgotOV13VnaAfPm9AAC46bZcN0w341.png">

</figure>

<p>
通过这样的方式，极大地减少了前端 Web 服务器或者是 Web 服务器的访问压力，同时提高了系统的响应性能。
</p>
</div>
</div>
<div id="outline-container-h:e974937a-d22a-4f05-b319-916b8b1df43f" class="outline-4">
<h4 id="h:e974937a-d22a-4f05-b319-916b8b1df43f">内容分发网络 CDN 缓存</h4>
<div class="outline-text-4" id="text-h:e974937a-d22a-4f05-b319-916b8b1df43f">
<p>
所谓的 CDN 是指在用户请求的前端（尽量前的前端）为用户提供数据服务。CDN并不存在于我们的数据中心，也不存在于用户的访问系统一端，它介于两者之间，作为 <code>网络服务商的缓存服务</code> 。用户进行互联网访问的时候，需要通过互联网网络服务商提供的网络链接才能够连接到数据中心，那么网络服务商就可以在自己提供的网络服务的机房里进行一次缓存操作，提供一次缓存服务。如下图所示。
</p>


<figure id="orgd110509">
<img src="./images/CgoB5l13Eh6AXvePAAGOZ4Q8scY773.png" alt="CgoB5l13Eh6AXvePAAGOZ4Q8scY773.png">

</figure>

<p>
客户端第一次访问 example.com 的时候，访问数据中心，数据中心返回 HTML 页面以后，客户端解析 HTML，HTML 里面还各种 js 文件、css 文件、图片等，这些静态资源访问的就是 CDN 服务器。CDN 服务器检查自己是否有需要的静态资源，如果有，就立即返回给客户端；如果没有，就自己访问数据中心，获得需要的静态资源后，缓存在 CDN 服务器上后，再返回客户端。
</p>

<p>
所以 CDN 缓存也叫作网络访问的“第一跳”，用户请求先到达的是互联网网络服务商的机房。在机房里面部署 CDN 服务器，提供缓存服务。如果 CDN 中存在用户请求的 Web 响应内容，那么就可以直接通过 CDN 进行返回；如果 CDN 中不存在，那么 CDN 会把这个请求通过后面的网络连接，把它发到系统的数据中心去。数据中心返回的结果依然是先通过 CDN 服务器，CDN 服务器就可以把数据缓存在自己的本地，供后面的用户请求操作响应。
</p>
</div>
</div>
<div id="outline-container-h:e726a75b-300e-447c-8a01-3a0547437647" class="outline-4">
<h4 id="h:e726a75b-300e-447c-8a01-3a0547437647">通读缓存(read-through)</h4>
<div class="outline-text-4" id="text-h:e726a75b-300e-447c-8a01-3a0547437647">
<ul class="org-ul">
<li>代理缓存、反向代理缓存、CDN 缓存，都是 <code>通读缓存</code></li>
<li>若通读缓存给客户端 <code>返回缓存资源</code> ，或在请求未命中缓存时 <code>获取实际数据</code></li>
<li><code>客户端连接的是通读缓存</code> 而不是生成响应的原始服务器</li>
</ul>

<p>
上面讲到的 <code>代理缓存、反向代理缓存、CDN 缓存，都是通读缓存</code> 。它代理了用户的请求，也就是说用户在访问数据的时候，总是要通过通读缓存。
</p>

<p>
当通读缓存中有需要访问的数据的时候，直接就把这个数据返回；如果没有，再由通读缓存向真正的数据提供者发出请求。其中重要的一点是客户端连接的是通读缓存，而不是生成响应的原始服务器 ，客户端并不知道真正的原始服务器在哪里，不会直接连接原始服务器，而是由通读缓存进行代理。
</p>
</div>
</div>
<div id="outline-container-h:e03adc2f-9b73-420a-ba37-ca78feaae6cc" class="outline-4">
<h4 id="h:e03adc2f-9b73-420a-ba37-ca78feaae6cc">旁路缓存(cache-aside)</h4>
<div class="outline-text-4" id="text-h:e03adc2f-9b73-420a-ba37-ca78feaae6cc">
<p>
和通读缓存相对应的叫作旁路缓存。前面提到的 key、value
这样的对象缓存就属于旁路缓存。旁路缓存和通读缓存不同。旁路缓存是客户端先访问旁路缓存中是否有自己想要的数据，如果旁路缓存中没有需要的数据，那么由客户端自己去访问真正的数据服务提供者，获取数据。客户端获得数据以后，会自己把这个数据写入到旁路缓存中，这样下一次或者其他客户端去读取旁路缓存的时候就可以获得想要的数据了。
</p>


<figure id="org7cee5b9">
<img src="./images/CgotOV13ExOAP6m3AAB1BADrv1M771.png" alt="CgotOV13ExOAP6m3AAB1BADrv1M771.png">

</figure>

<p>
在这里插入讲解一下各种介质数据访问的延迟，以便对数据的存储、缓存的特性以及数据的访问延迟有一个感性的认识。 
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">操作类型</td>
<td class="org-left">粗略时间</td>
</tr>

<tr>
<td class="org-left">访问本地内存</td>
<td class="org-left">100ns</td>
</tr>

<tr>
<td class="org-left">SSD磁盘搜索</td>
<td class="org-left">100.000ns</td>
</tr>

<tr>
<td class="org-left">网络数据包在同一数据中心来回一次的时间</td>
<td class="org-left">500.000ns</td>
</tr>

<tr>
<td class="org-left">磁盘搜索(非-SSD)</td>
<td class="org-left">10.000.000ns</td>
</tr>

<tr>
<td class="org-left">按顺序从网络读取1MB数据</td>
<td class="org-left">10.000.000ns</td>
</tr>

<tr>
<td class="org-left">按顺序从磁盘(非-SSD)读取1MB数据</td>
<td class="org-left">30.000.000ns</td>
</tr>

<tr>
<td class="org-left">跨大西洋网络数据包一次来回延时</td>
<td class="org-left">150.000.000ns</td>
</tr>

<tr>
<td class="org-left">每秒等于多少</td>
<td class="org-left">1,000,000,000ns</td>
</tr>
</tbody>
</table>


<p>
如上所示，访问本地内存大概需要 100ns 的时间；使用 SSD 磁盘进行搜索，大概需要 10万ns 时间；数据包在同一个数据中心来回一次的时间，也就是在同一个路由环境里进行一次访问，大概需要 50万ns 时间，也就是 0.5ms；使用非 SSD 磁盘进行一次搜索，大概需要 1000万ns，也就是 10ms 的时间；按顺序从网络中读取 1MB 的数据也是需要 10ms 的时间；按顺序从传统的机械磁盘，即非 SSD 磁盘，读取 1MB 数据，大概需要 30ms 的时间；跨越大西洋进行一次网络数据传输，一个来回大概需要 150ms 的时间。其中，1s 等于 1000ms，等于 10亿ns。
</p>
</div>
</div>
</div>
<div id="outline-container-h:e3a764d4-423f-4b9c-9344-ca94a79d9cdc" class="outline-3">
<h3 id="h:e3a764d4-423f-4b9c-9344-ca94a79d9cdc">合理使用缓存对象</h3>
<div class="outline-text-3" id="text-h:e3a764d4-423f-4b9c-9344-ca94a79d9cdc">
<p>
缓存虽然效率非常高，使用缓存也非常简单，但是缓存并不是无所不能的，使用缓存的时候需要注意合理使用缓存对象。
</p>

<ol class="org-ol">
<li>频繁修改的数据</li>
<li>没有热点的访问</li>
<li>数据不一致与脏读</li>
<li>缓存雪崩</li>
</ol>
</div>
<div id="outline-container-h:7d859ddb-f7ce-4dc2-900d-f02eeaabb6e1" class="outline-4">
<h4 id="h:7d859ddb-f7ce-4dc2-900d-f02eeaabb6e1">注意频繁修改的数据</h4>
<div class="outline-text-4" id="text-h:7d859ddb-f7ce-4dc2-900d-f02eeaabb6e1">
<p>
缓存数据是为一次写入多次读取准备的，但是如果写入的数据很快就被修改掉了，数据还没来得及读取就已经失效或者更新了，系统的负担就会很重，使用缓存也就没有太多的意义。一般说来， <code>数据的读写比例</code> 至少在 <code>2:1</code> 以上，缓存才有意义。
</p>
</div>
</div>
<div id="outline-container-h:699e4814-f461-439b-96d9-0513d2de075e" class="outline-4">
<h4 id="h:699e4814-f461-439b-96d9-0513d2de075e">注意没有热点的访问数据</h4>
<div class="outline-text-4" id="text-h:699e4814-f461-439b-96d9-0513d2de075e">
<p>
上面提到缓存是一次写入多次读取的数据，但是如果写入的数据并 <code>不会被多次读取</code> ，也就是所谓的 <code>没有热点</code> ，这时候使用缓存也是没有意义的。
</p>

<p>
我们常见的、日常使用的数据通常都是有热点的。比如说在淘宝中，那些热门的商品可能会被几百万几千万次的访问，那些冷门的商品可能一次访问都没有，热门商品数据就是有热点的，就需要缓存。在微博中也是，那些微博大V们的微博会被几百万几千万的粉丝访问，他们的微博数据也是有热点的，而那些没有几个粉丝的博主的微博，几乎不会被访问，这些数据是没有热点的。所以缓存存储的就是淘宝上那些热门的商品，微博上那些大V的微博，它们都是有热点的缓存，这些数据都能实现一次写入多次甚至非常多次的读取，这种缓存就有效果。但还是有一些业务场景数据是没有热点的，那么这一类业务场景数据就不需要使用缓存。
</p>
</div>
</div>
<div id="outline-container-h:87b39706-2d89-4774-9d1b-f0ca4f430cf6" class="outline-4">
<h4 id="h:87b39706-2d89-4774-9d1b-f0ca4f430cf6">注意数据不一致和脏读</h4>
<div class="outline-text-4" id="text-h:87b39706-2d89-4774-9d1b-f0ca4f430cf6">
<p>
缓存中的数据有可能和主存储数据库中的数据不一致。这个问题主要是通过 <code>失效时间</code> 来解决的，也就是说这个业务能够容忍的失效时间之内，保持缓存中的数据和数据库中的数据不一致，比如说淘宝的商品数据，如果卖家在对商品的数据进行了编辑，这个时候可能买家是看不到这些被更新过的数据的，可能需要几分钟的时间，比如是 3 分钟，那么 3 分钟之内，卖家编辑的数据买家是看不到的，但这种延迟通常是可以接受的。
</p>

<p>
如果某些业务场景对更新非常敏感，必须要实时看到，这个时候就不能够使用失效时间进行缓存过期处理了，可能需要进行失效通知。当数据进行更新的时候，立即清除缓存中的数据，下次访问这个数据的时候，缓存必须要重新从主数据库中去加载，才能够得到最新的数据。
</p>
</div>
</div>
<div id="outline-container-h:6ff2ae59-b9fc-4c1a-96f0-52201f53250a" class="outline-4">
<h4 id="h:6ff2ae59-b9fc-4c1a-96f0-52201f53250a">注意缓存雪崩</h4>
<div class="outline-text-4" id="text-h:6ff2ae59-b9fc-4c1a-96f0-52201f53250a">
<p>
因为热点数据主要是从缓存中去读取的，而热点数据是数据访问压力最大的一类数据。这些数据都从缓存中读取，极大地降低了数据库的访问压力。
</p>

<p>
而数据库整个系统也是在有缓存的情况下进行设计的，数据库的处理能力是强依赖缓存的。如果缓存忽然崩溃了，那么所有的访问压力就都会传递到数据库上去。数据库不能够承受这样的访问压力，可能也会崩溃。数据库崩溃了以后，应用程序访问不到数据库，请求不断超时，负载压力不断升高，应用程序服务器也会崩溃，最后导致整个网站所有服务器崩溃。这就是缓存雪崩。这种情况下系统甚至无法启动，因为系统启动后，新的访问压力又过来，依然是那么大，还是会崩溃。
</p>

<p>
这时候重启缓存也是没有用的，因为重启的话缓存中是没有数据的。我们刚才也讲到，对象缓存是通过加载数据库中的数据并写入到缓存中才有数据的。重新启动的缓存没有数据，它就不能够承担提供数据读操作的能力。所以，对缓存有重点依赖的系统，需要特别关注缓存的可用性。缓存用的部分数据丢失可以到数据库中加载，但是如果全部的缓存数据都丢失了，可能导致整个系统都会崩溃，特别需要注意。
</p>
</div>
</div>
</div>
<div id="outline-container-h:fda1f7d2-6df3-4567-80aa-943b517b1fd0" class="outline-3">
<h3 id="h:fda1f7d2-6df3-4567-80aa-943b517b1fd0">分布式对象缓存</h3>
<div class="outline-text-3" id="text-h:fda1f7d2-6df3-4567-80aa-943b517b1fd0">
<p>
下面看一下分布式对象缓存，如下图所示。
</p>


<figure id="org4bbfe6c">
<img src="./images/CgotOV13ExSAWhCFAACFNPzM4Q8959.png" alt="CgotOV13ExSAWhCFAACFNPzM4Q8959.png">

</figure>

<p>
分布式对象缓存是系统架构中比较重要的一部分内容。所谓的分布式对象缓存是指 <code>对象缓存以一个分布式集群的方式对外提供服务，多个应用系统使用同一个分布式对象缓存提供的缓存服务</code> 。这里的缓存服务器是由多台服务器组成的，这些服务器共同构成了一个集群对外提供服务。所以使用分布式对象缓存的一个重要问题就是，数据进行读写操作的时候，如何找到正确的缓存服务器进行读写操作。如果第一次写入数据的时候写入的是 A 服务器，但是数据进行缓存读操作的时候访问的是 B 服务器，就不能够正确地查找到数据，缓存也就没有了效果。
</p>

<p>
那么，如何才能找到正确的缓存服务器呢？以 Memcached
服务器集群为例，我们来看一下分布式对象的缓存模型，如下图。
</p>


<figure id="org587f355">
<img src="./images/CgoB5l13V3yAaDSfAACw9us7nBY044.png" alt="CgoB5l13V3yAaDSfAACw9us7nBY044.png">

</figure>

<p>
当需要进行分布式缓存访问的时候，依然是以 Key、value 这样的数据结构进行访问。如上图所示的例子中就是 BEIJING 作为 Key，一个 DATA 数据作为它的 value。当需要进行分布式对象访问的时候，应用程序需要使用分布式对象缓存的客户端 SDK。比如说 Memcached 提供的一个客户端 API 程序进行访问，客户端 API 程序会使用自己的路由算法进行路由选择，选择其中的某一台服务器，找到这台服务器的 IP 地址和端口以后，通过通讯模块和相对应的服务器进行通信。
</p>

<p>
因为进行路由选择的时候，就是使用缓存对象的 key 进行计算。下一次使用相同的 key 使用相同路由算法进行计算的时候，算出来的服务器依然还是前面计算出来的这个服务器。所以通过这种方法可以访问到正确的服务器进行数据读写。服务器越多，提供的缓存空间就越大，实现的缓存效果也就越好。通过集群的方式，提供了更多的缓存空间。
</p>

<p>
那么，路由算法又是如何进行服务器路由选择的？主要算法依然是上面讲到的哈希表的路由算法，也就是取模算法。
</p>

<p>
比如说，我们这里缓存服务器集群中有 3 台服务器，key 的哈希值对 3 取模得到的余数一定在 0、1、2 三个数据之间，那么每一个数字都对应着一台服务器，根据这个数字查找对应的服务器 IP 地址就可以了。使用余数取模这种方式进行路由计算非常简单，但这种算法也有一个问题，就是当服务器进行扩容的时候，比如说我们当前的服务器集群有 3 台服务器，如果我们 3 台服务器不够用了，需要添加 1 台服务器，这个时候对 3 取模就会变成对 4 去取模，导致的后果就是以前对 3 取模的时候写入的数据，对 4 取模的时候可能就查找不到了。
</p>

<p>
上面也讲过缓存雪崩的情况，实际上如果使用取模算法进行服务器添加，因为除数的变化会导致和缓存雪崩一样的后果，也就是说前面写入缓存服务器集群中的缓存数据，添加了 1 台服务器后很多数据都找不到了，类似于雪崩，最后会导致整个服务器集群都崩溃。
</p>

<p>
我们添加服务器的主要目的是提高它的处理能力，但是不正确的操作可能会导致整个集群都失效。解决这个问题的主要手段是使用一致性哈希算法。
</p>
</div>
<div id="outline-container-h:6b952811-3e2e-48c6-92e3-e370007ebcc7" class="outline-4">
<h4 id="h:6b952811-3e2e-48c6-92e3-e370007ebcc7">一致性哈希算法</h4>
<div class="outline-text-4" id="text-h:6b952811-3e2e-48c6-92e3-e370007ebcc7">
<p>
一致性哈希和余数哈希不同，一致性哈希首先是构建一个一致性哈希环的结构。一致性哈希环的大小是 0～2 的 32 次方减 1，实际上就是我们计算机中 <code>无符号整型值的取值范围</code> ，这个取值范围的 0 和最后一个值 2 的 32 次方减 1 首尾相连，就构成了一个一致性哈希环，如下图所示。
</p>


<figure id="org72ad748">
<img src="./images/CgotOV13ExWAGFH2AACSu5nTgAw967.png" alt="CgotOV13ExWAGFH2AACSu5nTgAw967.png">

</figure>

<p>
对每个服务器的节点取模，求它的哈希值并把这个哈希值放到环上，所有的服务器都取哈希值放到环上，每一次进行服务器查找路由计算的时候，把 key 也取它的哈希值，取到哈希值以后把 key 放到环上，顺时针查找距离它最近的服务器的节点是哪一个，它的路由节点就是哪一个。通过这种方式也可以实现，key 不变的情况下找到的总是相同的服务器。这种一致性哈希算法除了可以实现像余数哈希一样的路由效果以外，对服务器的集群扩容效果也非常好。
</p>

<p>
在一致性哈希环上进行服务器扩容的时候，新增加一个节点不需要改动前面取模算法里的除数，导致最后的取值结果全部混乱，它只需要在哈希环里根据新的服务器节点的名称计算它的哈希值，把哈希值放到这个环上就可以了。放到环上后，它不会影响到原先节点的哈希值，也不会影响到原先服务器在哈希环上的分布，它只 <code>会影响到离它最近的服务器</code> ，比如上图中 NODE3 是新加入的服务器，那么它只会影响到 NODE1，原先访问 NODE1 的 key 会访问到 NODE3 上，也就是说对缓存的影响是比较小的，它只会影响到缓存里面的一小段。如果缓存中一小部分数据受到了影响，不能够正确的命中，那么可以去数据库中读取，而数据库的压力只要在它的负载能力之内，也不会崩溃，系统就可以正常运行。所以通过一致性哈希算法可以实现缓存服务器的顺利伸缩扩容。
</p>

<p>
但是一致性哈希算法有着致命的缺陷。我们知道哈希值其实是一个随机值，把一个随机值放到一个环上以后，可能是 <code>不均衡</code> 的，也就是说某两个服务器可能距离很近，而和其它的服务器距离很远，这个时候就会导致有些服务器的负载压力特别大，有些服务器的负载压力非常小。同时在进行扩容的时候，比如说加入一个节点 3，它影响的只是节点 1，而我们实际上希望加入一个服务器节点的时候，它能够分摊其它所有服务器的访问压力和数据冲突。
</p>

<p>
所以对这个算法需要进行一些 <code>改进</code> ，改进办法就是 <code>使用虚拟节点</code> 。也就是说我们这一个服务器节点放入到一致性哈希环上的时候，并不是把真实的服务器的哈希值放到环上，而是将一个服务器虚拟成若干个虚拟节点，把这些虚拟节点的 hash 值放到环上去。在实践中通常是把一个服务器节点虚拟成 200 个虚拟节点，然后把 200 个虚拟节点放到环上。key 依然是顺时针的查找距离它最近的虚拟节点，找到虚拟节点以后，根据映射关系找到真正的物理节点。
</p>

<p>
第一，可以解决我们刚才提到的负载不均衡的问题，因为有更多的虚拟节点在环上，所以它们之间的距离总体来说大致是相近的。第二，在加入一个新节点的时候，是加入多个虚拟节点的，比如 200 个虚拟节点，那么加入进来以后环上的每个节点都可能会受到影响，从而分摊原先每个服务器的一部分负载。
</p>
</div>
</div>
</div>
<div id="outline-container-h:a6926cf9-c52a-4ecf-a3fe-73d494d5d8e0" class="outline-3">
<h3 id="h:a6926cf9-c52a-4ecf-a3fe-73d494d5d8e0">总结回顾</h3>
<div class="outline-text-3" id="text-h:a6926cf9-c52a-4ecf-a3fe-73d494d5d8e0">
<pre class="example" id="orgdab16cf">
缓存的优点--&gt;影响缓存的关键指标--&gt;缓存的主要类型--&gt;合理使用缓存的关注点
--&gt;分布式对象缓存--&gt;缓存无处不在
</pre>

<p>
最后，我们总结回顾一下整个关于缓存部分的内容。
</p>

<p>
缓存的主要优点是:
</p>
<ul class="org-ul">
<li>实现方法比较简单</li>
<li>同时提升的效果又非常明显</li>
</ul>

<p>
所以缓存是架构性能优化的一个重要手段。
</p>

<p>
影响缓存的主要指标是缓存命中率。影响命中率的几个关键因素是:
</p>
<ul class="org-ul">
<li>缓存键集合的大小</li>
<li>缓存空间的大小</li>
<li>缓存对象的存在时间，也就是缓存的寿命</li>
</ul>

<p>
缓存的主要类型有:
</p>
<ul class="org-ul">
<li>代理缓存</li>
<li>反向代理缓存</li>
<li>CDN缓存</li>
</ul>

<p>
这三类缓存叫作通读缓存。
</p>

<p>
客户端使用通读缓存的时候，不需要知道后面真实的数据存储服务器在哪里，只需要访问通读缓存，由通读缓存去访问真正的数据提供服务器。另一类缓存就是旁路缓存。这类缓存就是我们在系统架构中常用的对象缓存。使用旁路缓存的时候，应用程序一方面需要知道缓存，需要连接缓存服务器，通过缓存服务器去查找数据，如果缓存服务器中没有查到数据，那么就自己去连接数据库，从数据库中去查找数据，并且在返回数据以后，还要把这个数据当作缓存写入到缓存服务器中去，以便于下一次读取的时候从缓存中读取。
</p>


<p>
缓存虽然对系统性能提升非常明显，但是也还是需要对缓存进行合理的使用，在合适的场景下进行使用。
</p>
<ul class="org-ul">
<li>第一点是关注频繁修改的数据，如果一个数据经常被修改，那么使用缓存可能就价值不大；</li>
<li>第二点是缓存要有热点，因为缓存的空间总是有限的，只能存储一小部分的数据，如果被访问的数据概率都是一样的，没有热点，数据极有可能写入缓存以后很快又被清除掉了，没有被读取过，体现不出来缓存的价值；</li>
<li>还有两点分别是注意缓存雪崩和关注缓存的数据一致性。</li>
</ul>


<p>
分布式对象缓存是我们分布式架构中用的比较多的一种缓存。使用分布式缓存要注意的是：缓存的路由算法是如何实现的？比较重要的、用的比较广泛的是一致性哈希算法。
</p>

<p>
总之，缓存是无处不在的。在整个计算机系统中，在各个地方，只要你能够想得到的，都可以使用缓存来提升性能，甚至应用程序、一段代码中都可以使用缓存。所以我们要多关注缓存的使用，同时也要关注使用缓存的那些注意点。
</p>

<p>
缓存是系统性能优化的最重要的手段之一，关于性能优化更多的架构原理和技术方法，请关注章节6。
</p>
</div>
</div>
</section>
<section id="outline-container-h:e50841de-b583-479d-ac76-a8bd3a13d856" class="outline-2">
<h2 id="h:e50841de-b583-479d-ac76-a8bd3a13d856">第03讲：架构核心技术之分布式消息队列</h2>
<div class="outline-text-2" id="text-h:e50841de-b583-479d-ac76-a8bd3a13d856">
<form><input type="button" value="音频" onclick="doSound(3); return false;"></form>
<span id="dummy3"></span>

<blockquote>
<ol class="org-ol">
<li>同步调用与异步调用</li>
<li>消息队列构建异步调用架构</li>
<li>消息队列的好处与挑战</li>
</ol>
</blockquote>

<p>
本章节的主题是分布式消息队列，分布式消息队列的知识结构如下图。
</p>


<figure id="org1a0a5d9">
<img src="./images/CgoB5l13GW-AIfDbAAERpWtyIbk305.png" alt="CgoB5l13GW-AIfDbAAERpWtyIbk305.png">

</figure>

<p>
本章节主要介绍以下内容。
</p>

<ul class="org-ul">
<li>同步架构和异步架构的区别。</li>

<li>异步架构的

<ul class="org-ul">
<li>主要组成部分：消息生产者、消息消费者、分布式消息队列。</li>

<li>异步架构的两种主要模型：点对点模型和发布订阅模型。</li>
</ul></li>

<li>分布式消息队列异步架构的好处：

<ul class="org-ul">
<li>异步处理实现快速响应；</li>

<li>消费者易于伸缩；</li>

<li>高并发访问压力的时削峰填谷，减轻访问高峰的系统负载压力；</li>

<li>隔离失败任务，消费者处理任务失败，不会影响主业务流程；</li>

<li>业务逻辑解耦，系统易于开发和维护。</li>
</ul></li>

<li>异步架构的挑战：消息无序，竞态条件，系统复杂度提高。</li>

<li>使用分布式消息队列异步架构的反模式：

<ul class="org-ul">
<li>消息队列阻塞式调用，</li>

<li>生产者消费者显式依赖，</li>

<li>缺乏坏消息处理机制。</li>
</ul></li>

<li>常用的消息队列产品：RabbitMQ，ActiveMQ，RocketMQ，Kafka 等。</li>
</ul>
</div>
<div id="outline-container-h:8b2abc90-36bf-40df-af31-43314e62ddf3" class="outline-3">
<h3 id="h:8b2abc90-36bf-40df-af31-43314e62ddf3">同步调用与异步调用</h3>
<div class="outline-text-3" id="text-h:8b2abc90-36bf-40df-af31-43314e62ddf3">
</div>
<div id="outline-container-h:483c998c-5447-49b7-8595-06f836486768" class="outline-4">
<h4 id="h:483c998c-5447-49b7-8595-06f836486768">同步调用</h4>
<div class="outline-text-4" id="text-h:483c998c-5447-49b7-8595-06f836486768">
<p>
先看一下什么是同步调用。所谓的同步调用，就是说 <code>从请求的发起一直到最终的处理完成期间，请求的调用方一直在同步阻塞，等待调用的处理完成</code> 。下图所示的例子中，客户端代码 ClientCode，需要执行发送邮件 sendEmail 这样一个操作，它会调用 EmailService 进行发送，而 EmailService 会调用 SmtpEmailAdapter 类来进行处理，这个类会调用远程的一个服务，通过 SMTP 和 TCP 协议发送请求。
</p>


<figure id="org87c85f8">
<img src="./images/CgotOV13V8SAacKCAACH4MjE17c508.png" alt="CgotOV13V8SAacKCAACH4MjE17c508.png">

</figure>


<p>
而远程服务器收到消息以后会对消息进行一系列的操作，然后将邮件发送出去，再进行返回。Adapter 收到返回后，再返回给 EmailService。EmailService 收到返回后再把返回结果返回给 ClientCode。
</p>

<p>
ClientCode 在 sendEmail
发出请求后，就一直都阻塞在这里，等待最终调用结果的返回，是成功还是失败。因为这个过程是阻塞等待的，所以这个过程是同步调用。
</p>
</div>
</div>
<div id="outline-container-h:5545f7a2-8d6c-4a3b-94a0-9c9125078bc6" class="outline-4">
<h4 id="h:5545f7a2-8d6c-4a3b-94a0-9c9125078bc6">异步调用</h4>
<div class="outline-text-4" id="text-h:5545f7a2-8d6c-4a3b-94a0-9c9125078bc6">
<p>
与同步调用相反的是异步调用。异步调用过程，如下图所示，用户 ClientCode 调用 EmailService 以后，EmailService 会把这个调用请求发送给消息队列，然后就立即返回了。ClientCode 收到返回以后继续向下处理， <code>不会继续阻塞等待</code>  ，实际上消息发送到 Queue 后，还没有被处理。可以看到后面的消息消费，其实要比 EmailService 返回可能还要晚一点，EmailService 返回以后消息才会被消费处理。
</p>


<figure id="orgd6727cd">
<img src="./images/CgotOV13V-uAEtBmAACbBdrSrPQ139.png" alt="CgotOV13V-uAEtBmAACbBdrSrPQ139.png">

</figure>

<p>
QueueConsumer 消息队列的消费者，从消息队列中取出这个消息，再把这个消息发送给 SmtpAdapter，也就是调用 SmtpAdapter，处理逻辑跟同步调用一样。SmtpAdapter 通过 SMTP 的通讯协议，把消息发送给远程的一个服务器，进行邮件发送，通过 RemoteServer 进行处理，处理完了收到返回，再把返回结果通知消息队列 Queue。
</p>

<p>
在这个过程中，客户端的调用，也就是应用程序的调用，和业务逻辑真正发送邮件的操作是不同步的。在进行邮件发送操作的处理过程中，客户端的代码已经返回了，它可以继续进行自己的后续操作，而不需要等待邮件的发送，这就叫做 <code>异步调用</code> 。
</p>
</div>
</div>
</div>
<div id="outline-container-h:8e8e2848-85fc-4669-8313-66978c293d40" class="outline-3">
<h3 id="h:8e8e2848-85fc-4669-8313-66978c293d40">消息队列构建异步调用架构</h3>
<div class="outline-text-3" id="text-h:8e8e2848-85fc-4669-8313-66978c293d40">
<p>
使用异步调用架构的主要手段，就是通过消息队列构建。架构图如下图所示。
</p>


<figure id="org1c53148">
<img src="./images/CgoB5l13S8-ABqmHAABLgEvpt4w514.png" alt="CgoB5l13S8-ABqmHAABLgEvpt4w514.png">

</figure>

<p>
消息的生产者将消息发送到消息队列以后，由消息的消费者从消息队列中获取消息，然后进行业务逻辑的处理，消息的生产者和消费者是异步处理的，彼此不会等待阻塞，所以叫做异步架构。
</p>


<p>
使用消息队列构建一个异步调用架构，你需要了解 3 个角色：
</p>
<ul class="org-ul">
<li>一是消息的生产者</li>
<li>二是消息队列</li>
<li>三是消息的消费者。</li>
</ul>
</div>
<div id="outline-container-h:dca7dcb3-2750-4c26-ac04-0e5f7fb7642f" class="outline-4">
<h4 id="h:dca7dcb3-2750-4c26-ac04-0e5f7fb7642f">消息生产者</h4>
<div class="outline-text-4" id="text-h:dca7dcb3-2750-4c26-ac04-0e5f7fb7642f">
<p>
<code>消息的生产者是客户端应用程序代码的一部分，用来初始化异步调用处理流程</code> 。在消息队列的处理中，生产者的职责非常少，它要做的就是创建一个合法的消息，并把这个消息发送到消息队列中，由应用开发者决定生产者的代码在哪里执行，什么时候发送消息。
</p>
</div>
</div>
<div id="outline-container-h:ed45db84-a30e-43a4-9bdb-312def9d5636" class="outline-4">
<h4 id="h:ed45db84-a30e-43a4-9bdb-312def9d5636">消息队列</h4>
<div class="outline-text-4" id="text-h:ed45db84-a30e-43a4-9bdb-312def9d5636">
<p>
消息队列异步架构的另一个重要组成部分就是消息队列， <code>消息队列是消息发送的目的地，也是发给消费者过程中的一个缓冲</code> 。消息队列实现的方法有好多种，可以用共享文件夹，也可以用关系数据库或者
NoSQL 系统，当然最主要的还是使用专门的分布式消息队列服务器。
</p>
</div>
</div>
<div id="outline-container-h:6e5a86fb-237a-4d45-acbb-cd92397351a1" class="outline-4">
<h4 id="h:6e5a86fb-237a-4d45-acbb-cd92397351a1">消息消费者</h4>
<div class="outline-text-4" id="text-h:6e5a86fb-237a-4d45-acbb-cd92397351a1">
<p>
业务架构的第三个重要角色就是消息的消费者。消息的消费者从消息队列中接收并处理消息，也是 <code>由应用开发者实现</code> 的，但是一个异步处理的组件。消息的消费者不需要知道生产者存在，它 <code>只依赖消息队列中的消息</code> 。消息的消费者通常部署在独立的服务器上，和消息的生产者完全隔离，并且可以通过添加硬件的方式进行伸缩。
</p>
</div>
</div>
<div id="outline-container-h:739b5fce-08da-45e6-9c8a-388ea8576c12" class="outline-4">
<h4 id="h:739b5fce-08da-45e6-9c8a-388ea8576c12">点对点模型</h4>
<div class="outline-text-4" id="text-h:739b5fce-08da-45e6-9c8a-388ea8576c12">
<p>
知道以上 3 种主要角色之后，使用消息队列构建异步的调用架构，还需要知道两种模型： <code>点对点模型</code> 和 <code>发布订阅模型</code> 。
</p>

<p>
首先来看点对点模型。消费者和生产者只需要知道消息队列的名字，生产者发送消息到消息队列中，而消息队列的另一端是多个消费者竞争消费消息，每个到达消息队列的消息只会被路由到一个消费者中去，所以消费者看到的是全部消息的一个子集。如下图所示，消息的生产者有多个，消息的消费者也有多个，多个生产者将消息发送到消息队列中，而有多个消费者去消息队列中对消息进行竞争性的消费。每条消息只会被一个消费者消费，每个消费者只会消费消息队列中的一部分消息。
</p>


<figure id="org7354f46">
<img src="./images/CgotOV13S4-AO45dAACCTzTIUMo123.png" alt="CgotOV13S4-AO45dAACCTzTIUMo123.png">

</figure>
</div>
</div>
<div id="outline-container-h:6d82b2db-8604-48a9-b540-c33917dca57f" class="outline-4">
<h4 id="h:6d82b2db-8604-48a9-b540-c33917dca57f">发布订阅模型</h4>
<div class="outline-text-4" id="text-h:6d82b2db-8604-48a9-b540-c33917dca57f">
<p>
再来看发布订阅模型。在发布订阅模型中，消息可能被发送到不止一个消费者，生产者发送消息到一个主题，而不是队列中。消息被发布到主题后，就会被克隆给每一个订阅它的消费者，每个消费者接收一份消息复制到自己的私有队列。消费者可以独立于其他消费者使用自己订阅的消息，消费者之间不会竞争消息。常用的分布式消息队列都支持发布订阅模型，也就是说消息的发布订阅模型是分布式消息队列的一个功能特性。
</p>


<figure id="orgd7fc338">
<img src="./images/CgotOV13S2GAXpxGAAB59bGh2YU946.png" alt="CgotOV13S2GAXpxGAAB59bGh2YU946.png">

</figure>
</div>
</div>
<div id="outline-container-h:10bc7dae-c8a1-485e-9ace-2e78771fad41" class="outline-4">
<h4 id="h:10bc7dae-c8a1-485e-9ace-2e78771fad41">两种模型对比</h4>
<div class="outline-text-4" id="text-h:10bc7dae-c8a1-485e-9ace-2e78771fad41">
<p>
两种模型结合对比来看， <code>通常使用点对点模型的，是一些耗时较长的、逻辑相对独立的业务</code> ，比如前面讲到的发送邮件这样一个操作。因为发送邮件比较耗时，而且应用程序其实并不太关心邮件发送是否成功，发送邮件的逻辑也相对比较独立，所以它只需要把邮件消息丢到消息队列中就可以返回了。消费者也不需要关心是哪个生产者去发送的邮件，它只需要把邮件消息内容取出来以后进行消费，通过远程服务器将邮件发送出去就可以了。而且每个邮件只需要被发送一次。所以 <code>消息只被一个消费者消费</code> 就可以了。
</p>

<p>
相对应的另一些情况，比如新用户注册，就适合使用发布订阅模型。一个新用户注册成功以后，需要给用户发送一封激活邮件，发送一条欢迎短信，还需要将用户注册数据写入数据库，甚至需要将新用户信息发送给关联企业的系统，比如淘宝新用户信息发送给支付宝，这样允许用户可以一次注册就能登录使用多个关联产品。那么对于新用户注册这样一个消息，就需要使用按主题发布的方式，也就是发布订阅模型这种方式。一个新用户注册，会把注册消息发送给一个主题，多种消费者可以订阅这个主题，比如发送邮件的消费者、发送短信的消费者、将注册信息写入数据库的消费者，跨系统同步消息的消费者等。
</p>
</div>
</div>
</div>
<div id="outline-container-h:e6ca488f-45f9-4af8-8d78-a194398a41f4" class="outline-3">
<h3 id="h:e6ca488f-45f9-4af8-8d78-a194398a41f4">消息队列的好处</h3>
<div class="outline-text-3" id="text-h:e6ca488f-45f9-4af8-8d78-a194398a41f4">
<p>
通过前面的例子，可以看出消息队列有这样的一些优点，包括:
</p>
<ul class="org-ul">
<li>异步处理</li>
<li>易伸缩</li>
<li>使峰值变平缓</li>
<li>失败隔离及自我修复</li>
<li>解耦。</li>
</ul>
</div>
<div id="outline-container-h:7cb56cbf-65f3-4beb-a0d3-1d2a5eb0c9b0" class="outline-4">
<h4 id="h:7cb56cbf-65f3-4beb-a0d3-1d2a5eb0c9b0">异步处理</h4>
<div class="outline-text-4" id="text-h:7cb56cbf-65f3-4beb-a0d3-1d2a5eb0c9b0">
<p>
第一个好处是实现异步处理，提升处理性能。对一些比较耗时的操作，我们可以把处理过程通过消息队列进行异步处理。这样做一个显而易见的好处就是，可以推迟耗时操作的处理，使耗时操作异步化，而不必阻塞客户端的程序，客户端的程序在得到处理结果之前就可以继续执行，从而提高客户端程序的处理性能。
</p>
</div>
</div>
<div id="outline-container-h:8592c31e-55ef-4ea7-bc16-b812c48cebe5" class="outline-4">
<h4 id="h:8592c31e-55ef-4ea7-bc16-b812c48cebe5">易伸缩</h4>
<div class="outline-text-4" id="text-h:8592c31e-55ef-4ea7-bc16-b812c48cebe5">
<p>
第二个好处，它可以让系统获得更好的伸缩性。因为耗时的任务可以通过分布式消息队列向多台消费者服务器并行发送消息，然后在很多台消费者服务器上并行处理消息，也就是说可以在多台物理服务器上运行消费者。那么当负载上升的时候，可以很容易地添加更多的机器成为消费者。
</p>

<p>
如下图所示，用户上传文件后，通过发布消息的方式，通知后端的消费者获取数据、读取文件，进行异步的文件处理操作。那么当前端发布更多文件的时候，或者处理逻辑比较复杂的时候，就可以通过添加后端的消费者服务器，增强系统的处理能力。
</p>


<figure id="orgf2d114c">
<img src="./images/CgotOV13GXKATU17AABlL42Ox4U769.png" alt="CgotOV13GXKATU17AABlL42Ox4U769.png">

</figure>
</div>
</div>
<div id="outline-container-h:92a4193b-cae1-4454-a5f2-d203276f4470" class="outline-4">
<h4 id="h:92a4193b-cae1-4454-a5f2-d203276f4470">使峰值平缓</h4>
<div class="outline-text-4" id="text-h:92a4193b-cae1-4454-a5f2-d203276f4470">
<p>
使用消息队列的第三个好处是可以平衡流量峰值，削峰填谷。使用消息队列，即便是访问流量持续的增长，系统依然可以持续地接收请求。这种情况下，虽然生产者发布消息的速度比消费者消费消息的速度快，但是可以持续地将消息纳入到消息队列中，用消息队列作为消息的缓冲，因此短时间内，发布者不会受到消费处理能力的影响。
</p>

<p>
如下图所示，因为消息的生产者是直接面向用户请求的，而用户的请求访问压力是不均衡的，比如淘宝每天的访问高峰是在上午
10 点左右，而新浪微博则可能在某个明星半夜发一条微博后突然出现访问高峰。
</p>


<figure id="org89a298d">
<img src="./images/CgotOV13TBeANayOAACLzNzqryE259.png" alt="CgotOV13TBeANayOAACLzNzqryE259.png">

</figure>

<p>
在访问高峰，用户的并发访问数可能超过了系统的处理能力，所以在高峰期就可能会导致系统负载过大，响应速度变慢，更严重的可能会导致系统崩溃。这种情况下，通过消息队列将用户请求的消息纳入到消息队列中，通过消息队列缓冲消费者处理消息的速度。
</p>

<p>
如图中所示，消息的生产者负载有高峰有低谷，但是到了消费者这里，只会按照自己的最佳处理能力去消费消息。高峰期它会把消息缓冲在消息队列中，而在低谷期它也还是使用自己最大的处理能力去获取消息，将前面缓冲起来、来不及及时处理的消息处理掉。那么，通过这种手段可以实现系统负载 <code>削峰填谷</code> ，也就是说将访问的高峰削掉，而将访问的低谷填平，使系统处在一个最佳的处理状态之下，不会对系统的负载产生太大的冲击。
</p>
</div>
</div>
<div id="outline-container-h:4bbbfcfc-5955-4a11-887a-bc086a24930f" class="outline-4">
<h4 id="h:4bbbfcfc-5955-4a11-887a-bc086a24930f">失败隔离及自我修复</h4>
<div class="outline-text-4" id="text-h:4bbbfcfc-5955-4a11-887a-bc086a24930f">
<p>
消息队列的第四个好处是失败隔离和自我修复。因为发布者不直接依赖消费者，所以分布式消息队列可以将消费者系统产生的错误异常与生产者系统隔离开来，生产者不受消费者失败的影响。 当在消息消费过程中出现处理逻辑失败的时候，这个错误只会影响到消费者自身，而不会传递给消息的生产者，也就是应用程序可以按照原来的处理逻辑继续执行。
</p>

<p>
这也就意味着在任何时候都可以对后端的服务器执行维护和发布操作。我们可以重启、添加或删除服务器，而不影响生产者的可用性，这样简化了部署和服务器管理的难度。
</p>
</div>
</div>
<div id="outline-container-h:61373d15-c3db-4b8b-bde8-53aa71dc58ad" class="outline-4">
<h4 id="h:61373d15-c3db-4b8b-bde8-53aa71dc58ad">解耦</h4>
<div class="outline-text-4" id="text-h:61373d15-c3db-4b8b-bde8-53aa71dc58ad">
<p>
第五个好处，如下图所示，使用分布式消息队列，可以使生产者和消费者的代码实现解耦合，也就是说可以多个生产者发布消息，多个消费者处理消息，共同完成完整的业务处理逻辑，但是它们却不需要直接进行交互调用，没有代码的依赖耦合。在传统的同步调用中，调用者代码必须要依赖被调用者的代码，也就是生产者代码必须要依赖消费者的处理逻辑代码，代码需要直接的耦合，而使用消息队列，这两部分的代码不需要进行任何的耦合。耦合程度越低的代码越容易维护，也越容易进行扩展。
</p>


<figure id="orgfdf53be">
<img src="./images/CgoB5l13WDeAZbSUAACZpbCjQVI728.png" alt="CgoB5l13WDeAZbSUAACZpbCjQVI728.png">

</figure>

<p>
比如前面提到的新用户注册的例子，如果用传统同步调用的方式，那么发邮件、发短信、写数据库、通知关联系统这些代码会和用户注册代码直接耦合起来，整个代码看起来就是完成用户注册逻辑后，后面必然跟着发邮件、发短信这些代码。如果要新增一个功能，比如将监控用户注册情况，将注册信息发送到业务监控系统，就必须要修改前面的代码，至少增加一行代码，发送注册信息到监控系统，我们知道，任何代码的修改都可能会引起
bug。
</p>

<p>
而使用分布式消息队列实现生产者和消费者解耦合以后，用户注册完成，不需要调用任何后续处理代码，只需要将注册消息发送到分布式消息队列就可以了。如果要增加新功能，只需要写个新功能的消费者程序，在分布式消息队列中，订阅用户注册主题就可以了，不需要修改原来任何一行代码。
</p>

<p>
解耦的特点对于团队的工作分工也很有帮助。从消息生产者的视角看，它只需要构建消息，将消息放入消息队列中，开发就完成了；而从消费者的开发视角看，它只需要从消息队列中获取消息，然后进行逻辑处理。它们彼此之间不进行任何耦合。消息的生产者不关心放入消息队列中下一步会发生什么，而消费者也不需要知道消息从哪里来。这两部分程序的开发者也可以不关心彼此的工作进展，他们开发的代码也不需要集成在一起，只要约定好消息格式，就可以各自开发了。
</p>
</div>
</div>
</div>
<div id="outline-container-h:1fe270f1-1ce9-4c8d-9e31-dadcf036885c" class="outline-3">
<h3 id="h:1fe270f1-1ce9-4c8d-9e31-dadcf036885c">消息队列相关挑战</h3>
<div class="outline-text-3" id="text-h:1fe270f1-1ce9-4c8d-9e31-dadcf036885c">
<p>
了解到上面的 5 点好处，你会认为消息队列是完美的吗？其实不是的，接下来讲分布式消息队列遇到的挑战：
</p>
<ul class="org-ul">
<li>消息无序</li>
<li>消息重新入队列</li>
<li>竞态条件</li>
<li>复杂度风险。</li>
</ul>
</div>
<div id="outline-container-h:44cdd863-cef6-4e09-9580-428488b785ff" class="outline-4">
<h4 id="h:44cdd863-cef6-4e09-9580-428488b785ff">消息无序</h4>
<div class="outline-text-4" id="text-h:44cdd863-cef6-4e09-9580-428488b785ff">
<p>
先来说消息无序。因为生产者和消费者是异步处理的。虽然消息队列本身会保证先创建的消息在前面，但是消费者却并不能保证先创建的消息先消费掉。
</p>

<p>
如下图所示，生产者会创建两个消息，一个是创建用户，另一个是欢迎邮件。消费者应该先消费创建用户，然后再消费欢迎邮件，业务逻辑有先后顺序。但是由于消费者可能是在并行执行，两个消费者分别获得了创建用户和发送欢迎邮件两个消息。那么，有可能欢迎邮件被消费者先处理完了，而创建用户的消费者还没有来得及处理这条消息，就可能会导致欢迎邮件在创建用户之前就已经发出去了。
</p>


<figure id="orge418e8d">
<img src="./images/CgotOV13WGCAPpr5AAB6e0s8OFk657.png" alt="CgotOV13WGCAPpr5AAB6e0s8OFk657.png">

</figure>

<p>
一个简单的解决办法就是将消息处理的顺序设计到异步流程中，也就是创建用户的消费者在处理消息后，再发送一个欢迎邮件的消息到消息队列中。这样就可以保证邮件发送一定在创建用户之后，从而满足业务逻辑的顺序性要求。
</p>
</div>
</div>
<div id="outline-container-h:dc665827-fd28-4416-9a6c-d092cde945e7" class="outline-4">
<h4 id="h:dc665827-fd28-4416-9a6c-d092cde945e7">息重新入队列</h4>
<div class="outline-text-4" id="text-h:dc665827-fd28-4416-9a6c-d092cde945e7">
<ul class="org-ul">
<li><b>消息重复处理</b> ：在某些失败场景下可能导致消息重新进入队列</li>
<li><b>解决之道</b> ：实现幂等性，消费者可以多次处理同一条消息而不影响最终结果</li>
</ul>

<p>
另一个挑战是消息重新入队列，重复消费。有些分布式消息队列产品支持将某个消费者处理失败的消息重新放入到消息队列中，被其它的消费者重新处理。但是重新放入到消息队列中的消息有可能是被处理完成了的，也就是表面看起来处理失败，实际上已经处理完成，这种情况在软件运行过程中并不鲜见。那么这种情况下就会导致同一条消息被多次消费。
</p>

<p>
解决这个问题的主要手段是将消息处理设计成幂等性，也就是说消费者可以对同一条消息进行多次处理计算，而不会影响最终的结果。有些操作天然就是幂等的，比如将商品价格设置为 50 元，不管设置多少次，都是 50 元，不会影响最终结果。而有些操作，比如发送邮件，发送两次和发送一次结果肯定是不同的，对于这类非天然幂等的操作，需要进行特别设计，才能实现最终效果上的幂等。
</p>
</div>
</div>
<div id="outline-container-h:2f4d1a91-99b5-495e-81ca-9c1b7bc6591e" class="outline-4">
<h4 id="h:2f4d1a91-99b5-495e-81ca-9c1b7bc6591e">竞态条件</h4>
<div class="outline-text-4" id="text-h:2f4d1a91-99b5-495e-81ca-9c1b7bc6591e">
<p>
第三个挑战是竞态条件。所谓竞态条件就是指在程序并发执行的时候，不同的执行顺序会导致不同的结果，主要是因为对共享资源的访问顺序不同导致的结果不同。我们在编程中通过多线程实现程序的并发执行，消息队列可以在分布式的环境下实现架构层面的并发执行，并发执行就可能会导致对资源的争用。在编程中我们通常使用锁的机制进行并发的控制，以避免竞态、顺序执行。在消息队列的异步架构中也需要对共享资源的并发访问进行控制，以避免竞态条件的出现。
</p>
</div>
</div>
<div id="outline-container-h:b9cc588f-8225-44d6-9aad-cce4ca63aeb4" class="outline-4">
<h4 id="h:b9cc588f-8225-44d6-9aad-cce4ca63aeb4">复杂度风险</h4>
<div class="outline-text-4" id="text-h:b9cc588f-8225-44d6-9aad-cce4ca63aeb4">
<p>
消息队列的第四个挑战是复杂度风险。消息队列使系统的架构和处理流程更加复杂，带来了更多的复杂性问题，从而也对架构师的系统架构设计能力和架构把控能力提出了更高的挑战和要求。
</p>
</div>
</div>
</div>
<div id="outline-container-h:6deed4aa-3d65-48ed-8433-22453d6eab25" class="outline-3">
<h3 id="h:6deed4aa-3d65-48ed-8433-22453d6eab25">消息队列的反模式</h3>
<div class="outline-text-3" id="text-h:6deed4aa-3d65-48ed-8433-22453d6eab25">
<ul class="org-ul">
<li>模式：当解决方案被一次又一次证明是成功的</li>
<li>反模式：如果方案反复被证明带来问</li>
</ul>

<p>
所谓模式就是指可多次复用的解决方案。当解决方案一次又一次地被证明是成功的，我们就称它为“模式”。后面有同类问题出现的时候，我们就使用相同的解决方案去处理，也就是所谓的模式复用。
</p>

<p>
但是如果解决方案被认为是错误的，它们经常会带来问题，就称之为“反模式”。典型的反模式一开始用起来不错，但是时间越长问题越多。熟悉反模式，你就能在未来避免它们，就像对常见的设计缺陷产生免疫一样。
</p>

<p>
接下来介绍消息队列常见的几种反模式。
</p>
</div>
<div id="outline-container-h:a5662fc3-b970-4620-8454-e727aef4a369" class="outline-4">
<h4 id="h:a5662fc3-b970-4620-8454-e727aef4a369">阻塞式调用</h4>
<div class="outline-text-4" id="text-h:a5662fc3-b970-4620-8454-e727aef4a369">
<p>
有些分布式消息队列产品允许生产者阻塞，也就是生产者发送消息以后，阻塞等待消息队列处理结果，等消费者处理完成返回处理结果以后，继续向下执行。这样就使消息队列成为一个同步的调用模式。使用同步模式看起来在某些场合下是比较合理的，因为可以等待执行结果，拿到结果后继续处理，但是这种方式使得消息队列异步架构的各种好处都丧失了。
</p>
</div>
</div>
<div id="outline-container-h:46ef5a10-abed-47fd-82e8-a59abbd29946" class="outline-4">
<h4 id="h:46ef5a10-abed-47fd-82e8-a59abbd29946">耦合生产者和消费者</h4>
<div class="outline-text-4" id="text-h:46ef5a10-abed-47fd-82e8-a59abbd29946">
<p>
另一种反模式是耦合生产者和消费者。虽然消息队列将生产和消费者解耦合了，但是不恰当的设计依然会使生产者和消费者产生耦合。比如说在消息中包含处理逻辑，也就是说在消息中约定消费者应该如何进行处理。或者是说使用特定的序列化协议编码消息。那么消费者必须要按照特定的序列化格式，才能解码消息。这些情况都使得生产者和消费者产生了不必要的耦合。
</p>
</div>
</div>
<div id="outline-container-h:7a317e2b-5643-48e9-af53-672202681b58" class="outline-4">
<h4 id="h:7a317e2b-5643-48e9-af53-672202681b58">缺少坏消息处理</h4>
<div class="outline-text-4" id="text-h:7a317e2b-5643-48e9-af53-672202681b58">
<p>
还有一种反模式是缺少坏消息的处理。使用消息队列的时候，不能总是假定消息永远正确。对于引发消费者崩溃的消息，应该丢弃而不是重新处理。因为如果导致消费者失败的原因是消息本身，那么每次重新处理都会导致消费者失败，最后导致整个消费者服务器集群都崩溃，系统什么也干不了。
</p>
</div>
</div>
</div>
<div id="outline-container-h:b691f97e-19aa-47e3-8973-0b92abfd3930" class="outline-3">
<h3 id="h:b691f97e-19aa-47e3-8973-0b92abfd3930">常用消息队列产品</h3>
<div class="outline-text-3" id="text-h:b691f97e-19aa-47e3-8973-0b92abfd3930">
<p>
目前业界常用的消息队列产品，主要有：RabbitMQ 、ActiveMQ、RocketMQ 、Kafka。
</p>

<ul class="org-ul">
<li>RabbitMQ 的主要特点是性能好，社区活跃，但是 RabbitMQ 用 Erlang开发，
我们的应用很少用 Erlang，所以不便于二次开发和维护。</li>

<li>ActiveMQ 影响比较广泛，可以跨平台，使用 Java 开发，对 Java开发者比较
友好。</li>

<li>RocketMQ 是阿里推出的一个开源产品，也是使用 Java开发，性能比较好，可
靠性也比较高。</li>

<li><p>
Kafka 是 Linkedin出品的，专门针对分布式场景进行了优化，因此分布式的
伸缩性会比较好。
</p>

<p>
目前看来，Kafka 因为最初就是针对互联网的分布式、高可用应用场景而设计的，并且在大数据领域得到广泛支持，资料文档更加完善，因此在互联网企业得到更多的应用。
</p></li>
</ul>

<p>
分享一个技术产品选型的小技巧，技术决策时可作为参考。当在几个相似的技术 产品中进行选型决策，并且拿不定主意、感觉都差不多的时候，一个办法就是  <code>利用搜索引擎搜索一下这些产品的名字。搜索结果最多的产品</code> ，一般是最热门， 文档资料最多，遇到问题有更大概率找到答案的，最有发展前景不会半途而废没 人维护的。利用这个技巧，我们看一下消息队列（MQ）的产品选型，Kafka 在百度中的搜索结果数量是其它三个 MQ 产品的搜索结果数量之和，那么如果你拿不 定主意，选择 Kafka 至少不会是最糟糕的选择。
</p>
</div>
</div>
<div id="outline-container-h:682f4489-9d00-4dec-81f4-1d029b771748" class="outline-3">
<h3 id="h:682f4489-9d00-4dec-81f4-1d029b771748">总结回顾</h3>
<div class="outline-text-3" id="text-h:682f4489-9d00-4dec-81f4-1d029b771748">
<pre class="example" id="orgb7f904c">
异步调用架构方法--&gt;点对点与发布订阅--&gt;消息队列实现，更好的架构目标--&gt;
关注异步架构带来的挑战--&gt;正确使用异步架构--&gt;挑选合适的消息队列产品
</pre>

<p>
使用异步调用的架构方法，就是使用消息队列，将生产者和消费者进行隔离。主要的架构模型有两种，一种是点对点模型，一种是发布订阅模型。其中点对点模型，一个消息只会被一个消费者消费；而发布订阅模型，一个消息可以被多个消费者订阅。
</p>

<p>
消息队列实现的异步架构可以在架构上带来更多的好处。它可以实现业务逻辑的异步处理，从而获得更好性能特性；可以使系统具有更好的伸缩性；可以平衡用户访问流量，实现削峰填谷；还可以隔离失败，并进行自我修复；以及对生产者和消费者进行解耦，使系统拥有更好的扩展和维护能力。
</p>

<p>
同时我们需要关注异步消息队列架构带来的挑战。第一个是消息无序，第二个是消息重复处理，第三个是竞态条件，还有一个是系统的复杂度的增加。
</p>

<p>
总之，消息队列实际上可以带来很多架构上的好处，但是不正确地使用消息队列可能会丧失这些好处。
</p>

<p>
下一章节将讲解分布式数据库相关知识与实践。
</p>
</div>
</div>
</section>
<section id="outline-container-h:16165a6f-4100-4b9f-88b1-359771cbe09f" class="outline-2">
<h2 id="h:16165a6f-4100-4b9f-88b1-359771cbe09f">第04讲：架构核心技术之分布式数据存储</h2>
<div class="outline-text-2" id="text-h:16165a6f-4100-4b9f-88b1-359771cbe09f">
<form><input type="button" value="音频" onclick="doSound(4); return false;"></form>
<span id="dummy4"></span>

<blockquote>
<ol class="org-ol">
<li>MySQL 数据复制</li>
<li>数据库分区</li>
<li>NoSQL 分布式数据库</li>
</ol>
</blockquote>

<p>
本章节主题为分布式数据存储，知识架构图如下所示。
</p>


<figure id="orga5b6c97">
<img src="./images/CgotOV13HsiAXNKNAAGilToW6a4338.png" alt="CgotOV13HsiAXNKNAAGilToW6a4338.png">

</figure>

<p>
本章节主要包括以下内容：
</p>

<ul class="org-ul">
<li>MySQL 复制，有主从复制和主主复制两种；</li>

<li>数据分片（或称数据分区），具体为数据分片的原理、分片的方案、分片数据库的扩容；</li>

<li>数据库分布式部署的几种方案；
<ul class="org-ul">
<li>单一部署</li>

<li>分库</li>

<li>分片</li>
</ul></li>

<li>NoSQL 中的 CAP 原理、分布式系统的最终一致性及其实现方案。</li>
</ul>
</div>
<div id="outline-container-h:ab1f05b0-b2ce-40ea-a4ea-ed8f0bdbf52e" class="outline-3">
<h3 id="h:ab1f05b0-b2ce-40ea-a4ea-ed8f0bdbf52e">MySQL 数据库复制</h3>
<div class="outline-text-3" id="text-h:ab1f05b0-b2ce-40ea-a4ea-ed8f0bdbf52e">
</div>
<div id="outline-container-h:adaf4510-755f-4547-9968-a80038556f05" class="outline-4">
<h4 id="h:adaf4510-755f-4547-9968-a80038556f05">主从复制</h4>
<div class="outline-text-4" id="text-h:adaf4510-755f-4547-9968-a80038556f05">
<p>
MySQL 的主从复制，顾名思义就是将 MySQL 主数据库中的数据复制到从数据库中去。主要目的是实现数据库读写分离-&#x2013;&#x2014;写操作访问主数据库，读操作访问从数据库，从而使数据库具有更强大的访问负载能力，支撑更多的用户访问。
</p>

<p>
如下图所示，它的 <code>主要的复制原理</code> 是当应用程序客户端发送一条更新命令到数据库的时候，数据库会把这条更新命令同步记录到 Binlog 中，然后由另外一个线程从 Binlog 中读取这条日志，再通过远程通讯的方式将它复制到从服务器上面去，从服务器获得这条更新日志后，将其加入到自己的 Relay log 中，然后由另外一个 SQL 执行线程从 Relay log 中读取这条新的日志，并把它在本地的数据库中重新执行一遍，这样当客户端应用程序执行一个 update 命令的时候，这个命令会在主数据库和从数据库上同步执行，从而实现了主数据库向从数据库的复制，让从数据库和主数据库保持一样的数据。
</p>


<figure id="org09e0471">
<img src="./images/CgotOV13W-WANQYbAAR8RKLKV9U675.png" alt="CgotOV13W-WANQYbAAR8RKLKV9U675.png">

</figure>
</div>
</div>
<div id="outline-container-h:c013be74-c4de-44a3-b9bd-6897ff0284b5" class="outline-4">
<h4 id="h:c013be74-c4de-44a3-b9bd-6897ff0284b5">一主多从复制</h4>
<div class="outline-text-4" id="text-h:c013be74-c4de-44a3-b9bd-6897ff0284b5">
<p>
MySQL 的主从复制是一种数据同步机制，除了可以将一个主数据库中的数据同步复制到一个从数据库上，还可以将一个主数据库上的数据同步复制到多个从数据库上，也就是所谓的 MySQL 的一主多从复制。
</p>

<p>
如下图所示，多个从数据库关联到主数据库后，将主数据库上的 Binlog 日志同步地复制到了多个从数据库上，通过执行日志，每个从数据库的数据都和主数据库上的数据保持了一致。这里面的数据更新操作表示的是所有数据库的更新操作，除了 SELECT 之类的查询读操作以外，其他的 INSERT、DELETE、UPDATE 这样的 DML 写操作，以及 CREATE TABLE、DROPT ABLE、ALTER TABLE 等 DDL 操作都可以同步复制到从数据库上去。
</p>


<figure id="org6671ddb">
<img src="./images/CgoB5l13TW2ADnx0AAFtYmgkr0Y145.png" alt="CgoB5l13TW2ADnx0AAFtYmgkr0Y145.png">

</figure>
</div>
</div>
<div id="outline-container-h:9569c9c0-fb23-4f9e-9c92-a9f9ef6e681c" class="outline-4">
<h4 id="h:9569c9c0-fb23-4f9e-9c92-a9f9ef6e681c">一主多从复制的优点</h4>
<div class="outline-text-4" id="text-h:9569c9c0-fb23-4f9e-9c92-a9f9ef6e681c">
<p>
一主多从复制有四大优点：分摊负载、专机专用、便于冷备、高可用。
</p>

<ul class="org-ul">
<li><p>
分摊负载
</p>

<p>
将只读操作分布在多个从数据库上，从而将负载分摊到多台服务器上。
</p>

<p>
一般说来，对数据库做主从复制的时候，通常是为了进行读写分离，数据库的写操作会连接到主数据库上进行，而数据的读操作则连接到从服务器上进行，这样把读写两部分操作分别交给不同的服务器去处理，降低数据库的负载压力，而使用更多的从数据库向应用程序提供读服务，更好地减轻了整个数据库的访问压力。
</p></li>

<li><p>
专机专用
</p>

<p>
可以针对不同类型的查询，使用不同的从服务器。
</p>

<p>
比如有一台服务器专门用来做应用程序的读操作，另一个服务器专门用来执行数据报表类的操作，还有的服务器可能专门执行数据备份。通过这样的方式，将不同的操作连接到不同的从数据库上，从而实现了专机专用，也进一步改善了用户的体验。
</p></li>

<li><p>
便于冷备
</p>

<p>
即使数据库进行了一主多从的复制，在一些极端的情况下，比如整个机房遭遇了火灾、地震或其它一些极端灾害，也可能会导致整个数据中心的数据服务器都丢失。代码可以重新部署，但是数据库是我们过往的宝贵资源。如果历史数据都丢失了，用户信息、商品数据、订单数据&#x2026;&#x2026;所有的数据永远丢失，那么即使程序和代码都在，整个系统也永远都不可恢复了。这种损失是一个系统不能够承受的，更是一个公司不能承受的。
</p>

<p>
所以通常说来很多公司会对数据做冷备，即把历史上的数据全部备份下来，把它存储到另外一个地方，甚至锁在保险柜里。当发生了极端灾害的时候，所有的数据都丢失的时候，还可以通过这些冷备的数据重新恢复整个网站。 <code>但是进行冷备的时候有一个困难点在于，数据库如果正在进行写操作，冷备的数据就可能不完整，数据文件可能处于损坏状态</code> 。以前的做法是停机冷备，也就是停止数据库的写操作，将数据文件拷贝出去后，再重新打开数据访问。而现在使用一主多从的复制就就可以实现 <code>零停机时间的备份</code> 。只需要关闭数据的数据复制进程，文件就处于关闭状态了，然后进行数据文件拷贝，拷贝完成后再重新打开数据复制就可以了。
</p></li>

<li><p>
高可用
</p>

<p>
如果一台服务器宕机了，只要不发请求给这台服务器就不会出问题。当这台服务器恢复的时候，再重新发请求到这台服务器。所以，在一主多从的情况下，某一台从服务器宕机不可用，对整个系统的影响是非常小的。
</p></li>
</ul>
</div>
</div>
<div id="outline-container-h:c8997c9c-d035-4d4c-95b9-35b30b43ac86" class="outline-4">
<h4 id="h:c8997c9c-d035-4d4c-95b9-35b30b43ac86">主主复制</h4>
<div class="outline-text-4" id="text-h:c8997c9c-d035-4d4c-95b9-35b30b43ac86">
<p>
但是一主多从只能够实现从服务器上的这些优点，当主数据库宕机不可用的时候，数据依然是不能够写入的，因为数据不能够写入到从服务器上面去，从服务器是只读的。
</p>

<p>
为了解决主服务器的可用性问题，我们可以使用 MySQL 的主主复制方案。所谓的主主复制方案是 <code>指两台服务器都当作主服务器，任何一台服务器上收到的写操作都会复制到另一台服务器上</code> 。
</p>

<p>
如下图所示，来看 <code>主主复制原理</code> 。当客户端程序对主服务器 A 进行数据更新操作的时候，主服务器 A 会把更新操作写入到 Binlog 日志中，然后 Binlog 会将数据日志同步到主服务器 B，写入到主服务器的 Relay log 中，然后执行 Relay log，获得 Relay log 中的更新日志，执行 SQL 操作写入到数据库服务器 B 的本地数据库中。B 服务器上的更新也同样通过 Binlog 复制到了服务器 A 的 Relay log 中，然后通过 Relay log 将数据更新到服务器 A 中，通过这种方式，服务器 A 或者 B 任何一台服务器收到了数据的写操作都会同步更新到另一台服务器，实现了数据库主主复制。主主复制可以提高系统的写可用，实现写操作的高可用。
</p>


<figure id="orgf0075bf">
<img src="./images/CgoB5l13W7SAR1iEAAUv-NT59RI274.png" alt="CgoB5l13W7SAR1iEAAUv-NT59RI274.png">

</figure>

<p>
那么，当使用 MySQL 服务器实现主主复制时，数据库服务器失效该如何应对？
</p>

<p>
如下图所示，正常情况下用户会写入到主服务器 A 中，然后数据从 A 复制到主服务器 B 上。当主服务器 A 失效的时候，写操作会被发送到主服务器 B 中去，数据从 B 服务器复制到 A 服务器。
</p>


<figure id="org546f79e">
<img src="./images/CgoB5l13W5OAGyUpAAPoxrnObJo370.png" alt="CgoB5l13W5OAGyUpAAPoxrnObJo370.png">

</figure>

<p>
再具体看一下主主失效的维护过程，如下图。
</p>


<figure id="org87725f4">
<img src="./images/CgotOV13WKyAEPxFAAJHaNshZYg195.png" alt="CgotOV13WKyAEPxFAAJHaNshZYg195.png">

</figure>

<p>
最开始的时候，所有的主服务器都可以正常使用，当主服务器 A 失效的时候，进入故障状态，应用程序检测到主服务器 A 失效，检测过程可能需要几秒钟或者几分钟的时间，然后应用程序需要进行失效转移，将写操作发送到备份主服务器 B 上面去，将读操作发送到 B 服务器对应的从服务器上面去。一段时间后故障结束，A 服务器需要重建失效期间丢失的数据，也就是把自己当作从服务器去从 B 服务器上面同步数据，同步完成后系统才能恢复正常。这个时候 B 服务器是用户的主要访问服务器，A 服务器当作备份服务器。
</p>
</div>
</div>
<div id="outline-container-h:4e824aee-eaa7-4970-98cb-f4b55459e11a" class="outline-4">
<h4 id="h:4e824aee-eaa7-4970-98cb-f4b55459e11a">MySQL 复制的注意事项</h4>
<div class="outline-text-4" id="text-h:4e824aee-eaa7-4970-98cb-f4b55459e11a">
<blockquote>
<ul class="org-ul">
<li>主主复制的两个数据库不能并发写入</li>
<li>复制只是增加了数据的读并发处理能力，没有增加写并发能力和存储能力</li>
<li>更新表结构会导致巨大的同步延迟</li>
</ul>
</blockquote>

<p>
使用 MySQL 进行主主复制的时候需要注意如下事项。
</p>

<ul class="org-ul">
<li><p>
不要对两个数据库同时进行数据写操作，因为这种情况会导致数据冲突。
</p>

<p>
两个服务器对同一条记录进行写操作，互相进行数据复制的时候，数据库就不知道哪条数据是正确的。
</p></li>

<li><p>
复制只是增加了数据的读并发处理能力，并没有增加写并发的能力和系统存储能力。
</p>

<p>
因为数据复制后，所有的数据库存储的数据都是一样的，不管是主主复制，还是主从复制。如果存储资源不足、磁盘不够大，数据复制后，即使写到多个服务器上，存储依然是不够用的。同时，它也没有增加写并发能力，即使使用主主复制，应用程序一个时间内也只能向一个数据库写入。
</p></li>

<li><p>
更新数据表的结构会导致巨大的同步延迟。
</p>

<p>
比如要在一张表中增加一个字段，要执行一个 ALTER TABLE 操作，这个操作会导致同步延迟巨大，因为该操作会阻塞其它的 Binlog 日志同步，这时候主数据库的很多写操作都无法同步到从数据库上面去，导致数据不一致。所以 <code>在实践中需要更新表结构的操作，不要写入到 Binlog 中，也就是关闭更新表结构的 Binlog。如果要对表结构进行更新</code> ，应该有运维工程师 DBA 对所有主从数据库分别手动进行数据表结构的更新操作。
</p></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-h:64e38f44-2638-47b6-8f26-58e5f6902cf3" class="outline-3">
<h3 id="h:64e38f44-2638-47b6-8f26-58e5f6902cf3">数据分片</h3>
<div class="outline-text-3" id="text-h:64e38f44-2638-47b6-8f26-58e5f6902cf3">
<blockquote>
<ol class="org-ol">
<li>分片目标：将数据集切分成较小的分片，以便于将它们分散存储在多台服务器上，避免一台机器处理整个数据集</li>
<li>分片特点：服务器之间互相独立，不共享任何信息；通过分片键定位分片</li>
<li>分片原理：将数据以某种方式切分，以便每台服务器都只存储一部分数据</li>
</ol>
</blockquote>
</div>
<div id="outline-container-h:86914a18-8671-4578-ac72-83164dc91eaf" class="outline-4">
<h4 id="h:86914a18-8671-4578-ac72-83164dc91eaf">数据分片的目标</h4>
<div class="outline-text-4" id="text-h:86914a18-8671-4578-ac72-83164dc91eaf">
<p>
再看数据分片，上面提到过数据复制只能提高数据读并发操作能力，并不能提高数据写操作并发的能力以及数据整个的存储容量，也就是并不能提高数据库总存储记录数。如果我们数据库的写操作也有大量的并发请求需要满足，或者是我们的数据表特别大，单一的服务器甚至连一张表都无法存储，那怎么办？解决方案就是 <code>数据分片</code> 。
</p>

<p>
数据分片的主要目标是， <code>将一张数据表切分成较小的片，不同的片存储到不同的服务器上面去</code> ，通过分片的方式使用多台服务器存储一张数据表， <code>避免一台服务器记录存储处理整张数据表</code> 带来的存储及访问压力。
</p>
</div>
</div>
<div id="outline-container-h:0fac6f68-5bf3-4add-af06-43a873010bd7" class="outline-4">
<h4 id="h:0fac6f68-5bf3-4add-af06-43a873010bd7">数据分片的特点</h4>
<div class="outline-text-4" id="text-h:0fac6f68-5bf3-4add-af06-43a873010bd7">
<p>
分片的主要特点是 <code>数据库服务器之间互相独立，不共享任何信息</code> ，即使有部分服务器故障，也不影响整个系统的可用性。另一个特点是 <code>通过分片键定位分片</code> ，也就是说一个分片存储到哪个服务器上面去， <code>到哪个服务器上面去查找，是通过分片键进行路由分区算法计算出来的</code> 。在 SQL 语句里面，只要包含分片键，就可以访问特定的服务器，而不需要连接所有的服务器，跟其他的服务器进行通信。
</p>
</div>
</div>
<div id="outline-container-h:a7119310-079b-450a-b45d-f8b9c5fba3d9" class="outline-4">
<h4 id="h:a7119310-079b-450a-b45d-f8b9c5fba3d9">数据分片的原理与实现</h4>
<div class="outline-text-4" id="text-h:a7119310-079b-450a-b45d-f8b9c5fba3d9">
<p>
分片的主要原理是将数据以某种方式进行切分，通常就是用刚才提到的分片键的路由算法。通过分片键，根据某种路由算法进行计算，使每台服务器都只存储一部分数据。
</p>

<p>
如下图示例，通过应用程序硬编码的方式实现数据分片。假设我们的数据库将数据表根据用户 ID 进行分片，分片的逻辑是用户 ID 为奇数的数据存储在服务器 2 中，用户 ID 为偶数的数据存储在服务器 1 中。那么，应用程序在编码的时候，就可以直接通过用户 ID 进行哈希计算，通常是余数计算。如果余数为奇数就连接到服务器 2 上，如果余数为偶数，就连接到服务器 1 上，这样就实现了一张用户表分片在两个服务器上。
</p>


<figure id="org753e8b5">
<img src="./images/CgotOV13WOiAeJnvAAIteNo08c8975.png" alt="CgotOV13WOiAeJnvAAIteNo08c8975.png">

</figure>

<p>
这种 <code>硬编码主要的缺点</code> 在于， <code>数据库的分片逻辑是应用程序自身实现的</code> ，应用程序需要耦合数据库分片逻辑，不利于应用程序的维护和扩展。
</p>

<p>
一个简单的解决办法就是将映射关系存储在外面。如下图所示，应用程序在连接数据库进行 SQL 操作的时候，通过查找外部的数据存储查询自己应该连接到哪台服务器上面，然后根据返回的服务器的编号，连接对应的服务器执行相应的操作。在这个例子中，用户 ID 33 查找服务器是 2，用户 ID 94 查找服务器也是 2，它们根据查找到的用户服务器的编号，连接对应的服务器，将数据写入到对应的服务器分片中。
</p>


<figure id="orga793e7c">
<img src="./images/CgotOV13WTKAWRl6AAOpzLgF2Bs560.png" alt="CgotOV13WTKAWRl6AAOpzLgF2Bs560.png">

</figure>

<p>
通过 <code>这种手段实现数据分片的主要挑战</code> 在于：
</p>

<ul class="org-ul">
<li>需要额外的代码，业务逻辑因此变得复杂</li>
<li><p>
无法执行多分片的联合查询。
</p>

<p>
也就是执行查询操作的时候，只能在一个分片上进行。多个分片多张表进行 join 联合查询，这种操作，分片技术是无法实现的。
</p></li>

<li><p>
还有个问题在于无法使用数据库的事务。
</p>

<p>
我们知道现在的数据库事务是通过数据库自身的日志实现，数据库将多个更新 操作，当做一个事务来执行，要么全部完成，要么完全不执行。但是如果是通 过分片的方式，不同的数据操作落在不同的服务器上，不同的服务器之间是无 法实现所有的更新操作全部完成或者全部不执行的，因此也就无法使用数据库 的事务。
</p></li>

<li><p>
还有一个挑战就是系统的数据量是逐渐增加的，如何增加更多的服务器？
</p>

<p>
在数据增加的过程中，如果服务器不够用了，分片不够用了，需要扩大分片的时候，如何增加分片，增加服务器？
</p></li>
</ul>


<p>
<b>分布式数据库中间件</b>
</p>

<p>
现在有一些专门的分布式数据库中间件来解决上述这些问题，比较知名的有 Mycat。Mycat 是一个专门的分布式数据库中间件，应用程序像连接数据库一样去连接 Mycat，而数据分片的操作完全交给了 Mycat 去完成。在下图所示的例子中，有 3 个分片数据库服务器-&#x2013;&#x2014;数据库服务器 dn1、dn2 和 dn3，它们的分片规则是根据 prov 字段进行分片。那么，当我们执行一个查询操作“select * from orders where prov='wuhan'”的时候，Mycat 会根据分片规则将这条 SQL 操作路由到 dn1 这个服务器节点上。dn1 执行数据查询操作返回结果后，Mycat 再返回给应用程序。通过使用 Mycat 这样的分布式数据库中间件，应用程序可以透明地、无感知地使用分片数据库。同时，Mycat 还一定程度上支持分片数据库的联合 join 查询以及数据库事务。
</p>


<figure id="orgd2cd326">
<img src="./images/CgoB5l13WnKAFf4WAAKr7xhpGyc048.png" alt="CgoB5l13WnKAFf4WAAKr7xhpGyc048.png"> 

</figure>
</div>
</div>
<div id="outline-container-h:b4812e7f-a0b2-4293-9a5f-f597d91564a1" class="outline-4">
<h4 id="h:b4812e7f-a0b2-4293-9a5f-f597d91564a1">分片数据库的伸缩扩容</h4>
<div class="outline-text-4" id="text-h:b4812e7f-a0b2-4293-9a5f-f597d91564a1">
<p>
下面来看分片数据库如何进行扩容伸缩。一开始，数据量还不是太多，两个数据库服务器就够了。但是随着数据的不断增长，可能需要增加第三个、第四个、第五个，甚至更多的服务器。在增加服务器的过程中，分片规则需要改变。 <code>分片规则改变后</code> ，以前写入到原来的数据库中的数据，根据新的分片规则，可能要访问新的服务器，所以还 <code>需要进行数据迁移</code> 。
</p>

<p>
不管是更改分片的路由算法规则，还是进行数据迁移，都是一些比较麻烦和复杂的事情。因此在实践中通常的做法是 <code>数据分片使用逻辑数据库</code> ，也就是说一开始虽然只需要两个服务器就可以完成数据分片存储，但是依然在逻辑上把它切分成多个逻辑数据库。
</p>

<p>
在下图所示的例子中，我们将数据库切分成 32 个逻辑数据库，但是开始的时候只有两个物理服务器，我们把 32 个数据库分别启动在两个物理服务器上面。那么，路由算法就还是按照 32 进行路由分区，数据分片也是 32 片。当两台服务器不能够满足数据存储和访问要求的时候，我们只需要简单地将这些逻辑数据库迁移到其他的物理服务器上就可以完成扩容。因为迁移后数据分片还是 32 片，数据分片的算法不需要改变。数据迁移也仅仅是将逻辑数据库迁移到新的服务器上面去，而这种迁移通过数据库的主从复制就可以完成。
</p>


<figure id="orga6141f5">
<img src="./images/CgotOV13HsyANcQIAAx0gxI145s868.png" alt="CgotOV13HsyANcQIAAx0gxI145s868.png">

</figure>
</div>
</div>
</div>
<div id="outline-container-h:f8ef1ca2-5f24-4739-8d4b-31b6778e4e65" class="outline-3">
<h3 id="h:f8ef1ca2-5f24-4739-8d4b-31b6778e4e65">数据库部署方案</h3>
<div class="outline-text-3" id="text-h:f8ef1ca2-5f24-4739-8d4b-31b6778e4e65">
<p>
那么，实践中，数据库的部署方案有哪些？
</p>
</div>
<div id="outline-container-h:069491ba-fc6f-47d4-846d-7515cdc4b812" class="outline-4">
<h4 id="h:069491ba-fc6f-47d4-846d-7515cdc4b812">单一服务和单一数据库</h4>
<div class="outline-text-4" id="text-h:069491ba-fc6f-47d4-846d-7515cdc4b812">
<p>
最简单的就是单一服务和单一数据库。应用服务器可能有多个，但是它们完成的功能是单一的功能。多个完成单一功能的服务器，通过负载均衡对外提供服务。它们只连一台单一数据库服务器，这是应用系统早期用户量比较低的时候的一种架构方法，如下图所示。
</p>


<figure id="org534e121">
<img src="./images/CgoB5l13WoSAVRDFAAHw6hoKJ9E861.png" alt="CgoB5l13WoSAVRDFAAHw6hoKJ9E861.png">

</figure>
</div>
</div>
<div id="outline-container-h:c75adc92-8a2d-435f-8755-ceea412d6d8c" class="outline-4">
<h4 id="h:c75adc92-8a2d-435f-8755-ceea412d6d8c">主从复制</h4>
<div class="outline-text-4" id="text-h:c75adc92-8a2d-435f-8755-ceea412d6d8c">
<p>
如果对 <code>系统的可用性</code> 和对 <code>数据库的访问性能</code> 提出更高要求，就可以通过数据库的主从复制进行初步的伸缩。通过主从复制，实现一主多从。应用服务器的写操作连接主数据库，读操作从从服务器上进行读取，如下图所示。
</p>


<figure id="org57b637d">
<img src="./images/CgotOV13Wr2AI4XBAAIw5NYxRSY754.png" alt="CgotOV13Wr2AI4XBAAIw5NYxRSY754.png">

</figure>
</div>
</div>
<div id="outline-container-h:dcadbdd9-2a1b-47e0-89b2-8e6a7d08e3e6" class="outline-4">
<h4 id="h:dcadbdd9-2a1b-47e0-89b2-8e6a7d08e3e6">业务分库</h4>
<div class="outline-text-4" id="text-h:dcadbdd9-2a1b-47e0-89b2-8e6a7d08e3e6">
<p>
随着业务更加复杂，为了提供更高的数据库处理能力，可以进行数据的业务分库。数据的业务分库是一种逻辑上的，是基于功能的一种分割，将不同用途的数据表存储在不同的物理数据库上面去。
</p>

<p>
在下图的例子中，我们有产品类目服务和用户服务，两个应用服务器集群，对应地，我们将数据库也拆分成两个，一个叫作类目数据库，一个叫作用户数据库。每个数据库依然使用主从复制。通过业务分库的方式，我们在同一个系统中，提供了更多的数据库存储，同时也就提供了更强大的数据访问能力，同时也使系统变得更加简单，系统的耦合变得更低。
</p>


<figure id="orgfa2ea1f">
<img src="./images/CgotOV13WtGAG5nxAAPFQPN1lBs026.png" alt="CgotOV13WtGAG5nxAAPFQPN1lBs026.png">

</figure>
</div>
</div>
<div id="outline-container-h:4c935190-46b4-4a1e-ae65-b3538bad9568" class="outline-4">
<h4 id="h:4c935190-46b4-4a1e-ae65-b3538bad9568">综合部署</h4>
<div class="outline-text-4" id="text-h:4c935190-46b4-4a1e-ae65-b3538bad9568">
<p>
而更复杂的综合部署方案，则是根据不同数据的访问特点，使用不同的解决方案进行应对。比如类目数据库，也许通过主从复制就能够满足所有的访问要求，但是如果用户量特别大，进行主从复制或主主复制，还是不能够满足数据存储以及写操作的访问压力，这时候就可以对用户数据库进行数据分片存储了，同时每个分片数据库也使用主从复制的方式进行部署，如下图所示。
</p>


<figure id="orge8713cb">
<img src="./images/CgoB5l13WtuAaFvJAARjv_I5qRM960.png" alt="CgoB5l13WtuAaFvJAARjv_I5qRM960.png">

</figure>
</div>
</div>
</div>
<div id="outline-container-h:352b1c5a-63ab-4288-8283-c7bcb5c9c5ca" class="outline-3">
<h3 id="h:352b1c5a-63ab-4288-8283-c7bcb5c9c5ca">NoSQL 数据库</h3>
<div class="outline-text-3" id="text-h:352b1c5a-63ab-4288-8283-c7bcb5c9c5ca">
<blockquote>
<p>
MySQL：互联网公司使用最广泛的关系型数据库
</p>

<p>
非关系型数据库（NoSQL）：通常不支持 SQL 语言
</p>
</blockquote>

<p>
像 MySQL 这类关系数据库，在历史上使用比较广泛，但是随着互联网业务的发展，出现了一种新的数据库叫作 NoSQL 数据库。这种数据库和传统的关系数据库不同，它的主要访问方式也不再使用 SQL 进行操作，所以被称作 NoSQL 数据库。NoSQL 数据库主要是解决大规模分布式数据的存储问题。
</p>
</div>
<div id="outline-container-h:dbe146a2-bfb1-4477-b64e-45c1b9d04108" class="outline-4">
<h4 id="h:dbe146a2-bfb1-4477-b64e-45c1b9d04108">CAP 原理与数据一致性</h4>
<div class="outline-text-4" id="text-h:dbe146a2-bfb1-4477-b64e-45c1b9d04108">
<p>
对于大规模的数据分布式存储有一个著名的 CAP 原理。
</p>

<blockquote>
<ul class="org-ul">
<li>C(一致性)：数据一致性，数据的多个备份都是一致的</li>
<li>A(可用性)：数据可用性，任何时任何应用程序都可以读写访问</li>
<li>P(分区耐受性)：系统可以跨网络分区线性伸缩</li>
</ul>
</blockquote>

<p>
CAP 原理是说，对于一个分布式系统，它不能够同时满足一致性（C）、可用性（A）以及分区耐受性（P）这三个特点。其中，一致性是说，任何时候集群中所有的数据的备份都是一致的；可用性是说，当分布式集群中某些服务器节点失效的时候，集群依然是可用的；分区耐受性是说所当网络失效的时候，节点无法通信的时候，系统依然是可用的。而 <code>CAP 原理就是说这三者无法同时满足</code> 。 <code>通常一个分布式应用系统，可用性是必不可少的，而分区耐受性也是需要满足的。因此在现实中，很多系统是通过对数据的一致性做文章，来提供一个满足要求的分布式系统的</code> 。
</p>

<p>
我们先看一下数据是如何不一致的。如下图，假如说有一个分布式集群，有 ABC 3 个服务节点，对于客户端 1，如果执行某个操作，对 ID 55 执行价格等于 99 的 update 操作，这个操作执行在节点 A 上。同时有另一个客户端，对 ID 55 执行价格等于 75 的操作，这个操作执行在节点 B 上。正常情况下 3 个节点之间互相通信，会把 ID 等于 55 的数据同步给其他的节点，三个节点存储的数据一致。但是当网络通信以及节点失效的情况下，这种数据同步就无法完成，就会导致节点 A 和节点 B 上对同一个 ID 存储的数据是不同的，这个时候如果有其他的应用程序连接数据存储集群，并且它们连接的分别是节点 A 和节点 B，那么得到的结果也是不同的，这就会导致数据的不一致。
</p>


<figure id="org49a07e1">
<img src="./images/CgotOV13WuSAPm_PAAJ2eEQkqVA858.png" alt="CgotOV13WuSAPm_PAAJ2eEQkqVA858.png">

</figure>

<p>
那么，既然 CAP 原理说数据的一致性、可用性和分区耐受性是无法同时满足的，而可用性和分区耐受性我们通常又是不得不保证的。那么更多的时候，我们通过解决一致性的问题，来实现分布式系统。
</p>
</div>
</div>
<div id="outline-container-h:c7eb2483-54a5-471f-91d9-905b27ff939d" class="outline-4">
<h4 id="h:c7eb2483-54a5-471f-91d9-905b27ff939d">一致性冲突解决方案</h4>
<div class="outline-text-4" id="text-h:c7eb2483-54a5-471f-91d9-905b27ff939d">
<p>
解决一致性冲突的方案就是实现 <code>最终一致性</code> 。一致性是说，在任何时间，数据的多个备份存储都是一致的。而最终一致是说，在一个分布式系统中，在某个时候，不同服务器上存储的同一个数据可能是不一致的，但是它最终还是一致的，只要不一致的时间不影响应用程序的正确性，我们就是可以接受的，这种一致性叫作最终一致性。
</p>

<p>
比如说，如下图，客户端 A 连接到服务器 1，客户端 C 连接到服务器 2，客户端 A 对数据作出变更操作，服务器 1 将变更扩散到服务器 2，那么，客户端 C 连接到服务器 2 的时候，可能不会立即得到最新的数据，但是过一会儿，等变更扩散完成了，就可以获得最新的数据了。
</p>


<figure id="org6e2b843">
<img src="./images/CgotOV13Wu6AaG3jAALIUgL6dlE525.png" alt="CgotOV13Wu6AaG3jAALIUgL6dlE525.png">

</figure>

<p>
<b>当数据在写的过程中多个数据备份有冲突的时候，如何解决呢？</b>
</p>

<p>
一种方法是根据 <code>时间戳</code> 进行判断。最后写入的，也就是时间戳在后面的，覆盖时间戳在前面的。在下图例子中，两个客户端连接到不同的服务器节点，对同一个数据做更新操作。那么，在数据复制的时候就会出现数据冲突，这个时候解决冲突的办法就是根据时间戳进行判断，时间戳大的，也就是说最新的数据，覆盖时间戳小的、旧的数据。
</p>


<figure id="orgc93c73e">
<img src="./images/CgotOV13Hs-Ad34IAAH2XLaPnyk947.png" alt="CgotOV13Hs-Ad34IAAH2XLaPnyk947.png">

</figure>

<p>
另一种解决冲突的机制是通过 <code>客户端</code> 进行冲突解决。在下图例子中，客户端 1 保存用户购物车编号，用户 123 的购物车编号是 55，客户端 2 保存用户 123 购车编号是 70。当客户端 3 去获取用户 123 的购物车编号时，它就得到了两个编号的购物车。解决办法就是将这两个购物车进行合并，合并成一个购物车，并且把它重新写入到分步式存储集群中。
</p>


<figure id="org5a98a8f">
<img src="./images/CgoB5l13HtCAPTFQAAJUAwtt4uY430.png" alt="CgoB5l13HtCAPTFQAAJUAwtt4uY430.png">

</figure>

<p>
还有一种冲突的解决方案是通过 <code>投票</code> 进行解决。典型的就是 <code>Cassandra</code> 中的冲突解决机制。如下图所示，一个客户端向一个分布式集群中写入数据的时候，它会同时向 3 个节点写入数据，并且至少等待两个节点响应写入成功。而另一个客户端想要读取这个数据的时候，至少要从 3 个节点中去读取数据，并且至少有 2 个节点有返回，然后根据返回的节点数进行投票，获取最新版本的数据。
</p>


<figure id="org4296d25">
<img src="./images/CgoB5l13W1WAT5WIAAK-aY2RDbQ691.png" alt="CgoB5l13W1WAT5WIAAK-aY2RDbQ691.png">

</figure>
</div>
</div>
</div>
<div id="outline-container-h:a1353c67-ba2d-401e-a01f-12cae46fe8d3" class="outline-3">
<h3 id="h:a1353c67-ba2d-401e-a01f-12cae46fe8d3">总结回顾</h3>
<div class="outline-text-3" id="text-h:a1353c67-ba2d-401e-a01f-12cae46fe8d3">
<pre class="example" id="org236ea46">
数据库复制--&gt;提升性能与可用性--&gt;数据分片--&gt;数据库部署
--&gt;NoSQL--&gt;CAP 与最终一致性--&gt;一致性冲突解决方案
</pre>

<p>
分布式数据库和分布式存储是分布式系统中难度最大、挑战最大，也是最容易出问题的地方。解决的办法主要是数据库的复制，通过数据库的复制，提升数据库的读性能和系统的可用性。
</p>

<p>
如果对数据存储和数据库的写操作有更高要求的时候，就需要通过数据分片的方式来实现。在具体的部署过程中，可以混合使用数据复制、数据分库和数据分片几种技术方案。如果你的应用不是非要使用关系数据库的话，你还可以选择 NoSQL 数据库，NoSQL 数据库会提供更强大的数据存储能力和并发读写能力，但是 NoSQL 数据库因为 CAP 原理的约束可能会遇到数据不一致的问题。数据不一致的问题，可以通过时间戳合并、客户端判断以及投票这样的几种机制解决，实现最终一致性。
</p>

<p>
下一章节的主题是分布式微服务架构。
</p>
</div>
</div>
</section>
<section id="outline-container-h:8d9841ab-4901-4093-b73b-d188932a67a9" class="outline-2">
<h2 id="h:8d9841ab-4901-4093-b73b-d188932a67a9">第05讲：架构核心技术之微服务</h2>
<div class="outline-text-2" id="text-h:8d9841ab-4901-4093-b73b-d188932a67a9">
<form><input type="button" value="音频" onclick="doSound(5); return false;"></form>
<span id="dummy5"></span>

<blockquote>
<ol class="org-ol">
<li>单体应用的挑战</li>
<li>分布式微服务框架设计</li>
<li>微服务最佳实</li>
</ol>
</blockquote>

<p>
本章节我们来学习微服务。
</p>


<figure id="orgf591313">
<img src="./images/CgoB5l13JL6AA3PDAAJgEBDy948831.png" alt="CgoB5l13JL6AA3PDAAJgEBDy948831.png">

</figure>

<p>
本章节主要包括如下内容。
</p>

<ul class="org-ul">
<li>单体系统的困难：编译部署困难、数据库连接耗尽、服务复用困难、新增业务困难。</li>

<li>微服务框架：Dubbo 和 Spring Cloud，微服务的架构策略。</li>

<li>微服务模式：事件溯源、查询与命令职责分离 CQRS、断路器、超时。</li>

<li>微服务最佳实践。</li>
</ul>
</div>
<div id="outline-container-h:9c175ec2-ba65-4b12-bb20-02ccc3affe92" class="outline-3">
<h3 id="h:9c175ec2-ba65-4b12-bb20-02ccc3affe92">单体系统的困难</h3>
<div class="outline-text-3" id="text-h:9c175ec2-ba65-4b12-bb20-02ccc3affe92">
<blockquote>
<ol class="org-ol">
<li>编译、部署困难</li>
<li>新增业务困难</li>
<li>代码分支管理困难</li>
<li>发布困难</li>
<li>数据库连接耗尽</li>
</ol>
</blockquote>

<p>
在微服务出现之前，互联网应用系统主要是单体系统，也就是说一个网站的整个系统由一个应用构成。如果是 Java，就打包成一个 war 包，一个 war 包包含整个应用系统，系统更新的时候，即使只是更新其中极小的一部分，也要重新打包整个 war 包，发布整个系统。
</p>

<p>
这样的单体系统面临的挑战主要是什么呢？
</p>
</div>
<div id="outline-container-h:342ed803-a80c-477c-89a8-3800d7622ef5" class="outline-4">
<h4 id="h:342ed803-a80c-477c-89a8-3800d7622ef5"><b>编译、部署困难</b></h4>
<div class="outline-text-4" id="text-h:342ed803-a80c-477c-89a8-3800d7622ef5">
<p>
随着网站的业务不断发展，系统会变得越来越庞大，最后变成一个 <code>巨无霸的系统</code> 。
</p>

<p>
如果单个应用有几个 G 大，这对于网站开发工程师来说，开发编译和部署都是非常困难的。在开发的过程中，即使只改了庞大系统中的一行代码，也必须把完整的网站系统重新打包，才能做测试。这会经历漫长的编译过程：出去抽一支烟回来一看，在编译；又去喝了一杯水回来，还在编译；再去趟厕所，回来还在编译。好不容易编译结束了，如果某个配置项错误导致编译失败，又得重来一次，浪费大半天的时间。这样的单体系统对于开发部署和测试都是非常困难的。
</p>
</div>
</div>
<div id="outline-container-h:68c974ed-938f-4a3e-aca5-ba1e1579ff5f" class="outline-4">
<h4 id="h:68c974ed-938f-4a3e-aca5-ba1e1579ff5f">代码分支管理困难</h4>
<div class="outline-text-4" id="text-h:68c974ed-938f-4a3e-aca5-ba1e1579ff5f">
<p>
因为单体应用非常庞大，所以代码模块也是由多个团队共同维护的。但最后还是要编译成一个单体应用，统一发布。这就要求把各个团队的代码 merge 在一起，这个过程很容易发生代码冲突。而 merge 的时候又是网站要进行发布的时候，发布过程本来就复杂，再加上代码 merge 带来的问题，各种情况纠缠在一起，极易出错。所以，在单体应用时代每一次网站发布都需要搞到深更半夜。
</p>
</div>
</div>
<div id="outline-container-h:1332f3d4-6c12-458a-9bea-01abb5c04680" class="outline-4">
<h4 id="h:1332f3d4-6c12-458a-9bea-01abb5c04680">数据库连接耗尽</h4>
<div class="outline-text-4" id="text-h:1332f3d4-6c12-458a-9bea-01abb5c04680">
<p>
对于一个巨型的应用而言。因为有大量的用户进行访问，所以必须把应用部署到大规模的服务器集群上。然后每个应用都需要与数据库建立连接，大量的应用服务器连接到数据库，会对数据库的连接产生巨大的压力，某些情况下甚至会耗尽数据库的连接。
</p>
</div>
</div>
<div id="outline-container-h:a34de140-423b-4adb-8294-d2bb0146f19c" class="outline-4">
<h4 id="h:a34de140-423b-4adb-8294-d2bb0146f19c">新增业务困难</h4>
<div class="outline-text-4" id="text-h:a34de140-423b-4adb-8294-d2bb0146f19c">
<p>
巨无霸单体应用的另一个挑战是新增业务困难。因为所有的业务都耦合在一个单一的大系统里，通常随着时间的发展，这个系统会变得非常的复杂，里面的各种结构也非常乱，想要维护这样一个系统是非常困难和复杂的。很多工程师入职公司半年，都还不能熟悉业务，因为业务太过庞大和复杂，经常会出各种错误。所以就会出现这种现象：熟悉系统的老员们工忙得要死，加班加点干活，不熟悉系统的新员工们一帮忙就出乱，跟着加班加点干活。整个公司热火朝天地干活，但最后还是常常出故障，新的功能迟迟不能上线。
</p>
</div>
</div>
<div id="outline-container-h:30acd41e-9f9f-4f66-8c5a-8c9824cb6384" class="outline-4">
<h4 id="h:30acd41e-9f9f-4f66-8c5a-8c9824cb6384">发布困难</h4>
<div class="outline-text-4" id="text-h:30acd41e-9f9f-4f66-8c5a-8c9824cb6384">
<p>
因为一个 war 包包含了所有的代码，进行新版本发布的时候，发布代码跟自己的开发的代码一点关系没有，但是因为 war 包包含了自己的代码，为了以防万一，也不得不跟着发布值班。结果真正更新代码功能的只有几个人，而整个部门都要跟着加班。常常出现，到了深夜，有代码更新的同事汗流浃背进行代码冲突处理和修复发布 bug，没有代码更新的同事陪着聊天、打瞌睡、打游戏，这种情况。
</p>
</div>
</div>
</div>
<div id="outline-container-h:f5684cbb-bf4c-489a-8725-bb8574dbfda7" class="outline-3">
<h3 id="h:f5684cbb-bf4c-489a-8725-bb8574dbfda7">微服务架构</h3>
<div class="outline-text-3" id="text-h:f5684cbb-bf4c-489a-8725-bb8574dbfda7">
<p>
解决上述问题的主要手段是将一个单体的巨无霸系统， <code>根据模块以及复用的粒度进行拆分</code> ，拆分成多个可以独立部署的分布式服务。 <code>应用通过远程访问调用</code> 的方式，使用这些服务，构成一个系统。但是由于它的核心服务是在其他的服务器上分布部署的，本身的业务逻辑可以变得比较简单，这样就把一个巨无霸系统单体应用拆成了若干个可复用的服务，利用较少的逻辑代码就可以组成一个应用系统。
</p>

<p>
<b>SOA 架构</b>
</p>

<p>
这样的设计思路其实并不是在互联网时代才出现的。在早期的时候，就有人提出了 SOA 面向服务的体系架构。如下图所示，在面向服务的体系架构里面，服务的提供者向注册中心注册自己的服务，而服务的使用者向注册中心去发现服务。发现服务以后，根据服务注册中心提供的访问接口和访问路径对服务发起请求，由服务的提供者完成请求返回结果给调用者。现在的微服务或者分布式服务，其实也是 SOA 架构的一种实现。但是在早期的 SOA 架构实践中，服务的注册与服务的调用都非常复杂，服务调用效率也比较低。
</p>


<figure id="orge8057e8">
<img src="./images/CgoB5l13XFuAJnqQAAGRIgov63M066.png" alt="CgoB5l13XFuAJnqQAAGRIgov63M066.png">

</figure>

<p>
<b>微服务架构</b>
</p>

<p>
后来在互联网时代的微服务中，人们简化了 SOA 架构中的调用规范和服务规范，形成了我们现在所熟悉的分布式微服务架构。
</p>

<p>
如下图，所谓的 <code>微服务架构就是将一个单体的巨无霸系统拆分成一组可复用的服务，基于这些服务构成的应用系统</code> 。图中左边是早期的单体应用系统架构，里面的各个模块互相调用、耦合，所有的系统和模块打包在一起，最后组成一个庞大的巨无霸系统。右边是微服务架构，根据服务的粒度和可复用的级别，对服务进行拆分，以独立部署服务的方式，对外提供服务调用。而应用系统也按照用途和场景的不同，依赖这些可复用的服务，进行逻辑组合，构建成自己的业务系统。
</p>


<figure id="orgb1945a0">
<img src="./images/CgotOV13JL6AQIB7AAQuqpCR5Ns064.png" alt="CgotOV13JL6AQIB7AAQuqpCR5Ns064.png">

</figure>

<p>
通过这样一种方式，系统变得比较简单，复用级别也比较高，同时也解决了前面提出的单体巨无霸的几个重要问题。因为每一个服务或是应用系统，代码都比较简单，所以编译和部署、开发和测试，都比较简单和快速。而且这些服务都是独立维护和部署的，它的代码分支也是独立的，不会和其他的代码分支一起进行管理，减少了代码冲突的可能性。发布的时候，也是每个服务独立发布，只要做好服务的版本控制和接口兼容，应用系统不需要跟随服务一起更新发布。
</p>

<p>
在微服务体系中，连接数据库的是具体的服务，应用系统不需要自己去连接数据库，只需要调用组合服务，对服务进行编排。所以对数据库的连接也相对比以前更少一些。最主要的是当需要开发新业务的时候，使用这种方式不需要对原有的单体系统进行各种重构和代码修改，只需要开发一个新的业务系统，组合调用现有的微服务，就可以组合出来一个新的产品功能，可以快速开发新产品。
</p>
</div>
<div id="outline-container-h:86d74b6a-627a-46d7-9997-66a215cc481f" class="outline-4">
<h4 id="h:86d74b6a-627a-46d7-9997-66a215cc481f">微服务架构-Dubbo</h4>
<div class="outline-text-4" id="text-h:86d74b6a-627a-46d7-9997-66a215cc481f">
<p>
目前一些典型的微服务框架本身的架构是如何设计的？
</p>

<p>
先看 Dubbo 架构。Dubbo 是阿里开源的，比较早也比较有影响力的一个分布式微服务框架。如下图所示，在 Dubbo 架构中，最核心的模块有 3 个部分，一个是服务的提供者，一个是服务的消费者，还有一个是服务的注册中心。
</p>


<figure id="org7a9b0a0">
<img src="./images/CgoB5l13JL6AOLBoAAFOGse3TxA656.png" alt="CgoB5l13JL6AOLBoAAFOGse3TxA656.png">

</figure>

<p>
服务的提供者顾名思义就是微服务的具体提供者，通过微服务容器对外提供服务。而服务的消费者就是应用系统或是其他的微服务。
</p>

<p>
应用系统通过组合多个微服务，构成自己的业务逻辑，实现自己的产品功能。具体过程是服务的提供者程序在 Dubbo 的服务容器中启动，服务管理容器向服务注册中心进行注册，声明服务提供者所要提供的接口参数和规范，并且注册自己所在服务器的 IP 地址和端口，如下图所示。
</p>

<p>
而服务的消费者如果想要调用某个服务，只需依赖服务提供者的接口进行编程。而服务接口通过 Dubbo 框架的代理访问机制，调用 Dubbo 的服务框架客户端，服务框架客户端会根据服务接口声明，去注册中心查找对应的服务提供者启动在哪些服务器上，并且将这个服务器列表返回给客户端。客户端根据某种负载均衡策略，选择某一个服务器通过远程通讯模块发送具体的服务调用请求。
</p>

<p>
服务调用请求，通过 Dubbo 底层自己的远程通讯模块，也就是 RPC 调用方式，将请求发送到服务的提供者服务器，服务提供者服务器收到请求以后，将该请求发送给服务提供者程序，完成服务的执行，并将服务执行处理结果通过远程调用通讯模块 RPC 返回给服务消费者客户端，服务消费者客户端将结果返回给服务调用程序，从而完成远程服务的调用，获得服务处理的结果。
</p>

<p>
Dubbo 使用 Java 进行开发，并且通过服务接口的方式对消费者提供服务，所以它的服务调用方式比较简单，可以透明地进行远程微服务调用。服务消费者程序，可以无感知地进行远程微服务调用，对开发者相对比较友好。
</p>
</div>
</div>
<div id="outline-container-h:79c4a87a-0f0b-4b2f-b5af-120d1f584e6d" class="outline-4">
<h4 id="h:79c4a87a-0f0b-4b2f-b5af-120d1f584e6d">微服务框架-Spring Cloud</h4>
<div class="outline-text-4" id="text-h:79c4a87a-0f0b-4b2f-b5af-120d1f584e6d">
<p>
另一种目前比较热门的微服务框架是 Spring Cloud。Spring Cloud 微服务框架组件跟 Dubbo 类似，也是由服务的消费者、服务的提供者和注册中心组成。如下图所示，Spring cloud 的服务提供者通过 Spring Boot 启动，然后向服务注册中心 Eureka Server 进行注册，而服务的消费者通过一个 Zuul 网关访问 Eureka Server 进行服务的发现，获得自己想要调用的远程服务对应的服务地址。获得地址以后，通过 HTTP 的方式向远程的服务提供者发起调用请求。服务提供者完成服务处理后，将处理结果通过 HTTP 返回。从而实现了远程的微服务调用。
</p>


<figure id="orgca27831">
<img src="./images/CgoB5l13XGWAObX2AAO4kBq0A-0497.png" alt="CgoB5l13XGWAObX2AAO4kBq0A-0497.png">

</figure>


<p>
Spring Cloud 还包含了一组服务调用监控组件，主要是 Hystrix，通过 Hystrix 可以监控服务调用，还在此基础上实现了熔断、降级、超时管理等一系列高可用策略。
</p>
</div>
</div>
<div id="outline-container-h:65af7d05-7abf-46e0-9cb3-548ea1da43ac" class="outline-4">
<h4 id="h:65af7d05-7abf-46e0-9cb3-548ea1da43ac">微服务架构策略</h4>
<div class="outline-text-4" id="text-h:65af7d05-7abf-46e0-9cb3-548ea1da43ac">
<p>
对微服务架构而言，技术现在其实比较成熟。使用什么样的技术去实现一个微服务，本身并没有太多的困难。构建一个微服务架构最困难的还是服务治理，也就是业务划分。策略要点如下所示。
</p>

<blockquote>
<ul class="org-ul">
<li>业务先行，先理顺业务边界和依赖，技术是手段而不是目的</li>
<li>先有独立的模块，后有分布式服务</li>
<li>业务耦合严重，逻辑复杂多变的系统进行微服务重构要谨慎</li>
<li>要搞清楚实施微服务的目的是什么？业务复用？开发边界清晰？分布式集群提升性能？</li>
</ul>
</blockquote>

<p>
一个微服务包含的功能有哪些？服务的边界是什么？服务之间的依赖关系如何？这些关键的问题决定了服务的复用程度，维护的难易程度，开发的便利程度。所以设计微服务架构的时候，首先要关注的是业务，业务要先行，理顺业务模块之间的边界和依赖，做好服务治理和调用依赖管理。
</p>

<p>
微服务技术是微服务架构的手段，而不是目的。微服务最主要的目的还是实现 <code>服务治理------如何划分和管理服务</code> 。首先要有独立的功能模块，然后才有分布式的服务。也就是说在软件设计的时候，软件功能模块之间的依赖关系就要清晰、合理、规范、便于维护、便于扩展，便于实现新的功能。服务之间的依赖关系要清晰、参数要简单、耦合关系要少。设计好这样的模块化结构以后，将这些设计好的模块，拆分成独立的微服务进行部署和调用，就可以构建一个良好的微服务系统。如果模块本身就是混乱的、耦合严重的、边界不清晰的、关系复杂的，那么，把它们拆分成独立的微服务进行部署，只会使事情变得更加复杂。
</p>

<p>
所以进行微服务架构设计之初，就要先做好业务模块的设计和规划。同时，对于那些业务耦合比较严重、逻辑复杂多变的系统，进行微服务重构的时候，也要特别谨慎。如果做不好模块的划分和耦合管理。那么，宁可晚一点进行微服务架构重构，也不要仓促上马，以免最后带来巨大的损失。要使用微服务架构的时候，一定要搞清楚实施微服务的目的究竟是什么，是为了业务复用，是为了开发边界清晰，是为了分布式集群提升性能，还是仅仅想要使用微服务？目的一定要清楚。
</p>

<p>
跟其他技术不同，微服务具有强业务属性，业务如果本身结构混乱，目标不清晰，仓促使用微服务，可能会使整个系统变得更加复杂和难以控制。所以在使用微服务前，最重要的是要先明确自己的需求：我们到底想用微服务达到什么样的目的？需求清晰了，再去考虑具体的方案和技术。这也是使用大多数技术的时候应有的方法和思路。
</p>

<p>
最重要的是要求
</p>
<pre class="example" id="orgc3e7e84">
#倒金字塔
需求
价值
原则
实践
工具
</pre>

<p>
如上所示，最重要的是需求。在日常工作中，我们要根据需求去考虑具体的价值，再根据价值构建我们的设计原则，根据原则寻找最佳实践，最后根据实践去选择最合适的工具。按这样的方式去选择技术做架构设计才是比较成熟和高效的。如果相反，先找到一个工具，然后用工具硬往上套需求，只会导致技术也没用好，业务也没做好，所有人都疲惫不堪，事情变得一团糟，最后还可能反过来怪技术没用。
</p>
</div>
</div>
</div>
<div id="outline-container-h:4898f728-3d2d-46a9-8251-e2caa50cf83a" class="outline-3">
<h3 id="h:4898f728-3d2d-46a9-8251-e2caa50cf83a">微服务的使用模式</h3>
<div class="outline-text-3" id="text-h:4898f728-3d2d-46a9-8251-e2caa50cf83a">
<blockquote>
<ul class="org-ul">
<li>概念：将用户请求处理过程中的每次状态变化都记录到事件日志中，并按时间序列进行持久化存储</li>
<li>作用：
<ul class="org-ul">
<li>利用事件溯源，可以精确复现任何用户状态，进行复核审计</li>
<li>利用事件溯源，可以有效监控用户状态变化，并在此基础上实现分布式事</li>
</ul></li>
</ul>
</blockquote>

<p>
下面来看可供参考的几种微服务的使用模式。
</p>
</div>
<div id="outline-container-h:f01ee855-b3bb-4649-8dac-be0064052f53" class="outline-4">
<h4 id="h:f01ee855-b3bb-4649-8dac-be0064052f53">事件溯源</h4>
<div class="outline-text-4" id="text-h:f01ee855-b3bb-4649-8dac-be0064052f53">
<p>
第一是事件溯源，因为微服务的调用过程会比较复杂，调用链路可能会比较长。如果某个微服务调用出错，如何进行管理和监控？使用事件溯源这种模式是一种解决办法。
</p>

<p>
所谓的事件溯源是指 <code>将用户的请求处理过程，每一次的状态变化都记录到事件日志中，并按照时间序列进行持久化的存储</code> ，也就是说，把所有的变更操作都按日志的方式，按时间化序列进行记录。
</p>

<p>
使用事件溯源的好处有如下两点。
</p>

<ul class="org-ul">
<li><p>
可以精确地复现用户的状态变化。
</p>

<p>
用户执行了哪些操作，使它成为现在这样一种状况，然后通过事件溯源的方式，
追溯以往的操作和动作，从而 <code>进行复核和审计</code> 。当用户投诉的时候，当状
态不一致的时候，可以通过事件溯源中的日志进行审计和查找。
</p></li>

<li><p>
可以有效监控用户的状态变化，并在此基础上实现分布式的事务。
</p>

<p>
我们传统的事务使用数据库事务进行实现，可以将多个数据库操作统一提交，
或者统一回滚，保持数据的一致性，但是在分布式状况下，对数据的操作是分
布在多个独立部署的服务进行处理。这个时候就无法使用数据库的事务进行管
理。
</p></li>
</ul>

<p>
那么，如何在这种情况下实行分布式系统的事务？
</p>

<p>
事件溯源是一种办法。因为事件溯源将所有的数据变更都按日志的方式记录起来，所以如果日志不完整，我们就知道事务不完整，可以对事务进行重组或者补偿操作，从而使数据变得一致。
</p>
</div>
</div>
<div id="outline-container-h:dbc222bc-ab1b-46bf-8bbf-2673ec1b26d5" class="outline-4">
<h4 id="h:dbc222bc-ab1b-46bf-8bbf-2673ec1b26d5">命令与查询职责隔离（CQRS）</h4>
<div class="outline-text-4" id="text-h:dbc222bc-ab1b-46bf-8bbf-2673ec1b26d5">
<blockquote>
<p>
概念：
</p>
<ul class="org-ul">
<li>在服务接口层面将查询（读操作）与命令（写操作）隔离，服务层的读写分离</li>
</ul>

<p>
作用：
</p>
<ul class="org-ul">
<li>更清晰的领域模型</li>
<li>针对读写分别化，实现更好的性能</li>
<li>查询服务不会修改数据，更好地保护数据</li>
</ul>
</blockquote>

<p>
这种模式在服务接口层面将查询操作（也就是读操作）和命令操作（也就是写操作）隔离开来，在服务层实现读写分离。
</p>

<p>
使用 CQRS 模式，主要的好处是可以有更清晰的领域模型，根据操作的方式不同，使用不同的领域模型。还可以分别进行读写优化，从而实现更好的性能。
</p>

<p>
我们知道在读操作中主要使用的优化方式是缓存操作。那么，我们可以将接口层面的查询操作即读操作，尽量多地通过缓存来返回。而写操作也就是命令操作，主要的性能优化方式是使用消息队列。那么，我们可以将数据的更新操作，尽量通过消息队列，通过异步化的方式进行处理，以改善性能。
</p>

<p>
因为使用 CQRS 查询和命令分离的方式，我们可以在接口层面上使用不同的优化手段。查询操作不会修改数据库，那么所有来自于查询接口的服务，可以统一连接到只读数据库中，防止误操作破坏数据，可以更好地保护数据，同时使用 CQRS，还可以更好地实现刚才的事件溯源机制。因为查询操作是无须进行事件溯源的，所有的事件溯源都可以统一设置在命令服务接口上。
</p>
</div>
</div>
<div id="outline-container-h:11cd98ba-9857-4943-8beb-c120660fc7ed" class="outline-4">
<h4 id="h:11cd98ba-9857-4943-8beb-c120660fc7ed">断路器</h4>
<div class="outline-text-4" id="text-h:11cd98ba-9857-4943-8beb-c120660fc7ed">
<blockquote>
<p>
概念：
</p>
<ul class="org-ul">
<li>当某个服务出现故障，响应延迟或者失败率增加，继续调用这个服务实例会导
致请求者阻塞，资源消耗增加，进而出现服务的级联失效，这种情况下使用断
路器阻断对故障服务的调用。</li>
</ul>

<p>
实现：
</p>
<ul class="org-ul">
<li>三种状态：关闭、打开、半开</li>
<li>Spring Cloud 断路器实现：Hystrix</li>
</ul>
</blockquote>

<p>
使用微服务的时候，你还需要关注一个事情：服务的不可用。
</p>

<p>
当某个服务实例出现故障的时候，它的响应延迟或者失败率增加的时候，继续调用这个服务实例会导致请求者阻塞。请求阻塞以后会导致资源消耗增加，最后可能会导致请求者也失败和崩溃，进而出现服务的级联崩溃，也就是服务请求者的请求者也失败，最后会导致整个系统全部失败，即雪崩现象。
</p>

<p>
在这种情况下，可以使用断路器对故障服务进行隔离。断路器有三种状态：关闭、打开、半开。当服务出现故障的时候，通过断路器阻断对故障服务实例的调用，避免它的故障扩散开来。在
Spring Cloud 中可以使用 Hystrix 实现断路器。
</p>
</div>
</div>
<div id="outline-container-h:16d9be04-e99b-41e8-9b2b-5caacd6d187c" class="outline-4">
<h4 id="h:16d9be04-e99b-41e8-9b2b-5caacd6d187c">超时</h4>
<div class="outline-text-4" id="text-h:16d9be04-e99b-41e8-9b2b-5caacd6d187c">
<p>
还有一件需要关注的事情是：微服务调用的超时机制如何设置。
</p>

<p>
如果使用统一的超时设置，那么当下游调用者超时的时候，上游调用者一定也已经超时了，因为服务调用是阻塞的。所以，下游调用的超时一定会反应在上游调用者上。因此在设置超时的时候，要设置上游调用者的超时时间大于下游调用者的超时时间之和，相同的超时设置是没有意义的，如下图所示。
</p>


<figure id="org9c105ca">
<img src="./images/CgoB5l13TbyALL87AABEVzYnfn8013.png" alt="CgoB5l13TbyALL87AABEVzYnfn8013.png"> 

</figure>
</div>
</div>
</div>
<div id="outline-container-h:cbed1d17-268c-402c-bf13-c3cd5e4b9ebc" class="outline-3">
<h3 id="h:cbed1d17-268c-402c-bf13-c3cd5e4b9ebc">总结回顾</h3>
<div class="outline-text-3" id="text-h:cbed1d17-268c-402c-bf13-c3cd5e4b9ebc">
<pre class="example" id="orgb5d6faf">
单体系统的困难--&gt;微服务架构--&gt;分布式服务框架--&gt;业务驱动模块化--&gt;微服务最佳实践
</pre>

<p>
首先，之所以要使用微服务，是因为传统的单体巨无霸系统带来的挑战和困难，包括编译和部署的困难、连接的困难、打包代码冲突的困难，以及复用的困难、新增业务的困难。
</p>

<p>
而具体的微服务框架基本上都是由三个核心部分组成的：服务的提供者、服务的调用者和服务的注册中心。服务的提供者向注册中心注册自己的服务，而服务的调用者通过注册中心发现服务，并进行远程调用。
</p>

<p>
另外，很多微服务架构中还包括一个监控者的角色，通过监控者进行服务的管理和流量的控制。
</p>

<p>
使用微服务最重要的是做好业务的模块化设计，模块之间要低耦合，高聚合，模块之间的依赖关系要清晰简单。只有这样的模块化设计，才能够构建出良好的微服务架构。如果系统本身就是一团遭，强行将它们拆分在不同的微服务里，只会使系统变得更加混乱。
</p>

<p>
使用微服务的时候，有几个重要的使用模式，需要关注：一个是事件溯源，一个是命令与查询隔离，还有一个是断路器以及关于超时如何进行设置。
</p>
</div>
</div>
</section>
<section id="outline-container-h:28383032-6446-4e00-8b3e-be747cb50e66" class="outline-2">
<h2 id="h:28383032-6446-4e00-8b3e-be747cb50e66">第06讲：高性能系统架构设计</h2>
<div class="outline-text-2" id="text-h:28383032-6446-4e00-8b3e-be747cb50e66">
<form><input type="button" value="音频" onclick="doSound(6); return false;"></form>
<span id="dummy6"></span>

<blockquote>
<ol class="org-ol">
<li>系统性能测试</li>
<li>系统性能优化的分层思想</li>
</ol>
</blockquote>

<p>
本章节讲解大家常听到的高性能系统架构。
</p>

<p>
高性能系统架构，主要包括两部分内容，性能测试与性能优化。性能优化又可以细分为硬件优化、中间件优化、架构优化及代码优化，知识架构图如下。
</p>


<figure id="orgc25ebc9">
<img src="./images/CgoB5l142FGAao36AARTQx90mWg993.png" alt="CgoB5l142FGAao36AARTQx90mWg993.png">

</figure>

<ul class="org-ul">
<li>性能测试
<ul class="org-ul">
<li>性能指标</li>
<li>测试方法</li>
<li>性能曲线</li>
</ul></li>
<li>性能优化 
<ul class="org-ul">
<li>硬件优化
<ul class="org-ul">
<li>机房与骨干网络优化</li>
<li>服务器与硬件配置优化</li>
</ul></li>
<li>中间件优化
<ul class="org-ul">
<li>操作系统优化</li>
<li>虚拟机优化</li>
<li>基础组件优化</li>
</ul></li>
<li>架构优化
<ul class="org-ul">
<li>缓存</li>
<li>集群</li>
<li>异步</li>
</ul></li>
<li>代码优化
<ul class="org-ul">
<li>多线程</li>
<li>数据结构</li>
<li>设计模式</li>
<li>资源复用</li>
</ul></li>
</ul></li>
</ul>
</div>
<div id="outline-container-h:3ce26044-80f1-4722-ac18-3f4fc84be540" class="outline-3">
<h3 id="h:3ce26044-80f1-4722-ac18-3f4fc84be540">系统性能测试</h3>
<div class="outline-text-3" id="text-h:3ce26044-80f1-4722-ac18-3f4fc84be540">
<blockquote>
<p>
你不能优化一个未经测试的系统  &lt;&#x2013; 性能测试是性能优化的前提和基础，也是
性能优化结果的检查和度量标准 &#x2014;&gt; 不能优化一个你不了解的系统
</p>
</blockquote>

<p>
先看系统的性能测试。性能测试是性能优化的前提和基础，也是性能优化结果的检查和度量标准。
</p>

<p>
关于性能测试有一句著名的论断，叫作“你不能优化一个你未经测试的系统，你也不能优化一个你不了解的系统”。所以要进行性能优化，首先要进行性能测试，看系统的当前各项性能指标是什么样子的，问题在哪里，从哪些方面进行优化。
</p>

<p>
而具体在优化的时候，又必须要了解系统。系统的架构是什么样子的？系统的关键技术点、瓶颈点在哪里？为何会产生这样的瓶颈点？以及如何对它进行优化？也就是说必须要在了解系统的基础之上才能进行优化。所以性能测试以及了解系统，是性能优化的两个关键前提。
</p>

<p>
关于性能的标准，在不同的视角下，性能的度量标准是不同的，性能优劣也是不同的，性能标准有主观和客观两种视角。
</p>

<ul class="org-ul">
<li>主观标准是说 <code>使用者在体验上的快慢</code> ，用户在使用系统的时候，它主观上感觉
快还是慢，那么就会得到一个性能好还是差的主观标准；</li>

<li>客观标准，也就是在客观上 <code>性能指标到底是好还是差</code> 。</li>
</ul>

<p>
主观标准和客观标准，虽然它们本质上是统一的，但是也并不是完全一致的。比如客观性能指标相同的两个系统，其中一个系统通过页面渲染，通过一些动画提示，通过更良好的用户交互体验，可以使用户主观感觉系统响应更快。而另一个如果没有做任何交互上的设计优化，仅仅是直接向用户输出内容，那么用户可能会感觉等得更久一些，在主观体验上性能也更差一点。
</p>
</div>
</div>
<div id="outline-container-h:c36d91d4-3694-44aa-bc13-cf7c3ee8c765" class="outline-3">
<h3 id="h:c36d91d4-3694-44aa-bc13-cf7c3ee8c765">客观性能指标</h3>
<div class="outline-text-3" id="text-h:c36d91d4-3694-44aa-bc13-cf7c3ee8c765">
<p>
在客观视角上，性能优劣的指标主要有：
</p>
<ul class="org-ul">
<li>响应时间</li>
<li>并发数</li>
<li>吞吐量</li>
<li>性能计数器</li>
</ul>

<p>
这些指标通常也是我们技术上要进行优化的主要指标，后面我们的性能讨论主要是围绕这些客观上的性能指标展开的。
</p>
</div>
<div id="outline-container-h:a968b598-d411-4d19-b7a9-2a22d15d8bda" class="outline-4">
<h4 id="h:a968b598-d411-4d19-b7a9-2a22d15d8bda">响应时间</h4>
<div class="outline-text-4" id="text-h:a968b598-d411-4d19-b7a9-2a22d15d8bda">
<p>
第一重要的就是响应时间。所谓响应时间是指应用系统从发出请求开始到收到最后响应数据所需要的时间。响应时间是系统最重要的性能指标，最直接地反映了系统的快慢。
</p>
</div>
</div>
<div id="outline-container-h:03bcb58b-e30a-4690-8f85-a7a88821c78a" class="outline-4">
<h4 id="h:03bcb58b-e30a-4690-8f85-a7a88821c78a">并发数</h4>
<div class="outline-text-4" id="text-h:03bcb58b-e30a-4690-8f85-a7a88821c78a">
<p>
第二个指标是并发数。并发数是 <code>指系统同时处理的请求数</code> ，这个数字反映了系统的负载特性。对于互联网系统而言，并发数就是同时访问系统的用户数，也就是指同时提交请求的用户数目。和并发用户数相对应的还有在线用户数，也就是当前登录系统在使用系统的用户数，当前登录系统在使用系统的用户数并不是并发用户数，因为登录系统在使用的时候，它可能在查看页面内容，在填写页面信息，这个时候只要不提交请求，虽然它当前在系统上是在线的，但是它并不是并发用户数，而是在线用户数。另外，还有系统总用户数，指可能访问系统的总用户数。一般说来，系统的总用户数远大于在线用户数，在线用户数远大于并发用户数， <code>对系统性能产生影响的主要是并发用户数</code> 。
</p>
</div>
</div>
<div id="outline-container-h:21802ea6-5b0e-4dd8-b32c-5f8968e83898" class="outline-4">
<h4 id="h:21802ea6-5b0e-4dd8-b32c-5f8968e83898">吞吐量</h4>
<div class="outline-text-4" id="text-h:21802ea6-5b0e-4dd8-b32c-5f8968e83898">
<p>
另一个性能指标是吞吐量。吞吐量是 <code>指单位时间内系统处理请求的数量</code> ，体现的是系统的处理能力。我们一般用每秒的请求数、每秒的事务数这样的一些指标来衡量，也就是 <code>HPS</code> 、 <code>TPS</code> 这些，HPS
是每秒的 HTTP
数目，TPS 是每秒事务数。还可以用 <code>QPS</code> ，即每秒的查询数来表示，总之，就是单位时间内处理的请求数目。
</p>

<p>
吞吐量、响应时间和并发数三者之间是有关联性的，响应时间足够快，那么单位时间的吞吐量也会相应的提高。比如说响应时间如果是 100ms，对于一个并发用户，并发数是 1，那么 TPS 就可以是 10。如果响应时间是 500ms，用户并发数还是 1，那么 TPS 吞吐量就变成了 2。
</p>
</div>
</div>
<div id="outline-container-h:c04a0225-0e44-48f7-9484-589e96082504" class="outline-4">
<h4 id="h:c04a0225-0e44-48f7-9484-589e96082504">性能计数器</h4>
<div class="outline-text-4" id="text-h:c04a0225-0e44-48f7-9484-589e96082504">
<p>
最后一个性能指标是性能计数器。指的是 <code>服务器或者操作系统性能的一些指标数据</code> ，包括系统负载 System Load、对象和线程数、内存使用、CPU 使用、磁盘和网络 I/O 使用等指标。这些指标是系统监控的重要参数，反映系统负载和处理能力的一些关键指标，通常这些指标和性能是强相关的。这些指标很高，成为瓶颈，通常也预示着性能可能会出现问题。在实践中会对这些性能指标设置一些报警的阈值。当监控系统发现性能计数器超过阈值的时候，就会向运维和开发人员报警，以便及时发现、处理系统的性能问题。
</p>
</div>
</div>
</div>
<div id="outline-container-h:d2ddf5c0-ec56-43a0-93f0-1eade9275922" class="outline-3">
<h3 id="h:d2ddf5c0-ec56-43a0-93f0-1eade9275922">性能测试方法</h3>
<div class="outline-text-3" id="text-h:d2ddf5c0-ec56-43a0-93f0-1eade9275922">
<p>
再来看性能测试的方法。通常我们说性能测试的时候指的是一个总称，是广义上的性能测试，具体可以分为:
</p>
<ul class="org-ul">
<li>狭义上的性能测试</li>
<li>负载测试</li>
<li>压力测试</li>
<li>稳定性测试</li>
</ul>
</div>
<div id="outline-container-h:0ca09449-c0a2-416c-81e2-0944c8fce72e" class="outline-4">
<h4 id="h:0ca09449-c0a2-416c-81e2-0944c8fce72e">性能测试</h4>
<div class="outline-text-4" id="text-h:0ca09449-c0a2-416c-81e2-0944c8fce72e">
<p>
狭义的性能测试是指以系统设计初期规划的性能指标为 <code>预期目标</code> ，对系统不断施加压力，验证系统在资源可接受的范围内是否达到了性能的预期。所以性能测试主要是测试系统的性能是否达到了设计预期这样一个目标，对系统的压力相对比较小的。
</p>
</div>
</div>
<div id="outline-container-h:4d1a9d9a-52d8-4391-a38c-a438cbb541b1" class="outline-4">
<h4 id="h:4d1a9d9a-52d8-4391-a38c-a438cbb541b1">负载测试</h4>
<div class="outline-text-4" id="text-h:4d1a9d9a-52d8-4391-a38c-a438cbb541b1">
<p>
负载测试，则是对系统不断施加并发请求，增加系统的压力，直到系统的某项或多项指标 <code>达到安全临界值</code> 。比如某种系统资源已经呈现饱和状态，这个时候继续对系统施加压力，系统的处理能力不但不能提高，反而会下降。所以简单说，负载测试是指通过不断施加负载压力，寻找系统最优的处理能力，最好的性能状态，达到最大的性能指标。通常说来，负载测试的结果比性能测试的结果高一点。
</p>
</div>
</div>
<div id="outline-container-h:969bc395-9b34-4045-897a-5f4c3bab94bc" class="outline-4">
<h4 id="h:969bc395-9b34-4045-897a-5f4c3bab94bc">压力测试</h4>
<div class="outline-text-4" id="text-h:969bc395-9b34-4045-897a-5f4c3bab94bc">
<p>
第三个压力测试，是指在超过安全负载的情况下，对系统继续施加压力，直到系统崩溃，或者不再处理任何请求，以此获得系统的最大压力承受能力。压力测试也就是， <code>将系统压崩</code> 溃需要多大的负载压力或者是并发请求压力，测试系统在最坏的情况下可以承受多大的访问压力。
</p>
</div>
</div>
<div id="outline-container-h:a0117191-d25e-4a33-9386-51155b9be0f8" class="outline-4">
<h4 id="h:a0117191-d25e-4a33-9386-51155b9be0f8">稳定性测试</h4>
<div class="outline-text-4" id="text-h:a0117191-d25e-4a33-9386-51155b9be0f8">
<p>
稳定性测试则是指被测试的系统在特定的硬件、软件和网络环境条件下，给系统施加一定的 <code>业务压力</code> ，使系统运行较长一段时间，以此检测系统是否稳定。在生产环境中，请求压力是不均匀的、呈现波浪的特性，因此为了更好地模拟生产环境，稳定性测试也应该不均匀地对系统施加压力，看系统在这种持续的、长时间的、不均匀的访问压力之下，能否稳定地提供响应特性，系统性能是否保持稳定。
</p>
</div>
</div>
</div>
<div id="outline-container-h:629d9fb3-5d03-4617-9c36-c75e253a21a9" class="outline-3">
<h3 id="h:629d9fb3-5d03-4617-9c36-c75e253a21a9">性能特性曲线</h3>
<div class="outline-text-3" id="text-h:629d9fb3-5d03-4617-9c36-c75e253a21a9">
</div>
<div id="outline-container-h:e0442e59-efc8-42f0-b48d-00d2ef9f56af" class="outline-4">
<h4 id="h:e0442e59-efc8-42f0-b48d-00d2ef9f56af">吞吐量特性曲线</h4>
<div class="outline-text-4" id="text-h:e0442e59-efc8-42f0-b48d-00d2ef9f56af">
<p>
前面提到的，性能测试、负载测试和压力测试，它的测试曲线如下图所示。横轴是系统资源或者并发用户数，对于性能测试，系统资源和并发用户数本质上是一样的，因为随着并发用户数的增加，系统资源消耗是线性增加的。纵轴是它的吞吐量 TPS。
</p>


<figure id="org95deb53">
<img src="./images/CgoB5l142FKAS8JDAAA5sOCVW7U667.png" alt="CgoB5l142FKAS8JDAAA5sOCVW7U667.png">

</figure>

<p>
在性能测试阶段，随着并发访问逐渐的增加，系统资源的不断消耗，TPS 是在不断上升的。
</p>

<p>
到了负载测试阶段，这种上升的斜率会变小，直到达到了系统负载能力的最大点，也就是 c 点。而过了 c 点以后继续施加压力，继续提高并发请求的数量，系统资源消耗进一步增加，TPS 吞吐量不增反降，会呈现下降趋势。直到到达了某个点，d 点，系统超过了它的最大承受能力，系统崩溃。
</p>

<p>
压力测试的时候，吞吐量之所以会下降，是因为更多的并发请求、更多的用户请求进入系统以后，系统已经无法正常处理这样多的用户请求，系统的资源消耗情况会更加恶化，系统不能够有效地处理用户的正常请求，却又不得不分配出大量的资源，来调度用户的访问请求。这时候系统资源虽然被更多的消耗，但是响应时间在不断地加长，它的 TPS 在下降。
</p>
</div>
</div>
<div id="outline-container-h:cac7ab51-a9da-47ae-bc90-2a68fadab756" class="outline-4">
<h4 id="h:cac7ab51-a9da-47ae-bc90-2a68fadab756">响应时间特性曲线</h4>
<div class="outline-text-4" id="text-h:cac7ab51-a9da-47ae-bc90-2a68fadab756">
<p>
和 TPS 相对应的响应时间曲线则是相反的，如下图。随着并发用户数的增加，以及系统资源的不断消耗，系统的响应时间在不断增加。在性能测试阶段，系统的响应时间几乎没有太多的变化，但是到了负载测试的时候，系统的响应时间就开始增加，当超过了它最大负载点-&#x2013;&#x2014;c 点以后继续增加压力，系统的响应时间会急剧增加，系统的性能状况急剧恶化，最后到达了它的崩溃点-&#x2013;&#x2014;d 点。
</p>


<figure id="orgd10cde3">
<img src="./images/CgotOV142FKASZUpAABGou72PvU546.png" alt="CgotOV142FKASZUpAABGou72PvU546.png">

</figure>

<p>
一般说来，性能测试是通过增加并发数，不断测试各项性能指标获得的。如下图性能测试结果表所示，并发数不断地增加，响应时间也不断地增加，TPS 先增加后下降，而错误率超过了某些点以后开始增加，后来增速加剧，同时系统的负载也在不断增加。通过这个表，绘制出来的性能特性曲线就如上面的图中所示。
</p>

<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-right">并发数</td>
<td class="org-right">响应时间(ms)</td>
<td class="org-right">TPS</td>
<td class="org-right">错误率(%)</td>
<td class="org-right">Load</td>
<td class="org-right">内存(G)</td>
<td class="org-left">备注</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-right">500</td>
<td class="org-right">20</td>
<td class="org-right">0</td>
<td class="org-right">5</td>
<td class="org-right">8</td>
<td class="org-left">性能测试</td>
</tr>

<tr>
<td class="org-right">20</td>
<td class="org-right">800</td>
<td class="org-right">30</td>
<td class="org-right">0</td>
<td class="org-right">10</td>
<td class="org-right">10</td>
<td class="org-left">性能测试</td>
</tr>

<tr>
<td class="org-right">30</td>
<td class="org-right">1000</td>
<td class="org-right">40</td>
<td class="org-right">2</td>
<td class="org-right">15</td>
<td class="org-right">14</td>
<td class="org-left">性能测试</td>
</tr>

<tr>
<td class="org-right">40</td>
<td class="org-right">1200</td>
<td class="org-right">45</td>
<td class="org-right">20</td>
<td class="org-right">30</td>
<td class="org-right">16</td>
<td class="org-left">负载测试</td>
</tr>

<tr>
<td class="org-right">60</td>
<td class="org-right">2000</td>
<td class="org-right">30</td>
<td class="org-right">40</td>
<td class="org-right">50</td>
<td class="org-right">16</td>
<td class="org-left">压力测试</td>
</tr>

<tr>
<td class="org-right">80</td>
<td class="org-right">&#x2026;</td>
<td class="org-right">0</td>
<td class="org-right">1000</td>
<td class="org-right">&#x2026;</td>
<td class="org-right">&#x2026;</td>
<td class="org-left">压力测试</td>
</tr>
</tbody>
</table>


<p>
性能测试就是要测试出性能特性曲线，看当前的系统是否达到了性能目标，以及系统最好的性能特性是什么，能达到的最大负载压力是多大。从而做到对自己的系统心中有数，面对高并发访问的时候，心中不慌，从容应对。
</p>
</div>
</div>
</div>
<div id="outline-container-h:d194c978-0413-420c-bd80-59b3c2a1b82f" class="outline-3">
<h3 id="h:d194c978-0413-420c-bd80-59b3c2a1b82f">系统性能优化</h3>
<div class="outline-text-3" id="text-h:d194c978-0413-420c-bd80-59b3c2a1b82f">
<blockquote>
<p>
系统性能优化的分层思想：
</p>
<ul class="org-ul">
<li>机房与骨干网络性能优化</li>
<li>服务器与硬件性能优化</li>
<li>操作系统性能优化</li>
<li>虚拟机性能优化</li>
<li>基础组件性能优化</li>
<li>软件架构性能优化</li>
<li>软件代码性能优化</li>
</ul>
</blockquote>

<p>
现在我们已经了解了系统的各项性能指标，那么如何对系统进行性能优化呢？
</p>
</div>
<div id="outline-container-h:066b23b6-5fb6-4450-8e51-3b5a93be604a" class="outline-4">
<h4 id="h:066b23b6-5fb6-4450-8e51-3b5a93be604a">分层优化系统性能</h4>
<div class="outline-text-4" id="text-h:066b23b6-5fb6-4450-8e51-3b5a93be604a">
<p>
通常当说起对系统性能进行优化的时候，大家一般想到的是对系统内自己写的代码进行优化，或者大不了对系统的架构进行优化，但实际上对系统的性能优化可以有更高层次的思考。如下图所示，将系统的性能优化分为七层，可以在不同的层面对系统进行性能优化。
</p>
</div>
<div id="outline-container-h:cc0665d7-4903-4636-a267-31d98ae439d3" class="outline-5">
<h5 id="h:cc0665d7-4903-4636-a267-31d98ae439d3">第一层是机房与骨干网络的性能优化</h5>
<div class="outline-text-5" id="text-h:cc0665d7-4903-4636-a267-31d98ae439d3">
<p>
对于高并发的、大流量的、海量用户访问的一个互联网应用而言，通常它可能 是全球级的，它的用户可能分布在全球各个地方，我们知道，即使是以光的速 度进行传输，从地球的另一面对一个数据中心进行数据访问，它的一次请求响 应的网络通讯时间都需要几百毫秒的时间，而我们对一个成熟的应用进行性能 优化，通常是难以获得几百毫秒的响应时间优化的。所以对于大型互联网应用， 它们通常会进行全球各地的多机房部署，就近为当地用户提供访问服务，即使 是只针对国内的用户使用的一些大型互联网应用，为了提高不同地区的用户的 访问体验，也会进行多机房架构设计。比如说像新浪微博，它们在上海、北京 和广州建设了 3 个机房，分别为中国不同地域的用户提供服务。
</p>

<p>
所以机房与骨干网络的性能优化，主要手段就是采用 <code>异地多活的多机房架构</code> ， 同时为了联通这些异地多活的多机房架构，会建设自己专用的骨干网络， 并且自主进行 CDN 建设。
</p>
</div>
</div>
<div id="outline-container-h:7a3bbbc3-0e92-4e08-a5f4-bc0ce64aa11a" class="outline-5">
<h5 id="h:7a3bbbc3-0e92-4e08-a5f4-bc0ce64aa11a">第二层是对服务器内的硬件进行优化</h5>
<div class="outline-text-5" id="text-h:7a3bbbc3-0e92-4e08-a5f4-bc0ce64aa11a">
<p>
我们前面讨论过系统伸缩，有垂直伸缩和水平伸缩两种，互联网应用主要使用 的是水平伸缩。但是某些情况下，垂直伸缩实际上带来的性能优化也是不可忽 视的。在成本允许的情况下，考虑使用垂直伸缩，提高服务器硬件的性能，对系统性能的提升会有很大的好处。
</p>

<p>
比如说我们用 SSD 硬盘代替传统的机械硬盘，就可以使磁盘的访问读写特性得到数量级的提升。
</p>

<p>
如下图所示，这是一个 Spark 性能优化的案例。因为 Spark 是一个大数据处 理平台，所以需要处理大量的数据，在作业处理过程中，不同的服务器之间需 要传输大量的数据。经过性能指标分析，我们发现，在一次作业运行中，大量 的时间消耗在 <code>网络传输上</code> 。对这种情况进行性能优化，如果要是从程序或 者代码的层面进行优化，那么主要手段就是使用 <code>数据压缩</code> ，将数据压缩以 后进行传输，这样可以减少数据的传输量，减少网络传输的性能压力，降低网 络传输花费的时间。 <code>但是对数据进行压缩和解压缩，需要消耗大量的 CPU 资源</code> ，事实上大数据计算通常也是 CPU 密集型，将宝贵的 CPU 资源花费在 数据压缩和解压缩上，最后的性能结果可能会变的更差。
</p>


<figure id="org3bf0e82">
<img src="./images/CgoB5l142FSAF3twAAqCeMbFh7k344.png" alt="CgoB5l142FSAF3twAAqCeMbFh7k344.png">

</figure>

<p>
但是我们可以对 <code>硬件进行优化</code> ，如上图例子中看到的。在优化前，我们使 用的是如图这种 1G 的网卡，里面的曲线表示的是网卡读写性能，在某些阶段， 网卡的读写传输能力已经达到了它的极限，需要几十秒的时间去完成数据传输， 然后再进入下一个计算阶段。
</p>


<p>
我们通过硬件优化的方法，将网卡更换为 10G 网卡，如下图，得到了这样一 条网卡传输的性能曲线，我们看到系统在最大的数据传输压力情况下，它依然 没有触发到网卡处理能力的极限，而网络传输的时间也从以前的几十秒缩短到 了十多秒。
</p>


<figure id="org3ba96a9">
<img src="./images/CgotOV142FSAdCteAAfH9mPJTG0835.png" alt="CgotOV142FSAdCteAAfH9mPJTG0835.png"> 

</figure>
</div>
</div>
<div id="outline-container-h:217108fb-3508-4f5d-9be7-4875c58b12ac" class="outline-5">
<h5 id="h:217108fb-3508-4f5d-9be7-4875c58b12ac">硬件与服务器性能优化再下面一层，是操作系统的性能优化</h5>
<div class="outline-text-5" id="text-h:217108fb-3508-4f5d-9be7-4875c58b12ac">
<p>
这里我们再看一个案例，依然是 Spark 的性能优化案例。下图中是 CPU 的使 用率，我们看到其中红色的是用户程序使用的，表示的是 CPU 的用户态，紫 色部分是 CPU 的系统态，红色部分是 User 状态，紫色部分是 sys 状态。紫 色部分表示的是当前 CPU 被操作系统占据，执行操作系统的指令。但是为什 么在一个大数据处理作业过程中，有这样多的 CPU 时间花费在系统处理上？
</p>


<figure id="org63fd935">
<img src="./images/CgoB5l142FWAPdkpAAUqPYDnK5Y840.png" alt="CgoB5l142FWAPdkpAAUqPYDnK5Y840.png">

</figure>

<p>
经过进一步的性能分析，发现部分 Linux 版本在缺省状况下打开了 tranparent huge page 这样一个参数，当我们关闭参数的时候，发现处于 sys 状态 CPU 的消耗得到了极大的优化，也就是下图。如图所示，关闭 tranparent huge page 后，处于 sys 状态消耗的指标，也就是紫色部分消耗 的 CPU 指标得到了极大的改善，而整个的系统作业时间也从 200 多秒优化到 了 150 多秒。
</p>


<figure id="org6c02534">
<img src="./images/CgotOV142FaAQQ6UAAV1CX0sQzQ629.png" alt="CgotOV142FaAQQ6UAAV1CX0sQzQ629.png">

</figure>
</div>
</div>
<div id="outline-container-h:bd0998c5-03d6-4f25-9374-d329dc7060e5" class="outline-5">
<h5 id="h:bd0998c5-03d6-4f25-9374-d329dc7060e5">第四层是虚拟机的性能优化</h5>
<div class="outline-text-5" id="text-h:bd0998c5-03d6-4f25-9374-d329dc7060e5">
<p>
目前主流的像 Java、C# 这样的一些互联网 Web 应用，都是运行在虚拟机之 上的，那么对虚拟机的性能优化也会对系统的整个性能产生巨大的影响。
</p>

<p>
最典型的就是垃圾回收器对系统的性能优化，如下图，我们看到 Java 的几种 不同垃圾回收器，从最早的串行垃圾回收器，到目前比较新的 G1、ZGC 等垃 圾回收器，每一类的垃圾回收器都会对系统性能有不同的影响。
</p>


<figure id="org3f97d29">
<img src="./images/CgoB5l142FaAVg3hAAD9go8QaCc049.png" alt="CgoB5l142FaAVg3hAAD9go8QaCc049.png">

</figure>

<p>
现在互联网主流的垃圾回收器的 G1。
</p>

<p>
CMS 垃圾回收线程和用户的线程在很多时候是并发运行的，这也是 CMS 被称 为并发垃圾回收器的原因。因为用户线程和垃圾回收线程并发运行，所以在垃 圾回收的时候对用户的性能影响相对比较小一点。
</p>
</div>
</div>
<div id="outline-container-h:9b402a6f-0d83-42c3-9644-dd2bddcc9690" class="outline-5">
<h5 id="h:9b402a6f-0d83-42c3-9644-dd2bddcc9690">在虚拟机之下是基础组件的性能优化</h5>
<div class="outline-text-5" id="text-h:9b402a6f-0d83-42c3-9644-dd2bddcc9690">
<p>
我们的 Web 应用主要是运行和部署在 Web 容器组件上，比如像 Java 运行在 Tomcat、Jetty 或者 JBoss（WildFly）这样的 Web 容器之中，那么 Web 容 器本身的性能也一定会对我们这些系统性能产生很大的影响。举一个现实的例 子，在阿里巴巴曾经使用 Jetty 代替 JBoss，通过这样一种替换，实现了系 统性能的极大的提升，特别是节省了大量的服务器，在替换后，阿里巴巴全站 下线 1/3 的应用服务器。主要原因是 Jetty 比 JBoss 的架构更轻量，配置 更加简单，使用较少的 Jetty 容器，就可以实现原来 JBoss 能够提供的处理 能力，如下图所示。
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">部署方式</td>
<td class="org-right">并发</td>
<td class="org-right">TPS</td>
<td class="org-right">响应时间(MS)</td>
<td class="org-right">Load</td>
<td class="org-right">CPU%</td>
<td class="org-left">Swap in/out</td>
</tr>

<tr>
<td class="org-left">jboss-4.0.5GA + apache-2.0.61+ mod_jk+DBCP1.2.2</td>
<td class="org-right">20</td>
<td class="org-right">16.683</td>
<td class="org-right">1143</td>
<td class="org-right">2.706</td>
<td class="org-right">9.692</td>
<td class="org-left">无</td>
</tr>

<tr>
<td class="org-left">jetty7.1.5+apapche2.2.15+mod_jk+DBCP1.2.2</td>
<td class="org-right">20</td>
<td class="org-right">46</td>
<td class="org-right">400</td>
<td class="org-right">4.726</td>
<td class="org-right">23.448</td>
<td class="org-left">无</td>
</tr>

<tr>
<td class="org-left">jetty7.1.5+apapche2.2.15+mod_jk+DBCP1.4</td>
<td class="org-right">20</td>
<td class="org-right">89.095</td>
<td class="org-right">224</td>
<td class="org-right">11.991</td>
<td class="org-right">49.797</td>
<td class="org-left">无</td>
</tr>

<tr>
<td class="org-left">jetty7.1.5+apapche2.2.15+mod_proxy+DBCP1.4</td>
<td class="org-right">20</td>
<td class="org-right">86.41</td>
<td class="org-right">231</td>
<td class="org-right">12.737</td>
<td class="org-right">50.68</td>
<td class="org-left">无</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-h:ce84fc8e-ca89-4097-8a98-657aa8349015" class="outline-5">
<h5 id="h:ce84fc8e-ca89-4097-8a98-657aa8349015">在基础组件性能优化之下才是软件架构性能优化</h5>
<div class="outline-text-5" id="text-h:ce84fc8e-ca89-4097-8a98-657aa8349015">
<p>
<code>事实上我们整个教程都是围绕着架构性能优化的各种工具和技术展开的</code> 。在这 里面我们精简一下，抽象了关于软件架构性能优化的三板斧。这三板斧也是互 联网系统架构的最主要的三个技术，分别是缓存、异步和集群。
</p>

<p>
<b>软件架构性能优化的三板斧</b>
</p>

<ul class="org-ul">
<li><p>
缓存
</p>

<blockquote>
<ol class="org-ol">
<li>从内存获取数据，减少响应时间</li>
<li>减少数据库访问，降低存储设备负载压力</li>
<li>缓存结果对象，而不是原始数据，减少 CPU 计算</li>
<li>缓存主要优化读操作</li>
</ol>
</blockquote>
<p>
通过缓存可以减少数据库的负载压力。缓存使用内存中的数据，比数据库访问磁盘中的数据要有更好的性能，同时缓存中存储着的计算结果数据，也比数据库中存储的原始数据计算速度更快，资源消耗更小。此外还有一点，缓存减少了数据库的负载压力，从而可以使数据库提供更多的数据访问，支撑更大的系统访问压力，从而提升整体的系统性能。
</p></li>

<li><p>
异步
</p>

<blockquote>
<ol class="org-ol">
<li>即时响应，更好的用户体验</li>
<li>控制消费速度，合适的负载压力</li>
<li>异步主要优化写操作</li>
</ol>
</blockquote>
<p>
通过异步的方式，通过分布式消息队列，使系统不同应用之间、不同服务之间异步调用，可以使调用者尽快的返回用户响应，使系统能够得到更好的响应特性。同时分布式消息队列的异步架构，还有削峰填谷的作用，在访问高峰期，通过异步将用户请求数据写入到消息队列中，在访问低谷的时候还在继续消费处理这些消息，避免对数据库等产生较大的负载访问压力，使系统能够维持在一个较好地响应曲线上。
</p></li>

<li><p>
集群
</p>

<p>
通过负载均衡的手段，将多种应用服务器构建成一个集群，共同提供服务，以提高系统整个的处理能力，提升系统的响应性能。
</p></li>
</ul>
</div>
</div>
<div id="outline-container-h:6bbd3dfd-896c-4d2e-8f09-5b5b77c0d04c" class="outline-5">
<h5 id="h:6bbd3dfd-896c-4d2e-8f09-5b5b77c0d04c">在性能优化的最底层才是软件代码的性能优化</h5>
<div class="outline-text-5" id="text-h:6bbd3dfd-896c-4d2e-8f09-5b5b77c0d04c">
<blockquote>
<ol class="org-ol">
<li>遵循面向对象的设计原则与设计模式编程，避免“烂代码”</li>
<li>并发编程，多线程与锁</li>
<li>资源复用，线程池与对象池</li>
<li>异步编程，生产者消费者</li>
<li>数据结构，数组、链表、hash 表、树</li>
</ol>
</blockquote>

<p>
关于代码的性能优化，有这样一些实践可供参考。
</p>

<ul class="org-ul">
<li><p>
第一点是遵循面向对象的设计原则与设计模式编程，避免烂代码。
</p>

<p>
很多时候，我们应用程序性能不好，并不是性能上有什么技术挑战或者是缺陷，仅仅就是因为代码太烂了，系统之间调用耦合严重，很多已经不用的代码，无法清理下线，执行逻辑混乱，导致系统性能差。使用良好的原则与模式编程，编写清晰、灵活、健壮的代码对性能优化有长远的好处。
</p></li>

<li>第二点是并发编程，可以在程序并发运行的时候使用多线程。</li>

<li><p>
第三点是资源的复用。
</p>

<p>
对于一些比较昂贵的资源，比如说线程或者数据库连接，通过线程池或者数据库连接池对外提供服务。通过资源池复用对象或者是线程，供应用程序使用，应用程序每次需要资源的时候，从资源池获取，用完了放回到资源池中继续复用，而不是每次使用的时候都去创建，用完了以后就销毁。
</p></li>

<li><p>
第四点是用异步编程。
</p>

<p>
在程序内部使用消费者，生产者，以队列数据结构的方式，实现程序内的异步架构，以此来提高系统性能。
</p></li>

<li><p>
第五点是要使用正确的数据结构进行编程。
</p>

<p>
要熟悉数组、链表、栈、队列、Hash 表、树等常用数据结构，熟悉它们的特性、优缺点以及使用场景，正确地使用它们来管理和访问程序数据。
</p></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-h:b638c589-c0d6-4324-8708-63f90a3cd786" class="outline-4">
<h4 id="h:b638c589-c0d6-4324-8708-63f90a3cd786">性能优化案例</h4>
<div class="outline-text-4" id="text-h:b638c589-c0d6-4324-8708-63f90a3cd786">
<p>
我们以 Spark 为例，看一个代码的性能优化案例。如下图，我们通过对 CPU 的性能指标的分析发现，在 Spark 作业过程中有一个计算阶段 Stage，运行时间特别长，消耗时间 14 秒。CPU 和网络也都有一定的开销，研究应用代码，发现这段代码仅仅是做了一个数组的初始化，不应该需要花这么长的时间，那么时间究竟花在哪里呢？
</p>


<figure id="orga24624a">
<img src="./images/CgoB5l142FmAWTLOAArpts6MmoU383.png" alt="CgoB5l142FmAWTLOAArpts6MmoU383.png">

</figure>

<p>
进一步对 Spark 的源代码进行分析，发现 Spark 的任务初始化加载应用代码的时候，每一个执行器 Executor 都要加载一次可执行的应用代码，当时每台服务器启动了 48 个 Executor，每个应用程序的代码包是 17M，所以每一个服务器需要下载 48×17M，而集群有 5 台服务器。通过网络传输这么大的代码包，导致网络阻塞，性能劣化。
</p>

<p>
后来我们对 Spark 的源代码进行了优化，主要 <code>优化手段就是在 Executor 加载应用程序的时候，启动了本地文件的缓存模式</code> ，先检查本地文件中是否有需要执行的应用程序代码，如果没有，远程从 Driver 服务器上去加载，如果有直接拷贝本地代码到自己的执行路径下，通过这种优化，我们 <code>使第一个运行阶段，从 14 秒下降到了不到 1 秒</code> ，如下图所示。
</p>


<figure id="org8059fd7">
<img src="./images/CgotOV142FqAS0ldAAeQwDnCKvo591.png" alt="CgotOV142FqAS0ldAAeQwDnCKvo591.png">

</figure>

<p>
优化代码如下图所示，在 Spark 源码增加基于缓存的文件加载函数，十多行代码，获得极大的性能提升。
</p>


<figure id="org5736b2d">
<img src="./images/CgoB5l142FuAHq_eAAfw9xZF3Us688.png" alt="CgoB5l142FuAHq_eAAfw9xZF3Us688.png">

</figure>
</div>
</div>
</div>
<div id="outline-container-h:0900ffb7-0fc1-48bb-b5e1-04ed62dd2420" class="outline-3">
<h3 id="h:0900ffb7-0fc1-48bb-b5e1-04ed62dd2420">总结回顾</h3>
<div class="outline-text-3" id="text-h:0900ffb7-0fc1-48bb-b5e1-04ed62dd2420">
<pre class="example" id="org4cb7aa4">
性能测试--&gt;性能曲线--&gt;优化整体思维--&gt;硬件优化--&gt;
中间件优化--&gt;架构优化--&gt;代码优化
</pre>

<p>
性能优化的前提和基础是性能测试，通过性能测试，了解系统的性能特性才能进行优化，而性能测试主要就是要测试出来系统的性能曲线，通过对性能曲线进行分析，了解系统的瓶颈点和系统资源消耗，再进行性能优化。性能优化的时候需要建立一个整体的思维，要从整体系统的层面去思考优化，而不只是仅仅关注自己的代码，或者是自己设计的架构。
</p>

<p>
最上层的优化是硬件优化，包括骨干网络、数据中心服务器硬件这样的优化；然后是基础组件的性能优化，包括操作系统、虚拟机、应用中间件这几个方面；这之后才是架构的优化，包括核心的三板斧，缓存、异步和集群；最后才是代码的优化，代码优化的主要手段，有并发、复用、异步以及正确的数据结构，当然最重要的是设计清晰、易维护、易懂、简单、灵活的代码，也就是说最重要的是要遵循面向对象的设计原则和设计模式进行编程。
</p>

<p>
本章节的高性能内容讲到这里，下一章节主题是高可用，这是大型互联网架构中最重要的两个章节。
</p>
</div>
</div>
</section>
<section id="outline-container-h:2f7567d0-86b7-42d7-aa46-5af72ce197ff" class="outline-2">
<h2 id="h:2f7567d0-86b7-42d7-aa46-5af72ce197ff">第07讲：高可用系统架构设计</h2>
<div class="outline-text-2" id="text-h:2f7567d0-86b7-42d7-aa46-5af72ce197ff">
<form><input type="button" value="音频" onclick="doSound(7); return false;"></form>
<span id="dummy7"></span>

<blockquote>
<ol class="org-ol">
<li>互联网系统可用性度量</li>
<li>大型系统高可用的一般策略</li>
<li>高可用运</li>
</ol>
</blockquote>

<p>
本章节讲解高可用系统架构，如下图所示，本章节内容主要包括 3 个部分。
</p>


<figure id="org493d325">
<img src="./images/CgotOV13NhmAVDZqAAKvYM6OQbU322.png" alt="CgotOV13NhmAVDZqAAKvYM6OQbU322.png">

</figure>

<ol class="org-ol">
<li>互联网系统 <code>可用性度量</code> ，即如何用指标来衡量系统的可用性，以及进行可用性管理时的一些手段。</li>

<li>高可用架构策略，主要包括负载均衡、备份与失效转移、消息队列隔离、限流与降级、异地多活这样几种架构方法。</li>

<li>高可用运维，如何在开发测试发布以及系统运行过程中，保障系统的高可用，包括自动化部署、自动化监控、自动化测试、预发布测试这几个方面。</li>
</ol>
</div>
<div id="outline-container-h:f02e2e5e-9298-440a-b2f6-9bc96e314e04" class="outline-3">
<h3 id="h:f02e2e5e-9298-440a-b2f6-9bc96e314e04">系统高可用的挑战</h3>
<div class="outline-text-3" id="text-h:f02e2e5e-9298-440a-b2f6-9bc96e314e04">
<blockquote>
<ol class="org-ol">
<li>DNS 被劫持</li>
<li>CDN 服务不可用</li>
<li>应用服务器及数据库服务器宕机</li>
<li>网络交换机失效</li>
<li>硬件故障：硬盘损坏、网卡松掉</li>
<li>环境故障：机房停电、空调失灵、光缆被挖掘机挖断</li>
<li>代码 bug</li>
<li>黑客攻击</li>
<li>促销引来大量用户访问</li>
<li>第三方合作伙伴的服务不可用</li>
<li>&#x2026; &#x2026;</li>
</ol>
</blockquote>

<p>
一个互联网应用想要完整地呈现在最终用户的面前，需要经过很多个环节，任何一个环节出了问题，都有可能会导致系统不可用。
</p>

<p>
比如说 DNS 被劫持，域名解析就失败了，系统虽然完好无损，但用户依然不能访问系统。再比如，CDN 服务不可用，前面提过，CDN 服务是用户访问的第一跳，对于大型互联网系统而言，主要的静态资源都是通过 CDN 返回的。如果 CDN 服务不可用，那么大量的用户请求就会到达互联网数据中心，会给互联网数据中心带来巨大的请求负载压力，可能直接导致系统崩溃。还有就是应用服务器及数据库宕机、网络交换机宕机、磁盘损坏、网卡松掉，这样的硬件故障；机房停电了、空调失灵了、光缆被挖掘机挖断了，这些环境故障。以及程序代码 bug 引起的故障，等等。
</p>

<p>
每种故障都是系统不可用的原因之一，在设计系统相关架构的时候，要考虑各个方面的因素。除了系统本身故障导致的可用性问题，还有外部因素导致的系统不可用。比如说系统被黑客攻击了；业务上要做一次大的促销，或者要做一个秒杀的活动，因此带来的访问压力冲击；以及第三方合作伙伴服务不可用等等，各种带来系统故障的原因。
</p>

<p>
系统的高可用架构，说的就是如何去应对这些挑战。
</p>
</div>
</div>
<div id="outline-container-h:c726b294-24d4-411b-b80e-97c803ee2a9f" class="outline-3">
<h3 id="h:c726b294-24d4-411b-b80e-97c803ee2a9f">互联网应用可用性的度量</h3>
<div class="outline-text-3" id="text-h:c726b294-24d4-411b-b80e-97c803ee2a9f">
<blockquote>
<ol class="org-ol">
<li>通常用 N 个 9 来说明互联网应用的可用性</li>
<li>年度可用性指标 = (1 - 不可用时间/年度总时间) * 100%</li>
<li>我们熟悉的互联网产品的可用性大多是 4 个 99， 即 99.99% 可用</li>
</ol>
</blockquote>

<p>
业界通常用多少个 9 来说明互联网应用的可用性。比如说 QQ 的可用性是 4 个 9，就是说 QQ 的服务 99.99% 可用，这句话的意思是 QQ 的服务要保证在其所有的运行时间里只有 0.01% 不可用，也就是说一年大概有 53 分钟不可用。这个 99.99% 就叫做系统的可用性指标，这个值的计算公式是：
</p>

\begin{equation*}
年度可用性指标 \ = 1 −（不可用时间/年度总时间）×100%
\end{equation*}

<p>
一般说来，
</p>
<ul class="org-ul">
<li>两个 9 表示系统基本可用，年度停机时间小于 88 小时；</li>
<li>3 个 9 是较高可用，年度停机时间小于 9 个小时；</li>
<li>4 个 9 是具有自动恢复能力的高可用，年度停机时间小于 53 分钟；</li>
<li>5 个 9 指极高的可用性，年度停机时间小于 5 分钟。</li>
</ul>

<p>
事实上对于一个复杂的大型互联网系统而言，对可用性的影响因素是非常多的，能够达到 4 个 9 甚至 5 个 9 的可用性，除了具备过硬的技术、大量的设备资金投入、有责任心的工程师，有时候还需要好运气。
</p>

<p>
我们熟悉的互联网产品的可用性大多是 4 个 9，淘宝、支付宝、微信，差不多都是这样。我们用可用性来描述一个系统是否整体可用，但是实际上很少会出现整个系统在几分钟几个小时内全部不可用的情况，更多的时候是一部分用户全部不可用，或者是全部的用户一部分功能不可用。可用性指标是对系统整体可用性的一个度量。
</p>
</div>
<div id="outline-container-h:8923cd60-2a7f-4eaa-9e4c-7b4742185b1e" class="outline-4">
<h4 id="h:8923cd60-2a7f-4eaa-9e4c-7b4742185b1e">故障分类</h4>
<div class="outline-text-4" id="text-h:8923cd60-2a7f-4eaa-9e4c-7b4742185b1e">
<p>
在互联网企业中为了管理好系统的可用性，界定好系统故障以后的责任，通常会用 <code>故障分</code> 进行管理。一般过程是，根据系统可用性指标换算成故障分，是整个系统的故障分，比如 10万 分，再根据各自团队各个产品各个职能角色承担的责任的不同，会把故障分下发给每个团队，直到每个人，也就是说每个工程师在年初的时候就会收到一个预计的故障分。然后每一次系统出现可用性故障的时候，都会进行故障考核，划定到具体的团队和责任人以后，会扣除他的故障分。如果到了年底的时候，一个工程师，他的故障分被扣为负分，那么就可能会影响他的绩效考核。
</p>

<p>
故障分类的计算方式是用 <code>故障时间乘以故障权</code> 重来计算得到的。而故障的权重通常是在故障产生以后，根据影响程度，由运营方确定的一个故障权重值。如下是故障权重的示例。
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">分类</td>
<td class="org-left">描述</td>
<td class="org-right">权重</td>
</tr>

<tr>
<td class="org-left">事故故障</td>
<td class="org-left">严重故障，网站整体不可用</td>
<td class="org-right">100</td>
</tr>

<tr>
<td class="org-left">A类故障</td>
<td class="org-left">网站访问不顺畅或核心功能不可用</td>
<td class="org-right">20</td>
</tr>

<tr>
<td class="org-left">B类故障</td>
<td class="org-left">非核心功能不可用，或核心功能少数用户不可用</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-left">C类故障</td>
<td class="org-left">以上故障以外的其他故障</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-h:5d03bce9-9cc9-41c3-9989-836a88bd119c" class="outline-4">
<h4 id="h:5d03bce9-9cc9-41c3-9989-836a88bd119c">故障处理流程和故障时间</h4>
<div class="outline-text-4" id="text-h:5d03bce9-9cc9-41c3-9989-836a88bd119c">
<p>
再看一般互联网应用的故障处理流程和故障时间的确定，如下示例。
</p>

<pre class="example" id="org1037a68">
- 客服报告故障或监控系统发现故障（故障开始时间）
- 提交故障给相关部门接口人
- 故障接手&amp;处理
- 故障处理完毕，故障归档（故障结束时间）
- 确认故障归属，记入绩效考核
</pre>

<p>
首先是故障的开始，故障的开始时间是客服报告故障的时间点，或者是监控系统发现故障的时间点，如果客服收到了投诉，说系统不可用，这个时候就开始计算故障时间。或者监控系统发现，用户访问量或者是订单量因系统故障而出现了大幅的下跌，那么监控系统监控到的故障时间点就是故障的开始时间。
</p>

<p>
确定了故障以后，就把故障提交给相关部门的接口人，接口人再把故障现象发送给相关的责任人，责任人接手故障后，进行故障排查和处理。处理完毕以后系统重新启动，或者是代码重新发布上线以后，重新确认系统指标正常或者是功能恢复正常，确认故障处理完毕，这个时间就是故障的结束时间。
</p>

<p>
我们刚才用来计算故障分的故障时间，就是用这个故障结束时间减去开始时间，就是故障时间。这个时间通常以秒为单位，故障处理整个过程是争分夺秒的。故障结束以后，通常要开一个故障复盘会，检讨故障产生的原因，亡羊补牢，避免下次出现类似的故障，同时也要对引起故障的原因进行责任划分，扣除相关责任者的故障分计入绩效考核。
</p>
</div>
</div>
</div>
<div id="outline-container-h:5a44e343-5993-4b46-a094-5a2b82efbc4c" class="outline-3">
<h3 id="h:5a44e343-5993-4b46-a094-5a2b82efbc4c">大型系统高可用的一般策略</h3>
<div class="outline-text-3" id="text-h:5a44e343-5993-4b46-a094-5a2b82efbc4c">
<p>
那么，大型系统高可用的一般策略有哪些？
</p>
</div>
<div id="outline-container-h:a8c463aa-65b0-4d3d-b831-9b1d242be508" class="outline-4">
<h4 id="h:a8c463aa-65b0-4d3d-b831-9b1d242be508">负载均衡</h4>
<div class="outline-text-4" id="text-h:a8c463aa-65b0-4d3d-b831-9b1d242be508">

<figure id="org9c99c26">
<img src="./images/CgotOV13Tg6ASyqaAAMdZZQxLNA225.png" alt="CgotOV13Tg6ASyqaAAMdZZQxLNA225.png">

</figure>

<p>
首先是应用服务器的负载均衡。负载均衡核心要解决的就是通过一个负载均衡服务器，将用户的请求分发给多个应用服务器，将多个应用服务器构建成一个集群，共同对外提供服务。这样的架构可以提高系统的处理能力，以解决高并发用户请求下的系统性能问题。
</p>

<p>
事实上，负载均衡还可以实现系统的高可用。因为用户的请求是通过负载均衡服务器请求分发到不同的应用服务器上的。那么当某个应用服务器宕机的时候，负载均衡服务器可以通过响应超时或者其它的心跳策略，发现这个应用服务器不可用，就可以将请求转发给其它的服务器，保证用户的请求总是能够成功的，整个系统对外看起来是可用的。从而使某个应用的服务器宕机，不会影响到整个系统的可用性。
</p>

<p>
这里面需要注意的一个点是，当我们提到一个应用服务器不可用的时候，并不仅仅是指应用服务器的硬件故障，或者是系统故障导致的系统宕机，更多的可能是应用程序在发布，因为应用程序要发布，必须要关闭以前的应用程序进程，拷贝新的程序代码，重新启动应用程序，这个时间可能需要几分钟或者十几分钟的时间，那么这段时间这台应用服务器对外看起来就是不可用的。
</p>

<p>
而这样的发布在互联网场景中是非常频繁的，一周有几次，甚至一天都有几次这样的发布。应用服务器是需要频繁停机的。所以在架构设计的时候，你不光要考虑到真正的服务器硬件或者系统故障导致的宕级，还要考虑到应用程序发布导致的系统停机，而这个可能更加频繁。
</p>
</div>
</div>
<div id="outline-container-h:6619d25f-68a0-494c-8405-72da8919715f" class="outline-4">
<h4 id="h:6619d25f-68a0-494c-8405-72da8919715f">负载均衡实现方法</h4>
<div class="outline-text-4" id="text-h:6619d25f-68a0-494c-8405-72da8919715f">
<ul class="org-ul">
<li>HTTP 重定向负载均衡</li>
</ul>

<p>
比较简单的一种是 HTTP 重定向负载均衡，也就是来自用户的 HTTP 请求到达负载均衡服务器以后，负载均衡服务器根据某种负载均衡算法计算一个新的服务器，通过 HTTP 重定向响应，将新的 IP 地址发送给用户浏览器，用户浏览器收到重定向响应以后，重新发送请求到真正的应用服务器，以此来实现负载均衡。工作原理如下图所示。
</p>


<figure id="org38c0bbb">
<img src="./images/CgotOV13TjWAcbwLAAOWnFopnts060.png" alt="CgotOV13TjWAcbwLAAOWnFopnts060.png">

</figure>

<p>
HTTP 重定向负载均衡的优点是它的设计比较简单，最简单的 HTTP 重定向负载均衡服务器，可能只需要几十行代码就可以完成。但是它的缺点是，用户完成一次访问需要两次请求数据中心，一次请求负载均衡服务器，一次是请求应用服务器；另一个问题是因为响应要重定向到真正的应用服务器，所以需要把应用服务器的 IP 地址暴露给外部用户，这样可能会导致安全性的问题。
</p>

<ul class="org-ul">
<li>DNS 负载均衡</li>
</ul>

<p>
另一种实现负载均衡的策略是 DNS 负载均衡。我们知道浏览器访问我们数据中心的时候，通常是用域名进行访问，HTTP 协议则必须知道 IP 地址才能建立通信连接，那么域名是如何转换成 IP 地址的呢？就是通过 DNS 服务器来完成。当用户从浏览器发起发起 HTTP 请求的时候，他输入域名，首先要到 DNS 域名服务器进行域名解析，解析得到 IP 地址以后，用户才能够根据 IP 地址建立 HTTP 连接，访问真正的数据中心的应用服务器，那么就可以在 DNS 域名解析的时候进行负载均衡，不同的浏览器进行解析的时候，返回不同的 IP 地址，从而实现负载均衡。工作原理如下图所示。
</p>


<figure id="org608b624">
<img src="./images/CgoB5l13NhuAay7PAANuWKPiFK8545.png" alt="CgoB5l13NhuAay7PAANuWKPiFK8545.png">

</figure>

<p>
目前主要的 DNS 服务商和 DNS 软件都支持 DNS 域名解析负载均衡。DNS 域名解析负载均衡的主要问题有两个方面。一方面它依然是要将 Web 服务器的 IP 地址暴露给浏览器，产生安全问题。另一方面，很多时候，DNS 域名解析服务器是在互联网应用系统之外的一个服务器，它由域名解析服务商提供，不在我们的控制范围之内，所以当我们的服务器不可用的时候，DNS 域名解析服务器并不知道，它依然会将用户请求分发过来。而且域名解析并不是每一次请求都进行解析的，即使我们去域名解析服务商的机器上去更新了域名解析对应的 IP 列表，这个更新也不会立即生效，依然会有大量的请求到达我们的应用服务器。那么这些已经宕机的、不可用的服务器就无法完成用户的需求，在用户看起来就是我们的系统不可用。
</p>

<p>
虽然 DNS 域名解析负载均衡有这样的一些问题，但是在实践中大型互联网系统几乎都使用域名解析负载均衡，主要原因是在于，这些大型互联网系统，比如像淘宝、Facebook、百度这些系统，根据域名解析出来的 IP 地址，并不是真正的 Web 服务器 IP 地址，是负载均衡服务器的 IP 地址，也就是说这些大型互联网系统，它们都采用了两级负载均衡机制，DNS 域名解析进行一次负载均衡解析出来的 IP 地址是负载均衡服务器的 IP 地址，然后由负载均衡服务器，再做一次负载均衡，将用户的请求分发到应用服务器，这样的话，我们的应用服务器的 IP 地址就不会暴露出去。同时由于负载均衡服务器通常是比较高可用的，也不存在应用程序发布的问题，所以很少有可用性方面的问题。
</p>

<ul class="org-ul">
<li>反向代理负载均衡</li>
</ul>

<p>
负载均衡的另外一种实现是反向代理负载均衡。我们前面提到用户请求到达数据中心以后，最先到达的就是反向代理服务器。反向代理服务器，除了可以提供请求的缓存功能以外，还可以进行负载均衡，将用户的请求分发到不同的服务器上面去。反向代理是工作在
HTTP 协议层上的一个服务器，所以它代理的也是 HTTP 的请求和响应。而 HTTP
协议相对说来，作为互联网第七层的一个协议，它的协议比较重，效率比较低，所以反向代理负载均衡通常用在小规模的互联网系统上，只有几台或者十几台服务器的规模。工作原理如图所示。
</p>


<figure id="org48a5b2c">
<img src="./images/CgotOV13TleAGkEbAAMjmfjdqT4222.png" alt="CgotOV13TleAGkEbAAMjmfjdqT4222.png">

</figure>

<ul class="org-ul">
<li>IP 层负载均衡（四层负载均衡）</li>
</ul>

<p>
如果规模再大一点的集群，通常就不会再使用反向代理服务器进行负载均衡。在七层网络通讯之下的另外一种负载均衡方法是在 IP 层进行负载均衡，IP 层是网络通讯协议的第四层，所以有时候叫四层负载均衡。它的主要工作原理是当用户的请求到达负载均衡服务器以后，负载均衡服务器会拿到 TCP/IP 的数据包，对数据包的 IP 地址进行转换，修改 IP 地址，将其修改为 Web 服务器的 IP 地址，然后把数据包重新发送出去。如下图所示。
</p>


<figure id="org56004c7">
<img src="./images/CgotOV13ToGAOH4DAANP56h82n8245.png" alt="CgotOV13ToGAOH4DAANP56h82n8245.png">

</figure>

<p>
因为 IP 地址已经是 Web 服务器的 IP 地址，所以这个数据包会重新路由到应用服务器上，以此来实现负载均衡。IP 层负载均衡，比我们刚才提到的工作在第七层的反向代理负载均衡效率要高得多。但是它依然有一个缺陷，就是不管是请求还是响应的数据包都要通过负载均衡服务器进行 IP 地址转换，才能够正确地进行数据分发，或者正确地响应到用户的客户端浏览器。请求的数据通常比较小，一个 URL 或者是一个简单的表单，但是响应的数据不管是 HTML 还是图片，JS、CSS 这样的资源文件通常都会比较大，因此负载均衡服务器会成为响应数据的流量瓶颈。
</p>

<ul class="org-ul">
<li>数据链路层负载均衡</li>
</ul>

<p>
为了解决这个问题，将负载均衡的数据传输，再往下放一层，放到了数据链路层，实现数据链路层的负载均衡。在这一层上，负载均衡服务器并不修改数据包的 IP 地址，而是修改网卡的 MAC 地址。而应用服务器和负载均衡服务器都使用相同的虚拟 IP 地址，这样 IP 路由就不会受到影响，但是网卡会根据自己的 MAC 地址选择负载均衡发送到自己的网卡的数据包，交给对应的应用服务器去处理，处理结束以后，当他把响应的数据包发送到网络上的时候，因为 IP 地址没有修改过，所以这个响应会直接到达用户的浏览器，而不会再经过负载均衡服务器。工作原理如下图所示。
</p>


<figure id="orgcf6fb0d">
<img src="./images/CgoB5l13NhuABboPAANF16k_Zus646.png" alt="CgoB5l13NhuABboPAANF16k_Zus646.png">

</figure>

<p>
这种通信方式我们从上图看是一个三角形，所以也被形象地称为三角模式。数据链路层的负载均衡是目前大型互联网系统中使用得最多的负载均衡方案。在 Linux 内核中也支持数据链路层负载均衡，也就是说可以用一台 Linux 服务器去配置实现数据链路层负载均衡，通过负载均衡实现应用服务器的高可用。
</p>
</div>
</div>
<div id="outline-container-h:56f3af95-8566-4c87-b04f-771f90646702" class="outline-4">
<h4 id="h:56f3af95-8566-4c87-b04f-771f90646702">数据库复制与失效转移</h4>
<div class="outline-text-4" id="text-h:56f3af95-8566-4c87-b04f-771f90646702">
<p>
数据库的高可用要比应用服务器复杂很多，因为应用服务器是无状态的，请求可以分发到任何一台服务器去处理，而数据库上必须存储有正确的数据才能将请求分发给它。对于数据库的高可用，通常是使用 <code>数据库复制与失效转移</code> 来完成的。我们在分布式数据库存储这一讲中提到过 MySQL 的主主复制，以及 MySQL 的主从复制。
</p>

<p>
因为有数据复制，所以用户请求可以访问到不同的从服务器上，当某一台从服务器宕机的时候，系统的读操作不会受到影响，实现数据库读操作高可用。而如果实现了主主复制，那么当主服务器宕机的时候，写请求连接到另外一台主服务器上，实现数据库的写操作高可用，而数据库部署的时候，可以同时部署如下图所示这样的主主复制和主从复制，也就是实现数据库的读写都高可用。
</p>


<figure id="org45f43b3">
<img src="./images/CgotOV13XS-ABhWJAAXmqw3pev8732.png" alt="CgotOV13XS-ABhWJAAXmqw3pev8732.png">

</figure>
</div>
</div>
<div id="outline-container-h:d51933b8-b9c1-48eb-a3c6-e42f6610d2f8" class="outline-4">
<h4 id="h:d51933b8-b9c1-48eb-a3c6-e42f6610d2f8">消息队列隔离</h4>
<div class="outline-text-4" id="text-h:d51933b8-b9c1-48eb-a3c6-e42f6610d2f8">
<p>
系统高可用的另一种策略是使用消息队列实现异步解耦，即消息队列隔离。我们在分布式消息队列一讲中也提到过这种架构方式的高可用。
</p>

<p>
一方面，消息的生产者和消费者通过消息队列进行隔离，那么如果消费者出现故障的时候，生产者可以继续向消息队列发送消息，而不会感知到消费者的故障，等消费者恢复正常以后再去到消息队列中消费消息，所以从用户处理的视角看，系统一直是可用的。
</p>


<figure id="org6e4f9bc">
<img src="./images/CgoB5l13NhyAZztaAACvmUe0VZI668.png" alt="CgoB5l13NhyAZztaAACvmUe0VZI668.png">

</figure>

<p>
另一方面，由于分布式消息队列具有削峰填谷的作用，所以在高并发的时候，消息的生产者可以将消息缓存在分布式消息队列中，消费者可以慢慢地到消息队列中去处理，而不会将瞬时的高并发负载压力直接施加到整个系统上，导致系统崩溃。
</p>
</div>
</div>
<div id="outline-container-h:e018fd58-8d06-4a19-98f9-170ce70a25ac" class="outline-4">
<h4 id="h:e018fd58-8d06-4a19-98f9-170ce70a25ac">限流和降级</h4>
<div class="outline-text-4" id="text-h:e018fd58-8d06-4a19-98f9-170ce70a25ac">
<blockquote>
<p>
限流： 通过对并发访问进行限流，降低并发请求数量来保护系统
</p>

<p>
降级：关闭部分非核心功能，降低对系统的资源消耗，保证系统在高并发的情况仍保持可用
</p>
</blockquote>

<p>
系统高可用的另一个策略是限流和降级。主要针对的是，在高并发场景下，如果系统的访问量超过了系统的承受能力，如何对系统进行保护？
</p>

<p>
限流是指对进入系统的用户请求进行限流处理，如果访问量超过了系统的最大处理能力，就会丢弃一部分的用户请求，保证整个系统可用，保证大部分用户是可以访问系统的。这样虽然有一部分用户的请求被丢弃，产生了部分不可用，但还是好过整个系统崩溃，所有的用户都不可用要好。
</p>

<p>
保护系统的另一种手段就是降级。有一些系统功能是非核心的，但是实际它也给系统产生了非常大的压力，比如说在电商系统中有“确认收货”这个功能，对于大多数互联网电商应用，我们即使是不去确认收货，超时它会自动确认收货。
</p>

<p>
但实际上确认收货这个操作是一个非常重的操作，因为它要更改订单状态，完成支付确认，并进行评价等一系列操作。这些操作都是一些非常重的、对数据库压力很大的操作。如果在系统高并发的时候去完成这些操作，那么会对系统雪上加霜，使系统的处理能力更加恶化。解决办法就是在系统高并发的时候，比如说像淘宝“双11“这样的时候，当天可能整天系统都处于一种极限的高并发访问压力之下，这一天就可以将确认收货、评价这些非核心的功能关闭，将宝贵的系统资源留下来，给正在购物的人，让他们去完成交易。
</p>
</div>
</div>
<div id="outline-container-h:2dee68fe-d20d-47ed-9558-e7f92734e719" class="outline-4">
<h4 id="h:2dee68fe-d20d-47ed-9558-e7f92734e719">异地多活机房架构</h4>
<div class="outline-text-4" id="text-h:2dee68fe-d20d-47ed-9558-e7f92734e719">

<figure id="orgb4103e1">
<img src="./images/img_20240303_232125.png" alt="img_20240303_232125.png" width="80%">

</figure>

<p>
系统高可用的另一个策略是异地多活的架构。我们前面提到的各种高可用策略，都还是针对一个机房内的系统架构，但是如果整个机房都不可用，比如说机房所在城市遭遇了地震，机房遭遇了火灾或者停电，这样的话，不管我们前面的设计和系统多么的高可用，整个机房都不可访问，看起来系统依然是不可用的。
</p>

<p>
为了解决这个问题，同时也为了提高系统的处理能力和改善用户体验。很多大型互联网应用都采用了异地多活的多机房架构策略，也就是说将数据中心分布在多个不同地点的机房里，这些机房都可以对外提供服务，用户可以连接任何一个机房进行访问。这样每个机房都可以提供完整的系统服务，即使某一个机房不可使用，系统也不会宕机，依然保持可用。
</p>

<p>
异地多活的架构考虑的一个重点是，用户请求如何分发到不同的机房去。这个主要可以在域名解析的时候完成，也就是用户进行域名解析的时候，会根据就近原则或者其它一些策略，完成用户请求的分发。
</p>

<p>
另一个至关重要的技术点是，因为是多个机房都可以独立对外提供服务，所以也就意味着每个机房都要有完整的数据记录，所以用户在任何一个机房完成的数据操作，都必须要同步传输给其它的机房，需要进行数据实时同步。
</p>

<p>
目前远程数据库同步的解决方法有很多，最需要关注的是数据冲突问题。同一条数据，同时在两个数据中心被修改了，该如何解决？为了解决这种数据冲突的问题，很多异地多活的多机房架构实际上 <code>采用的是类似 MySQL 的主主模式</code> ，也就是说多个机房在某个时刻是有一个主机房的，某些请求只能到达主机房才能被处理，其它的机房不处理这一类请求，以此来避免关键数据的冲突。
</p>
</div>
</div>
</div>
<div id="outline-container-h:752f3220-bf19-4f41-beb4-3307bdc1cbe1" class="outline-3">
<h3 id="h:752f3220-bf19-4f41-beb4-3307bdc1cbe1">高可用运维</h3>
<div class="outline-text-3" id="text-h:752f3220-bf19-4f41-beb4-3307bdc1cbe1">
</div>
<div id="outline-container-h:e42e1703-b8ff-4c0e-b270-4ff3aace088a" class="outline-4">
<h4 id="h:e42e1703-b8ff-4c0e-b270-4ff3aace088a">自动化测试</h4>
<div class="outline-text-4" id="text-h:e42e1703-b8ff-4c0e-b270-4ff3aace088a">
<p>
除了高可用的架构，还有保障系统高可用的运维。
</p>

<p>
其中一种高可用的运维是自动化测试。对于一个成熟的互联网系统，任何一次代码变更，都可能需要执行大量的回归测试，才能够保证系统没有 bug，而这种更新又是非常频繁的，如果依赖手工操作，测试效率和测试资源都难以满足如此大量的回归测试需求。所以对于成熟的互联网产品，很多时候采用自动化测试，通过自动化脚本自动对 APP 或者是服务接口进行测试。
</p>

<p>
一开始的时候要写自动化的测试脚本，工作量会比较大，投入也会比较大。但是随着脚本的不断的积累，自动化测试的成本会比手工测试的成本要更低。一般说来，在实践中，对于比较成熟的互联网产品，也就是说每次变更相对影响比较小的互联网产品，使用自动化测试是比较划算的。自动化测试和手工测试的总体成本对比如下图。
</p>


<figure id="org77e2a9a">
<img src="./images/CgotOV13NhyADh9_AACC0HK0g6k701.png" alt="CgotOV13NhyADh9_AACC0HK0g6k701.png">

</figure>
</div>
</div>
<div id="outline-container-h:12050e85-8178-4d50-8eda-009621fa96d6" class="outline-4">
<h4 id="h:12050e85-8178-4d50-8eda-009621fa96d6">自动化监控</h4>
<div class="outline-text-4" id="text-h:12050e85-8178-4d50-8eda-009621fa96d6">
<p>
还有一种是自动化监控。系统在线上运行的时候，必须要实时的监控系统的各项指标，包括业务指标和技术指标。业务指标包括用户访问量、订单量、查询量这些主要的业务指标，技术指标包括 CPU、磁盘、内存的使用率等。通过这些指标可以实时监控业务是否正常，系统是否正常。如果指标不正常，通过监控报警的手段，通知相关的人员，还可以在自动化监控的基础上去，触发自动化的运维工具，进行自动化的系统修复。
</p>


<figure id="orgc9507d2">
<img src="./images/CgoB5l13XWCAMVCMAAXGZAuzLs8203.png" alt="CgoB5l13XWCAMVCMAAXGZAuzLs8203.png">

</figure>
</div>
</div>
<div id="outline-container-h:80fb2374-9b81-4113-aa8d-b9ab20069d17" class="outline-4">
<h4 id="h:80fb2374-9b81-4113-aa8d-b9ab20069d17">预发布</h4>
<div class="outline-text-4" id="text-h:80fb2374-9b81-4113-aa8d-b9ab20069d17">
<p>
高可用运维的另一种手段是预发布。虽然在系统上线之前，系统在代码更新以后，要经过测试才会上线，但是还有一些情况在测试环境是无法复现的。比如对第三方服务的调用，数据库结构的变更，以及一些线上的配置参数变更等等，只有线上才能够发现。
</p>

<p>
但是一旦发布到线上以后，如果有这些问题，就会导致系统不可用，解决方法就是进行预发布。在线上的服务器集群里面有一台服务器，是专门的预发布服务器，这台服务器不配置在负载均衡服务器，也就是说外部的用户是无法访问到这台服务器的，但是这台服务器跟其它的应用服务器，使用的配置、连接的数据库、连接的第三方服务都是完全一样的，它是一个完全线上的一个服务器，而这个服务器只有内部的工程师才可以访问到。
</p>

<p>
在系统发布的时候，先发布到这台预发布服务器上，然后工程师通过域名绑定的方式，直接访问这台服务器，进行一些关键的业务操作，看系统是否正常。如果正常，那么就将代码同步到其它的服务器上，这时候外部服务器才能够访问到最新的代码。如果发现问题，那么就可以重新进行修复。这个问题虽然是线上的，但是并不会影响到外部用户的使用。预发布的工作原理如下图。
</p>


<figure id="org401827e">
<img src="./images/CgoB5l13XaiAV3hlAAV3nLAn3Pg963.png" alt="CgoB5l13XaiAV3hlAAV3nLAn3Pg963.png">

</figure>
</div>
</div>
<div id="outline-container-h:2eb6cd3f-503b-47ef-94cd-f7934a67595c" class="outline-4">
<h4 id="h:2eb6cd3f-503b-47ef-94cd-f7934a67595c">灰度发布</h4>
<div class="outline-text-4" id="text-h:2eb6cd3f-503b-47ef-94cd-f7934a67595c">
<p>
对于大型互联网系统，虽然有前面的各种保障措施，但还是可能发生上线以后用户报告出现故障，对于用户报告的故障或者监控到的故障，就需要对系统进行回滚到原来的代码，系统退回到前一个版本。但是对于大型互联网系统而言，它的服务器特别多，可能有数万台服务器，这个时候即使是进行系统回滚，也可能要花很长的时间。这段时间系统一直处于某种不可用的故障状态。
</p>

<p>
为了避免上述情况，大型互联网系统，会使用一种灰度发布的手段，也就是说每天都只发布一部分服务器，如果出现问题，那么只需要回滚这一部分服务器就可以。发布以后观察一天，第二天再发布一部分服务器。如果没有故障报告，那么就继续发布，如果有故障报告就进行回滚，减少故障的影响力和影响时间。灰度发布流程如下图。
</p>


<figure id="orga838581">
<img src="./images/CgoB5l13Nh2AMDiGAAEHM7DJ1so485.png" alt="CgoB5l13Nh2AMDiGAAEHM7DJ1so485.png">

</figure>
</div>
</div>
</div>
<div id="outline-container-h:6034da0d-2f2e-42af-8c1f-351d21b0f64d" class="outline-3">
<h3 id="h:6034da0d-2f2e-42af-8c1f-351d21b0f64d">总结回顾</h3>
<div class="outline-text-3" id="text-h:6034da0d-2f2e-42af-8c1f-351d21b0f64d">
<pre class="example" id="org1beb178">
可用性指标与故障分--&gt;负载均衡--&gt;备份与失效转移--&gt;消息队列隔离--&gt;
限流与降级--&gt;异地多活--&gt;自动化运维
</pre>

<p>
系统可用性是通过可用性指标来进行衡量的。当我们说一个系统 4 个 9 可用的时候，就是指这个系统 99.99% 的时间都是可用的，也就意味着一年中的不可用时间只占 53 分钟。
</p>

<p>
为了对故障进行管理和考核，很多互联网企业还引入了故障分这样一个手段。保障系统高可用的主要策略有应用服务器的负载均衡、数据库的备份与失效转移、消息队列隔离，限流、降级以及异地多活的多机房架构。
</p>

<p>
除了这些高可用的架构策略，还通过一系列的自动化手段，实现运维的高可用，包括自动化测试、自动化监控，预发布以及灰度发布这些手段。
</p>

<p>
本章节内容至此结束，下一章节讲解系统的安全架构。
</p>
</div>
</div>
</section>
<section id="outline-container-h:e690dc67-4e4b-4a31-aea4-5255830193aa" class="outline-2">
<h2 id="h:e690dc67-4e4b-4a31-aea4-5255830193aa">第08讲：系统的安全架构设计</h2>
<div class="outline-text-2" id="text-h:e690dc67-4e4b-4a31-aea4-5255830193aa">
<form><input type="button" value="音频" onclick="doSound(8); return false;"></form>
<span id="dummy8"></span>

<blockquote>
<ol class="org-ol">
<li>Web 攻击与防护</li>
<li>敏感数据加密与解密</li>
<li>信息过滤与反垃圾</li>
</ol>
</blockquote>

<p>
本章节讲解系统的安全架构。
</p>


<figure id="orgaccb1a7">
<img src="./images/CgoB5l2-U5-AOCXQAAGe9-kdGzA892.png" alt="CgoB5l2-U5-AOCXQAAGe9-kdGzA892.png">

</figure>

<p>
本节主要讲 Web 的攻击与防护、信息的加解密与反垃圾。其中 Web 攻击方式包括 XSS 跨站点脚本攻击、SQL 注入攻击和 CSRF 跨站点请求伪造攻击；防护手段主要有消毒过滤、SQL 参数绑定、验证码和防火墙；加密手段，主要有单向散列加密、对称加密、非对称加密；信息过滤与反垃圾主要讨论分类算法和布隆过滤器。
</p>
</div>
<div id="outline-container-h:9c394548-be4d-4647-a79a-af68ac7b7f6a" class="outline-3">
<h3 id="h:9c394548-be4d-4647-a79a-af68ac7b7f6a">Web 攻击与防护</h3>
<div class="outline-text-3" id="text-h:9c394548-be4d-4647-a79a-af68ac7b7f6a">
</div>
<div id="outline-container-h:4ba226f7-6ef3-46be-994f-1bb05cf09a9b" class="outline-4">
<h4 id="h:4ba226f7-6ef3-46be-994f-1bb05cf09a9b">XSS 攻击</h4>
<div class="outline-text-4" id="text-h:4ba226f7-6ef3-46be-994f-1bb05cf09a9b">
<p>
先看 XSS 跨站点脚本攻击。XSS 攻击，顾名思义，就是通过构造一个非法的浏览器脚本，让用户跨站点去执行，从而达到攻击的目的。
</p>

<ul class="org-ul">
<li>URL 钓鱼攻击</li>
</ul>

<p>
如下图示例：用户登录了被攻击的服务器，比如微博的服务器，然后他收到了攻击者发送给他的一个含有恶意脚本的 URL，这个 URL 是指向微博服务器的。用户点击恶意 URL 以后，就会把 URL 提交给微博的服务器，同时这段 URL 里面还包含了一段可执行的恶意脚本，这个脚本也会被客户端去执行。在这个恶意脚本里面，会强制用户关注某个特定的微博账号，并发送一条含有恶意脚本的微博，当其他用户浏览点击微博的时候，会再一次执行同样的动作，以此来达到攻击不断扩散的目的。
</p>


<figure id="org97d6195">
<img src="./images/CgotOV2-U5-APAI9AAH0MZs8utQ950.png" alt="CgotOV2-U5-APAI9AAH0MZs8utQ950.png"> 

</figure>

<ul class="org-ul">
<li>直接攻击</li>
</ul>

<p>
除了通过上述 URL 钓鱼的方式进行攻击，还有一种攻击方式是，恶意的攻击者直接攻击被攻击的服务器。
</p>


<p>
如下图所示，攻击者发送一个含有恶意脚本的请求给被攻击的服务器，比如通过发布微博的方式向微博的服务器发送恶意请求，被攻击的服务器将恶意脚本存储到本地的数据库中，其他正常用户通过被攻击的服务器浏览信息的时候，服务器会读取数据库中含有恶意脚本的数据，并将其展现给正常的用户，在正常用户的浏览器上执行，从而达到攻击的目的。
</p>


<figure id="org8fb23fd">
<img src="./images/CgoB5l2-U5-AEfJkAAGAPrbp3mA831.png" alt="CgoB5l2-U5-AEfJkAAGAPrbp3mA831.png">

</figure>
</div>
</div>
<div id="outline-container-h:b7497e71-afe9-4655-aa0c-f2b63942884f" class="outline-4">
<h4 id="h:b7497e71-afe9-4655-aa0c-f2b63942884f">XSS 攻击防御</h4>
<div class="outline-text-4" id="text-h:b7497e71-afe9-4655-aa0c-f2b63942884f">
<p>
XSS 攻击防御的主要手段有以下几种。
</p>

<ul class="org-ul">
<li>消毒</li>
</ul>

<p>
检查用户提交的请求中是否含有可执行的脚本，因为大部分的脚本都需要用尖括号等脚本语法，因此大部分的攻击也都包含尖括号这样的脚本语法，所以可以通过 HTML 转义的方式，比如把“&gt;”转义为“&amp;gt”这样的转义 HTML 字符，HTML 显示的时候还是正常的”&gt;“，但是这样的脚本无法在浏览器上执行，也就无法达到攻击的目的。
</p>

<ul class="org-ul">
<li>HttpOnly</li>
</ul>

<p>
此外，XSS 攻击的目的是想利用客户端浏览器的权限去执行一些特定的动作，而这种权限通常是需要依赖 Cookie 的，所以可以通过限制脚本访问 Cookie，从而达到防止攻击的目的。也就是在 Cookie 上设置 HttpOnly 的属性，使恶意脚本无法获取 Cookie，避免被攻击脚本攻击。
</p>
</div>
</div>
<div id="outline-container-h:ce2e6419-13b6-4dab-9cfd-5dc987973ac2" class="outline-4">
<h4 id="h:ce2e6419-13b6-4dab-9cfd-5dc987973ac2">SQL 注入攻击</h4>
<div class="outline-text-4" id="text-h:ce2e6419-13b6-4dab-9cfd-5dc987973ac2">
<p>
SQL 注入是另外一种常见的攻击手段。恶意的攻击者在提交的请求参数里面，包含有恶意的 SQL 脚本。
</p>

<p>
如下图示例，在需要输入的参数 username 里面，注入了另外一条 SQL 语句“drop table users”，这是一条删除 users 表的命令。如果程序根据输入参数进行 SQL 构造，那么构造出来的就是这样两条 SQL：一条是 Select 根据用户名进行查询的 SQL 语句；另一条 SQL 就是删除 users 表。当这样的两条 SQL 被提交到数据库以后，数据库 user 表就会被删除，从而导致系统瘫痪。
</p>


<figure id="org7ef1558">
<img src="./images/CgotOV2-U5-AGWNPAAJUvYRCOyo547.png" alt="CgotOV2-U5-AGWNPAAJUvYRCOyo547.png">

</figure>
</div>
</div>
<div id="outline-container-h:18333c6f-ef43-4a8b-9117-bb746f5bde95" class="outline-4">
<h4 id="h:18333c6f-ef43-4a8b-9117-bb746f5bde95">SQL 攻击防御</h4>
<div class="outline-text-4" id="text-h:18333c6f-ef43-4a8b-9117-bb746f5bde95">
<ul class="org-ul">
<li>消毒</li>
</ul>

<p>
解决 SQL 注入的手段，一种手段是消毒。通过拦截请求中的数据，对请求数据进行正则表达式匹配，如果请求数据里面包含有某些 SQL 语句，比如“drop table”，那么就对这些语句进行转义和消毒，插入一些特定的不可见字符或者进行编码转换，使其无法在数据库上执行，从而达到防御攻击的目的。
</p>

<ul class="org-ul">
<li>参数绑定</li>
</ul>

<p>
但是在实践中最常用、最有效、最高效的是第二种，通过 SQL <code>预编译手段</code> ，即将 SQL 命令和输入参数绑定，防止将输入参数中的数据当作 SQL 执行。也就是说访问数据库的 SQL，通过预编译的方式已经提交到了数据库，数据库收到请求参数以后，只会按照特定的 SQL 参数，按照已经编译好的执行命令去执行，所有提交的数据都会被当作参数，而不会当作 SQL 语句去执行。目前很多常用的 Web 数据库访问框架，比如 MyBatis、Hibernate 等 ORM 框架，都支持 SQL 预编译和参数绑定，能够避免 SQL 注入攻击。
</p>
</div>
</div>
<div id="outline-container-h:730701e7-d683-4c30-ad3f-cdfd320c10b0" class="outline-4">
<h4 id="h:730701e7-d683-4c30-ad3f-cdfd320c10b0">CSRF 攻击</h4>
<div class="outline-text-4" id="text-h:730701e7-d683-4c30-ad3f-cdfd320c10b0">
<p>
还有一种常见的攻击是跨站点请求伪造
CSRF，跨站请求伪造的攻击方式如下图所示。
</p>


<figure id="org0f27616">
<img src="./images/CgoB5l2-U5-Ad1inAAF_4377E24493.png" alt="CgoB5l2-U5-Ad1inAAF_4377E24493.png">

</figure>

<p>
用户先登录受信任的服务器，然后又访问了被攻击的服务器。被攻击了的服务器返回的响应里面包含着用户访问受信任的服务器的请求，用户在不知情的情况下执行了请求，从而达到了攻击者的目的。
</p>
</div>
</div>
<div id="outline-container-h:6f4b14c8-6872-46d6-b427-1c42662eab4a" class="outline-4">
<h4 id="h:6f4b14c8-6872-46d6-b427-1c42662eab4a">CSRF 攻击防御</h4>
<div class="outline-text-4" id="text-h:6f4b14c8-6872-46d6-b427-1c42662eab4a">
<ul class="org-ul">
<li>表单 Token</li>
</ul>

<p>
跨站请求伪造的防御手段，一种是使用表单 Token。要达到 CSRF 跨站请求伪造，用户必须要构造出来受信任站点的完整的请求参数才能够进行请求，那么如果请求参数是必须要在当前浏览器或者是应用中生成的，比如请求中包含必须要在特定场景下生成的 Token 才能够发送的请求，这样攻击者就无法构造这个 Token，也就无法进行攻击。通常这样的 Token 利用时间戳、用户设备指纹、页面内容等多方数据进行计算，服务器在收到请求后，对请求包含的 Token 进行校验，确定是否是合法的 Token，只有包含合法Token 的请求才会被执行。
</p>

<ul class="org-ul">
<li>验证码</li>
</ul>

<p>
另一种手段就是用验证码。CSRF 攻击是在用户不知情的情况下，去请求受信任的服务器，达到自己的攻击目的。对于一些比较敏感的操作，比如关于资金方面的操作，那么可以要求用户输入图片验证码或者手机验证码，才能够完成。这个时候用户就会发现自己被攻击了，避免执行被攻击的请求，从而防御 CSRF 攻击。
</p>
</div>
</div>
<div id="outline-container-h:b94e8d00-7000-420a-92c5-3ef6bd7cb08e" class="outline-4">
<h4 id="h:b94e8d00-7000-420a-92c5-3ef6bd7cb08e">Web 应用防火墙</h4>
<div class="outline-text-4" id="text-h:b94e8d00-7000-420a-92c5-3ef6bd7cb08e">
<blockquote>
<p>
大部分的攻击都可以在请求和响应阶段进行拦截处理，设置统一的 web 应用
防火墙即可，如开源防火墙 ModeSecurity
</p>
</blockquote>

<p>
大部分的攻击都可以在请求和响应阶段进行拦截处理，所以不用每个程序自己去独立处理。在应用网关或者在请求接入的时候，可以设置一个统一的 Web 应用防火墙，对所有的请求响应进行拦截处理。
</p>


<p>
ModSecurity 就是这样一个开源的 Web 应用防火墙，如下图所示。它能够探测攻击并保护应用系统，既可以嵌入到 Web 应用服务器之内，也可以作为一个独立的应用程序启动。ModSecurity 最早是 Apache 服务器的一个模块，现在已经有了 Java、.net 多个版本，并且支持 Nginx。
</p>

<p>
ModSecurity 本身的架构设计也非常值得借鉴。ModSecurity 采用处理逻辑与规则集合分离的架构模式。处理逻辑负责请求和响应的拦截过滤、规则加载执行等功能。而规则集合则负责对具体的攻击的规则定义、模式识别、防御策略等功能。处理逻辑比较稳定，规则集合需要不断针对漏洞进行升级，这是一种可扩展的架构设计。
</p>
</div>
</div>
</div>
<div id="outline-container-h:6ebbb268-46c7-4aa0-9cc6-c84324baa6c6" class="outline-3">
<h3 id="h:6ebbb268-46c7-4aa0-9cc6-c84324baa6c6">信息加解密</h3>
<div class="outline-text-3" id="text-h:6ebbb268-46c7-4aa0-9cc6-c84324baa6c6">
<p>
再看信息加解密技术。信息加解密技术主要分为三类，单向散列加密、对称加密和非对称加密。
</p>
</div>
<div id="outline-container-h:53b1d872-2663-4365-864a-8ce60ef0c161" class="outline-4">
<h4 id="h:53b1d872-2663-4365-864a-8ce60ef0c161">单向散列加密</h4>
<div class="outline-text-4" id="text-h:53b1d872-2663-4365-864a-8ce60ef0c161">
<p>
所谓的单向散列加密是指对一串明文信息进行单向散列加密以后，得到的密文信息是不可以解密的，也就是说给定一个密文，即使是加密者也无法知道它的明文是什么，加密是单向的，不支持解密。
</p>

<p>
单向散列加密的主要应用场景就是应用到用户密码加密上。我们知道将用户密码的明文直接存储到数据库中是比较危险的，如果数据库被内部员工泄露，或者是被黑客拖库以后，那么用户的密码就会被暴露出去。所以对用户密码进行解密是没有意义的，反而会造成密码不安全，事实上现在一般的应用系统都是 <code>对数据库的密码采用单向散列加密的方式进行保护</code> 的。
</p>

<p>
主要过程如下面架构时序图所示。用户在注册的时候需要输入密码，应用服务器得到用户输入的密码以后， <code>调用单向散列加密算法，对密码进行加密，然后将加密后的密文存储到数据库中去</code> 。用户下一次登录的时候，用户在客户端依然需要输入密码，用户输入的密码发送到 Web 服务器以后，Web 服务器对输入的密码再进行一次单向散列加密，得到密文，然后和从数据库中取出来的密文进行对比，如果两个密文是相同的，那么用户的登录验证就是成功的。通过这种手段，既可以保证用户密码的安全性，也实现了对用户的身份认证。
</p>


<figure id="org8dc97c9">
<img src="./images/CgoB5l2-U5-AcudWAAGIU2NMq0c882.png" alt="CgoB5l2-U5-AcudWAAGIU2NMq0c882.png"> 

</figure>

<p>
因为常用单向散列算法，就这么几种，而用户常用的密码组合，也有一定的重复性，比如根据生日设置密码，根据姓名拼音设置密码等等，所以如果有足够多的密码明文和密文，建立一个明文和密文之间的映射表，虽然通过密文无法解密计算出来明文，但是知道密文以后，可以通过查表的方式去查找出来明文是什么。
</p>

<p>
所以现在常用的单向散列加密，不但使用算法进行加密，还在算法上加一些盐，其实也是类似于密钥一样性质的东西，如下图。这样不同的加盐参数加出来的密文，即使是有了明文和密文的映射表，也无法通过密文和映射表去查找得到明文了。
</p>


<figure id="orgadaacf0">
<img src="./images/CgotOV2-U5-AYegaAAAcHRFTHS4534.png" alt="CgotOV2-U5-AYegaAAAcHRFTHS4534.png">

</figure>
</div>
</div>
<div id="outline-container-h:2a1d2a9a-89cb-460e-80f8-411aaa645e39" class="outline-4">
<h4 id="h:2a1d2a9a-89cb-460e-80f8-411aaa645e39">对称加密</h4>
<div class="outline-text-4" id="text-h:2a1d2a9a-89cb-460e-80f8-411aaa645e39">
<p>
对称加密，顾名思义，使用一个加密算法和一个密钥，对一段明文进行加密以后得到密文，然后使用相同的密钥和对应的解密算法，对密文进行解密，就可以计算得到明文，如下图所示。对称加密主要用于加密一些敏感信息，对密文进行信息传输和存储，但是在使用的时候，必须要解密得到明文信息的一些场景。
</p>


<figure id="orgdc98251">
<img src="./images/CgoB5l2-U5-ALoRLAAA-AyJGXjc412.png" alt="CgoB5l2-U5-ALoRLAAA-AyJGXjc412.png">

</figure>

<p>
比如说用户的信用卡卡号，很多互联网电商网站支持用户使用信用卡进行支付，把用户的信用卡信息存储在自己的服务器，当用户支付的时候，直接用信用卡信息和银行通信，完成信用卡扣款支付。用户的信用卡卡号等信息需要在交易的时候，跟银行进行支付认证。但是如果直接把信用卡号、有效期、安全码存储在数据库中，是比较危险的，所以必须要对它进行加密。在数据库中存储密文，在使用的时候又必须要对密码进行解密，还原得到明文，才能够正常使用。所以这个时候就要使用对称加密算法，在存储的时候使用加密算法进行加密，在使用的时候使用解密算法进行解密。
</p>
</div>
</div>
<div id="outline-container-h:43d3b844-a82f-4275-887d-a54cb1d4b516" class="outline-4">
<h4 id="h:43d3b844-a82f-4275-887d-a54cb1d4b516">非对称加密</h4>
<div class="outline-text-4" id="text-h:43d3b844-a82f-4275-887d-a54cb1d4b516">
<p>
所谓的非对称加密是指在加密的时候使用一个加密算法和一个加密密钥进行加密，得到一个密文，在解密的时候，必须要使用解密算法和解密密钥进行解密才能够还原得到明文，加密密钥和解密密钥完全不同，如下图所示。非对称加密的典型应用场景，就是我们常见的 HTTPS。HTTPS 加密就是一种非对称加密，用户在客户端进行网络通讯的时候，对数据使用加密密钥和加密算法进行加密，得到密文。到了数据中心的服务器以后，使用解密密钥和解密算法进行解密，得到明文。
</p>


<figure id="org58d7f1e">
<img src="./images/CgotOV2-U6CAZlouAACNianvVaY708.png" alt="CgotOV2-U6CAZlouAACNianvVaY708.png">

</figure>

<p>
在 HTTPS 这个场景中，由于所有的用户都要获得加密密钥，才能够对自己的明文进行加密，所以加密密钥通常也被叫作公钥，意思就是公开的密钥，谁都可以获得得到。但是解密密钥只有互联网系统后端服务器才能够拥有，只能由数据中心的服务器使用，所以也叫作私钥，也就是说谁都可以加密，但是只有自己才能解密，通过这种方式实现网络的安全传输，因为公钥本身就是公开的，所以也不需要担心密钥泄漏。同时由于公钥是对所有用户公开的，为了保证公钥本身的安全性和权威性，通常 HTTPS 的公钥和私钥使用权威的 CA 认证中心颁发的密钥证书。
</p>

<p>
使用非对称加密，还可以实现数字签名。用数字签名的时候是反过来的，自己用私钥进行加密，得到一个密文，但是其他人可以用公钥将密文解开，因为私钥只有自己才拥有，所以等同于签名。一段经过自己私钥加密后的文本，文本内容就等于是自己签名认证过的。
</p>
</div>
</div>
</div>
<div id="outline-container-h:5d8b6f1c-1e6e-4078-9a56-ae0b8376a007" class="outline-3">
<h3 id="h:5d8b6f1c-1e6e-4078-9a56-ae0b8376a007">信息过滤与反垃圾</h3>
<div class="outline-text-3" id="text-h:5d8b6f1c-1e6e-4078-9a56-ae0b8376a007">
<p>
接下来看信息过滤与反垃圾，包括分类算法和布隆过滤器黑名单。
</p>
</div>
<div id="outline-container-h:790fb3fe-8a27-4e85-b48f-a4d1f77d52c8" class="outline-4">
<h4 id="h:790fb3fe-8a27-4e85-b48f-a4d1f77d52c8">分类算法</h4>
<div class="outline-text-4" id="text-h:790fb3fe-8a27-4e85-b48f-a4d1f77d52c8">
<p>
分类算法，来看常用的贝叶斯分类算法，贝叶斯分类算法可以解决概率论中的一个典型问题。
</p>

<p>
如果有两个箱子，一号箱子里面放着红色球和白色球各 20 个，二号箱放有白色球 10 个，红色球 30 个。现在随机挑选一个箱子，取出来 1 个球的颜色是红色的，那么请问这只球来自于一号箱子的概率是多少？解决这类问题的方法就是使用条件概率，条件概率公式如下所示。
</p>

\begin{equation*}
P(B|A) = \frac {P(A|B)P(B)}{P(A)}
\end{equation*}

<p>
方程式左边 P(B|A) 表示的是在 A 条件发生的情况下，B 发生的概率是多少？在上图这个例子中，A 就是红色球，B 就是一号箱，P(B|A) 也就是问题中，在取出红色球的情况下，该球来自一号箱的概率是多少？计算公式是 P(A|B) 乘以 P(B) 除以 P(A)，P(A|B) 是在一号箱中有红色球的概率，P(B) 是一号箱的概率，P(A) 是红色球的概率。也就是一号箱中有红色球的概率乘以一号箱的概率，再除以红色球的概率，来得到取出红色球的情况下是一号箱的概率。
<b>分类算法构建垃圾邮件分类系统</b>
</p>

<p>
实践中我们会使用贝叶斯分类算法进行垃圾邮件的识别。比如说我们统计现有的邮件，将邮件分为垃圾邮件和非垃圾邮件两类，然后再统计垃圾邮件中包含的文本特征的概率，以及非垃圾邮件中文本特征的概率。那么当我们收到一份邮件的时候，我们就可以根据这份邮件中的文本特征概率去计算它是垃圾邮件的概率。在这个例子里面，P(A) 是邮件中的文本特征，P(B) 就是垃圾邮件的概率，使用分类算法，根据文本特征计算垃圾邮件的概率。垃圾邮件过滤的整个的流程，如下图所示。
</p>


<figure id="orga440c3d">
<img src="./images/CgotOV2-U6CABOIAAABoSO-2jbU539.png" alt="CgotOV2-U6CABOIAAABoSO-2jbU539.png">

</figure>

<p>
我们先对当前的邮件进行人工分类，分为垃圾邮件和非垃圾邮件两类，然后将这两类邮件输入分类算法进行训练，训练得到 P(A)、P(B) 以及 P(A|B) 这些概率值，然后当一份新邮件到达的时候，也就是待处理邮件到达的时候，我们将待处理邮件带入分类算法进行计算，也就是计算 P(B|A) 的值，然后根据计算出来的值，判断它是垃圾邮件还是正常邮件。
</p>

<p>
通过分类算法我们可以识别出来一份邮件是垃圾邮件还是非垃圾邮件。如果是垃圾邮件，那么发送垃圾邮件的邮箱地址通常也会被标记为黑名单地址，需要记录下来。对于一个邮箱系统而言，需要管理的黑名单是非常庞大的，如何管理这样庞大的一组黑名单邮箱的地址，最直观的解决手段就是使用哈希表。但是如果数量特别庞大，那么哈希表也会非常庞大，需要占用大量的内存空间。事实上，我们对黑名单里面这些邮件地址并不关心，我们只需要关心，一个邮件到达以后，它的发件人地址是不是在黑名单里就可以了。
</p>
</div>
</div>
<div id="outline-container-h:70a56721-b775-43b6-bbe1-e8318609574d" class="outline-4">
<h4 id="h:70a56721-b775-43b6-bbe1-e8318609574d">布隆过滤器</h4>
<div class="outline-text-4" id="text-h:70a56721-b775-43b6-bbe1-e8318609574d">
<p>
更简单的办法就是使用布隆过滤器这样一种手段去记录邮箱地址黑名单。
</p>

<p>
如下图所示，布隆过滤器的算法实现是这样的。首先它开辟一块巨大的连续存储空间，比如说开辟一个 16G 比特的连续存储空间，也就是 2G 大的一个内存空间，并将这个空间所有比特位都设置为 0。然后对每个邮箱地址使用多种哈希算法，比如使用 8 种哈希算法，分别计算 8 个哈希值，并保证每个哈希值是落在这个 16G 的空间里的，也就是，每个 Hash 值对应 16G 空间里的一个地址下标。然后根据计算出来的哈希值将对应的地址空间里的比特值设为 1，这样一个邮箱地址就可以将 8 个比特位设置为 1。当检查一个邮箱地址是否在黑名单里的时候，只需要将邮箱地址重复使用这 8 个哈希算法，计算出 8 个地址下标，然后检查这 8 个地址下标里面的二进制数是否全是 1，如果全是 1，那么表示它就是在黑名单里头。使用布隆过滤器，记录同样大小的邮箱黑名单，可以比使用哈希表节约更多的内存空间。
</p>


<figure id="org7184650">
<img src="./images/CgoB5l2-U6CAA1dEAAHPmdNExmE018.png" alt="CgoB5l2-U6CAA1dEAAHPmdNExmE018.png">

</figure>

<p>
使用布隆过滤器需要注意的是，该过滤器存在误杀的情况。也就是说，一个非黑名单邮箱地址对应的 8 个比特位的值，正好被其它的黑名单邮箱地址都设为 1 了。那么在检查比特位时，该邮箱地址就会被误认为黑名单邮箱，被错误拦截。
</p>
</div>
</div>
</div>
<div id="outline-container-h:5a3aa948-8af7-42bd-ade2-06bd8fe7da21" class="outline-3">
<h3 id="h:5a3aa948-8af7-42bd-ade2-06bd8fe7da21">总结回顾</h3>
<div class="outline-text-3" id="text-h:5a3aa948-8af7-42bd-ade2-06bd8fe7da21">
<pre class="example" id="orgaef449a">
XSS 攻击--&gt;SQL注入攻击--&gt;CSRF攻击--&gt;
web防火墙--&gt;加密--&gt;信息过滤与反垃圾
</pre>

<p>
回顾本节内容如下。
</p>

<ol class="org-ol">
<li>主要的几种攻击方式，XSS 攻击、SQL 注入攻击和 CSRF 攻击。这三种攻击方式占了 Web 攻击 90% 以上的攻击。解决方案有消毒、SQL 预编译参数绑定、验证码等常用手段，而所有这些攻击都可以通过使用统一的 Web 应用防火墙去解决。</li>

<li>加密的几种常用算法：单向散列加密，主要应用场景是用户密码加密、存储；还有对称加密，加密密钥和解密密钥相同，主要是对敏感信息进行加密，比如信用卡；非对称加密的主要应用场景就是 HTTPS，它的加密密钥和解密密钥是不同的。</li>

<li>此外在信息过滤和反垃圾中，我们学习了两个算法，一个是贝叶斯分类算法，一个是布隆过滤器算法，前者通过邮件内容去检查邮件是否为垃圾邮件，后者利用较小的内存空间记录垃圾邮件地址黑名单。</li>
</ol>

<p>
以上就是本节的内容。在这个越来越重视信息安全的时代，做出更加安全的系统也就显得尤为重要。下一章节主要分享一些架构案例。
</p>
</div>
</div>
</section>
<section id="outline-container-h:4739bef2-a008-4efe-a974-9154dc326a8e" class="outline-2">
<h2 id="h:4739bef2-a008-4efe-a974-9154dc326a8e">第09讲：架构实战案例分析</h2>
<div class="outline-text-2" id="text-h:4739bef2-a008-4efe-a974-9154dc326a8e">
<form><input type="button" value="音频" onclick="doSound(9); return false;"></form>
<span id="dummy9"></span>

<blockquote>
<ol class="org-ol">
<li>初创互联网公司架构演化案例</li>
<li>分布式存储系统Doris架构案例</li>
<li>反应式编程框架Flower架构案例</li>
</ol>
</blockquote>

<p>
本章节的主题是架构案例分享，通过案例分析来加深对前面所学内容的理解。下面将分析三种不同的系统架构案例。
</p>

<ol class="org-ol">
<li>分析初创互联网公司的架构演化案例，看一个小的系统架构是如何演化成一个较为成熟的、能够承受百万级订单的互联网系统架构。</li>

<li>分析一个分布式存储的架构案例，看如何去设计一个分布式存储系统，底层存储系统的架构是如何设计的。</li>

<li>分析一个反应式编程框架的架构案例，看开发框架的架构是如何设计的。</li>
</ol>

<p>
这三类系统架构是三种比较典型的架构设计，对设计的要求很不一样，对架构师能力的考验也不太相同。了解这三种不同的架构设计，可以对架构师的工作有一个比较全面的认知。
</p>
</div>
<div id="outline-container-h:ab1990c2-c844-448f-82c9-1e5ca2fa958e" class="outline-3">
<h3 id="h:ab1990c2-c844-448f-82c9-1e5ca2fa958e">初创互联网公司架构演化案例</h3>
<div class="outline-text-3" id="text-h:ab1990c2-c844-448f-82c9-1e5ca2fa958e">
<p>
首先看初创互联网公司架构演化案例。
</p>
</div>
<div id="outline-container-h:bcc3fc08-7877-4b53-9443-cc5e371f0c35" class="outline-4">
<h4 id="h:bcc3fc08-7877-4b53-9443-cc5e371f0c35">万级日订单级别架构</h4>
<div class="outline-text-4" id="text-h:bcc3fc08-7877-4b53-9443-cc5e371f0c35">
<p>
如下图，这是一个真实的校园互联网电商系统的架构。在早期的时候，每天处理 1万 左右的用户订单，这时候的系统架构如图所示，还是比较简单的。
</p>


<figure id="org9f3dd8f">
<img src="./images/CgotOV2-U0mAF53OAAINSMa5La8843.png" alt="CgotOV2-U0mAF53OAAINSMa5La8843.png">

</figure>

<p>
分析上图架构。应用端主要是移动端的应用，通过负载均衡访问 Web 服务器集群，也就是前端集群。前端集群是两台 Nginx 服务器组成的，在 Nginx 再进行一次负载均衡，将用户请求分发到一组应用服务器集群。应用服务器集群按照应用场景分为买家系统、卖家系统、供应链系统以及运营系统四个系统集群，每个系统集群又包含了若干台服务器，所有这些系统都连接到一台 MySQL 服务器上。
</p>
</div>
</div>
<div id="outline-container-h:a40c6891-25aa-48c3-8003-e6d8a8f329cb" class="outline-4">
<h4 id="h:a40c6891-25aa-48c3-8003-e6d8a8f329cb">十万级日订单级别架构</h4>
<div class="outline-text-4" id="text-h:a40c6891-25aa-48c3-8003-e6d8a8f329cb">
<p>
但是这样的系统在几千订单的时候运行还算可以，但是在交易比较活跃、并发比较高的时候，系统就会出现各种问题。在上图示例中，当时的市场总监说”我们的交易越忙，你们的系统越出问题，太邪门了。“当时我们也没敢说什么，技术部悄悄对系统做了一次改进和重构，主要优化系统架构方面。优化后的架构如下图。
</p>


<figure id="orgbf52897">
<img src="./images/CgoB5l2-U0mAZNLbAAJoBiLgC_k168.png" alt="CgoB5l2-U0mAZNLbAAJoBiLgC_k168.png">

</figure>

<p>
主要优化点之一是在前端使用 CDN 服务，这样用户请求的各种静态资源都通过 CDN 服务返回，而所有的商品图片，再通过一个分布式文件系统进行管理。商品图片的上传和浏览，都由分布式文件系统提供。
</p>

<p>
在应用服务器集群上又加了一个 Redis 集群。我们前面说过，提升应用系统性能的第一个手段就是使用缓存。Redis 集群的使用，包括前面的 CDN 以及分布式文件系统，极大地缓解了系统在访问高峰期的访问压力。同时我们对 MySQL 数据库还做了一次主从复制的分离，构建了一个一主两从的分布式数据库。两个从服务器，一个从服务器用来给应用服务器用来做读操作服务，另一个从服务器做 SQL 数据分析，有时候也会通过 Sqoop 将数据导出到大数据平台上，做大数据计算。
</p>

<p>
在十万订单的时候，除了系统交易本身的压力比较大，公司对数据的处理的要求也比较高。除了各种各样的统计分析、竞对分析，还有各市场大区的绩效、具体到每个人的绩效都需要进行统计计算，所以专门搭建了一个大数据平台。在大数据平台上，根据业务数据进行统计分析和运营预测，还根据运营数据进行绩效考核。大数据平台上的数据一部分来自于应用服务器，通过消息队列 Kafka 导入到大数据平台，另一部分数据是来自于 MySQL 从数据库导入到大数据平台。通过这样一次系统重构，系统可以满足十万级日订单的访问压力。
</p>
</div>
</div>
<div id="outline-container-h:585e1efc-0671-415e-9f47-11070b4f59d4" class="outline-4">
<h4 id="h:585e1efc-0671-415e-9f47-11070b4f59d4">百万级日订单级别架构</h4>
<div class="outline-text-4" id="text-h:585e1efc-0671-415e-9f47-11070b4f59d4">
<p>
但是随着业务的进一步的发展，系统的订单量还在快速增长，这时候主要的挑战来自于两个方面。一个方面是随着订单的增长，业务也变得越来越复杂，开发新的功能变得越来越困难，系统的基本功能维护也越来越困难。另一个方面是，虽然经过了主从分离以及部署了多种缓存以后，高峰期的数据访问压力也可以承受了，但是数据库的存储空间难以满足要求。对于一个日订单百万级的系统，年订单量就是数亿，这样大的数据库存储对于 MySQL 而言是难以承受的。
</p>

<p>
所以我们对系统进行了进一步的重构。这次重构主要是两个方面，如下图。
</p>


<figure id="org1973aba">
<img src="./images/CgotOV2-U0mASlTuAALexN14sdY634.png" alt="CgotOV2-U0mASlTuAALexN14sdY634.png">

</figure>

<ul class="org-ul">
<li>微服务拆分</li>
</ul>

<p>
一方面是做了一个微服务方面的重构拆分，将可复用的一些业务拆分为独立的微服务，进行分布式部署，供应用系统调用，典型的就是用户服务、商品服务、订单服务、红包服务等。以前红包作为一个功能，在各个应用系统中可能都有涉及，买家需要使用红包，卖家要发放红包，而运营系统也可能发放系统级的红包，而这些红包的功能在各个子系统都有存在，所以对红包功能进行维护修改的时候，可能在很多个系统都要进行相关的代码变更和维护。产品经理需要跟几个系统开发团队进行合作，开发一个功能一不小心就可能会产生Bug。
</p>

<p>
重构以后，红包服务作为一个独立的功能，独立部署，其他的所有系统都通过远程调用的方式访问红包服务。红包的发放使用，以及红包的各种记录都通过红包服务进行管理，其他的应用只需要调用服务接口就可以了。如果要修改红包服务相关的功能，进行业务变更，那么大多数情况下只需要修改红包服务就可以。这样使业务系统开发变得更加的简单，因为红包功能相对比较集中，也更容易实施和落地。
</p>

<ul class="org-ul">
<li>数据库冷热分离</li>
</ul>

<p>
另一方面是，对数据库在原来的主从分离的基础上又做了一次冷热分离。因为我们刚才提到经过主从分离后的数据库，读写访问压力已经可以接受，这时候，主要压力来自于订单的持续不断增长和数据表记录的不断扩展，带来的存储方面的压力。而订单的一个特点是当订单已经完成，订单状态被关闭以后，订单就是只读的。这个时候只需要能够对订单提供查询、读服务就可以了，无需为它提供事务性写操作，那么我们就可以从比较宝贵的
MySQL
数据库资源中，把这些已经关闭了的订单分离出来，存储到更容易进行分步式存储的其他的
NoSQL 系统上。
</p>

<p>
当时我们选择了 MongoDB 作为订单数据的冷存储。每天夜里运行批处理任务，执行一个冷订单备份的迁移操作，将已经关闭一个月以上的订单数据，从 MySQL  数据库中迁移到了 MongoDB 中。而订单服务在进行订单操作的时候，所有的写操作依然访问 MySQL 数据库。对于读操作，如果要是查询一个月以内的订单，也还是访问 MySQL 从数据库，而如果是需要查询一个月以上的订单，那么就访问 MongoDB 数据库就好了。
</p>

<p>
通过这样一个冷热分离来设计数据库，只存储最近一个月的数据，存储访问的压力、数据存储的压力大大的减轻。
</p>

<p>
以上就是一个校园电商的互联网创业项目，在 2015 年的时候，这个项目快速发展，一年之内进行了三轮融资，融资规模从几十万美元到几千万美元，系统也由一开始的一个较为简单的系统，在一年之内进行了三次架构重构，演化成这样一个较为复杂功能较为齐全的系统架构。
</p>
</div>
</div>
</div>
<div id="outline-container-h:2583d131-2e4a-496c-b8b7-1dcaf6868451" class="outline-3">
<h3 id="h:2583d131-2e4a-496c-b8b7-1dcaf6868451">分布式存储系统 Doris 架构案例</h3>
<div class="outline-text-3" id="text-h:2583d131-2e4a-496c-b8b7-1dcaf6868451">
<p>
再看一个分布式存储系统 Doris
的架构案例。上面是一个互联网应用系统整体的架构，而应用系统是由各种各样的系统组件组成的，它包括业务组件，也包括一些技术组件。比如说像分布式数据存储这样的存储技术组件，那么这些分布式系统技术组件自身又是如何进行架构设计的呢？
</p>
</div>
<div id="outline-container-h:bd8723cc-a506-485e-acd9-ed0ca9e2656d" class="outline-4">
<h4 id="h:bd8723cc-a506-485e-acd9-ed0ca9e2656d">Doris 设计目标</h4>
<div class="outline-text-4" id="text-h:bd8723cc-a506-485e-acd9-ed0ca9e2656d">
<p>
Doris 是一个典型的分布式存储系统，它的设计目标如下。
</p>

<ol class="org-ol">
<li>进行海量的数据存储，也就是说可以在大规模服务器的集群上进行数据存储，可以进行透明的集群管理。</li>

<li>要求能够线性伸缩，当集群存储资源不足的时候，可以很容易地添加服务器到集群中，对集群进行平滑的扩容。</li>

<li>系统要高可用，要能够自动的容错和故障转移，当集群出现服务器宕机故障的时候，不会影响系统的读写，更不会出现数据丢失的情况。</li>

<li>同时要高性能，要在高并发的情况下，依然保持较低的响应时间。</li>

<li>还要具备灵活的扩展能力，可以很方便地扩展新功能。</li>

<li>要有较低的运维成本。可以在无需运维工程师的支持下进行集群的扩容、监控和故障管理。</li>
</ol>
</div>
</div>
<div id="outline-container-h:46d04933-e537-48d6-a01b-10becac843e9" class="outline-4">
<h4 id="h:46d04933-e537-48d6-a01b-10becac843e9">Doris 的整体架构</h4>
<div class="outline-text-4" id="text-h:46d04933-e537-48d6-a01b-10becac843e9">
<p>
如下图，来看 Doris 的整体架构。
</p>


<figure id="orge5803ee">
<img src="./images/CgoB5l2-U0qANU5NAAOpllJww24954.png" alt="CgoB5l2-U0qANU5NAAOpllJww24954.png">

</figure>

<p>
Doris 的整体架构包括三个部分。
</p>

<ol class="org-ol">
<li>客户端。Doris 给应用程序提供一个客户端的 SDK 包，客户端可以使用 Doris SDK 进行分布式的数据读写操作，Doris 支持存储 Key Value 这样的 KV 数据结构，跟缓存一样。客户端一方面连接 Doris 集群的控制中心 Administration，从控制中心获得配置信息，主要是获得服务器集群的地址端口、角色等配置信息，另一方面获得路由算法信息。</li>

<li>Administration。可以通过控制台进行集群的故障管理和扩容管理。</li>

<li>Data Server 数据存储。Data Server 也是真正的分布式数据存储的地方，Doris 对数据进行分片存储的。根据集群规模、配置信息和算法进行路由计算，计算每个 KV 应该存储的的 Data Server 服务器。Data Server 服务器也和 Administration 服务器进行通信，报告自己的健康状况。应用程序的 KV Client 与 Administration 之间的通讯，只包括配置或者控制信息的通信，不会进行数据通讯，也就是说真正的数据读写操作，只会在 Client 和 Data Server 之间，不需要通过 Administration 进行数据代理。</li>
</ol>
</div>
</div>
<div id="outline-container-h:1ca6e171-5a00-4d9e-bdb0-f0ae2a4a8556" class="outline-4">
<h4 id="h:1ca6e171-5a00-4d9e-bdb0-f0ae2a4a8556">Doris 数据分区架构与分区算法</h4>
<div class="outline-text-4" id="text-h:1ca6e171-5a00-4d9e-bdb0-f0ae2a4a8556">
<p>
来看一下 Doris 比较有特点的核心架构设计。Doris 采用路由算法设计，也就是 Doris 的分区算法设计，如下图。
</p>


<figure id="orgd3123ba">
<img src="./images/CgotOV2-U0qABHM-AAJIWbX_Tr4770.png" alt="CgotOV2-U0qABHM-AAJIWbX_Tr4770.png">

</figure>

<p>
前面章节2的缓存部分中，提到路由分区的几种典型的算法，包括余数哈希以及一致性哈希算法等，其中一致性哈希算法有个重要的特点是使用了虚拟节点进行计算。而 Doris 则创造了一种余数哈希和虚拟节点相结合的哈希算法，如上图所示，也就是在 key 进行路由计算的时候，先针对虚拟节点进行一次余数哈希。这个时候会对一个较大的数进行取模，比如说 10万，对 10万 进行取模，计算得到一个虚拟节点。
</p>

<p>
然后对虚拟节点和物理节点进行一次关系映射，根据虚拟节点与物理节点之间的关系进行查找，寻找到真正要访问的物理节点，再将数据写入到这台物理服务器上。这种分区算法的设计，相比于一致性哈希有更好的负载平衡特性。
</p>

<p>
也就是说 key 在不同的物理服务器上的分布更加均衡，同时也更便于进行集群扩容，因为当添加新的物理服务器的时候，如上图右边部分所示，只需要修改虚拟节点和物理服务器之间的映射关系就可以了，将一部分虚拟节点的映射调整到新的物理服务器上。比如说我们加了一个新的物理节点 PN3，那么我们把虚拟节点 VN3 和 VN6 两个虚拟节点的映射调整到 PN3 上，因此这种算法也能够实现和一致性哈希一样的效果，就是添加服务器的时候只影响一小部分数据。
</p>

<p>
同时这种算法在运维上有一个更大的好处，就是集群扩容的时候，运维调整可以按照虚拟节点进行调整，因为是以虚拟节点为单位重新映射到新的物理节点上。如果存储的时候就是按照虚拟节点为单位进行的存储，比如说一个虚拟节点一个文件，那么进行集群扩容的时候，只需要将虚拟节点对应的文件拷贝到新的服务器上，就可以实现集群扩容了。
</p>
</div>
</div>
<div id="outline-container-h:d3796a26-e293-4950-ad89-4dc095b5eec2" class="outline-4">
<h4 id="h:d3796a26-e293-4950-ad89-4dc095b5eec2">Doris 调用时序</h4>
<div class="outline-text-4" id="text-h:d3796a26-e293-4950-ad89-4dc095b5eec2">
<p>
接下来看 Doris 调用时序图，如下图。
</p>


<figure id="org96e9c51">
<img src="./images/CgoB5l2-U0qAbYcRAAEW8VNNGkQ788.png" alt="CgoB5l2-U0qAbYcRAAEW8VNNGkQ788.png"> 

</figure>

<p>
Doris 调用时序是指，Doris 在架构上，为了保证高可用，将所有的服务器分为多个组，这个组在 Doris 内部也被称为序列，每个序列存储一份数据，数据在写入的时候，每次都在不同的分组，也就是在不同的序列上进行存储，这样保证数据有多个备份存储，保证数据的高可用。
</p>

<p>
如上图所示，包含有 Doris 客户端 SDK 的应用服务器，先通过 SDK 访问管理中心服务器 Administration 获取集群的信息，以及获取应用的级别，应用的级别决定了数据要写多少个备份，示例中写两个备份，也就是将所有服务器分为两个序列。
</p>

<p>
SDK
根据这些信息以及刚才的路由算法，进行路由计算，计算在每个分组序列的服务器集群上要访问哪一台服务器。根据计算出来的结果，在每个序列中访问对应的服务器，比如说当前的可用性级别是
2，那么就访问这两个序列中的两台服务器，分别对每个序列中的每台服务器进行并发的数据写入，保证数据至少有两个备份存储。
</p>
</div>
</div>
<div id="outline-container-h:d59740b8-62cb-4817-9ac3-8af537f1d9be" class="outline-4">
<h4 id="h:d59740b8-62cb-4817-9ac3-8af537f1d9be">Doris 高可用架构</h4>
<div class="outline-text-4" id="text-h:d59740b8-62cb-4817-9ac3-8af537f1d9be">
<p>
再看 Doris 的高可用架构，如下图。
</p>


<figure id="org8fefba7">
<img src="./images/CgotOV2-U0qAcdbEAAGN2uR0aBc651.png" alt="CgotOV2-U0qAcdbEAAGN2uR0aBc651.png">

</figure>

<p>
当服务器有不可用时，Doris 是如何保证整个集群依然可以提供高可用的读写服务的呢？Doris 的高可用，主要解决两种问题。一种问题就是当系统临时出现故障的时候，比如说内存、网卡的临时损坏需要进行更换，或者是说程序升级发布需要临时停机，这些情况下系统如何保证高可用。另一种是系统永久失效，比如说硬盘损坏，上面的数据全部丢失，或者服务器过保需要下架，需要彻底更换服务器。这种情况下，系统如何保证高可用。
</p>

<p>
对前一种系统临时停机进行维护，这种情况叫做临时失效。Doris 主要解决方案是在系统临时失效的时候，应用程序依然保证多份写入。在进行临时实效维护的时候，只在其中一个序列的服务器上进行失效维护，另一个序列的服务器保证正常使用，而数据依然多份写入，正常序列的集群上的服务器依然正常读写，对已经失效的服务器，启动一个临时节点，进行备份写入，保证数据仍然是多份写入。
</p>

<p>
当过一段时间系统发布完成，服务器硬件更换完毕，失效系统重新启动，恢复运行以后，这时系统写入的时候会将数据写入到恢复中的服务节点，但是因为这段时间失效期间的数据是不完整的，所以读取只从原来正常的服务器上读取，正在恢复的服务器不读数据，同时将失效期间写入到临时备份节点的数据，迁移到正在恢复的服务器上，直到备份节点中的数据全部恢复完成。两个序列的服务器数据完全一致，这个时候系统恢复到正常。系统同时向两个服务器写入，而随机挑一台服务器进行读取。
</p>

<p>
与之相对，如果服务器永久下架，或者是硬盘损坏导致数据永久丢失，那么就无法通过临时时效节点进行数据恢复。解决的办法也比较暴力，直接将正常服务器中的数据，完整地拷贝一份到一台新服务器，代替损坏的物理服务器，就可以了。
</p>
</div>
</div>
</div>
<div id="outline-container-h:1d9a7a4d-0bcb-4a47-bb6c-238c8f33f9a6" class="outline-3">
<h3 id="h:1d9a7a4d-0bcb-4a47-bb6c-238c8f33f9a6">反应式编程框架 Flower 架构案例</h3>
<div class="outline-text-3" id="text-h:1d9a7a4d-0bcb-4a47-bb6c-238c8f33f9a6">
<p>
下面来看软件编程框架的架构设计案例。
</p>

<p>
除了上述系统这种整体的架构设计，还有一类架构，就是用来解决应用程序如何进行程序开发的。应用程序开发的时候，通常需要依赖各种编程框架进行开发，那么编程框架本身的设计会影响到开发的日常工作，大家日常开发中使用的各种 MVC 框架、ORM 框架，都是用来解决如何进行应用程序编程这些关键问题的。那么编程框架本身又是如何进行架构设计的，如何开发出来的？
</p>

<p>
目前反应式编程越来越流行，我们介绍一个反应式编程框架的架构设计案例-&#x2013;&#x2014;Flower。
</p>

<p>
Flower 是一个构建在 Akka 上的反应式编程框架，开发者只需要针对每一个细粒度的业务，开发一个 Service 服务，将这些 Service 服务，按照业务流程进行可视化的编排，就可以得到一个反应式的系统。
</p>
</div>
<div id="outline-container-h:555f8208-81b4-41e5-8af5-3ca801f1d83e" class="outline-4">
<h4 id="h:555f8208-81b4-41e5-8af5-3ca801f1d83e">反应式系统特性</h4>
<div class="outline-text-4" id="text-h:555f8208-81b4-41e5-8af5-3ca801f1d83e">
<p>
所谓反应式系统，包括以下四个方面的特性。
</p>

<ol class="org-ol">
<li>即时响应，应用的调用者可以即时得到响应，无需等到整个应用程序执行完毕，也就是说应用调用是非阻塞的。</li>

<li>回弹性，当应用程序部分功能失效的时候，应用系统本身能够进行自我修复，保证正常运行，保证响应，不会出现系统崩溃和宕机。</li>

<li>弹性，能够对应用负载压力做出响应，能够自动伸缩以适应应用负载压力，根据压力自动调整自身的处理能力，或者根据自身的处理能力，调整进入系统中的访问请求数量。</li>

<li>消息驱动，功能模块之间、服务之间，通过消息进行驱动，完成服务的流程。</li>
</ol>
</div>
</div>
<div id="outline-container-h:9a94c18f-b0a2-403a-9fb9-de1e50562a79" class="outline-4">
<h4 id="h:9a94c18f-b0a2-403a-9fb9-de1e50562a79">Flower 设计目标</h4>
<div class="outline-text-4" id="text-h:9a94c18f-b0a2-403a-9fb9-de1e50562a79">
<p>
Flower 框架的设计目标是，开发者可以无需关注反应式的编程细节，就可以得到一个反应式的系统。目前主流的反应式编程框架有 RxJava、 webflux 等。但是这些反应式编程框架，基本上都是基于函数式编程。Flower 允许大家使用传统的命令式编程的方法，构建反应式的系统，可以更好地兼容以往的代码，使开发者有更低的使用门槛，同时也有更强大的系统特性。
</p>
</div>
</div>
<div id="outline-container-h:6e9ed776-1a22-4253-84b4-b030f2d665a9" class="outline-4">
<h4 id="h:6e9ed776-1a22-4253-84b4-b030f2d665a9">Flower 重构前后性能对比</h4>
<div class="outline-text-4" id="text-h:6e9ed776-1a22-4253-84b4-b030f2d665a9">
<p>
来看使用 Flower 对一个系统进行反应式编程重构前后的性能对比，如下图。
</p>


<figure id="org883735e">
<img src="./images/CgotOV2-U0uALMZVAAEma3KG84Q391.png" alt="CgotOV2-U0uALMZVAAEma3KG84Q391.png">

</figure>

<p>
上图中，左边是系统吞吐量的性能对比图。红色是使用 Flower 重构后的 TPS 吞吐曲线。蓝色是重构前的阻塞式编程得到的系统的吞吐量特性。我们看到，重构以后 Flower 的吞吐能力是重构前的吞吐能力的两倍。
</p>

<p>
上图右边这幅图是响应时间对比图。可以看到 Flower 同样表现出较为优异的响应时间特性，特别是在高并发的情况下，越是高并发，Flower 的性能优势越是明显。那么 Flower 是如何显著地提升系统特性的呢？
</p>
</div>
</div>
<div id="outline-container-h:186a3b89-88ee-46a2-ae76-5c4322ca6f56" class="outline-4">
<h4 id="h:186a3b89-88ee-46a2-ae76-5c4322ca6f56">Flower 提升系统性能原理</h4>
<div class="outline-text-4" id="text-h:186a3b89-88ee-46a2-ae76-5c4322ca6f56">
<p>
如下图，我们看一下 Flower 和传统的阻塞式编程的应用程序运行时有什么不同。
</p>


<figure id="org212ab4c">
<img src="./images/CgoB5l2-U0uADqCVAAHxXOH0DP8643.png" alt="CgoB5l2-U0uADqCVAAHxXOH0DP8643.png">

</figure>

<p>
图中，上部分是传统的应用程序运行期的线程特性示意图；下部分是 Flower 运行期的线程特性示意图。传统的阻塞式编程，针对每个用户请求创建一个线程，整个线程在用户的请求服务周期内都是完全被独占的。任何引起请求操作的阻塞，都会导致整个线程的阻塞。
</p>

<p>
我们看到，对于一个高并发的应用系统，同时总是有很多个用户请求到达系统的 Web 容器，Web 容器为每一个请求分配一个用户线程去进行处理，而容器能够启动的用户线程数目是有限的。如果当前所有的容器线程都已经被用完了，这时候还有新的用户请求到达，请求就会被阻塞在应用服务器，等待前面的线程释放。
</p>

<p>
而线程在运行期会遇到各种阻塞情况，导致线程无法执行下去。比较典型的就是访问数据库，一个用户程序，想要访问数据库，必须要获得数据库的连接，而数据库的连接数相对用户线程数是比较少的。当数据库连接用完以后，线程请求获得数据库连接的时候就会被阻塞。而对于得到了数据库连接的线程，去访问数据库的时候，当它将数据库操作请求发送以后，数据库在远程进行数据处理的时候，当前的线程依然会被阻塞。这些被阻塞的线程既无法去响应其他的用户操作，也无法完成自己的工作，只能白白地消耗系统的资源。如果遇到某种情况，比如说数据库因为某个慢查询而响应比较慢，那么大量的用户线程都会堆积阻塞在数据访问这里无法得到释放，响应时间变长。而新的请求又会不断到达，不断消耗系统资源，最后可能会导致系统崩溃。
</p>

<p>
下面的 Flower 是如何解决这个问题的？
</p>

<p>
对 Flower 而言，只需要有限的几个线程，就可以完成全部的用户请求操作。当并发用户到达应用服务器的时候，Flower 只需要极少的容器线程就可以处理所有的并发用户请求。这个线程并不会执行真正的业务操作，它只是将用户的请求变为请求对象以后，将请求对象异步交给 Flower 的 Service 去处理，自身立刻就返回。因为容器线程不做太多的工作，所以极少的线程就可以满足高并发的用户的请求，用户的请求不会被阻塞，不会因为线程不够而无法处理。
</p>

<p>
用户请求交给 Flower 的 Service 对象以后，Service 之间依然是使用异步的消息通讯的方式进行调用，Service 之间也不会直接进行阻塞式的调用。一个 Service 完成业务逻辑处理计算以后，会返回一个处理结果，这个结果以消息的方式异步发送给它的下一个 Service，Service 之间使用了 AKKA Actor 进行消息通信，也是只需要有限的几个线程就可以完成大量的 Service 处理和消息传输。
</p>

<p>
上面提到 Web 应用主要的线程阻塞，是因为数据库的访问导致的线程阻塞。Flower 支持异步数据库驱动，用户请求数据库的时候，将请求提交给异步数据库驱动，立刻就返回，不会阻塞当前线程，异步数据库访问连接远程的数据库，进行真正的数据库操作，得到结果以后，将结果以异步回调的方式发送给 Flower 的 Service 进行进一步的处理，这个时候依然不会有线程被阻塞。也就是说使用 Flower 开发的系统，在一个典型的 Web 应用中，几乎没有任何地方会被阻塞，所有的线程都可以被不断复用，有限的线程就可以完成大量的并发用户请求，从而极大地提高了系统的吞吐能力，也极大地提高了系统的响应时间。
</p>
</div>
</div>
<div id="outline-container-h:471febcf-43e4-41c3-9db0-4c6f95a09862" class="outline-4">
<h4 id="h:471febcf-43e4-41c3-9db0-4c6f95a09862">AKKA Actor</h4>
<div class="outline-text-4" id="text-h:471febcf-43e4-41c3-9db0-4c6f95a09862">
<p>
刚才说过，Flower Service 是基于 AKKA Actor 进行通信的，那么 AKKA Actor 又是如何实现异步的消息通信的呢？下面是 AKKA Actor 架构图。
</p>


<figure id="orgc6e155e">
<img src="./images/CgotOV2-U0uAOtWMAACmhYolP1Q924.png" alt="CgotOV2-U0uAOtWMAACmhYolP1Q924.png">

</figure>

<p>
如上图所示，一个 Actor 向另一个 Actor 进行通讯的时候，当前 Actor 就是一个消息的发送者 Sender，当它想要向另一个 Actor 进行通讯的时候，需要获得另一个 Actor 的 ActorRef，也就是一个“引用“，通过“引用“进行消息通信。而 ActorRef 收到消息以后，会将这个消息放入到 Actor 的 Mailbox 里面去，然后就立即返回了。也就是说一个 Actor 向另一个 Actor 发送消息的时候，不需要另一个 Actor 去真正处理这个消息，只需要将消息发送到目标 Actor 的邮箱 Mailbox 里面就可以了，自己不会被堵塞，可以继续执行自己的操作。而目标 Actor 检查自己的 Mailbox 中是否有消息，如果有消息， Actor 则会从 Mailbox 里面去获取自己消息，之后对消息进行异步的处理，而所有的 Actor 会共享一些线程，这些线程不会有任何的阻塞。
</p>
</div>
</div>
<div id="outline-container-h:7acd212e-3f3a-40be-b393-8416b72ee69c" class="outline-4">
<h4 id="h:7acd212e-3f3a-40be-b393-8416b72ee69c">Flower 核心模块架构</h4>
<div class="outline-text-4" id="text-h:7acd212e-3f3a-40be-b393-8416b72ee69c">
<p>
如上述，Flower 的核心模块主要是基于 Actor 进行封装的。
</p>

<p>
每个 Service 会被封装在一个 Actor 里面，然后 Service 可以通过可视化的流程编排进行消息的传送，实现异步非阻塞的调用。下面是 Flower 核心模块的架构图。
</p>


<figure id="org6c14f49">
<img src="./images/CgoB5l2-U0yAUlqjAAE9YZct6lI506.png" alt="CgoB5l2-U0yAUlqjAAE9YZct6lI506.png">

</figure>
</div>
</div>
<div id="outline-container-h:8ccdd5f5-c6c3-4f4b-a528-df8efb13e949" class="outline-4">
<h4 id="h:8ccdd5f5-c6c3-4f4b-a528-df8efb13e949">Flower 分布式架构</h4>
<div class="outline-text-4" id="text-h:8ccdd5f5-c6c3-4f4b-a528-df8efb13e949">
<p>
同时 Actor 还支持分布式开发，如下图所示，Flower 的 Service 可以远程部署到一个 Service 容器里面，就像我们现在常用的微服务架构一样。Flower 会提供一个独立的 Flower 容器，用于启动一些 Service，这些 Service 在启动以后会向注册中心进行注册，而应用程序可以将这些 Service 进行流程编排，得到一个分布式非阻塞的微服务系统。整体架构和我们章节5讨论的微服务架构很像，主要的区别就是 Flower 的服务是异步的，通过流程编排的方式进行服务调用，而不是接口的方式进行调用。
</p>


<figure id="orgdb724fc">
<img src="./images/CgotOV2-U0yAc_PTAAE6c4Wbk3E108.png" alt="CgotOV2-U0yAc_PTAAE6c4Wbk3E108.png">

</figure>

<p>
如果你对 Flower 感兴趣，可以通过上图底部的 GitHub 地址得到 Flower 的源代码，目前 Flower 已经在一些项目中得到应用，你可以将 Flower 应用到你的项目中，也欢迎你参与到 Flower 的开发中来。任何关于 Flower 的问题，你可以通过 GitHub 和我交流。
</p>
</div>
</div>
</div>
<div id="outline-container-h:1ab4271b-02aa-4392-819e-5e96a83a5f8c" class="outline-3">
<h3 id="h:1ab4271b-02aa-4392-819e-5e96a83a5f8c">总结回顾</h3>
<div class="outline-text-3" id="text-h:1ab4271b-02aa-4392-819e-5e96a83a5f8c">
<p>
本节主要讨论了三种不同的系统架构案例。
</p>

<ol class="org-ol">
<li>互联网应用系统架构，看一个互联网应用系统的架构是如何设计的，如何利用各种各样的分布式技术，构建一个分布式互联网系统。</li>

<li>分布式数据库的架构设计案例，它的架构考量点主要是什么，一个分布式的数据库如何实现高可用、高性能、可伸缩等一系列的分布式特性的。</li>

<li>编程框架的架构设计，开发工程师每天在编程的时候都要使用编程框架进行开发。那么架构师除了要做这种整体的架构，还要考虑如何为开发工程师去设计一个易用强大的编程框架。这里我们以一个反应式微服务编程框架 Flower 为例，简单介绍了反应式编程以及编程框架架构应该考虑的一些方面。</li>
</ol>

<p>
开始部分说过，软件架构就是关于整体与部分的关系设计，以及关键细节的设计。第一个案例主要是整体与部分的关系如何设计，而第二、三个案例则是关键的技术细节设计，一个系统里最核心的组成部分如何进行设计的。整体应用系统的架构设计可以通过经验和学习获得，关键技术细节的设计则需要对计算机基础的扎实掌握和自身编程能力的不断强化才能做好。
</p>

<p>
如何成为一个优秀的架构师，如何不断训练提升自己，如何做好架构师这个角色，处理好工作中的各种问题。对于这些问题，下一章节将会分享相关经验。
</p>
</div>
</div>
</section>
<section id="outline-container-h:c11957d0-e98b-4848-90b3-225c0bbcd72a" class="outline-2">
<h2 id="h:c11957d0-e98b-4848-90b3-225c0bbcd72a">第10讲：致未来的架构师</h2>
<div class="outline-text-2" id="text-h:c11957d0-e98b-4848-90b3-225c0bbcd72a">
<form><input type="button" value="音频" onclick="doSound(10); return false;"></form>
<span id="dummy10"></span>

<blockquote>
<ol class="org-ol">
<li>从普通程序员到顶尖专家之路</li>
<li>架构师阅读清单</li>
</ol>
</blockquote>

<p>
本章节将分享技术之外的话题：如何从普通程序员成长为技术专家？
</p>
</div>
<div id="outline-container-h:0790fbb5-983e-4dbd-bea9-e2db53699a11" class="outline-3">
<h3 id="h:0790fbb5-983e-4dbd-bea9-e2db53699a11">技术人的进阶路径</h3>
<div class="outline-text-3" id="text-h:0790fbb5-983e-4dbd-bea9-e2db53699a11">
<p>
普通程序员与顶尖技术专家之间有多大差距？他们的进阶路径是怎样的？
</p>

<p>
跟大多数领域一样，计算机技术人才构成也是金字塔型。一般说来，这样的金字塔结构是按照二八定律划分的。如下图，我按照二八定律将技术人金字塔分为八层，从 0 级到 7 级。
</p>


<figure id="orgfe3f585">
<img src="./images/CgoB5l2-U8qABw53AADfMNkTB88914.png" alt="CgoB5l2-U8qABw53AADfMNkTB88914.png">

</figure>
</div>
<div id="outline-container-h:3fe0a341-e247-4be7-9c85-90518df1d9f3" class="outline-4">
<h4 id="h:3fe0a341-e247-4be7-9c85-90518df1d9f3">0 级-&#x2013;&#x2014;普通程序员</h4>
<div class="outline-text-4" id="text-h:3fe0a341-e247-4be7-9c85-90518df1d9f3">
<p>
最下面的是第 0 级，80% 的技术人都处在这一级。0 级技术人，在开发过程中几乎没有话语权。他们要实现的功能，所使用的技术框架、编程语言、数据库，他们遇到关键问题的处理方法等等，都是被指定的。中国目前大约有 1000万 程序员，也就意味着有 800万 的程序员是在别人的指导和安排下工作的。一个 10 人团队大约有 8 人是 0 级技术人，这跟现实中观察到的情况大致相同。
</p>
</div>
</div>
<div id="outline-container-h:d08a9d2d-bd45-4a5d-98b4-f73135e9ee97" class="outline-4">
<h4 id="h:d08a9d2d-bd45-4a5d-98b4-f73135e9ee97">1级-&#x2013;&#x2014;团队的影响者</h4>
<div class="outline-text-4" id="text-h:d08a9d2d-bd45-4a5d-98b4-f73135e9ee97">
<p>
往上一级是 1 级技术人，占剩下 20% 的 80%，即技术人总数的 16%。处于这一级的人我称之为团队的影响者。他们通常是技术团队里的架构师、技术经理、技术骨干，每个 10 人团队里面大约有一两个这样的技术人员。他们负责团队产品研发的技术选型、关键的技术实现、排查关键的技术难题、负责产品的技术架构设计等。
</p>
</div>
</div>
<div id="outline-container-h:6a10ea85-e1a2-4a08-8bd0-7d1505f5a577" class="outline-4">
<h4 id="h:6a10ea85-e1a2-4a08-8bd0-7d1505f5a577">2 级-&#x2013;&#x2014;公司的影响者</h4>
<div class="outline-text-4" id="text-h:6a10ea85-e1a2-4a08-8bd0-7d1505f5a577">
<p>
再上面一级是 2 级技术人，有 3.2% 的技术人处于 2 级，我称这一级的人为公司的影响者。他们在公司范围内有一定的技术影响力，决定了公司大的技术方向，比如使用什么样的编程语言，整个公司使用什么样的核心框架、使用什么样的数据库、什么样的测试工具，诸如此类。在一个 300 人左右的公司里面，差不多有 10 个这样的人。
</p>
</div>
</div>
<div id="outline-container-h:84156318-b9d8-4a2a-b6de-6e9a079764a8" class="outline-4">
<h4 id="h:84156318-b9d8-4a2a-b6de-6e9a079764a8">3 级-&#x2013;&#x2014;全国影响者</h4>
<div class="outline-text-4" id="text-h:84156318-b9d8-4a2a-b6de-6e9a079764a8">
<p>
再往上是金字塔的第四层，3 级技术人是全国影响者，占技术人总数的 0.64%。他们通过自己的博客、专业书籍、各类技术峰会等公开渠道在全国范围内影响到相当一部分人，是某一个细分领域的领军人物。他们通常也是技术的布道师，率先在开发中使用实践了国外一些比较新的技术方法、技术工具、技术框架等，并将这些技术在全国范围内进行推广。
</p>
</div>
</div>
<div id="outline-container-h:923cf490-2da7-4d05-9bd7-de59175705b1" class="outline-4">
<h4 id="h:923cf490-2da7-4d05-9bd7-de59175705b1">4 级-&#x2013;&#x2014;全球影响者</h4>
<div class="outline-text-4" id="text-h:923cf490-2da7-4d05-9bd7-de59175705b1">
<p>
而在 3 级之上，则是具有全球影响力的一些技术人员。他们在全球范围内进行技术布道、出版书籍、发表演讲，在全球范围内影响技术潮流，这样的人大约占总数的 1‰ 左右。对绝大多数中国的技术人说， 3 级是瓶颈，很难到达 4 级，成为具有全球影响力的 4 级技术人，因为中国的 IT 技术在全球技术生态仍在第二梯队，在第一梯队引领全世界的是美国，4 级以上的技术人才目前主要在美国。
</p>

<p>
在金字塔的 4 级及以下，虽然也有人拥有较大的影响力，会一定程度上影响技术趋势，但他们仅仅是软件的使用者、布道者、传播者，并不是开发者。
</p>
</div>
</div>
<div id="outline-container-h:f15753f8-ea9f-4732-a52d-df3609cc8886" class="outline-4">
<h4 id="h:f15753f8-ea9f-4732-a52d-df3609cc8886">5级-&#x2013;&#x2014;关键开创者</h4>
<div class="outline-text-4" id="text-h:f15753f8-ea9f-4732-a52d-df3609cc8886">
<p>
具有全球影响力的技术工具和技术框架的开发者才是真正的开创者。这些人处在金字塔的第六层，是 5 级技术人，我称其为关键开创者。因为有了他们的工作和成果，如 Log4j、JUnit 等提升生产力的工具，全球的开发人员都能够更高效地开展工作，开发出更高质量的代码，这样的人仅占技术人总数的万分之二。
</p>
</div>
</div>
<div id="outline-container-h:8060f2d0-91ce-4bbb-a8fc-1527b377038b" class="outline-4">
<h4 id="h:8060f2d0-91ce-4bbb-a8fc-1527b377038b">6 级-&#x2013;&#x2014;领域开创者</h4>
<div class="outline-text-4" id="text-h:8060f2d0-91ce-4bbb-a8fc-1527b377038b">
<p>
而在金字塔的第七层，我称其为领域开创者，这些人不但开创出流行的应用工具，还开创了一些领域。在这个领域之内，还有其他的开发者进行周边生态开发。比如像 Spring，已经构成了一个软件开发的生态。Java 开发人员可以利用 Spring 全家桶开发一个功能完备的 Web 应用系统。这样的人约占技术人总数的十万分之五。
</p>
</div>
</div>
<div id="outline-container-h:84b8dcbe-834f-4348-87e6-efb5b5d90cb3" class="outline-4">
<h4 id="h:84b8dcbe-834f-4348-87e6-efb5b5d90cb3">7 级-&#x2013;&#x2014;行业开创者</h4>
<div class="outline-text-4" id="text-h:84b8dcbe-834f-4348-87e6-efb5b5d90cb3">
<p>
在整个金字塔最上层，是全球技术人中的王者。他们是行业的开创者，可以催生出每年营收在几十甚至几百亿的行业，比如 Hadoop 的开创者 Doug Cutting、Java 的开创者、Linux 的开创者，这些人约占全球技术人的十万分之一。
</p>
</div>
</div>
<div id="outline-container-h:cd6734d9-f7a0-4c75-89f6-92af8ec3cf96" class="outline-4">
<h4 id="h:cd6734d9-f7a0-4c75-89f6-92af8ec3cf96">进阶路径</h4>
<div class="outline-text-4" id="text-h:cd6734d9-f7a0-4c75-89f6-92af8ec3cf96">
<p>
对于普通的软件开发者而言，到达金字塔的最上层，成为一个行业的开山祖师可能性不大，但成为 3 级、4 级甚至 5 级的机会还是存在的。特别随着中国互联网和 IT 技术的不断进步，这样的机会事实上是越来越多了。美国人主导的知名开源软件中，越来越多的核心开发人员来自中国，而中国人自己主导的开源软件， 也越来越得到全球认可。
</p>


<figure id="org99a9ac4">
<img src="./images/CgotOV2-U8qABGWwAADu716xF6k769.png" alt="CgotOV2-U8qABGWwAADu716xF6k769.png">

</figure>

<p>
如上图所示，对于 0 级技术人而言，比较现实的途径依然是不断精进、逐级提升。如果你现在只是团队里面的一个普通开发者，尽量去学些新技术、实践新技术，试着解决团队里的技术难题、做一些架构设计，使自己成为 1 级技术人，成为团队里面的技术骨干或者架构师。
</p>

<p>
成为团队的技术骨干后，进一步地，在跨团队合作过程中，对其他技术团队进行技术指导，帮助他们解决难题，争取成为有公司影响力的人。在你获得了足够的技术经验和技术实力的基础之上，通过公开演讲、出版图书、撰写博客等方式去打造自己的个人品牌，获得全国影响力。在这个过程中也可以参与或者主导一些开源技术产品的实现，争取成为关键开创者，甚至成为领域开创者。
</p>
</div>
</div>
</div>
<div id="outline-container-h:429ca313-cd66-47f1-afbd-ecc3463ac34a" class="outline-3">
<h3 id="h:429ca313-cd66-47f1-afbd-ecc3463ac34a">如何逐步成为技术专家</h3>
<div class="outline-text-3" id="text-h:429ca313-cd66-47f1-afbd-ecc3463ac34a">
<p>
那么如何才能一级一级地提升自己，成为具有更高影响力的专家呢？这里总结了几点，如下图所示，以供参考。
</p>
</div>
<div id="outline-container-h:0c88ecc1-237b-4e4a-a888-709e5437cbc7" class="outline-4">
<h4 id="h:0c88ecc1-237b-4e4a-a888-709e5437cbc7">勇于承担责任</h4>
<div class="outline-text-4" id="text-h:0c88ecc1-237b-4e4a-a888-709e5437cbc7">
<p>
第一是要勇于承担责任。好的技术都是经过现实锤炼的，能够真正解决现实问题的，得到大多数人欢迎和拥护的。所以自己去学习各种各样的新技术固然重要，但是更重要的是在实践中思考。如果一味按照指令完成开发，永远都无法真正理解一项技术。但如果在实践中勇于对自己工作的结果负责，就可以倒逼自己更多地思考技术的核心、关键点、技术的缺陷与优势，从而真正掌握一项技术。另外，在团队中承担核心的技术职责，有助于产生技术影响并巩固自己的技术地位。
</p>
</div>
</div>
<div id="outline-container-h:31d63bb8-91de-4744-9e83-bda530d09580" class="outline-4">
<h4 id="h:31d63bb8-91de-4744-9e83-bda530d09580">在实践中保持技能</h4>
<div class="outline-text-4" id="text-h:31d63bb8-91de-4744-9e83-bda530d09580">
<p>
第二个是在实践中保持技能。有个说法叫作“1万小时定律”。是说成为一个领域的专家级人物，必须要经过 1万 小时高强度的训练才行。对软件开发这样更强调技术的领域，这一点尤其明显，必须要经过长时间的编程实践来提升技术认知，理解技术的精髓，感悟技术的真谛。但是 1万 小时的编程并不指重复写低难度代码，而是有适当难度的代码。什么叫适当难度呢？就是努力才能达到，但也不是遥不可及。
</p>

<p>
比如，每一次在完成一个工作以后，下一次的工作都要比上一次的工作难度再增加一点点，不断地让自己去挑战更高难度，从而去获得更高的技术，拥有更高的技术能力和技术认知。通俗说来就是要摘跳起来够得着的苹果，不要简单地摘伸手就能摘到的苹果，这样对你的技术提升是没有帮助的。但是如果难度太高，去做了，然后失败了，连续的失败，痛苦的失败，其实对人的挫折打击也是非常大的，而对真正的技术提升其实帮助并不大。所以最好是选择那些跳起来能够摘得到的苹果，你要努力再进步一点点，你才能够完成。完成以后，下一次，在这个基础上再努力一点点、进步一点点，完成更难一点的工作。通过这样持续的工作训练和挑战，在实践中去持续地获得进步，你就可以从金字塔的一级向更高的一级前进。
</p>
</div>
</div>
<div id="outline-container-h:b4fafb02-84c9-4449-8571-b78344016f11" class="outline-4">
<h4 id="h:b4fafb02-84c9-4449-8571-b78344016f11">警惕银弹陷阱，关注问题场景</h4>
<div class="outline-text-4" id="text-h:b4fafb02-84c9-4449-8571-b78344016f11">
<p>
还有一个建议是警惕银弹陷阱，关注问题场景。很多人都有一种理想化的期望，就是希望能够想到一个一劳永逸、可以解决所有问题的解决方案或技术。但现实中这样的解决方案和技术是不存在的。没有万能的方法，每一种方法都有适用的场景，每一种技术都有优缺点。你必须要理解所面临的问题的关键细节、上下文场景，才能选出最合适的技术方案，真正解决问题，否则即使你拥有强大的技术，也很难用好技术。所谓的专家就是善于根据场景发现方法的那个人，如果你关注场景、根据场景去寻找解决办法，或许你会发现解决问题非常简单，并不需要多么高深的工具和技术。所以，你必须意识到方法、技术、工具这些都不是最复杂的，真正难的是剖析场景、理解问题。
</p>

<p>
关于问题，软件开发其实就是解决问题，解决业务的问题、解决技术的问题等。我们每天都在帮公司解决问题，帮用户解决问题，但其实大多数情况下我们连公司面对的问题是什么，用户真正的问题是什么都不知道。所以如果你想真正把问题解决好，那么，当产品经理、老板、上司要你去解决一个问题的时候，你要先去了解真正要解决的问题是什么，而不只是听从指令完成交付。因为在稀里糊涂的状态下，你很难有所提升。
</p>
</div>
</div>
</div>
<div id="outline-container-h:b036d8fb-f4b9-4e9b-8cd2-1e1eafef8af2" class="outline-3">
<h3 id="h:b036d8fb-f4b9-4e9b-8cd2-1e1eafef8af2">架构师阅读清单</h3>
<div class="outline-text-3" id="text-h:b036d8fb-f4b9-4e9b-8cd2-1e1eafef8af2">
<p>
教程的最后，分享一下对我个人成长影响较大的几本书，这 5 本书支撑起了我的技术思维框架，每一本书都是我个人技术成长中的一座重要的里程碑，希望这些书也能够给你带来帮助。
</p>
</div>
<div id="outline-container-h:1cc8794c-f6fd-4962-9217-d8022cefc41b" class="outline-4">
<h4 id="h:1cc8794c-f6fd-4962-9217-d8022cefc41b">《Effective Java中文版》</h4>
<div class="outline-text-4" id="text-h:1cc8794c-f6fd-4962-9217-d8022cefc41b">
<p>
第一本书是 Effective Java。这本书是我在早期的时候遇到的，令我感觉比较震撼的一本技术书。通过这本书，我第一次感受到技术编程之美，发现在枯燥无聊的软件开发过程中，还有这样一些精致的、巧妙的编程方法和技巧可以应用，而这些技巧有很多是和我当时的编程方法相反的。下图所示是《Effective Java中文版》。
</p>

<p>
事实上正是通过这本书，我打开了专业软件编程的大门，它使我意识到专业的东西一定是反常识的，这恐怕是这本书给我最大的收获。看了这本书以后，当我本能地想用习惯的方法进行编程的时候，我总是问自己，有没有更好的、更高效的编程方法。这本书让我知道，在堆砌代码实现功能之外，还有这样一些优美的、精致的技巧可以使用。它让我理解到了编程这门技术的专业性所在，让我感受到技术的高度，不再坐井观天。
</p>
</div>
</div>
<div id="outline-container-h:0b533caf-39a1-429f-9b8c-3b1e5d87fdd6" class="outline-4">
<h4 id="h:0b533caf-39a1-429f-9b8c-3b1e5d87fdd6">《设计模式》</h4>
<div class="outline-text-4" id="text-h:0b533caf-39a1-429f-9b8c-3b1e5d87fdd6">
<p>
另外一本书是《设计模式》，如下图。这本书也比较知名，我也在很早的时候就看了这本书。但是读这本书的时候，我其实并没有太多的感觉，真正让我理解它是在后面的漫长的工作中。当我在阅读别人的代码，包括一些开源代码和优秀的代码示例的时候，我从别人的代码里看到了这些设计模式，看到这样一些精致的编程解决方法，回过头来再想，原来设计模式是这样一些可以让问题变得更加优美的、精致的、灵活的解决方法，然后从头再学习这些设计模式。
</p>

<p>
之后，我在工作中才开始尝试使用各种各样的设计模式，让自己的代码也变得更加灵活和可复用。这个过程大概持续了好几年的时间，这几年的时间里，我反复地阅读了几本关于设计模式的书，从多个方面去了解设计模式究竟是如何解决技术问题的。可以这么说，如果你不懂设计模式，你就不懂面向对象编程，你就没有真正掌握那些面向对象编程的强大技术。所以掌握面向对象编程一定要学习设计模式。
</p>
</div>
</div>
<div id="outline-container-h:ceb818a3-4c2e-42c4-b68b-2605e2703325" class="outline-4">
<h4 id="h:ceb818a3-4c2e-42c4-b68b-2605e2703325">《敏捷软件开发-&#x2013;&#x2014;原则模式与实践》</h4>
<div class="outline-text-4" id="text-h:ceb818a3-4c2e-42c4-b68b-2605e2703325">
<p>
还有一本给我震撼的书是 Bob 大叔的这本《敏捷软件开发-&#x2013;&#x2014;原则模式与实践》，如下图所示。这本书里面提出了一个重要的软件设计思想方法， 就是在软件开发过程中，需求一定是会变更的。软件设计的重要的使命就是去面对需求变更，去解决需求变更的问题，也就是所谓的敏捷开发。
</p>

<p>
但是敏捷开发最重要的并不是什么软件开发方法、软件开发过程管理，而是软件设计本身。你设计出来的软件，必须真正是灵活、敏捷、易于维护、易于扩展、易于变更的，只有这样你才算做到了敏捷软件开发。
</p>

<p>
那么如何做到让自己开发的软件灵活、易维护、易变更、易扩展？Bob 大叔在这本书里面给了几组软件开发的设计原则、设计模式与最佳实践。包括了很多人都很熟悉的：开闭原则、依赖倒转原则、里氏替换原则、接口隔离原则、单一职责原则。
</p>

<p>
在这本书里面 Bob 大叔说，优秀的工程师不应该害怕需求变更，而是应该欢迎需求变更。因为所谓的优秀的软件就是面向需求组变更设计的，只有当需求变更发生的时候，自己的设计才能够体现出价值来。而好的程序和差的程序员之间的差别并不在于开发的功能是否完备，而是在于开发出来的软件是否更易于维护和扩展。
</p>
</div>
</div>
<div id="outline-container-h:441bc4da-8a7b-4ba9-8032-24b5a89c5a96" class="outline-4">
<h4 id="h:441bc4da-8a7b-4ba9-8032-24b5a89c5a96">《企业应用架构模式》</h4>
<div class="outline-text-4" id="text-h:441bc4da-8a7b-4ba9-8032-24b5a89c5a96">
<p>
如下图所示，《企业应用架构模式》也是一本关于模式的书，作者是大名鼎鼎的马丁·弗洛（Martin Fowler）。
</p>

<p>
我以前也曾经很好奇这些做架构设计的，开发出来灵活可复用的框架的人，他们是如何工作的？他们为什么能够开发出来这样有技术难度的产品来。马丁·弗洛在这本书里面对各种各样的企业应用架构模式进行了总结，看了这本书，你会发现各种各样的框架、工具、架构方法，其实都是有模式可循的，也就是有套路可循的。
</p>

<p>
所谓的“模式“就是指可重复使用的解决方案。人们在实践中发现很多软件开发的需求问题，要面对的架构问题都是相似的，它的解决方法也是相似的，把这些相似的解决方法总结出来，就构成了架构模式。马丁·弗洛在这本书里面对企业应用架构的各种模式都进行了总结。基本上通过这本书，你对于企业应用开发过程中的各种问题，和相对的解决方案，以及方案的各种优缺点，都会有一个完整的了解和认知。
</p>

<p>
更重要的是，你一旦洞悉了这模式背后的规律，你也就对自己的工作，对其他人的工作有了一个更高层次的认知和感悟。你不会再纠结于眼前的这些方法问题，你会超越这些方法和问题，去更高一层看待它们，看它们是否有某种重复性，是否可以进行提炼？这样思考以后，随着工作经验的积累，你就会形成自己的一套架构模式、设计模式，从而真正进入了高手和专家之路。
</p>
</div>
</div>
<div id="outline-container-h:4cc2acef-c19e-4091-ab85-e8450e58979a" class="outline-4">
<h4 id="h:4cc2acef-c19e-4091-ab85-e8450e58979a">《卓有成效的管理者》</h4>
<div class="outline-text-4" id="text-h:4cc2acef-c19e-4091-ab85-e8450e58979a">
<p>
最后再推荐一本关于管理的书。关于软件开发管理也有很多书，但是管理这件事情其实是有通用性的。软件开发过程中的管理并不特别，这本彼得·德鲁克（Peter F. Drucker）的《卓有成效的管理者》，如下图，讲述了对于知识性、技术性的组织和团队管理中的一些特点和技巧。彼得·德鲁克被认为是管理学大师中的大师，影响了非常多的人，而且彼得·德鲁克并不教条地去讲述那些管理方法和技巧，他认为最好的管理方法、管理技巧其实在小说里，而不是管理学的本里，管理最重要的就是要洞悉人性，了解人的所求所想，进而利用人的本性，将人有效地组织起来，进行管理。
</p>

<p>
而这种理念恰恰是从技术转向管理的工程师、架构师们比较缺乏的，我们做技术的，总以为这个世界是按照某种确定的规律在运行，事物的因果关系是确定的，总以为，我们做成了 A、B、C，那么 D 一定会到来。而事实上，人的关系总是不确定的，管理中的因果关系是非线性的。但是人的关系依然有其内在的逻辑，技术管理者需要从大师的教导中，去理解这种非确定性的逻辑。
</p>
</div>
</div>
</div>
<div id="outline-container-h:2abd0819-7c3c-40ba-bd02-fc65ae719337" class="outline-3">
<h3 id="h:2abd0819-7c3c-40ba-bd02-fc65ae719337">总结回顾</h3>
<div class="outline-text-3" id="text-h:2abd0819-7c3c-40ba-bd02-fc65ae719337">
<p>
软件技术人员在职业生涯中每一次跨越阶层的技术进步，其实都要超越所在阶层的其他 80% 的人，所以这个过程其实是非常艰难的。那么如何去超越同阶层的人，持续不断地获得进步，有几点实践中要注意的事情。
</p>

<ol class="org-ol">
<li>第一是要勇于承担责任，因为通过承担责任才能够真正的洞悉问题和方法，才能够真正的了解自己所在的环境，因为人毕竟是在环境中生活和工作的。</li>

<li>第二持续的训练，通过持续的训练，获得更高层次的技术的感悟和接受能力，但是这种训练是不能重复的。每一次训练都要在上一次训练难度的基础上再提高一点，不要提高太多，只提高一点，也就是所谓摘跳起来够得着的苹果。</li>

<li>在解决问题的过程中要关注问题的场景。因为本质上，方法其实是简单的，技术是简单的，真正困难的是对场景的理解，是对问题本身的理解，要在这个过程中发现真正的问题所在。</li>
</ol>

<p>
我从事软件开发工作 20 多年了，这些年给我最大的感悟就是：一点一滴的知识看起来似乎都是微不足道的，似乎什么也没有改变，但是经过漫长的积累，这些知识点会逐渐构成一个体系，会产生出巨大的威力，或迟或早，会让你跨越一个又一个技术阶层。最重要的是要不停地积累，不停地学习，完成量变到质变的转换。
</p>

<p>
本门架构教程中，有些知识可能会立刻对你现在的工作有帮助，而有些知识可能只是在你的心里埋下种子，这些种子可能会在你未来持续的学习积累过程中继续成长，最后在某个时候，在你遇到类似场景问题的时候，结出收获的果实，让你忽然理解顿悟。
</p>

<p>
希望你在将来继续不断学习、成长、思考、实践。我们正处在一个快速变革的时代，各种机会层出不穷，祝你能把握住属于你的机会，实现自己的人生梦想和人生价值。
</p>
</div>
</div>
</section>
</div>
<div id="postamble" class="status">
    <div class=bar data-astro-cid-p3givckg>
        <div class=list data-astro-cid-p3givckg>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=simple-icons:gnuemacs height=1em viewBox="0 0 24 24" width=1em>
                    <title>emacs</title>
                    <symbol id=ai:simple-icons:gnuemacs>
                        <path d="M12 24C5.448 24 .118 18.617.118 12S5.448 0 12 0s11.882 5.383 11.882 12S18.552 24 12 24zM12 .661C5.813.661.779 5.748.779 12S5.813 23.339 12 23.339S23.221 18.253 23.221 12S18.187.661 12 .661zM8.03 20.197s.978.069 2.236-.042c.51-.045 2.444-.235 3.891-.552c0 0 1.764-.377 2.707-.725c.987-.364 1.524-.673 1.766-1.11c-.011-.09.074-.408-.381-.599c-1.164-.488-2.514-.4-5.185-.457c-2.962-.102-3.948-.598-4.472-.997c-.503-.405-.25-1.526 1.907-2.513c1.086-.526 5.345-1.496 5.345-1.496c-1.434-.709-4.109-1.955-4.659-2.224c-.482-.236-1.254-.591-1.421-1.021c-.19-.413.448-.768.804-.87c1.147-.331 2.766-.536 4.24-.56c.741-.012.861-.059.861-.059c1.022-.17 1.695-.869 1.414-1.976c-.252-1.13-1.579-1.795-2.84-1.565c-1.188.217-4.05 1.048-4.05 1.048c3.539-.031 4.131.028 4.395.398c.156.218-.071.518-1.015.672c-1.027.168-3.163.37-3.163.37c-2.049.122-3.492.13-3.925 1.046c-.283.599.302 1.129.558 1.46c1.082 1.204 2.646 1.853 3.652 2.331c.379.18 1.49.52 1.49.52c-3.265-.18-5.619.823-7.001 1.977c-1.562 1.445-.871 3.168 2.33 4.228c1.891.626 2.828.921 5.648.667c1.661-.09 1.923-.036 1.939.1c.023.192-1.845.669-2.355.816c-1.298.374-4.699 1.129-4.716 1.133z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:simple-icons:gnuemacs></use>
                </svg>
                <div class="content left" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Emacs</p>
                </div>
            </span>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=simple-icons:org height=1em viewBox="0 0 24 24" width=1em>
                    <title>org-mode</title>
                    <symbol id=ai:simple-icons:org>
                        <path d="M17.169 0c-.566.004-2.16 3.312-3.376 5.94a2.19 2.19 0 0 1-.408-1.267c-.03-.582-1.089.237-.936 1.275c-.068-.035-1.26.227-1.26.23c-.23-.93-.802-1.618-1.15-.563c-.701 1.663-.88 2.984.115 4.585c-.908 4.058-6.948 6.053-6.32 9.33c.175.004 1.634 3.48 6.337 2.057c5.557-1.577 8.624 2.116 8.978 2.375c.52.526-1.348-4.573-5.302-6.865c-2.339-1.276-.87-3.474-.703-4.25c0 0 1.874 1.312 3.232-.692c1.227.316 2.05-.224 3.105.158c.64.28 3.336.11 2.334-1.396c-.148.129.07.27-.075.46c-.043.056-.128.232-.408.315c-.314.149-.83.27-1.43-.37c-.434-.32-.748-.04-.992-.063c.152-.098.577-.315 1.264-.315c.388 0 .594.336.854.338c.174 0 .685-.262.787-.365c.63-.41.697-.278 1.012-.905c.17-.759-.215-.92-.332-1.129c-.032-.483-.436-.67-.919-.326c-1.106-.198-2.192-.105-2.728-.15c-1.175-.164-2.153-.786-2.153-.786c.143-.19.075-.6-.842-.628c-.315-.104-.45-.2-.745-.307c.61-1.37.674-2.007 1.418-4.004c.261-1.053 1.039-2.685.643-2.682zm-4.297 8.093c.03-.086.443.138.952.176c.395.03.805.048 1.296-.025c.03-.005.172.095-.15.194c-.02.01-.062-.01-.065.196c0 .022-.01.04-.02.046c-.15.152-.708.223-1.065.1c-.436-.17-.482-.316-.517-.443c-.305-.147-.47-.123-.43-.244zM9.685 10.2C8.86 9 8.929 8.36 8.96 7.256C7.961 8.288 6.855 8.3 5.18 8.58c-1.299.234-3.657 2.447-4.025 4.742c-.043.608-.08 2.183.424 3.498c.492 1.13.828 1.727 1.844 2.335c-.882-3.169 5.296-5.33 6.263-8.955z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:simple-icons:org></use>
                </svg>
                <div class="content left" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Orgmode</p>
                </div>
            </span>
            <a href=/donations.html class=entry data-astro-cid-p3givckg>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=simple-icons:astro height=1em viewBox="0 0 24 24" width=1em>
                    <title>Donations</title>
                    <symbol id=ai:simple-icons:astro>
                        <path d="M8.358 20.162c-1.186-1.07-1.532-3.316-1.038-4.944c.856 1.026 2.043 1.352 3.272 1.535c1.897.283 3.76.177 5.522-.678c.202-.098.388-.229.608-.36c.166.473.209.95.151 1.437c-.14 1.185-.738 2.1-1.688 2.794c-.38.277-.782.525-1.175.787c-1.205.804-1.531 1.747-1.078 3.119l.044.148a3.158 3.158 0 0 1-1.407-1.188a3.31 3.31 0 0 1-.544-1.815c-.004-.32-.004-.642-.048-.958c-.106-.769-.472-1.113-1.161-1.133c-.707-.02-1.267.411-1.415 1.09c-.012.053-.028.104-.045.165h.002zm-5.961-4.445s3.24-1.575 6.49-1.575l2.451-7.565c.092-.366.36-.614.662-.614c.302 0 .57.248.662.614l2.45 7.565c3.85 0 6.491 1.575 6.491 1.575L16.088.727C15.93.285 15.663 0 15.303 0H8.697c-.36 0-.615.285-.784.727l-5.516 14.99z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:simple-icons:astro></use>
                </svg>
                <div class="content left" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>打赏</p>
                </div>
            </span>
            </a>
            <span class=entry data-astro-cid-p3givckg>
                <svg xmlns="http://www.w3.org/2000/svg" class=heading data-astro-cid-p3givckg data-icon=simple-icons:copyright width="1em" height="1em" viewBox="0 0 24 24">
                    <title>Copyright</title>
                    <path fill="currentColor" d="M19 2a3 3 0 0 1 3 3v14a3 3 0 0 1-3 3H5a3 3 0 0 1-3-3V5a3 3 0 0 1 3-3zm-5 5h-4a1 1 0 0 0-1 1l.007.117A1 1 0 0 0 10 9h3v5a1 1 0 0 1-1.993.117L11 14a1 1 0 0 0-2 0a3 3 0 0 0 6 0V8a1 1 0 0 0-1-1" />
                    <use xlink:href=#ai:simple-icons:copyright></use>
                </svg>
                <div class="content left" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>© 2025 Jasper Hsu</p>
                </div>
            </span>
        </div>
        <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ class="list license" data-astro-cid-p3givckg>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=fa6-brands:creative-commons height=1em viewBox="0 0 496 512" width=0.97em>
                    <title>Creative Commons</title>
                    <symbol id=ai:fa6-brands:creative-commons>
                        <path d="m245.83 214.87l-33.22 17.28c-9.43-19.58-25.24-19.93-27.46-19.93c-22.13 0-33.22 14.61-33.22 43.84c0 23.57 9.21 43.84 33.22 43.84c14.47 0 24.65-7.09 30.57-21.26l30.55 15.5c-6.17 11.51-25.69 38.98-65.1 38.98c-22.6 0-73.96-10.32-73.96-77.05c0-58.69 43-77.06 72.63-77.06c30.72-.01 52.7 11.95 65.99 35.86zm143.05 0l-32.78 17.28c-9.5-19.77-25.72-19.93-27.9-19.93c-22.14 0-33.22 14.61-33.22 43.84c0 23.55 9.23 43.84 33.22 43.84c14.45 0 24.65-7.09 30.54-21.26l31 15.5c-2.1 3.75-21.39 38.98-65.09 38.98c-22.69 0-73.96-9.87-73.96-77.05c0-58.67 42.97-77.06 72.63-77.06c30.71-.01 52.58 11.95 65.56 35.86zM247.56 8.05C104.74 8.05 0 123.11 0 256.05c0 138.49 113.6 248 247.56 248c129.93 0 248.44-100.87 248.44-248c0-137.87-106.62-248-248.44-248zm.87 450.81c-112.54 0-203.7-93.04-203.7-202.81c0-105.42 85.43-203.27 203.72-203.27c112.53 0 202.82 89.46 202.82 203.26c-.01 121.69-99.68 202.82-202.84 202.82z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:fa6-brands:creative-commons></use>
                </svg>
                <div class="content right" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Creative Commons</p>
                </div>
            </span>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=fa6-brands:creative-commons-by height=1em viewBox="0 0 496 512" width=0.97em>
                    <title>Attribute</title>
                    <symbol id=ai:fa6-brands:creative-commons-by>
                        <path d="M314.9 194.4v101.4h-28.3v120.5h-77.1V295.9h-28.3V194.4c0-4.4 1.6-8.2 4.6-11.3c3.1-3.1 6.9-4.7 11.3-4.7H299c4.1 0 7.8 1.6 11.1 4.7c3.1 3.2 4.8 6.9 4.8 11.3zm-101.5-63.7c0-23.3 11.5-35 34.5-35s34.5 11.7 34.5 35c0 23-11.5 34.5-34.5 34.5s-34.5-11.5-34.5-34.5zM247.6 8C389.4 8 496 118.1 496 256c0 147.1-118.5 248-248.4 248C113.6 504 0 394.5 0 256C0 123.1 104.7 8 247.6 8zm.8 44.7C130.2 52.7 44.7 150.6 44.7 256c0 109.8 91.2 202.8 203.7 202.8c103.2 0 202.8-81.1 202.8-202.8c.1-113.8-90.2-203.3-202.8-203.3z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:fa6-brands:creative-commons-by></use>
                </svg>
                <div class="content right" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Attribute</p>
                </div>
            </span>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=fa6-brands:creative-commons-nc height=1em viewBox="0 0 496 512" width=0.97em>
                    <title>Noncommercial</title>
                    <symbol id=ai:fa6-brands:creative-commons-nc>
                        <path d="M247.6 8C387.4 8 496 115.9 496 256c0 147.2-118.5 248-248.4 248C113.1 504 0 393.2 0 256C0 123.1 104.7 8 247.6 8zM55.8 189.1c-7.4 20.4-11.1 42.7-11.1 66.9c0 110.9 92.1 202.4 203.7 202.4c122.4 0 177.2-101.8 178.5-104.1l-93.4-41.6c-7.7 37.1-41.2 53-68.2 55.4v38.1h-28.8V368c-27.5-.3-52.6-10.2-75.3-29.7l34.1-34.5c31.7 29.4 86.4 31.8 86.4-2.2c0-6.2-2.2-11.2-6.6-15.1c-14.2-6-1.8-.1-219.3-97.4zM248.4 52.3c-38.4 0-112.4 8.7-170.5 93l94.8 42.5c10-31.3 40.4-42.9 63.8-44.3v-38.1h28.8v38.1c22.7 1.2 43.4 8.9 62 23L295 199.7c-42.7-29.9-83.5-8-70 11.1c53.4 24.1 43.8 19.8 93 41.6l127.1 56.7c4.1-17.4 6.2-35.1 6.2-53.1c0-57-19.8-105-59.3-143.9c-39.3-39.9-87.2-59.8-143.6-59.8z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:fa6-brands:creative-commons-nc></use>
                </svg>
                <div class="content right" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Noncommercial</p>
                </div>
            </span>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=fa6-brands:creative-commons-sa height=1em viewBox="0 0 496 512" width=0.97em>
                    <title>Share Alike</title>
                    <symbol id=ai:fa6-brands:creative-commons-sa>
                        <path d="M247.6 8C389.4 8 496 118.1 496 256c0 147.1-118.5 248-248.4 248C113.6 504 0 394.5 0 256C0 123.1 104.7 8 247.6 8zm.8 44.7C130.2 52.7 44.7 150.6 44.7 256c0 109.8 91.2 202.8 203.7 202.8c103.2 0 202.8-81.1 202.8-202.8c.1-113.8-90.2-203.3-202.8-203.3zM137.7 221c13-83.9 80.5-95.7 108.9-95.7c99.8 0 127.5 82.5 127.5 134.2c0 63.6-41 132.9-128.9 132.9c-38.9 0-99.1-20-109.4-97h62.5c1.5 30.1 19.6 45.2 54.5 45.2c23.3 0 58-18.2 58-82.8c0-82.5-49.1-80.6-56.7-80.6c-33.1 0-51.7 14.6-55.8 43.8h18.2l-49.2 49.2l-49-49.2h19.4z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:fa6-brands:creative-commons-sa></use>
                </svg>
                <div class="content right" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Share Alike</p>
                </div>
            </span>
        </a>
    </div>
<!--
<script type="text/javascript" src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script type="text/javascript" src="https://unpkg.com/@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
<script type="text/javascript" src="https://unpkg.com/bootstrap@5.2.1/dist/js/bootstrap.min.js"></script>
<div id="back-to-top" class=""><svg viewBox="0 0 24 24"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path></svg></div>
-->
</div>
</body>
</html>
