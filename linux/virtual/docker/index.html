<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Linux: Docker</title>
<meta name="generator" content="Org Mode" />
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="me" href="https://emacs.ch/@jasperhsu">
<meta name="google-adsense-account" content="ca-pub-1741779893655624">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1741779893655624" crossorigin="anonymous"></script>
<!-- from -->
<!--
<style>#back-to-top{background:#000;-webkit-border-radius:50%;-moz-border-radius:50%;border-radius:50%;bottom:20px;-webkit-box-shadow:0 2px 5px 0 rgba(0,0,0,.26);-moz-box-shadow:0 2px 5px 0 rgba(0,0,0,.26);box-shadow:0 2px 5px 0 rgba(0,0,0,.26);color:#fff;cursor:pointer;display:block;height:56px;opacity:1;outline:0;position:fixed;right:20px;-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none;-webkit-transition:bottom .2s,opacity .2s;-o-transition:bottom .2s,opacity .2s;-moz-transition:bottom .2s,opacity .2s;transition:bottom .2s,opacity .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:56px;z-index:1}#back-to-top svg{display:block;fill:currentColor;height:24px;margin:16px auto 0;width:24px}#back-to-top.hidden{bottom:-56px;opacity:0}</style>
-->
<link rel="stylesheet" href="/static/aandds.com/css/main.css">
<link rel="stylesheet" href="/static/aandds.com/css/drollery.min.css">
<script type="text/javascript" src="/static/aandds.com/js/main.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">Linux: Docker</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#h:59afff25-c02d-4a23-ae52-169a6c598214">docker 基本操作</a>
<ul>
<li><a href="#h:332a6c13-3680-4bc1-8a9b-cbaa25a71c96">Docker 介绍</a>
<ul>
<li><a href="#h:acf0c5f2-4efe-4548-a444-0f91f0b88f30">容器历史</a></li>
<li><a href="#h:605f2a1d-bd7d-4a2e-8ac3-598984935c92">Docker 是什么</a></li>
<li><a href="#h:a00dcf7a-9cc2-4342-8dce-ec5a5d1ee260">Docker 和虚拟机，物理主机</a></li>
<li><a href="#h:a6dc874a-7003-4a51-8097-719fe661570f">Docker 的组成</a></li>
<li><a href="#h:671ffbfa-da03-4d40-ae24-5424e77d836b">Namespace</a>
<ul>
<li><a href="#h:60dfff01-aac9-4a27-80b3-9fd86b77e82f">MNT Namespace</a></li>
<li><a href="#h:10766bb4-3796-4f7e-b8d1-3395976a000a">IPC Namespace</a></li>
<li><a href="#h:053cfe7f-ec05-412a-86b2-04646de27027">UTS Namespace</a></li>
<li><a href="#h:133555f3-2948-4634-a700-2c4627816ebe">PID Namespace</a></li>
<li><a href="#h:2d8dd7c3-e849-4694-8b6d-2df414e0f45a">NET Namespace</a></li>
<li><a href="#h:0b348e18-af01-419a-9e9e-bb36ea25e47c">User Namespace</a></li>
</ul>
</li>
<li><a href="#h:125ca637-ec74-4c95-b96f-e24e8f85b1c2">Control groups</a>
<ul>
<li><a href="#h:cf8042b2-5bb0-4590-a485-ab5448edae48">验证系统 cgroups</a></li>
<li><a href="#h:3d1ca4a4-db6a-44f2-9005-a70fd4f93dbc">cgroups 具体实现</a></li>
<li><a href="#h:82bec724-cd04-4b39-97aa-193722d5960f">查看系统 cgroups</a></li>
</ul>
</li>
<li><a href="#h:a2de403d-e9c4-4b98-8254-0abdde02aa1b">容器管理工具</a>
<ul>
<li><a href="#h:ee68d1e7-508d-468c-8fee-49644545dafc">LXC</a></li>
<li><a href="#h:450337eb-8b80-4d44-87b3-b5873acaf67e">docker</a></li>
<li><a href="#h:365ed166-8a20-4643-b9c9-386b1fd43832">pouch</a></li>
<li><a href="#h:17d80072-9150-45b4-ba19-b65e73f5c724">Podman</a></li>
</ul>
</li>
<li><a href="#h:a1b75597-ac68-4dc3-a318-4373536e277b">Docker 的优势</a></li>
<li><a href="#h:713e070c-687c-422f-b18a-52fc38587c6e">Docker 的缺点</a></li>
<li><a href="#h:83b64a12-69f3-45e5-af9f-951057c6442d">容器的核心技术</a>
<ul>
<li><a href="#h:f18f3f97-3e14-4951-a193-373bfea4d871">容器规范</a></li>
<li><a href="#h:a7eeefd6-c79e-4c23-b6cd-6f0f97dcd280">容器 runtime</a></li>
<li><a href="#h:75565f90-61cc-4e6b-9fe8-a67d6600262f">容器管理工具</a></li>
<li><a href="#h:fdbecb54-cee7-47ba-981e-bfab881b296c">容器定义工具</a></li>
<li><a href="#h:3663310f-2e8f-42d5-85c0-488606249e20">镜像仓库 Registry</a></li>
<li><a href="#h:0197109d-34be-480b-b69c-b383acbfb6d7">容器编排工具</a></li>
</ul>
</li>
<li><a href="#h:ee0966d8-a06c-4660-afbe-d80a6951095d">docker(容器)的依赖技术</a></li>
</ul>
</li>
<li><a href="#h:5227bbd9-6e8e-40a7-91ea-079b03a3ac66">Docker安装及基础命令介绍</a>
<ul>
<li><a href="#h:a55c40b1-0333-48ef-b392-bb18bcf91e4a">安装和删除方法</a>
<ul>
<li><a href="#h:b110e97b-0b8a-43c3-814a-b7f50fabff0d">安装文档参考</a></li>
<li><a href="#h:740cede6-ad62-4fdf-8d4e-6668beb030f1">Ubuntu 安装和删除Docker</a></li>
<li><a href="#h:dbb5157d-59c8-4135-9255-b2dc85267b88">CentOS 安装和删除Docker</a></li>
<li><a href="#h:08c3bb76-ad51-4e24-82ce-37d299429f13">Kali Linux上安装docker</a></li>
<li><a href="#h:6933d6f3-a2ba-42a9-a742-4b70c744abc8">EndeavourOS 安装docker</a></li>
<li><a href="#h:c223b563-e509-44f9-9ba0-150271e29910">Linux 二进制安装</a></li>
</ul>
</li>
<li><a href="#h:a5e45f05-a786-45ba-80c5-5cf830cf72db">docker 程序环境</a></li>
<li><a href="#h:85a1d040-8610-4551-b8fd-0d438596a118">docker 命令帮助</a></li>
<li><a href="#h:f2315ca6-1c33-46a7-a917-1e08f814e1bf">查看 Docker 相关信息</a>
<ul>
<li><a href="#h:35d40c70-c15c-44e5-84e1-943278032d38">查看 docker 版本</a></li>
<li><a href="#h:8a53fbd2-383b-479a-83ab-6eeb5ba2626b">查看 docker 详解信息</a></li>
<li><a href="#h:799e892e-ebf9-479d-9744-683f49f8fb9b">docker 存储引擎</a></li>
<li><a href="#h:947c7cc4-59f2-4b38-923b-df5d9a5ed01a">docker 服务进程</a></li>
</ul>
</li>
<li><a href="#h:678115fe-086b-4795-9b32-947f9ea0fc26">docker 服务管理</a></li>
</ul>
</li>
<li><a href="#h:7570c4c0-6062-4c2b-a20c-0f885f8ef201">镜像管理</a>
<ul>
<li><a href="#h:e6670e1f-e099-4711-8b00-b23ecd73ec61">镜像结构和原理</a></li>
<li><a href="#h:de33145e-d39c-4df2-92be-21518456a334">搜索镜像</a>
<ul>
<li><a href="#h:9df61e60-5147-4141-b666-86ce94692bc2">搜索镜像</a></li>
<li><a href="#h:63471112-f286-4fee-af08-b7db62efbe39">alpine 介绍</a></li>
<li><a href="#h:b4ea2e3a-fb01-41f6-93c6-d9fb9e449cd6">Debian(ubuntu)系统建议安装的基础包</a></li>
</ul>
</li>
<li><a href="#h:5468b87c-d74e-43b8-80af-7a04d4c65e19">下载镜像</a></li>
<li><a href="#h:b47307c7-9ed6-41ee-b8b4-c66009265a1a">docker 镜像加速配置</a>
<ul>
<li><a href="#h:7bf137ed-908d-406a-903d-b7dc3fd077a1">阿里云获取加速地址</a></li>
<li><a href="#h:9f131957-acbc-44a3-b8a6-11152d2b1bc7">镜像加速配置</a></li>
</ul>
</li>
<li><a href="#h:fa721b79-e85d-4122-8f30-1ec2eb22985a">查看本地镜像</a></li>
<li><a href="#h:2c82116e-bfb4-4822-b77f-7584111a1a59">镜像导出</a></li>
<li><a href="#h:15ada5fe-b279-4519-a5b0-8d4eeca49093">镜像导入</a>
<ul>
<li><a href="#org969a3ca">一次性打包所有镜像</a></li>
</ul>
</li>
<li><a href="#h:90478dc4-5395-4247-81b7-da62809102a8">删除镜像</a></li>
<li><a href="#h:037a95c2-77bf-493f-b960-4f33af08886a">镜像打标签</a></li>
</ul>
</li>
<li><a href="#h:b27f04cc-9bb4-4df2-b184-0c6ee32ca015">容器操作基础命令</a>
<ul>
<li><a href="#h:8392fec7-735a-452a-bbcf-1c53c87cd600">启动容器</a>
<ul>
<li><a href="#h:cf8e9e9c-4f4d-4d18-a435-41d2f6bc04b8">启动第一个容器</a></li>
<li><a href="#h:49f3eaf8-aadc-4cf8-966a-29d7326b815a">启动容器的流程</a></li>
<li><a href="#h:ae69d801-cee8-4cb0-8130-bf7c6b6c7f5a">启动容器用法</a></li>
</ul>
</li>
<li><a href="#h:28e3e641-5c5f-46be-ab13-ac3a9d51c106">查看容器信息</a>
<ul>
<li><a href="#h:368c52d7-c401-4069-8098-fc37f87eb477">显示当前存在容器</a></li>
<li><a href="#h:cb4dc285-1cdc-4079-a70d-2817678663ad">查看容器内的进程</a></li>
<li><a href="#h:5bb394b9-3953-4969-817a-3c2fc85783d4">查看容器资源使用情况</a></li>
<li><a href="#h:05869dcd-11bf-4214-9b2e-fcf77b9ee566">查看容器的详细信息</a></li>
</ul>
</li>
<li><a href="#h:9c57b186-3a05-440c-92fc-e01da8cf42a1">删除容器</a></li>
<li><a href="#h:ea56eccf-13df-4758-812d-575f222ed5f6">容器的启动和停止</a></li>
<li><a href="#h:58ed5366-7cb3-4333-bdcd-c5796d055d2c">给正在运行的容器发信号</a></li>
<li><a href="#h:ba8e8656-0e56-493d-8eaa-b5c94c8d1556">进入正在运行的容器</a>
<ul>
<li><a href="#h:d67f987a-931f-47d1-ba29-4a7f59aa3682">使用attach命令</a></li>
<li><a href="#h:c670a4ba-732f-4959-ae96-9447ccfcb655">使用exec命令</a></li>
<li><a href="#h:5762044b-29af-40a0-8ed6-e4d9994cac25">使用nsenter命令</a></li>
<li><a href="#h:51b89d8d-5b15-40e0-a5ef-e570d2f04fee">脚本方式</a></li>
<li><a href="#h:df395a1f-9389-46fe-9212-c6732935a0c0">暴露所有容器端口</a></li>
</ul>
</li>
<li><a href="#h:7b8fdf51-a7c6-4f17-9d41-41c15691128a">指定端口映射</a></li>
<li><a href="#h:9560fe05-89bd-4ba6-a046-03b05c349a89">查看容器的日志</a></li>
<li><a href="#h:a439a451-1df9-4911-ba94-d548f4336155">传递运行命令</a></li>
<li><a href="#h:56df7eeb-d6cd-428e-aab3-1ef20dd60d8d">容器内部的hosts文件</a></li>
<li><a href="#h:8e0d95bc-463b-4eff-a423-97bf3f5e4285">指定容器DNS</a></li>
<li><a href="#h:60565b97-ad01-4248-b87d-6b22e777d5fc">容器内和宿主机之间复制文件</a></li>
<li><a href="#h:e4499075-057d-40d8-bcd1-5ba7456d5a63">使用 systemd 控制容器运行</a></li>
<li><a href="#h:4529de20-e153-40db-b532-5426ceda6dcc">传递环境变量</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:969a017e-62b3-4e42-a2e7-d5f7f9db8b95">Docker 镜像制作和管理</a>
<ul>
<li><a href="#h:e5ace7d7-1cf7-4c10-8d16-e5790cbb64bf">Docker 镜像说明</a>
<ul>
<li><a href="#h:31dbbde1-83d7-44ac-99f3-2a96fcad0cab">Docker 镜像中有没有内核</a></li>
<li><a href="#h:97f29990-93d1-4397-8daf-833ffd96c4d5">为什么没有内核</a></li>
<li><a href="#h:fc5c3629-35e0-4680-92af-da408e6705f5">容器中的程序后台运行会导致此容器启动后立即退出</a></li>
<li><a href="#h:40ba9475-54f7-405d-8560-ef111651bb55">docker 镜像生命周期</a></li>
<li><a href="#h:ac234a41-c20e-4008-8f5c-fe95363bdd5f">制作镜像方式</a></li>
</ul>
</li>
<li><a href="#h:46df6738-aa4f-42bf-a6d0-8812ef64192b">将现有容器通过 docker commit 手动构建镜像</a>
<ul>
<li><a href="#h:366c99a9-68ec-487d-bcda-f401b9cee737">基于容器手动制作镜像步骤</a></li>
<li><a href="#h:3179e75e-d5a8-4208-abf6-5620649342a7">实战案例: 基于 busybox 制作 httpd 镜像</a></li>
</ul>
</li>
<li><a href="#h:270fce76-bfaf-4cb8-844d-856cf2ca9507">利用 DockerFile 文件执行 docker build 自动构建镜像</a>
<ul>
<li><a href="#h:647becca-7862-4981-8f4a-1c78d513de79">Dockfile 使用详解</a>
<ul>
<li><a href="#h:e2cb0db0-b6ce-4a64-99fa-ab9b66b4b7c2">Dockerfile 介绍</a></li>
<li><a href="#h:02356ca8-57e0-4d0a-91ec-d89808471032">Dockerfile 镜像制作和使用流程</a></li>
<li><a href="#h:ce9e6995-b588-4a75-8cc2-c9a1affb0f4b">Dockerfile文件的制作镜像的分层结构</a></li>
<li><a href="#h:941e2b50-d59a-47f8-a66f-ec6e084e7729">Dockerfile 文件格式</a></li>
<li><a href="#h:5a8f04cf-1897-4a58-a4af-e3e6364dcaec">Dockerfile 相关指令</a></li>
<li><a href="#h:98b56914-74ab-4181-8fb0-3c569d4adf81">构建镜像docker build 命令</a></li>
</ul>
</li>
<li><a href="#h:1f656c77-c145-4bcd-96ec-970219d6eaad">检查镜像中dockerfile内容</a>
<ul>
<li><a href="#h:93e3db93-5f8f-42c8-a99e-e816e8a1cd71">docker history</a></li>
<li><a href="#h:7ba447d9-ac79-4504-a6e6-589d87804c6d">image2df</a></li>
</ul>
</li>
<li><a href="#h:55fc356f-0772-49c0-9868-e7c7bb89497a">实战案例: Dockerfile 制作基于基础镜像的Base镜像</a>
<ul>
<li><a href="#h:8a02c906-b5d9-47df-ae85-da038ffafd3f">准备目录结构，下载镜像并初始化系统</a></li>
<li><a href="#h:fc2f427d-9678-4049-ba52-464d519131f4">先制作基于基础镜像的系统Base镜像</a></li>
</ul>
</li>
<li><a href="#h:5141ed9f-ef9d-4537-9c90-d9864333f00e">实战案例: Dockerfile 制作基于Base镜像的 nginx 镜像</a>
<ul>
<li><a href="#h:1313436e-5450-4a26-94ea-626e23552423">在Dockerfile目录下准备编译安装的相关文件</a></li>
<li><a href="#h:1b69977e-161d-4858-81cf-7daba3e509a4">在一台测试机进行编译安装同一版本的nginx 生成模版配置文件</a></li>
<li><a href="#h:1c8d6a59-ad9b-4086-91b2-a5b28e94d36a">编写Dockerfile文件</a></li>
<li><a href="#h:58774e67-6a8b-4980-8482-e82dc6cac1f1">生成nginx镜像</a></li>
<li><a href="#h:93c0b0d4-c90d-427c-933b-ac590eae5e16">生成的容器测试镜像</a></li>
</ul>
</li>
<li><a href="#h:b6d02c34-b863-4ea7-9f72-fc4fdb6d523d">实战案例: Dockerfile 直接制作 nginx 镜像</a></li>
</ul>
</li>
<li><a href="#h:356c5eea-36c2-4d53-a7fb-bb88391790db">基于 alpine 基础镜像制作nginx镜像</a></li>
<li><a href="#h:7cde48e5-4521-4810-94e4-82a5cff5a6ae">基于 Ubuntu 基础镜像制作 nginx 镜像</a></li>
</ul>
</li>
<li><a href="#h:7d21cb54-a602-4d26-bb4a-e5d245a3b6e3">Docker 数据管理</a>
<ul>
<li><a href="#h:d691abdf-daec-4289-b0a0-dbc4b36cda5b">容器的数据管理介绍</a>
<ul>
<li><a href="#h:17b276d0-2fce-4658-a9e3-bd6d823e3d19">Docker容器的分层</a></li>
<li><a href="#h:230421e3-e16a-4a92-8188-f3da7fc9b901">哪些数据需要持久化</a></li>
<li><a href="#h:a99c8fc6-24e8-44a2-82c5-3c21d6bab6ee">容器数据持久保存方式</a></li>
<li><a href="#h:187ad021-5f8f-4b25-b49f-6285295668ee">数据卷特点和使用</a>
<ul>
<li><a href="#h:f57bc38f-e088-4cf7-acf6-014649b509f7">数据卷使用场景</a></li>
<li><a href="#h:f95f6fc8-1def-48d8-bee9-d4f7af59e2ba">数据卷的特点</a></li>
<li><a href="#h:51862e50-6f3c-4bc0-83bb-4c9e57968bf8">数据卷使用方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:f2f63b8d-856a-45a0-b10d-e304f3b64ff3">数据卷容器</a>
<ul>
<li><a href="#h:bb5228fb-1c92-45bc-bfb6-265a2a0dd38a">数据卷容器介绍</a></li>
<li><a href="#h:241eb79b-6a07-46a0-b0cb-496c794f8f66">使用数据卷容器</a></li>
<li><a href="#h:b0e73366-12e0-4898-842b-58afe4f0cc64">利用数据卷容器备份指定容器的数据卷实现</a></li>
<li><a href="#h:68bae616-c0ae-4cf4-bd88-4a01abcf6daa">数据卷容器总结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:d3e49a63-5d25-4181-9af3-48d264da9ac2">网络管理</a>
<ul>
<li><a href="#h:86dc7cfe-8eb0-4f69-bb2c-48b190f82bd8">Docker的默认的网络通信</a>
<ul>
<li><a href="#h:b4cd889a-7d77-4bfc-960a-549070e810c2">Docker安装后默认的网络设置</a></li>
<li><a href="#h:476b1eb7-63ef-4d58-a347-e799593e6a9c">创建容器后的网络配置</a></li>
<li><a href="#h:47c476ac-d197-4b8c-a52b-9a4e7bca7a67">容器间的通信</a>
<ul>
<li><a href="#h:96ea34b8-c2ba-448c-bca2-a052652c28fc">同一个宿主机的不同容器可相互通信</a></li>
<li><a href="#h:95633594-80ca-440a-ab01-b705d7873081">禁止同一个宿主机的不同容器间通信</a></li>
</ul>
</li>
<li><a href="#h:e1ab5a16-19dd-48ec-a0da-2f73e5dfd601">修改默认网络设置</a></li>
</ul>
</li>
<li><a href="#h:08c2de2e-a33b-4113-9c79-60e95529a593">容器名称互联</a>
<ul>
<li><a href="#h:c9c0f775-1d08-453e-8e79-2b57e5e268a6">通过容器名称互联</a>
<ul>
<li><a href="#h:32fb82ad-8f73-45ad-b695-f5c562b2df6a">容器名称介绍</a></li>
<li><a href="#h:c4e39b62-8073-4dcc-a1a5-14f81d9d8d06">容器名称实现</a></li>
<li><a href="#h:582aa1f4-f83a-4a01-8e03-294d733682ab">实战案例1: 使用容器名称进行容器间通信</a></li>
<li><a href="#h:314518cf-2b3e-4cf8-9092-9658626c2695">实战案例2: 实现 wordpress 和 MySQL 两个容器互连</a></li>
</ul>
</li>
<li><a href="#h:55ad9ca6-5a32-4a32-ae3e-3beb8db241a5">通过自定义容器别名互联</a>
<ul>
<li><a href="#h:e8d8dfb7-c374-48c4-8a06-c5447e58abb7">容器别名介绍</a></li>
<li><a href="#h:81eb0458-5a39-4143-ad07-ec25377be407">容器别名实现</a></li>
<li><a href="#h:050a5743-e519-497a-8015-7d3d6f259265">实战案例: 使用容器别名</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:75416717-f815-4e66-b786-e2c35489c50c">docker 网络连接模式</a>
<ul>
<li><a href="#h:3e7a32cf-ee2c-408d-adcd-51273b29c6dc">网络模式介绍</a></li>
<li><a href="#h:2aa8cd56-957b-4371-a9df-589141b64dc4">网络模式指定</a></li>
<li><a href="#h:e8bb08d9-bbe6-48ce-afb2-700e3aad9399">bridge网络模式</a>
<ul>
<li><a href="#h:1e3c1937-1f49-46e4-88df-e854f388cfdc">bridge 网络模式架构</a></li>
<li><a href="#h:9c0fe615-6658-4110-8466-05fbaef4073c">bridge 模式的默认设置</a></li>
<li><a href="#h:c5f65636-91b8-4a79-9cc8-276d69dd6c35">修改默认的 bridge 模式网络配置</a></li>
</ul>
</li>
<li><a href="#h:e7008006-c411-4c72-b93e-da1c4c2fe52a">Host 模式</a></li>
<li><a href="#h:16dcd838-0976-41b6-b072-9c9576c7a3e4">none 模式</a></li>
<li><a href="#h:ba00cd2f-211f-4cb3-bbe9-b4bbeff8888b">Container 模式</a></li>
<li><a href="#h:14fd189f-db6f-44bc-a53f-439fd28222e8">自定义网络模式</a>
<ul>
<li><a href="#h:1367c1de-862f-43b3-a665-50993a05a961">自定义网络实现</a></li>
<li><a href="#h:4274d2d8-c17f-4978-8dbb-94f26012d892">实战案例: 自定义网络</a></li>
<li><a href="#h:f9a2d8aa-06c6-467c-9072-bdb96a019b01">实战案例: 利用自定义网络实现 Redis Cluster</a></li>
</ul>
</li>
<li><a href="#h:b6411e28-c009-495b-97f6-7a64b2fd586d">同一个宿主机之间不同网络的容器通信</a>
<ul>
<li><a href="#h:508f1b45-adef-4a99-987f-694bfa37c510">实战案例 1: 修改iptables实现同一宿主机上的不同网络的容器间通信</a></li>
<li><a href="#h:9fefd7e2-d322-4946-9623-8bc7a3744712">实战案例 2: 通过解决docker network connect 实现同一个宿主机不同网络的容器间通信</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:5b3fdb04-7193-49ff-a7b8-2301d3da440a">实现跨宿主机的容器之间网络互联</a>
<ul>
<li><a href="#h:5381348e-7f75-490d-b2cb-2d4f6f4eb0e2">方式1: 利用桥接实现跨宿主机的容器间互联</a></li>
<li><a href="#h:152044ab-467d-45c5-82be-db09c1073bb1">方式2: 利用NAT实现跨主机的容器间互联</a>
<ul>
<li><a href="#h:9b826a15-6550-4700-89b6-993c03955b94">docker跨主机互联实现说明</a></li>
<li><a href="#h:93d449f3-61f0-4fc5-b4fc-dd1fc74cb314">修改各宿主机网段</a></li>
<li><a href="#h:73f9b83c-f378-467e-a2b1-d7a7b69a77b7">在两个宿主机分别启动一个容器</a></li>
<li><a href="#h:f8bd4b72-69ea-48e1-a6a8-537c31f1bea7">添加静态路由和iptables规则</a></li>
<li><a href="#h:fe37f7e3-6633-439d-845c-a9b6330996ec">测试跨宿主机之间容器互联</a></li>
<li><a href="#h:52d05a4b-c690-44f6-be0f-5ab3ee17923a">创建第三个容器测试</a></li>
</ul>
</li>
<li><a href="#h:f280aec4-bb42-4135-807e-be139728e389">方式3: 利用Open vSwitch实现跨主机的容器间互联</a>
<ul>
<li><a href="#h:dd839148-80f8-46f8-9a00-6214b8b469c0">Open vSwitch介绍</a></li>
<li><a href="#h:2aa596af-0242-40e3-9776-0a62db6047a5">利用Open vSwitch实现docker跨主机网络</a></li>
</ul>
</li>
<li><a href="#h:fdf82461-02b4-4f8a-81eb-f0b668d7031d">方式4: 使用 weave 实现跨主机的容器间互联</a>
<ul>
<li><a href="#h:f2183123-67cf-4f52-8590-365bf0e4f603">weave 介绍</a></li>
<li><a href="#h:7c9d7e37-6062-4941-886f-aebc45a02a75">weave实现跨主机容器互联的流程</a></li>
<li><a href="#h:166c535e-567d-496e-a2d7-5e9ba5e057db">实战案例: 通过weave 实现跨主机容器的互联</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:9253d262-515b-446b-96dc-605814572982">Docker 仓库管理</a>
<ul>
<li><a href="#h:e8d01552-a72e-4ff4-a9bb-d0ba0c1da278">官方 docker 仓库</a>
<ul>
<li><a href="#h:9964db38-5aad-4d6c-8a00-49e7b3f710e6">使用用户仓库管理镜像</a></li>
<li><a href="#h:a00790c9-307b-4873-8a44-4584696c7070">docker login 凭证</a></li>
</ul>
</li>
<li><a href="#h:20a85657-83f5-49a3-83c5-6c76b93fd8f7">私有云单机仓库Docker Registry</a>
<ul>
<li><a href="#h:648b4a75-f5ae-437c-bed7-c9139b7169d6">Docker Registry 介绍</a></li>
<li><a href="#h:329f3d2b-468a-4180-a718-82d3ee1d0311">下载 docker registry 镜像</a></li>
<li><a href="#h:d7aed6bf-660c-44e5-b7a6-f9527503e1f7">搭建单机仓库</a></li>
<li><a href="#h:1f3e6743-dddf-473c-90ab-884904d07112">登录仓库</a></li>
<li><a href="#h:24c96ef6-b932-433b-afd6-2f8755ea92ee">打标签并上传镜像</a></li>
<li><a href="#h:d6b203c9-d0fe-4f8d-bfe7-6d4d257cb7f9">下载镜像并启动容器</a></li>
</ul>
</li>
<li><a href="#h:ea7ed4b4-e9df-4fe5-bd8e-0618d0321f81">Docker 之分布式仓库 Harbor</a>
<ul>
<li><a href="#h:34887dbe-6496-4b4a-ba88-f7f95a94edd0">Harbor 介绍和架构</a>
<ul>
<li><a href="#h:9c8ccec3-f4da-4758-b822-7f2534cbe8c2">Harbor 介绍</a></li>
<li><a href="#h:8bb01f97-88aa-4f20-8453-b523cfb3f02f">Harbor功能官方介绍</a></li>
<li><a href="#h:efa5ab09-c302-4286-8714-626a9dad03de">Harbor 组成</a></li>
</ul>
</li>
<li><a href="#h:8ead3b45-6fc7-44c3-a9e0-f9003cc2a333">安装Harbor</a>
<ul>
<li><a href="#h:da28698a-02b5-4b00-ac47-c8cd78d6c059">下载Harbor安装包并解压缩</a></li>
<li><a href="#h:dd14d68e-a6e5-4203-9e37-382c77b1b11c">编辑配置文件 harbor.cfg</a></li>
<li><a href="#h:02726036-d855-4a3e-85a6-9359da43b2aa">运行 harbor 安装脚本</a></li>
<li><a href="#h:688caf36-fcb0-4cec-8483-dfefbc5a7718">实现开机自动启动 harbor</a></li>
<li><a href="#h:229dcac0-ee28-4a59-b194-f3cc4a6686e0">登录 harbor 主机网站</a></li>
</ul>
</li>
<li><a href="#h:00028af6-457a-4bfa-9f0b-268d453c4e08">实现 harbor 高可用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:f44edfbc-aad6-4225-a230-5be0203c12c4">单机编排之Docker Compose</a>
<ul>
<li><a href="#h:944a52d2-b32f-4d39-878e-eb4194011404">Docker Compse介绍</a>
<ul>
<li><a href="#h:09f3c0ff-4c60-46e4-a9f2-adc8e87ae5e2">安装和准备</a>
<ul>
<li><a href="#h:ba9d8d5b-f63c-410f-a1d0-b9aba54adbe3">安装Docker Compose</a></li>
</ul>
</li>
<li><a href="#h:675bd285-8fe8-4b8d-85e3-47b9d89a60f4">查看命令格式</a></li>
<li><a href="#h:bf0d8141-25e9-427a-9f8a-17ce0973f306">docker compse 文件格式</a></li>
<li><a href="#h:3fe2dad3-48fc-4ad4-9d4f-5de1200f43f1">指定同时启动容器的数量</a></li>
<li><a href="#h:cb328dd2-a42c-46bc-b6c7-4d21294acf2c">多doker compose文件容器互通</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:b89be07c-41f5-4b40-b3b4-672f70bba2d4">docker 的资源限制</a>
<ul>
<li><a href="#h:94e570a8-7960-4cdb-b7be-2d4099b11f90">docker 资源限制</a>
<ul>
<li><a href="#h:7b1d4395-a4e0-463c-89db-a1e6e03f35aa">容器资源限制介绍</a></li>
<li><a href="#h:a0f68920-1dd8-445f-9693-16b723925fa2">OOM （Out of Memory Exception）</a></li>
</ul>
</li>
<li><a href="#h:0745e9ae-549b-40bf-a51a-067828ed0cd7">容器的内存限制</a>
<ul>
<li><a href="#h:88d022ec-1c6e-4bdb-82f3-ea9fc753728f">内存相关选项</a></li>
<li><a href="#h:4b3918f7-bbf9-4e4a-a9ea-011931615741">swap限制</a></li>
<li><a href="#h:f3ac8150-04f9-4d5c-bf27-e208ad8588fe">stress-ng 压力测试工具</a></li>
<li><a href="#h:f4cbd166-83cf-4ddc-be1a-fa4a5d3ed17d">配置默认的CFS调度程序</a></li>
<li><a href="#h:58812ca9-527e-4f49-983b-5ee56e3302de">使用stress-ng测试cpu配置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:b1ea57c6-89bb-4607-a02f-38f5cb345522">可视化图形工具Portainer</a>
<ul>
<li><a href="#h:472b9e5f-1c0d-4139-8206-fad72db72b18">Portainer介绍</a></li>
<li><a href="#h:8e9f87e1-3e26-44e6-90d9-b3924ebd16b6">安装 Portainer</a></li>
<li><a href="#h:e23217cf-f634-4d75-b8a5-0413b6c43cea">登录和使用Portainer</a></li>
</ul>
</li>
<li><a href="#h:992ace4a-081c-48b8-a0a5-7fdd3909d89e">拓展</a>
<ul>
<li><a href="#h:071b57eb-9c77-4e55-bd05-005096bf91c9">多平台构建</a>
<ul>
<li><a href="#h:7c7d6c38-cb81-4e5d-b2d4-0972113f8ad6">启用binfmt_misc</a></li>
<li><a href="#h:6dafaaeb-0dc1-44a1-9ae9-4f1661838d96">从默认的构建器切换到多平台构建器</a></li>
<li><a href="#h:bf4204c9-3aa9-449f-9cee-efe2e2c368d1">构建多平台镜像</a>
<ul>
<li><a href="#h:4642b65d-04ac-43c7-8a38-2d0f2a096a12">使用 buildx 构建多架构的 Docker 镜像</a></li>
</ul>
</li>
<li><a href="#h:8b73b117-34ae-4deb-8119-e18b45a2f166">保存到本地并推送到私有仓库</a></li>
<li><a href="#h:a8c381cc-dee0-4504-81d2-6cca5b6a71ab">查看镜像支持的CPU架构</a></li>
<li><a href="#h:b36c4ecd-908f-4beb-a438-c041c7fcf113">构建基础镜像</a>
<ul>
<li><a href="#h:989f593c-d426-48da-82f9-69c9dbbc6dfd">jdk amd 与 arm 平台</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#h:969bcc40-9fdd-460a-95ae-a9a6b50e82b1">容器多进程管理</a></li>
<li><a href="#h:63f48071-3ed6-4909-8d0f-62ed03accd52">资源清理</a></li>
<li><a href="#h:1e560131-863e-4fbb-94ea-a29776de706a">容器排查</a>
<ul>
<li><a href="#h:c60a118b-5116-408d-8a3d-fb2bd716d228">查看进程是否属于docker</a></li>
<li><a href="#h:1ed705e2-b568-4ad3-b08e-0d93e206287f">找到本机docker进程</a></li>
<li><a href="#h:78d10d28-62ec-4395-bd36-2735308c8097">通过docker overlay2 目录名查找对应容器名</a></li>
</ul>
</li>
<li><a href="#h:8c715c6e-270a-4af0-a2bb-9f0dc89dc0a2">镜像加速</a>
<ul>
<li><a href="#h:fac0024f-be54-4730-950b-acaec6e7edea">使用Github Action来拉取docker镜像</a></li>
<li><a href="#h:fdca5471-6384-4d4e-9d3a-d5dda0cac3da">利用cloudflare代理DockerHub</a></li>
<li><a href="#h:02e6a941-be62-4487-8902-7652edf3a5df">nginx反向代理加速docker镜像</a></li>
<li><a href="#org6e7d1a5">HTTP代理加速docker镜像</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<p>
TAGS: <a href="../../index.html">Linux</a><br>
</p>

<p>
内容概述<br>
docker 基本操作<br>
容器镜像制作和管理<br>
数据卷管理<br>
网络管理<br>
镜像仓库管理<br>
容器编排管理工具docker compose<br>
容器资源限制<br>
可视化容器管理工具Portainer<br>
容器多进程管理<br>
容器排查<br>
镜像加速<br>
</p>
<section id="outline-container-h:59afff25-c02d-4a23-ae52-169a6c598214" class="outline-2">
<h2 id="h:59afff25-c02d-4a23-ae52-169a6c598214">docker 基本操作</h2>
<div class="outline-text-2" id="text-h:59afff25-c02d-4a23-ae52-169a6c598214">
<p>
Container 即容器，但今天我们所说的容器是一种 IT 技术。容器其实是一种沙盒技术。顾名思义，沙盒就是能够像一个集装箱一样，把你的应用装起来。这样，应用与应用之间就有了边界而不会相互干扰;同时装在沙盒里面的应用，也可以很方便的被搬来搬去，这也是 PaaS 想要的最理想的状态(可移植性,标准化,隔离性)。<br>
</p>
</div>
<div id="outline-container-h:332a6c13-3680-4bc1-8a9b-cbaa25a71c96" class="outline-3">
<h3 id="h:332a6c13-3680-4bc1-8a9b-cbaa25a71c96">Docker 介绍</h3>
<div class="outline-text-3" id="text-h:332a6c13-3680-4bc1-8a9b-cbaa25a71c96">
</div>
<div id="outline-container-h:acf0c5f2-4efe-4548-a444-0f91f0b88f30" class="outline-4">
<h4 id="h:acf0c5f2-4efe-4548-a444-0f91f0b88f30">容器历史</h4>
<div class="outline-text-4" id="text-h:acf0c5f2-4efe-4548-a444-0f91f0b88f30">
<p>
docker八卦<br>
</p>
<audio id='1_5' src="media/docker.mp3" controls preload="none"  style="display: block;"></audio>

<p>
虽然 docker 把容器技术推向了巅峰，但容器技术却不是从 docker 诞生的。实际上，容器技术连新技术都算不上，因为它的诞生和使用确实有些年头了。下面的一串名称可能有的你都没有听说过，但它们的确都是容器技术的应用:<br>
</p>

<ul class="org-ul">
<li>1、Chroot Jail<br></li>
</ul>
<p>
就是我们常见的 chroot 命令的用法。它在 1979 年的时候就出现了，被认为是最早的容器化技术之一。它可以把一个进程的文件系统隔离起来。<br>
</p>

<ul class="org-ul">
<li>2、The FreeBSD Jail<br></li>
</ul>
<p>
Freebsd Jail (监狱)实现了操作系统级别的虚拟化，它是操作系统级别虚拟化技术的先驱之一。2000年，伴随FreeBSD4.0版的发布<br>
</p>

<ul class="org-ul">
<li>3、Linux VServer<br></li>
</ul>
<p>
使用添加到 Linux 内核的系统级别的虚拟化功能实现的专用虚拟服务器。允许创建许多独立的虚拟专用服务器（VPS），这些虚拟专用服务器在单个物理服务器上全速同时运行，从而有效地共享硬件资源。VPS提供与传统Linux服务器几乎相同的操作环境。可以在这样的VPS上启动所有服务（例如ssh，邮件，Web和数据库服务器），而无需（或者在特殊情况下只需进行很少的修改），就像在任何真实服务器上一样。<br>
</p>

<p>
每个VPS都有自己的用户帐户数据库和root密码，并且与其他虚拟服务器隔离，但它们共享相同的硬件资源<br>
2003年11月1日 VServer 1.0 发布官网:<a href="http://linux-vserver.org/">http://linux-vserver.org/</a><br>
</p>

<ul class="org-ul">
<li>4、Solaris Containers<br></li>
</ul>
<p>
它也是操作系统级别的虚拟化技术，专为 X86 和 SPARC 系统设计。Solaris 容器是系统资源控制和通过"区域" 提供边界隔离的组合。<br>
</p>

<ul class="org-ul">
<li>5、OpenVZ<br></li>
</ul>
<p>
OpenVZ 是一种 Linux 中操作系统级别的虚拟化技术。 它允许创建多个安全隔离的 Linux 容器，即VPS。<br>
</p>

<ul class="org-ul">
<li>6、Process Containers<br></li>
</ul>
<p>
Process 容器由 Google 的工程师开发，一般被称为 cgroups。<br>
</p>

<ul class="org-ul">
<li>7、LXC<br></li>
</ul>
<p>
LXC为Linux Container的简写。可以提供轻量级的虚拟化，以便隔离进程和资源，而且不需要提供指令解释机制以及全虚拟化的其他复杂性。容器有效地将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求。<br>
</p>

<p>
Linux Container提供了在单一可控主机节点上支持多个相互隔离的server container同时执行的机制。<br>
Linux Container有点像chroot，提供了一个拥有自己进程和网络空间的虚拟环境，但又有别于虚拟机，因为lxc是一种操作系统层次上的资源的虚拟化。<br>
</p>

<ul class="org-ul">
<li>8、Warden<br></li>
</ul>
<p>
在最初阶段，Warden 使用 LXC 作为容器运行时。 如今已被 CloudFoundy 取代。<br>
</p>

<ul class="org-ul">
<li>9、LMCTFY<br></li>
</ul>
<p>
LMCTY 是 Let me contain that for you 的缩写。它是 Google 的容器技术栈的开源版本。Google 的工程师一直在与 docker 的 libertainer 团队合作，并将 libertainer 的核心概念进行抽象并移植到此项目中。该项目的进展不明，估计会被 libcontainer 取代。<br>
</p>

<ul class="org-ul">
<li>10、Docker<br></li>
</ul>
<p>
Docker 是一个可以将应用程序及其依赖打包到几乎可以在任何服务器上运行的容器的工具。<br>
</p>

<ul class="org-ul">
<li>11、RKT<br></li>
</ul>
<p>
RKT 是 Rocket 的缩写，它是一个专注于安全和开放标准的应用程序容器引擎。<br>
综上所述正如我们所看到的，docker 并不是第一个容器化技术，但它的确是最知名的一个。<br>
</p>
</div>
</div>
<div id="outline-container-h:605f2a1d-bd7d-4a2e-8ac3-598984935c92" class="outline-4">
<h4 id="h:605f2a1d-bd7d-4a2e-8ac3-598984935c92">Docker 是什么</h4>
<div class="outline-text-4" id="text-h:605f2a1d-bd7d-4a2e-8ac3-598984935c92">
<p>
Docker （码头工人）是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司（后由于 Docker 开源后大受欢迎就将公司改名为 Docker Inc ，总部位于美国加州的旧金山）内部的一个开源的 PAAS 服<br>
务 (Platform as a ServiceService )的业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。<br>
</p>

<p>
Docker 是基于 linux 内核实现，Docker 最早采用 LXC 技术 ，LXC 是 Linux 原生支持的容器技术 ，可以提供轻量级的虚拟化 ，可以说 docker 就是基于 LXC 发展起来 的，提供 LXC 的高级封装，标准的配置方法，在LXC的基础之上，docker提供了一系列更强大的功能。而虚拟化技术 KVM(KernelKernelbased Virtual Machine Machine) 基于 模块实现， 后来Docker 改为自己研发并开源的 runc 技术运行<br>
容器，彻底抛弃了LXC。<br>
</p>

<p>
Docker 相比虚拟机的交付速度更快，资源消耗更低，Docker 采用客户端/服务端架构，使用远程API来管理和创建容器，其可以轻松的创建一个轻量级的、可移植的、自给自足的容器，docker 的三大理念是build(构建)、ship(运输)、 run(运行)，Docker遵从apache 2.0协议，并通过（namespace及cgroup等）来提供容器的资源隔离与安全保障等，所以Docke容器在运行时不需要类似虚拟机（空运行的虚拟机占用物理机6-8%性能）的额外资源开销，因此可以大幅提高资源利用率,总而言之Docker是一种用了新颖方式实现的轻量级虚拟机.类似于VM但是在原理和应用上和VM的差别还是很大的，并且docker的专业叫法是应用容器(Application Container)。<br>
</p>

<p>
<b>Docker的主要目标</b><br>
<img src="./images/Snipaste_2023-04-25_14-18-54.png" alt="Snipaste_2023-04-25_14-18-54.png"><br>
</p>

<p>
Build, Ship and Run Any App, Anywhere，即通过对应用组件的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统。将应用运行在Docker 容器上，可以实现跨平台，跨服务器，只需一次配置准备好相关的应用环境，即可实现到处运行，保证研发和生产环境的一致性，解决了应用和运行环境的兼容性问题，从而极大提升了部署效率，减少故障的可能性<br>
</p>

<p>
<b>使用Docker 容器化封装应用程序的意义:</b><br>
<img src="./images/Snipaste_2023-04-25_14-22-15.png" alt="Snipaste_2023-04-25_14-22-15.png"><br>
</p>

<ul class="org-ul">
<li>统一基础设施环境-docker环境<br>
<ul class="org-ul">
<li>硬件的组成配置<br></li>
<li>操作系统的版本运行时环境的异构<br></li>
</ul></li>
<li>统一程序打包（装箱）方式-docker镜像<br>
<ul class="org-ul">
<li>java程序<br></li>
<li>python程序<br></li>
<li>nodejs程序<br></li>
</ul></li>
<li>统一程序部署（运行）方式-docker容器<br>
<ul class="org-ul">
<li>java-jar&#x2026;→ docker run&#x2026;<br></li>
<li>python manage.py runserver&#x2026; → docker run&#x2026;<br></li>
<li>npm run dev &#x2026; → docker run&#x2026;<br></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-h:a00dcf7a-9cc2-4342-8dce-ec5a5d1ee260" class="outline-4">
<h4 id="h:a00dcf7a-9cc2-4342-8dce-ec5a5d1ee260">Docker 和虚拟机，物理主机</h4>
<div class="outline-text-4" id="text-h:a00dcf7a-9cc2-4342-8dce-ec5a5d1ee260">

<figure id="orga51fd3b">
<img src="./images/Snipaste_2023-04-25_14-24-19.png" alt="Snipaste_2023-04-25_14-24-19.png"><br>

</figure>

<p>
<b>容器和虚拟机技术比较</b><br>
<img src="./images/Snipaste_2023-04-25_14-24-50.png" alt="Snipaste_2023-04-25_14-24-50.png"><br>
</p>

<ul class="org-ul">
<li>传统虚拟机是虚拟出一个主机硬件,并且运行一个完整的操作系统 ,然后在这个系统上安装和运行软件<br></li>
<li>容器内的应用直接运行在宿主机的内核之上,容器并没有自己的内核,也不需要虚拟硬件,相当轻量化<br></li>
<li>每个容器间是互相隔离,每个容器内都有一个属于自己的独立文件系统,独立的进程空间,网络空间,用户空间等,所以在同一个宿主机上的多个容器之间彼此不会相互影响<br></li>
</ul>

<p>
<b>容器和虚拟机表现比较</b><br>
</p>
<ul class="org-ul">
<li>资源利用率更高: 开销更小,不需要启动单独的虚拟机OS内核占用硬件资源,可以将服务器性能压榨至极致.虚拟机一般会有5-20%的损耗,容器运行基本无损耗,所以生产中一台物理机只能运行数十个虚拟机，但是一般可以运行数百个容器<br></li>
<li>启动速度更快: 可以在数秒内完成启动<br></li>
<li>占用空间更小: 容器一般占用的磁盘空间以MB为单位,而虚拟机以GB<br></li>
<li>集成性更好: 和CI/CD（持续集成/持续部署）相关技术结合性更好，实现打包镜像发布测试可以一键运行,做到自动化并快速的部署管理,实现高效的开发生命周期<br></li>
</ul>

<p>
使用虚拟机是为了更好的实现服务运行环境隔离，每个虚拟机都有独立的内核，虚拟化可以实现不同操作系统的虚拟机，但是通常一个虚拟机只运行一个服务，很明显资源利用率比较低且造成不必要的性能损耗，我们创建虚拟机的目的是为了运行应用程序，比如Nginx、PHP、Tomcat等web程序，使用虚拟机无疑带来了一些不必要的资源开销，但是容器技术则基于减少中间运行环节带来较大的性能提升。<br>
</p>

<p>
根据实验，一个运行着CentOS的KVM虚拟机启动后，在不做优化的情况下，虚拟机自己就需要占用100~200 MB内存。此外，用户应用运行在虚拟机里面，它对宿主机操作系统的调用就不可避免地要经过虚拟化软件的拦截和处理，这本身又是一层性能损耗，尤其对计算资源、网络和磁盘I/O的损耗非常大。<br>
</p>

<p>
比如: 一台96G内存的物理服务器，为了运行java程序的虚拟机一般需要分配8G内存/4核的资源，只能运行13台左右虚拟机，但是改为在docker容器上运行Java程序,每个容器只需要分配4G内存即可，同样的物理服务器就可以运行25个左右容器，运行数量相当于提高一倍，可以大幅节省IT支出，通常情况下至少可节约一半以上的物理设备<br>
</p>
</div>
</div>
<div id="outline-container-h:a6dc874a-7003-4a51-8097-719fe661570f" class="outline-4">
<h4 id="h:a6dc874a-7003-4a51-8097-719fe661570f">Docker 的组成</h4>
<div class="outline-text-4" id="text-h:a6dc874a-7003-4a51-8097-719fe661570f">
<p>
docker 官网: <a href="http://www.docker.com">http://www.docker.com</a><br>
帮助文档链接: <a href="https://docs.docker.com/">https://docs.docker.com/</a><br>
docker 镜像: <a href="https://hub.docker.com/">https://hub.docker.com/</a><br>
docker 中文网站: <a href="http://www.docker.org.cn/Docker">http://www.docker.org.cn/Docker</a><br>
</p>


<figure id="org483e75a">
<img src="./images/Snipaste_2023-04-25_15-11-14.png" alt="Snipaste_2023-04-25_15-11-14.png"><br>

</figure>


<ul class="org-ul">
<li>Docker 主机(Host): 一个物理机或虚拟机，用于运行Docker服务进程和容器，也称为宿主机，node节点<br></li>
<li>Docker 服务端(Server): Docker守护进程，运行docker容器<br></li>
<li>Docker 客户端(Client): 客户端使用 docker 命令或其他工具调用docker API<br></li>
<li>Docker 镜像(Images): 镜像可以理解为创建实例使用的模板,本质上就是一些程序文件的集合<br></li>
<li>Docker 仓库(Registry): 保存镜像的仓库，官方仓库: <a href="https://hub.docker.com/">https://hub.docker.com/</a> ，可以搭建私有仓库harbor<br></li>
<li>Docker 容器(Container): 容器是从镜像生成对外提供服务的一个或一组服务,其本质就是将镜像中的程序启动后生成的进程<br></li>
</ul>
</div>
</div>
<div id="outline-container-h:671ffbfa-da03-4d40-ae24-5424e77d836b" class="outline-4">
<h4 id="h:671ffbfa-da03-4d40-ae24-5424e77d836b">Namespace</h4>
<div class="outline-text-4" id="text-h:671ffbfa-da03-4d40-ae24-5424e77d836b">
<p>
一个宿主机运行了N个容器，多个容器共用一个 OS，必然带来的以下问题:<br>
</p>
<ul class="org-ul">
<li>怎么样保证每个容器都有不同的文件系统并且能互不影响？<br></li>
<li>一个docker主进程内的各个容器都是其子进程，那么如果实现同一个主进程下不同类型的子进程？各个容器子进程间能相互通信(内存数据)吗？<br></li>
<li>每个容器怎么解决IP及端口分配的问题？<br></li>
<li>多个容器的主机名能一样吗？<br></li>
<li>每个容器都要不要有root用户？怎么解决账户重名问题？<br></li>
</ul>

<p>
namespace是Linux系统的底层概念，在内核层实现，即有一些不同类型的命名空间被部署在核内，各个docker容器运行在同一个docker主进程并且共用同一个宿主机系统内核，各docker容器运行在宿主机的用户空间，每个容器都要有类似于虚拟机一样的相互隔离的运行空间，但是容器技术是在一个进程内实现运行指定服务的运行环境，并且还可以保护宿主机内核不受其他进程的干扰和影响，如文件系统空间、网络空间、进程空间等，目前主要通过以下技术实现容器运行空间的相互隔离:<br>
</p>

<p>
隔离类型 功能 系统调用参数 内核版本<br>
</p>
<ul class="org-ul">
<li>MNT Namespace(mount)： 提供磁盘挂载点和文件系统的隔离能力 CLONE_NEWNS 2.4.19<br></li>
<li>IPC Namespace(InterProcess Communication)：提供进程间通信的隔离能力,包括信号量,消息队列和共享内存 CLONE_NEWIPC 2.6.19<br></li>
<li>UTS Namespace(UNIX Timesharing System)：提供内核,主机名和域名隔离能力 CLONE_NEWUTS 2.6.19<br></li>
<li>PID Namespace(ProcessIdentification)： 提供进程隔离能力 CLONE_NEWPID 2.6.24<br></li>
<li>Net Namespace(network)： 提供网络隔离能力,包括网络设备,网络栈,端口等 CLONE_NEWNET 2.6.29<br></li>
<li>User Namespace(user)：提供用户隔离能力,包括用户和组 CLONE_NEWUSER 3.8<br></li>
</ul>

<p>
NameSpace是在内核级别完成环境隔离的方法。你可以把它想象成一种change root机制，能模拟一个独立的Linux运行使得用户程序在指定位置运行。<br>
</p>
</div>
<div id="outline-container-h:60dfff01-aac9-4a27-80b3-9fd86b77e82f" class="outline-5">
<h5 id="h:60dfff01-aac9-4a27-80b3-9fd86b77e82f">MNT Namespace</h5>
<div class="outline-text-5" id="text-h:60dfff01-aac9-4a27-80b3-9fd86b77e82f">
<p>
每个容器都要有独立的根文件系统有独立的用户空间，以实现在容器里面启动服务并且使用容器的运行环境，即一个宿主机是ubuntu的服务器，可以在里面启动一个centos运行环境的容器并且在容器里面启动一个Nginx服务，此Nginx运行时使用的运行环境就是centos系统目录的运行环境，但是在容器里面是不能访问宿主机的资源，宿主机是使用了chroot技术把容器锁定到一个指定的运行目录里面。<br>
</p>

<p>
例如:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">/var/lib/containerd/io.containerd.runtime.v1.linux/moby/&#23481;&#22120;ID
</pre>
</div>

<p>
根目录:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">/var/lib/docker/overlay2/ID
</pre>
</div>

<p>
范例: 容器和宿主机共享内核<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@centos8 ~]#podman exec nginx uname -r
4.18.0-147.el8.x86_64
[root@centos8 ~]#uname -r
4.18.0-147.el8.x86_64
</pre>
</div>
</div>
</div>
<div id="outline-container-h:10766bb4-3796-4f7e-b8d1-3395976a000a" class="outline-5">
<h5 id="h:10766bb4-3796-4f7e-b8d1-3395976a000a">IPC Namespace</h5>
<div class="outline-text-5" id="text-h:10766bb4-3796-4f7e-b8d1-3395976a000a">
<p>
一个容器内的进程间通信，允许一个容器内的不同进程的(内存、缓存等)数据访问，但是不能跨容器直接访问其他容器的数据<br>
</p>
</div>
</div>
<div id="outline-container-h:053cfe7f-ec05-412a-86b2-04646de27027" class="outline-5">
<h5 id="h:053cfe7f-ec05-412a-86b2-04646de27027">UTS Namespace</h5>
<div class="outline-text-5" id="text-h:053cfe7f-ec05-412a-86b2-04646de27027">
<p>
UTS namespace（UNIX Timesharing System包含了运行内核的名称、版本、底层体系结构类型等信息）用于系统标识，其中包含了主机名hostname 和域名domainname ，它使得一个容器拥有属于自己主机名标识，这个主机名标识独立于宿主机系统和其上的其他容器。<br>
</p>
</div>
</div>
<div id="outline-container-h:133555f3-2948-4634-a700-2c4627816ebe" class="outline-5">
<h5 id="h:133555f3-2948-4634-a700-2c4627816ebe">PID Namespace</h5>
<div class="outline-text-5" id="text-h:133555f3-2948-4634-a700-2c4627816ebe">
<p>
Linux系统中，有一个PID为1的进程(init/systemd)是其他所有进程的父进程，那么在每个容器内也要有一个父进程来管理其下属的子进程，那么多个容器的进程通PID namespace进程隔离(比如PID编号重复、器内的主进程生成与回收子进程等)。<br>
</p>


<figure id="orgb3d4363">
<img src="./images/Snipaste_2023-04-25_21-53-39.png" alt="Snipaste_2023-04-25_21-53-39.png"><br>

</figure>
</div>
</div>
<div id="outline-container-h:2d8dd7c3-e849-4694-8b6d-2df414e0f45a" class="outline-5">
<h5 id="h:2d8dd7c3-e849-4694-8b6d-2df414e0f45a">NET Namespace</h5>
<div class="outline-text-5" id="text-h:2d8dd7c3-e849-4694-8b6d-2df414e0f45a">
<p>
每一个容器都类似于虚拟机一样有自己的网卡、监听端口、TCP/IP协议栈等，<br>
</p>

<p>
Docker使用network namespace启动一个vethX接口，这样你的容器将拥有它自己的桥接ip地址，通常是docker0，而docker0实质就是Linux的虚拟网桥,网桥是在OSI七层模型的数据链路层的网络设备，通过mac地址对网络进行划分，并且在不同网络直接传递数据。<br>
</p>

<p>
演示：2)ip netns：管理网络名称空间<br>
将接口移动到指定的网络名称空间<br>
</p>
<div class="org-src-container">
<pre class="src src-sh">[root@centos7 ~]# ip netns add mynet
[root@centos7 ~]# ip link set eno16777736 netns mynet

[root@centos7 ~]# ip netns list
[root@centos7 ~]# ip netns exec mynet ip link show  <span style="color: #b22222;">#</span><span style="color: #b22222;">&#22312;&#34394;&#25311;&#32593;&#32476;&#20013;&#30340;&#20351;&#29992;&#21629;&#20196;&#26597;&#30475;&#25110;  ip netns exec mynet  netstat -ntlp
</span>[root@centos7 ~]# ip netns del mynet   <span style="color: #b22222;">#</span><span style="color: #b22222;">&#21024;&#38500;&#34394;&#25311;&#32593;&#32476;&#31354;&#38388;&#21518;&#65292;&#20854;&#37324;&#32593;&#21345;&#35774;&#22791;&#20063;&#23601;&#36824;&#21407;&#21407;&#20301;&#32622;&#20102;&#65307;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-h:0b348e18-af01-419a-9e9e-bb36ea25e47c" class="outline-5">
<h5 id="h:0b348e18-af01-419a-9e9e-bb36ea25e47c">User Namespace</h5>
<div class="outline-text-5" id="text-h:0b348e18-af01-419a-9e9e-bb36ea25e47c">
<p>
各个容器内可能会出现重名的用户和用户组名称，或重复的用户UID或者GID，那么怎么隔离各个容器内的用户空间呢？<br>
</p>

<p>
User Namespace允许在各个宿主机的各个容器空间内创建相同的用户名以及相同的用户UID和GID，只是会把用户的作用范围限制在每个容器内，即A容器和B容器可以有相同的用户名称和ID的账户，但是此用户的有效范围仅是当前容器内，不能访问另外一个容器内的文件系统，即相互隔离、互不影响、永不相见。<br>
</p>
</div>
</div>
</div>
<div id="outline-container-h:125ca637-ec74-4c95-b96f-e24e8f85b1c2" class="outline-4">
<h4 id="h:125ca637-ec74-4c95-b96f-e24e8f85b1c2">Control groups</h4>
<div class="outline-text-4" id="text-h:125ca637-ec74-4c95-b96f-e24e8f85b1c2">
<p>
Linux Cgroups的全称是Linux Control Groups,是Linux内核的一个功能.最早是由Google的工程师（主要是Paul Menage和Rohit Seth）在2006年发起，最早的名称为进程容器（process containers）。在2007年时，因为在Linux内核中，容器（container）这个名词有许多不同的意义，为避免混乱，被重命名为cgroup，并且被合并到2.6.24版的内核中去。自那以后，又添加了很多功能。<br>
</p>

<p>
如果不对一个容器做任何资源限制，则宿主机会允许其占用无限大的内存空间，有时候会因为代码bug程序会一直申请内存，直到把宿主机内存占完，为了避免此类的问题出现，宿主机有必要对容器进行资源分配限制，比如CPU、内存等<br>
</p>

<p>
Cgroups 最主要的作用，就是限制一个进程组能够使用的资源上限，包括CPU、内存、磁盘、网络带宽等等。此外，还能够对进程进行优先级设置，资源的计量以及资源的控制(比如:将进程挂起和恢复等操作)。<br>
</p>
</div>
<div id="outline-container-h:cf8042b2-5bb0-4590-a485-ab5448edae48" class="outline-5">
<h5 id="h:cf8042b2-5bb0-4590-a485-ab5448edae48">验证系统 cgroups</h5>
<div class="outline-text-5" id="text-h:cf8042b2-5bb0-4590-a485-ab5448edae48">
<p>
Cgroups在内核层默认已经开启，从CentOS 和 Ubuntu 不同版本对比，显然内核较新的支持的功能更多。<br>
</p>

<p>
Centos 8.1 cgroups:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@centos8 ~]#cat /etc/redhat-release
CentOS Linux release 8.1.1911 (Core)
[root@centos8 ~]#grep CGROUP /boot/config-4.18.0-147.el8.x86_64
<span style="color: #a0522d;">CONFIG_CGROUPS</span>=y
<span style="color: #a0522d;">CONFIG_BLK_CGROUP</span>=y
<span style="color: #b22222;"># </span><span style="color: #b22222;">CONFIG_DEBUG_BLK_CGROUP is not set
</span><span style="color: #a0522d;">CONFIG_CGROUP_WRITEBACK</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_SCHED</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_PIDS</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_RDMA</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_FREEZER</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_HUGETLB</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_DEVICE</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_CPUACCT</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_PERF</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_BPF</span>=y
<span style="color: #b22222;"># </span><span style="color: #b22222;">CONFIG_CGROUP_DEBUG is not set
</span><span style="color: #a0522d;">CONFIG_SOCK_CGROUP_DATA</span>=y
<span style="color: #b22222;"># </span><span style="color: #b22222;">CONFIG_BLK_CGROUP_IOLATENCY is not set
</span><span style="color: #a0522d;">CONFIG_NETFILTER_XT_MATCH_CGROUP</span>=m
<span style="color: #a0522d;">CONFIG_NET_CLS_CGROUP</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_NET_PRIO</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_NET_CLASSID</span>=y
[root@centos8 ~]#
</pre>
</div>

<p>
Centos 7.6 cgroups:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@centos7 ~]#cat /etc/redhat-release
CentOS Linux release 7.6.1810 (Core)
[root@centos7 ~]#grep CGROUP /boot/config-3.10.0-957.el7.x86_64
<span style="color: #a0522d;">CONFIG_CGROUPS</span>=y
<span style="color: #b22222;"># </span><span style="color: #b22222;">CONFIG_CGROUP_DEBUG is not set
</span><span style="color: #a0522d;">CONFIG_CGROUP_FREEZER</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_PIDS</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_DEVICE</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_CPUACCT</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_HUGETLB</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_PERF</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_SCHED</span>=y
<span style="color: #a0522d;">CONFIG_BLK_CGROUP</span>=y
<span style="color: #b22222;"># </span><span style="color: #b22222;">CONFIG_DEBUG_BLK_CGROUP is not set
</span><span style="color: #a0522d;">CONFIG_NETFILTER_XT_MATCH_CGROUP</span>=m
<span style="color: #a0522d;">CONFIG_NET_CLS_CGROUP</span>=y
<span style="color: #a0522d;">CONFIG_NETPRIO_CGROUP</span>=y
</pre>
</div>

<p>
ubuntu cgroups:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#grep CGROUP /boot/config-4.15.0-29-generic
<span style="color: #a0522d;">CONFIG_CGROUPS</span>=y
<span style="color: #a0522d;">CONFIG_BLK_CGROUP</span>=y
<span style="color: #b22222;"># </span><span style="color: #b22222;">CONFIG_DEBUG_BLK_CGROUP is not set
</span><span style="color: #a0522d;">CONFIG_CGROUP_WRITEBACK</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_SCHED</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_PIDS</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_RDMA</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_FREEZER</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_HUGETLB</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_DEVICE</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_CPUACCT</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_PERF</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_BPF</span>=y
<span style="color: #b22222;"># </span><span style="color: #b22222;">CONFIG_CGROUP_DEBUG is not set
</span><span style="color: #a0522d;">CONFIG_SOCK_CGROUP_DATA</span>=y
<span style="color: #a0522d;">CONFIG_NETFILTER_XT_MATCH_CGROUP</span>=m
<span style="color: #a0522d;">CONFIG_NET_CLS_CGROUP</span>=m
<span style="color: #a0522d;">CONFIG_CGROUP_NET_PRIO</span>=y
<span style="color: #a0522d;">CONFIG_CGROUP_NET_CLASSID</span>=y
</pre>
</div>

<p>
cgroups 中内存模块:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#grep MEMCG /boot/config-4.15.0-29-generic
<span style="color: #a0522d;">CONFIG_MEMCG</span>=y
<span style="color: #a0522d;">CONFIG_MEMCG_SWAP</span>=y
<span style="color: #b22222;"># </span><span style="color: #b22222;">CONFIG_MEMCG_SWAP_ENABLED is not set
</span><span style="color: #a0522d;">CONFIG_SLUB_MEMCG_SYSFS_ON</span>=y
</pre>
</div>
</div>
</div>
<div id="outline-container-h:3d1ca4a4-db6a-44f2-9005-a70fd4f93dbc" class="outline-5">
<h5 id="h:3d1ca4a4-db6a-44f2-9005-a70fd4f93dbc">cgroups 具体实现</h5>
<div class="outline-text-5" id="text-h:3d1ca4a4-db6a-44f2-9005-a70fd4f93dbc">
<ul class="org-ul">
<li>blkio: 块设备IO限制<br></li>
<li>cpu: 使用调度程序为 cgroup 任务提供 cpu 的访问<br></li>
<li>cpuacct: 产生 cgroup 任务的 cpu 资源报告<br></li>
<li>cpuset: 如果是多核心的 cpu，这个子系统会为 cgroup 任务分配单独的 cpu 和内存<br></li>
<li>devices: 允许或拒绝 cgroup 任务对设备的访问<br></li>
<li>freezer: 暂停和恢复 cgroup 任务<br></li>
<li>memory: 设置每个 cgroup 的内存限制以及产生内存资源报告<br></li>
<li>net_cls: 标记每个网络包以供 cgroup 方便使用<br></li>
<li>ns: 命名空间子系统<br></li>
<li>perf_event: 增加了对每 group 的监测跟踪的能力，可以监测属于某个特定的 group 的所有线程以及运行在特定CPU上的线程<br></li>
</ul>
</div>
</div>
<div id="outline-container-h:82bec724-cd04-4b39-97aa-193722d5960f" class="outline-5">
<h5 id="h:82bec724-cd04-4b39-97aa-193722d5960f">查看系统 cgroups</h5>
<div class="outline-text-5" id="text-h:82bec724-cd04-4b39-97aa-193722d5960f">
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#ll /sys/fs/cgroup/
total 0
drwxr-xr-x 15 root root 380 Jan 22 16:20 ./
drwxr-xr-x 10 root root 0 Jan 22 16:20 ../
dr-xr-xr-x 5 root root 0 Jan 22 16:20 blkio/
lrwxrwxrwx 1 root root 11 Jan 22 16:20 cpu -&gt; cpu,cpuacct/
lrwxrwxrwx 1 root root 11 Jan 22 16:20 cpuacct -&gt; cpu,cpuacct/
dr-xr-xr-x 5 root root 0 Jan 22 16:20 cpu,cpuacct/
dr-xr-xr-x 3 root root 0 Jan 22 16:20 cpuset/
dr-xr-xr-x 5 root root 0 Jan 22 16:20 devices/
dr-xr-xr-x 3 root root 0 Jan 22 16:20 freezer/
dr-xr-xr-x 3 root root 0 Jan 22 16:20 hugetlb/
dr-xr-xr-x 5 root root 0 Jan 22 16:20 memory/
lrwxrwxrwx 1 root root 16 Jan 22 16:20 net_cls -&gt; net_cls,net_prio/
dr-xr-xr-x 3 root root 0 Jan 22 16:20 net_cls,net_prio/
lrwxrwxrwx 1 root root 16 Jan 22 16:20 net_prio -&gt; net_cls,net_prio/
dr-xr-xr-x 3 root root 0 Jan 22 16:20 perf_event/
dr-xr-xr-x 5 root root 0 Jan 22 16:20 pids/
dr-xr-xr-x 2 root root 0 Jan 22 16:20 rdma/
dr-xr-xr-x 6 root root 0 Jan 22 16:20 systemd/
dr-xr-xr-x 5 root root 0 Jan 22 16:20 unified/

[root@ubuntu1804 ~]#cat /sys/fs/cgroup/cpu/docker/5dee9be9afdbab8c2f6c4c5eb0f956c9579efe93110daf638f8fd15f43d961e2/cpuacct.usage
4751336886

[root@ubuntu1804 ~]#cat /sys/fs/cgroup/memory/docker/5dee9be9afdbab8c2f6c4c5eb0f956c9579efe93110daf638f8fd15f43d961e2/cpuacct.usage

[root@ubuntu1804 ~]#cat /sys/fs/cgroup/memory/docker/5dee9be9afdbab8c2f6c4c5eb0f956c9579efe93110daf638f8fd15f43d961e2/memory.limit_in_bytes
9223372036854771712
[root@ubuntu1804 ~]#cat /sys/fs/cgroup/memory/docker/5dee9be9afdbab8c2f6c4c5eb0f956c9579efe93110daf638f8fd15f43d961e2/memory.max_usage_in_bytes
79278080
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:a2de403d-e9c4-4b98-8254-0abdde02aa1b" class="outline-4">
<h4 id="h:a2de403d-e9c4-4b98-8254-0abdde02aa1b">容器管理工具</h4>
<div class="outline-text-4" id="text-h:a2de403d-e9c4-4b98-8254-0abdde02aa1b">
<p>
有了以上的chroot、namespace、cgroups就具备了基础的容器运行环境，但是还需要有相应的容器创建与删除的管理工具、以及怎么样把容器运行起来、容器数据怎么处理、怎么进行启动与关闭等问题需要解决，于是容器管理技术出现了。目前主要是使用docker，早期使用 LXC<br>
</p>
</div>
<div id="outline-container-h:ee68d1e7-508d-468c-8fee-49644545dafc" class="outline-5">
<h5 id="h:ee68d1e7-508d-468c-8fee-49644545dafc">LXC</h5>
<div class="outline-text-5" id="text-h:ee68d1e7-508d-468c-8fee-49644545dafc">
<p>
LXC: Linux Container。可以提供轻量级的虚拟化功能,以便隔离进程和资源,包括一系列容器的管理工具软件,如，lxc-create,lxc-start,lxc-attach等,但这技术功能不完善,目前较少使用<br>
</p>

<p>
官方网站: <a href="https://linuxcontainers.org/">https://linuxcontainers.org/</a><br>
</p>

<p>
案例: Ubuntu安装 和使用 LXC<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#apt install lxc lxd
[root@ubuntu1804 ~]#lxc-checkconfig <span style="color: #b22222;">#</span><span style="color: #b22222;">&#26816;&#26597;&#20869;&#26680;&#23545;lcx&#30340;&#25903;&#25345;&#29366;&#20917;&#65292;&#24517;&#39035;&#20840;&#37096;&#20026;lcx
</span>Kernel configuration not found at /proc/config.gz; searching...
Kernel configuration found at /boot/config-4.15.0-29-generic
--- Namespaces ---
Namespaces: enabled
Utsname namespace: enabled
Ipc namespace: enabled
Pid namespace: enabled
User namespace: enabled
Network namespace: enabled
......
[root@ubuntu1804 ~]#lxc-create -t download --name alpine1 -- --dist alpine --release 3.9 --arch amd64
Setting up the GPG keyring
Downloading the image index
Downloading the rootfs
Downloading the metadata
The image cache is now ready
Unpacking the rootfs

[root@ubuntu1804 ~]#lxc-start alpine1 <span style="color: #b22222;">#</span><span style="color: #b22222;">&#21551;&#21160;lxc&#23481;&#22120;
</span>[root@ubuntu1804 ~]#lxc-attach alpine1 <span style="color: #b22222;">#</span><span style="color: #b22222;">&#36827;&#20837;lxc&#23481;&#22120;
</span>~ <span style="color: #b22222;"># </span><span style="color: #b22222;">ifconfig
</span>eth0 Link encap:Ethernet HWaddr 00:16:3E:DF:9E:45
lo Link encap:Local Loopback

~ <span style="color: #b22222;"># </span><span style="color: #b22222;">uname -r
</span>4.15.0-29-generic
~ <span style="color: #b22222;"># </span><span style="color: #b22222;">uname -a
</span>Linux alpine12 4.15.0-29-generic <span style="color: #b22222;">#</span><span style="color: #b22222;">31-Ubuntu SMP Tue Jul 17 15:39:52 UTC 2018x86_64 Linux
</span>~ <span style="color: #b22222;"># </span><span style="color: #b22222;">cat /etc/issue
</span>Welcome to Alpine Linux 9
Kernel \r on an \m (\l)
~ <span style="color: #b22222;"># </span><span style="color: #b22222;">exit</span>
</pre>
</div>

<p>
命令选项说明:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">-t &#27169;&#26495;: -t &#36873;&#39033;&#21518;&#38754;&#36319;&#30340;&#26159;&#27169;&#26495;&#65292;&#27169;&#24335;&#21487;&#20197;&#35748;&#20026;&#26159;&#19968;&#20010;&#21407;&#22411;&#65292;&#29992;&#26469;&#35828;&#26126;&#38656;&#35201;&#19968;&#20010;&#20160;&#20040;&#26679;&#30340;&#23481;&#22120;(&#27604;&#22914;&#23481;&#22120;&#37324;&#38754;&#38656;&#19981;&#38656;&#35201;&#26377;vim, apache&#31561;&#36719;&#20214;)&#65294;&#27169;&#26495;&#23454;&#38469;&#19978;&#23601;&#26159;&#19968;&#20010;&#33050;&#26412;&#25991;&#20214;(&#20301;&#20110;/usr/share/lxc/templates&#30446;&#24405;)&#65292;&#25105;&#20204;&#36825;&#37324;&#25351;&#23450;download&#27169;&#26495;(lxc-create&#20250;&#35843;&#29992;lxc-download&#33050;&#26412;&#65292;&#35813;&#33050;&#26412;&#20301;&#20110;&#21018;&#35828;&#30340;&#27169;&#26495;&#30446;&#24405;&#20013;)&#26159;&#35828;&#26126;&#25105;&#20204;&#30446;&#21069;&#27809;&#26377;&#33258;&#24049;&#27169;&#26495;&#65292;&#38656;&#35201;&#19979;&#36733;&#23448;&#26041;&#30340;&#27169;&#26495;
--name &#23481;&#22120;&#21517;&#31216;: &#20026;&#21019;&#24314;&#30340;&#23481;&#22120;&#21629;&#21517;
-- : --&#29992;&#26469;&#35828;&#26126;&#21518;&#38754;&#30340;&#21442;&#25968;&#26159;&#20256;&#36882;&#32473;download&#33050;&#26412;&#30340;&#65292;&#21578;&#35785;&#33050;&#26412;&#38656;&#35201;&#19979;&#36733;&#20160;&#20040;&#26679;&#30340;&#27169;&#26495;
--dist &#25805;&#20316;&#31995;&#32479;&#21517;&#31216;: &#25351;&#23450;&#25805;&#20316;&#31995;&#32479;
--release &#25805;&#20316;&#31995;&#32479;: &#25351;&#23450;&#25805;&#20316;&#31995;&#32479;&#65292;&#21487;&#20197;&#26159;&#21508;&#31181;Linux&#30340;&#21464;&#31181;
--arch &#26550;&#26500;: &#25351;&#23450;&#26550;&#26500;&#65292;&#26159;x86&#36824;&#26159;arm&#65292;&#26159;32&#20301;&#36824;&#26159;64&#20301;1.1.7.3 pouch
</pre>
</div>

<p>
lxc启动容器依赖于模板，清华模板源: <a href="https://mirrors.tuna.tsinghua.edu.cn/help/lxc-images/">https://mirrors.tuna.tsinghua.edu.cn/help/lxc-images/</a> ，但是做模板相对较难，需要手动一步步创构建文件系统、准备基础目录及可执行程序等，而且在大规模使用容器的场景很难横向扩展，另外后期代码升级也需要重新从头构建模板，基于以上种种原因便有了docker<br>
</p>
</div>
</div>
<div id="outline-container-h:450337eb-8b80-4d44-87b3-b5873acaf67e" class="outline-5">
<h5 id="h:450337eb-8b80-4d44-87b3-b5873acaf67e">docker</h5>
<div class="outline-text-5" id="text-h:450337eb-8b80-4d44-87b3-b5873acaf67e">
<p>
Docker 相当于增强版的LXC,功能更为强大和易用,也是当前最主流的容器前端管理工具<br>
</p>

<p>
Docker 先启动一个容器也需要一个外部模板，也称为镜像，docke的镜像可以保存在一个公共的地方共享使用，只要把镜像下载下来就可以使用，最主要的是可以在镜像基础之上做自定义配置并且可以再把其提交为一个镜像，一个镜像可以被启动为多个容器。<br>
<img src="./images/Snipaste_2023-04-25_22-16-40.png" alt="Snipaste_2023-04-25_22-16-40.png"><br>
</p>

<p>
Docker的镜像是分层的，镜像底层为库文件且只读层即不能写入也不能删除数据，从镜像加载启动为一个容器后会生成一个可写层，其写入的数据会复制到宿主机上对应容器的目录，但是容器内的数据在删除容器后也会被随之删除。<br>
</p>
</div>
</div>
<div id="outline-container-h:365ed166-8a20-4643-b9c9-386b1fd43832" class="outline-5">
<h5 id="h:365ed166-8a20-4643-b9c9-386b1fd43832">pouch</h5>
<div class="outline-text-5" id="text-h:365ed166-8a20-4643-b9c9-386b1fd43832">
<p>
项目网点: <a href="https://github.com/alibaba/pouch">https://github.com/alibaba/pouch</a><br>
</p>

<p>
Pouch （小袋子）起源于 2011 年，并于2017年11月19日上午，在中国开源年会现场，阿里巴巴正式开源了基于 Apache 2.0 协议的容器技术 Pouch。Pouch 是一款轻量级的容器技术，拥有快速高效、可移植性高、资源占用少等特性，主要帮助阿里更快的做到内部业务的交付，同时提高超大规模下数据中心的物理资源利用率<br>
</p>

<p>
目前的容器方案大多基于 Linux 内核提供的 cgroup 和 namespace 来实现隔离，然后这样轻量级方案<br>
</p>

<p>
存在弊端:<br>
</p>
<ul class="org-ul">
<li>容器间，容器与宿主间，共享同一个内核<br></li>
<li>内核实现的隔离资源，维度不足<br></li>
</ul>

<p>
面对如此的内核现状，阿里巴巴采取了三个方面的工作，来解决容器的安全问题:<br>
</p>
<ul class="org-ul">
<li>用户态增强容器的隔离维度，比如网络带宽、磁盘使用量等<br></li>
<li>给内核提交 patch，修复容器的资源可见性问题，cgroup 方面的 bug<br></li>
<li>实现基于 Hypervisor 的容器，通过创建新内核来实现容器隔离<br></li>
</ul>
</div>
</div>
<div id="outline-container-h:17d80072-9150-45b4-ba19-b65e73f5c724" class="outline-5">
<h5 id="h:17d80072-9150-45b4-ba19-b65e73f5c724">Podman</h5>
<div class="outline-text-5" id="text-h:17d80072-9150-45b4-ba19-b65e73f5c724">
<p>
虽然目前 Docker 是管理 Linux 容器最好的工具，注意没有之一，但是podman的横空出现即将改变这一点<br>
</p>

<p>
什么是Podman？<br>
Podman即Pod Manager tool，从名称上可以看出和kubernets的pod的密切联系，不过就其功能来说，简而言之: `alias docker = podman` ,是CentOS 8 新集成的功能，或许不久的未来会代替docker<br>
</p>

<p>
Podman是一个 为 Kubernetes 而生的开源的容器管理工具，原来是 CRI-O（即容器运行时接口CRI 和开放容器计划OCI） 项目的一部分，后来被分离成一个单独的项目叫 libpod。其可在大多数Linux平台上使用，它是一种无守护程序的容器引擎，用于在Linux系统上开发，管理和运行任何符合OpenContainer Initiative（OCI）标准的容器和容器镜像。<br>
</p>

<p>
Podman 提供了一个与Docker兼容的命令行前端，Podman 里面87%的指令都和Docker CLI 相同，因此可以简单地为Docker CLI别名，即“ alias docker = podman”，事实上，podman使用的一些库也是docker的一部分。<br>
</p>

<p>
官网地址: <a href="https://podman.io/">https://podman.io/</a><br>
</p>

<p>
项目地址: <a href="https://github.com/containers/libpod">https://github.com/containers/libpod</a><br>
</p>

<p>
Podman 和docker不同之处<br>
</p>
<ul class="org-ul">
<li>docker 需要在系统上运行一个守护进程(docker daemon)，这会产生一定的开销，而podman 不需要<br></li>
<li>启动容器的方式不同:<br>
<ul class="org-ul">
<li>docker cli 命令通过API跟 Docker Engine(引擎) 交互告诉它我想创建一个container，然后docker Engine 才会调用 OCI container runtime(runc) 来启动一个container。这代表container的process(进程)不会是 Docker CLI 的 child process(子进程) ，而是 DockerEngine 的 child process 。<br></li>
<li>Podman 是直接给 OCI containner runtime(runc) 进行交互来创建container的，所以container process 直接是 podman 的 child process 。<br></li>
</ul></li>
<li>因为docke有docker daemon，所以docker启动的容器支持 &#x2013;restart 策略，但是podman不支持<br></li>
<li>docker需要使用root用户来创建容器。 这可能会产生安全风险，尤其是当用户知道docker run命令的&#x2013;privileged选项时。podman既可以由root用户运行，也可以由非特权用户运行<br></li>
<li>docker在Linux上作为守护进程运行扼杀了容器社区的创新。 如果要更改容器的工作方式，则需要更改docker守护程序并将这些更改推送到上游。 没有守护进程，容器基础结构更加模块化，更容易进行更改。 podman的无守护进程架构更加灵活和安全。<br></li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">docker pull docker.io/library/mysql:latest

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21152;&#36895;
</span>vim /etc/containers/registries.conf
[registries.search]
<span style="color: #a0522d;">registries</span> = [<span style="color: #8b2252;">'docker.mirrors.aliyuncs.com'</span>]
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:a1b75597-ac68-4dc3-a318-4373536e277b" class="outline-4">
<h4 id="h:a1b75597-ac68-4dc3-a318-4373536e277b">Docker 的优势</h4>
<div class="outline-text-4" id="text-h:a1b75597-ac68-4dc3-a318-4373536e277b">
<ul class="org-ul">
<li>快速部署: 短时间内可以部署成百上千个应用，更快速交付到线上<br></li>
<li>高效虚拟化: 不需要额外hypervisor支持，基于linux内核实现应用虚拟化，相比虚拟机大幅提高性能和效率<br></li>
<li>节省开支: 提高服务器利用率，降低IT支出<br></li>
<li>简化配置: 将运行环境打包保存至容器，使用时直接启动即可<br></li>
<li>环境统一: 将开发，测试，生产的应用运行环境进行标准化和统一，减少环境不一样带来的各种问题<br></li>
<li>快速迁移和扩展: 可实现跨平台运行在物理机、虚拟机、公有云等环境，良好的兼容性可以方便将应用从A宿主机迁移到B宿主机，甚至是A平台迁移到B平台<br></li>
<li>更好的实现面向服务的架构,推荐一个容器只运行一个应用,实现分布的应用模型,可以方便的进行横向扩展,符合开发中高内聚,低耦合的要求,减少不同服务之间的相互影响<br></li>
</ul>
</div>
</div>
<div id="outline-container-h:713e070c-687c-422f-b18a-52fc38587c6e" class="outline-4">
<h4 id="h:713e070c-687c-422f-b18a-52fc38587c6e">Docker 的缺点</h4>
<div class="outline-text-4" id="text-h:713e070c-687c-422f-b18a-52fc38587c6e">
<ul class="org-ul">
<li>多个容器共用宿主机的内核，各应用之间的隔离不如虚拟机彻底<br></li>
<li>由于和宿主机之间的进程也是隔离的,需要进入容器查看和调试容器内进程等资源,变得比较困难和繁琐<br></li>
<li>如果容器内进程需要查看和调试,需要在每个容器内都需要安装相应的工具,这也造成存储空间的重复浪费<br></li>
</ul>
</div>
</div>
<div id="outline-container-h:83b64a12-69f3-45e5-af9f-951057c6442d" class="outline-4">
<h4 id="h:83b64a12-69f3-45e5-af9f-951057c6442d">容器的核心技术</h4>
<div class="outline-text-4" id="text-h:83b64a12-69f3-45e5-af9f-951057c6442d">
</div>
<div id="outline-container-h:f18f3f97-3e14-4951-a193-373bfea4d871" class="outline-5">
<h5 id="h:f18f3f97-3e14-4951-a193-373bfea4d871">容器规范</h5>
<div class="outline-text-5" id="text-h:f18f3f97-3e14-4951-a193-373bfea4d871">
<p>
OCI 官网:<a href="https://opencontainers.org/">https://opencontainers.org/</a><br>
容器技术除了的docker之外，还有coreOS的rkt，还有阿里的Pouch，为了保证容器生态的标准性和健康可持续发展，包括Linux 基金会、Docker、微软、红帽谷歌和、IBM、等公司在2015年6月共同成立了一个叫Open Container Initiative（OCI）的组织，其目的就是制定开放的标准的容器规范，目前OCI一共发布了两个规范，分别是runtime spec和 image format spec，有了这两个规范，不同的容器公司开发的容器只要兼容这两个规范，就可以保证容器的可移植性和相互可操作性。<br>
</p>
</div>
</div>
<div id="outline-container-h:a7eeefd6-c79e-4c23-b6cd-6f0f97dcd280" class="outline-5">
<h5 id="h:a7eeefd6-c79e-4c23-b6cd-6f0f97dcd280">容器 runtime</h5>
<div class="outline-text-5" id="text-h:a7eeefd6-c79e-4c23-b6cd-6f0f97dcd280">
<p>
runtime是真正运行容器的地方，因此为了运行不同的容器runtime需要和操作系统内核紧密合作相互在支持，以便为容器提供相应的运行环境<br>
</p>

<p>
runtime 类型:<br>
</p>
<ul class="org-ul">
<li>Lxc: linux上早期的runtime，在 2013 年 Docker 刚发布的时候,就是采用lxc作为runtime, Docker把 LXC 复杂的容器创建与使用方式简化为 Docker 自己的一套命令体系。随着Docker的发展，原有的LXC不能满足Docker的需求,比如跨平台功能<br></li>
<li>Libcontainer: 随着 Docker 的不断发展，重新定义容器的实现标准，将底层实现都抽象化到<br></li>
<li>Libcontainer 的接口。这就意味着，底层容器的实现方式变成了一种可变的方案，无论是使用namespace、cgroups 技术抑或是使用 systemd 等其他方案，只要实现了 Libcontainer 定义的一组接口，Docker 都可以运行。这也为 Docker 实现全面的跨平台带来了可能。<br></li>
<li>runc: 早期libcontainer是Docker公司控制的一个开源项目，OCI的成立后,Docker把libcontainer项目移交给了OCI组织,runC就是在libcontainer的基础上进化而来,目前Docker默认的runtime，runc遵守OCI规范<br></li>
<li>rkt: 是CoreOS开发的容器runtime，也符合OCI规范，所以使用rktruntime也可以运行Docker容器<br></li>
</ul>

<p>
范例: 查看docker的 runtime<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker info
Runtimes: runc <span style="color: #b22222;">#</span><span style="color: #b22222;">Runtimes
</span>Default Runtime: runc <span style="color: #b22222;">#</span><span style="color: #b22222;">runtime</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-h:75565f90-61cc-4e6b-9fe8-a67d6600262f" class="outline-5">
<h5 id="h:75565f90-61cc-4e6b-9fe8-a67d6600262f">容器管理工具</h5>
<div class="outline-text-5" id="text-h:75565f90-61cc-4e6b-9fe8-a67d6600262f">
<p>
管理工具连接runtime与用户，对用户提供图形或命令方式操作，然后管理工具将用户操作传递给runtime执行。<br>
</p>

<ul class="org-ul">
<li>lxc 是lxd 的管理工具<br></li>
<li>Runc的管理工具是docker engine，docker engine包含后台deamon和cli两部分，大家经常提到的Docker就是指的docker engine<br></li>
<li>Rkt的管理工具是rkt cli<br></li>
</ul>
</div>
</div>
<div id="outline-container-h:fdbecb54-cee7-47ba-981e-bfab881b296c" class="outline-5">
<h5 id="h:fdbecb54-cee7-47ba-981e-bfab881b296c">容器定义工具</h5>
<div class="outline-text-5" id="text-h:fdbecb54-cee7-47ba-981e-bfab881b296c">
<p>
容器定义工具允许用户定义容器的属性和内容，以方便容器能够被保存、共享和重建。<br>
Docker image: 是docker 容器的模板，runtime依据docker image创建容器<br>
Dockerfile: 包含N个命令的文本文件，通过dockerfile创建出docker image<br>
ACI(App container image): 与docker image类似，是CoreOS开发的rkt容器的镜像格式<br>
</p>
</div>
</div>
<div id="outline-container-h:3663310f-2e8f-42d5-85c0-488606249e20" class="outline-5">
<h5 id="h:3663310f-2e8f-42d5-85c0-488606249e20">镜像仓库 Registry</h5>
<div class="outline-text-5" id="text-h:3663310f-2e8f-42d5-85c0-488606249e20">
<ul class="org-ul">
<li>统一保存镜像而且是多个不同镜像版本的地方，叫做镜像仓库<br></li>
<li>Docker hub: docker官方的公共仓库，已经保存了大量的常用镜像，可以方便大家直接使用<br></li>
<li>阿里云，网易等第三方镜像的公共仓库<br></li>
<li>Image registry: docker 官方提供的私有仓库部署工具，无web管理界面，目前使用较少<br></li>
<li>Harbor: vmware 提供的自带web界面自带认证功能的镜像私有仓库，目前有很多公司使用<br></li>
</ul>
</div>
</div>
<div id="outline-container-h:0197109d-34be-480b-b69c-b383acbfb6d7" class="outline-5">
<h5 id="h:0197109d-34be-480b-b69c-b383acbfb6d7">容器编排工具</h5>
<div class="outline-text-5" id="text-h:0197109d-34be-480b-b69c-b383acbfb6d7">
<p>
当多个容器在多个主机运行的时候，单独管理容器是相当复杂而且很容易出错，而且也无法实现某一台主机宕机后容器自动迁移到其他主机从而实现高可用的目的，也无法实现动态伸缩的功能，因此需要有一种工具可以实现统一管理、动态伸缩、故障自愈、批量执行等功能，这就是容器编排引擎<br>
</p>

<p>
容器编排通常包括容器管理、调度、集群定义和服务发现等功能<br>
</p>
<ul class="org-ul">
<li>Docker compose : docker 官方实现单机的容器的编排工具<br></li>
<li>Docker swarm: docker 官方开发的容器编排引擎,支持overlay network<br></li>
<li>Mesos+Marathon: Mesos是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核。Mesos最初是由加州大学伯克利分校的AMPLab开发的，后在Twitter得到广泛使用。通用的集群组员调度平台，mesos(资源分配)与marathon(容器编排平台)一起提供容器编排引擎功能<br></li>
<li>Kubernetes: google领导开发的容器编排引擎，内部项目为Borg，且其同时支持 docker 和CoreOS,当前已成为容器编排工具事实上的标准<br></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-h:ee0966d8-a06c-4660-afbe-d80a6951095d" class="outline-4">
<h4 id="h:ee0966d8-a06c-4660-afbe-d80a6951095d">docker(容器)的依赖技术</h4>
<div class="outline-text-4" id="text-h:ee0966d8-a06c-4660-afbe-d80a6951095d">
<ul class="org-ul">
<li>容器网络:<br></li>
</ul>
<p>
docker自带的网络docker network仅支持管理单机的容器网络，当多主机运行的时候需要使用第三方开源网络，例如:calico、flannel等<br>
</p>

<ul class="org-ul">
<li>服务发现:<br></li>
</ul>
<p>
容器的动态扩容特性决定了容器IP也会随之变化，因此需要有一种机制开源自动识别并将用户请求动态转发到新创建的容器上，kubernetes自带服务发现功能，需要结合kube-dns服务解析内部域名<br>
</p>

<ul class="org-ul">
<li>容器监控:<br></li>
</ul>
<p>
可以通过原生命令docker ps/top/stats 查看容器运行状态，另外也可以使用Prometheus 、heapster等第三方监控工具监控容器的运行状态<br>
</p>

<ul class="org-ul">
<li>数据管理:<br></li>
</ul>
<p>
容器的动态迁移会导致其在不同的Host之间迁移，因此如何保证与容器相关的数据也能随之迁移或随时访问，可以使用逻辑卷/存储挂载等方式解决<br>
</p>

<ul class="org-ul">
<li>日志收集:<br></li>
</ul>
<p>
docker 原生的日志查看工具docker logs，但是容器内部的日志需要通过ELK等专门的日志收集分析和展示工具进行处理<br>
</p>
</div>
</div>
</div>
<div id="outline-container-h:5227bbd9-6e8e-40a7-91ea-079b03a3ac66" class="outline-3">
<h3 id="h:5227bbd9-6e8e-40a7-91ea-079b03a3ac66">Docker安装及基础命令介绍</h3>
<div class="outline-text-3" id="text-h:5227bbd9-6e8e-40a7-91ea-079b03a3ac66">
</div>
<div id="outline-container-h:a55c40b1-0333-48ef-b392-bb18bcf91e4a" class="outline-4">
<h4 id="h:a55c40b1-0333-48ef-b392-bb18bcf91e4a">安装和删除方法</h4>
<div class="outline-text-4" id="text-h:a55c40b1-0333-48ef-b392-bb18bcf91e4a">
</div>
<div id="outline-container-h:b110e97b-0b8a-43c3-814a-b7f50fabff0d" class="outline-5">
<h5 id="h:b110e97b-0b8a-43c3-814a-b7f50fabff0d">安装文档参考</h5>
<div class="outline-text-5" id="text-h:b110e97b-0b8a-43c3-814a-b7f50fabff0d">
<ul class="org-ul">
<li>官方文档 : <a href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/</a><br></li>
</ul>

<p>
由于国内访问限制，可以使用国内源提代的自动脚本安装<br>
</p>
<ul class="org-ul">
<li>中科大：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/">https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/</a><br></li>
<li>阿里：<a href="https://developer.aliyun.com/mirror/docker-ce">https://developer.aliyun.com/mirror/docker-ce</a><br></li>
<li>清华：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/">https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/</a><br></li>
</ul>
</div>
</div>
<div id="outline-container-h:740cede6-ad62-4fdf-8d4e-6668beb030f1" class="outline-5">
<h5 id="h:740cede6-ad62-4fdf-8d4e-6668beb030f1">Ubuntu 安装和删除Docker</h5>
<div class="outline-text-5" id="text-h:740cede6-ad62-4fdf-8d4e-6668beb030f1">
<p>
官方文档: <a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a><br>
</p>

<p>
Ubuntu 14.04/16.04/18.04 安装docker<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;"># </span><span style="color: #b22222;">step 1: &#23433;&#35013;&#24517;&#35201;&#30340;&#19968;&#20123;&#31995;&#32479;&#24037;&#20855;
</span>sudo apt-get update
sudo apt-get -y install apt-transport-https ca-certificates curl softwareproperties-common
<span style="color: #b22222;"># </span><span style="color: #b22222;">step 2: &#23433;&#35013;GPG&#35777;&#20070;
</span>curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
<span style="color: #b22222;"># </span><span style="color: #b22222;">Step 3: &#20889;&#20837;&#36719;&#20214;&#28304;&#20449;&#24687;
</span>sudo add-apt-repository <span style="color: #8b2252;">"deb [arch=amd64] https://mirrors.aliyun.com/dockerce/linux/ubuntu $(lsb_release -cs) stable"</span>
<span style="color: #b22222;"># </span><span style="color: #b22222;">Step 4: &#26356;&#26032;&#24182;&#23433;&#35013;Docker-CE
</span>sudo apt-get -y update
sudo apt-get -y install docker-ce
<span style="color: #b22222;"># </span><span style="color: #b22222;">&#23433;&#35013;&#25351;&#23450;&#29256;&#26412;&#30340;Docker-CE:
</span><span style="color: #b22222;"># </span><span style="color: #b22222;">Step 1: &#26597;&#25214;Docker-CE&#30340;&#29256;&#26412;:
</span>apt-cache madison docker-ce
docker-ce | 5:19.03.5~3-0~ubuntu-bionic | https://mirrors.aliyun.com/dockerce/linux/ubuntu bionic/stable amd64 Packages
docker-ce | 18.06.3~ce~3-0~ubuntu | https://mirrors.aliyun.com/dockerce/linux/ubuntu bionic/stable amd64 Packages
<span style="color: #b22222;"># </span><span style="color: #b22222;">Step 2: &#23433;&#35013;&#25351;&#23450;&#29256;&#26412;&#30340;Docker-CE: (VERSION&#20363;&#22914;&#19978;&#38754;&#30340;5:17.03.1~ce-0~ubuntu-xenial)
</span>sudo apt-get -y install docker-ce=[VERSION] docker-ce-cli=[VERSION]
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#31034;&#20363;:&#25351;&#23450;&#29256;&#26412;&#23433;&#35013;
</span>apt-get -y install docker-ce=5:18.09.9~3-0~ubuntu-bionic docker-cecli=5:18.09.9~3-0~ubuntu-bionic
</pre>
</div>

<p>
删除docker<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu ~]#apt purge docker-ce
[root@ubuntu ~]#rm -rf /var/lib/docker
</pre>
</div>
</div>
</div>
<div id="outline-container-h:dbb5157d-59c8-4135-9255-b2dc85267b88" class="outline-5">
<h5 id="h:dbb5157d-59c8-4135-9255-b2dc85267b88">CentOS 安装和删除Docker</h5>
<div class="outline-text-5" id="text-h:dbb5157d-59c8-4135-9255-b2dc85267b88">
<p>
官方文档: <a href="https://docs.docker.com/install/linux/docker-ce/centos/">https://docs.docker.com/install/linux/docker-ce/centos/</a><br>
</p>

<p>
CentOS 6 因内核太旧，即使支持安装docker，但会有各种问题，不建议安装<br>
CentOS 7 的 extras 源虽然可以安装docker，但包比较旧，建议从官方源或镜像源站点下载安装<br>
</p>
</div>
</div>
<div id="outline-container-h:08c3bb76-ad51-4e24-82ce-37d299429f13" class="outline-5">
<h5 id="h:08c3bb76-ad51-4e24-82ce-37d299429f13">Kali Linux上安装docker</h5>
<div class="outline-text-5" id="text-h:08c3bb76-ad51-4e24-82ce-37d299429f13">
<p>
官方文档：<a href="https://www.kali.org/docs/containers/installing-docker-on-kali/#installing-docker-ce-on-kali-linux">https://www.kali.org/docs/containers/installing-docker-on-kali/#installing-docker-ce-on-kali-linux</a><br>
</p>

<p>
Kali Linux 基于 Debian，因此我们需要使用 Debian 的当前稳定版本。<br>
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#20351;&#29992;debian&#31283;&#23450;&#29256;docker&#28304;
</span><span style="color: #483d8b;">echo</span> <span style="color: #8b2252;">"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian bookworm stable"</span> | <span style="color: #8b2252;">\</span>
  sudo tee /etc/apt/sources.list.d/docker.list

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#23548;&#20837; gpg &#23494;&#38053;
</span>curl -fsSL https://download.docker.com/linux/debian/gpg |
  sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#23433;&#35013;&#26368;&#26032;&#29256;&#26412;&#30340; docker-ce
</span>sudo apt update
sudo apt install -y docker-ce docker-ce-cli containerd.io

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#23433;&#35013;docker&#25554;&#20214;
</span>sudo apt install -y docker-buildx-plugin docker-compose-plugin

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#23558;&#33258;&#24049;&#28155;&#21152;&#21040; docker &#32452;&#65292;&#20197;&#20415;&#20351;&#29992; docker &#32780;&#19981;&#38656;&#35201; sudo. 
</span>sudo usermod -aG docker $<span style="color: #a0522d;">USER</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#38656;&#35201; &#27880;&#38144;&#24182;&#37325;&#26032;&#30331;&#24405;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-h:6933d6f3-a2ba-42a9-a742-4b70c744abc8" class="outline-5">
<h5 id="h:6933d6f3-a2ba-42a9-a742-4b70c744abc8">EndeavourOS 安装docker</h5>
<div class="outline-text-5" id="text-h:6933d6f3-a2ba-42a9-a742-4b70c744abc8">
<p>
提前确认系统是否有bridge模块，没有安装<br>
</p>
<div class="org-src-container">
<pre class="src src-sh">lsmod |grep bridge

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#23433;&#35013;&#27169;&#22359;
</span>sudo pacman -S linux-headers
sudo pacman -Syu
sudo pacman -S linux
sudo pacman -S mkinitcpio
sudo mkinitcpio -P
reboot <span style="color: #b22222;">#</span><span style="color: #b22222;">&#37325;&#21551;
</span>
sudo modprobe bridge
sudo modprobe br_netfilter
</pre>
</div>

<p>
EndeavourOS 使用 Arch Linux 的包管理器 pacman，直接执行以下命令安装 Docker<br>
</p>
<div class="org-src-container">
<pre class="src src-sh">sudo pacman -S docker
sudo systemctl start docker
sudo systemctl enable docker

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#39564;&#35777;
</span>docker version
docker info

sudo pacman -S docker-compose
</pre>
</div>
</div>
</div>
<div id="outline-container-h:c223b563-e509-44f9-9ba0-150271e29910" class="outline-5">
<h5 id="h:c223b563-e509-44f9-9ba0-150271e29910">Linux 二进制安装</h5>
<div class="outline-text-5" id="text-h:c223b563-e509-44f9-9ba0-150271e29910">
<p>
本方法适用于无法上网或无法通过包安装方式安装的主机上安装docker<br>
安装文档: <a href="https://docs.docker.com/install/linux/docker-ce/binaries/">https://docs.docker.com/install/linux/docker-ce/binaries/</a><br>
</p>
</div>
</div>
</div>
<div id="outline-container-h:a5e45f05-a786-45ba-80c5-5cf830cf72db" class="outline-4">
<h4 id="h:a5e45f05-a786-45ba-80c5-5cf830cf72db">docker 程序环境</h4>
<div class="outline-text-4" id="text-h:a5e45f05-a786-45ba-80c5-5cf830cf72db">
<p>
环境配置文件:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">/etc/sysconfig/docker-network
/etc/sysconfig/docker-storage
/etc/sysconfig/docker
</pre>
</div>

<p>
Unit File:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">/usr/lib/systemd/system/docker.service
</pre>
</div>

<p>
docker-ce 配置文件<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">/etc/containers/registries.conf
</pre>
</div>


<p>
其它配置<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">mkdir -p /etc/docker/
cat&gt;/etc/docker/daemon.json&lt;&lt;EOF<span style="color: #ffa54f;">
{
  "registry-mirrors": [
      "https://fz5yth0r.mirror.aliyuncs.com",
      "http://hub-mirror.c.163.com/",
      "https://docker.mirrors.ustc.edu.cn/",
      "https://registry.docker-cn.com"
  ],
  "data-root":"/data/docker",
  "storage-opts": [
    "overlay2.override_kernel_check=true"
  ],
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "100m",
    "max-file": "3"
  }
}
EOF</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-h:85a1d040-8610-4551-b8fd-0d438596a118" class="outline-4">
<h4 id="h:85a1d040-8610-4551-b8fd-0d438596a118">docker 命令帮助</h4>
<div class="outline-text-4" id="text-h:85a1d040-8610-4551-b8fd-0d438596a118">
<p>
docker 命令是最常使用的docker 客户端命令，其后面可以加不同的参数以实现不同的功能<br>
docker 命令格式<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">docker [OPTIONS] COMMAND
COMMAND&#20998;&#20026;
Management Commands <span style="color: #b22222;">#</span><span style="color: #b22222;">&#25351;&#23450;&#31649;&#29702;&#30340;&#36164;&#28304;&#23545;&#35937;&#31867;&#22411;,&#36739;&#26032;&#30340;&#21629;&#20196;&#29992;&#27861;,&#23558;&#21629;&#20196;&#25353;&#36164;&#28304;&#31867;&#22411;&#36827;&#34892;&#20998;&#31867;,&#26041;&#20415;&#20351;&#29992;
</span>Commands <span style="color: #b22222;">#</span><span style="color: #b22222;">&#23545;&#19981;&#21516;&#36164;&#28304;&#25805;&#20316;&#30340;&#21629;&#20196;&#19981;&#20998;&#31867;,&#20351;&#29992;&#23481;&#26131;&#20135;&#29983;&#28151;&#20081;</span>
</pre>
</div>

<p>
命令有很多子命令，可以用下面方法查看帮助<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">docker &#21629;&#20196;&#24110;&#21161;
</span>man docker
docker
docker --help
<span style="color: #b22222;">#</span><span style="color: #b22222;">docker &#23376;&#21629;&#20196;&#24110;&#21161;
</span>man docker-COMMAND
docker COMMAND --help
[root@ubuntu1804 ~]#docker --help
</pre>
</div>

<p>
官方文档: <a href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a><br>
</p>
</div>
</div>
<div id="outline-container-h:f2315ca6-1c33-46a7-a917-1e08f814e1bf" class="outline-4">
<h4 id="h:f2315ca6-1c33-46a7-a917-1e08f814e1bf">查看 Docker 相关信息</h4>
<div class="outline-text-4" id="text-h:f2315ca6-1c33-46a7-a917-1e08f814e1bf">
</div>
<div id="outline-container-h:35d40c70-c15c-44e5-84e1-943278032d38" class="outline-5">
<h5 id="h:35d40c70-c15c-44e5-84e1-943278032d38">查看 docker 版本</h5>
<div class="outline-text-5" id="text-h:35d40c70-c15c-44e5-84e1-943278032d38">
<p>
docker version<br>
</p>
</div>
</div>
<div id="outline-container-h:8a53fbd2-383b-479a-83ab-6eeb5ba2626b" class="outline-5">
<h5 id="h:8a53fbd2-383b-479a-83ab-6eeb5ba2626b">查看 docker 详解信息</h5>
<div class="outline-text-5" id="text-h:8a53fbd2-383b-479a-83ab-6eeb5ba2626b">
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker info
Client:
Debug Mode: false <span style="color: #b22222;">#</span><span style="color: #b22222;">client &#31471;&#26159;&#21542;&#24320;&#21551; debug
</span>Server:
Containers: 2 <span style="color: #b22222;">#</span><span style="color: #b22222;">&#24403;&#21069;&#20027;&#26426;&#36816;&#34892;&#30340;&#23481;&#22120;&#24635;&#25968;
</span>Running: 0 <span style="color: #b22222;">#</span><span style="color: #b22222;">&#26377;&#20960;&#20010;&#23481;&#22120;&#26159;&#27491;&#22312;&#36816;&#34892;&#30340;
</span>Paused: 0 <span style="color: #b22222;">#</span><span style="color: #b22222;">&#26377;&#20960;&#20010;&#23481;&#22120;&#26159;&#26242;&#20572;&#30340;
</span>Stopped: 2 <span style="color: #b22222;">#</span><span style="color: #b22222;">&#26377;&#20960;&#20010;&#23481;&#22120;&#26159;&#20572;&#27490;&#30340;
</span>Images: 4 <span style="color: #b22222;">#</span><span style="color: #b22222;">&#24403;&#21069;&#26381;&#21153;&#22120;&#30340;&#38236;&#20687;&#25968;
</span>Server Version: 19.03.5 <span style="color: #b22222;">#</span><span style="color: #b22222;">&#26381;&#21153;&#31471;&#29256;&#26412;
</span>Storage Driver: overlay2 <span style="color: #b22222;">#</span><span style="color: #b22222;">&#27491;&#22312;&#20351;&#29992;&#30340;&#23384;&#20648;&#24341;&#25806;
</span>Backing Filesystem: extfs <span style="color: #b22222;">#</span><span style="color: #b22222;">&#21518;&#31471;&#25991;&#20214;&#31995;&#32479;&#65292;&#21363;&#26381;&#21153;&#22120;&#30340;&#30913;&#30424;&#25991;&#20214;&#31995;&#32479;
</span>Supports d_type: true <span style="color: #b22222;">#</span><span style="color: #b22222;">&#26159;&#21542;&#25903;&#25345; d_type
</span>Native Overlay Diff: true <span style="color: #b22222;">#</span><span style="color: #b22222;">&#26159;&#21542;&#25903;&#25345;&#24046;&#24322;&#25968;&#25454;&#23384;&#20648;
</span>Logging Driver: json-file <span style="color: #b22222;">#</span><span style="color: #b22222;">&#26085;&#24535;&#31867;&#22411;
</span>Cgroup Driver: cgroupfs <span style="color: #b22222;">#</span><span style="color: #b22222;">Cgroups &#31867;&#22411;
</span>Plugins: <span style="color: #b22222;">#</span><span style="color: #b22222;">&#25554;&#20214;
</span>Volume: local <span style="color: #b22222;">#</span><span style="color: #b22222;">&#21367;
</span>Network: bridge host ipvlan macvlan null overlay <span style="color: #b22222;"># </span><span style="color: #b22222;">overlay &#36328;&#20027;&#26426;&#36890;&#20449;
</span>Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk
syslog <span style="color: #b22222;"># </span><span style="color: #b22222;">&#26085;&#24535;&#31867;&#22411;
</span>Swarm: inactive <span style="color: #b22222;">#</span><span style="color: #b22222;">&#26159;&#21542;&#25903;&#25345; swarm
</span>Runtimes: runc <span style="color: #b22222;">#</span><span style="color: #b22222;">&#24050;&#23433;&#35013;&#30340;&#23481;&#22120;&#36816;&#34892;&#26102;
</span>Default Runtime: runc <span style="color: #b22222;">#</span><span style="color: #b22222;">&#40664;&#35748;&#20351;&#29992;&#30340;&#23481;&#22120;&#36816;&#34892;&#26102;
</span>Init Binary: docker-init <span style="color: #b22222;">#</span><span style="color: #b22222;">&#21021;&#22987;&#21270;&#23481;&#22120;&#30340;&#23432;&#25252;&#36827;&#31243;&#65292;&#21363; pid &#20026; 1 &#30340;&#36827;&#31243;
</span>containerd version: b34a5c8af56e510852c35414db4c1f4fa6172339 <span style="color: #b22222;">#</span><span style="color: #b22222;">&#29256;&#26412;
</span>runc version: 3e425f80a8c931f88e6d94a8c831b9d5aa481657 <span style="color: #b22222;">#</span><span style="color: #b22222;">runc &#29256;&#26412;
</span>init version: fec3683 <span style="color: #b22222;">#</span><span style="color: #b22222;">init &#29256;&#26412;
</span>Security Options: <span style="color: #b22222;">#</span><span style="color: #b22222;">&#23433;&#20840;&#36873;&#39033;
</span>apparmor <span style="color: #b22222;">#</span><span style="color: #b22222;">&#23433;&#20840;&#27169;&#22359;&#65292;https://docs.docker.com/engine/security/apparmor/
</span>seccomp <span style="color: #b22222;">#</span><span style="color: #b22222;">&#23433;&#20840;&#35745;&#31639;&#27169;&#22359;&#65292;&#21363;&#21046;&#23481;&#22120;&#25805;&#20316;&#65292;
</span>https://docs.docker.com/engine/security/seccomp/
Profile: default <span style="color: #b22222;">#</span><span style="color: #b22222;">&#40664;&#35748;&#30340;&#37197;&#32622;&#25991;&#20214;
</span>Kernel Version: 4.15.0-29-generic <span style="color: #b22222;">#</span><span style="color: #b22222;">&#23487;&#20027;&#26426;&#20869;&#26680;&#29256;&#26412;
</span>Operating System: Ubuntu 18.04.1 LTS <span style="color: #b22222;">#</span><span style="color: #b22222;">&#23487;&#20027;&#26426;&#25805;&#20316;&#31995;&#32479;
</span>OSType: linux <span style="color: #b22222;">#</span><span style="color: #b22222;">&#23487;&#20027;&#26426;&#25805;&#20316;&#31995;&#32479;&#31867;&#22411;
</span>Architecture: x86_64 <span style="color: #b22222;">#</span><span style="color: #b22222;">&#23487;&#20027;&#26426;&#26550;&#26500;
</span>CPUs: 1 <span style="color: #b22222;">#</span><span style="color: #b22222;">&#23487;&#20027;&#26426; CPU &#25968;&#37327;
</span>Total Memory: 962MiB <span style="color: #b22222;">#</span><span style="color: #b22222;">&#23487;&#20027;&#26426;&#24635;&#20869;&#23384;
</span>Name: ubuntu1804.xxx.org <span style="color: #b22222;">#</span><span style="color: #b22222;">&#23487;&#20027;&#26426; hostname
</span>ID: IZHJ:WPIN:BRMC:XQUI:VVVR:UVGK:NZBM:YQXT:JDWB:33RS:45V7:SQWJ <span style="color: #b22222;">#</span><span style="color: #b22222;">&#23487;&#20027;&#26426; ID
</span>Docker Root Dir: /var/lib/docker <span style="color: #b22222;">#</span><span style="color: #b22222;">&#23487;&#20027;&#26426;&#20851;&#20110;docker&#25968;&#25454;&#30340;&#20445;&#23384;&#30446;&#24405;
</span>Debug Mode: false <span style="color: #b22222;">#</span><span style="color: #b22222;">server &#31471;&#26159;&#21542;&#24320;&#21551; debug
</span>Registry: https://index.docker.io/v1/ <span style="color: #b22222;">#</span><span style="color: #b22222;">&#20179;&#24211;&#36335;&#24452;
</span>Labels:
Experimental: false <span style="color: #b22222;">#</span><span style="color: #b22222;">&#26159;&#21542;&#27979;&#35797;&#29256;
</span>Insecure Registries:
127.0.0.0/8 : <span style="color: #b22222;">#</span><span style="color: #b22222;">&#38750;&#23433;&#20840;&#30340;&#38236;&#20687;&#20179;&#24211;
</span>Registry Mirrors:
https://si7y70hh.mirror.aliyuncs.com/ <span style="color: #b22222;">#</span><span style="color: #b22222;">&#38236;&#20687;&#20179;&#24211;
</span>Live Restore Enabled: false <span style="color: #b22222;">#</span><span style="color: #b22222;">&#26159;&#21542;&#24320;&#21551;&#27963;&#21160;&#37325;&#21551; (&#37325;&#21551;docker-daemon &#19981;&#20851;&#38381;&#23481;&#22120; )
</span>WARNING: No swap limit support <span style="color: #b22222;">#</span><span style="color: #b22222;">&#31995;&#32479;&#35686;&#21578;&#20449;&#24687; (&#27809;&#26377;&#24320;&#21551; swap &#36164;&#28304;&#38480;&#21046; )</span>
</pre>
</div>

<p>
范例: 解决上述SWAP报警提示<br>
官方文档: <a href="https://docs.docker.com/install/linux/linux-postinstall/#your-kernel-does-not-support-cgroup-swap-limit-capabilities">https://docs.docker.com/install/linux/linux-postinstall/#your-kernel-does-not-support-cgroup-swap-limit-capabilities</a><br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker info
......
WARNING: No swap limit support
[root@ubuntu1804 ~]# vim /etc/default/grub
<span style="color: #a0522d;">GRUB_DEFAULT</span>=0
<span style="color: #a0522d;">GRUB_TIMEOUT_STYLE</span>=hidden
<span style="color: #a0522d;">GRUB_TIMEOUT</span>=2
<span style="color: #a0522d;">GRUB_DISTRIBUTOR</span>=<span style="color: #ff00ff;">`lsb_ release -i -s 2&gt; /dev/null || echo Debian`</span>
<span style="color: #a0522d;">GRUB_CMDLINE_LINUX_DEFAULT</span>=<span style="color: #8b2252;">""</span>
<span style="color: #a0522d;">GRUB_CMDLINE_LINUX</span>=<span style="color: #8b2252;">"net.ifnames=0 biosdevname=0 swapaccount=1"</span> <span style="color: #b22222;">#</span><span style="color: #b22222;">&#20462;&#25913;&#27492;&#34892;
</span>[root@ubuntu1804 ~]# update-grub
[root@ubuntu1804 ~]# reboot
</pre>
</div>
</div>
</div>
<div id="outline-container-h:799e892e-ebf9-479d-9744-683f49f8fb9b" class="outline-5">
<h5 id="h:799e892e-ebf9-479d-9744-683f49f8fb9b">docker 存储引擎</h5>
<div class="outline-text-5" id="text-h:799e892e-ebf9-479d-9744-683f49f8fb9b">
<p>
官方文档关于存储引擎的相关文档:<br>
<a href="https://docs.docker.com/storage/storagedriver/">https://docs.docker.com/storage/storagedriver/</a><br>
<a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/">https://docs.docker.com/storage/storagedriver/select-storage-driver/</a><br>
</p>
</div>
<ul class="org-ul">
<li><a id="h:a504d3f5-6ccb-4a88-8d2c-c20ba93d2fb1"></a>AUFS:<br>
<div class="outline-text-6" id="text-h:a504d3f5-6ccb-4a88-8d2c-c20ba93d2fb1">
<p>
（Advanced Mult-Layered Unification Filesystem，版本2之前旧称AnotherUnionFS）是一种 Union FS ，是文件级的存储驱动。Aufs是之前的UnionFS的重新实现，2006年由JunjiroOkajima开发所谓 UnionFS就是把不同物理位置的目录合并 mount 到同一个目录中。简单来说就是支持将不同目录挂载到一个虚拟文件系统下的。这种可以层层地叠加修改文件。无论底下有多少都是只读的，最上系统可写的。当需要修改一个文件时， AUFS 创建该文件的一个副本，使用 CoW 将文件从只读层复制到可写进行修改，结果也保存在Docker 中，底下的只读层就是 image，可写层就是Container<br>
</p>

<p>
aufs 被拒绝合并到主线 Linux 。其代码被批评为"dense, unreadable, uncommented 密集、不可读、未注释"。 相反，OverlayFS被合并到 Linux 内核中。在多次尝试将 aufs 合并到主线内核失败后，作者放弃了<br>
</p>

<p>
AUFS 是 Docker 18.06 及更早版本的首选存储驱动程序，在内核 3.13 上运行 Ubuntu 14.04 时不支持 overlay2<br>
</p>
</div>
</li>
<li><a id="h:60d54c47-ba8d-4e23-9833-3cc4afab8e7f"></a>Overlay:<br>
<div class="outline-text-6" id="text-h:60d54c47-ba8d-4e23-9833-3cc4afab8e7f">
<p>
一种 Union FS 文件系统， Linux 内核 3.18 后支持Overlay2: Overlay 的升级版，到目前为止，所有 Linux 发行版推荐使用的存储类 型，也是docker默认使用的存储引擎为overlay2，需要磁盘分区支持d-type功能，因此需要系统磁盘的额外支持,相对AUFS来说Overlay2 有以下优势: 更简单地设计； 从3.18开始就进入了Linux内核主线；资源消耗更少<br>
</p>
</div>
</li>
<li><a id="h:299caa37-f451-42e7-bf94-b60ae25741dd"></a>devicemapper:<br>
<div class="outline-text-6" id="text-h:299caa37-f451-42e7-bf94-b60ae25741dd">
<p>
因为CentOS 7.2和RHEL 7.2 的之前版本内核版本不支持 overlay2，默认使用的存储驱动程序，最大数据容量只支持100GB且性能不佳，当前较新版本的CentOS 已经支持overlay2， 因此推荐使用 overlay2,另外此存储引擎已在Docker Engine 18.09中弃用<br>
</p>
</div>
</li>
<li><a id="h:831d38d5-ac07-4f1b-9281-c2e30dfb398e"></a>ZFS<br>
<div class="outline-text-6" id="text-h:831d38d5-ac07-4f1b-9281-c2e30dfb398e">
<p>
(Sun -2005)/btrfs(Oracle-2007): 目前没有广泛使用<br>
</p>
</div>
</li>
<li><a id="h:b91a14fc-c041-4761-9cb9-85711fdbae18"></a>vfs:<br>
<div class="outline-text-6" id="text-h:b91a14fc-c041-4761-9cb9-85711fdbae18">
<p>
用于测试环境，适用于无法使用 copy-on -writewrite 时的情况。 此存储驱动程序的性能很差，通常不建议用于生产<br>
</p>

<p>
修改存储引擎参考文档:<br>
<a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/">https://docs.docker.com/storage/storagedriver/overlayfs-driver/</a><br>
</p>

<p>
范例: 在CentOS7.2修改存储引擎<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@centos7 ~]#vim /lib/systemd/system/docker.service
.....
<span style="color: #a0522d;">ExecStart</span>=/usr/bin/dockerd -s overlay2 -H fd:// --
<span style="color: #a0522d;">containerd</span>=/run/containerd/containerd.sock
......
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21019;&#24314;&#26032;&#30340;xfs&#20998;&#21306;,&#28155;&#21152;ftype&#29305;&#24615;,&#21542;&#21017;&#40664;&#35748;&#26080;&#27861;&#21551;&#21160;docker&#26381;&#21153;
</span>[root@centos7 ~]#mkfs.xfs -n <span style="color: #a0522d;">ftype</span>=1 /dev/sdb
[root@centos7 ~]#mount /dev/sdb /var/lib/docker
[root@centos7 ~]#systemctl daemon-reload
[root@centos7 ~]#systemctl restart docker
</pre>
</div>

<p>
注意:修改存储引擎会导致所有容器丢失,所以先备份再修改<br>
</p>

<p>
Docker官方推荐首选存储引擎为overlay2，其次为devicemapper，但是devicemapper存在使用空间方面的一些限制，虽然可以通过后期配置解决，但是官方依然推荐使用overlay2，以下是生产故障事例:<br>
<a href="https://www.cnblogs.com/youruncloud/p/5736718.html">https://www.cnblogs.com/youruncloud/p/5736718.html</a><br>
</p>

<p>
如果docker数据目录是一块单独的磁盘分区而且是xfs格式的，那么需要在格式化的时候加上参数-n ftype=1(启用此功能表示节点文件类型存入在目录结构中）, 示例: `mkfs.xfs -n ftype=1 devname` ，否则后期在无法启动容器,并会报错不支持 d_type<br>
</p>

<p>
注意: ext4文件系统无需此d_type特性<br>
</p>

<p>
范例: aufs 实现联合文件系统挂载<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#cat /proc/filesystems
... ...
nodev overlay
nodev aufs
[root@ubuntu1804 ~]#grep -i aufs /boot/config-4.15.0-29-generic
<span style="color: #a0522d;">CONFIG_AUFS_FS</span>=m
<span style="color: #a0522d;">CONFIG_AUFS_BRANCH_MAX_127</span>=y
<span style="color: #b22222;"># </span><span style="color: #b22222;">CONFIG_AUFS_BRANCH_MAX_511 is not set
</span><span style="color: #b22222;"># </span><span style="color: #b22222;">CONFIG_AUFS_BRANCH_MAX_1023 is not set
</span><span style="color: #b22222;"># </span><span style="color: #b22222;">CONFIG_AUFS_BRANCH_MAX_32767 is not set
</span><span style="color: #a0522d;">CONFIG_AUFS_SBILIST</span>=y
<span style="color: #b22222;"># </span><span style="color: #b22222;">CONFIG_AUFS_HNOTIFY is not set
</span><span style="color: #a0522d;">CONFIG_AUFS_EXPORT</span>=y
<span style="color: #a0522d;">CONFIG_AUFS_INO_T_64</span>=y
<span style="color: #a0522d;">CONFIG_AUFS_XATTR</span>=y
<span style="color: #b22222;"># </span><span style="color: #b22222;">CONFIG_AUFS_FHSM is not set
</span><span style="color: #b22222;"># </span><span style="color: #b22222;">CONFIG_AUFS_RDU is not set
</span><span style="color: #a0522d;">CONFIG_AUFS_DIRREN</span>=y
<span style="color: #b22222;"># </span><span style="color: #b22222;">CONFIG_AUFS_SHWH is not set
</span><span style="color: #b22222;"># </span><span style="color: #b22222;">CONFIG_AUFS_BR_RAMFS is not set
</span><span style="color: #b22222;"># </span><span style="color: #b22222;">CONFIG_AUFS_BR_FUSE is not set&#33539;&#20363;: &#20462;&#25913;&#23384;&#20648;&#24341;&#25806;
</span><span style="color: #a0522d;">CONFIG_AUFS_BR_HFSPLUS</span>=y
<span style="color: #a0522d;">CONFIG_AUFS_BDEV_LOOP</span>=y
<span style="color: #b22222;"># </span><span style="color: #b22222;">CONFIG_AUFS_DEBUG is not set
</span>[root@ubuntu1804 ~]#mkdir dir{1,2}
[root@ubuntu1804 ~]#echo here is dir1 &gt; dir1/file1
[root@ubuntu1804 ~]#echo here is dir2 &gt; dir2/file2
[root@ubuntu1804 ~]#mkdir /data/aufs
[root@ubuntu1804 ~]#mount -t aufs -o <span style="color: #a0522d;">br</span>=/root/dir1=ro:/root/dir2=rw none /data/aufs
[root@ubuntu1804 ~]#ll /data/aufs/
total 16
drwxr-xr-x 4 root root 4096 Jan 25 16:22 ./
drwxr-xr-x 4 root root 4096 Jan 25 16:22 ../
-rw-r--r-- 1 root root 13 Jan 25 16:22 file1
-rw-r--r-- 1 root root 13 Jan 25 16:22 file2
[root@ubuntu1804 ~]#cat /data/aufs/file1
here is dir1
[root@ubuntu1804 ~]#cat /data/aufs/file2
here is dir2
[root@ubuntu1804 ~]#df -T
Filesystem Type 1K-blocks Used Available Use% Mounted on
udev devtmpfs 462560 0 462560 0% /dev
tmpfs tmpfs 98512 10296 88216 11% /run
/dev/sda2 ext4 47799020 2770244 42570972 7% /
tmpfs tmpfs 492552 0 492552 0% /dev/shm
tmpfs tmpfs 5120 0 5120 0% /run/lock
tmpfs tmpfs 492552 0 492552 0% /sys/fs/cgroup
/dev/sda3 ext4 19091540 45084 18053588 1% /data
/dev/sda1 ext4 944120 77112 801832 9% /boot
tmpfs tmpfs 98508 0 98508 0% /run/user/0
none aufs 47799020 2770244 42570972 7% /data/aufs
[root@ubuntu1804 ~]#echo write to file1 &gt;&gt; /data/aufs/file1
-bash: /data/aufs/file1: Read-only file system
[root@ubuntu1804 ~]#echo write to file2 &gt;&gt; /data/aufs/file2
[root@ubuntu1804 ~]#cat /data/aufs/file1
here is dir1
[root@ubuntu1804 ~]#cat /data/aufs/file2
here is dir2
write to file2
[root@ubuntu1804 ~]#umount /data/aufs
[root@ubuntu1804 ~]#mv dir1/file1 dir1/file2
[root@ubuntu1804 ~]#cat dir1/file2
here is dir1
[root@ubuntu1804 ~]#cat dir2/file2
here is dir2
write to file2
[root@ubuntu1804 ~]#mount -t aufs -o <span style="color: #a0522d;">br</span>=/root/dir1=ro:/root/dir2=rw none
/data/aufs
[root@ubuntu1804 ~]#ls /data/aufs -l
total 4
-rw-r--r-- 1 root root 13 Jan 25 16:22 file2
[root@ubuntu1804 ~]#cat /data/aufs/file2
here is dir1
[root@ubuntu1804 ~]#
</pre>
</div>

<p>
范例: 修改存储引擎<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker info |grep <span style="color: #8b2252;">"Storage Driver"</span>
Storage Driver: overlay2
[root@ubuntu1804 ~]#systemctl stop docker
[root@ubuntu1804 ~]#cat /etc/docker/daemon.json
{
<span style="color: #8b2252;">"storage-driver"</span>: <span style="color: #8b2252;">"aufs"</span>
}
[root@ubuntu1804 ~]#systemctl restart docker
[root@ubuntu1804 ~]#docker info |grep aufs
Storage Driver: aufs
Root Dir: /var/lib/docker/aufs
[root@ubuntu1804 ~]#docker images <span style="color: #b22222;"># </span><span style="color: #b22222;">&#26080;&#38236;&#20687;
</span>[root@ubuntu1804 ~]#docker ps -a
[root@ubuntu1804 ~]#ls /var/lib/docker
aufs builder buildkit containers image network overlay2 plugins runtimes swarm tmp trust volumes
[root@ubuntu1804 ~]#ls /var/lib/docker/aufs/
diff layers mnt
[root@ubuntu1804 ~]#cat /etc/docker/daemon.json
{
<span style="color: #8b2252;">"registry-mirrors"</span>: [<span style="color: #8b2252;">"https://si7y70hh.mirror.aliyuncs.com"</span>]
}
[root@ubuntu1804 ~]#systemctl restart docker
[root@ubuntu1804 ~]#docker ps -a
[root@ubuntu1804 ~]#docker images <span style="color: #b22222;"># </span><span style="color: #b22222;">&#38236;&#20687;&#24674;&#22797;</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-h:947c7cc4-59f2-4b38-923b-df5d9a5ed01a" class="outline-5">
<h5 id="h:947c7cc4-59f2-4b38-923b-df5d9a5ed01a">docker 服务进程</h5>
<div class="outline-text-5" id="text-h:947c7cc4-59f2-4b38-923b-df5d9a5ed01a">
<p>
通过查看docker进程，了解docker的运行及工作方式<br>
</p>
</div>
<ul class="org-ul">
<li><a id="h:a745584a-5360-4bd9-a8cc-1c0c37bbd56a"></a>查看宿主机进程树<br>
<div class="outline-text-6" id="text-h:a745584a-5360-4bd9-a8cc-1c0c37bbd56a">
<p>
pstree -p<br>
</p>
</div>
</li>
<li><a id="h:ae0bff9f-8ac9-4b52-8e19-69a90a8cbb61"></a>docker的进程关系<br>
<div class="outline-text-6" id="text-h:ae0bff9f-8ac9-4b52-8e19-69a90a8cbb61">
<p>
docker 相关的四个进程:<br>
</p>
<ul class="org-ul">
<li>dockerd: 服务器程序,被client直接访问，其父进程为宿主机的systemd守护进程。<br></li>
<li>docker-proxy: 每个进程docker-proxy实现对应一个需要网络通信的容器，管理宿主机和容器的之间端口映射，其父进程为dockerd，如果容器不需要网络则无需启动<br></li>
<li>containerd: 被dockerd进程调用以实现与runc交互<br></li>
<li>containerd-shim: 真正运行容器的载体，每个容器对应一个containerd-shim进程，其父进程为containerd<br></li>
</ul>
</div>
</li>
<li><a id="h:0229b05c-c44e-41e0-9dfa-17d7b1d6fe02"></a>容器的创建与管理过程<br>
<div class="outline-text-6" id="text-h:0229b05c-c44e-41e0-9dfa-17d7b1d6fe02">
<p>
通信流程:<br>
<img src="./images/Snipaste_2023-04-25_23-23-02.png" alt="Snipaste_2023-04-25_23-23-02.png"><br>
</p>

<ul class="org-ul">
<li>1. dockerd通过grpc和 containerd模块通信，dockerd由libcontainerd负责和containerd进行交换，dockerd和containerd 通信socket文件: /run/containerd/containerd.sock<br></li>
<li>2. containerd在dockerd启动时被启动，然后containerd启动grpc请求监听，containerd处理grpc请求，根据请求做相应动作<br></li>
<li>3. 若是run, start或是exec 容器，containerd 拉起一个container-shim , 并进行相应的操作<br></li>
<li>4. container-shim别拉起后，start/exec/create拉起runC进程，通过exit、control文件和containerd通信，通过父子进程关系和SIGCHLD监控容器中进程状态<br></li>
<li>5. 在整个容器生命周期中，containerd通过 epoll 监控容器文件，监控容器事件<br></li>
</ul>
</div>
</li>
<li><a id="h:bf7989c6-8f3b-4bb3-a283-cfa1ffbf73be"></a>gRPC简介<br>
<div class="outline-text-6" id="text-h:bf7989c6-8f3b-4bb3-a283-cfa1ffbf73be">

<figure id="orgf20867c">
<img src="./images/Snipaste_2023-04-25_23-24-41.png" alt="Snipaste_2023-04-25_23-24-41.png"><br>

</figure>

<p>
gRPC是Google开发的一款高性能、开源和通用的 RPC 框架，支持众多语言客户端<br>
</p>

<p>
官网: <a href="https://www.grpc.io/">https://www.grpc.io/</a><br>
</p>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-h:678115fe-086b-4795-9b32-947f9ea0fc26" class="outline-4">
<h4 id="h:678115fe-086b-4795-9b32-947f9ea0fc26">docker 服务管理</h4>
<div class="outline-text-4" id="text-h:678115fe-086b-4795-9b32-947f9ea0fc26">
<p>
docker 服务基于C/S 结构,可以实现基于本地和远程方式进行管理<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">Dockerd&#23432;&#25252;&#36827;&#31243;&#21551;&#21160;&#36873;&#39033;
</span>-H tcp://host:port
unix:///path/to/socket,
fd://* or fd://socketfd
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#23432;&#25252;&#36827;&#31243;&#40664;&#35748;&#37197;&#32622;:
</span>-H unix:///var/run/docker.sock
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#20351;&#29992;Docker&#23458;&#25143;&#31471;&#21629;&#20196;&#36873;&#39033;
</span>-H tcp://host:port
unix:///path/to/socket,
fd://* or fd://socketfd
&#23458;&#25143;&#31471;&#40664;&#35748;&#37197;&#32622;:
-H unix:///var/run/docker.sock
<span style="color: #b22222;">#</span><span style="color: #b22222;">docker&#23458;&#25143;&#31471;&#20063;&#21487;&#20197;&#20351;&#29992;&#29615;&#22659;&#21464;&#37327;DOCKER_ HOST,&#20195;&#26367;-H&#36873;&#39033;
</span><span style="color: #483d8b;">export</span> <span style="color: #a0522d;">DOCKER_HOST</span>=<span style="color: #8b2252;">"tcp://docker-server:2375"</span>
</pre>
</div>

<p>
范例: 通过UDS访问docker<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#cat /lib/systemd/system/docker.service
[Unit]
<span style="color: #a0522d;">Description</span>=Docker Application Container <span style="color: #a0522d;">EngineDocumentation</span>=https://docs.docker.com
<span style="color: #a0522d;">BindsTo</span>=containerd.service
<span style="color: #a0522d;">After</span>=network-online.target firewalld.service containerd.service
<span style="color: #a0522d;">Wants</span>=network-online.target
<span style="color: #a0522d;">Requires</span>=docker.socket
[Service]
<span style="color: #a0522d;">Type</span>=notify
<span style="color: #a0522d;">ExecStart</span>=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
<span style="color: #a0522d;">ExecReload</span>=/bin/kill -s HUP $<span style="color: #a0522d;">MAINPID</span>
<span style="color: #a0522d;">TimeoutSec</span>=0
<span style="color: #a0522d;">RestartSec</span>=2
<span style="color: #a0522d;">Restart</span>=always
<span style="color: #a0522d;">StartLimitBurst</span>=3
<span style="color: #a0522d;">StartLimitInterval</span>=60s
<span style="color: #a0522d;">LimitNOFILE</span>=infinity
<span style="color: #a0522d;">LimitNPROC</span>=infinity
<span style="color: #a0522d;">LimitCORE</span>=infinity
<span style="color: #a0522d;">TasksMax</span>=infinity
<span style="color: #a0522d;">Delegate</span>=yes
<span style="color: #a0522d;">KillMode</span>=process
[Install]
<span style="color: #a0522d;">WantedBy</span>=multi-user.target

[root@ubuntu1804 ~]#systemctl status docker
[root@ubuntu1804 ~]#ll /var/run/docker.sock
srw-rw---- 1 root docker 0 Jul 22 20:33 /var/run/docker.sock=

[root@ubuntu1804 ~]#nc -U /var/run/docker.sock
GET /info HTTP/1.1
host: www.xxx.org
HTTP/1.1 200 OK
Api-Version: 1.40
Content-Type: application/json
Docker-Experimental: false
Ostype: linux
Server: Docker/19.03.12 (linux)
Date: Wed, 22 Jul 2020 11:54:12 GMT
Transfer-Encoding: chunked
947
</pre>
</div>

<p>
范例: docker服务添加标签<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#vim /lib/systemd/system/docker.service
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#20462;&#25913;&#19979;&#38754;&#34892;
</span><span style="color: #a0522d;">ExecStart</span>=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --label=<span style="color: #8b2252;">"name=docker1"</span>

[root@ubuntu1804 ~]#systemctl daemon-reload
[root@ubuntu1804 ~]#systemctl restart docker
[root@ubuntu1804 ~]#docker info
Labels:
<span style="color: #a0522d;">name</span>=docker1 <span style="color: #b22222;">#</span><span style="color: #b22222;">&#27492;&#22788;&#26174;&#31034;&#28155;&#21152;&#30340;&#26631;&#31614;</span>
</pre>
</div>

<p>
范例: 开启docker的远程访问<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#26041;&#27861;1
</span>[root@ubuntu1804 ~]#vim /lib/systemd/system/docker.service
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#20462;&#25913;&#19979;&#38754;&#34892;
</span><span style="color: #a0522d;">ExecStart</span>=/usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:2375 --
<span style="color: #a0522d;">containerd</span>=/run/containerd/containerd.sock --label=<span style="color: #8b2252;">"name=docker1"</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26041;&#27861;2
</span>[root@ubuntu1804 ~]#vim /lib/systemd/system/docker.service
<span style="color: #a0522d;">ExecStart</span>=/usr/bin/dockerd --containerd=/run/containerd/containerd.sock[root@ubuntu1804 ~]#vim /etc/docker/daemon.json
{
<span style="color: #8b2252;">"hosts"</span>: [<span style="color: #8b2252;">"tcp://0.0.0.0:2375"</span>, <span style="color: #8b2252;">"fd://"</span>]
}
[root@ubuntu1804 ~]#systemctl daemon-reload
[root@ubuntu1804 ~]#systemctl restart docker
[root@ubuntu1804 ~]#ss -tnlp|grep 2375
[root@ubuntu1804 ~]#ps -ef | grep docker

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#23454;&#29616;&#36828;&#31243;&#35775;&#38382;&#26041;&#24335;1
</span>[root@centos7 ~]#curl http://10.0.0.100:2375/info

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#23454;&#29616;&#36828;&#31243;&#35775;&#38382;&#26041;&#24335;2
</span>[root@centos7 ~]#docker -H tcp://10.0.0.100:2375 info

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#23454;&#29616;&#36828;&#31243;&#35775;&#38382;&#26041;&#24335;3
</span>[root@centos7 ~]#export <span style="color: #a0522d;">DOCKER_HOST</span>=<span style="color: #8b2252;">"tcp://10.0.0.100:2375"</span>
[root@centos7 ~]#docker info

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#24674;&#22797;&#36830;&#25509;&#26412;&#26426;
</span>[rootcentos7 ~]#unset DOCKER_HOST
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:7570c4c0-6062-4c2b-a20c-0f885f8ef201" class="outline-3">
<h3 id="h:7570c4c0-6062-4c2b-a20c-0f885f8ef201">镜像管理</h3>
<div class="outline-text-3" id="text-h:7570c4c0-6062-4c2b-a20c-0f885f8ef201">
</div>
<div id="outline-container-h:e6670e1f-e099-4711-8b00-b23ecd73ec61" class="outline-4">
<h4 id="h:e6670e1f-e099-4711-8b00-b23ecd73ec61">镜像结构和原理</h4>
<div class="outline-text-4" id="text-h:e6670e1f-e099-4711-8b00-b23ecd73ec61">

<figure id="orgcc8767f">
<img src="./images/Snipaste_2023-04-26_10-25-28.png" alt="Snipaste_2023-04-26_10-25-28.png"><br>

</figure>

<p>
镜像即创建容器的模版，含有启动容器所需要的文件系统及所需要的内容，因此镜像主要用于方便和快速的创建并启动容器<br>
</p>

<p>
镜像含里面是一层层的文件系统,叫做 Union FS（联合文件系统）,联合文件系统，可以将几层目录挂载到一起（就像千层饼，洋葱头，俄罗斯套娃一样），形成一个虚拟文件系统,虚拟文件系统的目录结构就像普通 linux 的目录结构一样，镜像通过这些文件再加上宿主机的内核共同提供了一个 linux 的虚拟环境，每一层文件系统叫做一层 layer，联合文件系统可以对每一层文件系统设置三种权限，只读（readonly）、读写（readwrite）和写出（whiteout-able），但是镜像中每一层文件系统都是只读的,构建镜像的时候，从一个最基本的操作系统开始，每个构建提交的操作都相当于做一层的修改，增加了一层文件系统，一层层往上叠加，上层的修改会覆盖底层该位置的可见性，这也很容易理解，就像上层把底层遮住了一样，当使用镜像的时候，我们只会看到一个完全的整体，不知道里面有几层,实际上也不需要知道里面有几层，结构如下:<br>
</p>


<figure id="org93c7ccd">
<img src="./images/Snipaste_2023-04-26_10-26-03.png" alt="Snipaste_2023-04-26_10-26-03.png"><br>

</figure>

<p>
一个典型的 Linux文件系统由 bootfs 和 rootfs 两部分组成<br>
</p>

<p>
bootfs(boot file system) 主要包含bootloader和kernel，bootloader主要用于引导加载 kernel，Linux刚启动时会加载bootfs文件系统,当boot加载完成后,kernel 被加载到内存中后接管系统的控制权,bootfs会被 umount 掉<br>
</p>

<p>
rootfs (root file system) 包含的就是典型 Linux 系统中的/dev，/proc，/bin，/etc 等标准目录和文件，不同的 linux 发行版（如 ubuntu 和 CentOS ) 主要在 rootfs 这一层会有所区别。一般的镜像通常都比较小，官方提供的Ubuntu镜像只有60MB多点，而 CentOS 基础镜像也只有200MB左右，一些其他版本的镜像甚至只有几MB，比如: busybox 才1.22MB，alpine镜像也只有5M左右。镜像直接调用宿主机的内核，镜像中只提供 rootfs，也就是只需要包括最基本的命令,配置文件和程序库等相关文件就可以了。<br>
</p>

<p>
下图就是有两个不同的镜像在一个宿主机内核上实现不同的rootfs。<br>
<img src="./images/Snipaste_2023-04-26_10-27-23.png" alt="Snipaste_2023-04-26_10-27-23.png"><br>
</p>

<p>
容器、镜像和父镜像关系:<br>
<img src="./images/Snipaste_2023-04-26_10-28-04.png" alt="Snipaste_2023-04-26_10-28-04.png"><br>
</p>


<p>
范例: 查看镜像的分层结构<br>
[root@ubuntu1804 ~]#docker pull nginx<br>
#查看镜像分层历史<br>
[root@ubuntu1804 ~]#docker image history nginx<br>
IMAGE CREATED CREATED BY<br>
SIZE COMMENT<br>
0901fa9da894 9 days ago /bin/sh -c #(nop) CMD ["nginx" "-g"<br>
"daemon… 0B<br>
&lt;missing&gt; 9 days ago /bin/sh -c #(nop) STOPSIGNAL SIGTERM<br>
0B<br>
&lt;missing&gt; 9 days ago /bin/sh -c #(nop) EXPOSE 80<br>
0B<br>
&lt;missing&gt; 9 days ago /bin/sh -c #(nop) ENTRYPOINT ["/dockerentr… 0B<br>
&lt;missing&gt; 9 days ago /bin/sh -c #(nop) COPY<br>
<a href="0fd5fca330dcd6a7">0fd5fca330dcd6a7</a>… 1.04kB<br>
&lt;missing&gt; 9 days ago /bin/sh -c #(nop) COPY<br>
<a href="1d0a4127e78a26c1">1d0a4127e78a26c1</a>… 1.96kB<br>
&lt;missing&gt; 9 days ago /bin/sh -c #(nop) COPY<br>
<a href="e7e183879c35719c">e7e183879c35719c</a>… 1.2kB<br>
&lt;missing&gt; 9 days ago /bin/sh -c set -x &amp;&amp; addgroup &#x2013;<br>
system -… 63.3MB<br>
&lt;missing&gt; 9 days ago /bin/sh -c #(nop) ENV<br>
PKG_RELEASE=1~buster 0B<br>
&lt;missing&gt; 9 days ago /bin/sh -c #(nop) ENV NJS_VERSION=0.4.2<br>
0B<br>
&lt;missing&gt; 9 days ago /bin/sh -c #(nop) ENV<br>
NGINX_VERSION=1.19.1 0B<br>
&lt;missing&gt; 5 weeks ago /bin/sh -c #(nop) LABEL<br>
maintainer=NGINX Do… 0B<br>
&lt;missing&gt; 5 weeks ago /bin/sh -c #(nop) CMD ["bash"]<br>
0B<br>
&lt;missing&gt; 5 weeks ago /bin/sh -c #(nop) ADD<br>
<a href="4d35f6c8bbbe6801c">4d35f6c8bbbe6801c</a>… 69.2MB<br>
</p>
</div>
</div>
<div id="outline-container-h:de33145e-d39c-4df2-92be-21518456a334" class="outline-4">
<h4 id="h:de33145e-d39c-4df2-92be-21518456a334">搜索镜像</h4>
<div class="outline-text-4" id="text-h:de33145e-d39c-4df2-92be-21518456a334">
</div>
<div id="outline-container-h:9df61e60-5147-4141-b666-86ce94692bc2" class="outline-5">
<h5 id="h:9df61e60-5147-4141-b666-86ce94692bc2">搜索镜像</h5>
<div class="outline-text-5" id="text-h:9df61e60-5147-4141-b666-86ce94692bc2">
</div>
<ul class="org-ul">
<li><a id="h:41143454-0dc8-47a0-9b39-f6240b36c729"></a>官方网站进行镜像的搜索<br>
<div class="outline-text-6" id="text-h:41143454-0dc8-47a0-9b39-f6240b36c729">
<p>
官网: <a href="http://hub.docker.com">http://hub.docker.com</a><br>
</p>

<p>
官方的docker 仓库中搜索指定名称的docker镜像，也会有很多三方镜像。<br>
</p>
</div>
</li>
<li><a id="h:5661e409-846b-417d-a0a1-959888deb1e9"></a>执行docker search命令进行搜索<br>
<div class="outline-text-6" id="text-h:5661e409-846b-417d-a0a1-959888deb1e9">
<p>
格式如下:<br>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">Usage: docker search [OPTIONS] TERM
Options:
-f, --filter filter Filter output based on conditions provided
--format string Pretty-print search using a Go template
--limit int Max number of search results (default 25)
--no-trunc Don<span style="color: #8b2252;">'t truncate output</span>
</pre>
</div>

<p>
说明:<br>
OFFICIAL: 官方<br>
AUTOMATED: 使用第三方docker服务来帮助编译镜像，可以在互联网上面直接拉取到镜像，减少了繁琐的编译过程<br>
</p>

<p>
范例：搜索点赞100个以上的镜像<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker search --filter=<span style="color: #a0522d;">stars</span>=100 centos
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="outline-container-h:63471112-f286-4fee-af08-b7db62efbe39" class="outline-5">
<h5 id="h:63471112-f286-4fee-af08-b7db62efbe39">alpine 介绍</h5>
<div class="outline-text-5" id="text-h:63471112-f286-4fee-af08-b7db62efbe39">
<p>
Alpine 操作系统是一个面向安全的轻型 Linux 发行版。它不同于通常 Linux 发行版，Alpine 采用了musl libc 和 busybox 以减小系统的体积和运行时资源消耗，但功能上比 busybox 又完善的多，因此得到开源社区越来越多的青睐。在保持瘦身的同时，Alpine 还提供了自己的包管理工具 apk，可以通过 <a href="https://pkgs.alpinelinux.org/packages">https://pkgs.alpinelinux.org/packages</a> 网站上查询包信息，也可以直接通过 apk 命令直接查询和安装各种软件。<br>
</p>

<p>
Alpine 由非商业组织维护的，支持广泛场景的 Linux发行版，它特别为资深/重度Linux用户而优化，关注安全，性能和资源效能。Alpine 镜像可以适用于更多常用场景，并且是一个优秀的可以适用于生产的基础系统/环境。<br>
</p>

<p>
Alpine Docker 镜像也继承了 Alpine Linux 发行版的这些优势。相比于其他 Docker 镜像，它的容量非常小，仅仅只有 5 MB 左右（对比 Ubuntu 系列镜像接近 200 MB），且拥有非常友好的包管理机制。官方镜像来自 docker-alpine 项目。<br>
</p>

<p>
目前 Docker 官方已开始推荐使用 Alpine 替代之前的 Ubuntu 做为基础镜像环境。这样会带来多个好处。包括镜像下载速度加快，镜像安全性提高，主机之间的切换更方便，占用更少磁盘空间等。<br>
</p>

<p>
下表是官方镜像的大小比较:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">REPOSITORY TAG IMAGE ID VIRTUAL SIZE
alpine latest 4e38e38c8ce0 4.799 MB
debian latest 4d6ce913b130 84.98 MB
ubuntu latest b39b81afc8ca 188.3 MB
centos latest 8efe422e6104 210 MB
</pre>
</div>

<ul class="org-ul">
<li>Alpine 官网: <a href="https://www.alpinelinux.org/">https://www.alpinelinux.org/</a><br></li>
<li>Alpine 官方仓库: <a href="https://github.com/alpinelinux">https://github.com/alpinelinux</a><br></li>
<li>Alpine 官方镜像: <a href="https://hub.docker.com/_/alpine/">https://hub.docker.com/_/alpine/</a><br></li>
<li>Alpine 官方镜像仓库: <a href="https://github.com/gliderlabs/docker-alpine">https://github.com/gliderlabs/docker-alpine</a><br></li>
<li>Alpine 阿里云的镜像仓库: <a href="https://mirrors.aliyun.com/alpine/">https://mirrors.aliyun.com/alpine/</a><br></li>
</ul>

<p>
范例: alpine管理软件<br>
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#20462;&#25913;&#28304;&#26367;&#25442;&#25104;&#38463;&#37324;&#28304;&#65292;&#23558;&#37324;&#38754; dl-cdn.alpinelinux.org &#30340; &#25913;&#25104; mirrors.aliyun.com
</span>vi /etc/apk/repositories
http://mirrors.aliyun.com/alpine/v3.8/main/
http://mirrors.aliyun.com/alpine/v3.8/community/
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26356;&#26032;&#28304;
</span>apk update
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#23433;&#35013;&#36719;&#20214;
</span>apk add vim
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21024;&#38500;&#36719;&#20214;
</span>apk del openssh openntp vim
</pre>
</div>

<p>
范例：<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">/ <span style="color: #b22222;"># </span><span style="color: #b22222;">apk add nginx
</span>/ <span style="color: #b22222;"># </span><span style="color: #b22222;">apk info nginx   
</span>~ <span style="color: #b22222;"># </span><span style="color: #b22222;">apk manifest nginx
</span>~ <span style="color: #b22222;"># </span><span style="color: #b22222;">ls -l /bin</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-h:b4ea2e3a-fb01-41f6-93c6-d9fb9e449cd6" class="outline-5">
<h5 id="h:b4ea2e3a-fb01-41f6-93c6-d9fb9e449cd6">Debian(ubuntu)系统建议安装的基础包</h5>
<div class="outline-text-5" id="text-h:b4ea2e3a-fb01-41f6-93c6-d9fb9e449cd6">
<p>
在很多软件官方提供的镜像都使用的是Debian(ubuntu)的系统,比如:nginx,tomcat,mysql,httpd 等,但镜像内缺少很多常用的调试工具.当需要进入容器内进行调试管理时,可以安装以下常用工具包<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;"># </span><span style="color: #b22222;">apt update #&#23433;&#35013;&#36719;&#20214;&#21069;&#38656;&#35201;&#20808;&#26356;&#26032;&#32034;&#24341;
</span><span style="color: #b22222;"># </span><span style="color: #b22222;">apt install procps #&#25552;&#20379;top,ps,free&#31561;&#21629;&#20196;
</span><span style="color: #b22222;"># </span><span style="color: #b22222;">apt install psmisc #&#25552;&#20379;pstree,killall&#31561;&#21629;&#20196;
</span><span style="color: #b22222;"># </span><span style="color: #b22222;">apt install iputils-ping #&#25552;&#20379;ping&#21629;&#20196;
</span><span style="color: #b22222;"># </span><span style="color: #b22222;">apt install net-tools #&#25552;&#20379;netstat&#32593;&#32476;&#24037;&#20855;&#31561;&#38236;&#20687;&#19979;&#36733;&#35828;&#26126;</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:5468b87c-d74e-43b8-80af-7a04d4c65e19" class="outline-4">
<h4 id="h:5468b87c-d74e-43b8-80af-7a04d4c65e19">下载镜像</h4>
<div class="outline-text-4" id="text-h:5468b87c-d74e-43b8-80af-7a04d4c65e19">
<p>
从 docker 仓库将镜像下载到本地，命令格式如下:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker pull [OPTIONS] NAME[:TAG|@DIGEST]
Options:
-a, --all-tags Download all tagged images<span style="color: #a020f0;"> in</span> the repository
--disable-content-trust Skip image verification (default true)
--platform string Set platform if server is multi-platform capable
-q, --quiet Suppress verbose output
NAME: &#26159;&#38236;&#20687;&#21517;,&#19968;&#33324;&#30340;&#24418;&#24335; &#20179;&#24211;&#26381;&#21153;&#22120;:&#31471;&#21475;/&#39033;&#30446;&#21517;&#31216;/&#38236;&#20687;&#21517;&#31216;
:TAG: &#21363;&#29256;&#26412;&#21495;,&#22914;&#26524;&#19981;&#25351;&#23450;:TAG,&#21017;&#19979;&#36733;&#26368;&#26032;&#29256;&#38236;&#20687;
</pre>
</div>

<p>
<b>镜像下载说明</b><br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker pull hello-world
Using default tag: latest <span style="color: #b22222;">#</span><span style="color: #b22222;">&#40664;&#35748;&#19979;&#36733;&#26368;&#26032;&#29256;&#26412;
</span>latest: Pulling from library/hello-world
1b930d010525: Pull complete <span style="color: #b22222;">#</span><span style="color: #b22222;">&#20998;&#23618;&#19979;&#36733;
</span>Digest: sha256:9572f7cdcee8591948c2963463447a53466950b3fc15a247fcad1917ca215a2f <span style="color: #b22222;">#</span><span style="color: #b22222;">&#25688;&#35201;
</span>Status: Downloaded newer image for hello-world:latest
docker.io/library/hello-world:latest <span style="color: #b22222;">#</span><span style="color: #b22222;">&#19979;&#36733;&#30340;&#23436;&#25972;&#22320;&#22336;</span>
</pre>
</div>

<p>
镜像下载保存的路径:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">/var/lib/docker/overlay2/&#38236;&#20687;ID
</pre>
</div>

<p>
注意: 镜像下载完成后，会自动解压缩，比官网显示的可能会大很多，如: centos8.1.1911下载时只有70MB，下载完后显示237MB<br>
</p>

<p>
范例: 指定 TAG下载特定版本的镜像<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">docker pull centos:centos8.1.1911
</pre>
</div>

<p>
范例: 指定DIGEST下载特定版本的镜像<br>
先到 hub.docker.com查到指定版本的DIGEST<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker pull alpine@sha256:156f59dc1cbe233827642e09ed06e259ef6fa1ca9b2e29d52ae14d5e7b79d7f0
</pre>
</div>
</div>
</div>
<div id="outline-container-h:b47307c7-9ed6-41ee-b8b4-c66009265a1a" class="outline-4">
<h4 id="h:b47307c7-9ed6-41ee-b8b4-c66009265a1a">docker 镜像加速配置</h4>
<div class="outline-text-4" id="text-h:b47307c7-9ed6-41ee-b8b4-c66009265a1a">
<p>
docker 镜像官方的下载站点是: <a href="https://hub.docker.com/">https://hub.docker.com/</a><br>
</p>

<p>
从国内下载官方的镜像站点有时候会很慢，因此可以更改docker配置文件添加一个加速器，可以通过加速器达到加速下载镜像的目的<br>
</p>

<p>
国内有许多公司都提供了docker 加速镜像，比如: 阿里云，腾讯云，网易云，以下以阿里云为例<br>
</p>
</div>
<div id="outline-container-h:7bf137ed-908d-406a-903d-b7dc3fd077a1" class="outline-5">
<h5 id="h:7bf137ed-908d-406a-903d-b7dc3fd077a1">阿里云获取加速地址</h5>
<div class="outline-text-5" id="text-h:7bf137ed-908d-406a-903d-b7dc3fd077a1">
<p>
浏览器打开<a href="http://cr.console.aliyun.com">http://cr.console.aliyun.com</a> ， 注册或登录阿里云账号，点击左侧的镜像加速器，将会得到一个专属的加速地址，而且下面有使用配置说明:<br>
</p>
</div>
</div>
<div id="outline-container-h:9f131957-acbc-44a3-b8a6-11152d2b1bc7" class="outline-5">
<h5 id="h:9f131957-acbc-44a3-b8a6-11152d2b1bc7">镜像加速配置</h5>
<div class="outline-text-5" id="text-h:9f131957-acbc-44a3-b8a6-11152d2b1bc7">
<div class="org-src-container">
<pre class="src src-shell">1. &#23433;&#35013;&#65295;&#21319;&#32423;Docker&#23458;&#25143;&#31471;
&#25512;&#33616;&#23433;&#35013;1.10.0&#20197;&#19978;&#29256;&#26412;&#30340;Docker&#23458;&#25143;&#31471;&#65292;&#21442;&#32771;&#25991;&#26723; docker-ce
2. &#37197;&#32622;&#38236;&#20687;&#21152;&#36895;&#22120;
&#20462;&#25913;daemon&#37197;&#32622;&#25991;&#20214;/etc/docker/daemon.json&#26469;&#20351;&#29992;&#21152;&#36895;&#22120;
mkdir -p /etc/docker
tee /etc/docker/daemon.json &lt;&lt;-<span style="color: #8b2252;">'EOF'</span><span style="color: #ffa54f;">
{
"registry-mirrors": ["https://si7y70hh.mirror.aliyuncs.com"]
}
EOF
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">&#32593;&#26131;&#20113;: http://hub-mirror.c.163.com/
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">&#33150;&#35759;&#20113;: https://mirror.ccs.tencentyun.com
</span>systemctl daemon-reload
systemctl restart docker
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:fa721b79-e85d-4122-8f30-1ec2eb22985a" class="outline-4">
<h4 id="h:fa721b79-e85d-4122-8f30-1ec2eb22985a">查看本地镜像</h4>
<div class="outline-text-4" id="text-h:fa721b79-e85d-4122-8f30-1ec2eb22985a">
<p>
docker images 可以查看下载至本地的镜像<br>
格式:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker images [OPTIONS] [REPOSITORY[:TAG]]
docker image ls [OPTIONS] [REPOSITORY[:TAG]]
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#24120;&#29992;&#36873;&#39033;:
</span>-q, --quiet Only show numeric IDs
-a, --all Show all images (default hides intermediate images)
    --digests Show digests
    --no-trunc Don<span style="color: #8b2252;">'t truncate output
-f, --filter filter Filter output based on conditions provided
    --format string Pretty-print images using a Go template</span>
</pre>
</div>

<p>
执行结果的显示信息说明:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">REPOSITORY <span style="color: #b22222;">#</span><span style="color: #b22222;">&#38236;&#20687;&#25152;&#23646;&#30340;&#20179;&#24211;&#21517;&#31216;
</span>TAG <span style="color: #b22222;">#</span><span style="color: #b22222;">&#38236;&#20687;&#29256;&#26412;&#21495;&#65288;&#26631;&#35782;&#31526;&#65289;&#65292;&#40664;&#35748;&#20026;latest
</span>IMAGE ID <span style="color: #b22222;">#</span><span style="color: #b22222;">&#38236;&#20687;&#21807;&#19968;ID&#26631;&#35782;,&#22914;&#26524;ID&#30456;&#21516;,&#35828;&#26126;&#26159;&#21516;&#19968;&#20010;&#38236;&#20687;&#26377;&#22810;&#20010;&#21517;&#31216;
</span>CREATED <span style="color: #b22222;">#</span><span style="color: #b22222;">&#38236;&#20687;&#22312;&#20179;&#24211;&#20013;&#34987;&#21019;&#24314;&#26102;&#38388;
</span>VIRTUAL SIZE <span style="color: #b22222;">#</span><span style="color: #b22222;">&#38236;&#20687;&#30340;&#22823;&#23567;</span>
</pre>
</div>

<p>
Repository仓库<br>
</p>
<ul class="org-ul">
<li>由某特定的docker镜像的所有迭代版本组成的镜像仓库<br></li>
<li>一个Registry中可以存在多个Repository<br></li>
<li>Repository可分为“顶层仓库”和“用户仓库”<br></li>
<li>Repository用户仓库名称一般格式为“用户名/仓库名”<br></li>
<li>每个Repository仓库可以包含多个Tag(标签),每个标签对应一个镜像<br></li>
</ul>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#26174;&#31034;&#23436;&#25972;&#30340;ImageID
</span>[root@ubuntu1804 ~]#docker images --no-trunc
<span style="color: #b22222;"># </span><span style="color: #b22222;">&#26597;&#30475;&#25351;&#23450;&#38236;&#20687;&#30340;&#35814;&#32454;&#20449;&#24687;
</span>root@centos8 ~]#podman image inspect alpine
</pre>
</div>
</div>
</div>
<div id="outline-container-h:2c82116e-bfb4-4822-b77f-7584111a1a59" class="outline-4">
<h4 id="h:2c82116e-bfb4-4822-b77f-7584111a1a59">镜像导出</h4>
<div class="outline-text-4" id="text-h:2c82116e-bfb4-4822-b77f-7584111a1a59">
<p>
利用docker save命令可以将从本地镜像导出为一个打包 tar文件，然后复制到其他服务器进行导入使用<br>
格式:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker save [OPTIONS] IMAGE [IMAGE...]
&#36873;&#39033;:
-o, --output string Write to a file, instead of STDOUT
</pre>
</div>

<p>
常见用法:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker save -o /path/file.tar IMAGE1 IMAGE2 ...
docker save IMAGE1 IMAGE2 ... &gt; /path/file.tar
</pre>
</div>
</div>
</div>
<div id="outline-container-h:15ada5fe-b279-4519-a5b0-8d4eeca49093" class="outline-4">
<h4 id="h:15ada5fe-b279-4519-a5b0-8d4eeca49093">镜像导入</h4>
<div class="outline-text-4" id="text-h:15ada5fe-b279-4519-a5b0-8d4eeca49093">
<p>
利用docker load命令可以将镜像导出的压缩文件再导入<br>
格式:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#36873;&#39033;
</span>-i, --input string Read from tar archive file, instead of STDIN
-q, --quiet Suppress the load output&#33539;&#20363;: &#19968;&#27425;&#23548;&#20986;&#22810;&#20010;&#38236;&#20687;
</pre>
</div>

<p>
范例: 镜像导入<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@centos7 ~]#docker load -i /data/myimages.tar
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#25110;&#32773;
</span>[root@centos7 ~]#docker load &lt; /data/myimages.tar
[root@centos7 ~]#docker images
</pre>
</div>

<p>
范例: 一次导出多个镜像<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker save busybox alpine &gt; /all.tar
[root@ubuntu1804 ~]#docker rmi -f <span style="color: #ff00ff;">`docker images -q`</span>
[root@ubuntu1804 ~]#docker load -i /opt/all.tar
[root@ubuntu1804 ~]#docker images
</pre>
</div>
</div>
<div id="outline-container-org969a3ca" class="outline-5">
<h5 id="org969a3ca">一次性打包所有镜像</h5>
<div class="outline-text-5" id="text-org969a3ca">
<div class="org-src-container">
<pre class="src src-sh">docker image save <span style="color: #ff00ff;">`docker image ls --format "{{.Repository}}:{{.Tag}}"`</span> -o k8s-node-images-v1.50.0.tar
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21387;&#32553;
</span>gzip k8s-node-images-v1.50.0.tar
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#25335;&#36125;&#21040;&#20854;&#20182;&#20027;&#26426;&#20043;&#21518;
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">&#30452;&#25509;&#21152;&#36733;&#38236;&#20687;&#23601;&#22909;&#20102;
</span>docker load -i k8s-node-images-v1.50.0.tar.gz
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:90478dc4-5395-4247-81b7-da62809102a8" class="outline-4">
<h4 id="h:90478dc4-5395-4247-81b7-da62809102a8">删除镜像</h4>
<div class="outline-text-4" id="text-h:90478dc4-5395-4247-81b7-da62809102a8">
<p>
docker rmi 命令可以删除本地镜像<br>
</p>

<p>
格式<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker rmi [OPTIONS] IMAGE [IMAGE...]
docker image rm [OPTIONS] IMAGE [IMAGE...]
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#36873;&#39033;:
</span>-f, --force Force removal of the image
    --no-prune Do not delete untagged parents
</pre>
</div>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#21024;&#38500;&#22810;&#20010;&#38236;&#20687;
</span>[root@ubuntu1804 ~]#docker rmi nginx tomcat

<span style="color: #b22222;"># </span><span style="color: #b22222;">&#24378;&#21046;&#21024;&#38500;&#27491;&#22312;&#20351;&#29992;&#30340;&#38236;&#20687;&#65292;&#20063;&#20250;&#21024;&#38500;&#23545;&#24212;&#30340;&#23481;&#22120;
</span>docker rmi -f centos:centos8.1.1911

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21024;&#38500;&#25152;&#26377;&#38236;&#20687;
</span>[root@ubuntu1804 ~]#docker rmi -f <span style="color: #ff00ff;">`docker images -q`</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-h:037a95c2-77bf-493f-b960-4f33af08886a" class="outline-4">
<h4 id="h:037a95c2-77bf-493f-b960-4f33af08886a">镜像打标签</h4>
<div class="outline-text-4" id="text-h:037a95c2-77bf-493f-b960-4f33af08886a">
<p>
docker tag 可以给镜像打标签，类似于起别名,但通常要遵守一定的命名规范,才可以上传到指定的仓库<br>
格式<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]

<span style="color: #b22222;">#</span><span style="color: #b22222;">TARGET_IMAGE[:TAG]&#26684;&#24335;&#19968;&#33324;&#24418;&#24335;
</span>&#20179;&#24211;&#20027;&#26426;FQDN&#25110;IP[:&#31471;&#21475;]/&#39033;&#30446;&#21517;(&#25110;&#29992;&#25143;&#21517;)/image&#21517;&#23383;:&#29256;&#26412;
</pre>
</div>

<p>
TAG默认为latest<br>
</p>

<p>
总结: 企业使用镜像及常见操作: 搜索、下载、导出、导入、删除<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker search centos
docker pull alpine
docker images
docker save &gt; /opt/centos.tar <span style="color: #b22222;">#</span><span style="color: #b22222;">centos #&#23548;&#20986;&#38236;&#20687;
</span>docker load -i centos-latest.tar.xz <span style="color: #b22222;">#</span><span style="color: #b22222;">&#23548;&#20837;&#26412;&#22320;&#38236;&#20687;
</span>docker rmi &#38236;&#20687;ID/&#38236;&#20687;&#21517;&#31216; <span style="color: #b22222;">#</span><span style="color: #b22222;">&#21024;&#38500;&#25351;&#23450;ID&#30340;&#38236;&#20687;&#65292;&#27492;&#38236;&#20687;&#23545;&#24212;&#23481;&#22120;&#27491;&#21551;&#21160;&#38236;&#20687;&#19981;&#33021;&#34987;&#21024;&#38500;&#65292;&#38500;&#38750;&#23558;&#23481;&#22120;&#20840;&#37096;&#20851;&#38381;</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:b27f04cc-9bb4-4df2-b184-0c6ee32ca015" class="outline-3">
<h3 id="h:b27f04cc-9bb4-4df2-b184-0c6ee32ca015">容器操作基础命令</h3>
<div class="outline-text-3" id="text-h:b27f04cc-9bb4-4df2-b184-0c6ee32ca015">
<p>
容器生命周期<br>
<img src="./images/Snipaste_2023-04-26_13-53-36.png" alt="Snipaste_2023-04-26_13-53-36.png"><br>
</p>

<p>
容器相关命令<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker container
Usage:  docker container COMMAND

Manage containers

Commands:
  attach      Attach local standard input, output, and error streams to a running container
  commit      Create a new image from a container<span style="color: #8b2252;">'s changes
  cp          Copy files/folders between a container and the local filesystem
  create      Create a new container
  diff        Inspect changes to files or directories on a container'</span>s filesystem
  <span style="color: #a020f0;">exec</span>        Run a command<span style="color: #a020f0;"> in</span> a running container
  <span style="color: #483d8b;">export</span>      Export a container<span style="color: #8b2252;">'s filesystem as a tar archive
  inspect     Display detailed information on one or more containers
  kill        Kill one or more running containers
  logs        Fetch the logs of a container
  ls          List containers
  pause       Pause all processes within one or more containers
  port        List port mappings or a specific mapping for the container
  prune       Remove all stopped containers
  rename      Rename a container
  restart     Restart one or more containers
  rm          Remove one or more containers
  run         Run a command in a new container
  start       Start one or more stopped containers
  stats       Display a live stream of container(s) resource usage statistics
  stop        Stop one or more running containers
  top         Display the running processes of a container
  unpause     Unpause all processes within one or more containers
  update      Update configuration of one or more containers
  wait        Block until one or more containers stop, then print their exit codes

Run '</span>docker container COMMAND --help<span style="color: #8b2252;">' for more information on a command.</span>
</pre>
</div>
</div>
<div id="outline-container-h:8392fec7-735a-452a-bbcf-1c53c87cd600" class="outline-4">
<h4 id="h:8392fec7-735a-452a-bbcf-1c53c87cd600">启动容器</h4>
<div class="outline-text-4" id="text-h:8392fec7-735a-452a-bbcf-1c53c87cd600">
<p>
docker run 可以启动容器，进入到容器，并随机生成容器ID和名称<br>
</p>
</div>
<div id="outline-container-h:cf8e9e9c-4f4d-4d18-a435-41d2f6bc04b8" class="outline-5">
<h5 id="h:cf8e9e9c-4f4d-4d18-a435-41d2f6bc04b8">启动第一个容器</h5>
<div class="outline-text-5" id="text-h:cf8e9e9c-4f4d-4d18-a435-41d2f6bc04b8">
<p>
范例: 运行docker 的 hello world<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@centos8 ~]# docker run hello-world
[root@centos8 ~]#docker ps -a
</pre>
</div>
</div>
</div>
<div id="outline-container-h:49f3eaf8-aadc-4cf8-966a-29d7326b815a" class="outline-5">
<h5 id="h:49f3eaf8-aadc-4cf8-966a-29d7326b815a">启动容器的流程</h5>
<div class="outline-text-5" id="text-h:49f3eaf8-aadc-4cf8-966a-29d7326b815a">

<figure id="orgd932804">
<img src="./images/Snipaste_2023-04-26_14-01-01.png" alt="Snipaste_2023-04-26_14-01-01.png"><br>

</figure>
</div>
</div>
<div id="outline-container-h:ae69d801-cee8-4cb0-8130-bf7c6b6c7f5a" class="outline-5">
<h5 id="h:ae69d801-cee8-4cb0-8130-bf7c6b6c7f5a">启动容器用法</h5>
<div class="outline-text-5" id="text-h:ae69d801-cee8-4cb0-8130-bf7c6b6c7f5a">
<p>
帮助: man docker-run<br>
命令格式:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker run [&#36873;&#39033;] [&#38236;&#20687;&#21517;] [shell&#21629;&#20196;] [&#21442;&#25968;]
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#36873;&#39033;:
</span>-i, --interactive Keep STDIN open even if not attached&#65292;&#36890;&#24120;&#21644;-t&#19968;&#36215;&#20351;&#29992;
-t, --tty &#20998;&#37197;pseudo-TTY&#65292;&#36890;&#24120;&#21644;-i&#19968;&#36215;&#20351;&#29992;,&#27880;&#24847;&#23545;&#24212;&#30340;&#23481;&#22120;&#24517;&#39035;&#36816;&#34892;shell&#25165;&#25903;&#25345;&#36827;&#20837;
-d, --detach Run container<span style="color: #a020f0;"> in</span> background and print container ID,&#21488;&#21518;&#36816;&#34892;&#65292;&#40664;&#35748;&#21069;&#21488;
--name string Assign a name to the container
--h, --hostname string Container host name
--rm Automatically remove the container when it exits
-p, --publish list Publish a container<span style="color: #8b2252;">'s port(s) to the host
-P, --publish-all Publish all exposed ports to random ports
--dns list Set custom DNS servers
--entrypoint string Overwrite the default ENTRYPOINT of the image
--restart policy
--privileged Give extended privileges to container
-e, --env=[] Set environment variables
--env-file=[] Read in a line delimited file of environment variablespolicy &#35828;&#26126;
</span>
</pre>
</div>

<p>
&#x2013;restart 可以指定四种不同的policy<br>
</p>

<ul class="org-ul">
<li>no： Default is no，Do not automatically restart the container when it exits.<br></li>
<li>on-failure[:maxretries]：on-failure[:max-retries] Restart only if the container exits with a non-zero exit status. Optionally, limit the number of restart retries the Docker daemon attempts.<br></li>
<li>always：Always restart the container regardless of the exit status. When you specifyalways, the Docker daemon will try to restart the container indefinitely. The container will also always start on daemon startup, regardless of the current state of the container.<br></li>
<li>unlessstopped：Always restart the container regardless of the exit status, but do not start it on daemon startup if the container has been put to a stopped state before.<br></li>
</ul>

<p>
<b>注意: 容器启动后,如果容器内没有前台运行的进程,将自动退出停止</b><br>
</p>

<p>
从容器内退出,并停止容器：exit<br>
</p>

<p>
从容器内退出,且容器不停止：同时按三个键，ctrl+p+q<br>
</p>

<p>
docker run &#x2013;name a1 alpine<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">1. &#19968;&#27425;&#24615;&#36816;&#34892;&#23481;&#22120;&#20013;&#21629;
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">&#21551;&#21160;&#30340;&#23481;&#22120;&#22312;&#25191;&#34892;&#23436;shell&#21629;&#20196;&#23601;&#36864;&#20986;&#65292;&#29992;&#20110;&#27979;&#35797;
</span>[root@ubuntu1804 ~]#docker run busybox echo <span style="color: #8b2252;">"Hello cici"</span>
Hello cici

<span style="color: #b22222;">#</span><span style="color: #b22222;">2. &#25351;&#23450;&#23481;&#22120;&#21517;&#31216;
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">&#27880;&#24847;&#27599;&#20010;&#23481;&#22120;&#30340;&#21517;&#31216;&#35201;&#21807;&#19968;
</span>docker run --name a1 alpine

<span style="color: #b22222;">#</span><span style="color: #b22222;">3. &#36816;&#34892;&#20132;&#20114;&#24335;&#23481;&#22120;&#24182;&#36864;&#20986;
</span>docker run -it docker.io/busybox sh
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">exit
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">&#29992;exit&#36864;&#20986;&#21518;&#23481;&#22120;&#20063;&#20572;&#27490;
</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">4. &#35774;&#32622;&#23481;&#22120;&#20869;&#30340;&#20027;&#26426;&#21517;
</span>docker run -it --name a1 -h a1.xxx.org alpine
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">hostname
</span>/ <span style="color: #b22222;"># </span><span style="color: #b22222;">cat /etc/hosts
</span>/ <span style="color: #b22222;"># </span><span style="color: #b22222;">cat /etc/resolv.conf
</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">5. &#19968;&#27425;&#24615;&#36816;&#34892;&#23481;&#22120;&#65292;&#36864;&#20986;&#21518;&#31435;&#21363;&#21024;&#38500;&#65292;&#29992;&#20110;&#27979;&#35797;
</span>[root@ubuntu1804 ~]#docker run --rm alpine cat /etc/issue

<span style="color: #b22222;">#</span><span style="color: #b22222;">6. &#21019;&#24314;&#23481;&#22120;&#21518;&#30452;&#25509;&#36827;&#20837;&#24182;&#36864;&#20986;
</span>&#36864;&#20986;&#20004;&#31181;&#26041;&#24335;:
- exit &#23481;&#22120;&#20063;&#20572;&#27490;
- &#25353;ctrl+p+q &#23481;&#22120;&#19981;&#20572;&#27490;
</pre>
</div>

<p>
<b>什么是守护式容器:</b><br>
</p>
<ul class="org-ul">
<li>能够长期运行<br></li>
<li>无需交互式会话<br></li>
<li>适合运行应用程序和服务<br></li>
</ul>

<p>
范例: 启动前台守护式容器<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker run nginx
172.17.0.4 - - [28/Jul/2020:13:12:49 +0000] <span style="color: #8b2252;">"GET / HTTP/1.1"</span> 200 612 <span style="color: #8b2252;">"-"</span> <span style="color: #8b2252;">"Wget"</span>
<span style="color: #8b2252;">"-"</span>
[root@ubuntu1804 ~]#docker run --rm --name b1 busybox wget -qO - 172.17.0.3
</pre>
</div>

<p>
范例: 启动后台守护式容器<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker run -d nginx

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26377;&#20123;&#23481;&#22120;&#21518;&#21488;&#21551;&#21160;&#19981;&#20250;&#25345;&#32493;&#36816;&#34892;
</span>[root@ubuntu1804 ~]#docker run -d --name alpine4 alpine
[root@ubuntu1804 ~]#docker ps -a
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
3a05bbf66dac alpine <span style="color: #8b2252;">"/bin/sh"</span> 3 seconds ago Exited (0) 2 seconds ago alpine4

[root@ubuntu1804 ~]#docker run -td --name alpine5 alpine
[root@ubuntu1804 ~]#docker ps -a
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
868b33da850c alpine <span style="color: #8b2252;">"/bin/sh"</span> 2 seconds ago Up 1 second alpine5
</pre>
</div>

<p>
范例: 开机自动运行容器<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#40664;&#35748;&#23481;&#22120;&#19981;&#20250;&#33258;&#21160;&#21551;&#21160;
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">&#35774;&#32622;&#23481;&#22120;&#24635;&#26159;&#36816;&#34892;
</span>[root@ubuntu1804 ~]#docker run -d --name nginx --restart=always -p 80:80 nginx
</pre>
</div>

<p>
<b>&#x2013;privileged 选项</b><br>
大约在0.6版，&#x2013;privileged 选项被引入docker。使用该参数，container内的root拥有真正的root权限。<br>
</p>

<p>
否则，container内的root只是外部的一个普通用户权限。privileged启动的容器，可以看到很多host上的设备，并且可以执行mount。甚至允许你在docker容器中启动docker容器。<br>
</p>

<p>
范例: 使用&#x2013;privileged 让容器获取 root 权限<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#21033;&#29992;--privileged &#36873;&#39033;&#36816;&#34892;&#23481;&#22120;
</span>[root@centos8 ~]#podman run -it --privileged centos
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21487;&#20197;&#30475;&#21040;&#23487;&#20027;&#26426;&#30340;&#35774;&#22791;
</span>[root@a6391a8f82e3 /]# lsblk
NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
sda 8:0 0 200G 0 disk
|-sda1 8:1 0 1G 0 part
|-sda2 8:2 0 100G 0 part
|-sda3 8:3 0 50G 0 part
|-sda4 8:4 0 1K 0 part
[root@a6391a8f82e3 /]# mount /dev/sda3 /mnt
[root@a6391a8f82e3 /]# touch /mnt/containter.txt
[root@a6391a8f82e3 /]# echo container data &gt; /mnt/containter.txt
[root@a6391a8f82e3 /]# cat /mnt/containter.txt
container data
[root@a6391a8f82e3 /]#

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#22312;&#23487;&#20027;&#26426;&#26597;&#30475;&#26159;&#21542;&#29983;&#25104;&#25991;&#20214;
</span>[root@centos8 ~]#lsblk
NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
sda 8:0 0 200G 0 disk
&#9500;&#9472;sda1 8:1 0 1G 0 part /boot
&#9500;&#9472;sda2 8:2 0 100G 0 part /
&#9500;&#9472;sda3 8:3 0 50G 0 part /data
&#9500;&#9472;sda4 8:4 0 1K 0 part
&#9492;&#9472;sda5 8:5 0 2G 0 part [SWAP]
sr0 11:0 1 7G 0 rom
[root@centos8 ~]#ll /data/containter.txt
-rw-r--r-- 1 root root 25 Feb 29 12:26 /data/containter.txt
[root@centos8 ~]#cat /data/containter.txt
container data
[root@centos8 ~]#echo host data &gt;&gt; /data/containter.txt
[root@centos8 ~]#cat /data/containter.txt
container data
host data

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#22312;&#23481;&#22120;&#20869;&#21487;&#30475;&#25991;&#20214;&#26159;&#21542;&#21457;&#29983;&#21464;&#21270;
</span>[root@a6391a8f82e3 /]# cat /mnt/containter.txt
container data
</pre>
</div>

<p>
范例: 运行docker官方文档容器<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@centos8 ~]#podman run -it -d -p 4000:4000 docs/docker.github.io:latest
[root@centos8 ~]#podman images docs/docker.github.io
REPOSITORY TAG IMAGE ID CREATED SIZE
docker.io/docs/docker.github.io latest ffd9131eeee7 2 days ago 1.99 GB
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#29992;&#27983;&#35272;&#22120;&#35775;&#38382;http://localhost:4000/&#21487;&#20197;&#30475;&#21040;&#19979;&#38754;docker&#25991;&#26723;&#36164;&#26009;</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:28e3e641-5c5f-46be-ab13-ac3a9d51c106" class="outline-4">
<h4 id="h:28e3e641-5c5f-46be-ab13-ac3a9d51c106">查看容器信息</h4>
<div class="outline-text-4" id="text-h:28e3e641-5c5f-46be-ab13-ac3a9d51c106">
</div>
<div id="outline-container-h:368c52d7-c401-4069-8098-fc37f87eb477" class="outline-5">
<h5 id="h:368c52d7-c401-4069-8098-fc37f87eb477">显示当前存在容器</h5>
<div class="outline-text-5" id="text-h:368c52d7-c401-4069-8098-fc37f87eb477">
<p>
格式<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker ps [OPTIONS]
docker container ls [OPTIONS]
&#36873;&#39033;:
-a, --all Show all containers (default shows just running)
-q, --quiet Only display numeric IDs
-s, --size Display total file sizes
-f, --filter filter Filter output based on conditions provided
-l, --latest Show the latest created container (includes all states)
-n, --last int Show n last created containers (includes all states) (default -1)
</pre>
</div>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#26174;&#31034;&#36816;&#34892;&#30340;&#23481;&#22120;
</span>[root@ubuntu1804 ~]#docker ps

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26174;&#31034;&#20840;&#37096;&#23481;&#22120;&#65292;&#21253;&#25324;&#36864;&#20986;&#29366;&#24577;&#30340;&#23481;&#22120;
</span>[root@ubuntu1804 ~]#docker ps -a

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21482;&#26174;&#31034;&#23481;&#22120;ID
</span>[root@ubuntu1804 ~]#docker ps -a -q
d7ece7f62532
dcdf71d17177

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26174;&#31034;&#23481;&#22120;&#22823;&#23567;
</span>[root@ubuntu1804 ~]#docker ps -a -s

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26174;&#31034;&#26368;&#26032;&#21019;&#24314;&#30340;&#23481;&#22120;(&#20572;&#27490;&#30340;&#23481;&#22120;&#20063;&#33021;&#26174;&#31034;)
</span>[root@ubuntu1804 ~]#docker ps -l
</pre>
</div>

<p>
范例: 显示指定状态的容器<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker ps -f <span style="color: #8b2252;">'status=exited</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-h:cb4dc285-1cdc-4079-a70d-2817678663ad" class="outline-5">
<h5 id="h:cb4dc285-1cdc-4079-a70d-2817678663ad">查看容器内的进程</h5>
<div class="outline-text-5" id="text-h:cb4dc285-1cdc-4079-a70d-2817678663ad">
<div class="org-src-container">
<pre class="src src-shell">docker top CONTAINER [ps OPTIONS]
</pre>
</div>
</div>
</div>
<div id="outline-container-h:5bb394b9-3953-4969-817a-3c2fc85783d4" class="outline-5">
<h5 id="h:5bb394b9-3953-4969-817a-3c2fc85783d4">查看容器资源使用情况</h5>
<div class="outline-text-5" id="text-h:5bb394b9-3953-4969-817a-3c2fc85783d4">
<div class="org-src-container">
<pre class="src src-shell">docker stats [OPTIONS] [CONTAINER...]
Display a live stream of container(s) resource usage statistics

Options:
-a, --all Show all containers (default shows just running)
    --format string Pretty-print images using a Go template
    --no-stream Disable streaming stats and only pull the first result
    --no-trunc Do not truncate output
</pre>
</div>
</div>
</div>
<div id="outline-container-h:05869dcd-11bf-4214-9b2e-fcf77b9ee566" class="outline-5">
<h5 id="h:05869dcd-11bf-4214-9b2e-fcf77b9ee566">查看容器的详细信息</h5>
<div class="outline-text-5" id="text-h:05869dcd-11bf-4214-9b2e-fcf77b9ee566">
<p>
docker inspect 可以查看docker各种对象的详细信息,包括:镜像,容器,网络等<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">docker inspect [OPTIONS] NAME|ID [NAME|ID...]
Options:
-f, --format string Format the output using the given Go template
-s, --size Display total file sizes if the type is container
</pre>
</div>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker inspect 9997
&#36873;&#25321;&#24615;&#26597;&#30475;
[root@ubuntu1804 ~]#docker inspect -f <span style="color: #8b2252;">"{{.Metadata}}"</span> test:v1.0
{2020-07-24 21:56:42.247448035 +0800 CST}

[root@ubuntu1804 ~]#docker inspect -f <span style="color: #8b2252;">"{{.Created}}"</span> c1
2020-07-24T13:37:11.006574248Z
[root@ubuntu1804 ~]#docker inspect --format <span style="color: #8b2252;">"{{.Created}}"</span> c1
2020-07-24T13:37:11.006574248Z
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:9c57b186-3a05-440c-92fc-e01da8cf42a1" class="outline-4">
<h4 id="h:9c57b186-3a05-440c-92fc-e01da8cf42a1">删除容器</h4>
<div class="outline-text-4" id="text-h:9c57b186-3a05-440c-92fc-e01da8cf42a1">
<p>
docker rm 可以删除容器，即使容器正在运行当中，也可以被强制删除掉<br>
格式<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker rm [OPTIONS] CONTAINER [CONTAINER...]
docker container rm [OPTIONS] CONTAINER [CONTAINER...]
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#36873;&#39033;:
</span>-f, --force Force the removal of a running container (uses SIGKILL)&#33539;&#20363;:
-v, --volumes Remove the volumes associated with the container

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21024;&#38500;&#20572;&#27490;&#30340;&#23481;&#22120;
</span>docker container prune [OPTIONS]
Options:
--filter filter Provide filter values (e.g. <span style="color: #8b2252;">'until=&lt;timestamp&gt;'</span>)
-f, --force Do not prompt for confirmation
</pre>
</div>

<p>
范例: 删除所有容器<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker rm -f <span style="color: #ff00ff;">`docker ps -a -q`</span>
[root@ubuntu1804 ~]#docker ps -a -q | xargs docker rm -f
</pre>
</div>

<p>
范例: 删除指定状态的容器<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker rm <span style="color: #ff00ff;">`docker ps -qf status=exited`</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-h:ea56eccf-13df-4758-812d-575f222ed5f6" class="outline-4">
<h4 id="h:ea56eccf-13df-4758-812d-575f222ed5f6">容器的启动和停止</h4>
<div class="outline-text-4" id="text-h:ea56eccf-13df-4758-812d-575f222ed5f6">
<p>
格式<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker start|stop|restart|pause|unpause &#23481;&#22120;ID
</pre>
</div>

<p>
批量正常启动或关闭所有容器<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker start $(docker ps -a -q)
docker stop $(docker ps -a -q)
</pre>
</div>

<p>
范例: 启动并进入容器<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker run --name=c1 -it ubuntu bash
root@539722b55b76:/# exit
<span style="color: #a020f0;">exit</span>

[root@ubuntu1804 ~]#docker ps -l
CONTAINER ID IMAGE COMMAND CREATED
STATUS PORTS NAMES
539722b55b76 ubuntu <span style="color: #8b2252;">"bash"</span> 4 seconds ago
<span style="color: #0000ff;">Exited</span> (0) 1 second ago c1

[root@ubuntu1804 ~]#docker start c1
c1
[root@ubuntu1804 ~]#docker stop c1
c1

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21551;&#21160;&#24182;&#36827;&#20837;&#23481;&#22120;
</span>[root@ubuntu1804 ~]#docker start -i c1
root@539722b55b76:/# exit
<span style="color: #a020f0;">exit</span>
</pre>
</div>

<p>
范例: 启动和停止所有容器<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker stop <span style="color: #ff00ff;">`docker ps -a -q`</span>
[root@ubuntu1804 ~]#docker start <span style="color: #ff00ff;">`docker ps -a -q`</span>
</pre>
</div>

<p>
范例: 暂停和恢复容器<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker run -d --name n1 nginx
[root@ubuntu1804 ~]#docker pause n1
[root@ubuntu1804 ~]#docker unpause n1
</pre>
</div>
</div>
</div>
<div id="outline-container-h:58ed5366-7cb3-4333-bdcd-c5796d055d2c" class="outline-4">
<h4 id="h:58ed5366-7cb3-4333-bdcd-c5796d055d2c">给正在运行的容器发信号</h4>
<div class="outline-text-4" id="text-h:58ed5366-7cb3-4333-bdcd-c5796d055d2c">
<p>
docker kill 可以给容器发信号,默认号SIGKILL,即9信号<br>
</p>

<p>
格式<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker kill [OPTIONS] CONTAINER [CONTAINER...]
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#36873;&#39033;:
</span>-s, --signal string Signal to send to the container (default <span style="color: #8b2252;">"KILL"</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-h:ba8e8656-0e56-493d-8eaa-b5c94c8d1556" class="outline-4">
<h4 id="h:ba8e8656-0e56-493d-8eaa-b5c94c8d1556">进入正在运行的容器</h4>
<div class="outline-text-4" id="text-h:ba8e8656-0e56-493d-8eaa-b5c94c8d1556">
</div>
<div id="outline-container-h:d67f987a-931f-47d1-ba29-4a7f59aa3682" class="outline-5">
<h5 id="h:d67f987a-931f-47d1-ba29-4a7f59aa3682">使用attach命令</h5>
<div class="outline-text-5" id="text-h:d67f987a-931f-47d1-ba29-4a7f59aa3682">
<p>
docker attach 容器名，不推荐使用<br>
attach 类似于vnc，操作会在同一个容器的多个会话界面同步显示，所有使用此方式进入容器的操作都是同步显示的，且使用exit退出后容器自动关闭，不推荐使用，需要进入到有shell环境的容器<br>
</p>
</div>
</div>
<div id="outline-container-h:c670a4ba-732f-4959-ae96-9447ccfcb655" class="outline-5">
<h5 id="h:c670a4ba-732f-4959-ae96-9447ccfcb655">使用exec命令</h5>
<div class="outline-text-5" id="text-h:c670a4ba-732f-4959-ae96-9447ccfcb655">
<p>
在运行中的容器启动新进程,可以执行单次命令，以及进入容器测试环境使用此方式，使用exit退出,但容器还在运行，此为推荐方式<br>
</p>

<p>
格式:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]
&#24120;&#29992;&#36873;&#39033;:
-d, --detach Detached mode: run command<span style="color: #a020f0;"> in</span> the background
-e, --env list Set environment variables
-i, --interactive Keep STDIN open even if not attached
-t, --tty Allocate a pseudo-TTY
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#24120;&#35265;&#29992;&#27861;
</span>docker exec -it &#23481;&#22120;ID sh|bash
</pre>
</div>
</div>
</div>
<div id="outline-container-h:5762044b-29af-40a0-8ed6-e4d9994cac25" class="outline-5">
<h5 id="h:5762044b-29af-40a0-8ed6-e4d9994cac25">使用nsenter命令</h5>
<div class="outline-text-5" id="text-h:5762044b-29af-40a0-8ed6-e4d9994cac25">
<p>
nsenter命令需要通过PID进入到容器内部，且退出后仍然正常运行: 不过需要事先使用docker inspect 获取到容器的PID， 目前此方式使用较少，此工具来自于util-linux包<br>
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#23433;&#35013;nsenter&#21629;&#20196;
</span>yum -y install util-linux <span style="color: #b22222;">#</span><span style="color: #b22222;">CentOS
</span>apt -y install util-linux <span style="color: #b22222;">#</span><span style="color: #b22222;">Ubuntu
</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#33719;&#21462;&#23481;&#22120;&#30340;IP
</span>docker inspect -f <span style="color: #8b2252;">"{{.NetworkSettings.IPAddress}}"</span> &#23481;&#22120;ID

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#33719;&#21462;&#21040;&#26576;&#20010;docker&#23481;&#22120;&#30340;PID&#65292;&#21487;&#20197;&#36890;&#36807;PID&#36827;&#20837;&#21040;&#23481;&#22120;&#20869;
</span>docker inspect -f <span style="color: #8b2252;">"{{.State.Pid}}"</span> &#23481;&#22120;ID
nsenter -t PID -m -u -i -n -p
</pre>
</div>
</div>
</div>
<div id="outline-container-h:51b89d8d-5b15-40e0-a5ef-e570d2f04fee" class="outline-5">
<h5 id="h:51b89d8d-5b15-40e0-a5ef-e570d2f04fee">脚本方式</h5>
<div class="outline-text-5" id="text-h:51b89d8d-5b15-40e0-a5ef-e570d2f04fee">
<p>
将nsenter命令写入到脚本进行调用，方便进入容器看日志或排错<br>
</p>

<p>
如下:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">cat docker-in.sh
<span style="color: #b22222;">#</span><span style="color: #b22222;">!/bin/bash
</span>
<span style="color: #0000ff;">docker_in</span>(){
<span style="color: #a0522d;">NAME_ID</span>=$<span style="color: #a0522d;">1</span>
<span style="color: #a0522d;">PID</span>=$(docker inspect -f <span style="color: #8b2252;">"{{.State.Pid}}"</span> ${<span style="color: #a0522d;">NAME_ID</span>})
nsenter -t ${<span style="color: #a0522d;">PID</span>} -m -u -i -n -p
}

docker_in $<span style="color: #a0522d;">1</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-h:df395a1f-9389-46fe-9212-c6732935a0c0" class="outline-5">
<h5 id="h:df395a1f-9389-46fe-9212-c6732935a0c0">暴露所有容器端口</h5>
<div class="outline-text-5" id="text-h:df395a1f-9389-46fe-9212-c6732935a0c0">
<p>
容器启动后,默认处于预定义的NAT网络中,所以外部网络的主机无法直接访问容器中网络服务<br>
</p>

<p>
docker run -P 可以将事先容器预定义的所有端口映射宿主机的网卡的随机端口，默认从32768开始<br>
</p>

<p>
使用随机端口 时,当停止容器后再启动可能会导致端口发生变化<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">-P , --publish-all= true | <span style="color: #483d8b;">false</span>&#40664;&#35748;&#20026;false
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#31034;&#20363;:
</span>docker run -P docker.io/nginx <span style="color: #b22222;">#</span><span style="color: #b22222;">&#26144;&#23556;&#23481;&#22120;&#25152;&#26377;&#26292;&#38706;&#31471;&#21475;&#33267;&#38543;&#26426;&#26412;&#22320;&#31471;&#21475;</span>
</pre>
</div>

<p>
docker port 可以查看容器的端口映射关系<br>
格式<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker port CONTAINER [PRIVATE_PORT[/PROTO]]
</pre>
</div>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@centos7 ~]#docker port nginx-c1
443/tcp -&gt; 0.0.0.0:8443
53/udp -&gt; 0.0.0.0:8053
80/tcp -&gt; 0.0.0.0:8080
[root@centos7 ~]#docker port nginx-c1 53/udp
0.0.0.0:8053
</pre>
</div>

<p>
<b>端口映射的本质就是利用NAT技术实现的</b><br>
</p>

<p>
范例: 端口映射和iptables<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#31471;&#21475;&#26144;&#23556;&#21069;&#30340;iptables&#35268;&#21017;
</span>[root@ubuntu1804 ~]#iptables -S
[root@ubuntu1804 ~]#iptables -S -t nat
[root@ubuntu1804 ~]#iptables -S &gt; pre.filter
[root@ubuntu1804 ~]#iptables -S -t nat &gt; pre.nat

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#23454;&#29616;&#31471;&#21475;&#26144;&#23556;
</span>[root@ubuntu1804 ~]#docker run -d -P --name nginx1 nginx
[root@ubuntu1804 ~]#docker exec -it nginx1 hostname -i
172.17.0.2
[root@ubuntu1804 ~]#docker port nginx1
80/tcp -&gt; 0.0.0.0:32769

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#31471;&#21475;&#26144;&#23556;&#21518;&#30340;iptables&#35268;&#21017;
</span>[root@ubuntu1804 ~]#iptables -S

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#23545;&#27604;&#31471;&#21475;&#26144;&#23556;&#21069;&#21518;&#30340;&#21464;&#21270;
</span>[root@ubuntu1804 ~]#iptables -S &gt; post.filter
[root@ubuntu1804 ~]#iptables -S -t nat &gt; post.nat
[root@ubuntu1804 ~]#diff pre.filter post.filter
13a14
&gt; -A DOCKER -d 172.17.0.2/32 ! -i docker0 -o docker0 -p tcp -m tcp --dport 80 -j ACCEPT
[root@ubuntu1804 ~]#diff pre.nat post.nat
8a9
&gt; -A POSTROUTING -s 172.17.0.2/32 -d 172.17.0.2/32 -p tcp -m tcp --dport 80 -jMASQUERADE
9a11
&gt; -A DOCKER ! -i docker0 -p tcp -m tcp --dport 32769 -j DNAT --to-destination
172.17.0.2:80

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26412;&#22320;&#21644;&#36873;&#31243;&#37117;&#21487;&#20197;&#35775;&#38382;
</span>[root@ubuntu1804 ~]#curl 127.0.0.1:32769

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21033;&#29992;iptables &#38459;&#27490;&#21516;&#19968;&#20010;&#23487;&#20027;&#26426;&#30340;&#20854;&#23427;&#23481;&#22120;CentOS8&#30340;&#35775;&#38382;
</span>[root@ubuntu1804 ~]#iptables -I DOCKER -s 10.0.0.8 -d 172.17.0.2 -p tcp --dport 80 -j REJECT
[root@ubuntu1804 ~]#iptables -S

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#27979;&#35797;&#35775;&#38382;
</span>[root@centos8 ~]#curl 10.0.0.100:32769
curl: (7) Failed to connect to 10.0.0.100 port 32769: Connection refused

[root@centos7 ~]#curl -I 10.0.0.100:32769
HTTP/1.1 200 OK
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:7b8fdf51-a7c6-4f17-9d41-41c15691128a" class="outline-4">
<h4 id="h:7b8fdf51-a7c6-4f17-9d41-41c15691128a">指定端口映射</h4>
<div class="outline-text-4" id="text-h:7b8fdf51-a7c6-4f17-9d41-41c15691128a">
<p>
docker run -p 可以将容器的预定义的指定端口映射到宿主机的相应端口<br>
</p>

<p>
注意: 多个容器映射到宿主机的端口不能冲突，但容器内使用的端口可以相同<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">&#26041;&#24335;1: &#23481;&#22120;80&#31471;&#21475;&#26144;&#23556;&#23487;&#20027;&#26426;&#26412;&#22320;&#38543;&#26426;&#31471;&#21475;
docker run -p 80 --name nginx-test-port1 nginx

&#26041;&#24335;2: &#23481;&#22120;80&#31471;&#21475;&#26144;&#23556;&#21040;&#23487;&#20027;&#26426;&#26412;&#22320;&#31471;&#21475;81
docker run -p 81:80 --name nginx-test-port2 nginx

&#26041;&#24335;3: &#23487;&#20027;&#26426;&#26412;&#22320;IP:&#23487;&#20027;&#26426;&#26412;&#22320;&#31471;&#21475;:&#23481;&#22120;&#31471;&#21475;
docker run -p 10.0.0.100:82:80 --name nginx-test-port3 docker.io/nginx

&#26041;&#24335;4: &#23487;&#20027;&#26426;&#26412;&#22320;IP:&#23487;&#20027;&#26426;&#26412;&#22320;&#38543;&#26426;&#31471;&#21475;:&#23481;&#22120;&#31471;&#21475;&#65292;&#40664;&#35748;&#20174;32768&#24320;&#22987;
docker run -p 10.0.0.100::80 --name nginx-test-port4 docker.io/nginx

&#26041;&#24335;5: &#23487;&#20027;&#26426;&#26412;&#26426;ip:&#23487;&#20027;&#26426;&#26412;&#22320;&#31471;&#21475;:&#23481;&#22120;&#31471;&#21475;/&#21327;&#35758;&#65292;&#40664;&#35748;&#20026;tcp&#21327;&#35758;
docker run -p 10.0.0.100:83:80/udp --name nginx-test-port5 docker.io/nginx

&#26041;&#24335;6: &#19968;&#27425;&#24615;&#26144;&#23556;&#22810;&#20010;&#31471;&#21475;+&#21327;&#35758;
docker run -p 8080:80/tcp -p 8443:443/tcp -p 53:53/udp --name nginx-test-port6 nginx
</pre>
</div>
</div>
</div>
<div id="outline-container-h:9560fe05-89bd-4ba6-a046-03b05c349a89" class="outline-4">
<h4 id="h:9560fe05-89bd-4ba6-a046-03b05c349a89">查看容器的日志</h4>
<div class="outline-text-4" id="text-h:9560fe05-89bd-4ba6-a046-03b05c349a89">
<p>
docker logs 可以查看容器中运行的进程在控制台输出的日志信息<br>
</p>

<p>
格式<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker logs [OPTIONS] CONTAINER
&#36873;&#39033;:
--details Show extra details provided to logs
-f, --follow Follow log output
--since string Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes)
--tail string Number of lines to show from the end of the logs (default <span style="color: #8b2252;">"all"</span>)
-t, --timestamps Show timestamps
--until string Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes)
</pre>
</div>

<p>
范例: 查看容器日志<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker run -d alpine /bin/sh -c <span style="color: #8b2252;">'i=1;while true;do echo hello$i;let i++;sleep 2;done'</span>
[root@ubuntu1804 ~]#docker logs 5126
hello1
hello2
hello3
hello4
hello5
hello6
[root@ubuntu1804 ~]#docker logs --tail 3 5126
hello8
hello9
hello10

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26174;&#31034;&#26102;&#38388;
</span>[root@ubuntu1804 ~]#docker logs --tail 0 -t 5126
2020-02-25T13:30:07.321390731Z hello17

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#25345;&#32493;&#36319;&#36394;
</span>[root@ubuntu1804 ~]#docker logs -f 5126
</pre>
</div>
</div>
</div>
<div id="outline-container-h:a439a451-1df9-4911-ba94-d548f4336155" class="outline-4">
<h4 id="h:a439a451-1df9-4911-ba94-d548f4336155">传递运行命令</h4>
<div class="outline-text-4" id="text-h:a439a451-1df9-4911-ba94-d548f4336155">
<p>
容器需要有一个前台运行的进程才能保持容器的运行，通过传递运行参数是一种方式，另外也可以在构建镜像的时候指定容器启动时运行的前台命令<br>
</p>

<p>
容器里的PID为1的守护进程的实现方式<br>
</p>
<ul class="org-ul">
<li>服务类: 如: Nginx，Tomcat，Apache ，但服务不能停<br></li>
<li>命令类: 如: tail -f /etc/hosts ，主要用于测试环境，注意: 不要tail -f &lt;服务访问日志&gt; 会产生不必要的磁盘IO<br></li>
</ul>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker run -d alpine tail -f /etc/hosts
</pre>
</div>
</div>
</div>
<div id="outline-container-h:56df7eeb-d6cd-428e-aab3-1ef20dd60d8d" class="outline-4">
<h4 id="h:56df7eeb-d6cd-428e-aab3-1ef20dd60d8d">容器内部的hosts文件</h4>
<div class="outline-text-4" id="text-h:56df7eeb-d6cd-428e-aab3-1ef20dd60d8d">
<p>
容器会自动将容器的ID加入自已的/etc/hosts文件中，并解析成容器的IP<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker run -it centos /bin/bash
[root@598262a87c46 /]# cat /etc/hosts
127.0.0.1 localhost
::1 localhost ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
172.17.0.2 598262a87c46 <span style="color: #b22222;">#</span><span style="color: #b22222;">&#40664;&#35748;&#20250;&#23558;&#23454;&#20363;&#30340;ID &#28155;&#21152;&#21040;&#33258;&#24049;&#30340;hosts&#25991;&#20214;
</span>[root@598262a87c46 /]# hostname
598262a87c46
[root@598262a87c46 /]# ping 598262a87c46
PING 598262a87c46 (172.17.0.2) 56(84) bytes of data.
64 bytes from 598262a87c46 (172.17.0.2): <span style="color: #a0522d;">icmp_seq</span>=1 <span style="color: #a0522d;">ttl</span>=64 <span style="color: #a0522d;">time</span>=0.118 ms
64 bytes from 598262a87c46 (172.17.0.2): <span style="color: #a0522d;">icmp_seq</span>=2 <span style="color: #a0522d;">ttl</span>=64 <span style="color: #a0522d;">time</span>=0.085 ms
</pre>
</div>

<p>
范例: 修改容器的 hosts文件<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker run -it --rm --add-host www.xxx.com:6.6.6.6 --add-host www.ttt.org:8.8.8.8 busybox
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">cat /etc/hosts
</span>127.0.0.1 localhost
::1 localhost ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
6.6.6.6 www.xxx.com
8.8.8.8 www.ttt.org
172.17.0.2 449bf0468efd
</pre>
</div>
</div>
</div>
<div id="outline-container-h:8e0d95bc-463b-4eff-a423-97bf3f5e4285" class="outline-4">
<h4 id="h:8e0d95bc-463b-4eff-a423-97bf3f5e4285">指定容器DNS</h4>
<div class="outline-text-4" id="text-h:8e0d95bc-463b-4eff-a423-97bf3f5e4285">
<p>
容器的dns服务器，默认采用宿主机的dns 地址，可以用下面方式指定其它的DNS地址<br>
</p>

<ul class="org-ul">
<li>将dns地址配置在宿主机<br></li>
<li>在容器启动时加选项 &#x2013;dns=x.x.x.x<br></li>
<li>在/etc/docker/daemon.json 文件中指定<br></li>
</ul>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#33539;&#20363;: &#23481;&#22120;&#30340;DNS&#40664;&#35748;&#20174;&#23487;&#20027;&#26426;&#30340;DNS&#33719;&#21462;
</span>[root@ubuntu1804 ~]#systemd-resolve --status|grep -A1 -i <span style="color: #8b2252;">"DNS Servers"</span>
DNS Servers: 180.76.76.76
223.6.6.6
[root@ubuntu1804 ~]#docker run -it --rm centos bash
[root@1364f98c4227 /]# cat /etc/resolv.conf
nameserver 180.76.76.76
nameserver 223.6.6.6
search xxx.com xxx.org
[root@1364f98c4227 /]# exit
<span style="color: #a020f0;">exit</span>

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#33539;&#20363;: &#25351;&#23450;DNS&#22320;&#22336;
</span>[root@ubuntu1804 ~]#docker run -it --rm --dns 1.1.1.1 --dns 8.8.8.8 centos bash

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#33539;&#20363;: &#25351;&#23450;domain&#21517;
</span>[root@ubuntu1804 ~]#docker run -it --rm --dns 1.1.1.1 --dns 8.8.8.8 --dns-search a.com --dns-search b.com busybox
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">cat /etc/resolv.conf
</span>search a.com b.com
nameserver 1.1.1.1
nameserver 8.8.8.8

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#33539;&#20363;: &#37197;&#32622;&#25991;&#20214;&#25351;&#23450;DNS&#21644;&#25628;&#32034;domain&#21517;
</span>[root@ubuntu1804 ~]#cat /etc/docker/daemon.json
{
<span style="color: #8b2252;">"storage-driver"</span>: <span style="color: #8b2252;">"overlay2"</span>,
<span style="color: #8b2252;">"registry-mirrors"</span>: [<span style="color: #8b2252;">"https://si7y70hh.mirror.aliyuncs.com"</span>],
<span style="color: #8b2252;">"dns"</span> : [ <span style="color: #8b2252;">"114.114.114.114"</span>, <span style="color: #8b2252;">"119.29.29.29"</span>],
<span style="color: #8b2252;">"dns-search"</span>: [ <span style="color: #8b2252;">"xxx.com"</span>, <span style="color: #8b2252;">"xxx.org"</span>]
}

[root@ubuntu1804 ~]#systemctl restart docker
[root@ubuntu1804 ~]#docker run -it --rm centos bash
[root@7a2d8fac6f6b /]# cat /etc/resolv.conf

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#29992;--dns&#25351;&#23450;&#20248;&#20808;&#32423;&#26356;&#39640;
</span>[root@ubuntu1804 ~]#docker run -it --rm --dns 8.8.8.8 --dns 8.8.4.4 centos bash
[root@80ffe3547b87 /]# cat /etc/resolv.conf
search xxx.com xxx.org
nameserver 8.8.8.8
nameserver 8.8.4.4
</pre>
</div>
</div>
</div>
<div id="outline-container-h:60565b97-ad01-4248-b87d-6b22e777d5fc" class="outline-4">
<h4 id="h:60565b97-ad01-4248-b87d-6b22e777d5fc">容器内和宿主机之间复制文件</h4>
<div class="outline-text-4" id="text-h:60565b97-ad01-4248-b87d-6b22e777d5fc">
<div class="org-src-container">
<pre class="src src-shell">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-
docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH
Options:
-a, --archive Archive mode (copy all uid/gid information)
-L, --follow-link Always follow symbol link<span style="color: #a020f0;"> in</span> SRC_PATH
</pre>
</div>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#23558;&#23481;&#22120;&#20869;&#25991;&#20214;&#22797;&#21046;&#21040;&#23487;&#20027;&#26426;
</span>[root@ubuntu1804 ~]#docker run -itd centos
1311fe67e6708dac71c01f7d1752a6dcb5e85c2f1fa4ac2efcef9edfe4fb6bb5

[root@ubuntu1804 ~]#docker cp -a 1311:/etc/centos-release .
[root@ubuntu1804 ~]#cat centos-release
CentOS Linux release 8.1.1911 (Core)

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#23558;&#23487;&#20027;&#26426;&#25991;&#20214;&#22797;&#21046;&#21040;&#23481;&#22120;&#20869;
</span>[root@ubuntu1804 ~]#docker cp /etc/issue 1311:/root/
[root@ubuntu1804 ~]#docker exec 1311 cat /root/issue
Ubuntu 18.04.1 LTS \n \l
</pre>
</div>
</div>
</div>
<div id="outline-container-h:e4499075-057d-40d8-bcd1-5ba7456d5a63" class="outline-4">
<h4 id="h:e4499075-057d-40d8-bcd1-5ba7456d5a63">使用 systemd 控制容器运行</h4>
<div class="outline-text-4" id="text-h:e4499075-057d-40d8-bcd1-5ba7456d5a63">
<div class="org-src-container">
<pre class="src src-shell">
[root@ubuntu1804 ~]#cat /lib/systemd/system/hello.service
[Unit]
<span style="color: #a0522d;">Description</span>=Hello World
<span style="color: #a0522d;">After</span>=docker.service
<span style="color: #a0522d;">Requires</span>=docker.service
[Service]
<span style="color: #a0522d;">TimeoutStartSec</span>=0
<span style="color: #a0522d;">ExecStartPre</span>=-/usr/bin/docker kill busybox-hello
<span style="color: #a0522d;">ExecStartPre</span>=-/usr/bin/docker rm busybox-hello
<span style="color: #a0522d;">ExecStartPre</span>=/usr/bin/docker pull busybox
<span style="color: #a0522d;">ExecStart</span>=/usr/bin/docker run --name busybox-hello busybox /bin/sh -c <span style="color: #8b2252;">"while
true; do echo Hello World; sleep 1; done"</span>
<span style="color: #a0522d;">ExecStop</span>=/usr/bin/docker kill busybox-hello
[Install]
<span style="color: #a0522d;">WantedBy</span>=multi-user.target
[root@ubuntu1804 ~]#systemctl daemon-reload
[root@ubuntu1804 ~]#systemctl enable --now hello.service
</pre>
</div>
</div>
</div>
<div id="outline-container-h:4529de20-e153-40db-b532-5426ceda6dcc" class="outline-4">
<h4 id="h:4529de20-e153-40db-b532-5426ceda6dcc">传递环境变量</h4>
<div class="outline-text-4" id="text-h:4529de20-e153-40db-b532-5426ceda6dcc">
<p>
有些容器运行时，需要传递变量，可以使用 -e &lt;参数&gt; 或 &#x2013;env-file &lt;参数文件&gt; 实现<br>
</p>

<p>
范例: 传递变量创建MySQL<br>
</p>

<p>
变量参考链接: <a href="https://hub.docker.com/_/mysql">https://hub.docker.com/_/mysql</a><br>
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">MySQL&#23481;&#22120;&#36816;&#34892;&#26102;&#38656;&#35201;&#25351;&#23450;root&#30340;&#21475;&#20196;
</span>docker run --name mysql-test1 -v /data/mysql:/var/lib/mysql -e <span style="color: #a0522d;">MYSQL_ROOT_PASSWORD</span>=123456 -e <span style="color: #a0522d;">MYSQL_DATABASE</span>=wordpress -e <span style="color: #a0522d;">MYSQL_USER</span>=wpuser -e <span style="color: #a0522d;">MYSQL_PASSWORD</span>=123456 -d -p 3306:3306 mysql:5.7.30

docker run --name mysql-test2 -v /root/mysql/:/etc/mysql/conf.d -v /data/mysql2:/var/lib/mysql --envfile=env.list -d -p 3307:3306 mysql:5.7.30

[root@ubuntu1804 ~]#cat mysql/mysql-test.cnf
[mysqld]
server-id=100
log-bin=mysql-bin
[root@ubuntu1804 ~]#cat env.list
<span style="color: #a0522d;">MYSQL_ROOT_PASSWORD</span>=123456
<span style="color: #a0522d;">MYSQL_DATABASE</span>=wordpress
<span style="color: #a0522d;">MYSQL_USER</span>=wpuser
<span style="color: #a0522d;">MYSQL_PASSWORD</span>=wppass
</pre>
</div>
</div>
</div>
</div>
</section>
<section id="outline-container-h:969a017e-62b3-4e42-a2e7-d5f7f9db8b95" class="outline-2">
<h2 id="h:969a017e-62b3-4e42-a2e7-d5f7f9db8b95">Docker 镜像制作和管理</h2>
<div class="outline-text-2" id="text-h:969a017e-62b3-4e42-a2e7-d5f7f9db8b95">
</div>
<div id="outline-container-h:e5ace7d7-1cf7-4c10-8d16-e5790cbb64bf" class="outline-3">
<h3 id="h:e5ace7d7-1cf7-4c10-8d16-e5790cbb64bf">Docker 镜像说明</h3>
<div class="outline-text-3" id="text-h:e5ace7d7-1cf7-4c10-8d16-e5790cbb64bf">
</div>
<div id="outline-container-h:31dbbde1-83d7-44ac-99f3-2a96fcad0cab" class="outline-4">
<h4 id="h:31dbbde1-83d7-44ac-99f3-2a96fcad0cab">Docker 镜像中有没有内核</h4>
<div class="outline-text-4" id="text-h:31dbbde1-83d7-44ac-99f3-2a96fcad0cab">
<p>
从镜像大小上面来说，一个比较小的镜像只有1MB多点或几MB，而内核文件需要几十MB， 因此镜像里面是没有内核的，镜像在被启动为容器后将直接使用宿主机的内核，而镜像本身则只提供相应的<br>
</p>

<p>
rootfs，即系统正常运行所必须的用户空间的文件系统，比如: /dev/，/proc，/bin，/etc等目录，容器当中/boot目录是空的，而/boot当中保存的就是与内核相关的文件和目录。<br>
</p>
</div>
</div>
<div id="outline-container-h:97f29990-93d1-4397-8daf-833ffd96c4d5" class="outline-4">
<h4 id="h:97f29990-93d1-4397-8daf-833ffd96c4d5">为什么没有内核</h4>
<div class="outline-text-4" id="text-h:97f29990-93d1-4397-8daf-833ffd96c4d5">
<p>
由于容器启动和运行过程中是直接使用了宿主机的内核，不会直接调用物理硬件，所以也不会涉及到硬件驱动，因此也无需容器内拥有自已的内核和驱动。而如果使用虚拟机技术，对应每个虚拟机都有自已独立的内核<br>
</p>
</div>
</div>
<div id="outline-container-h:fc5c3629-35e0-4680-92af-da408e6705f5" class="outline-4">
<h4 id="h:fc5c3629-35e0-4680-92af-da408e6705f5">容器中的程序后台运行会导致此容器启动后立即退出</h4>
<div class="outline-text-4" id="text-h:fc5c3629-35e0-4680-92af-da408e6705f5">
<p>
Docker容器如果希望启动后能持续运行,就必须有一个能前台持续运行的进程，如果在容器中启动传统的服务，如:httpd,php-fpm等均为后台进程模式运行,就导致 docker 在前台没有运行的应用,这样的容器启动后会立即退出。所以一般会将服务程序以前台方式运行，对于有一些可能不知道怎么实现前台运行的程序,只需要在你启动的该程序之后添加类似于 tail ，top 这种可以前台运行的程序即可. 比较常用的方法，如 `tail -f /etc/hosts` 。<br>
</p>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">httpd
</span>ENTRYPOINT [ <span style="color: #8b2252;">"/usr/sbin/apache2"</span> ]
CMD [<span style="color: #8b2252;">"-D"</span>, <span style="color: #8b2252;">"FOREGROUND"</span>]

<span style="color: #b22222;">#</span><span style="color: #b22222;">nginx
</span>ENTRYPOINT [ <span style="color: #8b2252;">"/usr/sbin/nginx"</span>, <span style="color: #8b2252;">"-g"</span>, <span style="color: #8b2252;">"daemon off;"</span> ]

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#29992;&#33050;&#26412;&#36816;&#34892;&#23481;&#22120;
</span>cat run_haproxy.sh
<span style="color: #b22222;">#</span><span style="color: #b22222;">!/bin/bash
</span>haproxy -f /etc/haproxy/haproxy.cfg
tail -f /etc/hosts
tail -n1 Dockerfile
CMD [<span style="color: #8b2252;">"run_haproxy.sh"</span>]
</pre>
</div>
</div>
</div>
<div id="outline-container-h:40ba9475-54f7-405d-8560-ef111651bb55" class="outline-4">
<h4 id="h:40ba9475-54f7-405d-8560-ef111651bb55">docker 镜像生命周期</h4>
<div class="outline-text-4" id="text-h:40ba9475-54f7-405d-8560-ef111651bb55">

<figure id="orge42e5bf">
<img src="./images/Snipaste_2023-04-27_00-27-36.png" alt="Snipaste_2023-04-27_00-27-36.png"><br>

</figure>
</div>
</div>
<div id="outline-container-h:ac234a41-c20e-4008-8f5c-fe95363bdd5f" class="outline-4">
<h4 id="h:ac234a41-c20e-4008-8f5c-fe95363bdd5f">制作镜像方式</h4>
<div class="outline-text-4" id="text-h:ac234a41-c20e-4008-8f5c-fe95363bdd5f">
<p>
Docker 镜像制作类似于虚拟机的镜像（模版）制作，即按照公司的实际业务需求将需要安装的软件、相关配置等基础环境配置完成，然后将其做成镜像，最后再批量从镜像批量生成容器实例，这样可以极大的简化相同环境的部署工作.<br>
</p>

<p>
Docker的镜像制作分为手动制作（基于容器）和自动制作(基于DockerFile)，企业通常都是基于Dockerfile制作镜像<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker commit <span style="color: #b22222;">#</span><span style="color: #b22222;">&#36890;&#36807;&#20462;&#25913;&#29616;&#26377;&#23481;&#22120;,&#23558;&#20043;&#25163;&#21160;&#26500;&#24314;&#20026;&#38236;&#20687;
</span>docker build <span style="color: #b22222;">#</span><span style="color: #b22222;">&#36890;&#36807;Dockerfile&#25991;&#20214;,&#25209;&#37327;&#26500;&#24314;&#20026;&#38236;&#20687;</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:46df6738-aa4f-42bf-a6d0-8812ef64192b" class="outline-3">
<h3 id="h:46df6738-aa4f-42bf-a6d0-8812ef64192b">将现有容器通过 docker commit 手动构建镜像</h3>
<div class="outline-text-3" id="text-h:46df6738-aa4f-42bf-a6d0-8812ef64192b">
</div>
<div id="outline-container-h:366c99a9-68ec-487d-bcda-f401b9cee737" class="outline-4">
<h4 id="h:366c99a9-68ec-487d-bcda-f401b9cee737">基于容器手动制作镜像步骤</h4>
<div class="outline-text-4" id="text-h:366c99a9-68ec-487d-bcda-f401b9cee737">
<p>
docker commit 格式<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#36873;&#39033;
</span>-a, --author string Author (e.g., <span style="color: #8b2252;">"John Hannibal Smith <a href="mailto:hannibal%40ateam.com">&lt;hannibal@ateam.com&gt;</a>"</span>)
-c, --change list Apply Dockerfile instruction to the created image
-m, --message string Commit message
-p, --pause Pause container during commit (default true)

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#35828;&#26126;:
</span>&#21046;&#20316;&#38236;&#20687;&#21644;CONTAINER&#29366;&#24577;&#26080;&#20851;,&#20572;&#27490;&#29366;&#24577;&#20063;&#21487;&#20197;&#21046;&#20316;&#38236;&#20687;
&#22914;&#26524;&#27809;&#26377;&#25351;&#23450;[REPOSITORY[:TAG]],REPOSITORY&#21644;TAG&#37117;&#20026;&lt;none&gt;
&#25552;&#20132;&#30340;&#26102;&#20505;&#26631;&#35760;TAG&#21495;: &#29983;&#20135;&#24403;&#20013;&#24120;&#29992;&#65292;&#21518;&#26399;&#21487;&#20197;&#26681;&#25454;TAG&#26631;&#35760;&#21019;&#24314;&#19981;&#21516;&#29256;&#26412;&#30340;&#38236;&#20687;&#20197;&#21450;&#21019;&#24314;&#19981;&#21516;&#29256;&#26412;&#30340;&#23481;&#22120;
</pre>
</div>

<p>
<b>基于容器手动制作镜像步骤具体如下:</b><br>
</p>
<ul class="org-ul">
<li>下载一个系统的官方基础镜像，如: CentOS 或 Ubuntu<br></li>
<li>基于基础镜像启动一个容器,并进入到容器<br></li>
<li>在容器里面做配置操作<br>
<ul class="org-ul">
<li>安装基础命令<br></li>
<li>配置运行环境<br></li>
<li>安装服务和配置服务<br></li>
<li>放业务程序代码<br></li>
</ul></li>
<li>提交为一个新镜像 docker commit<br></li>
<li>基于自己的的镜像创建容器并测试访问<br></li>
</ul>
</div>
</div>
<div id="outline-container-h:3179e75e-d5a8-4208-abf6-5620649342a7" class="outline-4">
<h4 id="h:3179e75e-d5a8-4208-abf6-5620649342a7">实战案例: 基于 busybox 制作 httpd 镜像</h4>
<div class="outline-text-4" id="text-h:3179e75e-d5a8-4208-abf6-5620649342a7">
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker run -it --name b1 busybox
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ls
</span>bin dev etc home proc root sys tmp usr var
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">mkdir /data/html -p
</span>/ <span style="color: #b22222;"># </span><span style="color: #b22222;">echo httpd website in busybox &gt; /data/html/index.html
</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26684;&#24335;1
</span>[root@ubuntu1804 ~]#docker commit -a <span style="color: #8b2252;">"user1<a href="mailto:root%40xxx.com">&lt;root@xxx.com&gt;</a>"</span> -c <span style="color: #8b2252;">'CMD /bin/httpd -fv -h /data/html'</span> -c <span style="color: #8b2252;">"EXPOSE 80"</span> b1 httpd-busybox:v1.0
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26684;&#24335;2
</span>[root@ubuntu1804 ~]#docker commit -a <span style="color: #8b2252;">"user1<a href="mailto:root%40xxx.com">&lt;root@xxx.com&gt;</a>"</span> -c <span style="color: #8b2252;">'CMD ["/bin/httpd", "-f", "-v","-h", "/data/html"]'</span> -c <span style="color: #8b2252;">"EXPOSE 80"</span> b1 httpdbusybox:v1.0

[root@ubuntu1804 ~]#docker run -d -P --name httpd01 httpd-busybox:v1.0

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#23545;&#24212;&#26684;&#24335;1
</span>[root@ubuntu1804 ~]#docker inspect -f <span style="color: #8b2252;">"{{.Config.Cmd}}"</span> httpd01
[/bin/sh -c /bin/httpd -f -h /data/html]
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#23545;&#24212;&#26684;&#24335;2
</span>[root@ubuntu1804 ~]#docker inspect -f <span style="color: #8b2252;">"{{.Config.Cmd}}"</span> httpd01
[/bin/httpd -f -h /data/html]

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#20877;&#27425;&#21046;&#20316;&#38236;&#20687;v2.0&#29256;
</span>[root@ubuntu1804 ~]#docker commit -a <span style="color: #8b2252;">"user1<a href="mailto:root%40xxx.com">&lt;root@xxx.com&gt;</a>"</span> b1 httpdbusybox:v2.0
[root@ubuntu1804 ~]#docker run -d --name web2 -p 81:80 httpd-busybox:v2.0 /bin/httpd -fv -h /data/html
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:270fce76-bfaf-4cb8-844d-856cf2ca9507" class="outline-3">
<h3 id="h:270fce76-bfaf-4cb8-844d-856cf2ca9507">利用 DockerFile 文件执行 docker build 自动构建镜像</h3>
<div class="outline-text-3" id="text-h:270fce76-bfaf-4cb8-844d-856cf2ca9507">
</div>
<div id="outline-container-h:647becca-7862-4981-8f4a-1c78d513de79" class="outline-4">
<h4 id="h:647becca-7862-4981-8f4a-1c78d513de79">Dockfile 使用详解</h4>
<div class="outline-text-4" id="text-h:647becca-7862-4981-8f4a-1c78d513de79">
</div>
<div id="outline-container-h:e2cb0db0-b6ce-4a64-99fa-ab9b66b4b7c2" class="outline-5">
<h5 id="h:e2cb0db0-b6ce-4a64-99fa-ab9b66b4b7c2">Dockerfile 介绍</h5>
<div class="outline-text-5" id="text-h:e2cb0db0-b6ce-4a64-99fa-ab9b66b4b7c2">
<p>
DockerFile 是一种被Docker程序解释执行的脚本，由一条条的命令组成的，每条命令对应linux下面的一条命令，Docker程序将这些DockerFile指令再翻译成真正的linux命令，其有自己的书写方式和支持的命令，Docker程序读取DockerFile并根据指令生成Docker镜像，相比手动制作镜像的方式，DockerFile更能直观的展示镜像是怎么产生的，有了DockerFile，当后期有额外的需求时，只要在之前的DockerFile添加或者修改响应的命令即可重新生成新的Docker镜像，避免了重复手动制作镜像的麻烦,类似与shell脚本一样,可以方便高效的制作镜像<br>
</p>

<p>
Docker守护程序 Dockerfile 逐一运行指令，如有必要，将每个指令的结果提交到新镜像，然后最终输出新镜像的ID。Docker守护程序将自动清理之前发送的上下文请注意，每条指令都是独立运行的，并会导致创建新镜像，比如 RUN cd /tmp 对下一条指令不会有任何影响。<br>
</p>

<p>
Docker将尽可能重用中间镜像层（缓存），以显著加速 docker build 命令的执行过程，这由 Using cache 控制台输出中的消息指示<br>
</p>
</div>
</div>
<div id="outline-container-h:02356ca8-57e0-4d0a-91ec-d89808471032" class="outline-5">
<h5 id="h:02356ca8-57e0-4d0a-91ec-d89808471032">Dockerfile 镜像制作和使用流程</h5>
<div class="outline-text-5" id="text-h:02356ca8-57e0-4d0a-91ec-d89808471032">

<figure id="org7bd696d">
<img src="./images/Snipaste_2023-04-27_11-27-46.png" alt="Snipaste_2023-04-27_11-27-46.png"><br>

</figure>
</div>
</div>
<div id="outline-container-h:ce9e6995-b588-4a75-8cc2-c9a1affb0f4b" class="outline-5">
<h5 id="h:ce9e6995-b588-4a75-8cc2-c9a1affb0f4b">Dockerfile文件的制作镜像的分层结构</h5>
<div class="outline-text-5" id="text-h:ce9e6995-b588-4a75-8cc2-c9a1affb0f4b">

<figure id="orgc5b2d2d">
<img src="./images/Snipaste_2023-04-27_11-28-39.png" alt="Snipaste_2023-04-27_11-28-39.png"><br>

</figure>

<p>
范例:<br>
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#25353;&#29031;&#19994;&#21153;&#31867;&#22411;&#25110;&#31995;&#32479;&#31867;&#22411;&#31561;&#26041;&#24335;&#21010;&#20998;&#21019;&#24314;&#30446;&#24405;&#29615;&#22659;&#65292;&#26041;&#20415;&#21518;&#26399;&#38236;&#20687;&#27604;&#36739;&#22810;&#30340;&#26102;&#20505;&#36827;&#34892;&#20998;&#31867;
</span>[root@ubuntu1804 ~]#mkdir /data/dockerfile/{web/{nginx,apache,tomcat,jdk},system/{centos,ubuntu,alpine,debian}} -p
[root@ubuntu1804 ~]#tree /data/dockerfile/
/data/dockerfile
&#9500;&#9472;&#9472; system
&#9474;&#160;&#160; &#9500;&#9472;&#9472; alpine
&#9474;&#160;&#160; &#9500;&#9472;&#9472; centos
&#9474;&#160;&#160; &#9500;&#9472;&#9472; debian
&#9474;&#160;&#160; &#9492;&#9472;&#9472; ubuntu
&#9492;&#9472;&#9472; web
    &#9500;&#9472;&#9472; apache
    &#9500;&#9472;&#9472; jdk
    &#9500;&#9472;&#9472; nginx
    &#9492;&#9472;&#9472; tomcat
10 directories, 0 files
</pre>
</div>
</div>
</div>
<div id="outline-container-h:941e2b50-d59a-47f8-a66f-ec6e084e7729" class="outline-5">
<h5 id="h:941e2b50-d59a-47f8-a66f-ec6e084e7729">Dockerfile 文件格式</h5>
<div class="outline-text-5" id="text-h:941e2b50-d59a-47f8-a66f-ec6e084e7729">
<p>
Dockerfile 是一个有特定语法格式的文本文件<br>
</p>

<p>
dockerfile 官方说明: <a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a><br>
</p>

<p>
帮助: man 5 dockerfile<br>
</p>

<p>
<b>Dockerfile 文件说明</b><br>
</p>
<ul class="org-ul">
<li>每一行以Dockerfile的指令开头，指令不区分大小写，但是惯例使用大写<br></li>
<li>使用 # 开始作为注释<br></li>
<li>每一行只支持一条指令，每条指令可以携带多个参数<br></li>
<li>指令按文件的顺序从上至下进行执行<br></li>
<li>每个指令的执行会生成一个新的镜像层，为了减少分层和镜像大小，尽可能将多条指令合并成一条指令<br></li>
<li>制作镜像一般可能需要反复多次，每次执行dockfile都按顺序执行，从头开始，已经执行过的指令已经缓存，不需要再执行，如果后续有一行新的指令没执行过，其往后的指令将会重新执行，所以为加速镜像制作，将最常变化的内容放下dockerfile的文件的后面<br></li>
</ul>
</div>
</div>
<div id="outline-container-h:5a8f04cf-1897-4a58-a4af-e3e6364dcaec" class="outline-5">
<h5 id="h:5a8f04cf-1897-4a58-a4af-e3e6364dcaec">Dockerfile 相关指令</h5>
<div class="outline-text-5" id="text-h:5a8f04cf-1897-4a58-a4af-e3e6364dcaec">
<p>
dockerfile 文件中的常见指令:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">ADD
COPY
ENV
EXPOSE
FROM
LABEL
STOPSIGNAL
USER
VOLUME
WORKDIR
</pre>
</div>
</div>
<ul class="org-ul">
<li><a id="h:174302d6-2e90-46a0-b273-b34f45963a55"></a>FROM: 指定基础镜像<br>
<div class="outline-text-6" id="text-h:174302d6-2e90-46a0-b273-b34f45963a55">
<p>
定制镜像，需要先有一个基础镜像，在这个基础镜像上进行定制。<br>
</p>

<p>
<b>FROM</b> 就是指定基础镜像，此指令通常必需放在Dockerfile文件第一个非注释行。后续的指令都是运行于此基准镜像所提供的运行环境<br>
</p>

<p>
基础镜像可以是任何可用镜像文件，默认情况下，docker build会在docker主机上查找指定的镜像文件，在其不存在时，则会从Docker Hub Registry上拉取所需的镜像文件.如果找不到指定的镜像文件，docker build会返回一个错误信息<br>
</p>

<p>
<b>如何选择合适的镜像呢？</b><br>
对于不同的软件官方都提供了相关的docker镜像，比如: nginx、redis、mysql、httpd、tomcat等服务类的镜像，也有操作系统类，如: centos、ubuntu、debian等。建议使用官方镜像，比较安全。<br>
</p>

<p>
格式:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">FROM [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]
FROM [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]
FROM [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#35828;&#26126;:
</span>--platform &#25351;&#23450;&#38236;&#20687;&#30340;&#24179;&#21488;&#65292;&#27604;&#22914;: linux/amd64, linux/arm64, or windows/amd64
tag &#21644; digest&#26159;&#21487;&#36873;&#39033;&#65292;&#22914;&#26524;&#19981;&#25351;&#23450;&#65292;&#40664;&#35748;&#20026;latest
</pre>
</div>

<p>
<b>说明: 关于scratch 镜像</b><br>
</p>
<div class="org-src-container">
<pre class="src src-shell">FROM scratch
&#21442;&#32771;&#38142;&#25509;:
https://hub.docker.com/_/scratch?<span style="color: #a0522d;">tab</span>=description
https://docs.docker.com/develop/develop-images/baseimages/
&#35813;&#38236;&#20687;&#26159;&#19968;&#20010;&#31354;&#30340;&#38236;&#20687;&#65292;&#21487;&#20197;&#29992;&#20110;&#26500;&#24314;busybox&#31561;&#36229;&#23567;&#38236;&#20687;&#65292;&#21487;&#20197;&#35828;&#26159;&#30495;&#27491;&#30340;&#20174;&#38646;&#24320;&#22987;&#26500;&#24314;&#23646;&#20110;&#33258;&#24049;&#30340;&#38236;&#20687;
&#35813;&#38236;&#20687;&#22312;&#26500;&#24314;&#22522;&#30784;&#38236;&#20687;&#65288;&#20363;&#22914;debian&#21644;busybox&#65289;&#25110;&#36229;&#26368;&#23567;&#38236;&#20687;&#65288;&#20165;&#21253;&#21547;&#19968;&#20010;&#20108;&#36827;&#21046;&#25991;&#20214;&#21450;&#20854;&#25152;&#38656;&#20869;&#23481;&#65292;&#20363;&#22914;:hello-world&#65289;&#30340;&#19978;&#19979;&#25991;&#20013;&#26368;&#26377;&#29992;&#12290;
</pre>
</div>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">FROM scratch <span style="color: #b22222;">#</span><span style="color: #b22222;">&#25152;&#26377;&#38236;&#20687;&#30340;&#36215;&#28304;&#38236;&#20687;&#65292;&#30456;&#24403;&#20110;Object&#31867;
</span>FROM ubuntu
FROM ubuntu:bionic
FROM debian:buster-slim
</pre>
</div>
</div>
</li>
<li><a id="h:ab04a7fa-00ca-4c23-89fc-f96fa3dc96f2"></a>LABEL: 指定镜像元数据<br>
<div class="outline-text-6" id="text-h:ab04a7fa-00ca-4c23-89fc-f96fa3dc96f2">
<p>
可以指定镜像元数据，如: 镜像作者等<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...
</pre>
</div>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">LABEL <span style="color: #8b2252;">"com.example.vendor"</span>=<span style="color: #8b2252;">"ACME Incorporated"</span>
LABEL com.example.label-with-value=<span style="color: #8b2252;">"foo"</span>
LABEL <span style="color: #a0522d;">version</span>=<span style="color: #8b2252;">"1.0"</span>
LABEL <span style="color: #a0522d;">description</span>=<span style="color: #8b2252;">"This text illustrates \
that label-values can span multiple lines."</span>
</pre>
</div>

<p>
一个镜像可以有多个label ,还可以写在一行中,即多标签写法,可以减少镜像的的大小<br>
</p>

<p>
范例: 多标签写法<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#19968;&#34892;&#26684;&#24335;
</span>LABEL multi.label1=<span style="color: #8b2252;">"value1"</span> multi.label2=<span style="color: #8b2252;">"value2"</span> <span style="color: #a0522d;">other</span>=<span style="color: #8b2252;">"value3"</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#22810;&#34892;&#26684;&#24335;
</span>LABEL multi.label1=<span style="color: #8b2252;">"value1"</span> <span style="color: #8b2252;">\</span>
multi.label2=<span style="color: #8b2252;">"value2"</span> <span style="color: #8b2252;">\</span>
<span style="color: #a0522d;">other</span>=<span style="color: #8b2252;">"value3"</span>
</pre>
</div>
<p>
docker inspect 命令可以查看LABEL<br>
</p>

<p>
MAINTAINER: 指定维护者信息<br>
此指令已过时，用LABEL代替<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">MAINTAINER &lt;name&gt;
</pre>
</div>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">MAINTAINER xxx <a href="mailto:root%40xxx.com">&lt;root@xxx.com&gt;</a>
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#29992;LABEL&#20195;&#26367;
</span>LABEL <span style="color: #a0522d;">maintainer</span>=<span style="color: #8b2252;">"xxx <a href="mailto:root%40xxx.com">&lt;root@xxx.com&gt;</a>"</span>
</pre>
</div>
</div>
</li>
<li><a id="h:d5261f2e-1682-4195-a95a-6c0b6a030249"></a>RUN: 执行 shell命令<br>
<div class="outline-text-6" id="text-h:d5261f2e-1682-4195-a95a-6c0b6a030249">
<p>
RUN 指令用来在构建镜像阶段需要执行 FROM 指定镜像所支持的Shell命令。<br>
</p>

<p>
通常各种基础镜像一般都支持丰富的shell命令<br>
</p>

<p>
注意: RUN 可以写多个，每一个RUN指令都会建立一个镜像层，所以尽可能合并成一条指令,比如将多个shell命令通过 &amp;&amp; 连接一起成为在一条指令<br>
</p>

<p>
每个RUN都是独立运行的,和前一个RUN无关<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">shell &#26684;&#24335;: &#30456;&#24403;&#20110; /bin/sh -c &lt;&#21629;&#20196;&gt; &#27492;&#31181;&#24418;&#24335;&#25903;&#25345;&#29615;&#22659;&#21464;&#37327;
</span>RUN &lt;&#21629;&#20196;&gt;

<span style="color: #b22222;">#</span><span style="color: #b22222;">exec &#26684;&#24335;: &#27492;&#31181;&#24418;&#24335;&#19981;&#25903;&#25345;&#29615;&#22659;&#21464;&#37327;,&#27880;&#24847;:&#26159;&#21452;&#24341;&#21495;,&#19981;&#33021;&#26159;&#21333;&#24341;&#21495;
</span>RUN [<span style="color: #8b2252;">"&#21487;&#25191;&#34892;&#25991;&#20214;"</span>, <span style="color: #8b2252;">"&#21442;&#25968;1"</span>, <span style="color: #8b2252;">"&#21442;&#25968;2"</span>]

<span style="color: #b22222;">#</span><span style="color: #b22222;">exec&#26684;&#24335;&#21487;&#20197;&#25351;&#23450;&#20854;&#23427;shell
</span>RUN [<span style="color: #8b2252;">"/bin/bash"</span>,<span style="color: #8b2252;">"-c"</span>,<span style="color: #8b2252;">"echo hello user1"</span>]
</pre>
</div>

<p>
说明:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">shell&#26684;&#24335;&#20013;&#65292;&lt;command&gt;&#36890;&#24120;&#26159;&#19968;&#20010;shell&#21629;&#20196;&#65292;&#19988;&#20197;<span style="color: #8b2252;">"/bin/sh -c&#8221;&#26469;&#36816;&#34892;&#23427;&#65292;&#36825;&#24847;&#21619;&#30528;&#27492;&#36827;&#31243;&#22312;&#23481;&#22120;&#20013;&#30340;PID&#19981;&#20026;1&#65292;&#19981;&#33021;&#25509;&#25910;Unix&#20449;&#21495;&#65292;&#22240;&#27492;&#65292;&#24403;&#20351;&#29992;docker stop &lt;container&gt;&#21629;&#20196;&#20572;&#27490;&#23481;&#22120;&#26102;&#65292;&#27492;&#36827;&#31243;&#25509;&#25910;&#19981;&#21040;SIGTERM&#20449;&#21495;

exec&#26684;&#24335;&#20013;&#30340;&#21442;&#25968;&#26159;&#19968;&#20010;JSON&#26684;&#24335;&#30340;&#25968;&#32452;&#65292;&#20854;&#20013;&lt;executable&gt;&#20026;&#35201;&#36816;&#34892;&#30340;&#21629;&#20196;&#65292;&#21518;&#38754;&#30340;&lt;paramN&gt;&#20026;&#20256;&#36882;&#32473;&#21629;&#20196;&#30340;&#36873;&#39033;&#25110;&#21442;&#25968;;&#28982;&#32780;&#65292;&#27492;&#31181;&#26684;&#24335;&#25351;&#23450;&#30340;&#21629;&#20196;&#19981;&#20250;&#20197;"</span>/bin/sh -c<span style="color: #8b2252;">"&#26469;&#21457;&#36215;&#65292;&#22240;&#27492;&#24120;&#35265;&#30340;shell&#25805;&#20316;&#22914;&#21464;&#37327;&#26367;&#25442;&#20197;&#21450;&#36890;&#37197;&#31526;(?,*&#31561;)&#26367;&#25442;&#23558;&#19981;&#20250;&#36827;&#34892;;&#19981;&#36807;&#65292;&#22914;&#26524;&#35201;&#36816;&#34892;&#30340;&#21629;&#20196;&#20381;&#36182;&#20110;&#27492;shell&#29305;&#24615;&#30340;&#35805;&#65292;&#21487;&#20197;&#23558;&#20854;&#26367;&#25442;&#20026;&#31867;&#20284;&#19979;&#38754;&#30340;&#26684;&#24335;&#12290;
RUN ["</span>/bin/bash<span style="color: #8b2252;">", "</span>-c<span style="color: #8b2252;">", "</span>&lt;executable&gt;<span style="color: #8b2252;">", "</span>&lt;param1&gt;<span style="color: #8b2252;">"]</span>
</pre>
</div>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">RUN echo <span style="color: #8b2252;">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html
RUN [<span style="color: #8b2252;">"/bin/bash"</span>, <span style="color: #8b2252;">"-c"</span>, <span style="color: #8b2252;">"echo hello world"</span>]
RUN yum -y install epel-release <span style="color: #8b2252;">\</span>
      &amp;&amp; yum -y install nginx <span style="color: #8b2252;">\</span>
      &amp;&amp; rm -rf /usr/share/nginx/html/*
      &amp;&amp; <span style="color: #483d8b;">echo</span> <span style="color: #8b2252;">"&lt;h1&gt; docker test nginx &lt;/h1&gt;"</span> &gt; /usr/share/nginx/html/index.html
</pre>
</div>

<p>
范例: 多个 前后RUN 命令独立无关和shell命令不同<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">world.txt&#24182;&#19981;&#23384;&#25918;&#22312;/app&#20869;
</span>RUN cd /app
RUN echo <span style="color: #8b2252;">"hello"</span> &gt; world.txt
</pre>
</div>
</div>
</li>
<li><a id="h:d317f964-9de4-4b4b-8f05-8acd992b2f08"></a>ENV: 设置环境变量<br>
<div class="outline-text-6" id="text-h:d317f964-9de4-4b4b-8f05-8acd992b2f08">
<p>
ENV 可以定义环境变量和值，会被后续指令(如:ENV,ADD,COPY,RUN等)通过\(KEY或\){KEY}进行引用，并在容器运行时保持<br>
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#21464;&#37327;&#36171;&#20540;&#26684;&#24335;1
</span>ENV &lt;key&gt; &lt;value&gt; <span style="color: #b22222;">#</span><span style="color: #b22222;">&#27492;&#26684;&#24335;&#21482;&#33021;&#23545;&#19968;&#20010;key&#36171;&#20540;,&lt;key&gt;&#20043;&#21518;&#30340;&#25152;&#26377;&#20869;&#23481;&#22343;&#20250;&#34987;&#35270;&#20316;&#20854;&lt;value&gt;&#30340;&#32452;&#25104;&#37096;&#20998;
</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21464;&#37327;&#36171;&#20540;&#26684;&#24335;2
</span>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt; <span style="color: #8b2252;">\ </span>#&#27492;&#26684;&#24335;&#21487;&#20197;&#25903;&#25345;&#22810;&#20010;key&#36171;&#20540;,&#23450;&#20041;&#22810;&#20010;&#21464;&#37327;&#24314;&#35758;&#20351;&#29992;,&#20943;&#23569;&#38236;&#20687;&#23618;
    &lt;key3&gt;=&lt;value3&gt; ...

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#22914;&#26524;&lt;value&gt;&#20013;&#21253;&#21547;&#31354;&#26684;&#65292;&#21487;&#20197;&#20197;&#21453;&#26012;&#32447;\&#36827;&#34892;&#36716;&#20041;&#65292;&#20063;&#21487;&#36890;&#36807;&#23545;&lt;value&gt;&#21152;&#24341;&#21495;&#36827;&#34892;&#26631;&#35782;;&#21478;&#22806;&#65292;&#21453;&#26012;&#32447;&#20063;&#21487;&#29992;&#20110;&#32493;&#34892;
</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21482;&#20351;&#29992;&#19968;&#27425;&#21464;&#37327;
</span>RUN &lt;key&gt;=&lt;value&gt; &lt;command&gt;

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#24341;&#29992;&#21464;&#37327;
</span>RUN $<span style="color: #a0522d;">key</span> .....

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21464;&#37327;&#25903;&#25345;&#39640;&#32423;&#36171;&#20540;&#26684;&#24335;
</span>${<span style="color: #a0522d;">key</span>:-word}
${<span style="color: #a0522d;">kye</span>:+word}
</pre>
</div>

<p>
如果运行容器时如果需要修改变量,可以执行下面通过基于 exec 机制实现<br>
</p>

<p>
注意: 下面方式只影响容器运行时环境,而不影响构建镜像的过程,即只能覆盖docker run时的环境变量,而不会影响docker build时环境变量的值<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker run -e|--env &lt;key&gt;=&lt;value&gt;

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#35828;&#26126;
</span>-e, --env list <span style="color: #b22222;">#</span><span style="color: #b22222;">Set environment variables
</span>--env-file filename <span style="color: #b22222;">#</span><span style="color: #b22222;">Read in a file of environment variables&#33539;&#20363;:</span>
</pre>
</div>

<p>
示例: 两种格式功能相同<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#26684;&#24335;1
</span>ENV <span style="color: #a0522d;">myName</span>=<span style="color: #8b2252;">"John Doe"</span> <span style="color: #a0522d;">myDog</span>=Rex<span style="color: #8b2252;">\ </span>The<span style="color: #8b2252;">\ </span>Dog <span style="color: #8b2252;">\</span>
    <span style="color: #a0522d;">myCat</span>=fluffy

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26684;&#24335;2
</span>ENV myName John Doe
ENV myDog Rex The Dog
ENV myCat fluffy
</pre>
</div>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">ENV <span style="color: #a0522d;">VERSION</span>=1.0 <span style="color: #a0522d;">DEBUG</span>=on <span style="color: #a0522d;">NAME</span>=<span style="color: #8b2252;">"Happy Feet"</span>
ENV PG_MAJOR 9.3
ENV PG_VERSION 9.3.4
RUN curl -SL http://example.com/postgres-$<span style="color: #a0522d;">PG_VERSION</span>.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; &#8230;
ENV PATH /usr/local/postgres-$<span style="color: #a0522d;">PG_MAJOR</span>/bin:$<span style="color: #a0522d;">PATH</span>
</pre>
</div>

<p>
范例：<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 dockerfile]#cat Dockerfile
FROM busybox
LABEL <span style="color: #a0522d;">maintainer</span>=<span style="color: #8b2252;">"xxx <a href="mailto:root%40xxx.com">&lt;root@xxx.com&gt;</a>"</span>
ENV NAME user1 
RUN touch $<span style="color: #a0522d;">NAME</span>.txt

[root@ubuntu1804 dockerfile]#cat build.sh
<span style="color: #b22222;">#</span><span style="color: #b22222;">!/bin/bash
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">
</span><span style="color: #a0522d;">TAG</span>=$<span style="color: #a0522d;">1</span>
docker build -t test:$<span style="color: #a0522d;">TAG</span> .

[root@ubuntu1804 dockerfile]#./build.sh v5.0

[root@ubuntu1804 dockerfile]#docker run --rm --name c1 test:v5.0 env
<span style="color: #a0522d;">PATH</span>=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
<span style="color: #a0522d;">HOSTNAME</span>=d4e1f89aca71
<span style="color: #a0522d;">NAME</span>=user1 cici
<span style="color: #a0522d;">HOME</span>=/root

[root@ubuntu1804 dockerfile]#docker run --rm -e <span style="color: #a0522d;">NAME</span>=cici --name c1 test:v5.0 env
<span style="color: #a0522d;">PATH</span>=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
<span style="color: #a0522d;">HOSTNAME</span>=b23500aa100d
<span style="color: #a0522d;">NAME</span>=cici
<span style="color: #a0522d;">HOME</span>=/root

</pre>
</div>
</div>
</li>
<li><a id="h:360504fb-e662-46cc-9fd4-6173f8365bb0"></a>COPY: 复制文本<br>
<div class="outline-text-6" id="text-h:360504fb-e662-46cc-9fd4-6173f8365bb0">
<p>
复制本地宿主机的 到容器中的 。<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;
COPY [--chown=&lt;user&gt;:&lt;group&gt;] [<span style="color: #8b2252;">"&lt;src&gt;"</span>,... <span style="color: #8b2252;">"&lt;dest&gt;"</span>] <span style="color: #b22222;">#</span><span style="color: #b22222;">&#36335;&#24452;&#20013;&#26377;&#31354;&#30333;&#23383;&#31526;&#26102;,&#24314;&#35758;&#20351;&#29992;&#27492;&#26684;&#24335;</span>
</pre>
</div>

<p>
说明:<br>
</p>
<ul class="org-ul">
<li>可以是多个,可以使用通配符，通配符规则满足Go的filepath.Match 规则filepath.Match 参考链接: <a href="https://golang.org/pkg/path/filepath/#Match">https://golang.org/pkg/path/filepath/#Match</a><br></li>
<li>必须是build上下文中的路径(为 Dockerfile 所在目录的相对路径）， <b>不能是其父目录中的文件</b> <br></li>
<li>如果是目录，则其内部文件或子目录会被递归复制， <b>但目录自身不会被复制</b><br></li>
<li>如果指定了多个, 或在中使用了通配符，则必须是一个目录， <b>且必须以 / 结尾</b><br></li>
<li>可以是绝对路径或者是 WORKDIR 指定的相对路径<br></li>
<li>使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等<br></li>
<li>如果事先不存在，它将会被自动创建，这包括其父目录路径,即递归创建目录<br></li>
</ul>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">COPY hom* /mydir/
COPY hom?.txt /mydir/
</pre>
</div>
</div>
</li>
<li><a id="h:e4789daf-0d47-4775-b923-4760cef7179b"></a>ADD: 复制和解包文件<br>
<div class="outline-text-6" id="text-h:e4789daf-0d47-4775-b923-4760cef7179b">
<p>
该命令可认为是增强版的COPY，不仅支持COPY，还支持自动解缩。可以将复制指定的 到容器中的<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;
ADD [--chown=&lt;user&gt;:&lt;group&gt;] [<span style="color: #8b2252;">"&lt;src&gt;"</span>,... <span style="color: #8b2252;">"&lt;dest&gt;"</span>]&#22914;&#26524;&#26159;&#30446;&#24405;&#65292;&#21482;&#22797;&#21046;&#30446;&#24405;&#20013;&#30340;&#20869;&#23481;&#65292;&#32780;&#38750;&#30446;&#24405;&#26412;&#36523;
</pre>
</div>

<p>
说明:<br>
</p>
<ul class="org-ul">
<li>可以是Dockerfile所在目录的一个相对路径；也可是一个 URL；还可是一个 tar 文件（自动解压）<br></li>
<li>可以是绝对路径或者是 WORKDIR 指定的相对路径<br></li>
<li>如果是一个 URL ，下载后的文件权限自动设置为 600<br></li>
<li>如果为URL且不以/结尾，则指定的文件将被下载并直接被创建为,如果以 / 结尾，则文件名URL指定的文件将被直接下载并保存为/&lt; filename&gt;<br></li>
<li>如果是一个本地文件系统上的打包文件,如: gz, bz2 ,xz ，它将被解包 ，其行为类似于"tar -x"命令,但是通过URL获取到的tar文件将不会自动展开<br></li>
<li>如果有多个，或其间接或直接使用了通配符，则必须是一个以/结尾的目录路径;如果不以/结尾，则其被视作一个普通文件，的内容将被直接写入到<br></li>
</ul>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">ADD test relativeDir/ <span style="color: #b22222;"># </span><span style="color: #b22222;">adds "test" to `WORKDIR`/relativeDir/
</span>ADD test /absoluteDir/ <span style="color: #b22222;"># </span><span style="color: #b22222;">adds "test" to /absoluteDir/
</span>ADD --chown=55:mygroup files* /somedir/
ADD --chown=bin files* /somedir/
ADD --chown=1 files* /somedir/
ADD --chown=10:11 files* /somedir/
ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /
</pre>
</div>
</div>
</li>
<li><a id="h:c211282a-1215-4af9-be1f-d37fae4de20c"></a>CMD: 容器启动命令<br>
<div class="outline-text-6" id="text-h:c211282a-1215-4af9-be1f-d37fae4de20c">
<p>
一个容器中需要持续运行的进程一般只有一个,CMD 用来指定启动容器时默认执行的一个命令，且其运行结束后,容器也会停止,所以一般CMD 指定的命令为持续运行且为前台命令.<br>
</p>

<ul class="org-ul">
<li>如果docker run没有指定任何的执行命令或者dockerfile里面也没有ENTRYPOINT，那么开启容器时就会使用执行CMD指定的默认的命令<br></li>
<li>前面介绍过的 RUN 命令是在构建镜像进执行的命令,注意二者的不同之处<br></li>
<li>每个 Dockerfile 只能有一条 CMD 命令。如指定了多条，只有最后一条被执行<br></li>
<li>如果用户启动容器时用 docker run xxx 指定运行的命令，则会覆盖 CMD 指定的命令<br></li>
<li>如果 Dockerfile 中有 ENTRYPOINT 命令，CMD 充当其默认参数<br></li>
</ul>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;"># </span><span style="color: #b22222;">&#20351;&#29992; exec &#25191;&#34892;&#65292;&#25512;&#33616;&#26041;&#24335;&#65292;&#31532;&#19968;&#20010;&#21442;&#25968;&#24517;&#39035;&#26159;&#21629;&#20196;&#30340;&#20840;&#36335;&#24452;,&#27492;&#31181;&#24418;&#24335;&#19981;&#25903;&#25345;&#29615;&#22659;&#21464;&#37327;
</span>CMD [<span style="color: #8b2252;">"executable"</span>,<span style="color: #8b2252;">"param1"</span>,<span style="color: #8b2252;">"param2"</span>]

<span style="color: #b22222;"># </span><span style="color: #b22222;">&#22312; /bin/sh &#20013;&#25191;&#34892;&#65292;&#25552;&#20379;&#32473;&#38656;&#35201;&#20132;&#20114;&#30340;&#24212;&#29992;&#65307;&#27492;&#31181;&#24418;&#24335;&#25903;&#25345;&#29615;&#22659;&#21464;&#37327;
</span>CMD command param1 param2

<span style="color: #b22222;"># </span><span style="color: #b22222;">&#25552;&#20379;&#32473; ENTRYPOINT &#21629;&#20196;&#30340;&#40664;&#35748;&#21442;&#25968;
</span>CMD [<span style="color: #8b2252;">"param1"</span>,<span style="color: #8b2252;">"param2"</span>]
</pre>
</div>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">CMD [<span style="color: #8b2252;">"nginx"</span>, <span style="color: #8b2252;">"-g"</span>, <span style="color: #8b2252;">"daemon off;"</span>]
</pre>
</div>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">cat Dockerfile

FROM ubuntu:18.04
LABEL <span style="color: #a0522d;">maintainer</span>=<span style="color: #8b2252;">"xxx <a href="mailto:root%40xxx.com">&lt;root@xxx.com&gt;</a>"</span>
RUN apt update <span style="color: #8b2252;">\</span>
&amp;&amp; apt -y install curl <span style="color: #8b2252;">\</span>
&amp;&amp; rm -rf /var/lib/apt/lists/*
CMD [ <span style="color: #8b2252;">"curl"</span>, <span style="color: #8b2252;">"-s"</span>,<span style="color: #8b2252;">"https://ip.cn"</span>]
[root@centos8 ubuntu]#podman run 9b
{<span style="color: #8b2252;">"ip"</span>: <span style="color: #8b2252;">"111.199.187.36"</span>, <span style="color: #8b2252;">"country"</span>: <span style="color: #8b2252;">"&#21271;&#20140;&#24066;"</span>, <span style="color: #8b2252;">"city"</span>: <span style="color: #8b2252;">"&#32852;&#36890;"</span>}

<span style="color: #b22222;">#</span><span style="color: #b22222;">cat /etc/etc/issue&#35206;&#30422;&#20102;curl&#21629;&#20196;
</span>[root@centos8 ubuntu]#podman run 9b cat /etc/issue
Ubuntu 18.04.4 LTS \n \l
</pre>
</div>
</div>
</li>
<li><a id="h:6b08e5ec-70d7-4e61-aa70-affe970b448e"></a>ENTRYPOINT: 入口点<br>
<div class="outline-text-6" id="text-h:6b08e5ec-70d7-4e61-aa70-affe970b448e">
<p>
功能类似于CMD，配置容器启动后执行的命令及参数<br>
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;"># </span><span style="color: #b22222;">&#20351;&#29992; exec &#25191;&#34892;
</span>ENTRYPOINT [<span style="color: #8b2252;">"executable"</span>, <span style="color: #8b2252;">"param1"</span>, <span style="color: #8b2252;">"param2"</span>]

<span style="color: #b22222;"># </span><span style="color: #b22222;">shell&#20013;&#25191;&#34892;
</span>ENTRYPOINT command param1 param2
</pre>
</div>

<ul class="org-ul">
<li>ENTRYPOINT 不能被 docker run 提供的参数覆盖，而是追加,即如果docker run 命令有参数，那么参数全部都会作为ENTRYPOINT的参数<br></li>
<li>如果docker run 后面没有额外参数，但是dockerfile中的CMD里有（即上面CMD的第三种用法），即Dockerfile中即有CMD也有ENTRYPOINT,那么CMD的全部内容会作为ENTRYPOINT的参数<br></li>
<li>如果docker run 后面有额外参数，同时Dockerfile中即有CMD也有ENTRYPOINT,那么docker run后面的参数覆盖掉CMD参数内容,最终作为ENTRYPOINT的参数<br></li>
<li>可以通过docker run &#x2013;entrypoint string 参数在运行时替换,注意string不要加空格<br></li>
<li>使用CMD要在运行时重新写命令本身,然后在后面才能追加运行参数，ENTRYPOINT则可以运行时无需重写命令就可以直接接受新参数<br></li>
<li>每个 Dockerfile 中只能有一个 ENTRYPOINT，当指定多个时，只有最后一个生效<br></li>
</ul>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker run -it --entrypoint cat alpine /etc/issue
Welcome to Alpine Linux 3.12
Kernel \r on an \m (\l)

[root@ubuntu1804 dockerfile]#cat Dockerfile
FROM ubuntu:18.04
RUN apt update <span style="color: #8b2252;">\</span>
&amp;&amp; apt -y install curl <span style="color: #8b2252;">\</span>
&amp;&amp; rm -rf /var/lib/apt/lists/*
ENTRYPOINT [ <span style="color: #8b2252;">"curl"</span>, <span style="color: #8b2252;">"-s"</span>,<span style="color: #8b2252;">"https://ip.cn"</span>]

[root@centos8 dockerfile]#podman run -it --rm f68e006
{<span style="color: #8b2252;">"ip"</span>: <span style="color: #8b2252;">"111.199.187.36"</span>, <span style="color: #8b2252;">"country"</span>: <span style="color: #8b2252;">"&#21271;&#20140;&#24066;"</span>, <span style="color: #8b2252;">"city"</span>: <span style="color: #8b2252;">"&#32852;&#36890;"</span>}

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#36861;&#21152;-i&#21442;&#25968;
</span>[root@centos8 dockerfile]#podman run -it --rm f68e006 -i
HTTP/2 200
date: Sun, 23 Feb 2020 08:05:19 GMT
content-type: application/json; <span style="color: #a0522d;">charset</span>=UTF-8
set-cookie: <span style="color: #a0522d;">__cfduid</span>=d4a22496ea6f3b2861763354f8ca600711582445119; <span style="color: #a0522d;">expires</span>=Tue,
24-Mar-20 08:05:19 GMT; <span style="color: #a0522d;">path</span>=/; <span style="color: #a0522d;">domain</span>=.ip.cn; HttpOnly; <span style="color: #a0522d;">SameSite</span>=Lax
cf-cache-status: DYNAMIC
expect-ct: max-age=604800, report-uri=<span style="color: #8b2252;">"https://report-uri.cloudflare.com/cdncgi/beacon/expect-ct"</span>
alt-svc: h3-25=<span style="color: #8b2252;">":443"</span>; <span style="color: #a0522d;">ma</span>=86400, h3-24=<span style="color: #8b2252;">":443"</span>; <span style="color: #a0522d;">ma</span>=86400, h3-23=<span style="color: #8b2252;">":443"</span>; <span style="color: #a0522d;">ma</span>=86400
server: cloudflare
cf-ray: 5697b1ac1862eb41-LAX

{<span style="color: #8b2252;">"ip"</span>: <span style="color: #8b2252;">"111.199.187.36"</span>, <span style="color: #8b2252;">"country"</span>: <span style="color: #8b2252;">"&#21271;&#20140;&#24066;"</span>, <span style="color: #8b2252;">"city"</span>: <span style="color: #8b2252;">"&#32852;&#36890;"</span>}
</pre>
</div>

<p>
范例: 利用脚本实现指定环境变量动态生成配置文件内容<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#echo <span style="color: #8b2252;">'Nginx Website in Dockerfile'</span> &gt; index.html
[root@ubuntu1804 ~]#cat Dockerfile
FROM nginx:1.16-alpine
LABEL <span style="color: #a0522d;">maintainer</span>=<span style="color: #8b2252;">"xxx <a href="mailto:root%40xxx.com">&lt;root@xxx.com&gt;</a>"</span>
ENV <span style="color: #a0522d;">DOC_ROOT</span>=<span style="color: #8b2252;">'/data/website/'</span>
ADD index.html ${<span style="color: #a0522d;">DOC_ROOT</span>}
ADD entrypoint.sh /bin/
EXPOSE 80/tcp 8080
<span style="color: #b22222;">#</span><span style="color: #b22222;">HEALTHCHECK --start-period=3s CMD wget -0 - -q http://${IP:-0.0.0.0}:
</span>{PORT:-80}/
CMD [<span style="color: #8b2252;">"/usr/sbin/nginx"</span>,<span style="color: #8b2252;">"-g"</span>, <span style="color: #8b2252;">"daemon off;"</span>] <span style="color: #b22222;">#</span><span style="color: #b22222;">CMD&#25351;&#20196;&#30340;&#20869;&#23481;&#37117;&#25104;&#20026;&#20102;ENTRYPOINT&#30340;&#21442;&#25968;
</span>ENTRYPOINT [ <span style="color: #8b2252;">"/bin/entrypoint.sh"</span>]

[root@ubuntu1804 ~]#cat entrypoint.sh
<span style="color: #b22222;">#</span><span style="color: #b22222;">!/bin/sh
</span>cat &gt; /etc/nginx/conf.d/www.conf &lt;&lt;EOF<span style="color: #ffa54f;">
server {
server_name ${HOSTNAME};
listen ${IP:-0.0.0.0}:${PORT:-80};
root ${DOC_ROOT:-/usr/share/nginx/html};
}
EOF
</span><span style="color: #a020f0;">exec</span> <span style="color: #8b2252;">"$@"</span>

[root@ubuntu1804 ~]#chmod +x entrypoint.sh
[root@ubuntu1804 ~]#docker build -t nginx:v1.0 .
[root@ubuntu1804 ~]#docker run --name n1 --rm -P -e <span style="color: #8b2252;">"PORT=8080"</span> -e
<span style="color: #8b2252;">"HOSTNAME=www.xxx.org"</span> nginx:v1.0
</pre>
</div>
</div>
</li>
<li><a id="h:8c4e6068-fbbd-4a6d-b777-77bf1a3369bd"></a>ARG: 构建参数<br>
<div class="outline-text-6" id="text-h:8c4e6068-fbbd-4a6d-b777-77bf1a3369bd">
<p>
ARG指令在build 阶段指定变量,和ENV不同的是，容器运行时不会存在这些环境变量<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">ARG &lt;name&gt;[=&lt;default value&gt;]&#35828;&#26126;: ARG &#21644; FROM
</pre>
</div>

<p>
如果和ENV同名，ENV覆盖ARG变量<br>
</p>

<p>
可以用 docker build &#x2013;build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖<br>
</p>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#cat Dockerfile
FROM busybox
ARG <span style="color: #a0522d;">author</span>=<span style="color: #8b2252;">"user1 <a href="mailto:root%40xxx.com">&lt;root@xxx.com&gt;</a>"</span>
LABEL <span style="color: #a0522d;">maintainer</span>=<span style="color: #8b2252;">"${author}"</span>

[root@ubuntu1804 ~]#docker build --build-arg <span style="color: #a0522d;">author</span>=<span style="color: #8b2252;">"xxx@qq.com"</span> -t busybox:v1.0 .
</pre>
</div>

<p>
说明：ARG 和 FROM<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">FROM&#25351;&#20196;&#25903;&#25345;&#30001;&#31532;&#19968;&#20010;FROM&#20043;&#21069;&#30340;&#20219;&#20309;ARG&#25351;&#20196;&#22768;&#26126;&#30340;&#21464;&#37327;
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">&#31034;&#20363;:
</span>ARG <span style="color: #a0522d;">CODE_VERSION</span>=latest
FROM base:${<span style="color: #a0522d;">CODE_VERSION</span>}
CMD /code/run-app
FROM extras:${<span style="color: #a0522d;">CODE_VERSION</span>}
CMD /code/run-extras

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#22312;FROM&#20043;&#21069;&#22768;&#26126;&#30340;ARG&#22312;&#26500;&#24314;&#38454;&#27573;&#20043;&#22806;&#65292;&#25152;&#20197;&#23427;&#19981;&#33021;&#22312;FROM&#20043;&#21518;&#30340;&#20219;&#20309;&#25351;&#20196;&#20013;&#20351;&#29992;&#12290; &#35201;&#20351;&#29992;&#22312;&#31532;&#19968;&#20010;FROM&#20043;&#21069;&#22768;&#26126;&#30340;ARG&#30340;&#40664;&#35748;&#20540;&#65292;&#35831;&#22312;&#26500;&#24314;&#38454;&#27573;&#20869;&#20351;&#29992;&#27809;&#26377;&#20540;&#30340;ARG&#25351;&#20196;
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">&#31034;&#20363;:
</span>ARG <span style="color: #a0522d;">VERSION</span>=latest
FROM busybox:$<span style="color: #a0522d;">VERSION</span>
ARG VERSION
RUN echo $<span style="color: #a0522d;">VERSION</span> &gt; image_version
</pre>
</div>
</div>
</li>
<li><a id="h:c2ddda28-e0bb-4c80-8ecd-7f569a1206e4"></a>VOLUME: 匿名卷<br>
<div class="outline-text-6" id="text-h:c2ddda28-e0bb-4c80-8ecd-7f569a1206e4">
<p>
在容器中创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等，一般会将宿主机上的目录挂载至VOLUME 指令指定的容器目录。即使容器后期被删除，此宿主机的目录仍会保留，从而实现容器数据的持久保存。<br>
</p>

<p>
宿主机目录为<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">/var/lib/docker/volumes/&lt;volume_id&gt;/_data
</pre>
</div>

<p>
语法:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">VOLUME &lt;&#23481;&#22120;&#20869;&#36335;&#24452;&gt;
VOLUME [<span style="color: #8b2252;">"&lt;&#23481;&#22120;&#20869;&#36335;&#24452;1&gt;"</span>, <span style="color: #8b2252;">"&lt;&#23481;&#22120;&#20869;&#36335;&#24452;2&gt;"</span>...]
</pre>
</div>

<p>
注意:<br>
</p>
<ul class="org-ul">
<li>Dockerfile中的VOLUME实现的是匿名数据卷,无法指定宿主机路径和容器目录的挂载关系<br></li>
<li>通过docker rm -fv &lt;容器ID&gt; 可以删除容器的同时删除VOLUME指定的卷<br></li>
</ul>

<p>
范例: 在容器创建两个/data/ ,/data2的挂载点<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">VOLUME [ <span style="color: #8b2252;">"/data1"</span>,<span style="color: #8b2252;">"/data2"</span> ]
</pre>
</div>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@centos8 ~]#cat /data/dockerfile/system/alpine/Dockerfile
FROM alpine:3.11
LABEL <span style="color: #a0522d;">maintainer</span>=<span style="color: #8b2252;">"xxx <a href="mailto:root%40xxx.com">&lt;root@xxx.com&gt;</a>"</span>
COPY repositories /etc/apk/repositories
VOLUME [ <span style="color: #8b2252;">"/testdata"</span>,<span style="color: #8b2252;">"/testdata2"</span> ]

[root@centos8 alpine]#podman run -it --rm 8ef61dd3959da3f sh
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">df
</span>Filesystem 1K-blocks Used Available Use% Mounted on
overlay 104806400 3656380 101150020 3% /
tmpfs 65536 0 65536 0% /dev
/dev/sda2 104806400 3656380 101150020 3% /testdata2
/dev/sda2 104806400 3656380 101150020 3% /testdata

/ <span style="color: #b22222;"># </span><span style="color: #b22222;">cp /etc/issue /testdata/f1.txt
</span>/ <span style="color: #b22222;"># </span><span style="color: #b22222;">cp /etc/issue /testdata2/f2.txt
</span>
[root@centos8 ~]#tree /var/lib/containers/storage/volumes/
/var/lib/containers/storage/volumes/
&#9500;&#9472;&#9472; 725f0f67921bdbffbe0aaf9b015d663a6e3ddd24674990d492025dfcf878529b
&#9474; &#9492;&#9472;&#9472; _data
&#9474;     &#9492;&#9472;&#9472; f1.txt
&#9492;&#9472;&#9472; fbd13e5253deb375e0dea917df832d2322e96b04ab43bae061584dcdbe7e89f2
   &#9492;&#9472;&#9472; _data
      &#9492;&#9472;&#9472; f2.txt
</pre>
</div>
</div>
</li>
<li><a id="h:1e7a7d85-499d-4599-af3d-275353a05b2b"></a>EXPOSE: 暴露端口<br>
<div class="outline-text-6" id="text-h:1e7a7d85-499d-4599-af3d-275353a05b2b">
<p>
指定服务端的容器需要对外暴露(监听)的端口号，以实现容器与外部通信。<br>
</p>

<p>
EXPOSE 仅仅是声明容器打算使用什么端口而已,并不会真正暴露端口,即不会自动在宿主进行端口映射<br>
</p>

<p>
因此，在启动容器时需要通过 -P 或-p ，Docker 主机才会真正分配一个端口转发到指定暴露的端口才可使用<br>
</p>

<p>
注意: 即使 Dockerfile没有EXPOSE 端口指令,也可以通过docker run -p 临时暴露容器内程序真正监听的端口,所以EXPOSE 相当于指定默认的暴露端口,可以通过docker run -P 进行真正暴露<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">EXPOSE &lt;port&gt;[/ &lt;protocol&gt;] [&lt;port&gt;[/ &lt;protocol&gt;] ..]
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#35828;&#26126;
</span>&lt;protocol&gt;&#29992;&#20110;&#25351;&#23450;&#20256;&#36755;&#23618;&#21327;&#35758;&#65292;&#21487;&#20026;tcp&#25110;udp&#20108;&#32773;&#20043;&#19968;&#65292;&#40664;&#35748;&#20026;TCP&#21327;&#35758;
</pre>
</div>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">EXPOSE 80 443
EXPOSE 11211/udp 11211/tcp
</pre>
</div>
</div>
</li>
<li><a id="h:b00c9103-ee36-4970-a60c-fa4b4fe9520c"></a>WORKDIR: 指定工作目录<br>
<div class="outline-text-6" id="text-h:b00c9103-ee36-4970-a60c-fa4b4fe9520c">
<p>
为后续的 RUN、CMD、ENTRYPOINT 指令配置工作目录，当容器运行后，进入容器内WORKDIR指定的默认目录<br>
</p>

<p>
WORKDIR 指定工作目录（或称当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会自行创建<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">WORKDIR /path/to/workdir
</pre>
</div>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#20004;&#27425;RUN&#29420;&#31435;&#36816;&#34892;,&#19981;&#22312;&#21516;&#19968;&#20010;&#30446;&#24405;&#65292;
</span>RUN cd /app
RUN echo <span style="color: #8b2252;">"hello"</span> &gt; world.txt
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#22914;&#26524;&#24819;&#23454;&#29616;&#30456;&#21516;&#30446;&#24405;&#21487;&#20197;&#20351;&#29992;WORKDIR
</span>WORKDIR /app
RUN echo <span style="color: #8b2252;">"hello"</span> &gt; world.txt
</pre>
</div>

<p>
可以使用多个 WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">WORKDIR /a
WORKDIR b
WORKDIR c
RUN pwd
</pre>
</div>
<p>
则最终路径为 /a/b/c<br>
</p>
</div>
</li>
<li><a id="h:ab2d0faf-adf8-49f4-97cc-16d96921e050"></a>ONBUILD: 子镜像引用父镜像的指令<br>
<div class="outline-text-6" id="text-h:ab2d0faf-adf8-49f4-97cc-16d96921e050">
<p>
可以用来配置当构建当前镜像的子镜像时，会自动触发执行的指令,但在当前镜像构建时,并不会执行,即延迟到子镜像构建时才执行<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">ONBUILD [INSTRUCTION]
</pre>
</div>

<p>
例如，Dockerfile 使用如下的内容创建了镜像 image-A。<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">...
ONBUILD ADD http://www.xxx.com/wp-content/uploads/2017/09/logo.png /data/
ONBUILD RUN rm -rf /*
ONBUILD RUN /usr/local/bin/python-build --dir /app/src...
</pre>
</div>

<p>
如果基于 image-A 创建新的镜像image-B时，新的Dockerfile中使用 FROM image-A指定基础镜像时，会自动执行ONBUILD 指令内容，等价于在后面添加了两条指令。<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">FROM image-A
<span style="color: #b22222;">#</span><span style="color: #b22222;">Automatically run the following
</span>ADD http://www.xxx.com/wp-content/uploads/2017/09/logo.png /data
RUN /usr/local/bin/python-build --dir /app/src
</pre>
</div>

<p>
说明:<br>
</p>
<ul class="org-ul">
<li>尽管任何指令都可注册成为触发器指令，但ONBUILD不能自我能套，且不会触发FROM和MAINTAINER指令<br></li>
<li>使用 ONBUILD 指令的镜像，推荐在标签中注明，例如 ruby:1.9-onbuild<br></li>
</ul>
</div>
</li>
<li><a id="h:db220f37-4db8-487a-9cd7-a8834a6b4e66"></a>USER: 指定当前用户<br>
<div class="outline-text-6" id="text-h:db220f37-4db8-487a-9cd7-a8834a6b4e66">
<p>
指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户<br>
当服务不需要管理员权限时，可以通过该命令指定运行用户<br>
这个用户必须是事先建立好的，否则无法切换<br>
如果没有指定 USER,默认是 root 身份执行<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">USER &lt;user&gt;[:&lt;group&gt;]
USER &lt;UID&gt;[:&lt;GID&gt;]
</pre>
</div>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">RUN groupadd -r mysql &amp;&amp; useradd -r -g mysql mysql
USER mysql
</pre>
</div>
</div>
</li>
<li><a id="h:6c05ce4f-15a4-4b9b-ad87-499b7120baff"></a>HEALTHCHECK: 健康检查<br>
<div class="outline-text-6" id="text-h:6c05ce4f-15a4-4b9b-ad87-499b7120baff">
<p>
检查容器的健康性<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">HEALTHCHECK [&#36873;&#39033;] CMD &lt;&#21629;&#20196;&gt; <span style="color: #b22222;">#</span><span style="color: #b22222;">&#35774;&#32622;&#26816;&#26597;&#23481;&#22120;&#20581;&#24247;&#29366;&#20917;&#30340;&#21629;&#20196;
</span>HEALTHCHECK NONE <span style="color: #b22222;">#</span><span style="color: #b22222;">&#22914;&#26524;&#22522;&#30784;&#38236;&#20687;&#26377;&#20581;&#24247;&#26816;&#26597;&#25351;&#20196;&#65292;&#20351;&#29992;&#36825;&#34892;&#21487;&#20197;&#23631;&#34109;&#25481;&#20854;&#20581;&#24247;&#26816;&#26597;&#25351;&#20196;
</span>
HEALTHCHECK &#25903;&#25345;&#19979;&#21015;&#36873;&#39033;:
--interval=&lt;&#38388;&#38548;&gt; <span style="color: #b22222;">#</span><span style="color: #b22222;">&#20004;&#27425;&#20581;&#24247;&#26816;&#26597;&#30340;&#38388;&#38548;&#65292;&#40664;&#35748;&#20026; 30 &#31186;
</span>--timeout=&lt;&#26102;&#38271;&gt; <span style="color: #b22222;">#</span><span style="color: #b22222;">&#20581;&#24247;&#26816;&#26597;&#21629;&#20196;&#36816;&#34892;&#36229;&#26102;&#26102;&#38388;&#65292;&#22914;&#26524;&#36229;&#36807;&#36825;&#20010;&#26102;&#38388;&#65292;&#26412;&#27425;&#20581;&#24247;&#26816;&#26597;&#23601;&#34987;&#35270;&#20026;&#22833;&#36133;&#65292;&#40664;&#35748; 30 &#31186;
</span>--retries=&lt;&#27425;&#25968;&gt; <span style="color: #b22222;">#</span><span style="color: #b22222;">&#24403;&#36830;&#32493;&#22833;&#36133;&#25351;&#23450;&#27425;&#25968;&#21518;&#65292;&#21017;&#23558;&#23481;&#22120;&#29366;&#24577;&#35270;&#20026; unhealthy&#65292;&#40664;&#35748;3&#27425;
</span>--start-period=&lt;FDURATION&gt; <span style="color: #b22222;">#</span><span style="color: #b22222;">default: 0s
</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26816;&#26597;&#32467;&#26524;&#36820;&#22238;&#20540;:
</span>0 <span style="color: #b22222;">#</span><span style="color: #b22222;">success the container is healthy and ready for use
</span>1 <span style="color: #b22222;">#</span><span style="color: #b22222;">unhealth the container is not working correctly
</span>2 <span style="color: #b22222;">#</span><span style="color: #b22222;">reserved do not use this exit code</span>
</pre>
</div>

<p>
范例：<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">FROM nginx
RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*
HEALTHCHECK --interval=5s --timeout=3s <span style="color: #8b2252;">\</span>
CMD curl -fs http://localhost/ || <span style="color: #a020f0;">exit</span> 1
</pre>
</div>
</div>
</li>
<li><a id="h:d81ec47a-e386-4f41-9e8e-872eb1b21c50"></a>STOPSIGNAL: 退出容器的信号<br>
<div class="outline-text-6" id="text-h:d81ec47a-e386-4f41-9e8e-872eb1b21c50">
<p>
该 STOPSIGNAL 指令设置将被发送到容器退出的系统调用信号。该信号可以是与内核syscall表中的位置匹配的有效无符号数字（例如9），也可以是SIGNAME格式的信号名称（例如SIGKILL）<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">STOPSIGNAL signal
</pre>
</div>
</div>
</li>
<li><a id="h:bc8be0b5-f204-4891-aa5f-3a8e926fbe50"></a>SHELL : 指定shell<br>
<div class="outline-text-6" id="text-h:bc8be0b5-f204-4891-aa5f-3a8e926fbe50">
<p>
SHELL指令允许覆盖用于命令的shell形式的默认SHELL, 必须在Dockerfile中以JSON形式编写SHELL指令。<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">SHELL [<span style="color: #8b2252;">"executable"</span>, <span style="color: #8b2252;">"parameters"</span>]
</pre>
</div>

<p>
在Linux上默认SHELL程序为[“/bin/sh”，“-c”]，在Windows上，默认SHELL程序为[“cmd”，“/S”，“/C”]。<br>
</p>

<p>
SHELL指令在Windows上特别有用，在Windows上有两个常用且完全不同的本机<a href="shell:cmd%E5%92%8Cpowershell%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%8C%85%E6%8B%ACsh%E5%9C%A8%E5%86%85%E7%9A%84%E5%A4%87%E7%94%A8shell">shell:cmd%E5%92%8Cpowershell%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%8C%85%E6%8B%ACsh%E5%9C%A8%E5%86%85%E7%9A%84%E5%A4%87%E7%94%A8shell</a>。<br>
</p>

<p>
SHELL指令可以出现多次。 每个SHELL指令将覆盖所有先前的SHELL指令，并影响所有后续的指令<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">FROM microsoft/windowsservercore

<span style="color: #b22222;"># </span><span style="color: #b22222;">Executed as cmd /S /C echo default
</span>RUN echo default

<span style="color: #b22222;"># </span><span style="color: #b22222;">Executed as cmd /S /C powershell -command Write-Host default
</span>RUN powershell -command Write-Host default

<span style="color: #b22222;"># </span><span style="color: #b22222;">Executed as powershell -command Write-Host hello
</span>SHELL [<span style="color: #8b2252;">"powershell"</span>, <span style="color: #8b2252;">"-command"</span>]
RUN Write-Host hello

<span style="color: #b22222;"># </span><span style="color: #b22222;">Executed as cmd /S /C echo hello
</span>SHELL [<span style="color: #8b2252;">"cmd"</span>, <span style="color: #8b2252;">"/S"</span>, <span style="color: #8b2252;">"/C"</span>]
RUN echo hello
</pre>
</div>
</div>
</li>
<li><a id="h:4c28a829-08e5-4ae2-8c3f-295fdab0e6ae"></a>.dockerignore文件<br>
<div class="outline-text-6" id="text-h:4c28a829-08e5-4ae2-8c3f-295fdab0e6ae">
<p>
官方文档: <a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file">https://docs.docker.com/engine/reference/builder/#dockerignore-file</a><br>
</p>

<p>
与.gitignore文件类似，生成构建上下文时Docker客户端应忽略的文件和文件夹指定模式<br>
</p>

<p>
.dockerignore 使用 Go 的文件路径规则 filepath.Match<br>
</p>

<p>
参考链接: <a href="https://golang.org/pkg/path/filepath/#Match">https://golang.org/pkg/path/filepath/#Match</a><br>
</p>

<p>
完整的语法<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;"># </span><span style="color: #b22222;">#&#20197;#&#24320;&#22836;&#30340;&#34892;&#20026;&#27880;&#37322;
</span>* <span style="color: #b22222;">#</span><span style="color: #b22222;">&#21305;&#37197;&#20219;&#20309;&#38750;&#20998;&#38548;&#31526;&#23383;&#31526;&#24207;&#21015;
</span>? <span style="color: #b22222;">#</span><span style="color: #b22222;">&#21305;&#37197;&#20219;&#20309;&#21333;&#20010;&#38750;&#20998;&#38548;&#31526;
</span><span style="color: #8b2252;">\\</span> <span style="color: #b22222;">#</span><span style="color: #b22222;">&#34920;&#31034; \
</span>
** <span style="color: #b22222;">#</span><span style="color: #b22222;">&#21305;&#37197;&#20219;&#24847;&#25968;&#37327;&#30340;&#30446;&#24405;&#65288;&#21253;&#25324;&#38646;&#65289;&#20363;&#22914;&#65292;**/*.go&#23558;&#25490;&#38500;&#22312;&#25152;&#26377;&#30446;&#24405;&#20013;&#20197;.go&#32467;&#23614;&#30340;&#25152;&#26377;&#25991;&#20214;&#65292;&#21253;&#25324;&#26500;&#24314;&#19978;&#19979;&#25991;&#30340;&#26681;&#12290;
</span>! <span style="color: #b22222;">#</span><span style="color: #b22222;">&#34920;&#31034;&#21462;&#21453;&#65292;&#21487;&#29992;&#20110;&#25490;&#38500;&#20363;&#22806;&#24773;&#20917;&#33539;&#20363;:</span>
</pre>
</div>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#25490;&#38500; test &#30446;&#24405;&#19979;&#30340;&#25152;&#26377;&#25991;&#20214;
</span>test/*
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#25490;&#38500; md &#30446;&#24405;&#19979;&#30340; xttblog.md &#25991;&#20214;
</span>md/xttblog.md
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#25490;&#38500; xttblog &#30446;&#24405;&#19979;&#30340;&#25152;&#26377; .md &#30340;&#25991;&#20214;
</span>xttblog/*.md
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#25490;&#38500;&#20197; xttblog &#20026;&#21069;&#32512;&#30340;&#25991;&#20214;&#21644;&#25991;&#20214;&#22841;
</span>xttblog?
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#25490;&#38500;&#25152;&#26377;&#30446;&#24405;&#19979;&#30340; .sql &#25991;&#20214;&#22841;
</span>**/*.sql

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#38500;&#20102;README&#30340;md&#19981;&#25490;&#22806;&#65292;&#25490;&#38500;&#25152;&#26377;md&#25991;&#20214;&#65292;&#20294;&#19981;&#25490;&#38500;README-secret.md
</span>*.md
!README*.md
README-secret.md

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#38500;&#20102;&#25152;&#26377;README&#30340;md&#25991;&#20214;&#20197;&#22806;&#30340;md&#37117;&#25490;&#38500;
</span>*.md
README-secret.md
!README*.md
</pre>
</div>
</div>
</li>
<li><a id="h:63de6ac2-261c-4a99-9c22-ddcdf8921a0c"></a>Dockerfile 构建过程和指令总结<br>
<div class="outline-text-6" id="text-h:63de6ac2-261c-4a99-9c22-ddcdf8921a0c">
<p>
<b>Dockerfile 构建过程</b><br>
</p>
<ul class="org-ul">
<li>从基础镜像运行一个容器<br></li>
<li>执行一条指令，对容器做出修改<br></li>
<li>执行类似docker commit的操作，提交一个新的中间镜像层(可以利用中间层镜像创建容器进行调试和排错)<br></li>
<li>再基于刚提交的镜像运行一个新容器<br></li>
<li>执行Dockerfile中的下一条指令，直至所有指令执行完毕<br></li>
</ul>

<p>
<b>Dockerfile 指令总结</b><br>
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-h:98b56914-74ab-4181-8fb0-3c569d4adf81" class="outline-5">
<h5 id="h:98b56914-74ab-4181-8fb0-3c569d4adf81">构建镜像docker build 命令</h5>
<div class="outline-text-5" id="text-h:98b56914-74ab-4181-8fb0-3c569d4adf81">
<p>
docker build命令使用Dockerfile文件创建镜像<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">docker build [OPTIONS] PATH | URL | -

&#35828;&#26126;:
PATH | URL | - <span style="color: #b22222;">#</span><span style="color: #b22222;">&#21487;&#20197;&#20351;&#26159;&#26412;&#22320;&#36335;&#24452;&#65292;&#20063;&#21487;&#20197;&#26159;URL&#36335;&#24452;&#12290;&#33509;&#35774;&#32622;&#20026; - &#65292;&#21017;&#20174;&#26631;&#20934;&#36755;&#20837;&#33719;&#21462;Dockerfile&#30340;&#20869;&#23481;
</span>-f, --file string <span style="color: #b22222;">#</span><span style="color: #b22222;">Dockerfile&#25991;&#20214;&#21517;,&#40664;&#35748;&#20026; PATH/Dockerfile
</span>--force-rm <span style="color: #b22222;">#</span><span style="color: #b22222;">&#24635;&#26159;&#21024;&#38500;&#20013;&#38388;&#23618;&#23481;&#22120;,&#21019;&#24314;&#38236;&#20687;&#22833;&#36133;&#26102;&#65292;&#21024;&#38500;&#20020;&#26102;&#23481;&#22120;
</span>--no-cache <span style="color: #b22222;">#</span><span style="color: #b22222;">&#19981;&#20351;&#29992;&#20043;&#21069;&#26500;&#24314;&#20013;&#21019;&#24314;&#30340;&#32531;&#23384;
</span>-q --quiet=false <span style="color: #b22222;">#</span><span style="color: #b22222;">&#19981;&#26174;&#31034;Dockerfile&#30340;RUN&#36816;&#34892;&#30340;&#36755;&#20986;&#32467;&#26524;
</span>--rm=true <span style="color: #b22222;">#</span><span style="color: #b22222;">&#21019;&#24314;&#38236;&#20687;&#25104;&#21151;&#26102;&#65292;&#21024;&#38500;&#20020;&#26102;&#23481;&#22120;
</span>-t --tag list <span style="color: #b22222;">#</span><span style="color: #b22222;">&#35774;&#32622;&#27880;&#20876;&#21517;&#31216;&#12289;&#38236;&#20687;&#21517;&#31216;&#12289;&#26631;&#31614;&#12290;&#26684;&#24335;&#20026; &lt;&#27880;&#20876;&#21517;&#31216;&gt;/&lt;&#38236;&#20687;&#21517;&#31216;&gt;:&lt;&#26631;&#31614;&gt;&#65288;&#26631;&#31614;&#40664;&#35748;&#20026;latest&#65289;</span>
</pre>
</div>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker build .
docker build /usr/local/src/nginx
docker build -f /path/to/a/Dockerfile .
docker build -t shykes/myapp .
docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest .
docker build -t test/myapp .
docker build -t nginx:v1 /usr/local/src/nginx
</pre>
</div>

<p>
<b>查看镜像的构建历史: docker history 镜像ID</b><br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@centos8 ~]#podman history 90201858b1fc
</pre>
</div>

<p>
<b>范例: 利用Dockerfile构建基于CentOS的nginx镜像</b><br>
</p>

<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#cat /data/Dockerfile
FROM centos
LABEL <span style="color: #a0522d;">maintainer</span>=<span style="color: #8b2252;">"xxx <a href="mailto:root%40xxx.com">&lt;root@xxx.com&gt;</a>"</span>
RUN yum install -y nginx &amp;&amp; <span style="color: #483d8b;">echo</span> Nginx Website<span style="color: #a020f0;"> in</span> Docker &gt;
/usr/share/nginx/html/index.html
EXPOSE 80
CMD [<span style="color: #8b2252;">"nginx"</span>, <span style="color: #8b2252;">"-g"</span>, <span style="color: #8b2252;">"daemon off;"</span>]
<span style="color: #b22222;">#</span><span style="color: #b22222;">ENTRYPOINT ["nginx", "-g", "daemon off;"]
</span>
[root@ubuntu1804 ~]#docker build -t nginx_centos8.2:v1.14.1 /data/
[root@ubuntu1804 ~]#docker ps
[root@ubuntu1804 ~]#curl http://127.0.0.1:32775
Nginx Website<span style="color: #a020f0;"> in</span> Docker
[root@ubuntu1804 ~]#curl -I http://127.0.0.1:32775
</pre>
</div>


<p>
范例: 刷新镜像缓存重新构建新镜像<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#cat /data/Dockerfile
FROM centos
LABEL <span style="color: #a0522d;">maintainer</span>=<span style="color: #8b2252;">"xxx <a href="mailto:root%40xxx.com">&lt;root@xxx.com&gt;</a>"</span>
RUN yum install -y nginx
RUN echo Nginx Website<span style="color: #a020f0;"> in</span> Docker &gt; /usr/share/nginx/html/index.html
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#20462;&#25913;&#19979;&#38754;&#34892;,&#20174;&#19979;&#38754;&#34892;&#24320;&#22987;&#19981;&#20877;&#20351;&#29992;&#32531;&#23384;
</span>ENV REFRESH_DATA 2020-01-01
EXPOSE 80
CMD [<span style="color: #8b2252;">"nginx"</span>, <span style="color: #8b2252;">"-g"</span>, <span style="color: #8b2252;">"daemon off;"</span>]

[root@ubuntu1804 ~]#docker build -t nginx_centos8.2:v1.14.1 /data/
Sending build context to Docker daemon 209.2MB
Step 1/7 : FROM centos
---&gt; 831691599b88
Step 2/7 : LABEL <span style="color: #a0522d;">maintainer</span>=<span style="color: #8b2252;">"xxx <a href="mailto:root%40xxx.com">&lt;root@xxx.com&gt;</a>"</span>
---&gt; Using cache
---&gt; 598318841b8a
Step 3/7 : RUN yum install -y nginx
---&gt; Using cache
---&gt; 8963fb608c33
Step 4/7 : RUN echo Nginx Website<span style="color: #a020f0;"> in</span> Docker &gt; /usr/share/nginx/html/index.html
---&gt; Using cache
---&gt; 9a95e56b9bc0
Step 5/7 : ENV REFRESH_DATA 2020-01-01 <span style="color: #b22222;">#</span><span style="color: #b22222;">&#20174;&#27492;&#34892;&#24320;&#22987;&#19981;&#20877;&#21033;&#29992;&#32531;&#23384;
</span>---&gt; Running<span style="color: #a020f0;"> in</span> 4607ee0d0e77
Removing intermediate container 4607ee0d0e77
Step 6/7 : EXPOSE 80
---&gt; Running<span style="color: #a020f0;"> in</span> 6924aab5c5c8
Removing intermediate container 6924aab5c5c8
---&gt; 545393760683
Step 7/7 : CMD [<span style="color: #8b2252;">"nginx"</span>, <span style="color: #8b2252;">"-g"</span>, <span style="color: #8b2252;">"daemon off;"</span>]
---&gt; Running<span style="color: #a020f0;"> in</span> 345bbc6179d8
Removing intermediate container 345bbc6179d8
---&gt; 4bafc2d0c7e0
Successfully built 4bafc2d0c7e0
Successfully tagged nginx_centos8.2:v1.14.1



<span style="color: #b22222;">#</span><span style="color: #b22222;">&#20840;&#37096;&#19981;&#21033;&#29992;&#32531;&#23384;&#37325;&#26032;&#26500;&#24314;&#38236;&#20687;
</span>[root@ubuntu1804 ~]#docker build --no-cache -t nginx_centos8.2:v1.14.1 /data/
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:1f656c77-c145-4bcd-96ec-970219d6eaad" class="outline-4">
<h4 id="h:1f656c77-c145-4bcd-96ec-970219d6eaad">检查镜像中dockerfile内容</h4>
<div class="outline-text-4" id="text-h:1f656c77-c145-4bcd-96ec-970219d6eaad">
</div>
<div id="outline-container-h:93e3db93-5f8f-42c8-a99e-e816e8a1cd71" class="outline-5">
<h5 id="h:93e3db93-5f8f-42c8-a99e-e816e8a1cd71">docker history</h5>
<div class="outline-text-5" id="text-h:93e3db93-5f8f-42c8-a99e-e816e8a1cd71">
<div class="org-src-container">
<pre class="src src-sh">docker history [OPTIONS] IMAGE
</pre>
</div>
</div>
</div>
<div id="outline-container-h:7ba447d9-ac79-4504-a6e6-589d87804c6d" class="outline-5">
<h5 id="h:7ba447d9-ac79-4504-a6e6-589d87804c6d">image2df</h5>
<div class="outline-text-5" id="text-h:7ba447d9-ac79-4504-a6e6-589d87804c6d">
<p>
<a href="https://hub.docker.com/r/cucker/image2df">https://hub.docker.com/r/cucker/image2df</a><br>
</p>

<p>
范例：<br>
</p>
<div class="org-src-container">
<pre class="src src-sh">$ echo <span style="color: #8b2252;">"alias image2df='docker run --rm -v /var/run/docker.sock:/var/run/docker.sock cucker/image2df'"</span> &gt;&gt; ~/.bashrc
$ . ~/.bashrc
$ docker pull mysql
$ image2df mysql
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:55fc356f-0772-49c0-9868-e7c7bb89497a" class="outline-4">
<h4 id="h:55fc356f-0772-49c0-9868-e7c7bb89497a">实战案例: Dockerfile 制作基于基础镜像的Base镜像</h4>
<div class="outline-text-4" id="text-h:55fc356f-0772-49c0-9868-e7c7bb89497a">
</div>
<div id="outline-container-h:8a02c906-b5d9-47df-ae85-da038ffafd3f" class="outline-5">
<h5 id="h:8a02c906-b5d9-47df-ae85-da038ffafd3f">准备目录结构，下载镜像并初始化系统</h5>
<div class="outline-text-5" id="text-h:8a02c906-b5d9-47df-ae85-da038ffafd3f">
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#mkdir
/data/dockerfile/{web/{nginx,apache,tomcat,jdk},system/{centos,ubuntu,alpine,debian}} -p

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#19979;&#36733;&#22522;&#30784;&#38236;&#20687;
</span>[root@ubuntu1804 ~]#docker pull centos:centos7.7.1908
</pre>
</div>
</div>
</div>
<div id="outline-container-h:fc2f427d-9678-4049-ba52-464d519131f4" class="outline-5">
<h5 id="h:fc2f427d-9678-4049-ba52-464d519131f4">先制作基于基础镜像的系统Base镜像</h5>
<div class="outline-text-5" id="text-h:fc2f427d-9678-4049-ba52-464d519131f4">
<p>
#按照业务类型或系统类型等方式划分创建目录环境，方便后期镜像比较多的时候进行分类<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#20808;&#21046;&#20316;&#22522;&#20110;&#22522;&#30784;&#38236;&#20687;&#30340;&#31995;&#32479;base&#38236;&#20687;
</span>[root@ubuntu1804 ~]#cd /data/dockerfile/system/centos/
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21019;&#24314;Dockerfile&#65292;&#27880;&#24847;&#21487;&#20197;&#26159;dockerfile&#65292;&#20294;&#26080;&#35821;&#27861;&#30528;&#33394;&#21151;&#33021;
</span>
[root@ubuntu1804 centos]#cat Dockerfile
FROM centos:centos7.7.1908
LABEL <span style="color: #a0522d;">maintainer</span>=<span style="color: #8b2252;">"xxx <a href="mailto:root%40xxx.com">&lt;root@xxx.com&gt;</a>"</span>
RUN yum -y install wget &amp;&amp; rm -f /etc/yum.repos.d/* &amp;&amp; wget -P /etc/yum.repos.d/  http://mirrors.aliyun.com/repo/Centos-7.repo <span style="color: #8b2252;">\</span>
      &amp;&amp; wget -P /etc/yum.repos.d/ http://mirrors.aliyun.com/repo/epel-7.repo <span style="color: #8b2252;">\</span>
      &amp;&amp; yum -y install vim-enhanced tcpdump lrzsz tree telnet bash-completion net-tools wget curl bzip2 lsof zip unzip nfs-utils gcc make gcc-c++ glibc glibc-devel pcre pcre-devel openssl openssl-devel systemd-devel zlib-devel <span style="color: #8b2252;">\</span>
      &amp;&amp; yum clean all <span style="color: #8b2252;">\</span>
      &amp;&amp; rm -f /etc/localtime <span style="color: #8b2252;">\</span>
      &amp;&amp; ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime

[root@ubuntu1804 centos]#vim build.sh
[root@ubuntu1804 centos]#cat build.sh
<span style="color: #b22222;">#</span><span style="color: #b22222;">!/bin/bash
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">
</span>docker build -t centos7-base:v1 .
[root@ubuntu1804 centos]#chmod +x build.sh

[root@ubuntu1804 centos]#./build.sh
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:5141ed9f-ef9d-4537-9c90-d9864333f00e" class="outline-4">
<h4 id="h:5141ed9f-ef9d-4537-9c90-d9864333f00e">实战案例: Dockerfile 制作基于Base镜像的 nginx 镜像</h4>
<div class="outline-text-4" id="text-h:5141ed9f-ef9d-4537-9c90-d9864333f00e">
</div>
<div id="outline-container-h:1313436e-5450-4a26-94ea-626e23552423" class="outline-5">
<h5 id="h:1313436e-5450-4a26-94ea-626e23552423">在Dockerfile目录下准备编译安装的相关文件</h5>
<div class="outline-text-5" id="text-h:1313436e-5450-4a26-94ea-626e23552423">
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#mkdir /data/dockerfile/web/nginx/1.16
[root@ubuntu1804 ~]#cd /data/dockerfile/web/nginx/1.16
[root@ubuntu1804 1.16]#wget http://nginx.org/download/nginx-1.16.1.tar.gz
[root@ubuntu1804 1.16]#mkdir app/
[root@ubuntu1804 1.16]#echo <span style="color: #8b2252;">"Test Page in app"</span> &gt; app/index.html
[root@ubuntu1804 1.16]#tar zcf app.tar.gz app
[root@ubuntu1804 1.16]#ls
app app.tar.gz nginx-1.16.1.tar.gz
</pre>
</div>
</div>
</div>
<div id="outline-container-h:1b69977e-161d-4858-81cf-7daba3e509a4" class="outline-5">
<h5 id="h:1b69977e-161d-4858-81cf-7daba3e509a4">在一台测试机进行编译安装同一版本的nginx 生成模版配置文件</h5>
<div class="outline-text-5" id="text-h:1b69977e-161d-4858-81cf-7daba3e509a4">
<div class="org-src-container">
<pre class="src src-shell">[root@centos7 ~]#yum -y install vim-enhanced tcpdump lrzsz tree telnet bashcompletion net-tools wget bzip2 lsof tmux man-pages zip unzip nfs-utils gcc make gcc-c++ glibc glibc-devel pcre pcre-devel openssl openssl-devel systemd-devel zlib-devel

[root@centos7 ~]#wget -P /usr/local/src http://nginx.org/download/nginx-1.16.1.tar.gz
[root@centos7 ~]#cd /usr/local/src/
[root@centos7 src]#tar xvf nginx-1.16.1.tar.gz
[root@centos7 src]#cd nginx-1.16.1/
[root@centos7 nginx-1.16.1]#./configure --prefix=/apps/nginx &amp;&amp; make &amp;&amp; make install

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#23558;&#37197;&#32622;&#25991;&#20214;&#22797;&#21046;&#21040;nginx&#38236;&#20687;&#30340;&#26381;&#21153;&#22120;&#30456;&#24212;&#30446;&#24405;&#19979;
</span>[root@centos7 ~]#scp /apps/nginx/conf/nginx.conf 10.0.0.100:/data/dockerfile/web/nginx/1.16

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#20934;&#22791;&#37197;&#32622;&#25991;&#20214;
</span>[root@ubuntu1804 1.16]#vim /data/dockerfile/web/nginx/1.16/nginx.conf

worker_processes 1;
user nginx;
daemon off; <span style="color: #b22222;">#</span><span style="color: #b22222;">&#22686;&#21152;&#27492;&#34892;,&#21069;&#21488;&#36816;&#34892;nginx</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-h:1c8d6a59-ad9b-4086-91b2-a5b28e94d36a" class="outline-5">
<h5 id="h:1c8d6a59-ad9b-4086-91b2-a5b28e94d36a">编写Dockerfile文件</h5>
<div class="outline-text-5" id="text-h:1c8d6a59-ad9b-4086-91b2-a5b28e94d36a">
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#cd /data/dockerfile/web/nginx
[root@ubuntu1804 nginx]#vim Dockerfile
[root@ubuntu1804 nginx]#cat Dockerfile
FROM centos7-base:v1

LABEL <span style="color: #a0522d;">maintainer</span>=<span style="color: #8b2252;">"xxx <a href="mailto:root%40xxx.com">&lt;root@xxx.com&gt;</a>"</span>

ADD nginx-1.16.1.tar.gz /usr/local/src
RUN cd /usr/local/src/nginx-1.16.1 &amp;&amp; <span style="color: #8b2252;">\</span>
    &amp;&amp; ./configure --prefix=/apps/nginx <span style="color: #8b2252;">\</span>
    &amp;&amp; make &amp;&amp; make install <span style="color: #8b2252;">\</span>
    &amp;&amp; rm -f /usr/local/src/nginx* <span style="color: #8b2252;">\</span>
    &amp;&amp; useradd -r nginx

COPY nginx.conf /apps/nginx/conf/
ADD app.tar.gz /apps/nginx/html/

EXPOSE 80 443
CMD [<span style="color: #8b2252;">"/apps/nginx/sbin/nginx"</span>]

[root@ubuntu1804 nginx]#
</pre>
</div>
</div>
</div>
<div id="outline-container-h:58774e67-6a8b-4980-8482-e82dc6cac1f1" class="outline-5">
<h5 id="h:58774e67-6a8b-4980-8482-e82dc6cac1f1">生成nginx镜像</h5>
<div class="outline-text-5" id="text-h:58774e67-6a8b-4980-8482-e82dc6cac1f1">
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#cd /data/dockerfile/web/nginx/1.16
[root@ubuntu1804 1.16]#ls
app app.tar.gz build.sh Dockerfile nginx-1.16.1.tar.gz nginx.conf

[root@ubuntu1804 1.16]#vim build.sh
[root@ubuntu1804 1.16]#cat build.sh
<span style="color: #b22222;">#</span><span style="color: #b22222;">!/bin/bash
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">
</span>docker build -t nginx-centos7:1.6.1 .

[root@ubuntu1804 1.16]#chmod +x build.sh
[root@ubuntu1804 1.16]#./build.sh
</pre>
</div>
</div>
</div>
<div id="outline-container-h:93c0b0d4-c90d-427c-933b-ac590eae5e16" class="outline-5">
<h5 id="h:93c0b0d4-c90d-427c-933b-ac590eae5e16">生成的容器测试镜像</h5>
<div class="outline-text-5" id="text-h:93c0b0d4-c90d-427c-933b-ac590eae5e16">
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker run -d -p 80:80 nginx-centos7:1.6.1

[root@ubuntu1804 ~]#docker exec -it e8e733c6dc96 bash
[root@e8e733c6dc96 /]# ps aux
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
root 1 0.2 0.2 20572 2468 ? Ss 03:36 0:00 nginx: master
process /apps/nginx/sbin/nginx
nginx 12 0.0 0.2 21024 2344 ? S 03:36 0:00 nginx: worker
process
root 13 4.0 0.3 12364 3536 pts/0 Ss 03:37 0:00 bash
root 32 0.0 0.3 51764 3460 pts/0 R+ 03:37 0:00 ps aux
[root@e8e733c6dc96 /]# exit
<span style="color: #a020f0;">exit</span>
[root@ubuntu1804 ~]#curl 127.0.0.1/app/
Test Page<span style="color: #a020f0;"> in</span> app
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:b6d02c34-b863-4ea7-9f72-fc4fdb6d523d" class="outline-4">
<h4 id="h:b6d02c34-b863-4ea7-9f72-fc4fdb6d523d">实战案例: Dockerfile 直接制作 nginx 镜像</h4>
<div class="outline-text-4" id="text-h:b6d02c34-b863-4ea7-9f72-fc4fdb6d523d">
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#22312;Dockerfile&#30446;&#24405;&#19979;&#20934;&#22791;&#32534;&#35793;&#23433;&#35013;&#30340;&#30456;&#20851;&#25991;&#20214;
</span>[root@ubuntu1804 ~]#mkdir /data/dockerfile/web/nginx/1.16.1
[root@ubuntu1804 ~]#cd /data/dockerfile/web/nginx/1.16.1
[root@ubuntu1804 1.16.1]#vim nginx.conf
user nginx;
worker_processes 1;
<span style="color: #b22222;">#</span><span style="color: #b22222;">daemon off;
</span>[root@ubuntu1804 1.16.1]#wget http://nginx.org/download/nginx-1.16.1.tar.gz

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#32534;&#20889;Dockerfile&#25991;&#20214;
</span>[root@ubuntu1804 1.16.1]#pwd
/data/dockerfile/web/nginx/1.16.1
[root@ubuntu1804 1.16.1]#vim Dockerfile
[root@ubuntu1804 1.16.1]#cat Dockerfile
<span style="color: #b22222;">#</span><span style="color: #b22222;">Nginx Dockerfile
</span>FROM centos:centos7.7.1908
MAINTAINER xxx <a href="mailto:root%40xxx.com">&lt;root@xxx.com&gt;</a>
RUN yum install -y gcc gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel <span style="color: #8b2252;">\</span>
      &amp;&amp; useradd -r -s /sbin/nologin nginx <span style="color: #8b2252;">\</span>
      &amp;&amp; yum clean all
ADD nginx-1.16.1.tar.gz /usr/local/src/
RUN cd /usr/local/src/nginx-1.16.1 <span style="color: #8b2252;">\</span>
    &amp;&amp; ./configure --prefix=/apps/nginx <span style="color: #8b2252;">\</span>
    &amp;&amp; make <span style="color: #8b2252;">\</span>
    &amp;&amp; make install <span style="color: #8b2252;">\</span>
    &amp;&amp; rm -rf /usr/local/src/nginx*
ADD nginx.conf /apps/nginx/conf/nginx.conf
COPY index.html /apps/nginx/html/
RUN ln -s /apps/nginx/sbin/nginx /usr/sbin/nginx
EXPOSE 80 443
CMD [<span style="color: #8b2252;">"nginx"</span>,<span style="color: #8b2252;">"-g"</span>,<span style="color: #8b2252;">"daemon off;"</span>]

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#29983;&#25104;nginx&#38236;&#20687;
</span>[root@ubuntu1804 ~]#cd /data/dockerfile/web/nginx/1.16.1
[root@ubuntu1804 1.16.1]#vim build.sh
[root@ubuntu1804 1.16.1]#cat build.sh
<span style="color: #b22222;">#</span><span style="color: #b22222;">!/bin/bash
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">
</span>docker build -t nginx-centos7:1.6.1-v2 .
[root@ubuntu1804 1.16.1]#chmod +x build.sh
[root@ubuntu1804 1.16.1]#ls
build.sh Dockerfile index.html nginx-1.16.1.tar.gz nginx.conf
[root@ubuntu1804 1.16.1]#./build.sh

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#29983;&#25104;&#23481;&#22120;&#27979;&#35797;&#38236;&#20687;
</span>[root@ubuntu1804 ~]#docker run -d -p 80:80 nginx-centos7:1.6.1-v2
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:356c5eea-36c2-4d53-a7fb-bb88391790db" class="outline-3">
<h3 id="h:356c5eea-36c2-4d53-a7fb-bb88391790db">基于 alpine 基础镜像制作nginx镜像</h3>
<div class="outline-text-3" id="text-h:356c5eea-36c2-4d53-a7fb-bb88391790db">
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#22312;&#31532;&#20108;&#21488;&#20027;&#26426;&#19978;&#24674;&#22797;&#21551;&#21160;&#23481;&#22120;
</span>[root@ubuntu1804 ~]#docker pull alpine
[root@ubuntu1804 ~]#docker tag alpine alpine:3.11

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#20934;&#22791;&#30456;&#20851;&#25991;&#20214;
</span>[root@ubuntu1804 ~]#cd /data/dockerfile/system/alpine
[root@ubuntu1804 alpine]#cat repositories
http://mirrors.aliyun.com/alpine/v3.11/main
http://mirrors.aliyun.com/alpine/v3.11/community

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#20934;&#22791;Dockerfile&#25991;&#20214;
</span>[root@ubuntu1804 alpine]#cat Dockerfile
FROM alpine:3.11
LABEL <span style="color: #a0522d;">maintainer</span>=<span style="color: #8b2252;">"xxx <a href="mailto:root%40xxx.com">&lt;root@xxx.com&gt;</a>"</span>
COPY repositories /etc/apk/repositories
RUN apk update &amp;&amp; apk --no-cache add iotop gcc libgcc libc-dev libcurl libcutils pcre-dev zlib-dev libnfs make pcre pcre2 zip unzip net-tools pstree wget libevent libevent-dev iproute2

docker build -t alpine-base:3.11 .

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21046;&#20316;&#22522;&#20110;alpine&#33258;&#23450;&#20041;&#38236;&#20687;&#30340;nginx&#38236;&#20687;
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">&#32534;&#20889;Dockerfile&#25991;&#20214;
</span>[root@ubuntu1804 1.16.1-alpine]#cat Dockerfile
FROM alpine-base:3.11
LABEL <span style="color: #a0522d;">maintainer</span>=<span style="color: #8b2252;">"xxx <a href="mailto:root%40xxx.com">&lt;root@xxx.com&gt;</a>"</span>
ADD nginx-1.16.1.tar.gz /usr/local/src
RUN cd /usr/local/src/nginx-1.16.1 &amp;&amp; ./configure --prefix=/apps/nginx &amp;&amp; make &amp;&amp; make install &amp;&amp; ln -s /apps/nginx/sbin/nginx /usr/bin/
RUN addgroup -g 2019 -S nginx &amp;&amp; adduser -s /sbin/nologin -S -D -u 2019 -G nginx nginx
COPY nginx.conf /apps/nginx/conf/nginx.conf
ADD index.html /data/nginx/html/index.html
RUN chown -R nginx.nginx /data/nginx/ /apps/nginx/
EXPOSE 80 443
CMD [<span style="color: #8b2252;">"nginx"</span>]
</pre>
</div>
</div>
</div>
<div id="outline-container-h:7cde48e5-4521-4810-94e4-82a5cff5a6ae" class="outline-3">
<h3 id="h:7cde48e5-4521-4810-94e4-82a5cff5a6ae">基于 Ubuntu 基础镜像制作 nginx 镜像</h3>
<div class="outline-text-3" id="text-h:7cde48e5-4521-4810-94e4-82a5cff5a6ae">
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#32534;&#20889;Dockerfile&#25991;&#20214;
</span>[root@ubuntu1804 1.16.1-ubuntu1804]#cat Dockerfile
FROM ubuntu:18.04
LABEL <span style="color: #a0522d;">maintainer</span>=<span style="color: #8b2252;">"xxx <a href="mailto:root%40xxx.com">&lt;root@xxx.com&gt;</a>"</span>
COPY sources.list /etc/apt/sources.list
RUN apt update &amp;&amp; apt install -y nfs-kernel-server nfs-common gcc opensshserver lrzsz tree openssl libssl-dev libpcre3 libpcre3-dev zlib1g-dev unzip zip make
ADD nginx-1.16.1.tar.gz /usr/local/src
RUN cd /usr/local/src/nginx-1.16.1 &amp;&amp; ./configure --prefix=/apps/nginx &amp;&amp; make &amp;&amp; make install &amp;&amp; ln -s /apps/nginx/sbin/nginx /usr/bin &amp;&amp; rm -rf /usr/local/src/nginx-1.16.1*
ADD nginx.conf /apps/nginx/conf/nginx.conf
ADD index.html /data/nginx/html/index.html
RUN groupadd -g 2019 nginx &amp;&amp; useradd -g nginx -s /usr/sbin/nologin -u 2019 nginx &amp;&amp; chown -R nginx.nginx /apps/nginx /data/nginx
EXPOSE 80 443
CMD [<span style="color: #8b2252;">"nginx"</span>]
</pre>
</div>
</div>
</div>
</section>
<section id="outline-container-h:7d21cb54-a602-4d26-bb4a-e5d245a3b6e3" class="outline-2">
<h2 id="h:7d21cb54-a602-4d26-bb4a-e5d245a3b6e3">Docker 数据管理</h2>
<div class="outline-text-2" id="text-h:7d21cb54-a602-4d26-bb4a-e5d245a3b6e3">

<figure id="orga3f42aa">
<img src="./images/Snipaste_2023-04-27_23-24-08.png" alt="Snipaste_2023-04-27_23-24-08.png"><br>

</figure>

<p>
Docker镜像由多个只读层叠加而成，启动容器时，Docker会加载只读镜像层并在镜像栈顶部添加一个读写层<br>
</p>

<p>
如果运行中的容器修改了现有的一个已经存在的文件，那该文件将会从读写层下面的只读层复制到读写层，该文件的只读版本仍然存在，只是已经被读写层中该文件的副本所隐藏，此即“写时复制(COW copy on write)"机制<br>
</p>

<p>
如果将正在运行中的容器修改生成了新的数据，那么新产生的数据将会被复制到读写层，进行持久化保存，这个读写层也就是容器的工作目录，也为写时复制(COW) 机制。<br>
</p>

<p>
COW机制节约空间,但会导致性低下,虽然关闭重启容器,数据不受影响,但会随着容器的删除,其对应的可写层也会随之而删除,即数据也会丢失.如果容器需要持久保存数据,并不影响性能可以用数据卷技术实现<br>
</p>

<p>
如下图是将对根的数据写入到了容器的可写层，但是把/data 中的数据写入到了一个另外的volume 中用于数据持久化<br>
<img src="./images/Snipaste_2023-04-27_23-25-27.png" alt="Snipaste_2023-04-27_23-25-27.png"><br>
</p>
</div>
<div id="outline-container-h:d691abdf-daec-4289-b0a0-dbc4b36cda5b" class="outline-3">
<h3 id="h:d691abdf-daec-4289-b0a0-dbc4b36cda5b">容器的数据管理介绍</h3>
<div class="outline-text-3" id="text-h:d691abdf-daec-4289-b0a0-dbc4b36cda5b">
<p>
Docker镜像是分层设计的，镜像层是只读的，通过镜像启动的容器添加了一层可读写的文件系统，用户<br>
写入的数据都保存在这一层中。<br>
</p>
</div>
<div id="outline-container-h:17b276d0-2fce-4658-a9e3-bd6d823e3d19" class="outline-4">
<h4 id="h:17b276d0-2fce-4658-a9e3-bd6d823e3d19">Docker容器的分层</h4>
<div class="outline-text-4" id="text-h:17b276d0-2fce-4658-a9e3-bd6d823e3d19">
<p>
容器的数据分层目录<br>
</p>
<ul class="org-ul">
<li>LowerDir: image 镜像层,即镜像本身，只读<br></li>
<li>UpperDir: 容器的上层,可读写 ,容器变化的数据存放在此处<br></li>
<li>MergedDir: 容器的文件系统，使用Union FS（联合文件系统）将lowerdir 和 upperdir 合并完成后给容器使用,最终呈现给用户的统一视图<br></li>
<li>WorkDir: 容器在宿主机的工作目录,挂载后内容会被清空，且在使用过程中其内容用户不可见<br></li>
</ul>

<p>
范例: 查看指定容器数据分层<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker inspect 12959f2c152f
        <span style="color: #8b2252;">"GraphDriver"</span>: {
            <span style="color: #8b2252;">"Data"</span>: {
                <span style="color: #8b2252;">"LowerDir"</span>: <span style="color: #8b2252;">"/data/docker_data/overlay2/e00510d1f615c8bc7d80c4a44371c8c7a242aa7a9cc725e76d269df377cc8e37/diff:/data/docker_data/overlay2/032f179041abd41e139c18c4213452e5d3499f89000e24f1b934e9d8329f3ff5/diff"</span>,
                <span style="color: #8b2252;">"MergedDir"</span>: <span style="color: #8b2252;">"/data/docker_data/overlay2/24d6af2ae21e7ccf0c72da7992c09464cb74b9e3dc7166cb14e02e97cec2bb8d/merged"</span>,
                <span style="color: #8b2252;">"UpperDir"</span>: <span style="color: #8b2252;">"/data/docker_data/overlay2/24d6af2ae21e7ccf0c72da7992c09464cb74b9e3dc7166cb14e02e97cec2bb8d/diff"</span>,
                <span style="color: #8b2252;">"WorkDir"</span>: <span style="color: #8b2252;">"/data/docker_data/overlay2/24d6af2ae21e7ccf0c72da7992c09464cb74b9e3dc7166cb14e02e97cec2bb8d/work"</span>
            },
            <span style="color: #8b2252;">"Name"</span>: <span style="color: #8b2252;">"overlay2"</span>
        },

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#27599;&#20010;&#38236;&#20687;&#23618;&#30446;&#24405;&#20013;&#21253;&#21547;&#20102;&#19968;&#20010;&#25991;&#20214;link&#65292;&#25991;&#20214;&#20869;&#23481;&#21017;&#26159;&#24403;&#21069;&#23618;&#23545;&#24212;&#30340;&#30701;&#26631;&#35782;&#31526;&#65292;&#38236;&#20687;&#23618;&#30340;&#20869;&#23481;&#21017;&#23384;&#25918;&#22312;diff&#30446;&#24405;
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">find /var/lib/docker/overlay2/848d77064091ba3ddd25a10ea6e0065af15ee701fed06f82804cf9ed58751761 -name test.img -ls
</span>

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21024;&#38500;&#23481;&#22120;&#21518;&#65292;&#25152;&#26377;&#23481;&#22120;&#25968;&#25454;&#30446;&#24405;&#37117;&#38543;&#20043;&#32780;&#21024;&#38500;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-h:230421e3-e16a-4a92-8188-f3da7fc9b901" class="outline-4">
<h4 id="h:230421e3-e16a-4a92-8188-f3da7fc9b901">哪些数据需要持久化</h4>
<div class="outline-text-4" id="text-h:230421e3-e16a-4a92-8188-f3da7fc9b901">
<p>
<b>有状态的协议</b><br>
有状态协议就是就通信双方要记住双方，并且共享一些信息。而无状态协议的通信每次都是独立的，与上一次的通信没什么关系。<br>
"状态”可以理解为“记忆”，有状态对应有记忆，无状态对应无记忆3.2 数据卷(data volume)<br>
</p>
</div>
</div>
<div id="outline-container-h:a99c8fc6-24e8-44a2-82c5-3c21d6bab6ee" class="outline-4">
<h4 id="h:a99c8fc6-24e8-44a2-82c5-3c21d6bab6ee">容器数据持久保存方式</h4>
<div class="outline-text-4" id="text-h:a99c8fc6-24e8-44a2-82c5-3c21d6bab6ee">
<p>
如果要将写入到容器的数据永久保存，则需要将容器中的数据保存到宿主机的指定目录<br>
</p>

<p>
Docker的数据类型分为两种:<br>
</p>
<ul class="org-ul">
<li>数据卷(Data Volume): 直接将宿主机目录挂载至容器的指定的目录 ，推荐使用此种方式，此方式较常用<br></li>
<li>数据卷容器(Data Volume Container): 间接使用宿主机空间，数据卷容器是将宿主机的目录挂载至一个专门的数据卷容器，然后让其他容器通过数据卷容器读写宿主机的数据 ，此方式不常用<br></li>
</ul>
</div>
</div>
<div id="outline-container-h:187ad021-5f8f-4b25-b49f-6285295668ee" class="outline-4">
<h4 id="h:187ad021-5f8f-4b25-b49f-6285295668ee">数据卷特点和使用</h4>
<div class="outline-text-4" id="text-h:187ad021-5f8f-4b25-b49f-6285295668ee">
<p>
数据卷实际上就是宿主机上的目录或者是文件，可以被直接mount到容器当中使用<br>
</p>

<p>
实际生成环境中，需要针对不同类型的服务、不同类型的数据存储要求做相应的规划，最终保证服务的可扩展性、稳定性以及数据的安全性<br>
</p>
</div>
<div id="outline-container-h:f57bc38f-e088-4cf7-acf6-014649b509f7" class="outline-5">
<h5 id="h:f57bc38f-e088-4cf7-acf6-014649b509f7">数据卷使用场景</h5>
<div class="outline-text-5" id="text-h:f57bc38f-e088-4cf7-acf6-014649b509f7">
<ul class="org-ul">
<li>数据库<br></li>
<li>日志输出<br></li>
<li>静态web页面<br></li>
<li>应用配置文件<br></li>
<li>多容器间目录或文件共享<br></li>
</ul>
</div>
</div>
<div id="outline-container-h:f95f6fc8-1def-48d8-bee9-d4f7af59e2ba" class="outline-5">
<h5 id="h:f95f6fc8-1def-48d8-bee9-d4f7af59e2ba">数据卷的特点</h5>
<div class="outline-text-5" id="text-h:f95f6fc8-1def-48d8-bee9-d4f7af59e2ba">
<ul class="org-ul">
<li>数据卷是目录或者文件，并且可以在多个容器之间共同使用,实现容器之间共享和重用<br></li>
<li>对数据卷更改数据在所有容器里面会立即更新。<br></li>
<li>数据卷的数据可以持久保存，即使删除使用使用该容器卷的容器也不影响。<br></li>
<li>在容器里面的写入数据不会影响到镜像本身,即数据卷的变化不会影响镜像的更新<br></li>
<li>依赖于宿主机目录，宿主机出问题，上面容器会受影响，当宿主机较多时，不方便统一管理<br></li>
<li>匿名和命名数据卷在容器启动时初始化，如果容器使用的镜像在挂载点包含了数据，会拷贝到新初始化的数据卷中<br></li>
</ul>
</div>
</div>
<div id="outline-container-h:51862e50-6f3c-4bc0-83bb-4c9e57968bf8" class="outline-5">
<h5 id="h:51862e50-6f3c-4bc0-83bb-4c9e57968bf8">数据卷使用方法</h5>
<div class="outline-text-5" id="text-h:51862e50-6f3c-4bc0-83bb-4c9e57968bf8">
<p>
启动容器时，可以指定使用数据卷实现容器数据的持久化,数据卷有三种<br>
</p>
<ul class="org-ul">
<li>指定宿主机目录或文件: 指定宿主机的具体路径和容器路径的挂载关系<br></li>
<li>匿名卷: 不指定数据名称,只指定容器内目录路径充当挂载点,docker自动指定宿主机的路径进行挂载<br></li>
<li>命名卷: 指定数据卷的名称和容器路径的挂载关系<br></li>
</ul>

<p>
docker run 命令的以下格式可以实现数据卷<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">-v, --volume=[host-src:]container-dest[:&lt;options&gt;]

&lt;options&gt;
ro &#20174;&#23481;&#22120;&#20869;&#23545;&#27492;&#25968;&#25454;&#21367;&#26159;&#21482;&#35835;&#65292;&#19981;&#20889;&#27492;&#39033;&#40664;&#35748;&#20026;&#21487;&#35835;&#21487;&#20889;
rw &#20174;&#23481;&#22120;&#20869;&#23545;&#27492;&#25968;&#25454;&#21367;&#21487;&#35835;&#21487;&#20889;,&#27492;&#20026;&#40664;&#35748;&#20540;
</pre>
</div>

<p>
方式1<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#25351;&#23450;&#23487;&#20027;&#26426;&#30446;&#24405;&#25110;&#25991;&#20214;&#26684;&#24335;:
</span>-v &lt;&#23487;&#20027;&#26426;&#32477;&#23545;&#36335;&#24452;&#30340;&#30446;&#24405;&#25110;&#25991;&#20214;&gt;:&lt;&#23481;&#22120;&#30446;&#24405;&#25110;&#25991;&#20214;&gt;[:ro] <span style="color: #b22222;">#</span><span style="color: #b22222;">&#23558;&#23487;&#20027;&#26426;&#30446;&#24405;&#25346;&#36733;&#23481;&#22120;&#30446;&#24405;&#65292;&#20004;&#20010;&#30446;&#24405;&#37117;&#21487;&#33258;&#21160;&#21019;&#24314;</span>
</pre>
</div>

<p>
方式2<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#21311;&#21517;&#21367;,&#21482;&#25351;&#23450;&#23481;&#22120;&#20869;&#36335;&#24452;,&#27809;&#26377;&#25351;&#23450;&#23487;&#20027;&#26426;&#36335;&#24452;&#20449;&#24687;,&#23487;&#20027;&#26426;&#33258;&#21160;&#29983;&#25104;/var/lib/docker/volumes/&lt;&#21367;ID&gt;/_data&#30446;&#24405;,&#24182;&#25346;&#36733;&#33267;&#23481;&#22120;&#25351;&#23450;&#36335;&#24452;
</span>-v &lt;&#23481;&#22120;&#20869;&#36335;&#24452;&gt;

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#31034;&#20363;:
</span>docker run --name nginx -v /etc/nginx nginx
</pre>
</div>

<p>
方式3<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#21629;&#21517;&#21367;&#23558;&#22266;&#23450;&#30340;&#23384;&#25918;&#22312;/var/lib/docker/volumes/&lt;&#21367;&#21517;&gt;/_data
</span>-v &lt;&#21367;&#21517;&gt;:&lt;&#23481;&#22120;&#30446;&#24405;&#36335;&#24452;&gt;

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21487;&#20197;&#36890;&#36807;&#20197;&#19979;&#21629;&#20196;&#20107;&#20808;&#21019;&#24314;,&#22914;&#21487;&#27809;&#26377;&#20107;&#20808;&#21019;&#24314;&#21367;&#21517;,docker run&#26102;&#20063;&#20250;&#33258;&#21160;&#21019;&#24314;&#21367;
</span>docker volume create &lt;&#21367;&#21517;&gt;

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#31034;&#20363;:
</span>docker run -d -p 80:80 --name nginx01 -v vol1:/usr/share/nginx/html nginx
</pre>
</div>

<p>
<b>docker rm 的 -v 选项可以删除容器时，同时删除相关联的匿名卷</b><br>
</p>
<div class="org-src-container">
<pre class="src src-shell">-v, --volumes Remove the volumes associated with the container
</pre>
</div>


<p>
<b>管理卷命令</b><br>
</p>

<div class="org-src-container">
<pre class="src src-shell">docker volume COMMAND

Commands:
  create Create a volume
  inspect Display detailed information on one or more volumes
  ls List volumes
  prune Remove all unused local volumes
  rm Remove one or more volumes
</pre>
</div>

<p>
查看数据卷的挂载关系<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker inspect --format=<span style="color: #8b2252;">"{{.Mounts}}"</span> &lt;&#23481;&#22120;ID&gt;
</pre>
</div>

<p>
范例: 删除所有数据卷<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker volume rm <span style="color: #ff00ff;">`docker volume ls -q`</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-h:f2f63b8d-856a-45a0-b10d-e304f3b64ff3" class="outline-3">
<h3 id="h:f2f63b8d-856a-45a0-b10d-e304f3b64ff3">数据卷容器</h3>
<div class="outline-text-3" id="text-h:f2f63b8d-856a-45a0-b10d-e304f3b64ff3">
</div>
<div id="outline-container-h:bb5228fb-1c92-45bc-bfb6-265a2a0dd38a" class="outline-4">
<h4 id="h:bb5228fb-1c92-45bc-bfb6-265a2a0dd38a">数据卷容器介绍</h4>
<div class="outline-text-4" id="text-h:bb5228fb-1c92-45bc-bfb6-265a2a0dd38a">
<p>
在Dockerfile中创建的是匿名数据卷,无法直接实现多个容器之间共享数据<br>
</p>

<p>
数据卷容器最大的功能是可以让数据在多个docker容器之间共享<br>
</p>
</div>
</div>
<div id="outline-container-h:241eb79b-6a07-46a0-b0cb-496c794f8f66" class="outline-4">
<h4 id="h:241eb79b-6a07-46a0-b0cb-496c794f8f66">使用数据卷容器</h4>
<div class="outline-text-4" id="text-h:241eb79b-6a07-46a0-b0cb-496c794f8f66">
<p>
启动容器时，指定使用数据卷容器<br>
</p>

<p>
docker run 命令的以下选项可以实现数据卷容器，格式如下:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">--volumes-from &lt;&#25968;&#25454;&#21367;&#23481;&#22120;&gt; Mount volumes from the specified container(s)
</pre>
</div>
</div>
</div>
<div id="outline-container-h:b0e73366-12e0-4898-842b-58afe4f0cc64" class="outline-4">
<h4 id="h:b0e73366-12e0-4898-842b-58afe4f0cc64">利用数据卷容器备份指定容器的数据卷实现</h4>
<div class="outline-text-4" id="text-h:b0e73366-12e0-4898-842b-58afe4f0cc64">
<p>
由于匿名数据卷在宿主机中的存储位置不确定,所以为了方便的备份匿名数据卷,可以利用数据卷容器实现数据卷的备份<br>
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#22312;&#25191;&#34892;&#22791;&#20221;&#21629;&#20196;&#23481;&#22120;&#19978;&#25191;&#34892;&#22791;&#20221;&#26041;&#24335;
</span>docker run -it --rm --volumes-from [container name] -v $(<span style="color: #483d8b;">pwd</span>):/backup ubuntu
root@ca5bb2c1f877:/#tar cvf /backup/backup.tar [container data volume]

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#35828;&#26126;
</span>[container name] <span style="color: #b22222;">#</span><span style="color: #b22222;">&#34920;&#31034;&#38656;&#35201;&#22791;&#20221;&#30340;&#23481;&#22120;
</span>[container data volume] <span style="color: #b22222;">#</span><span style="color: #b22222;">&#34920;&#31034;&#23481;&#22120;&#20869;&#30340;&#38656;&#35201;&#22791;&#20221;&#30340;&#25968;&#25454;&#21367;&#23545;&#24212;&#30340;&#30446;&#24405;
</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#36824;&#21407;&#26041;&#24335;
</span>docker run -it --rm --volumes-from [container name] -V $(<span style="color: #483d8b;">pwd</span>):/backup ubuntu
root@ca5bb2c1f877:/#tar xvf /backup/backup.tar -C [container data volume]
</pre>
</div>
</div>
</div>
<div id="outline-container-h:68bae616-c0ae-4cf4-bd88-4a01abcf6daa" class="outline-4">
<h4 id="h:68bae616-c0ae-4cf4-bd88-4a01abcf6daa">数据卷容器总结</h4>
<div class="outline-text-4" id="text-h:68bae616-c0ae-4cf4-bd88-4a01abcf6daa">
<p>
将提供卷的容器Server 删除，已经运行的容器Client依然可以使用挂载的卷，因为容器是通过挂载访问数据的，但是无法创建新的卷容器客户端，但是再把卷容器Server创建后即可正常创建卷容器Client，此方式可以用于线上共享数据目录等环境，因为即使数据卷容器被删除了，其他已经运行的容器依然可以挂载使用<br>
</p>

<p>
由此可知, 数据卷容器的功能只是将数据挂载信息传递给了其它使用数据卷容器的容器,而数据卷容器本身并不提供数据存储功能<br>
</p>

<p>
数据卷容器可以作为共享的方式为其他容器提供文件共享，类似于NFS共享，可以在生产中启动一个实例挂载本地的目录，然后其他的容器分别挂载此容器的目录，即可保证各容器之间的数据一致性<br>
</p>

<p>
数据卷容器的 Server 和 Client 可以不使用同一个镜像生成<br>
</p>
</div>
</div>
</div>
</section>
<section id="outline-container-h:d3e49a63-5d25-4181-9af3-48d264da9ac2" class="outline-2">
<h2 id="h:d3e49a63-5d25-4181-9af3-48d264da9ac2">网络管理</h2>
<div class="outline-text-2" id="text-h:d3e49a63-5d25-4181-9af3-48d264da9ac2">
<p>
docker容器创建后，必不可少的要和其它主机或容器进行网络通信<br>
</p>

<p>
官方文档: <a href="https://docs.docker.com/network/">https://docs.docker.com/network/</a><br>
</p>
</div>
<div id="outline-container-h:86dc7cfe-8eb0-4f69-bb2c-48b190f82bd8" class="outline-3">
<h3 id="h:86dc7cfe-8eb0-4f69-bb2c-48b190f82bd8">Docker的默认的网络通信</h3>
<div class="outline-text-3" id="text-h:86dc7cfe-8eb0-4f69-bb2c-48b190f82bd8">
</div>
<div id="outline-container-h:b4cd889a-7d77-4bfc-960a-549070e810c2" class="outline-4">
<h4 id="h:b4cd889a-7d77-4bfc-960a-549070e810c2">Docker安装后默认的网络设置</h4>
<div class="outline-text-4" id="text-h:b4cd889a-7d77-4bfc-960a-549070e810c2">
</div>
</div>
<div id="outline-container-h:476b1eb7-63ef-4d58-a347-e799593e6a9c" class="outline-4">
<h4 id="h:476b1eb7-63ef-4d58-a347-e799593e6a9c">创建容器后的网络配置</h4>
<div class="outline-text-4" id="text-h:476b1eb7-63ef-4d58-a347-e799593e6a9c">
<p>
每次新建容器后<br>
</p>
<ul class="org-ul">
<li>宿主机多了一个虚拟网卡，和容器的网卡组合成一个网卡，比如: 137: veth8ca6d43@if136，而在容器内的网卡名为136，可以看出和宿主机的网卡之间的关联<br></li>
<li>容器会自动获取一个172.17.0.0/16网段的随机地址，默认从172.17.0.2开始，第二次容器为172.17.0.3，以此类推<br></li>
<li>容器获取的地址并不固定,每次容器重启,可能会发生地址变化<br></li>
</ul>

<p>
创建容器后的网络状态<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">brctl show

&#20363;&#65306;
[root@ubuntu1804 ~]#brctl show
bridge name bridge id STP enabled interfaces
docker0 8000.0242027fa8c6 no veth8ca6d43
                             vethf599a47
</pre>
</div>
</div>
</div>
<div id="outline-container-h:47c476ac-d197-4b8c-a52b-9a4e7bca7a67" class="outline-4">
<h4 id="h:47c476ac-d197-4b8c-a52b-9a4e7bca7a67">容器间的通信</h4>
<div class="outline-text-4" id="text-h:47c476ac-d197-4b8c-a52b-9a4e7bca7a67">
</div>
<div id="outline-container-h:96ea34b8-c2ba-448c-bca2-a052652c28fc" class="outline-5">
<h5 id="h:96ea34b8-c2ba-448c-bca2-a052652c28fc">同一个宿主机的不同容器可相互通信</h5>
<div class="outline-text-5" id="text-h:96ea34b8-c2ba-448c-bca2-a052652c28fc">
<p>
默认情况下<br>
</p>
<ul class="org-ul">
<li>同一个宿主机的不同容器之间可以相互通信<br></li>
</ul>
<div class="org-src-container">
<pre class="src src-shell">dockerd --icc Enable inter-container communication (default true)
--icc=false <span style="color: #b22222;">#</span><span style="color: #b22222;">&#27492;&#37197;&#32622;&#21487;&#20197;&#31105;&#27490;&#21516;&#19968;&#20010;&#23487;&#20027;&#26426;&#30340;&#23481;&#22120;&#20043;&#38388;&#36890;&#20449;</span>
</pre>
</div>
<ul class="org-ul">
<li>不同宿主机之间的容器IP地址重复，默认不能相互通信<br></li>
</ul>
</div>
</div>
<div id="outline-container-h:95633594-80ca-440a-ab01-b705d7873081" class="outline-5">
<h5 id="h:95633594-80ca-440a-ab01-b705d7873081">禁止同一个宿主机的不同容器间通信</h5>
<div class="outline-text-5" id="text-h:95633594-80ca-440a-ab01-b705d7873081">
<p>
范例: 同一个宿主机不同容器间禁止通信<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#vim /lib/systemd/system/docker.service
<span style="color: #a0522d;">ExecStart</span>=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --icc=false

[root@ubuntu1804 ~]#systemctl daemon-reload
[root@ubuntu1804 ~]#systemctl restart docker

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21019;&#24314;&#20004;&#20010;&#23481;&#22120;,&#27979;&#35797;&#26080;&#27861;&#36890;&#20449;
</span>[root@ubuntu1804 ~]#docker run -it --name test1 --rm alpine sh
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">hostname -i
</span>172.17.0.2
[root@ubuntu1804 ~]#docker run -it --name test2 --rm alpine sh
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">hostname -i
</span>172.17.0.3
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping 172.17.0.2</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:e1ab5a16-19dd-48ec-a0da-2f73e5dfd601" class="outline-4">
<h4 id="h:e1ab5a16-19dd-48ec-a0da-2f73e5dfd601">修改默认网络设置</h4>
<div class="outline-text-4" id="text-h:e1ab5a16-19dd-48ec-a0da-2f73e5dfd601">
<p>
新建容器默认使用docker0的网络配置,可以修改默认指向自定义的网桥网络<br>
</p>

<p>
范例: 用自定义的网桥代替默认的docker0<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#26597;&#30475;&#40664;&#35748;&#32593;&#32476;
</span>[root@ubuntu1804 ~]#ip a

[root@ubuntu1804 ~]#apt -y install bridge-utils
[root@ubuntu1804 ~]#brctl addbr br0
[root@ubuntu1804 ~]#ip a a 192.168.100.1/24 dev br0
[root@ubuntu1804 ~]#brctl show
bridge name bridge id STP enabled interfaces
br0 8000.000000000000 no
docker0 8000.024235bae7ce no

[root@ubuntu1804 ~]#ip a
[root@ubuntu1804 ~]#vim /lib/systemd/system/docker.service
<span style="color: #a0522d;">ExecStart</span>=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock -b br0
[root@ubuntu1804 ~]#systemctl daemon-reload
[root@ubuntu1804 ~]#systemctl restart docker

[root@ubuntu1804 ~]#docker run --rm alpine hostname -i
192.168.100.2
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:08c2de2e-a33b-4113-9c79-60e95529a593" class="outline-3">
<h3 id="h:08c2de2e-a33b-4113-9c79-60e95529a593">容器名称互联</h3>
<div class="outline-text-3" id="text-h:08c2de2e-a33b-4113-9c79-60e95529a593">
<p>
新建容器时，docker会自动分配容器名称，容器ID和IP地址，导致容器名称，容器ID和IP都不固定，那么如何区分不同的容器，实现和确定目标容器的通信呢？解决方案是给容器起个固定的名称，容器之间通过固定名称实现确定目标的通信<br>
</p>

<p>
有两种固定名称:<br>
</p>
<ul class="org-ul">
<li>容器名称<br></li>
<li>容器名称的别名<br></li>
</ul>

<p>
注意: 两种方式都最少需要两个容器才能实现<br>
</p>
</div>
<div id="outline-container-h:c9c0f775-1d08-453e-8e79-2b57e5e268a6" class="outline-4">
<h4 id="h:c9c0f775-1d08-453e-8e79-2b57e5e268a6">通过容器名称互联</h4>
<div class="outline-text-4" id="text-h:c9c0f775-1d08-453e-8e79-2b57e5e268a6">
</div>
<div id="outline-container-h:32fb82ad-8f73-45ad-b695-f5c562b2df6a" class="outline-5">
<h5 id="h:32fb82ad-8f73-45ad-b695-f5c562b2df6a">容器名称介绍</h5>
<div class="outline-text-5" id="text-h:32fb82ad-8f73-45ad-b695-f5c562b2df6a">
<p>
即在同一个宿主机上的容器之间可以通过自定义的容器名称相互访问，比如: 一个业务前端静态页面是使用nginx，动态页面使用的是tomcat，另外还需要负载均衡调度器，如: haproxy 对请求调度至nginx和tomcat的容器，由于容器在启动的时候其内部IP地址是DHCP 随机分配的，而给容器起个固定的名称，则是相对比较固定的，因此比较适用于此场景<br>
</p>

<p>
<b>注意: 如果被引用的容器地址变化,必须重启当前容器才能生效</b><br>
</p>
</div>
</div>
<div id="outline-container-h:c4e39b62-8073-4dcc-a1a5-14f81d9d8d06" class="outline-5">
<h5 id="h:c4e39b62-8073-4dcc-a1a5-14f81d9d8d06">容器名称实现</h5>
<div class="outline-text-5" id="text-h:c4e39b62-8073-4dcc-a1a5-14f81d9d8d06">
<p>
docker run 创建容器，可使用&#x2013;link选项实现容器名称的引用<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">--link list <span style="color: #b22222;">#</span><span style="color: #b22222;">Add link to another container
</span>
&#26684;&#24335;:
docker run --name &lt;&#23481;&#22120;&#21517;&#31216;&gt; <span style="color: #b22222;">#</span><span style="color: #b22222;">&#20808;&#21019;&#24314;&#25351;&#23450;&#21517;&#31216;&#30340;&#23481;&#22120;
</span>docker run --link &lt;&#30446;&#26631;&#36890;&#20449;&#30340;&#23481;&#22120;ID&#25110;&#23481;&#22120;&#21517;&#31216;&gt; <span style="color: #b22222;">#</span><span style="color: #b22222;">&#20877;&#21019;&#24314;&#23481;&#22120;&#26102;&#24341;&#29992;&#19978;&#38754;&#23481;&#22120;&#30340;&#21517;&#31216;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-h:582aa1f4-f83a-4a01-8e03-294d733682ab" class="outline-5">
<h5 id="h:582aa1f4-f83a-4a01-8e03-294d733682ab">实战案例1: 使用容器名称进行容器间通信</h5>
<div class="outline-text-5" id="text-h:582aa1f4-f83a-4a01-8e03-294d733682ab">
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">1. &#20808;&#21019;&#24314;&#31532;&#19968;&#20010;&#25351;&#23450;&#23481;&#22120;&#21517;&#31216;&#30340;&#23481;&#22120;
</span>[root@ubuntu1804 ~]#docker run -it --name server1 --rm alpine:3.11 sh
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">cat /etc/hosts
</span>172.17.0.2 cdb5173003f5

/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping 172.17.0.2
</span>PING 172.17.0.2 (172.17.0.2): 56 data bytes
64 bytes from 172.17.0.2: <span style="color: #a0522d;">seq</span>=0 <span style="color: #a0522d;">ttl</span>=64 <span style="color: #a0522d;">time</span>=0.038 ms
^C

/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping server1
</span>ping: bad address <span style="color: #8b2252;">'server1'</span>
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping cdb5173003f5
</span>PING cdb5173003f5 (172.17.0.2): 56 data bytes
64 bytes from 172.17.0.2: <span style="color: #a0522d;">seq</span>=0 <span style="color: #a0522d;">ttl</span>=64 <span style="color: #a0522d;">time</span>=0.040 ms
64 bytes from 172.17.0.2: <span style="color: #a0522d;">seq</span>=1 <span style="color: #a0522d;">ttl</span>=64 <span style="color: #a0522d;">time</span>=0.128 ms
^C

<span style="color: #b22222;">#</span><span style="color: #b22222;">2. &#26032;&#24314;&#31532;&#20108;&#20010;&#23481;&#22120;&#26102;&#24341;&#29992;&#31532;&#19968;&#20010;&#23481;&#22120;&#30340;&#21517;&#31216;
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">&#20250;&#33258;&#21160;&#23558;&#31532;&#19968;&#20010;&#20027;&#26426;&#30340;&#21517;&#31216;&#21152;&#20837;/etc/hosts&#25991;&#20214;,&#20174;&#32780;&#21487;&#20197;&#21033;&#29992;&#31532;&#19968;&#20010;&#23481;&#22120;&#21517;&#31216;&#36827;&#34892;&#35775;&#38382;
</span>[root@ubuntu1804 ~]#docker run -it --rm --name server2 --link server1 alpine:3.11 sh
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">env
</span><span style="color: #a0522d;">HOSTNAME</span>=395d8c3392ee
<span style="color: #a0522d;">SHLVL</span>=1
<span style="color: #a0522d;">HOME</span>=/root
<span style="color: #a0522d;">TERM</span>=xterm
<span style="color: #a0522d;">SERVER1_NAME</span>=/server2/server1
<span style="color: #a0522d;">PATH</span>=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
<span style="color: #a0522d;">PWD</span>=/

/ <span style="color: #b22222;"># </span><span style="color: #b22222;">cat /etc/hosts
</span>172.17.0.2 server1 cdb5173003f5
172.17.0.3 7ca466320980

/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping server1
</span>PING server1 (172.17.0.2): 56 data bytes
64 bytes from 172.17.0.2: <span style="color: #a0522d;">seq</span>=0 <span style="color: #a0522d;">ttl</span>=64 <span style="color: #a0522d;">time</span>=0.111 ms
^C
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping server2
</span>ping: bad address <span style="color: #8b2252;">'server2'</span>
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping 7ca466320980
</span>PING 7ca466320980 (172.17.0.3): 56 data bytes
64 bytes from 172.17.0.3: <span style="color: #a0522d;">seq</span>=0 <span style="color: #a0522d;">ttl</span>=64 <span style="color: #a0522d;">time</span>=0.116 ms4.2.1.4
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping cdb5173003f5
</span>PING cdb5173003f5 (172.17.0.2): 56 data bytes
64 bytes from 172.17.0.2: <span style="color: #a0522d;">seq</span>=0 <span style="color: #a0522d;">ttl</span>=64 <span style="color: #a0522d;">time</span>=0.072 ms
^C
</pre>
</div>
</div>
</div>
<div id="outline-container-h:314518cf-2b3e-4cf8-9092-9658626c2695" class="outline-5">
<h5 id="h:314518cf-2b3e-4cf8-9092-9658626c2695">实战案例2: 实现 wordpress 和 MySQL 两个容器互连</h5>
<div class="outline-text-5" id="text-h:314518cf-2b3e-4cf8-9092-9658626c2695">
<div class="org-src-container">
<pre class="src src-shell">[root@centos7 ~]#tree lamp_docker/
lamp_docker/
&#9500;&#9472;&#9472; env_mysql.list
&#9500;&#9472;&#9472; env_wordpress.list
&#9492;&#9472;&#9472; mysql
   &#9492;&#9472;&#9472; mysql_test.cnf

[root@centos7 ~]#cat lamp_docker/env_mysql.list
<span style="color: #a0522d;">MYSQL_ROOT_PASSWORD</span>=123456
<span style="color: #a0522d;">MYSQL_DATABASE</span>=wordpress
<span style="color: #a0522d;">MYSQL_USER</span>=wpuser
<span style="color: #a0522d;">MYSQL_PASSWORD</span>=wppass
[root@centos7 ~]#cat lamp_docker/env_wordpress.list
<span style="color: #a0522d;">WORDPRESS_DB_HOST</span>=mysql:3306
<span style="color: #a0522d;">WORDPRESS_DB_NAME</span>=wordpress
<span style="color: #a0522d;">WORDPRESS_DB_USER</span>=wpuser
<span style="color: #a0522d;">WORDPRESS_DB_PASSWORD</span>=wppass
<span style="color: #a0522d;">WORDPRESS_TABLE_PREFIX</span>=wp_
[root@centos7 ~]#cat lamp_docker/mysql/mysql_test.cnf
[mysqld]
server-id=100
log-bin=mysql-bin

[root@centos7 ~]#docker run --name mysql -v /root/lamp_docker/mysql/:/etc/mysql/conf.d -v /data/mysql:/var/lib/mysql --envfile=/root/lamp_docker/env_mysql.list -d -p 3306:3306 mysql:5.7.30

[root@centos7 ~]#docker run -d --name wordpress --link mysql --envfile=/root/lamp_docker/env_wordpress.list -p 80:80 wordpress
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:55ad9ca6-5a32-4a32-ae3e-3beb8db241a5" class="outline-4">
<h4 id="h:55ad9ca6-5a32-4a32-ae3e-3beb8db241a5">通过自定义容器别名互联</h4>
<div class="outline-text-4" id="text-h:55ad9ca6-5a32-4a32-ae3e-3beb8db241a5">
</div>
<div id="outline-container-h:e8d8dfb7-c374-48c4-8a06-c5447e58abb7" class="outline-5">
<h5 id="h:e8d8dfb7-c374-48c4-8a06-c5447e58abb7">容器别名介绍</h5>
<div class="outline-text-5" id="text-h:e8d8dfb7-c374-48c4-8a06-c5447e58abb7">
<p>
自定义的容器名称可能后期会发生变化，那么一旦名称发生变化，容器内程序之间也必须要随之发生变化，比如:程序通过固定的容器名称进行服务调用，但是容器名称发生变化之后再使用之前的名称肯定是无法成功调用，每次都进行更改的话又比较麻烦，因此可以使用自定义别名的方式解决，即容器名称可以随意更改，只要不更改别名即可<br>
</p>
</div>
</div>
<div id="outline-container-h:81eb0458-5a39-4143-ad07-ec25377be407" class="outline-5">
<h5 id="h:81eb0458-5a39-4143-ad07-ec25377be407">容器别名实现</h5>
<div class="outline-text-5" id="text-h:81eb0458-5a39-4143-ad07-ec25377be407">
<p>
命令格式:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker run --name &lt;&#23481;&#22120;&#21517;&#31216;&gt; <span style="color: #b22222;">#</span><span style="color: #b22222;">&#20808;&#21019;&#24314;&#25351;&#23450;&#21517;&#31216;&#30340;&#23481;&#22120;
</span>docker run -d --name &#23481;&#22120;&#21517;&#31216; --link &lt;&#30446;&#26631;&#23481;&#22120;&#21517;&#31216;&gt;:&lt;&#23481;&#22120;&#21035;&#21517;&gt; <span style="color: #b22222;">#</span><span style="color: #b22222;">&#32473;&#19978;&#38754;&#21019;&#24314;&#30340;&#23481;&#22120;&#36215;&#21035;&#21517;,&#26469;&#21019;&#24314;&#26032;&#23481;&#22120;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-h:050a5743-e519-497a-8015-7d3d6f259265" class="outline-5">
<h5 id="h:050a5743-e519-497a-8015-7d3d6f259265">实战案例: 使用容器别名</h5>
<div class="outline-text-5" id="text-h:050a5743-e519-497a-8015-7d3d6f259265">
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker run -it --rm --name server3 --link server1:server1-alias alpine:3.11 sh
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">env
</span><span style="color: #a0522d;">HOSTNAME</span>=395d8c3392ee
<span style="color: #a0522d;">SHLVL</span>=1
<span style="color: #a0522d;">HOME</span>=/root
<span style="color: #a0522d;">TERM</span>=xterm
SERVER1-ALIAS_NAME=/server3/server1-alias
<span style="color: #a0522d;">PATH</span>=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
<span style="color: #a0522d;">PWD</span>=/
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">cat /etc/hosts
</span>172.17.0.2 server1-alias cdb5173003f5 server1
172.17.0.4 d9622c6831f7
</pre>
</div>

<p>
范例: 创建第四个容器，引用前面创建的容器，并起多个别名<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker run -it --rm --name server4 --link server1:<span style="color: #8b2252;">"server1-alias1 server1-alias2"</span> alpine:3.11 sh
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">cat /etc/hosts
</span>172.17.0.2 server1-alias1 server1-alias2 cdb5173003f5 server1
172.17.0.5 db3d2f084c05
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-h:75416717-f815-4e66-b786-e2c35489c50c" class="outline-3">
<h3 id="h:75416717-f815-4e66-b786-e2c35489c50c">docker 网络连接模式</h3>
<div class="outline-text-3" id="text-h:75416717-f815-4e66-b786-e2c35489c50c">
</div>
<div id="outline-container-h:3e7a32cf-ee2c-408d-adcd-51273b29c6dc" class="outline-4">
<h4 id="h:3e7a32cf-ee2c-408d-adcd-51273b29c6dc">网络模式介绍</h4>
<div class="outline-text-4" id="text-h:3e7a32cf-ee2c-408d-adcd-51273b29c6dc">

<figure id="orga9a93c0">
<img src="./images/Snipaste_2023-04-28_06-59-14.png" alt="Snipaste_2023-04-28_06-59-14.png"><br>

</figure>

<p>
Docker 的网络支持5种网络模式:<br>
</p>
<ul class="org-ul">
<li>none<br></li>
<li>bridge<br></li>
<li>host<br></li>
<li>container<br></li>
<li>network-name<br></li>
</ul>

<p>
范例: 查看默认的网络模式<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker network ls
NETWORK ID NAME DRIVER SCOPE
fe08e6d23c4c bridge bridge local
cb64aa83626c host host local
10619d45dcd4 none null local
</pre>
</div>
</div>
</div>
<div id="outline-container-h:2aa8cd56-957b-4371-a9df-589141b64dc4" class="outline-4">
<h4 id="h:2aa8cd56-957b-4371-a9df-589141b64dc4">网络模式指定</h4>
<div class="outline-text-4" id="text-h:2aa8cd56-957b-4371-a9df-589141b64dc4">
<p>
默认新建的容器使用Bridge模式，创建容器时，docker run 命令使用以下选项指定网络模式<br>
</p>

<p>
格式<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker run --network &lt;mode&gt;
docker run --net=&lt;mode&gt;

&lt;mode&gt;: &#21487;&#26159;&#20197;&#19979;&#20540;
none
bridge
host
container:&lt;&#23481;&#22120;&#21517;&#25110;&#23481;&#22120;ID&gt;
&lt;&#33258;&#23450;&#20041;&#32593;&#32476;&#21517;&#31216;&gt;
</pre>
</div>
</div>
</div>
<div id="outline-container-h:e8bb08d9-bbe6-48ce-afb2-700e3aad9399" class="outline-4">
<h4 id="h:e8bb08d9-bbe6-48ce-afb2-700e3aad9399">bridge网络模式</h4>
<div class="outline-text-4" id="text-h:e8bb08d9-bbe6-48ce-afb2-700e3aad9399">
</div>
<div id="outline-container-h:1e3c1937-1f49-46e4-88df-e854f388cfdc" class="outline-5">
<h5 id="h:1e3c1937-1f49-46e4-88df-e854f388cfdc">bridge 网络模式架构</h5>
<div class="outline-text-5" id="text-h:1e3c1937-1f49-46e4-88df-e854f388cfdc">

<figure id="org4cabbeb">
<img src="./images/Snipaste_2023-04-28_07-02-18.png" alt="Snipaste_2023-04-28_07-02-18.png"><br>

</figure>

<p>
本模式是docker的默认模式，即不指定任何模式就是bridge模式，也是使用比较多的模式，此模式创建的容器会为每一个容器分配自己的网络 IP 等信息，并将容器连接到一个虚拟网桥与外界通信<br>
</p>


<figure id="org8739b4b">
<img src="./images/Snipaste_2023-04-28_07-03-09.png" alt="Snipaste_2023-04-28_07-03-09.png"><br>

</figure>

<p>
可以和外部网络之间进行通信，通过SNAT访问外网，使用DNAT可以让容器被外部主机访问，所以此模式也称为NAT模式<br>
</p>

<p>
此模式宿主机需要启动ip_forward功能<br>
</p>

<p>
bridge网络模式特点<br>
</p>
<ul class="org-ul">
<li>网络资源隔离: 不同宿主机的容器无法直接通信，各自使用独立网络<br></li>
<li>无需手动配置: 容器默认自动获取172.17.0.0/16的IP地址，此地址可以修改<br></li>
<li>可访问外网: 利用宿主机的物理网卡，SNAT连接外网<br></li>
<li>外部主机无法直接访问容器: 可以通过配置DNAT接受外网的访问<br></li>
<li>低性能较低: 因为可通过NAT，网络转换带来更的损耗<br></li>
<li>端口管理繁琐: 每个容器必须手动指定唯一的端口，容器产生端口冲容<br></li>
</ul>
</div>
</div>
<div id="outline-container-h:9c0fe615-6658-4110-8466-05fbaef4073c" class="outline-5">
<h5 id="h:9c0fe615-6658-4110-8466-05fbaef4073c">bridge 模式的默认设置</h5>
<div class="outline-text-5" id="text-h:9c0fe615-6658-4110-8466-05fbaef4073c">
<p>
范例: 查看bridge模式信息<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker network inspect bridge
[
    {
        <span style="color: #8b2252;">"Name"</span>: <span style="color: #8b2252;">"bridge"</span>,
        <span style="color: #8b2252;">"Id"</span>: <span style="color: #8b2252;">"387a0aec81eef455a5a9ff2ddc25bb4b146f4b4f47af376158ae3b08ea17dd28"</span>,
        <span style="color: #8b2252;">"Created"</span>: <span style="color: #8b2252;">"2023-03-20T15:19:05.883786416+08:00"</span>,
        <span style="color: #8b2252;">"Scope"</span>: <span style="color: #8b2252;">"local"</span>,
        <span style="color: #8b2252;">"Driver"</span>: <span style="color: #8b2252;">"bridge"</span>,
        <span style="color: #8b2252;">"EnableIPv6"</span>: false,
        <span style="color: #8b2252;">"IPAM"</span>: {
            <span style="color: #8b2252;">"Driver"</span>: <span style="color: #8b2252;">"default"</span>,
            <span style="color: #8b2252;">"Options"</span>: null,
            <span style="color: #8b2252;">"Config"</span>: [
                {
                    <span style="color: #8b2252;">"Subnet"</span>: <span style="color: #8b2252;">"172.17.0.0/16"</span>,
                    <span style="color: #8b2252;">"Gateway"</span>: <span style="color: #8b2252;">"172.17.0.1"</span>
                }
            ]
        },
        <span style="color: #8b2252;">"Internal"</span>: false,
        <span style="color: #8b2252;">"Attachable"</span>: false,
        <span style="color: #8b2252;">"Ingress"</span>: false,
        <span style="color: #8b2252;">"ConfigFrom"</span>: {
            <span style="color: #8b2252;">"Network"</span>: <span style="color: #8b2252;">""</span>
        },
        <span style="color: #8b2252;">"ConfigOnly"</span>: false,
        <span style="color: #8b2252;">"Containers"</span>: {
            <span style="color: #8b2252;">"f03c144e137e342c95609444cce311d3b9ab7a9a1eeb280de73a8b6bc4a7dada"</span>: {
                <span style="color: #8b2252;">"Name"</span>: <span style="color: #8b2252;">"buildx_buildkit_mutil-platform-builder0"</span>,
                <span style="color: #8b2252;">"EndpointID"</span>: <span style="color: #8b2252;">"9a86768b0b8323596bcc1c476e514fab06a089e7311579593d28e2b2a2d172da"</span>,
                <span style="color: #8b2252;">"MacAddress"</span>: <span style="color: #8b2252;">"02:42:ac:11:00:02"</span>,
                <span style="color: #8b2252;">"IPv4Address"</span>: <span style="color: #8b2252;">"172.17.0.2/16"</span>,
                <span style="color: #8b2252;">"IPv6Address"</span>: <span style="color: #8b2252;">""</span>
            }
        },
        <span style="color: #8b2252;">"Options"</span>: {
            <span style="color: #8b2252;">"com.docker.network.bridge.default_bridge"</span>: <span style="color: #8b2252;">"true"</span>,
            <span style="color: #8b2252;">"com.docker.network.bridge.enable_icc"</span>: <span style="color: #8b2252;">"true"</span>,
            <span style="color: #8b2252;">"com.docker.network.bridge.enable_ip_masquerade"</span>: <span style="color: #8b2252;">"true"</span>,
            <span style="color: #8b2252;">"com.docker.network.bridge.host_binding_ipv4"</span>: <span style="color: #8b2252;">"0.0.0.0"</span>,
            <span style="color: #8b2252;">"com.docker.network.bridge.name"</span>: <span style="color: #8b2252;">"docker0"</span>,
            <span style="color: #8b2252;">"com.docker.network.driver.mtu"</span>: <span style="color: #8b2252;">"1500"</span>
        },
        <span style="color: #8b2252;">"Labels"</span>: {}
    }
]
</pre>
</div>


<p>
范例: 宿主机的网络状态<br>
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#23433;&#35013;docker&#21518;.&#40664;&#35748;&#21551;&#29992;ip_forward
</span>[root@ubuntu1804 ~]#cat /proc/sys/net/ipv4/ip_forward
1
[root@ubuntu1804 ~]#iptables -vnL -t nat
Chain PREROUTING (policy ACCEPT 1532K packets, 92M bytes)
 pkts bytes target     prot opt<span style="color: #a020f0;"> in</span>     out     source               destination
1475K   89M DOCKER     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL

Chain INPUT (policy ACCEPT 1475K packets, 89M bytes)
 pkts bytes target     prot opt<span style="color: #a020f0;"> in</span>     out     source               destination

Chain OUTPUT (policy ACCEPT 1111K packets, 82M bytes)
 pkts bytes target     prot opt<span style="color: #a020f0;"> in</span>     out     source               destination
   39  3276 DOCKER     all  --  *      *       0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCAL

Chain POSTROUTING (policy ACCEPT 1111K packets, 82M bytes)
 pkts bytes target     prot opt<span style="color: #a020f0;"> in</span>     out     source               destination
56721 3877K MASQUERADE  all  --  *      !docker0  172.17.0.0/16        0.0.0.0/0

Chain DOCKER (2 references)
 pkts bytes target     prot opt<span style="color: #a020f0;"> in</span>     out     source               destination
    0     0 RETURN     all  --  docker0 *       0.0.0.0/0            0.0.0.0/0
</pre>
</div>

<p>
范例: 通过宿主机的物理网卡利用SNAT访问外部网络<br>
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#22312;&#21478;&#19968;&#21488;&#20027;&#26426;&#19978;&#24314;&#31435;httpd&#26381;&#21153;&#22120;
</span>[root@centos7 ~]#systemctl is-active httpd
active
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21551;&#21160;&#23481;&#22120;&#65292;&#40664;&#35748;&#26159;bridge&#32593;&#32476;&#27169;&#24335;
</span>[root@ubuntu1804 ~]#docker run -it --rm alpine:3.11 sh
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ip a
</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21487;&#33021;&#35775;&#38382;&#20854;&#23427;&#23487;&#20027;&#26426;
</span>/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping 10.0.0.7
</span>PING 10.0.0.7 (10.0.0.7): 56 data bytes
64 bytes from 10.0.0.7: <span style="color: #a0522d;">seq</span>=1 <span style="color: #a0522d;">ttl</span>=63 <span style="color: #a0522d;">time</span>=1.147 ms
^C
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping www.baidu.com
</span>PING www.baidu.com (61.135.169.125): 56 data bytes
64 bytes from 61.135.169.125: <span style="color: #a0522d;">seq</span>=0 <span style="color: #a0522d;">ttl</span>=127 <span style="color: #a0522d;">time</span>=5.182 ms
^C
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">traceroute 10.0.0.7
</span>traceroute to 10.0.0.7 (10.0.0.7), 30 hops max, 46 byte packets
1 172.17.0.1 (172.17.0.1) 0.008 ms 0.008 ms 0.007 ms
2 10.0.0.7 (10.0.0.7) 0.255 ms 0.510 ms 0.798 ms
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">wget -qO - 10.0.0.7
</span>Website on 10.0.0.7
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">route -n
</span>Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         172.17.0.1     0.0.0.0         UG    0      0        0 eth0
172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0

[root@centos7 ~]#curl 127.0.0.1
Website on 10.0.0.7
[root@centos7 ~]#tail /var/log/httpd/access_log
127.0.0.1 - - [01/Feb/2020:19:31:16 +0800] <span style="color: #8b2252;">"GET / HTTP/1.1"</span> 200 20 <span style="color: #8b2252;">"-"</span>
<span style="color: #8b2252;">"curl/7.29.0"</span>
10.0.0.100 - - [01/Feb/2020:19:31:21 +0800] <span style="color: #8b2252;">"GET / HTTP/1.1"</span> 200 20 <span style="color: #8b2252;">"-"</span> <span style="color: #8b2252;">"Wget"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-h:c5f65636-91b8-4a79-9cc8-276d69dd6c35" class="outline-5">
<h5 id="h:c5f65636-91b8-4a79-9cc8-276d69dd6c35">修改默认的 bridge 模式网络配置</h5>
<div class="outline-text-5" id="text-h:c5f65636-91b8-4a79-9cc8-276d69dd6c35">
<p>
范例: 修改bridge模式默认的网段方法1<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#ip a
3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state
inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0

[root@ubuntu1804 ~]#docker run -it --rm alpine sh
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ip a
</span>4: eth0@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue
inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
/ <span style="color: #b22222;">#</span><span style="color: #b22222;">exit
</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#20462;&#25913;&#26725;&#25509;&#22320;&#22336;
</span>[root@ubuntu1804 ~]#vim /lib/systemd/system/docker.service
<span style="color: #a0522d;">ExecStart</span>=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --bip=10.100.0.1/24

[root@ubuntu1804 ~]#systemctl daemon-reload
[root@ubuntu1804 ~]#systemctl restart docker

[root@ubuntu1804 ~]#ip a
3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state
inet 10.100.0.1/24 brd 10.100.0.255 scope global docker0
[root@ubuntu1804 ~]#docker run -it --rm alpine sh
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ip a
</span>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000
[root@ubuntu1804 ~]#docker network inspect bridge
</pre>
</div>


<p>
范例: 修改bridge网络配置方法2<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#vim /etc/docker/daemon.json
{
<span style="color: #8b2252;">"hosts"</span>: [<span style="color: #8b2252;">"tcp://0.0.0.0:2375"</span>, <span style="color: #8b2252;">"fd://"</span>],
<span style="color: #8b2252;">"bip"</span>: <span style="color: #8b2252;">"192.168.100.100/24"</span>, <span style="color: #b22222;">#</span><span style="color: #b22222;">&#20998;&#37197;docker0&#32593;&#21345;&#30340;IP,24&#26159;&#23481;&#22120;IP&#30340;netmask
</span><span style="color: #8b2252;">"fixed-cidr"</span>: <span style="color: #8b2252;">"192.168.100.128/26"</span>, <span style="color: #b22222;">#</span><span style="color: #b22222;">&#20998;&#37197;&#23481;&#22120;IP&#33539;&#22260;,26&#19981;&#26159;&#23481;&#22120;IP&#30340;&#23376;&#32593;&#25513;&#30721;,&#21482;&#34920;&#31034;&#22320;&#22336;&#33539;&#22260;
</span><span style="color: #8b2252;">"fixed-cidr-v6"</span>: <span style="color: #8b2252;">"2001:db8::/64"</span>,
<span style="color: #8b2252;">"mtu"</span>: 1500,
<span style="color: #8b2252;">"default-gateway"</span>: <span style="color: #8b2252;">"192.168.100.200"</span>, <span style="color: #b22222;">#</span><span style="color: #b22222;">&#32593;&#20851;&#24517;&#39035;&#21644;bip&#22312;&#21516;&#19968;&#20010;&#32593;&#27573;
</span><span style="color: #8b2252;">"default-gateway-v6"</span>: <span style="color: #8b2252;">"2001:db8:abcd::89"</span>,
<span style="color: #8b2252;">"dns"</span>: [ <span style="color: #8b2252;">"1.1.1.1"</span>, <span style="color: #8b2252;">"8.8.8.8"</span>]
}

[root@ubuntu1804 ~]#systemctl restart docker

[root@ubuntu1804 ~]#ip a show docker0
3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP
inet 192.168.100.100/24 brd 192.168.100.255 scope global docker0
valid_lft forever preferred_lft forever
inet6 fe80::42:23ff:febe:9775/64 scope link

[root@ubuntu1804 ~]#docker run -it --name b1 busybox
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ip a
</span>36: eth0@if37: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue
inet 192.168.100.128/24 brd 192.168.100.255 scope global eth0
valid_lft forever preferred_lft forever

/ <span style="color: #b22222;"># </span><span style="color: #b22222;">cat /etc/resolv.conf
</span>search xxx.com xxx.org
nameserver 1.1.1.1
nameserver 8.8.8.8
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">route -n
</span>Kernel IP routing table
Destination Gateway Genmask Flags Metric Ref Use Iface
0.0.0.0 192.168.100.200 0.0.0.0 UG 0 0 0 eth0
192.168.100.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0
[root@ubuntu1804 ~]#docker network inspect bridge
[
{
<span style="color: #8b2252;">"Name"</span>: <span style="color: #8b2252;">"bridge"</span>,
<span style="color: #8b2252;">"Id"</span>:
<span style="color: #8b2252;">"381bc2df514b0901e2a7570708aa93a3af05f298f27d4d077b52a8b324fad66c"</span>,
<span style="color: #8b2252;">"Created"</span>: <span style="color: #8b2252;">"2020-07-27T21:58:31.419420569+08:00"</span>,
<span style="color: #8b2252;">"Scope"</span>: <span style="color: #8b2252;">"local"</span>,
<span style="color: #8b2252;">"Driver"</span>: <span style="color: #8b2252;">"bridge"</span>,
<span style="color: #8b2252;">"EnableIPv6"</span>: false,
<span style="color: #8b2252;">"IPAM"</span>: {
<span style="color: #8b2252;">"Driver"</span>: <span style="color: #8b2252;">"default"</span>,
<span style="color: #8b2252;">"Options"</span>: null,
<span style="color: #8b2252;">"Config"</span>: [
{
<span style="color: #8b2252;">"Subnet"</span>: <span style="color: #8b2252;">"192.168.100.0/24"</span>,
<span style="color: #8b2252;">"IPRange"</span>: <span style="color: #8b2252;">"192.168.100.128/26"</span>,
<span style="color: #8b2252;">"Gateway"</span>: <span style="color: #8b2252;">"192.168.100.100"</span>,
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:e7008006-c411-4c72-b93e-da1c4c2fe52a" class="outline-4">
<h4 id="h:e7008006-c411-4c72-b93e-da1c4c2fe52a">Host 模式</h4>
<div class="outline-text-4" id="text-h:e7008006-c411-4c72-b93e-da1c4c2fe52a">

<figure id="org21ebd01">
<img src="./images/Snipaste_2023-04-28_10-44-53.png" alt="Snipaste_2023-04-28_10-44-53.png"><br>

</figure>

<p>
如果指定host模式启动的容器，那么新创建的容器不会创建自己的虚拟网卡，而是直接使用宿主机的网卡和IP地址，因此在容器里面查看到的IP信息就是宿主机的信息，访问容器的时候直接使用宿主机IP+容器端口即可，不过容器内除网络以外的其它资源，如: 文件系统、系统进程等仍然和宿主机保持隔离<br>
</p>

<p>
此模式由于直接使用宿主机的网络无需转换，网络性能最高，但是各容器内使用的端口不能相同，适用于运行容器端口比较固定的业务<br>
</p>

<p>
Host 网络模式特点:<br>
</p>
<ul class="org-ul">
<li>使用参数 &#x2013;network host 指定<br></li>
<li>共享宿主机网络<br></li>
<li>网络性能无损耗<br></li>
<li>网络故障排除相对简单<br></li>
<li>各容器网络无隔离<br></li>
<li>网络资源无法分别统计<br></li>
<li>端口管理困难: 容易产生端口冲突<br></li>
<li>不支持端口映射<br></li>
</ul>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#26597;&#30475;&#23487;&#20027;&#26426;&#30340;&#32593;&#32476;&#35774;&#32622;
</span>[root@ubuntu1804 ~]#ifconfig

[root@ubuntu1804 ~]#route -n
Kernel IP routing table
Destination Gateway Genmask Flags Metric Ref Use Iface
0.0.0.0 10.0.0.2 0.0.0.0 UG 0 0 0 eth0
10.0.0.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0
172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker0

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#25171;&#24320;&#23481;&#22120;&#21069;&#30830;&#35748;&#23487;&#20027;&#26426;&#30340;80/tcp&#31471;&#21475;&#27809;&#26377;&#25171;&#24320;
</span>[root@ubuntu1804 ~]#ss -ntl|grep :80

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21019;&#24314;host&#27169;&#24335;&#30340;&#23481;&#22120;
</span>[root@ubuntu1804 ~]#docker run -d --network host --name web1 nginx-centos7-base:1.6.1

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21019;&#24314;&#23481;&#22120;&#21518;&#65292;&#23487;&#20027;&#26426;&#30340;80/tcp&#31471;&#21475;&#25171;&#24320;
</span>[root@ubuntu1804 ~]#ss -ntlp|grep :80
LISTEN 0 128 0.0.0.0:80 0.0.0.0:* users:((<span style="color: #8b2252;">"nginx"</span>,<span style="color: #a0522d;">pid</span>=43762,<span style="color: #a0522d;">fd</span>=6),(<span style="color: #8b2252;">"nginx"</span>,<span style="color: #a0522d;">pid</span>=43737,<span style="color: #a0522d;">fd</span>=6))

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#36827;&#20837;&#23481;&#22120;
</span>[root@ubuntu1804 ~]#docker exec -it web1 bash

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#36827;&#20837;&#23481;&#22120;&#21518;&#20173;&#26174;&#31034;&#23487;&#20027;&#26426;&#30340;&#20027;&#26426;&#21517;&#25552;&#31034;&#31526;&#20449;&#24687;
</span>[root@ubuntu1804 /]# hostname
ubuntu1804.xxx.org
[root@ubuntu1804 /]# ifconfig
[root@ubuntu1804 /]# route -n
Kernel IP routing table
Destination Gateway Genmask Flags Metric Ref Use Iface
0.0.0.0 10.0.0.2 0.0.0.0 UG 0 0 0 eth0
10.0.0.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0
172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker0

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#20174;&#23481;&#22120;&#35775;&#38382;&#36828;&#31243;&#20027;&#26426;
</span>[root@ubuntu1804 /]# curl 10.0.0.7
Website on 10.0.0.7

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26597;&#30475;&#36828;&#31243;&#20027;&#26426;&#30340;&#35775;&#38382;&#26085;&#24535;
</span>[root@centos7 ~]#tail -n1 /var/log/httpd/access_log
10.0.0.100 - - [01/Feb/2020:19:58:06 +0800] <span style="color: #8b2252;">"GET / HTTP/1.1"</span> 200 20 <span style="color: #8b2252;">"-"</span>
<span style="color: #8b2252;">"curl/7.29.0"</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#36828;&#31243;&#20027;&#26426;&#21487;&#20197;&#35775;&#38382;&#23481;&#22120;&#30340;web&#26381;&#21153;
</span>[root@centos7 ~]#curl 10.0.0.100/app/
Test Page<span style="color: #a020f0;"> in</span> app
</pre>
</div>
</div>
</div>
<div id="outline-container-h:16dcd838-0976-41b6-b072-9c9576c7a3e4" class="outline-4">
<h4 id="h:16dcd838-0976-41b6-b072-9c9576c7a3e4">none 模式</h4>
<div class="outline-text-4" id="text-h:16dcd838-0976-41b6-b072-9c9576c7a3e4">
<p>
在使用none 模式后，Docker 容器不会进行任何网络配置，没有网卡、没有IP也没有路由，因此默认无法与外界通信，需要手动添加网卡配置IP等，所以极少使用<br>
</p>

<p>
none模式特点<br>
</p>
<ul class="org-ul">
<li>使用参数 &#x2013;network none 指定<br></li>
<li>默认无网络功能，无法和外部通信<br></li>
</ul>
</div>
</div>
<div id="outline-container-h:ba00cd2f-211f-4cb3-bbe9-b4bbeff8888b" class="outline-4">
<h4 id="h:ba00cd2f-211f-4cb3-bbe9-b4bbeff8888b">Container 模式</h4>
<div class="outline-text-4" id="text-h:ba00cd2f-211f-4cb3-bbe9-b4bbeff8888b">

<figure id="orgf16cd3b">
<img src="./images/Snipaste_2023-04-28_10-52-31.png" alt="Snipaste_2023-04-28_10-52-31.png"><br>

</figure>

<p>
使用此模式创建的容器需指定和一个已经存在的容器共享一个网络，而不是和宿主机共享网，新创建的容器不会创建自己的网卡也不会配置自己的IP，而是和一个被指定的已经存在的容器共享IP和端口范围，因此这个容器的端口不能和被指定容器的端口冲突，除了网络之外的文件系统、进程信息等仍然保持相互隔离，两个容器的进程可以通过lo网卡进行通信<br>
</p>

<p>
Container 模式特点<br>
</p>
<ul class="org-ul">
<li>使用参数 –-network container:名称或ID 指定<br></li>
<li>与宿主机网络空间隔离<br></li>
<li>空器间共享网络空间<br></li>
<li>适合频繁的容器间的网络通信<br></li>
<li>直接使用对方的网络，较少使用<br></li>
</ul>

<p>
范例:<br>
#创建第一个容器<br>
[root@ubuntu1804 ~]#docker run -it &#x2013;name server1 -p 80:80 alpine:3.11 sh<br>
#创建第二个容器，基于第一个容器的container的网络模式<br>
[root@ubuntu1804 ~]#docker run -d &#x2013;name server2 &#x2013;network container:server1 nginx-centos7-base:1.6.1<br>
</p>


<p>
[root@ubuntu1804 ~]#docker exec -it server2 bash<br>
#和第一个容器共享相同的网络<br>
[root@4d342fac169f /]# netstat -ntl<br>
Active Internet connections (only servers)<br>
Proto Recv-Q Send-Q Local Address Foreign Address State<br>
tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN<br>
#可访问外网<br>
[root@4d342fac169f /]# ping www.baidu.com<br>
PING www.a.shifen.com (61.135.169.121) 56(84) bytes of data.<br>
64 bytes from 61.135.169.121 (61.135.169.121): icmp_seq=1 ttl=127 time=3.99 ms<br>
64 bytes from 61.135.169.121 (61.135.169.121): icmp_seq=2 ttl=127 time=5.03 ms<br>
^C<br>
</p>


<p>
范例: 第一个容器使用host网络模式,第二个容器与之共享网络<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker run -d --name c1 --network host nginxcentos7.8:v5.0-1.18.0
[root@ubuntu1804 ~]#docker run -it --name c2 --network container:c1 centos7.8:v1.0
[root@ubuntu1804 /]# ip a
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP
inet 10.0.0.100/24 brd 10.0.0.255 scope global eth0
3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state
inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0

[root@ubuntu1804 ~]#docker exec -it c1 bash
[root@ubuntu1804 /]# ip a
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP
inet 10.0.0.100/24 brd 10.0.0.255 scope global eth0
3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state
inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
</pre>
</div>
</div>
</div>
<div id="outline-container-h:14fd189f-db6f-44bc-a53f-439fd28222e8" class="outline-4">
<h4 id="h:14fd189f-db6f-44bc-a53f-439fd28222e8">自定义网络模式</h4>
<div class="outline-text-4" id="text-h:14fd189f-db6f-44bc-a53f-439fd28222e8">
<p>
除了以上的网络模式，也可以自定义网络，使用自定义的网段地址，网关等信息<br>
</p>

<p>
<b>注意: 自定义网络内的容器可以直接通过容器名进行相互的访问,而无需使用 &#x2013;link</b><br>
</p>

<p>
可以使用自定义网络模式,实现不同集群应用的独立网络管理,而互不影响,而且在网一个网络内,可以直接利用容器名相互访问非常便利<br>
</p>
</div>
<div id="outline-container-h:1367c1de-862f-43b3-a665-50993a05a961" class="outline-5">
<h5 id="h:1367c1de-862f-43b3-a665-50993a05a961">自定义网络实现</h5>
<div class="outline-text-5" id="text-h:1367c1de-862f-43b3-a665-50993a05a961">
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker network --help
Usage: docker network COMMAND

Manage networks

Commands:
    connect Connect a container to a network
    create Create a network
    disconnect Disconnect a container from a network
    inspect Display detailed information on one or more networks
    ls List networks
    prune Remove all unused networks
    rm Remove one or more networks
</pre>
</div>

<p>
创建自定义网络:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker network create -d &lt;mode&gt; --subnet &lt;CIDR&gt; --gateway &lt;&#32593;&#20851;&gt; &lt;&#33258;&#23450;&#20041;&#32593;&#32476;&#21517;&#31216;&gt;
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#27880;&#24847;mode&#19981;&#25903;&#25345;host&#21644;none</span>
</pre>
</div>

<p>
查看自定义网络信息<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker network inspect &lt;&#33258;&#23450;&#20041;&#32593;&#32476;&#21517;&#31216;&#25110;&#32593;&#32476;ID&gt;
</pre>
</div>

<p>
引用自定议网络<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker run --network &lt;&#33258;&#23450;&#20041;&#32593;&#32476;&#21517;&#31216;&gt; &lt;&#38236;&#20687;&#21517;&#31216;&gt;
</pre>
</div>

<p>
删除自定义网络<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">doccker network rm &lt;&#33258;&#23450;&#20041;&#32593;&#32476;&#21517;&#31216;&#25110;&#32593;&#32476;ID&gt;
</pre>
</div>
</div>
</div>
<div id="outline-container-h:4274d2d8-c17f-4978-8dbb-94f26012d892" class="outline-5">
<h5 id="h:4274d2d8-c17f-4978-8dbb-94f26012d892">实战案例: 自定义网络</h5>
<div class="outline-text-5" id="text-h:4274d2d8-c17f-4978-8dbb-94f26012d892">
<div class="org-src-container">
<pre class="src src-shell">1. &#21019;&#24314;&#33258;&#23450;&#20041;&#30340;&#32593;&#32476;
[root@ubuntu1804 ~]#docker network create -d bridge --subnet 172.27.0.0/16 --gateway 172.27.0.1 test-net

[root@ubuntu1804 ~]#docker network ls
NETWORK ID NAME DRIVER SCOPE
c90dee3b7937 test-net bridge local

[root@ubuntu1804 ~]#docker inspect test-net

[root@ubuntu1804 ~]#ip a
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26032;&#28155;&#21152;&#20102;&#19968;&#20010;&#34394;&#25311;&#32593;&#21345;
</span>14: br-c90dee3b7937: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue
inet 172.27.0.1/16 brd 172.27.255.255 scope global br-c90dee3b7937

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26032;&#21152;&#20102;&#19968;&#20010;&#32593;&#26725;
</span>[root@ubuntu1804 ~]#brctl show
bridge name bridge id STP enabled interfaces
br-00ab0f2d29e8 8000.024245e647ec no
docker0 8000.0242cfd26f0a no

[root@ubuntu1804 ~]#route -n
Kernel IP routing table
Destination Gateway Genmask Flags Metric Ref Use Iface
0.0.0.0 10.0.0.2 0.0.0.0 UG 0 0 0 eth0
10.0.0.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0
172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker0
172.27.0.0 0.0.0.0 255.255.0.0 U 0 0 0 brc90dee3b7937

2.&#21033;&#29992;&#33258;&#23450;&#20041;&#30340;&#32593;&#32476;&#21019;&#24314;&#23481;&#22120;
[root@ubuntu1804 ~]#docker run -it --rm --network test-net alpine sh
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ip a
</span>15: eth0@if16: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue
inet 172.27.0.2/16 brd 172.27.255.255 scope global eth0
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">/ # route -n
</span>Kernel IP routing table
Destination Gateway Genmask Flags Metric Ref Use Iface
0.0.0.0 172.27.0.1 0.0.0.0 UG 0 0 0 eth0
172.27.0.0 0.0.0.0 255.255.0.0 U 0 0 0 eth0

/ <span style="color: #b22222;"># </span><span style="color: #b22222;">cat /etc/resolv.conf
</span>search xxx.com xxx.org
nameserver 127.0.0.11
options ndots:0

/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping -c1 www.baidu.com
</span>PING www.baidu.com (111.206.223.172): 56 data bytes
64 bytes from 111.206.223.172: <span style="color: #a0522d;">seq</span>=0 <span style="color: #a0522d;">ttl</span>=127 <span style="color: #a0522d;">time</span>=5.053 ms

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#20877;&#24320;&#19968;&#20010;&#26032;&#32456;&#31471;&#31383;&#21475;&#26597;&#30475;&#32593;&#32476;
</span>[root@ubuntu1804 ~]#docker inspect test-net
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#20986;&#29616;&#27492;&#32593;&#32476;&#20013;&#23481;&#22120;&#30340;&#32593;&#32476;&#20449;&#24687;
</span><span style="color: #8b2252;">"Containers"</span>: {
<span style="color: #8b2252;">"89e54ed71c111ac7b41a62ce20191707cf53a3a234ba3e25ac11c1a4a6bed7ef"</span>:
{
<span style="color: #8b2252;">"Name"</span>: <span style="color: #8b2252;">"frosty_ellis"</span>,
<span style="color: #8b2252;">"EndpointID"</span>:
<span style="color: #8b2252;">"cf72bf192df73a8b290d8b18dd8507fef64a1f9480d4d65f74c23258d20dbafb"</span>,
<span style="color: #8b2252;">"MacAddress"</span>: <span style="color: #8b2252;">"02:42:ac:1b:00:02"</span>,
<span style="color: #8b2252;">"IPv4Address"</span>: <span style="color: #8b2252;">"172.27.0.2/16"</span>,
<span style="color: #8b2252;">"IPv6Address"</span>: <span style="color: #8b2252;">""</span>
}
},
<span style="color: #8b2252;">"Options"</span>: {},
<span style="color: #8b2252;">"Labels"</span>: {}
}
]
</pre>
</div>
</div>
</div>
<div id="outline-container-h:f9a2d8aa-06c6-467c-9072-bdb96a019b01" class="outline-5">
<h5 id="h:f9a2d8aa-06c6-467c-9072-bdb96a019b01">实战案例: 利用自定义网络实现 Redis Cluster</h5>
<div class="outline-text-5" id="text-h:f9a2d8aa-06c6-467c-9072-bdb96a019b01">
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">1 &#21019;&#24314;&#33258;&#23450;&#20041;&#32593;&#32476;
</span>[root@ubuntu1804 ~]#docker network create net-redis --subnet 172.18.0.0/16
[root@ubuntu1804 ~]#docker inspect net-redis

<span style="color: #b22222;">#</span><span style="color: #b22222;">2 &#21019;&#24314;6&#20010;redis&#23481;&#22120;&#37197;&#32622;
</span><span style="color: #b22222;"># </span><span style="color: #b22222;">&#36890;&#36807;&#33050;&#26412;&#21019;&#24314;&#20845;&#20010;redis&#23481;&#22120;&#37197;&#32622;
</span>[root@ubuntu1804 ~]#for port<span style="color: #a020f0;"> in</span> {1..6};<span style="color: #a020f0;">do</span>
    mkdir -p /data/redis/node-${<span style="color: #a0522d;">port</span>}/conf
    cat &gt;&gt; /data/redis/node-${<span style="color: #a0522d;">port</span>}/conf/redis.conf &lt;&lt; EOF<span style="color: #ffa54f;">
port 6379
bind 0.0.0.0
masterauth 123456
requirepass 123456
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
cluster-announce-ip 172.18.0.1${port}
cluster-announce-port 6379
cluster-announce-bus-port 16379
appendonly yes
EOF
</span><span style="color: #a020f0;">done</span>

<span style="color: #b22222;">#</span><span style="color: #b22222;">3 &#21019;&#24314;6&#20010; redis &#23481;&#22120;
</span><span style="color: #b22222;"># </span><span style="color: #b22222;">&#36890;&#36807;&#33050;&#26412;&#36816;&#34892;&#20845;&#20010;redis&#23481;&#22120;
</span>[root@ubuntu1804 ~]#for port<span style="color: #a020f0;"> in</span> {1..6};<span style="color: #a020f0;">do</span>
docker run -p 637${<span style="color: #a0522d;">port</span>}:6379 -p 1667${<span style="color: #a0522d;">port</span>}:16379 --name redis-${<span style="color: #a0522d;">port</span>} <span style="color: #8b2252;">\</span>
   -v /data/redis/node-${<span style="color: #a0522d;">port</span>}/data:/data <span style="color: #8b2252;">\</span>
   -v /data/redis/node-${<span style="color: #a0522d;">port</span>}/conf/redis.conf:/etc/redis/redis.conf <span style="color: #8b2252;">\</span>
   -d --net net-redis --ip 172.18.0.1${<span style="color: #a0522d;">port</span>} redis:5.0.9-alpine3.11 redisserver /etc/redis/redis.conf
<span style="color: #a020f0;">done</span>

[root@ubuntu1804 ~]#docker ps

<span style="color: #b22222;">#</span><span style="color: #b22222;">4 &#21019;&#24314; redis cluster
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">&#36830;&#25509;redis cluster
</span>[root@ubuntu1804 ~]#docker exec -it redis-1 /bin/sh
/data <span style="color: #b22222;"># </span><span style="color: #b22222;">redis-cli -a 123456
</span>Warning: Using a password with <span style="color: #8b2252;">'-a'</span> or <span style="color: #8b2252;">'-u'</span> option on the command line interface
may not be safe.
127.0.0.1:6379&gt; exit
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#19981;&#25903;&#25345; { } &#25193;&#23637;
</span>/data <span style="color: #b22222;"># </span><span style="color: #b22222;">echo {1..10}
</span>{1..10}
/data <span style="color: #b22222;"># </span><span style="color: #b22222;">echo $-
</span>smi

<span style="color: #b22222;"># </span><span style="color: #b22222;">&#21019;&#24314;&#38598;&#32676;
</span>/data <span style="color: #b22222;"># </span><span style="color: #b22222;">redis-cli -a 123456 --cluster create 172.18.0.11:6379 172.18.0.12:6379 172.18.0.13:6379 172.18.0.14:6379 172.18.0.15:6379 172.18.0.16:6379 --clusterreplicas 1
</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">5 &#27979;&#35797;&#35775;&#38382;&#22312;
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">&#36830;&#25509;redis cluster
</span>/data <span style="color: #b22222;"># </span><span style="color: #b22222;">redis-cli -a 123456 -c
</span>Warning: Using a password with <span style="color: #8b2252;">'-a'</span> or <span style="color: #8b2252;">'-u'</span> option on the command line interface
may not be safe.
127.0.0.1:6379&gt; cluster info
cluster_state:ok

127.0.0.1:6379&gt; cluster nodes
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#30475;&#21040;172.18.0.{11,12,13}&#20026;master,172.18.0.{14,15,16}&#20026;slave
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">&#20197;&#19979;&#20026;master/slave&#20851;&#31995;
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">172.18.0.11&lt;---&gt;172.18.0.15
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">172.18.0.12&lt;---&gt;172.18.0.16
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">172.18.0.13&lt;---&gt;172.18.0.14
</span>2f69287f52ec7243a0b894491814d2afe28a46d2 172.18.0.15:6379@16379 slave
0f9bd0d24495f826702a030703896f7690bebdee 0 1595404269581 5 connected
0f9bd0d24495f826702a030703896f7690bebdee 172.18.0.11:6379@16379 myself,master -
0 1595404269000 1 connected 0-5460
c64dfd1bd6c964a3c6425a28f6ab0f0e1bcea1ba 172.18.0.14:6379@16379 slave
599f69b43a3579ec064b1854680c77997c809470 0 1595404268000 4 connected
9b6ab0b8f75516d6acd9d566d0d349f1fdd29540 172.18.0.12:6379@16379 master - 0
1595404268976 2 connected 5461-10922
599f69b43a3579ec064b1854680c77997c809470 172.18.0.13:6379@16379 master - 0
1595404269481 3 connected 10923-16383
06295ce4884948858cf60243629a595afa461b21 172.18.0.16:6379@16379 slave
9b6ab0b8f75516d6acd9d566d0d349f1fdd29540 0 1595404268000 6 connected

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#28155;&#21152;key&#21040;redis-2&#19978;
</span>127.0.0.1:6379&gt; set name user1
-&gt; Redirected to slot [5798] located at 172.18.0.12:6379
OK
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#28155;&#21152;key&#21040;redis-1&#19978;
</span>172.18.0.12:6V379&gt; set title cto
-&gt; Redirected to slot [2217] located at 172.18.0.11:6379
OK
172.18.0.11:6379&gt; get name
-&gt; Redirected to slot [5798] located at 172.18.0.12:6379
<span style="color: #8b2252;">"user1"</span>
172.18.0.12:6379&gt; get title
-&gt; Redirected to slot [2217] located at 172.18.0.11:6379
<span style="color: #8b2252;">"cto"</span>

<span style="color: #b22222;">#</span><span style="color: #b22222;">5 &#27979;&#35797;&#25925;&#38556;&#23454;&#29616; redis cluster &#39640;&#21487;&#29992;&#24615;
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">&#27169;&#25311;redis-2&#25925;&#38556;
</span>[root@ubuntu1804 ~]#docker stop redis-2
redis-2
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#20877;&#27425;&#26597;&#30475;cluster&#29366;&#24577;,&#21487;&#20197;&#30475;&#21040;redis-2&#20986;&#38169;
</span>[root@ubuntu1804 ~]#docker exec -it redis-1 /bin/sh
/data <span style="color: #b22222;"># </span><span style="color: #b22222;">redis-cli -a 123456 --cluster check 127.0.0.1:6379
</span>Warning: Using a password with <span style="color: #8b2252;">'-a'</span> or <span style="color: #8b2252;">'-u'</span> option on the command line interface may not be safe.
Could not connect to Redis at 172.18.0.12:6379: Host is unreachable
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26597;&#30475;&#21040; 172.18.0.16&#25552;&#21319;&#20026;&#26032;&#30340;master
</span>172.18.0.16:6379 (06295ce4...) -&gt; 1 keys | 5462 slots | 0 slaves.
172.18.0.13:6379 (599f69b4...) -&gt; 0 keys | 5461 slots | 1 slaves.
172.18.0.15:6379 (2f69287f...) -&gt; 1 keys | 5461 slots | 1 slaves.
[OK] 2 keys<span style="color: #a020f0;"> in</span> 3 masters.
0.00 keys per slot on average.
&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:6379)
S: 0f9bd0d24495f826702a030703896f7690bebdee 127.0.0.1:6379
slots: (0 slots) slave
replicates 2f69287f52ec7243a0b894491814d2afe28a46d2
M: 06295ce4884948858cf60243629a595afa461b21 172.18.0.16:6379
slots:[5461-10922] (5462 slots) master
M: 599f69b43a3579ec064b1854680c77997c809470 172.18.0.13:6379
slots:[10923-16383] (5461 slots) master
1 additional replica(s)
M: 2f69287f52ec7243a0b894491814d2afe28a46d2 172.18.0.15:6379
slots:[0-5460] (5461 slots) master
1 additional replica(s)
S: c64dfd1bd6c964a3c6425a28f6ab0f0e1bcea1ba 172.18.0.14:6379
slots: (0 slots) slave
replicates 599f69b43a3579ec064b1854680c77997c809470
[OK] All nodes agree about slots configuration.
&gt;&gt;&gt; Check for open slots...
&gt;&gt;&gt; Check slots coverage...
[OK] All 16384 slots covered.

/data <span style="color: #b22222;"># </span><span style="color: #b22222;">redis-cli -a 123456 -c
</span>Warning: Using a password with <span style="color: #8b2252;">'-a'</span> or <span style="color: #8b2252;">'-u'</span> option on the command line interface
may not be safe.
127.0.0.1:6379&gt; cluster nodes
06295ce4884948858cf60243629a595afa461b21 172.18.0.16:6379@16379 master - 0
1595406573128 8 connected 5461-10922
599f69b43a3579ec064b1854680c77997c809470 172.18.0.13:6379@16379 master - 0
1595406572623 3 connected 10923-16383
0f9bd0d24495f826702a030703896f7690bebdee 172.18.0.11:6379@16379 myself,slave
2f69287f52ec7243a0b894491814d2afe28a46d2 0 1595406571000 1 connected
2f69287f52ec7243a0b894491814d2afe28a46d2 172.18.0.15:6379@16379 master - 0
1595406571614 7 connected 0-5460
9b6ab0b8f75516d6acd9d566d0d349f1fdd29540 172.18.0.12:6379@16379 master,fail -
1595404533839 1595404532528 2 connected
c64dfd1bd6c964a3c6425a28f6ab0f0e1bcea1ba 172.18.0.14:6379@16379 slave
599f69b43a3579ec064b1854680c77997c809470 0 1595406572118 4 connected

127.0.0.1:6379&gt; get name
-&gt; Redirected to slot [5798] located at 172.18.0.16:6379
<span style="color: #8b2252;">"user1"</span>
172.18.0.16:6379&gt; get title
-&gt; Redirected to slot [2217] located at 172.18.0.15:6379
<span style="color: #8b2252;">"cto"</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:b6411e28-c009-495b-97f6-7a64b2fd586d" class="outline-4">
<h4 id="h:b6411e28-c009-495b-97f6-7a64b2fd586d">同一个宿主机之间不同网络的容器通信</h4>
<div class="outline-text-4" id="text-h:b6411e28-c009-495b-97f6-7a64b2fd586d">
<p>
开两个容器，一个使用自定义网络容器，一个使用默认brideg网络的容器,默认因iptables规则导致无法通信<br>
<img src="./images/Snipaste_2023-04-28_13-48-13.png" alt="Snipaste_2023-04-28_13-48-13.png"><br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker run -it --rm --name test1 alpine sh
docker run -it --rm --network test-net --name test2 alpine sh
</pre>
</div>
</div>
<div id="outline-container-h:508f1b45-adef-4a99-987f-694bfa37c510" class="outline-5">
<h5 id="h:508f1b45-adef-4a99-987f-694bfa37c510">实战案例 1: 修改iptables实现同一宿主机上的不同网络的容器间通信</h5>
<div class="outline-text-5" id="text-h:508f1b45-adef-4a99-987f-694bfa37c510">
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#30830;&#35748;&#24320;&#21551;ip_forward
</span>[root@ubuntu1804 ~]#cat /proc/sys/net/ipv4/ip_forward
1 

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#40664;&#35748;&#32593;&#32476;&#21644;&#33258;&#23450;&#20041;&#32593;&#32476;&#26159;&#20004;&#20010;&#19981;&#21516;&#30340;&#32593;&#26725;
</span>[root@ubuntu1804 ~]#brctl show
bridge name bridge id STP enabled interfaces
br-c90dee3b7937 8000.0242587cf093 no veth984a5b4
docker0 8000.02429b31732b no veth1a20128
[root@ubuntu1804 ~]#
[root@ubuntu1804 ~]#iptables-save
<span style="color: #b22222;"># </span><span style="color: #b22222;">Generated by iptables-save v1.6.1 on Sun Feb 2 14:33:19 2020
</span>*filter
... ...
-A DOCKER-ISOLATION-STAGE-2 -o br-c90dee3b7937 -j DROP <span style="color: #b22222;">#</span><span style="color: #b22222;">&#27880;&#24847;&#27492;&#34892;&#35268;&#21017;
</span>-A DOCKER-ISOLATION-STAGE-2 -o docker0 -j DROP <span style="color: #b22222;">#</span><span style="color: #b22222;">&#27880;&#24847;&#27492;&#34892;&#35268;&#21017;
</span>-A DOCKER-ISOLATION-STAGE-2 -j RETURN
-A DOCKER-USER -j RETURN
COMMIT
<span style="color: #b22222;"># </span><span style="color: #b22222;">Completed on Sun Feb 2 14:33:19 2020
</span><span style="color: #b22222;"># </span><span style="color: #b22222;">Generated by iptables-save v1.6.1 on Sun Feb 2 14:33:19 2020
</span>... ...
COMMIT
<span style="color: #b22222;"># </span><span style="color: #b22222;">Completed on Sun Feb 2 14:33:19 2020
</span>
[root@ubuntu1804 ~]#iptables-save &gt; iptables.rule
[root@ubuntu1804 ~]#vim iptables.rule
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#20462;&#25913;&#19979;&#38754;&#20004;&#34892;&#30340;&#35268;&#21017;
</span>-A DOCKER-ISOLATION-STAGE-2 -o br-c90dee3b7937 -j ACCEPT
-A DOCKER-ISOLATION-STAGE-2 -o docker0 -j ACCEPT
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#25110;&#32773;&#25191;&#34892;&#19979;&#38754;&#21629;&#20196;
</span>[root@ubuntu1804 ~]#iptables -I DOCKER-ISOLATION-STAGE-2 -j ACCEPT

[root@ubuntu1804 ~]#iptables-restore &lt; iptables.rule

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#20877;&#27425;&#20004;&#20010;&#23481;&#22120;&#20043;&#38388;&#21487;&#20197;&#30456;&#20114;&#36890;&#20449;
</span>/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping 172.27.0.2
</span>PING 172.27.0.2 (172.27.0.2): 56 data bytes
64 bytes from 172.27.0.2: <span style="color: #a0522d;">seq</span>=896 <span style="color: #a0522d;">ttl</span>=63 <span style="color: #a0522d;">time</span>=0.502 ms
64 bytes from 172.27.0.2: <span style="color: #a0522d;">seq</span>=897 <span style="color: #a0522d;">ttl</span>=63 <span style="color: #a0522d;">time</span>=0.467 ms
64 bytes from 172.27.0.2: <span style="color: #a0522d;">seq</span>=898 <span style="color: #a0522d;">ttl</span>=63 <span style="color: #a0522d;">time</span>=0.227 ms
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping 172.17.0.2
</span>PING 172.17.0.2 (172.17.0.2): 56 data bytes
64 bytes from 172.17.0.2: <span style="color: #a0522d;">seq</span>=0 <span style="color: #a0522d;">ttl</span>=63 <span style="color: #a0522d;">time</span>=0.163 ms
64 bytes from 172.17.0.2: <span style="color: #a0522d;">seq</span>=1 <span style="color: #a0522d;">ttl</span>=63 <span style="color: #a0522d;">time</span>=0.232 ms
</pre>
</div>
</div>
</div>
<div id="outline-container-h:9fefd7e2-d322-4946-9623-8bc7a3744712" class="outline-5">
<h5 id="h:9fefd7e2-d322-4946-9623-8bc7a3744712">实战案例 2: 通过解决docker network connect 实现同一个宿主机不同网络的容器间通信</h5>
<div class="outline-text-5" id="text-h:9fefd7e2-d322-4946-9623-8bc7a3744712">
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#23558;CONTAINER&#36830;&#20837;&#25351;&#23450;&#30340;NETWORK&#20013;,&#20351;&#27492;CONTAINER&#21487;&#20197;&#19982;NETWORK&#20013;&#30340;&#20854;&#23427;&#23481;&#22120;&#36827;&#34892;&#36890;&#20449;
</span>docker network connect [OPTIONS] NETWORK CONTAINER
Connect a container to a network
Options:
   --alias strings Add network-scoped alias for the container
   --driver-opt strings driver options for the network
   --ip string IPv4 address (e.g., 172.30.100.104)
   --ip6 string IPv6 address (e.g., 2001:db8::33)
   --link list Add link to another container
   --link-local-ip strings Add a link-local address for the container

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#23558;CONTAINER&#19982;&#25351;&#23450;&#30340;NETWORK&#26029;&#24320;&#36830;&#25509;,&#20351;&#27492;CONTAINER&#21487;&#20197;&#19982;CONTAINER&#20013;&#30340;&#20854;&#23427;&#23481;&#22120;&#36827;&#34892;&#26080;&#27861;&#36890;&#20449;
</span>docker network disconnect [OPTIONS] NETWORK CONTAINER
Disconnect a container from a network

Options:
-f, --force Force the container to disconnect from a network
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shell">1 &#19978;&#38754;&#26696;&#20363;&#20013;test1&#21644;test2&#30340;&#23481;&#22120;&#38388;&#40664;&#35748;&#26080;&#27861;&#36890;&#20449;
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#27599;&#20010;&#32593;&#32476;&#20013;&#26377;&#23646;&#20110;&#27492;&#32593;&#32476;&#30340;&#23481;&#22120;&#20449;&#24687;
</span>2 &#35753;&#40664;&#35748;&#32593;&#32476;&#20013;&#23481;&#22120;test1&#21487;&#20197;&#36830;&#36890;&#33258;&#23450;&#20041;&#32593;&#32476;test-net&#30340;&#23481;&#22120;test2
[root@ubuntu1804 ~]#docker network connect test-net test1
[root@ubuntu1804 ~]#docker network inspect test-net
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#22312;test1&#23481;&#22120;&#20013;&#21487;&#20197;&#30475;&#21040;&#26032;&#28155;&#21152;&#20102;&#19968;&#20010;&#32593;&#21345;,&#24182;&#19988;&#20998;&#37197;&#20102;test-net&#32593;&#32476;&#30340;IP&#20449;&#24687;
</span>/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ip a
</span>27: eth0@if28: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue
state UP
link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
valid_lft forever preferred_lft forever
29: eth1@if30: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue
state UP
link/ether 02:42:ac:1b:00:03 brd ff:ff:ff:ff:ff:ff
inet 172.27.0.3/16 brd 172.27.255.255 scope global eth1
valid_lft forever preferred_lft forever



<span style="color: #b22222;">#</span><span style="color: #b22222;">test1&#21487;&#20197;&#36830;&#25509;test2&#23481;&#22120;
</span>/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping -c1 172.27.0.2
</span>PING 172.27.0.2 (172.27.0.2): 56 data bytes
64 bytes from 172.27.0.2: <span style="color: #a0522d;">seq</span>=0 <span style="color: #a0522d;">ttl</span>=64 <span style="color: #a0522d;">time</span>=0.100 ms

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#22312;test2&#23481;&#22120;&#20013;&#27809;&#26377;&#21464;&#21270;,&#20173;&#28982;&#26080;&#27861;&#36830;&#25509;test1
</span>/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ip a
</span>1: lo: &lt;LOOPBack 00:00:00:00:00:00 brd 00:00:00:00:00:00
inet 127.0.0.1/8 scope host lo
valid_lft forever preferred_lft forever
23: eth0@if24: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue
state UP
link/ether 02:42:ac:1b:00:02 brd ff:ff:ff:ff:ff:ff
inet 172.27.0.2/16 brd 172.27.255.255 scope global eth0
valid_lft forever preferred_lft forever
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping -c1 172.17.0.2
</span>PING 172.17.0.2 (172.17.0.2): 56 data bytes
^C
--- 172.17.0.2 ping statistics ---
1 packets transmitted, 0 packets received, 100% packet loss

3 &#35753;&#33258;&#23450;&#20041;&#32593;&#32476;&#20013;&#23481;&#22120;test2&#21487;&#20197;&#36830;&#36890;&#40664;&#35748;&#32593;&#32476;&#30340;&#23481;&#22120;test1
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#23558;&#33258;&#23450;&#20041;&#32593;&#32476;&#20013;&#30340;&#23481;&#22120;test2&#20063;&#21152;&#20837;&#21040;&#40664;&#35748;&#32593;&#32476;&#20013;,&#20351;&#20043;&#21644;&#40664;&#35748;&#32593;&#32476;&#20013;&#30340;&#23481;&#22120;test1&#36890;&#20449;
</span>[root@ubuntu1804 ~]#docker network connect bridge test2
[root@ubuntu1804 ~]#docker network inspect bridge
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#30830;&#35748;&#33258;&#23450;&#20041;&#32593;&#32476;&#30340;&#23481;&#22120;test2&#20013;&#28155;&#21152;&#20102;&#26032;&#32593;&#21345;,&#24182;&#35774;&#32622;&#40664;&#35748;&#32593;&#32476;&#30340;IP&#20449;&#24687;
</span>/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ip a
</span>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000
link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
inet 127.0.0.1/8 scope host lo
valid_lft forever preferred_lft forever
23: eth0@if24: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue
state UP
link/ether 02:42:ac:1b:00:02 brd ff:ff:ff:ff:ff:ff
inet 172.27.0.2/16 brd 172.27.255.255 scope global eth0
valid_lft forever preferred_lft forever
31: eth1@if32: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue
state UP
link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff
inet 172.17.0.3/16 brd 172.17.255.255 scope global eth1
valid_lft forever preferred_lft forever

<span style="color: #b22222;">#</span><span style="color: #b22222;">test2&#21487;&#20197;&#36830;&#25509;test1&#23481;&#22120;
</span>/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping -c1 172.17.0.2
</span>PING 172.17.0.2 (172.17.0.2): 56 data bytes
64 bytes from 172.17.0.2: <span style="color: #a0522d;">seq</span>=0 <span style="color: #a0522d;">ttl</span>=64 <span style="color: #a0522d;">time</span>=0.128 ms
--- 172.17.0.2 ping statistics ---
1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max = 0.128/0.128/0.128 ms

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#22312;test1&#20013;&#21487;&#20197;&#21033;&#29992;test2&#23481;&#22120;&#21517;&#36890;&#20449;
</span>/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping -c1 test2
</span>PING test2 (172.27.0.2): 56 data bytes
64 bytes from 172.27.0.2: <span style="color: #a0522d;">seq</span>=0 <span style="color: #a0522d;">ttl</span>=64 <span style="color: #a0522d;">time</span>=0.076 ms
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#22312;test2&#20013;&#21487;&#20197;&#21033;test1&#23481;&#22120;&#21517;&#36890;&#20449;
</span>/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping -c1 test1
</span>PING test1 (172.27.0.3): 56 data bytes
64 bytes from 172.27.0.3: <span style="color: #a0522d;">seq</span>=0 <span style="color: #a0522d;">ttl</span>=64 <span style="color: #a0522d;">time</span>=0.075 ms

4 &#26029;&#24320;&#19981;&#21516;&#32593;&#32476;&#20013;&#23481;&#22120;&#30340;&#36890;&#20449;
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#23558;test1 &#26029;&#24320;&#21644;&#32593;&#32476;test-net&#20013;&#20854;&#23427;&#23481;&#22120;&#30340;&#36890;&#20449;
</span>[root@ubuntu1804 ~]#docker network disconnect test-net test1

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#22312;&#23481;&#22120;test1&#20013;&#26080;&#27861;&#21644;test2&#36890;&#20449;
</span>/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ip a
</span>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000
link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
inet 127.0.0.1/8 scope host lo
valid_lft forever preferred_lft forever
27: eth0@if28: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue
state UP
link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
valid_lft forever preferred_lft forever
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping -c1 172.27.0.2
</span>PING 172.27.0.2 (172.27.0.2): 56 data bytes
--- 172.27.0.2 ping statistics ---
1 packets transmitted, 0 packets received, 100% packet loss

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#22312;&#23481;&#22120;test2&#20013;&#20173;&#33021;&#21644;test1&#36890;&#20449;
</span>/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ip a
</span>
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000
link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
inet 127.0.0.1/8 scope host lo
valid_lft forever preferred_lft forever
23: eth0@if24: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue
state UP
link/ether 02:42:ac:1b:00:02 brd ff:ff:ff:ff:ff:ff
inet 172.27.0.2/16 brd 172.27.255.255 scope global eth0
valid_lft forever preferred_lft forever
31: eth1@if32: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue
state UP
link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff
inet 172.17.0.3/16 brd 172.17.255.255 scope global eth1
valid_lft forever preferred_lft forever
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping -c1 172.17.0.2
</span>PING 172.17.0.2 (172.17.0.2): 56 data bytes
64 bytes from 172.17.0.2: <span style="color: #a0522d;">seq</span>=0 <span style="color: #a0522d;">ttl</span>=64 <span style="color: #a0522d;">time</span>=0.085 ms

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#23558;test2 &#26029;&#24320;&#21644;&#40664;&#35748;&#32593;&#32476;&#20013;&#20854;&#23427;&#23481;&#22120;&#30340;&#36890;&#20449;
</span>[root@ubuntu1804 ~]#docker network disconnect bridge test2
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#22312;&#23481;&#22120;test2&#20013;&#26080;&#27861;&#21644;test1&#36890;&#20449;
</span>/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ip a
</span>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000
link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
inet 127.0.0.1/8 scope host lo
valid_lft forever preferred_lft forever
23: eth0@if24: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue
state UP
link/ether 02:42:ac:1b:00:02 brd ff:ff:ff:ff:ff:ff
inet 172.27.0.2/16 brd 172.27.255.255 scope global eth0
valid_lft forever preferred_lft forever
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping -c1 172.17.0.2
</span>PING 172.17.0.2 (172.17.0.2): 56 data bytes
--- 172.17.0.2 ping statistics ---
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-h:5b3fdb04-7193-49ff-a7b8-2301d3da440a" class="outline-3">
<h3 id="h:5b3fdb04-7193-49ff-a7b8-2301d3da440a">实现跨宿主机的容器之间网络互联</h3>
<div class="outline-text-3" id="text-h:5b3fdb04-7193-49ff-a7b8-2301d3da440a">
<p>
同一个宿主机之间的各个容器之间是可以直接通信的，但是如果访问到另外一台宿主机的容器呢？<br>
</p>
</div>
<div id="outline-container-h:5381348e-7f75-490d-b2cb-2d4f6f4eb0e2" class="outline-4">
<h4 id="h:5381348e-7f75-490d-b2cb-2d4f6f4eb0e2">方式1: 利用桥接实现跨宿主机的容器间互联</h4>
<div class="outline-text-4" id="text-h:5381348e-7f75-490d-b2cb-2d4f6f4eb0e2">

<figure id="org32882f0">
<img src="./images/Snipaste_2023-04-28_14-22-00.png" alt="Snipaste_2023-04-28_14-22-00.png"><br>

</figure>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#20998;&#21035;&#23558;&#20004;&#20010;&#23487;&#20027;&#26426;&#37117;&#25191;&#34892;&#19979;&#38754;&#25805;&#20316;
</span>[root@ubuntu1804 ~]#apt -y install bridge-utils
[root@ubuntu1804 ~]#brctl addif docker0 eth0

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#22312;&#20004;&#20010;&#23487;&#20027;&#26426;&#19978;&#21508;&#21551;&#21160;&#19968;&#20010;&#23481;&#22120;,&#38656;&#35201;&#30830;&#20445;IP&#19981;&#21516;,&#30456;&#20114;&#27979;&#35797;&#35775;&#38382;
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">&#31532;&#19968;&#20010;&#23487;&#20027;&#26426;&#30340;&#23481;&#22120;
</span>[root@ubuntu1804 ~]#docker run -it --name b1 busybox
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">hostname -i
</span>172.17.0.2
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">httpd -h /data/html/ -f -v
</span>[::ffff:172.17.0.3]:42488:response:200

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#31532;&#20108;&#20010;&#23487;&#20027;&#26426;&#30340;&#23481;&#22120;
</span>[root@ubuntu1804 ~]#docker run -it --name b2 busybox
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">hostname -i
</span>172.17.0.3
/#wget-q0 - http://172.17.0.2
httpd website<span style="color: #a020f0;"> in</span> busybox
</pre>
</div>
</div>
</div>
<div id="outline-container-h:152044ab-467d-45c5-82be-db09c1073bb1" class="outline-4">
<h4 id="h:152044ab-467d-45c5-82be-db09c1073bb1">方式2: 利用NAT实现跨主机的容器间互联</h4>
<div class="outline-text-4" id="text-h:152044ab-467d-45c5-82be-db09c1073bb1">
</div>
<div id="outline-container-h:9b826a15-6550-4700-89b6-993c03955b94" class="outline-5">
<h5 id="h:9b826a15-6550-4700-89b6-993c03955b94">docker跨主机互联实现说明</h5>
<div class="outline-text-5" id="text-h:9b826a15-6550-4700-89b6-993c03955b94">
<p>
跨主机互联是说A宿主机的容器可以访问B主机上的容器，但是前提是保证各宿主机之间的网络是可以相互通信的，然后各容器才可以通过宿主机访问到对方的容器<br>
</p>

<p>
实现原理: 是在宿主机做一个网络路由就可以实现A宿主机的容器访问B主机的容器的目的<br>
</p>

<p>
注意: 此方式只适合小型网络环境，复杂的网络或者大型的网络可以使用google开源的k8s进行互联<br>
</p>
</div>
</div>
<div id="outline-container-h:93d449f3-61f0-4fc5-b4fc-dd1fc74cb314" class="outline-5">
<h5 id="h:93d449f3-61f0-4fc5-b4fc-dd1fc74cb314">修改各宿主机网段</h5>
<div class="outline-text-5" id="text-h:93d449f3-61f0-4fc5-b4fc-dd1fc74cb314">
<p>
Docker默认网段是172.17.0.x/24,而且每个宿主机都是一样的，因此要做路由的前提就是各个主机的网络不能一致<br>
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#31532;&#19968;&#20010;&#23487;&#20027;&#26426;A&#19978;&#26356;&#25913;&#32593;&#27573;
</span>[root@ubuntu1804 ~]#vim /etc/docker/daemon.json
[root@ubuntu1804 ~]#cat /etc/docker/daemon.json
{
<span style="color: #8b2252;">"bip"</span>: <span style="color: #8b2252;">"192.168.100.1/24"</span>,
<span style="color: #8b2252;">"registry-mirrors"</span>: [<span style="color: #8b2252;">"https://si7y70hh.mirror.aliyuncs.com"</span>]
}

[root@ubuntu1804 ~]# systemctl restart docker
[root@ubuntu1804 ~]#route -n

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#31532;&#20108;&#20010;&#23487;&#20027;&#26426;B&#26356;&#25913;&#32593;&#27573;
</span>[root@ubuntu1804 ~]#vim /etc/docker/daemon.json
{
<span style="color: #8b2252;">"bip"</span>: <span style="color: #8b2252;">"192.168.200.1/24"</span>,
<span style="color: #8b2252;">"registry-mirrors"</span>: [<span style="color: #8b2252;">"https://si7y70hh.mirror.aliyuncs.com"</span>]
}

[root@ubuntu1804 ~]#systemctl restart docker
[root@ubuntu1804 ~]#route -n
</pre>
</div>
</div>
</div>
<div id="outline-container-h:73f9b83c-f378-467e-a2b1-d7a7b69a77b7" class="outline-5">
<h5 id="h:73f9b83c-f378-467e-a2b1-d7a7b69a77b7">在两个宿主机分别启动一个容器</h5>
<div class="outline-text-5" id="text-h:73f9b83c-f378-467e-a2b1-d7a7b69a77b7">
<p>
第一个宿主机启动容器server1<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker run -it --name server1 --rm alpine sh
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ip a
</span>16: eth0@if17: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue
inet 192.168.100.2/24 brd 192.168.100.255 scope global eth0

/ <span style="color: #b22222;"># </span><span style="color: #b22222;">route -n
</span>Kernel IP routing table
Destination Gateway Genmask Flags Metric Ref Use Iface
0.0.0.0 192.168.100.1 0.0.0.0 UG 0 0 0 eth0
192.168.100.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0
</pre>
</div>

<p>
第二个宿主机启动容器server2<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker run -it --name server2 --rm alpine sh
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ip a
</span>8: eth0@if9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue
inet 192.168.200.2/24 brd 192.168.200.255 scope global eth0

/ <span style="color: #b22222;"># </span><span style="color: #b22222;">route -n
</span>Kernel IP routing table
Destination Gateway Genmask Flags Metric Ref Use Iface
0.0.0.0 192.168.200.1 0.0.0.0 UG 0 0 0 eth0
192.168.200.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0
</pre>
</div>

<p>
从第一个宿主机的容器server1无法和第二个宿主机的server2相互访问<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker run -it --name server1 --rm alpine sh
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ip a
</span>14: eth0@if15: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue
inet 10.100.0.2/16 brd 10.100.255.255 scope global eth0
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping -c1 192.168.200.2
</span>PING 192.168.200.2 (192.168.200.2): 56 data bytes

--- 192.168.200.2 ping statistics ---
1 packets transmitted, 0 packets received, 100% packet loss
</pre>
</div>
</div>
</div>
<div id="outline-container-h:f8bd4b72-69ea-48e1-a6a8-537c31f1bea7" class="outline-5">
<h5 id="h:f8bd4b72-69ea-48e1-a6a8-537c31f1bea7">添加静态路由和iptables规则</h5>
<div class="outline-text-5" id="text-h:f8bd4b72-69ea-48e1-a6a8-537c31f1bea7">
<p>
在各宿主机添加静态路由，网关指向对方宿主机的IP<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;"># </span><span style="color: #b22222;">&#22312;&#31532;&#19968;&#21488;&#23487;&#20027;&#26426;&#28155;&#21152;&#38745;&#24577;&#36335;&#30001;&#21644;iptables&#35268;&#21017;
</span>[root@ubuntu1804 ~]#route add -net 192.168.200.0/24 gw 10.0.0.102
[root@ubuntu1804 ~]#iptables -A FORWARD -s 10.0.0.0/24 -j ACCEPT

<span style="color: #b22222;"># </span><span style="color: #b22222;">&#22312;&#31532;&#20108;&#21488;&#23487;&#20027;&#26426;&#28155;&#21152;&#38745;&#24577;&#36335;&#30001;&#21644;iptables&#35268;&#21017;
</span>[root@ubuntu1804 ~]#route add -net 192.168.100.0/24 gw 10.0.0.101
[root@ubuntu1804 ~]#iptables -A FORWARD -s 10.0.0.0/24 -j ACCEPT
</pre>
</div>
</div>
</div>
<div id="outline-container-h:fe37f7e3-6633-439d-845c-a9b6330996ec" class="outline-5">
<h5 id="h:fe37f7e3-6633-439d-845c-a9b6330996ec">测试跨宿主机之间容器互联</h5>
<div class="outline-text-5" id="text-h:fe37f7e3-6633-439d-845c-a9b6330996ec">
<p>
宿主机A的容器server1访问宿主机B容器server2，同时在宿主机B上tcpdump抓包观察<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping -c1 192.168.200.2
</span>PING 192.168.200.2 (192.168.200.2): 56 data bytes
64 bytes from 192.168.200.2: <span style="color: #a0522d;">seq</span>=0 <span style="color: #a0522d;">ttl</span>=62 <span style="color: #a0522d;">time</span>=1.022 ms
--- 192.168.200.2 ping statistics ---
1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max = 1.022/1.022/1.022 ms

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#23487;&#20027;&#26426;B&#30340;&#25235;&#21253;&#21487;&#20197;&#35266;&#23519;&#21040;
</span>[root@ubuntu1804 ~]#tcpdump -i eth0 -nn icmp
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes
16:57:37.912925 IP 10.0.0.101 &gt; 192.168.200.2: ICMP echo request, id 2560, seq
0, length 64
16:57:37.913208 IP 192.168.200.2 &gt; 10.0.0.101: ICMP echo reply, id 2560, seq 0,
length 64
</pre>
</div>

<p>
宿主机B的容器server2访问宿主机B容器server1，同时在宿主机A上tcpdump抓包观察<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping -c1 192.168.100.2
</span>PING 192.168.100.2 (192.168.100.2): 56 data bytes
64 bytes from 192.168.100.2: <span style="color: #a0522d;">seq</span>=0 <span style="color: #a0522d;">ttl</span>=62 <span style="color: #a0522d;">time</span>=1.041 ms
--- 192.168.100.2 ping statistics ---
1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max = 1.041/1.041/1.041 ms

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#23487;&#20027;&#26426;A&#30340;&#25235;&#21253;&#21487;&#20197;&#35266;&#23519;&#21040;
</span>[root@ubuntu1804 ~]#tcpdump -i eth0 -nn icmp
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes
16:59:11.775784 IP 10.0.0.102 &gt; 192.168.100.2: ICMP echo request, id 2560, seq
0, length 64
16:59:11.776113 IP 192.168.100.2 &gt; 10.0.0.102: ICMP echo reply, id 2560, seq 0,
length 64
</pre>
</div>
</div>
</div>
<div id="outline-container-h:52d05a4b-c690-44f6-be0f-5ab3ee17923a" class="outline-5">
<h5 id="h:52d05a4b-c690-44f6-be0f-5ab3ee17923a">创建第三个容器测试</h5>
<div class="outline-text-5" id="text-h:52d05a4b-c690-44f6-be0f-5ab3ee17923a">
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#22312;&#31532;&#20108;&#20010;&#23487;&#20027;&#26426;B&#19978;&#21551;&#21160;&#31532;&#19968;&#20010;&#25552;&#20379;web&#26381;&#21153;&#30340;nginx&#23481;&#22120;server3
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">&#27880;&#24847;&#26080;&#38656;&#25171;&#24320;&#31471;&#21475;&#26144;&#23556;
</span>[root@ubuntu1804 ~]#docker run -d --name server3 centos7-nginx:1.6.1

[root@ubuntu1804 ~]#docker exec -it server3 bash
[root@69fc554fd00e /]# ifconfig

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#20174;server1&#20013;&#35775;&#38382;server3&#30340;&#39029;&#38754;&#21487;&#20197;&#25104;&#21151;
</span>/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ip a
</span>/ <span style="color: #b22222;"># </span><span style="color: #b22222;">wget -qO - http://192.168.200.3/app
</span>Test Page<span style="color: #a020f0;"> in</span> app
/ <span style="color: #b22222;">#</span><span style="color: #b22222;">
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">&#20174;server3&#23481;&#22120;&#35266;&#23519;&#35775;&#38382;&#26085;&#24535;&#65292;&#21487;&#20197;&#30475;&#21040;&#26469;&#33258;&#20110;&#31532;&#19968;&#20010;&#23487;&#20027;&#26426;&#65292;&#32780;&#38750;server1&#23481;&#22120;
</span>[root@69fc554fd00e /]# tail -f /apps/nginx/logs/access.log
10.0.0.101 - - [02/Feb/2020:09:02:00 +0000] <span style="color: #8b2252;">"GET /app HTTP/1.1"</span> 301 169 <span style="color: #8b2252;">"-"</span> <span style="color: #8b2252;">"Wget"</span>

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#29992;tcpdump&#25235;&#21253;80/tcp&#30340;&#21253;&#65292;&#21487;&#20197;&#35266;&#23519;&#21040;&#20197;&#19979;&#20869;&#23481;
</span>[root@ubuntu1804 ~]#tcpdump -i eth0 -nn port 80
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes
17:03:35.885627 IP 10.0.0.101.43578 &gt; 192.168.200.3.80: Flags [S], seq
3672256868, win 29200, options [mss 1460,sackOK,TS val 4161963574 ecr
0,nop,wscale 7], length 0
17:03:35.885768 IP 192.168.200.3.80 &gt; 10.0.0.101.43578: Flags [S.], seq
2298407060, ack 3672256869, win 28960, options [mss 1460,sackOK,TS val
3131173298 ecr 4161963574,nop,wscale 7], length 0
17:03:35.886312 IP 10.0.0.101.43578 &gt; 192.168.200.3.80: Flags [.], ack 1, win
229, options [nop,nop,TS val 4161963575 ecr 3131173298], length 0
17:03:35.886507 IP 10.0.0.101.43578 &gt; 192.168.200.3.80: Flags [P.], seq 1:80,
ack 1, win 229, options [nop,nop,TS val 4161963575 ecr 3131173298], length 79:
HTTP: GET /app HTTP/1.1
17:03:35.886541 IP 192.168.200.3.80 &gt; 10.0.0.101.43578: Flags [.], ack 80, win
227, options [nop,nop,TS val 3131173299 ecr 4161963575], length 0
17:03:35.887179 IP 192.168.200.3.80 &gt; 10.0.0.101.43578: Flags [P.], seq 1:365,
ack 80, win 227, options [nop,nop,TS val 3131173299 ecr 4161963575], length 364:
HTTP: HTTP/1.1 301 Moved Permanently
17:03:35.887222 IP 192.168.200.3.80 &gt; 10.0.0.101.43578: Flags [F.], seq 365, ack
80, win 227, options [nop,nop,TS val 3131173299 ecr 4161963575], length 0
17:03:35.890139 IP 10.0.0.101.43580 &gt; 192.168.200.3.80: Flags [.], ack
1660534352, win 229, options [nop,nop,TS val 4161963579 ecr 3131173301], length
0
17:03:35.890297 IP 10.0.0.101.43580 &gt; 192.168.200.3.80: Flags [P.], seq 0:80,
ack 1, win 229, options [nop,nop,TS val 4161963579 ecr 3131173301], length 80:
HTTP: GET /app/ HTTP/1.1
17:03:35.890327 IP 192.168.200.3.80 &gt; 10.0.0.101.43580: Flags [.], ack 80, win
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:f280aec4-bb42-4135-807e-be139728e389" class="outline-4">
<h4 id="h:f280aec4-bb42-4135-807e-be139728e389">方式3: 利用Open vSwitch实现跨主机的容器间互联</h4>
<div class="outline-text-4" id="text-h:f280aec4-bb42-4135-807e-be139728e389">
</div>
<div id="outline-container-h:dd839148-80f8-46f8-9a00-6214b8b469c0" class="outline-5">
<h5 id="h:dd839148-80f8-46f8-9a00-6214b8b469c0">Open vSwitch介绍</h5>
<div class="outline-text-5" id="text-h:dd839148-80f8-46f8-9a00-6214b8b469c0">
<p>
Open vSwitch，即Open Virtual Switch开放虚拟交换机，简称OVS, 是在开源的Apache2.0许可下的产品级质量的多层虚拟交换机。由Nicira Networks开发，主要实现代码为可移植的C代码。它的目的是让大规模网络自动化可以通过编程扩展，同时仍然支持标准的管理接口和协议(例如NetFlow, sFlow,SPAN, RSPAN, CLI, LACP, 802.1ag) ,即Open vSwitch通过软件的方式实现了交换机功能.<br>
</p>

<p>
跟传统的物理交换机相比，虚拟交换机同样具备众多优点，一是配置更加灵活。一台普通的服务器可以配置出数十台甚至上百台虚拟交换机，且端口数目可以灵活选择。例如，VMware的ESXi一台服务器可以仿真出248台虚拟交换机，且每台交换机预设虚拟端口即可达56个；二是成本更加低廉，通过虚拟交换往往可以获得昂贵的普通交换机才能达到的性能，例如微软的Hyper-V平台，虚拟机与虚拟交换机之间的联机速度轻易可达10Gbps。<br>
</p>

<p>
官网: <a href="http://www.openvswitch.org/">http://www.openvswitch.org/</a><br>
</p>

<p>
使用Open vSwitch实现跨主机容器连接一原理<br>
<img src="./images/Snipaste_2023-04-28_14-42-47.png" alt="Snipaste_2023-04-28_14-42-47.png"><br>
</p>

<p>
什么是GRE隧道?<br>
GRE:通用路由协议封装<br>
隧道技术(Tunneling) 是一种通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据(或负载)可以是不同协议的数据帧或包。隧道协议将其它协议的数据帧或包重新封装然后通过隧道发送。新的帧头提供路由信息,以便通过互联网传递被封装的负载数据。<br>
</p>
</div>
</div>
<div id="outline-container-h:2aa596af-0242-40e3-9776-0a62db6047a5" class="outline-5">
<h5 id="h:2aa596af-0242-40e3-9776-0a62db6047a5">利用Open vSwitch实现docker跨主机网络</h5>
<div class="outline-text-5" id="text-h:2aa596af-0242-40e3-9776-0a62db6047a5">
<p>
实现目标: 将两台主机的容器利用Open vSwitch连接起来，实现互联互通<br>
</p>

<p>
1 环境准备<br>
主机名 操作系统 宿主机IP Docker0 IP 容器 IP<br>
ovs1 ubuntu 18.04 10.0.0.101/24 192.168.1.1/24 192.168.1.0/24<br>
ovs2 ubuntu 18.04 10.0.0.102/24 192.168.2.1/24 192.168.2.0/24<br>
</p>

<p>
2 修改两台主机的docker0分别使用不同的网段<br>
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#37197;&#32622;&#31532;&#19968;&#21488;&#20027;&#26426;
</span>[root@ovs1 ~]#vim /etc/docker/daemon.json
{
<span style="color: #8b2252;">"bip"</span>: <span style="color: #8b2252;">"192.168.1.1/24"</span>,
<span style="color: #8b2252;">"registry-mirrors"</span>: [<span style="color: #8b2252;">"https://si7y70hh.mirror.aliyuncs.com"</span>]
}
[root@ovs1 ~]#systemctl restart docker
[root@ovs1 ~]#ip add show docker0
3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state
DOWN group default
inet 192.168.1.1/24 brd 192.168.1.255 scope global docker0
valid_lft forever preferred_lft forever

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#37197;&#32622;&#31532;&#20108;&#21488;&#20027;&#26426;
</span>[root@ovs2 ~]#vim /etc/docker/daemon.json
{
<span style="color: #8b2252;">"bip"</span>: <span style="color: #8b2252;">"192.168.2.1/24"</span>,
<span style="color: #8b2252;">"registry-mirrors"</span>: [<span style="color: #8b2252;">"https://si7y70hh.mirror.aliyuncs.com"</span>]
}
[root@ovs2 ~]#systemctl restart docker
[root@ovs2 ~]#ip add show docker0
3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state
DOWN group default
link/ether 02:42:e2:38:84:83 brd ff:ff:ff:ff:ff:ff
inet 192.168.2.1/24 brd 192.168.2.255 scope global docker0
valid_lft forever preferred_lft forever
</pre>
</div>

<p>
3 在两个宿主机安装openvswitch-switch和bridge-utils和确认版本<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#22312;&#31532;&#19968;&#20010;&#20027;&#26426;&#23433;&#35013;&#21253;
</span>[root@ovs1 ~]#apt -y install openvswitch-switch bridge-utils
[root@ovs1 ~]#ps -e | grep ovs
6766 ? 00:00:00 ovsdb-server
6826 ? 00:00:00 ovs-vswitchd
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26597;&#30475;ovs&#29256;&#26412;&#20449;&#24687;&#21644;ovs&#25903;&#25345;&#30340;OpenFlow&#21327;&#35758;&#30340;&#29256;&#26412;
</span>[root@ovs1 ~]#ovs-appctl --version
<span style="color: #0000ff;">ovs-appctl</span> (Open vSwitch) 2.9.5
[root@ovs1 ~]#ovs-ofctl --version
<span style="color: #0000ff;">ovs-ofctl</span> (Open vSwitch) 2.9.5
OpenFlow versions 0x1:0x5
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26597;&#30475;&#32593;&#26725;
</span>[root@ovs1 ~]#brctl show
bridge name bridge id STP enabled interfaces
docker0 8000.0242dc29036c no
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#22312;&#31532;&#20108;&#20010;&#20027;&#26426;&#23433;&#35013;&#21253;
</span>[root@ovs2 ~]#apt -y install openvswitch-switch bridge-utils
[root@ovs2 ~]#ps -e | grep ovs
6618 ? 00:00:00 ovsdb-server
6680 ? 00:00:00 ovs-vswitchd
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26597;&#30475;ovs&#29256;&#26412;&#20449;&#24687;&#21644;ovs&#25903;&#25345;&#30340;OpenFlow&#21327;&#35758;&#30340;&#29256;&#26412;
</span>[root@ovs2 ~]#ovs-appctl --version
<span style="color: #0000ff;">ovs-appctl</span> (Open vSwitch) 2.9.5
[root@ovs2 ~]#ovs-ofctl --version
<span style="color: #0000ff;">ovs-ofctl</span> (Open vSwitch) 2.9.5
OpenFlow versions 0x1:0x5
[root@ovs2 ~]#brctl show
bridge name bridge id STP enabled interfaces
docker0 8000.0242e2388483 no
</pre>
</div>

<p>
4 在两个宿主机都创建obr0网桥并激活<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">[root@ovs1 ~]#ovs-vsctl add-br obr0
[root@ovs1 ~]#ip link set dev obr0 up
[root@ovs1 ~]#ip a
4: ovs-system: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group
default qlen 1000
link/ether ce:ff:6f:7f:4b:11 brd ff:ff:ff:ff:ff:ff
5: obr0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UNKNOWN
group default qlen 1000
link/ether f2:2b:d7:d8:a1:4d brd ff:ff:ff:ff:ff:ff
inet6 fe80::f02b:d7ff:fed8:a14d/64 scope link
valid_lft forever preferred_lft forever

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#31532;&#20108;&#21488;&#20027;&#26426;&#37325;&#22797;&#19978;&#38754;
</span>[root@ovs2 ~]#ovs-vsctl add-br obr0
[root@ovs2 ~]#ip link set dev obr0 up
[root@ovs2 ~]#ip a
4: ovs-system: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group
default qlen 1000
5: obr0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UNKNOWN
group default qlen 1000
link/ether 82:4f:05:e3:5d:42 brd ff:ff:ff:ff:ff:ff
inet6 fe80::804f:5ff:fee3:5d42/64 scope link
valid_lft forever preferred_lft forever
</pre>
</div>

<p>
5 在两个宿主机创建gre隧道(remote_ip为peer宿主机ip)<br>
</p>

<p>
注意: 如果有多台docker主机需要构建网络创建多个gre隧道<br>
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#19968;&#26465;&#21629;&#20196;&#23454;&#29616;,remote_ip&#25351;&#21521;&#21478;&#19968;&#21488;&#23487;&#20027;&#26426;&#30340;IP
</span>[root@ovs1 ~]#ovs-vsctl add-port obr0 gre0 -- set Interface gre0 <span style="color: #a0522d;">type</span>=gre options:<span style="color: #a0522d;">remote_ip</span>=10.0.0.102

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#25110;&#32773;&#20004;&#26465;&#21629;&#20196;&#23454;&#29616;
</span>[root@ovs1 ~]#ovs-vsctl add-port obr0 gre0
[root@ovs1 ~]#ovs-vsctl set Interface gre0 <span style="color: #a0522d;">type</span>=gre options:<span style="color: #a0522d;">remote_ip</span>=10.0.0.102
[root@ovs1 ~]#ovs-vsctl list-ports obr0
gre0
[root@ovs1 ~]#ovs-vsctl show
84cbdad7-4731-4c2e-b7d7-eecb4a56d27b
Bridge <span style="color: #8b2252;">"obr0"</span>
Port <span style="color: #8b2252;">"gre0"</span>
Interface <span style="color: #8b2252;">"gre0"</span>
<span style="color: #483d8b;">type</span>: gre
options: {<span style="color: #a0522d;">remote_ip</span>=<span style="color: #8b2252;">"10.0.0.102"</span>}
Port <span style="color: #8b2252;">"obr0"</span>
Interface <span style="color: #8b2252;">"obr0"</span>
<span style="color: #483d8b;">type</span>: internal
ovs_version: <span style="color: #8b2252;">"2.9.5"</span>

[root@ovs1 ~]#ip a
4: ovs-system: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group
default qlen 1000
link/ether ce:ff:6f:7f:4b:11 brd ff:ff:ff:ff:ff:ff
5: obr0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UNKNOWN
link/ether f2:2b:d7:d8:a1:4d brd ff:ff:ff:ff:ff:ff
inet6 fe80::f02b:d7ff:fed8:a14d/64 scope link
valid_lft forever preferred_lft forever
6: gre0@NONE: &lt;NOARP&gt; mtu 1476 qdisc noop state DOWN group default qlen 1000
link/gre 0.0.0.0 brd 0.0.0.0
7: gretap0@NONE: &lt;BROADCAST,MULTICAST&gt; mtu 1462 qdisc noop state DOWN group
default qlen 1000
link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff
8: erspan0@NONE: &lt;BROADCAST,MULTICAST&gt; mtu 1450 qdisc noop state DOWN group
default qlen 1000
link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff
9: gre_sys@NONE: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 65000 qdisc fq_codel
master ovs-system state UNKNOWN group default qlen 1000
link/ether ce:d2:c1:4e:be:c6 brd ff:ff:ff:ff:ff:ff
inet6 fe80::ccd2:c1ff:fe4e:bec6/64 scope link
valid_lft forever preferred_lft forever

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#37197;&#32622;&#31532;&#20108;&#20010;&#23487;&#20027;&#26426;
</span>[root@ovs2 ~]#ovs-vsctl add-port obr0 gre0 -- set Interface gre0 <span style="color: #a0522d;">type</span>=gre options:<span style="color: #a0522d;">remote_ip</span>=10.0.0.101
[root@ovs2 ~]#ovs-vsctl list-ports obr0
gre0
[root@ovs2 ~]#ovs-vsctl show
e6a3aab3-e224-4834-85fc-2516b33a67e2
Bridge <span style="color: #8b2252;">"obr0"</span>
Port <span style="color: #8b2252;">"gre0"</span>
Interface <span style="color: #8b2252;">"gre0"</span>
<span style="color: #483d8b;">type</span>: gre
options: {<span style="color: #a0522d;">remote_ip</span>=<span style="color: #8b2252;">"10.0.0.101"</span>}
Port <span style="color: #8b2252;">"obr0"</span>
Interface <span style="color: #8b2252;">"obr0"</span>
<span style="color: #483d8b;">type</span>: internal
ovs_version: <span style="color: #8b2252;">"2.9.5"</span>
[root@ovs2 ~]#ip a
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group
default qlen 1000
link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
inet 127.0.0.1/8 scope host lo
valid_lft forever preferred_lft forever
inet6 ::1/128 scope host
valid_lft forever preferred_lft forever
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP
group default qlen 1000
link/ether 00:0c:29:01:f3:0c brd ff:ff:ff:ff:ff:ff
inet 10.0.0.102/24 brd 10.0.0.255 scope global eth0
valid_lft forever preferred_lft forever
inet6 fe80::20c:29ff:fe01:f30c/64 scope link
valid_lft forever preferred_lft forever
3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state
DOWN group default
link/ether 02:42:e2:38:84:83 brd ff:ff:ff:ff:ff:ff
inet 192.168.2.1/24 brd 192.168.2.255 scope global docker0
valid_lft forever preferred_lft forever
4: ovs-system: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group
default qlen 1000
5: obr0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UNKNOWN
group default qlen 1000
link/ether 82:4f:05:e3:5d:42 brd ff:ff:ff:ff:ff:ff
inet6 fe80::804f:5ff:fee3:5d42/64 scope link
valid_lft forever preferred_lft forever
6: gre0@NONE: &lt;NOARP&gt; mtu 1476 qdisc noop state DOWN group default qlen 1000
link/gre 0.0.0.0 brd 0.0.0.0
7: gretap0@NONE: &lt;BROADCAST,MULTICAST&gt; mtu 1462 qdisc noop state DOWN group
default qlen 1000
link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff
8: erspan0@NONE: &lt;BROADCAST,MULTICAST&gt; mtu 1450 qdisc noop state DOWN group
default qlen 1000
link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff
10: gre_sys@NONE: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 65000 qdisc fq_codel
master ovs-system state UNKNOWN group default qlen 1000
link/ether 0a:98:48:d9:5f:83 brd ff:ff:ff:ff:ff:ff
inet6 fe80::898:48ff:fed9:5f83/64 scope link
valid_lft forever preferred_lft forever
</pre>
</div>

<p>
6 在两个宿主机将obr0作为接口加入docker0网桥<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#31532;&#19968;&#21488;&#23487;&#20027;&#26426;&#25191;&#34892;
</span>[root@ovs1 ~]#brctl addif docker0 obr0
[root@ovs1 ~]#brctl show
bridge name bridge id STP enabled interfaces
docker0 8000.0242dc29036c no obr0
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#31532;&#20108;&#21488;&#23487;&#20027;&#26426;&#25191;&#34892;&#21516;&#26679;&#25805;&#20316;
</span>[root@ovs2 ~]#brctl addif docker0 obr0
[root@ovs2 ~]#brctl show
bridge name bridge id STP enabled interfaces
docker0 8000.0242e2388483 no obr0
</pre>
</div>

<p>
7 在两个宿主机添加静态路由(网段地址为 peer Docker网段)<br>
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">ovs1 &#28155;&#21152; peer docker net
</span>[root@ovs1 ~]#ip route add 192.168.2.0/24 dev docker0
[root@ovs1 ~]#route -n
Kernel IP routing table
Destination Gateway Genmask Flags Metric Ref Use Iface
0.0.0.0 10.0.0.2 0.0.0.0 UG 0 0 0 eth0
10.0.0.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0
192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 docker0
192.168.2.0 0.0.0.0 255.255.255.0 U 0 0 0 docker0
<span style="color: #b22222;">#</span><span style="color: #b22222;">ovs2 &#28155;&#21152; peer docker net
</span>[root@ovs2 ~]#ip route add 192.168.1.0/24 dev docker0
[root@ovs2 ~]#route -n
Kernel IP routing table
Destination Gateway Genmask Flags Metric Ref Use Iface
0.0.0.0 10.0.0.2 0.0.0.0 UG 0 0 0 eth0
10.0.0.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0
192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 docker0
192.168.2.0 0.0.0.0 255.255.255.0 U 0 0 0 docker0
</pre>
</div>

<p>
8 在两个宿主机测试跨主机的容器之间的连通性<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">[root@ovs1 ~]#docker run -it alpine /bin/sh
/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ip a
</span>2: gre0@NONE: &lt;NOARP&gt; mtu 1476 qdisc noop state DOWN qlen 1000
link/gre 0.0.0.0 brd 0.0.0.0
3: gretap0@NONE: &lt;BROADCAST,MULTICAST&gt; mtu 1462 qdisc noop state DOWN qlen 1000
link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff
4: erspan0@NONE: &lt;BROADCAST,MULTICAST&gt; mtu 1450 qdisc noop state DOWN qlen 1000
link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff
10: eth0@if11: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue
state UP
link/ether 02:42:ac:11:01:02 brd ff:ff:ff:ff:ff:ff
inet 192.168.1.2/24 brd 192.168.1.255 scope global eth0
valid_lft forever preferred_lft forever

/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping -c 3 192.168.2.2
</span>PING 192.168.2.2 (192.168.2.2): 56 data bytes
64 bytes from 192.168.2.2: <span style="color: #a0522d;">seq</span>=0 <span style="color: #a0522d;">ttl</span>=63 <span style="color: #a0522d;">time</span>=4.459 ms
64 bytes from 192.168.2.2: <span style="color: #a0522d;">seq</span>=1 <span style="color: #a0522d;">ttl</span>=63 <span style="color: #a0522d;">time</span>=1.279 ms
64 bytes from 192.168.2.2: <span style="color: #a0522d;">seq</span>=2 <span style="color: #a0522d;">ttl</span>=63 <span style="color: #a0522d;">time</span>=0.517 ms
--- 192.168.2.2 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 0.517/2.085/4.459 ms
[root@ovs2 ~]#docker run -it alpine /bin/sh

/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ip a
</span>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000
link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
inet 127.0.0.1/8 scope host lo
valid_lft forever preferred_lft forever
2: gre0@NONE: &lt;NOARP&gt; mtu 1476 qdisc noop state DOWN qlen 1000
link/gre 0.0.0.0 brd 0.0.0.0
3: gretap0@NONE: &lt;BROADCAST,MULTICAST&gt; mtu 1462 qdisc noop state DOWN qlen 1000
link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff
4: erspan0@NONE: &lt;BROADCAST,MULTICAST&gt; mtu 1450 qdisc noop state DOWN qlen 1000
link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff
11: eth0@if12: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue
state UP
link/ether 02:42:ac:11:02:02 brd ff:ff:ff:ff:ff:ff
inet 192.168.2.2/24 brd 192.168.2.255 scope global eth0
valid_lft forever preferred_lft forever

/ <span style="color: #b22222;"># </span><span style="color: #b22222;">ping -c 3 192.168.1.2
</span>PING 192.168.1.2 (192.168.1.2): 56 data bytes
64 bytes from 192.168.1.2: <span style="color: #a0522d;">seq</span>=0 <span style="color: #a0522d;">ttl</span>=63 <span style="color: #a0522d;">time</span>=1.553 ms
64 bytes from 192.168.1.2: <span style="color: #a0522d;">seq</span>=1 <span style="color: #a0522d;">ttl</span>=63 <span style="color: #a0522d;">time</span>=1.136 ms
64 bytes from 192.168.1.2: <span style="color: #a0522d;">seq</span>=2 <span style="color: #a0522d;">ttl</span>=63 <span style="color: #a0522d;">time</span>=1.176 ms
--- 192.168.1.2 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 1.136/1.288/1.553 ms
</pre>
</div>

<p>
在第二个主机上再打开一个nginx容器，从第一个主机的容器访问，观察来源的IP<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ovs2 ~]#docker pull nginx
[root@ovs2 ~]#docker run -d --name nginx nginx
d3c26005a7626628f7baf017481217b36e3d69dabfa6cc86fe125f9548e7333c
[root@ovs2 ~]#docker exec -it nginx hostname -I
192.168.2.2
[root@ovs2 ~]#docker logs -f nginx
192.168.1.2 - - [27/Feb/2020:09:57:18 +0000] <span style="color: #8b2252;">"GET / HTTP/1.1"</span> 200 612 <span style="color: #8b2252;">"-"</span> <span style="color: #8b2252;">"Wget"</span> <span style="color: #8b2252;">"-"</span>

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#20174;&#31532;&#19968;&#20010;&#20027;&#26426;&#30340;&#23481;&#22120;&#21457;&#36215;&#35831;&#27714;&#65292;&#21487;&#20197;&#26597;&#30475;&#21040;&#19978;&#38754;&#30340;&#35775;&#38382;&#26085;&#24535;&#36755;&#20986;
</span>[root@ovs1 ~]#docker run -it alpine wget -qO - http://192.168.2.2/
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;style&gt;
body {
width: 35em;
margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif;
}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
&lt;p&gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&lt;/p&gt;
&lt;p&gt;For online documentation and support please refer to
&lt;a <span style="color: #a0522d;">href</span>=<span style="color: #8b2252;">"http://nginx.org/"</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;
Commercial support is available at
&lt;a <span style="color: #a0522d;">href</span>=<span style="color: #8b2252;">"http://nginx.com/"</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

<p>
9 在两个宿主机用脚本保存配置用于开机启动<br>
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">ovs1&#37197;&#32622;
</span>[root@ovs1 ~]#cat &gt; net.sh &lt;&lt;EOF<span style="color: #ffa54f;">
#!/bin/bash
ip link set dev obr0 up
brctl addif docker0 obr0
ip route add 192.168.2.0/24 dev docker0
EOF
</span>[root@ovs1 ~]#chmod +x net.sh
<span style="color: #b22222;">#</span><span style="color: #b22222;">ovs2&#37197;&#32622;
</span>[root@ovs2 ~]#cat &gt; net.sh &lt;&lt;EOF<span style="color: #ffa54f;">
#!/bin/bash
ip link set dev obr0 up
brctl addif docker0 obr0
ip route add 192.168.1.0/24 dev docker0
EOF
</span>[root@ovs1 ~]#chmod +x net.sh
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:fdf82461-02b4-4f8a-81eb-f0b668d7031d" class="outline-4">
<h4 id="h:fdf82461-02b4-4f8a-81eb-f0b668d7031d">方式4: 使用 weave 实现跨主机的容器间互联</h4>
<div class="outline-text-4" id="text-h:fdf82461-02b4-4f8a-81eb-f0b668d7031d">
</div>
<div id="outline-container-h:f2183123-67cf-4f52-8590-365bf0e4f603" class="outline-5">
<h5 id="h:f2183123-67cf-4f52-8590-365bf0e4f603">weave 介绍</h5>
<div class="outline-text-5" id="text-h:f2183123-67cf-4f52-8590-365bf0e4f603">
<p>
weave 原意编织,意在建立一个虚拟的网络，用于将运行在不同主机的Docker容器连接起来<br>
</p>

<p>
官网: <a href="http://weave.works">http://weave.works</a><br>
github链接: <a href="https://github.com/weaveworks/weave#readme">https://github.com/weaveworks/weave#readme</a><br>
</p>
</div>
</div>
<div id="outline-container-h:7c9d7e37-6062-4941-886f-aebc45a02a75" class="outline-5">
<h5 id="h:7c9d7e37-6062-4941-886f-aebc45a02a75">weave实现跨主机容器互联的流程</h5>
<div class="outline-text-5" id="text-h:7c9d7e37-6062-4941-886f-aebc45a02a75">
<p>
官方文档: <a href="https://www.weave.works/docs/net/latest/install/using-weave/">https://www.weave.works/docs/net/latest/install/using-weave/</a><br>
</p>


<figure id="orgf8687ec">
<img src="./images/Snipaste_2023-04-28_14-56-22.png" alt="Snipaste_2023-04-28_14-56-22.png"><br>

</figure>

<p>
weave实现跨主机容器互联的流程<br>
</p>
<ul class="org-ul">
<li>安装weave<br></li>
<li>启动weave $weave launch<br></li>
<li>连接不同主机<br></li>
<li>通过weave启动容器<br></li>
</ul>
</div>
</div>
<div id="outline-container-h:166c535e-567d-496e-a2d7-5e9ba5e057db" class="outline-5">
<h5 id="h:166c535e-567d-496e-a2d7-5e9ba5e057db">实战案例: 通过weave 实现跨主机容器的互联</h5>
<div class="outline-text-5" id="text-h:166c535e-567d-496e-a2d7-5e9ba5e057db">
<p>
1 环境准备<br>
主机名 操作系统 宿主机IP Docker0 IP 容器<br>
ubuntu1804 ubuntu 18.04 10.0.0.100/24 172.17.0.1/16 a1<br>
centos7 centos 7.8 10.0.0.200/24 172.17.0.1/16 a2<br>
</p>

<p>
2 安装weave<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#wget -O /usr/bin/weave https://raw.githubusercontent.com/zettio/weave/master/weave

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#22312;&#31532;&#20108;&#20010;&#23487;&#20027;&#26426;&#37325;&#22797;&#19968;&#26679;&#30340;&#25805;&#20316;
</span>[root@centos7 ~]#wget -O /usr/bin/weave https://raw.githubusercontent.com/zettio/weave/master/weave
</pre>
</div>

<p>
3 第一个宿主机启动weave<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#chmod +x /usr/bin/weave
[root@ubuntu1804 ~]#weave launch
... ...
Digest: sha256:e666e66bf10c9da5dce52b777e86f9fbb62157169614a80f2dbe324b335c5602
Status: Downloaded newer image for weaveworks/weaveexec:latest
0244d489c1dfe1b403a6e1cf228f260e84cafabea408d8cdabee1b0ca09c7519
</pre>
</div>

<p>
4 启动第二宿主机的weave并连接第一个宿主机<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#22312;&#31532;&#20108;&#20010;&#23487;&#20027;&#26426;&#21551;&#21160;weave
</span>[root@centos7 ~]#chmod +x /usr/bin/weave
[root@centos7 ~]#weave launch 10.0.0.100
... ...
ab2ebef1670374ae81c3031c9de96df4136e55749f914eaddcb8e5e5aee60c6c

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26597;&#30475;&#20004;&#20010;&#23487;&#20027;&#26426;&#30340;&#36830;&#25509;
</span>[root@centos7 ~]#ss -nt
State Recv-Q Send-Q LocalAddress:Port Peer Address:Port
ESTAB 0 0 10.0.0.200:46521 10.0.0.100:6783
</pre>
</div>


<p>
5 通过weave 启动容器<br>
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#31532;&#19968;&#20010;&#23487;&#20027;&#26426;&#21021;&#22987;&#21270;&#29615;&#22659;
</span>[root@ubuntu1804 ~]#eval $(weave env)
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#31532;&#19968;&#20010;&#23487;&#20027;&#26426;&#24320;&#21551;&#21160;&#23481;&#22120;
</span>[root@ubuntu1804 ~]#docker run --name a1 -ti weaveworks/ubuntu
root@a1:/# hostname -i
10.32.0.1
root@a1:/# ping -c1 a2
PING a2 (10.44.0.0) 56(84) bytes of data.
64 bytes from a2.weave.local (10.44.0.0): <span style="color: #a0522d;">icmp_seq</span>=1 <span style="color: #a0522d;">ttl</span>=64 <span style="color: #a0522d;">time</span>=3.33 ms

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#31532;&#20108;&#20010;&#23487;&#20027;&#26426;&#21021;&#22987;&#21270;&#29615;&#22659;
</span>[root@centos7 ~]#eval $(weave env)
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#31532;&#20108;&#20010;&#23487;&#20027;&#26426;&#24320;&#21551;&#21160;&#23481;&#22120;
</span>[root@centos7 ~]#docker run --name a2 -ti weaveworks/ubuntu
root@a2:/# hostname -i
10.44.0.0
root@a2:/# ping a1 -c1
PING a1 (10.32.0.1) 56(84) bytes of data.
64 bytes from a1.weave.local (10.32.0.1): <span style="color: #a0522d;">icmp_seq</span>=1 <span style="color: #a0522d;">ttl</span>=64 <span style="color: #a0522d;">time</span>=0.474 ms
</pre>
</div>

<p>
6 查看宿主机的容器<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#33258;&#21160;&#29983;&#25104;&#20102;weave&#30456;&#20851;&#30340;&#23481;&#22120;
</span>[root@ubuntu1804 ~]#docker ps -a

[root@centos7 ~]#docker ps -a
</pre>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="outline-container-h:9253d262-515b-446b-96dc-605814572982" class="outline-2">
<h2 id="h:9253d262-515b-446b-96dc-605814572982">Docker 仓库管理</h2>
<div class="outline-text-2" id="text-h:9253d262-515b-446b-96dc-605814572982">
<p>
Docker仓库，类似于yum仓库，是用来保存镜像的仓库。为了方便的管理和使用docker镜像,可以将镜像集中保存至Docker仓库中，将制作好的镜像push到仓库集中保存，在需要镜像时，从仓库中pull镜像即可。<br>
</p>

<p>
Docker 仓库分为公有云仓库和私有云仓库<br>
</p>

<p>
公有云仓库: 由互联网公司对外公开的仓库<br>
</p>
<ul class="org-ul">
<li>官方<br></li>
<li>阿里云等第三方仓库<br></li>
</ul>

<p>
私有云仓库: 组织内部搭建的仓库，一般只为组织内部使用，常使用下面软件搭建仓库<br>
</p>
<ul class="org-ul">
<li>docker registory<br></li>
<li>docker harbor<br></li>
</ul>
</div>
<div id="outline-container-h:e8d01552-a72e-4ff4-a9bb-d0ba0c1da278" class="outline-3">
<h3 id="h:e8d01552-a72e-4ff4-a9bb-d0ba0c1da278">官方 docker 仓库</h3>
<div class="outline-text-3" id="text-h:e8d01552-a72e-4ff4-a9bb-d0ba0c1da278">
<p>
将自制的镜像上传至docker仓库；<a href="https://hub.docker.com/">https://hub.docker.com/</a><br>
</p>
</div>
<div id="outline-container-h:9964db38-5aad-4d6c-8a00-49e7b3f710e6" class="outline-4">
<h4 id="h:9964db38-5aad-4d6c-8a00-49e7b3f710e6">使用用户仓库管理镜像</h4>
<div class="outline-text-4" id="text-h:9964db38-5aad-4d6c-8a00-49e7b3f710e6">
<p>
每个注册用户都可以上传和管理自已的镜像<br>
</p>

<p>
1 用户登录<br>
上传镜像前需要执行docker login命令登录，登录后生成~/.docker/config.json文件保存验证信息<br>
</p>

<p>
格式<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker login [OPTIONS] [SERVER]
&#36873;&#39033;:
-p, --password string Password
--password-stdin Take the password from stdin
-u, --username string Username
</pre>
</div>

<p>
范例:<br>
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#30331;&#24405;docker&#23448;&#26041;&#20179;&#24211;&#26041;&#27861;1
</span>[root@ubuntu1804 ~]#docker login -u xxx -pP@ssw0rd! docker.io

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#30331;&#24405;docker&#23448;&#26041;&#20179;&#24211;&#26041;&#27861;2
</span>[root@ubuntu1804 ~]#docker login
Username: xxx
Password:
Login Succeeded

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#30331;&#24405;&#25104;&#21151;&#21518;,&#33258;&#21160;&#29983;&#25104;&#39564;&#35777;&#20449;&#24687;,&#19979;&#27425;&#20250;&#33258;&#21160;&#30331;&#24405;,&#32780;&#26080;&#38656;&#25163;&#21160;&#30331;&#24405;
</span>[root@ubuntu1804 ~]#cat .docker/config.json
{
<span style="color: #8b2252;">"auths"</span>: {
<span style="color: #8b2252;">"https://index.docker.io/v1/"</span>: {
<span style="color: #8b2252;">"auth"</span>: <span style="color: #8b2252;">"d2FuZ3hpYW9jaHVuOmxidG9vdGgwNjE4"</span>
}
},
<span style="color: #8b2252;">"HttpHeaders"</span>: {
<span style="color: #8b2252;">"User-Agent"</span>: <span style="color: #8b2252;">"Docker-Client/19.03.5 (linux)"</span>
}
}
</pre>
</div>

<p>
2 给本地镜像打标签<br>
上传本地镜像前必须先给上传的镜像用docker tag 命令打标签<br>
标签格式: docker.io/用户帐号/镜像名:TAG<br>
</p>

<p>
范例:<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker tag alpine:3.11 docker.io/xxx/alpine:3.11-v1
</pre>
</div>

<p>
3 上传本地镜像至官网<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#22914;tag&#30465;&#30053;,&#23558;&#19978;&#20256;&#25351;&#23450;REPOSITORY&#30340;&#25152;&#26377;&#29256;&#26412;,&#22914;&#19979;&#31034;&#20363;
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">[root@ubuntu1804 ~]#docker push docker.io/xxx/alpine
</span>
[root@ubuntu1804 ~]#docker push docker.io/xxx/alpine:3.11-v1
</pre>
</div>
</div>
</div>
<div id="outline-container-h:a00790c9-307b-4873-8a44-4584696c7070" class="outline-4">
<h4 id="h:a00790c9-307b-4873-8a44-4584696c7070">docker login 凭证</h4>
<div class="outline-text-4" id="text-h:a00790c9-307b-4873-8a44-4584696c7070">
<p>
<a href="https://docs.docker.com/engine/reference/commandline/login/">https://docs.docker.com/engine/reference/commandline/login/</a><br>
</p>

<p>
`$HOME/.docker/config.json`<br>
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#26041;&#27861;1
</span><span style="color: #483d8b;">echo</span> <span style="color: #8b2252;">"1qaz@WSX3edc"</span> | docker login tope365-registry.cn-beijing.cr.aliyuncs.com -u topedocker@tope365 --password-stdin
<span style="color: #483d8b;">echo</span> <span style="color: #8b2252;">"1qaz@WSX3edc"</span> | docker login registry.cn-beijing.aliyuncs.com -u topedocker@tope365 --password-stdin

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26041;&#27861;2
</span>(<span style="color: #483d8b;">umask</span> 077; mkdir /root/.docker; touch /root/.docker/config.json)
<span style="color: #a0522d;">dLogin</span>=<span style="color: #ff00ff;">`echo 'topedocker@tope365:1qaz@WSX3edc'|openssl  base64`</span>
<span style="color: #a0522d;">DOCKER_VERSION</span>=<span style="color: #ff00ff;">`docker info |grep 'Server Version' |awk -F'[: ]+' '{print $4}'`</span>
cat &lt;&lt;EOF &gt; /root/.docker/config.json<span style="color: #ffa54f;">
{
    "auths": {
        "registry-vpc.cn-beijing.aliyuncs.com": {
            "auth": "$dLogin"
        },
        "registry.cn-beijing.aliyuncs.com": {
            "auth": "$dLogin"
        },
        "tope365-registry-vpc.cn-beijing.cr.aliyuncs.com": {
            "auth": "$dLogin"
        },
        "tope365-registry.cn-beijing.cr.aliyuncs.com": {
            "auth": "$dLogin"
        }
    },
    "HttpHeaders": {
        "User-Agent": "Docker-Client/$DOCKER_VERSION (linux)"
    }
}
EOF
</span>&#27880;&#24847;&#36824;&#26159;&#35201;login
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:20a85657-83f5-49a3-83c5-6c76b93fd8f7" class="outline-3">
<h3 id="h:20a85657-83f5-49a3-83c5-6c76b93fd8f7">私有云单机仓库Docker Registry</h3>
<div class="outline-text-3" id="text-h:20a85657-83f5-49a3-83c5-6c76b93fd8f7">
</div>
<div id="outline-container-h:648b4a75-f5ae-437c-bed7-c9139b7169d6" class="outline-4">
<h4 id="h:648b4a75-f5ae-437c-bed7-c9139b7169d6">Docker Registry 介绍</h4>
<div class="outline-text-4" id="text-h:648b4a75-f5ae-437c-bed7-c9139b7169d6">
<p>
Docker Registry作为Docker的核心组件之一负责单主机的镜像内容的存储与分发，客户端的docker pull以及push命令都将直接与registry进行交互,最初版本的registry 由Python实现，由于设计初期在安<br>
全性，性能以及API的设计上有着诸多的缺陷，该版本在0.9之后停止了开发，由新项目 distribution（新的docker register被称为Distribution）来重新设计并开发下一代registry，新的项目由go语言开发，所有的API，底层存储方式，系统架构都进行了全面的重新设计已解决上一代registry中存在的问题，2016年4月份registry 2.0正式发布，docker 1.6版本开始支持registry 2.0，而八月份随着docker 1.8 发布，docker hub正式启用2.1版本registry全面替代之前版本 registry，新版registry对镜像存储格式进行了重新设计并和旧版不兼容，docker 1.5和之前的版本无法读取2.0的镜像，另外，Registry 2.4版本之后支持了回收站机制，也就是可以删除镜像了，在2.4版本之前是无法支持删除镜像的，所以如果你要使用最好是大于Registry 2.4版本的<br>
</p>

<p>
官方文档地址: <a href="https://docs.docker.com/registry/">https://docs.docker.com/registry/</a><br>
</p>

<p>
官方github 地址: <a href="https://github.com/docker/distribution">https://github.com/docker/distribution</a><br>
</p>

<p>
官方部署文档: <a href="https://github.com/docker/docker.github.io/blob/master/registry/deploying.md">https://github.com/docker/docker.github.io/blob/master/registry/deploying.md</a><br>
</p>

<p>
以下介绍通过官方提供的docker registry 镜像来简单搭建本地私有仓库环境<br>
</p>

<p>
环境: 三台主机<br>
</p>
<ul class="org-ul">
<li>10.0.0.100: 充当registry仓库服务器<br></li>
<li>10.0.0.101: 上传镜像<br></li>
<li>10.0.0.102: 下载镜像<br></li>
</ul>
</div>
</div>
<div id="outline-container-h:329f3d2b-468a-4180-a718-82d3ee1d0311" class="outline-4">
<h4 id="h:329f3d2b-468a-4180-a718-82d3ee1d0311">下载 docker registry 镜像</h4>
<div class="outline-text-4" id="text-h:329f3d2b-468a-4180-a718-82d3ee1d0311">
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker pull registry:2.7.1
[root@ubuntu1804 ~]#docker images
REPOSITORY TAG IMAGE ID CREATED
SIZE
registry 2.7.1 708bc6af7e5e 6 days ago
25.8MB
</pre>
</div>
</div>
</div>
<div id="outline-container-h:d7aed6bf-660c-44e5-b7a6-f9527503e1f7" class="outline-4">
<h4 id="h:d7aed6bf-660c-44e5-b7a6-f9527503e1f7">搭建单机仓库</h4>
<div class="outline-text-4" id="text-h:d7aed6bf-660c-44e5-b7a6-f9527503e1f7">
<p>
1 创建授权用户密码使用目录<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#mkdir -p /etc/docker/auth
</pre>
</div>

<p>
2 创建授权的registry用户和密码<br>
创建registry用户，用于上传和下载镜像<br>
</p>
<div class="org-src-container">
<pre class="src src-shelll">[root@ubuntu1804 ~]#apt -y install apache2
[root@ubuntu1804 ~]#htpasswd -Bbn user1 123456 &gt; /etc/docker/auth/registry
[root@ubuntu1804 ~]#cat /etc/docker/auth/registry
user1:$2y$05$nlRIIYEUBTSLdN2PkzodUue4ry7X/UyscpkkEufTDhEdI8nsyJMR6

#[root@ubuntu1804 ~]#docker run --entrypoint htpasswd registry:2.7.1 -Bbn user1 123456 &gt; /etc/docker/auth/registry
</pre>
</div>

<p>
3 启动docker registry 容器<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]# docker run -d -p 5000:5000 --restart=always --name registry -v /etc/docker/auth:/auth -e <span style="color: #8b2252;">"REGISTRY_AUTH=htpasswd"</span> -e <span style="color: #8b2252;">"REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm"</span> -e <span style="color: #a0522d;">REGISTRY_AUTH_HTPASSWD_PATH</span>=/auth/registry registry:2.7.1
</pre>
</div>

<p>
4 验证端口和容器<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker ps
CONTAINER ID IMAGE COMMAND CREATED
STATUS PORTS NAMES
998f970dd8ca registry:2.7.1 <span style="color: #8b2252;">"/entrypoint.sh /etc&#8230;"</span> About a minute
ago Up About a minute 0.0.0.0:5000-&gt;5000/tcp registry

[root@ubuntu1804 ~]#ss -ntl
LISTEN 0 128 *:5000 *:*
</pre>
</div>
</div>
</div>
<div id="outline-container-h:1f3e6743-dddf-473c-90ab-884904d07112" class="outline-4">
<h4 id="h:1f3e6743-dddf-473c-90ab-884904d07112">登录仓库</h4>
<div class="outline-text-4" id="text-h:1f3e6743-dddf-473c-90ab-884904d07112">
<p>
1 直接登录报错<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">docker login &#40664;&#35748;&#20351;&#29992;https&#30331;&#24405;,&#32780;docker registry&#20026;http,&#25152;&#20197;&#40664;&#35748;&#30331;&#24405;&#22833;&#36133;
</span>[root@ubuntu1804 ~]#docker login 10.0.0.100:500
Username: user1
Password:
Error response from daemon: Get https://10.0.0.100:500/v2/: dial tcp
10.0.0.100:500: connect: connection refused
</pre>
</div>

<p>
2 将registry仓库服务器地址加入service 单元文件<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#20462;&#25913;&#37197;&#32622;&#35753;docker login&#25903;&#25345;http&#21327;&#35758;
</span>[root@ubuntu1804 ~]#vim /lib/systemd/system/docker.service
[root@ubuntu1804 ~]#grep ExecStart /lib/systemd/system/docker.service
<span style="color: #a0522d;">ExecStart</span>=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --insecure-registry 10.0.0.100:5000

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#25110;&#32773;&#20462;&#25913;&#19979;&#38754;&#25991;&#20214;
</span>[root@ubuntu1804 ~]#vim /etc/docker/daemon.json
{
<span style="color: #8b2252;">"registry-mirrors"</span>: [<span style="color: #8b2252;">"https://si7y70hh.mirror.aliyuncs.com"</span>],
<span style="color: #8b2252;">"insecure-registry"</span>: [<span style="color: #8b2252;">"10.0.0.100:5000"</span>]
}

[root@ubuntu1804 ~]#systemctl daemon-reload
[root@ubuntu1804 ~]#systemctl restart docker

</pre>
</div>

<p>
3 再次登录验证成功<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker login 10.0.0.100:5000
Username: user1
Password:
Login Succeeded
</pre>
</div>
</div>
</div>
<div id="outline-container-h:24c96ef6-b932-433b-afd6-2f8755ea92ee" class="outline-4">
<h4 id="h:24c96ef6-b932-433b-afd6-2f8755ea92ee">打标签并上传镜像</h4>
<div class="outline-text-4" id="text-h:24c96ef6-b932-433b-afd6-2f8755ea92ee">
<p>
在10.0.0.101主机上执行打标签上传<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker tag centos7-base:v1 10.0.0.100:5000/centos7-base:v1
[root@ubuntu1804 ~]#docker push 10.0.0.100:5000/centos7-base:v1
</pre>
</div>
</div>
</div>
<div id="outline-container-h:d6b203c9-d0fe-4f8d-bfe7-6d4d257cb7f9" class="outline-4">
<h4 id="h:d6b203c9-d0fe-4f8d-bfe7-6d4d257cb7f9">下载镜像并启动容器</h4>
<div class="outline-text-4" id="text-h:d6b203c9-d0fe-4f8d-bfe7-6d4d257cb7f9">
<p>
在10.0.0.102主机上下载镜像并启动容器<br>
</p>

<p>
1 先修改docker的service 文件<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#vim /lib/systemd/system/docker.service
[root@ubuntu1804 ~]#grep ExecStart /lib/systemd/system/docker.service
<span style="color: #a0522d;">ExecStart</span>=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --insecure-registry 10.0.0.100:5000
[root@ubuntu1804 ~]#systemctl daemon-reload
[root@ubuntu1804 ~]#systemctl restart docker
</pre>
</div>

<p>
2 登录registry仓库服务器<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker login 10.0.0.100:5000
Username: user1
Password:
Login Succeeded
</pre>
</div>

<p>
3 下载镜像并启动容器<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker pull 10.0.0.100:5000/centos7-base:v1
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:ea7ed4b4-e9df-4fe5-bd8e-0618d0321f81" class="outline-3">
<h3 id="h:ea7ed4b4-e9df-4fe5-bd8e-0618d0321f81">Docker 之分布式仓库 Harbor</h3>
<div class="outline-text-3" id="text-h:ea7ed4b4-e9df-4fe5-bd8e-0618d0321f81">
</div>
<div id="outline-container-h:34887dbe-6496-4b4a-ba88-f7f95a94edd0" class="outline-4">
<h4 id="h:34887dbe-6496-4b4a-ba88-f7f95a94edd0">Harbor 介绍和架构</h4>
<div class="outline-text-4" id="text-h:34887dbe-6496-4b4a-ba88-f7f95a94edd0">
</div>
<div id="outline-container-h:9c8ccec3-f4da-4758-b822-7f2534cbe8c2" class="outline-5">
<h5 id="h:9c8ccec3-f4da-4758-b822-7f2534cbe8c2">Harbor 介绍</h5>
<div class="outline-text-5" id="text-h:9c8ccec3-f4da-4758-b822-7f2534cbe8c2">
<p>
Harbor是一个用于存储和分发Docker镜像的企业级Registry服务器，由VMware开源，其通过添加一些企业必需的功能特性，例如安全、标识和管理等，扩展了开源 Docker Distribution。作为一个企业级私有Registry服务器，Harbor 提供了更好的性能和安全。提升用户使用Registry构建和运行环境传输镜像的效率。Harbor支持安装在多个Registry节点的镜像资源复制，镜像全部保存在私有 Registry 中，确保数据和知识产权在公司内部网络中管控，另外，Harbor也提供了高级的安全特性，诸如用户管理，访问控制和活动审计等<br>
</p>

<p>
vmware 官方开源服务: <a href="https://vmware.github.io/">https://vmware.github.io/</a><br>
harbor 官方github 地址: <a href="https://github.com/vmware/harbor">https://github.com/vmware/harbor</a><br>
harbor 官方网址: <a href="https://goharbor.io/">https://goharbor.io/</a><br>
harbor 官方文档: <a href="https://goharbor.io/docs/">https://goharbor.io/docs/</a><br>
github文档: <a href="https://github.com/goharbor/harbor/tree/master/docs">https://github.com/goharbor/harbor/tree/master/docs</a><br>
</p>
</div>
</div>
<div id="outline-container-h:8bb01f97-88aa-4f20-8453-b523cfb3f02f" class="outline-5">
<h5 id="h:8bb01f97-88aa-4f20-8453-b523cfb3f02f">Harbor功能官方介绍</h5>
<div class="outline-text-5" id="text-h:8bb01f97-88aa-4f20-8453-b523cfb3f02f">
<ul class="org-ul">
<li>基于角色的访问控制: 用户与Docker镜像仓库通过“项目”进行组织管理，一个用户可以对多个镜像仓库在同一命名空间（project）里有不同的权限<br></li>
<li>镜像复制: 镜像可在多个Registry实例中复制（同步）。尤其适合于负载均衡，高可用，混合云和多云的场景<br></li>
<li>图形化用户界面: 用户可以通过浏览器来浏览，检索当前Docker镜像仓库，管理项目和命名空间<br></li>
<li>AD/LDAP 支: Harbor可以集成企业内部已有的AD/LDAP，用于鉴权认证管理<br></li>
<li>审计管理: 所有针对镜像仓库的操作都可以被记录追溯，用于审计管理<br></li>
<li>国际化: 已拥有英文、中文、德文、日文和俄文的本地化版本。更多的语言将会添加进来<br></li>
</ul>
</div>
</div>
<div id="outline-container-h:efa5ab09-c302-4286-8714-626a9dad03de" class="outline-5">
<h5 id="h:efa5ab09-c302-4286-8714-626a9dad03de">Harbor 组成</h5>
<div class="outline-text-5" id="text-h:efa5ab09-c302-4286-8714-626a9dad03de">

<figure id="org168bf5d">
<img src="./images/Snipaste_2023-04-28_16-58-16.png" alt="Snipaste_2023-04-28_16-58-16.png"><br>

</figure>

<p>
RESTful API: 提供给管理员对于Harbor更多的操控, 使得与其它管理软件集成变得更容易<br>
部署简单: 提供在线和离线两种安装工具， 也可以安装到vSphere平台(OVA方式)虚拟设备<br>
</p>

<ul class="org-ul">
<li>Proxy: 对应启动组件nginx。它是一个nginx反向代理，代理Notary client（镜像认证）、Dockerclient（镜像上传下载等）和浏览器的访问请求（Core Service）给后端的各服务<br></li>
<li>UI（Core Service）: 对应启动组件harbor-ui。底层数据存储使用mysql数据库，主要提供了四个子功能:<br>
<ul class="org-ul">
<li>UI: 一个web管理页面ui<br></li>
<li>API: Harbor暴露的API服务<br></li>
<li>Auth: 用户认证服务，decode后的token中的用户信息在这里进行认证；auth后端可以接db、ldap、uaa三种认证实现<br></li>
<li>Token服务（上图中未体现）: 负责根据用户在每个project中的role来为每一个dockerpush/pull命令发布一个token，如果从docker client发送给registry的请求没有带token，registry会重定向请求到token服务创建token<br></li>
</ul></li>
<li>Registry: 对应启动组件registry。负责存储镜像文件，和处理镜像的pull/push命令。Harbor对镜像进行强制的访问控制，Registry会将客户端的每个pull、push请求转发到token服务来获取有效的token<br></li>
<li>Admin Service: 对应启动组件harbor-adminserver。是系统的配置管理中心附带检查存储用量，ui和jobserver启动时候需要加载adminserver的配置<br></li>
<li>Job Sevice: 对应启动组件harbor-jobservice。负责镜像复制工作的，他和registry通信，从一个registry pull镜像然后push到另一个registry，并记录job_log<br></li>
<li>Log Collector: 对应启动组件harbor-log。日志汇总组件，通过docker的log-driver把日志汇总到一起<br></li>
<li>DB: 对应启动组件harbor-db，负责存储project、 user、 role、replication、image_scan、access等的metadata数据<br></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-h:8ead3b45-6fc7-44c3-a9e0-f9003cc2a333" class="outline-4">
<h4 id="h:8ead3b45-6fc7-44c3-a9e0-f9003cc2a333">安装Harbor</h4>
<div class="outline-text-4" id="text-h:8ead3b45-6fc7-44c3-a9e0-f9003cc2a333">
<p>
下载地址: <a href="https://github.com/vmware/harbor/releases">https://github.com/vmware/harbor/releases</a><br>
</p>

<p>
安装文档: <a href="https://github.com/goharbor/harbor/blob/master/docs/install-config/_index.md">https://github.com/goharbor/harbor/blob/master/docs/install-config/_index.md</a><br>
</p>

<p>
环境准备: 共四台主机<br>
</p>
<ul class="org-ul">
<li>两台主机harbor服务器，地址: 10.0.0.101|102<br></li>
<li>两台主机harbor客户端上传和下载镜像<br></li>
</ul>

<p>
安装docker compose<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#26041;&#27861;1: &#36890;&#36807;pip&#23433;&#35013;&#65292;&#29256;&#26412;&#36739;&#26032;docker_compose-1.25.3&#65292;&#25512;&#33616;&#20351;&#29992;
</span>[root@ubuntu1804 ~]#apt -y install python-pip
[root@ubuntu1804 ~]#pip install docker-compose

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26041;&#27861;2: &#30452;&#25509;&#20174;github&#19979;&#36733;&#23433;&#35013;&#23545;&#24212;&#29256;&#26412;
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">&#21442;&#30475;&#35828;&#26126;: https://github.com/docker/compose/releases
</span>curl -L https://github.com/docker/compose/releases/download/1.25.3/dockercompose-<span style="color: #ff00ff;">`uname -s`</span>-<span style="color: #ff00ff;">`uname -m`</span> -o /usr/bin/docker-compose
chmod +x /usr/bin/docker-compose

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26041;&#27861;3: &#30452;&#25509;&#23433;&#35013;&#65292;&#29256;&#26412;&#36739;&#26087;docker-compose-1.17.1-2&#65292;&#19981;&#25512;&#33616;&#20351;&#29992;
</span>[root@ubuntu1804 ~]#apt -y install docker-compose
</pre>
</div>
</div>
<div id="outline-container-h:da28698a-02b5-4b00-ac47-c8cd78d6c059" class="outline-5">
<h5 id="h:da28698a-02b5-4b00-ac47-c8cd78d6c059">下载Harbor安装包并解压缩</h5>
<div class="outline-text-5" id="text-h:da28698a-02b5-4b00-ac47-c8cd78d6c059">
<p>
以下使用 harbor 稳定版本1.7.6 安装包<br>
</p>

<p>
方法1: 下载离线完整安装包,推荐使用<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#wget https://storage.googleapis.com/harbor-releases/release-1.7.0/harbor-offline-installer-v1.7.6.tgz
</pre>
</div>

<p>
方法2: 下载在线安装包 ,比较慢，不是很推荐<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#wget https://storage.googleapis.com/harbor-releases/release-1.7.0/harbor-online-installer-v1.7.6.tgz
</pre>
</div>

<p>
解压缩离线包<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#mkdir /apps
[root@ubuntu1804 ~]#tar xvf harbor-offline-installer-v1.7.6.tgz -C /apps/
</pre>
</div>
</div>
</div>
<div id="outline-container-h:dd14d68e-a6e5-4203-9e37-382c77b1b11c" class="outline-5">
<h5 id="h:dd14d68e-a6e5-4203-9e37-382c77b1b11c">编辑配置文件 harbor.cfg</h5>
<div class="outline-text-5" id="text-h:dd14d68e-a6e5-4203-9e37-382c77b1b11c">
<p>
最新文档: <a href="https://github.com/goharbor/harbor/blob/master/docs/install-config/configure-yml-file.md">https://github.com/goharbor/harbor/blob/master/docs/install-config/configure-yml-file.md</a><br>
</p>

<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#vim /apps/harbor/harbor.cfg
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21482;&#38656;&#35201;&#20462;&#25913;&#19979;&#38754;&#20004;&#34892;
</span><span style="color: #a0522d;">hostname</span> = 10.0.0.101 <span style="color: #b22222;">#</span><span style="color: #b22222;">&#20462;&#25913;&#27492;&#34892;,&#25351;&#21521;&#24403;&#21069;&#20027;&#26426;IP &#25110; FQDN
</span><span style="color: #a0522d;">harbor_admin_password</span> = 123456 <span style="color: #b22222;">#</span><span style="color: #b22222;">&#20462;&#25913;&#27492;&#34892;&#25351;&#23450;harbor&#30331;&#24405;&#29992;&#25143;admin&#30340;&#23494;&#30721;,&#40664;&#35748;&#29992;&#25143;/&#23494;&#30721;:admin/Harbor12345
</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21487;&#36873;&#39033;
</span><span style="color: #a0522d;">ui_url_protocol</span> = http <span style="color: #b22222;">#</span><span style="color: #b22222;">&#40664;&#35748;&#21363;&#21487;,&#22914;&#26524;&#20462;&#25913;&#20026;https,&#38656;&#35201;&#25351;&#23450;&#19979;&#38754;&#35777;&#20070;&#36335;&#24452;
</span><span style="color: #a0522d;">ssl_cert</span> = /data/cert/server.crt <span style="color: #b22222;">#</span><span style="color: #b22222;">&#40664;&#35748;&#21363;&#21487;,https&#26102;&#65292;&#38656;&#25351;&#23450;&#19979;&#38754;&#35777;&#20070;&#25991;&#20214;&#36335;&#24452;
</span><span style="color: #a0522d;">ss_cert_key</span> = /data/cert/server.key <span style="color: #b22222;">#</span><span style="color: #b22222;">&#40664;&#35748;&#21363;&#21487;,https&#26102;&#65292;&#38656;&#25351;&#23450;&#19979;&#38754;&#31169;&#38053;&#25991;&#20214;&#36335;&#24452;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-h:02726036-d855-4a3e-85a6-9359da43b2aa" class="outline-5">
<h5 id="h:02726036-d855-4a3e-85a6-9359da43b2aa">运行 harbor 安装脚本</h5>
<div class="outline-text-5" id="text-h:02726036-d855-4a3e-85a6-9359da43b2aa">
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#20808;&#23433;&#35013;python
</span>root@ubuntu1804 ~]#apt -y install python
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#23433;&#35013;docker harbor
</span>root@ubuntu1804 ~]#/apps/harbor/install.sh

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#23433;&#35013;harbor&#21518;&#20250;&#33258;&#21160;&#24320;&#21551;&#24456;&#22810;&#30456;&#20851;&#23481;&#22120;
</span>[root@ubuntu1804 ~]#docker ps
</pre>
</div>
</div>
</div>
<div id="outline-container-h:688caf36-fcb0-4cec-8483-dfefbc5a7718" class="outline-5">
<h5 id="h:688caf36-fcb0-4cec-8483-dfefbc5a7718">实现开机自动启动 harbor</h5>
<div class="outline-text-5" id="text-h:688caf36-fcb0-4cec-8483-dfefbc5a7718">
<p>
方法1: 通过service文件实现<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">[root@harbor ~]#vim /lib/systemd/system/harbor.service
[Unit]
<span style="color: #a0522d;">Description</span>=Harbor
<span style="color: #a0522d;">After</span>=docker.service systemd-networkd.service systemd-resolved.service
<span style="color: #a0522d;">Requires</span>=docker.service
<span style="color: #a0522d;">Documentation</span>=http://github.com/vmware/harbor
[Service]
<span style="color: #a0522d;">Type</span>=simple
<span style="color: #a0522d;">Restart</span>=on-failure
<span style="color: #a0522d;">RestartSec</span>=5
<span style="color: #a0522d;">ExecStart</span>=/usr/bin/docker-compose -f /apps/harbor/docker-compose.yml up
<span style="color: #a0522d;">ExecStop</span>=/usr/bin/docker-compose -f /apps/harbor/docker-compose.yml down
[Install]
<span style="color: #a0522d;">WantedBy</span>=multi-user.target

[root@harbor ~]#systemctl daemon-reload
[root@harbor ~]#systemctl enable harbor
</pre>
</div>

<p>
方法2: 通过 rc.local实现<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@harbor ~]#cat /etc/rc.local
<span style="color: #b22222;">#</span><span style="color: #b22222;">!/bin/bash
</span><span style="color: #483d8b;">cd</span> /apps/harbor
/usr/bin/docker-compose up

[root@harbor ~]#chmod +x /etc/rc.local
</pre>
</div>
</div>
</div>
<div id="outline-container-h:229dcac0-ee28-4a59-b194-f3cc4a6686e0" class="outline-5">
<h5 id="h:229dcac0-ee28-4a59-b194-f3cc4a6686e0">登录 harbor 主机网站</h5>
<div class="outline-text-5" id="text-h:229dcac0-ee28-4a59-b194-f3cc4a6686e0">
<p>
用浏览器访问: <a href="http://10.0.0.101/">http://10.0.0.101/</a><br>
</p>
<ul class="org-ul">
<li>用户名: admin<br></li>
<li>密码: 即前面harbor.cfg中指定的密码<br></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-h:00028af6-457a-4bfa-9f0b-268d453c4e08" class="outline-4">
<h4 id="h:00028af6-457a-4bfa-9f0b-268d453c4e08">实现 harbor 高可用</h4>
<div class="outline-text-4" id="text-h:00028af6-457a-4bfa-9f0b-268d453c4e08">

<figure id="org223e949">
<img src="./images/Snipaste_2023-04-28_17-27-15.png" alt="Snipaste_2023-04-28_17-27-15.png"><br>

</figure>


<p>
Harbor支持基于策略的Docker镜像复制功能，这类似于MySQL的主从同步，其可以实现不同的数据中心、不同的运行环境之间同步镜像，并提供友好的管理界面，大大简化了实际运维中的镜像管理工作，已经有用很多互联网公司使用harbor搭建内网docker仓库的案例，并且还有实现了双向复制功能<br>
</p>
</div>
</div>
</div>
</section>
<section id="outline-container-h:f44edfbc-aad6-4225-a230-5be0203c12c4" class="outline-2">
<h2 id="h:f44edfbc-aad6-4225-a230-5be0203c12c4">单机编排之Docker Compose</h2>
<div class="outline-text-2" id="text-h:f44edfbc-aad6-4225-a230-5be0203c12c4">
</div>
<div id="outline-container-h:944a52d2-b32f-4d39-878e-eb4194011404" class="outline-3">
<h3 id="h:944a52d2-b32f-4d39-878e-eb4194011404">Docker Compse介绍</h3>
<div class="outline-text-3" id="text-h:944a52d2-b32f-4d39-878e-eb4194011404">
<p>
当在宿主机启动较多的容器时候，如果都是手动操作会觉得比较麻烦而且容易出错，此时推荐使用docker 单机编排工具 docker-compose<br>
</p>

<p>
docker-compose 是 docker 容器的一种单机编排服务，docker-compose 是一个管理多个容器的工具，比如: 可以解决容器之间的依赖关系，就像启动一个nginx 前端服务的时候会调用后端的tomcat，那就得先启动tomcat，但是启动tomcat 容器还需要依赖数据库，那就还得先启动数据库，dockercompose 可以用来解决这样的嵌套依赖关系，并且可以替代docker命令对容器进行创建、启动和停止<br>
等手工的操作<br>
</p>

<p>
因此，如果说docker命令就像linux的命令，docker compse就像shell脚本，可以自动的执行容器批量操作，从而实现自动化的容器管理，或者说docker命令相当于ansible命令，那么docker compose文件，就相当于ansible-playbook的yaml文件<br>
</p>

<p>
docker-compose 项目是Docker 官方的开源项目，负责实现对Docker 容器集群的快速编排，dockercompose 将所管理的容器分为三层，分别是工程（project），服务（service）以及容器（container）<br>
</p>

<p>
github地址: <a href="https://github.com/docker/compose">https://github.com/docker/compose</a><br>
官方地址: <a href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a><br>
</p>
</div>
<div id="outline-container-h:09f3c0ff-4c60-46e4-a9f2-adc8e87ae5e2" class="outline-4">
<h4 id="h:09f3c0ff-4c60-46e4-a9f2-adc8e87ae5e2">安装和准备</h4>
<div class="outline-text-4" id="text-h:09f3c0ff-4c60-46e4-a9f2-adc8e87ae5e2">
</div>
<div id="outline-container-h:ba9d8d5b-f63c-410f-a1d0-b9aba54adbe3" class="outline-5">
<h5 id="h:ba9d8d5b-f63c-410f-a1d0-b9aba54adbe3">安装Docker Compose</h5>
<div class="outline-text-5" id="text-h:ba9d8d5b-f63c-410f-a1d0-b9aba54adbe3">
<p>
方法1: 通过pip安装<br>
</p>

<p>
python-pip 包将安装一个 pip 的命令，pip 命令是一个pyhton 安装包的安装工具，其类似于ubuntu的apt 或者 redhat 的yum，但是pip 只安装 python 相关的安装包，可以在多种操作系统安装和使用pip<br>
</p>

<p>
此方式当前安装的版本较新，为docker_compose-1.25.3，推荐使用<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">Ubuntu:
<span style="color: #b22222;"># </span><span style="color: #b22222;">apt update
</span><span style="color: #b22222;"># </span><span style="color: #b22222;">apt install -y python-pip
</span>Centos:
<span style="color: #b22222;"># </span><span style="color: #b22222;">yum install epel-release
</span><span style="color: #b22222;"># </span><span style="color: #b22222;">yum install -y python-pip
</span><span style="color: #b22222;"># </span><span style="color: #b22222;">pip install --upgrade pip</span>
</pre>
</div>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#apt -y install python-pip
[root@ubuntu1804 ~]#pip install docker-compose
[root@ubuntu1804 ~]#docker-compose --version
docker-compose version 1.25.3, build unknown

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#22522;&#20110;python3&#23433;&#35013;
</span>[root@ubuntu1804 ~]#apt -y install python3-pip
[root@ubuntu1804 ~]#pip3 install docker-compose
[root@ubuntu1804 ~]#docker-compose --version
docker-compose version 1.27.4, build unknown
</pre>
</div>

<p>
方法2: 直接从github下载安装对应版本<br>
参看说明: <a href="https://github.com/docker/compose/releases">https://github.com/docker/compose/releases</a><br>
此方法安装版本可方便指定，推荐方法，但网络下载较慢<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#curl -L
https://github.com/docker/compose/releases/download/1.25.3/docker-compose-<span style="color: #ff00ff;">`uname -s`</span>-<span style="color: #ff00ff;">`uname -m`</span> -o /usr/local/bin/docker-compose
[root@ubuntu1804 ~]#chmod +x /usr/local/bin/docker-compose
</pre>
</div>

<p>
方法3: 直接从包仓库安装<br>
此方法安装的版本较旧，不推荐使用<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">ubuntu&#23433;&#35013;
</span>[root@ubuntu1804 ~]#apt -y install docker-compose
[root@ubuntu1804 ~]#docker-compose --version
docker-compose version 1.17.1, build unknown
<span style="color: #b22222;">#</span><span style="color: #b22222;">CentOS7&#23433;&#35013;&#65292;&#20381;&#36182;EPEL&#28304;
</span>[root@centos7 ~]#yum -y install docker-compose
[root@centos7 ~]#docker-compose --version
docker-compose version 1.18.0, buil 8dd22a9
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:675bd285-8fe8-4b8d-85e3-47b9d89a60f4" class="outline-4">
<h4 id="h:675bd285-8fe8-4b8d-85e3-47b9d89a60f4">查看命令格式</h4>
<div class="outline-text-4" id="text-h:675bd285-8fe8-4b8d-85e3-47b9d89a60f4">
<p>
官方文档: <a href="https://docs.docker.com/compose/reference/">https://docs.docker.com/compose/reference/</a><br>
</p>

<div class="org-src-container">
<pre class="src src-shell">docker-compose --help
Define and run multi-container applications with Docker.
Usage:
docker-compose [-f &lt;arg&gt;...] [options] [COMMAND] [ARGS...]
docker-compose -h|--help

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#36873;&#39033;&#35828;&#26126;:
</span>-f&#65292;&#8211;file FILE <span style="color: #b22222;">#</span><span style="color: #b22222;">&#25351;&#23450;Compose &#27169;&#26495;&#25991;&#20214;&#65292;&#40664;&#35748;&#20026;docker-compose.yml
</span>-p&#65292;&#8211;project-name NAME <span style="color: #b22222;">#</span><span style="color: #b22222;">&#25351;&#23450;&#39033;&#30446;&#21517;&#31216;&#65292;&#40664;&#35748;&#23558;&#20351;&#29992;&#24403;&#21069;&#25152;&#22312;&#30446;&#24405;&#21517;&#31216;&#20316;&#20026;&#39033;&#30446;&#21517;&#12290;
</span>--verbose <span style="color: #b22222;">#</span><span style="color: #b22222;">&#26174;&#31034;&#26356;&#22810;&#36755;&#20986;&#20449;&#24687;
</span>--log-level LEVEL <span style="color: #b22222;">#</span><span style="color: #b22222;">&#23450;&#20041;&#26085;&#24535;&#32423;&#21035; (DEBUG, INFO, WARNING, ERROR, CRITICAL)
</span>--no-ansi <span style="color: #b22222;">#</span><span style="color: #b22222;">&#19981;&#26174;&#31034;ANSI &#25511;&#21046;&#23383;&#31526;
</span>-v, --version <span style="color: #b22222;">#</span><span style="color: #b22222;">&#26174;&#31034;&#29256;&#26412;
</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#20197;&#19979;&#20026;&#21629;&#20196;&#36873;&#39033;&#65292;&#38656;&#35201;&#22312;docker-compose.yml|yaml &#25991;&#20214;&#25152;&#22312;&#22312;&#30446;&#24405;&#37324;&#25191;&#34892;
</span>build <span style="color: #b22222;">#</span><span style="color: #b22222;">&#26500;&#24314;&#38236;&#20687;
</span>bundle <span style="color: #b22222;">#</span><span style="color: #b22222;">&#20174;&#24403;&#21069;docker compose &#25991;&#20214;&#29983;&#25104;&#19968;&#20010;&#20197;&lt;&#24403;&#21069;&#30446;&#24405;&gt;&#20026;&#21517;&#31216;&#30340;json&#26684;&#24335;&#30340;Docker Bundle &#22791;
</span>&#20221;&#25991;&#20214;
config -q <span style="color: #b22222;">#</span><span style="color: #b22222;">&#26597;&#30475;&#24403;&#21069;&#37197;&#32622;&#65292;&#27809;&#26377;&#38169;&#35823;&#19981;&#36755;&#20986;&#20219;&#20309;&#20449;&#24687;
</span>create <span style="color: #b22222;">#</span><span style="color: #b22222;">&#21019;&#24314;&#26381;&#21153;&#65292;&#36739;&#23569;&#20351;&#29992;
</span>down <span style="color: #b22222;">#</span><span style="color: #b22222;">&#20572;&#27490;&#21644;&#21024;&#38500;&#25152;&#26377;&#23481;&#22120;&#12289;&#32593;&#32476;&#12289;&#38236;&#20687;&#21644;&#21367;
</span>events <span style="color: #b22222;">#</span><span style="color: #b22222;">&#20174;&#23481;&#22120;&#25509;&#25910;&#23454;&#26102;&#20107;&#20214;&#65292;&#21487;&#20197;&#25351;&#23450;json &#26085;&#24535;&#26684;&#24335;&#65292;&#36739;&#23569;&#20351;&#29992;
</span><span style="color: #a020f0;">exec</span> <span style="color: #b22222;">#</span><span style="color: #b22222;">&#36827;&#20837;&#25351;&#23450;&#23481;&#22120;&#36827;&#34892;&#25805;&#20316;
</span>help <span style="color: #b22222;">#</span><span style="color: #b22222;">&#26174;&#31034;&#24110;&#21161;&#32454;&#20449;&#24687;
</span>images <span style="color: #b22222;">#</span><span style="color: #b22222;">&#26174;&#31034;&#38236;&#20687;&#20449;&#24687;&#65292;&#36739;&#23569;&#20351;&#29992;
</span><span style="color: #483d8b;">kill</span> <span style="color: #b22222;">#</span><span style="color: #b22222;">&#24378;&#21046;&#32456;&#27490;&#36816;&#34892;&#20013;&#30340;&#23481;&#22120;
</span>logs <span style="color: #b22222;">#</span><span style="color: #b22222;">&#26597;&#30475;&#23481;&#22120;&#30340;&#26085;&#24535;
</span>pause <span style="color: #b22222;">#</span><span style="color: #b22222;">&#26242;&#20572;&#26381;&#21153;
</span>port <span style="color: #b22222;">#</span><span style="color: #b22222;">&#26597;&#30475;&#31471;&#21475;
</span>ps <span style="color: #b22222;">#</span><span style="color: #b22222;">&#21015;&#20986;&#23481;&#22120;&#65292;&#36739;&#23569;&#20351;&#29992;
</span>pull <span style="color: #b22222;">#</span><span style="color: #b22222;">&#37325;&#26032;&#25289;&#21462;&#38236;&#20687;&#65292;&#38236;&#20687;&#21457;&#29983;&#21464;&#21270;&#21518;&#65292;&#38656;&#35201;&#37325;&#26032;&#25289;&#21462;&#38236;&#20687;&#65292;&#36739;&#23569;&#20351;&#29992;
</span>push <span style="color: #b22222;">#</span><span style="color: #b22222;">&#19978;&#20256;&#38236;&#20687;
</span>restart <span style="color: #b22222;">#</span><span style="color: #b22222;">&#37325;&#21551;&#26381;&#21153;&#65292;&#36739;&#23569;&#20351;&#29992;
</span>rm <span style="color: #b22222;">#</span><span style="color: #b22222;">&#21024;&#38500;&#24050;&#32463;&#20572;&#27490;&#30340;&#26381;&#21153;
</span>run <span style="color: #b22222;">#</span><span style="color: #b22222;">&#19968;&#27425;&#24615;&#36816;&#34892;&#23481;&#22120;
</span>scale <span style="color: #b22222;">#</span><span style="color: #b22222;">&#35774;&#32622;&#25351;&#23450;&#26381;&#21153;&#36816;&#34892;&#30340;&#23481;&#22120;&#20010;&#25968;
</span>start <span style="color: #b22222;">#</span><span style="color: #b22222;">&#21551;&#21160;&#26381;&#21153; &#65292;&#36739;&#23569;&#20351;&#29992;
</span>stop <span style="color: #b22222;">#</span><span style="color: #b22222;">&#20572;&#27490;&#26381;&#21153;&#65292;&#36739;&#23569;&#20351;&#29992;
</span>top <span style="color: #b22222;">#</span><span style="color: #b22222;">&#26174;&#31034;&#23481;&#22120;&#36816;&#34892;&#29366;&#24577;
</span>unpause <span style="color: #b22222;">#</span><span style="color: #b22222;">&#21462;&#28040;&#26242;&#23450;
</span>up <span style="color: #b22222;">#</span><span style="color: #b22222;">&#21019;&#24314;&#24182;&#21551;&#21160;&#23481;&#22120; &#65292;&#36739;&#23569;&#20351;&#29992; -d &#21518;&#21488;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-h:bf0d8141-25e9-427a-9f8a-17ce0973f306" class="outline-4">
<h4 id="h:bf0d8141-25e9-427a-9f8a-17ce0973f306">docker compse 文件格式</h4>
<div class="outline-text-4" id="text-h:bf0d8141-25e9-427a-9f8a-17ce0973f306">
<p>
官方文档: <a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a><br>
</p>

<p>
docker compose 文件是一个yaml格式的文件，所以注意行首的缩进很严格<br>
</p>

<p>
默认docker-compose命令会调用当前目录下的docker-compose.yml的文件，因此一般执行dockercompose命令前先进入docker-compose.yml文件所在目录<br>
</p>

<p>
docker compose文件的格式很不同版本，版本不同，语法和格式有所不同，参看以下列表<br>
3.7 18.06.0+<br>
3.6 18.02.0+<br>
3.5 17.12.0+<br>
3.4 17.09.0+<br>
3.3 17.06.0+<br>
3.2 17.04.0+<br>
3.1 1.13.1+<br>
3.0 1.13.0+<br>
2.4 17.12.0+<br>
2.3 17.06.0+<br>
2.2 1.13.0+<br>
2.1 1.12.0+<br>
2.0 1.10.0+<br>
1.0 1.9.1.+<br>
</p>

<p>
docker compose版本众多，以下通过具体示例说明docker compose的使用方法<br>
</p>
</div>
</div>
<div id="outline-container-h:3fe2dad3-48fc-4ad4-9d4f-5de1200f43f1" class="outline-4">
<h4 id="h:3fe2dad3-48fc-4ad4-9d4f-5de1200f43f1">指定同时启动容器的数量</h4>
<div class="outline-text-4" id="text-h:3fe2dad3-48fc-4ad4-9d4f-5de1200f43f1">
<p>
docker-compose up -d &#x2013;scale service-nginxweb=2<br>
</p>
</div>
</div>
<div id="outline-container-h:cb328dd2-a42c-46bc-b6c7-4d21294acf2c" class="outline-4">
<h4 id="h:cb328dd2-a42c-46bc-b6c7-4d21294acf2c">多doker compose文件容器互通</h4>
<div class="outline-text-4" id="text-h:cb328dd2-a42c-46bc-b6c7-4d21294acf2c">
<p>
加入对方网络空间就可以了<br>
</p>

<p>
范例： vm_net与slots-game-net网络空间中容器网络互通<br>
</p>

<ul class="org-ul">
<li>networks 中 <code>external: true</code> 表示使用外部创建好的网络空间solts-game-net<br></li>
<li>services 中 networks 引用外部网络空间名<br></li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">networks:
  slots-net:
    name: slots-game-net
    external: true

  vm_net:
    name: vm_net
    driver: bridge
    ipam:
      config:
        - subnet: 172.26.0.0/24

services:
  mysqld_exporter:
    image: prom/mysqld-exporter:v0.15.1
    hostname: mysqld-exporter
    container_name: mysqld_exporter
    ports:
      - 9104
    command:
      - <span style="color: #8b2252;">"--mysqld.username=root:kot2LT4jgJEo2rsnvduF"</span>
<span style="color: #b22222;">#      </span><span style="color: #b22222;">- "--mysqld.address=host.docker.internal:3396"
</span>      - <span style="color: #8b2252;">"--mysqld.address=mysql-8-slots:3306"</span>
      - <span style="color: #8b2252;">'--tls.insecure-skip-verify'</span>
    restart: always
    networks:
      - vm_net
      - slots-net
<span style="color: #b22222;">#    </span><span style="color: #b22222;">extra_hosts:
</span><span style="color: #b22222;">#      </span><span style="color: #b22222;">- host.docker.internal:host-gateway
</span>
  redis_exporter:
    image: oliver006/redis_exporter:v1.62.0
    container_name: redis_exporter
    ports:
      - 9121
    command:
<span style="color: #b22222;">#      </span><span style="color: #b22222;">- "--redis.addr==redis://host.docker.internal:6389"
</span>      - <span style="color: #8b2252;">"--redis.addr=redis://redis-stack-slots:6379"</span>
      <span style="color: #b22222;">#</span><span style="color: #b22222;">- "--redis.user=default"
</span>      - <span style="color: #8b2252;">"--redis.password=OzTKYlJ9KvGZAkYf9B"</span>
      - <span style="color: #8b2252;">'--debug'</span>
    restart: always
    networks:
      - vm_net
      - slots-net
<span style="color: #b22222;">#    </span><span style="color: #b22222;">extra_hosts:
</span><span style="color: #b22222;">#      </span><span style="color: #b22222;">- host.docker.internal:host-gateway</span>
</pre>
</div>
</div>
</div>
</div>
</section>
<section id="outline-container-h:b89be07c-41f5-4b40-b3b4-672f70bba2d4" class="outline-2">
<h2 id="h:b89be07c-41f5-4b40-b3b4-672f70bba2d4">docker 的资源限制</h2>
<div class="outline-text-2" id="text-h:b89be07c-41f5-4b40-b3b4-672f70bba2d4">
</div>
<div id="outline-container-h:94e570a8-7960-4cdb-b7be-2d4099b11f90" class="outline-3">
<h3 id="h:94e570a8-7960-4cdb-b7be-2d4099b11f90">docker 资源限制</h3>
<div class="outline-text-3" id="text-h:94e570a8-7960-4cdb-b7be-2d4099b11f90">
</div>
<div id="outline-container-h:7b1d4395-a4e0-463c-89db-a1e6e03f35aa" class="outline-4">
<h4 id="h:7b1d4395-a4e0-463c-89db-a1e6e03f35aa">容器资源限制介绍</h4>
<div class="outline-text-4" id="text-h:7b1d4395-a4e0-463c-89db-a1e6e03f35aa">
<p>
官方文档: <a href="https://docs.docker.com/config/containers/resource_constraints/">https://docs.docker.com/config/containers/resource_constraints/</a><br>
</p>

<p>
默认情况下，容器没有资源的使用限制，可以使用主机内核调度程序允许的尽可能多的资源<br>
</p>

<p>
Docker 提供了控制容器使用资源的方法,可以限制容器使用多少内存或 CPU等， 在docker run 命令的运行时配置标志实现资源限制功能。<br>
</p>

<p>
其中许多功能都要求宿主机的内核支持，要检查是否支持这些功能，可以使用docker info 命令 ，如果内核中的某项特性可能会在输出结尾处看到警告， 如下所示:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">WARNING: No swap limit support
</pre>
</div>

<p>
可通过修改内核参数消除以上警告<br>
</p>

<p>
官方文档: <a href="https://docs.docker.com/install/linux/linux-postinstall/#your-kernel-does-not-support-cgroup-swap-limit-capabilities">https://docs.docker.com/install/linux/linux-postinstall/#your-kernel-does-not-support-cgroup-swap-limit-capabilities</a><br>
</p>

<p>
范例: 修改内核参数消除以上警告<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker info
WARNING: No swap limit support
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#20462;&#25913;&#20869;&#26680;&#21442;&#25968;
</span>[root@ubuntu1804 ~]#vim /etc/default/grub
<span style="color: #a0522d;">GRUB_CMDLINE_LINUX</span>=<span style="color: #8b2252;">"cgroup_enable=memory net.ifnames=0 swapaccount=1"</span>

[root@ubuntu1804 ~]#update-grub
[root@ubuntu1804 ~]#reboot
[root@ubuntu1804 ~]#docker info
</pre>
</div>
</div>
</div>
<div id="outline-container-h:a0f68920-1dd8-445f-9693-16b723925fa2" class="outline-4">
<h4 id="h:a0f68920-1dd8-445f-9693-16b723925fa2">OOM （Out of Memory Exception）</h4>
<div class="outline-text-4" id="text-h:a0f68920-1dd8-445f-9693-16b723925fa2">
<p>
对于 Linux 主机，如果没有足够的内存来执行其他重要的系统任务，将会抛出OOM (Out of MemoryException,内存溢出、内存泄漏、内存异常 )，随后系统会开始杀死进程以释放内存， 凡是运行在宿主机的进程都有可能被 kill ，包括 Dockerd和其它的应用程序， 如果重要的系统进程被 Kill，会导致和该进程相关的服务全部宕机。通常越消耗内存比较大的应用越容易被kill，比如: MySQL数据库，Java程序等<br>
</p>

<p>
产生 OOM 异常时， Dockerd尝试通过调整 Docker 守护程序上的 OOM 优先级来减轻这些风险，以便它比系统上的其他进程更不可能被杀死但是容器 的 OOM 优先级未调整， 这使得单个容器被杀死的可能性比 Docker守护程序或其他系统进程被杀死的可能性更大，不推荐通过在守护程序或容器上手动设置&#x2013; oom -score-adj为极端负数，或通过在容器上设置 &#x2013; oom-kill-disable来绕过这些安全措施<br>
</p>

<p>
<b>OOM 优先级机制:</b><br>
</p>

<p>
linux会为每个进程算一个分数，最终将分数最高的kill<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">/proc/PID/oom_score_adj
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#33539;&#22260;&#20026; -1000 &#21040; 1000&#65292;&#20540;&#36234;&#39640;&#23481;&#26131;&#34987;&#23487;&#20027;&#26426; kill&#25481;&#65292;&#22914;&#26524;&#23558;&#35813;&#20540;&#35774;&#32622;&#20026; -1000 &#65292;&#21017;&#36827;&#31243;&#27704;&#36828;&#19981;&#20250;&#34987;&#23487;&#20027;&#26426; kernel kill
</span>
/proc/PID/oom_adj
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#33539;&#22260;&#20026; -17 &#21040;+15 &#65292;&#21462;&#20540;&#36234;&#39640;&#36234;&#23481;&#26131;&#34987;&#24178;&#25481;&#65292;&#22914;&#26524;&#26159; -17 &#65292; &#21017;&#34920;&#31034;&#19981;&#33021;&#34987; kill &#65292;&#35813;&#35774;&#32622;&#21442;&#25968;&#30340;&#23384;&#22312;&#26159;&#20026;&#20102;&#21644;&#26087;&#29256;&#26412;&#30340; Linux &#20869;&#26680;&#20860;&#23481;&#12290;
</span>
/proc/PID/oom_score
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#36825;&#20010;&#20540;&#26159;&#31995;&#32479;&#32508;&#21512;&#36827;&#31243;&#30340;&#20869;&#23384;&#28040;&#32791;&#37327;&#12289; CPU &#26102;&#38388; (utime + &#12289;&#23384;&#27963;&#26102;&#38388; (uptime - start time)&#21644; oom_adj &#35745;&#31639;&#20986;&#30340;&#36827;&#31243;&#24471;&#20998; &#65292;&#28040;&#32791;&#20869;&#23384;&#36234;&#22810;&#24471;&#20998;&#36234;&#39640;&#65292;&#23481;&#26131;&#34987;&#23487;&#20027;&#26426; kernel &#24378;&#21046;&#26432;&#27515;</span>
</pre>
</div>

<p>
范例: 查看OOM相关值<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#25353;&#20869;&#23384;&#25490;&#24207;
</span>[root@ubuntu1804 ~]#top

[root@ubuntu1804 ~]#cat /proc/19674/oom_adj
0
[root@ubuntu1804 ~]#cat /proc/19674/oom_score
32
[root@ubuntu1804 ~]#cat /proc/19674/oom_score_adj
0
[root@ubuntu1804 ~]#cat /proc/7108/oom_adj
0
[root@ubuntu1804 ~]#cat /proc/7108/oom_score
1
[root@ubuntu1804 ~]#cat /proc/7108/oom_score_adj
0
<span style="color: #b22222;">#</span><span style="color: #b22222;">docker&#26381;&#21153;&#36827;&#31243;&#30340;OOM&#40664;&#35748;&#20540;
</span>[root@ubuntu1804 ~]#cat /proc/<span style="color: #ff00ff;">`pidof dockerd`</span>/oom_adj
-8
[root@ubuntu1804 ~]#cat /proc/<span style="color: #ff00ff;">`pidof dockerd`</span>/oom_score
0
[root@ubuntu1804 ~]#cat /proc/<span style="color: #ff00ff;">`pidof dockerd`</span>/oom_score_adj
-500
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:0745e9ae-549b-40bf-a51a-067828ed0cd7" class="outline-3">
<h3 id="h:0745e9ae-549b-40bf-a51a-067828ed0cd7">容器的内存限制</h3>
<div class="outline-text-3" id="text-h:0745e9ae-549b-40bf-a51a-067828ed0cd7">
<p>
Docker 可以强制执行硬性内存限制，即只允许容器使用给定的内存大小。<br>
Docker 也可以执行非硬性内存限制，即容器可以使用尽可能多的内存，除非内核检测到主机上的内存不够用了<br>
</p>
</div>
<div id="outline-container-h:88d022ec-1c6e-4bdb-82f3-ea9fc753728f" class="outline-4">
<h4 id="h:88d022ec-1c6e-4bdb-82f3-ea9fc753728f">内存相关选项</h4>
<div class="outline-text-4" id="text-h:88d022ec-1c6e-4bdb-82f3-ea9fc753728f">
<p>
官文文档: <a href="https://docs.docker.com/config/containers/resource_constraints/">https://docs.docker.com/config/containers/resource_constraints/</a><br>
</p>

<p>
以下设置大部分的选项取正整数，跟着一个后缀 b ， k ， m ， g ，，表示字节，千字节，兆字节或千兆字节<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">-m &#65292; --memory=&#65306; &#23481;&#22120;&#21487;&#20197;&#20351;&#29992;&#30340;&#26368;&#22823;&#29289;&#29702;&#20869;&#23384;&#37327;&#65292;&#30828;&#38480;&#21046;&#65292;&#27492;&#36873;&#39033;&#26368;&#23567;&#20801;&#35768;&#20540;&#20026;4m &#65288;4 MB&#65289;&#65292;&#27492;&#39033;&#36739;&#24120;&#29992;

--memory-swap : &#20801;&#35768;&#27492;&#23481;&#22120;&#20132;&#25442;&#21040;&#30913;&#30424;&#30340;&#20869;&#23384;&#37327;,&#24517;&#39035;&#20808;&#29992;-m &#23545;&#20869;&#23384;&#38480;&#21046;&#25165;&#21487;&#20197;&#20351;&#29992;,&#35814;&#32454;&#35828;&#26126;&#22914;&#19979;

--memory-swappiness &#35774;&#32622;&#23481;&#22120;&#20351;&#29992;&#20132;&#25442;&#20998;&#21306;&#30340;&#20542;&#21521;&#24615;&#65292;&#20540;&#36234;&#39640;&#34920;&#31034;&#36234;&#20542;&#21521;&#20110;&#20351;&#29992;swap&#20998;&#21306;&#65292;&#33539;&#22260;&#20026;0-100&#65292;0&#20026;&#33021;&#19981;&#29992;&#23601;&#19981;&#29992;&#65292;100&#20026;&#33021;&#29992;&#23601;&#29992;

--memoryreservation &#20801;&#35768;&#25351;&#23450;&#23567;&#20110; --memory &#30340;&#36719;&#38480;&#21046; &#65292;&#24403; Docker &#26816;&#27979;&#21040;&#20027;&#26426;&#19978;&#30340;&#20105;&#29992;&#25110;&#20869;&#23384;&#19981;&#36275;&#26102;&#20250;&#28608;&#27963;&#35813;&#38480;&#21046;&#65292;&#22914;&#26524;&#20351;-- memory-reservation&#65292;&#21017;&#24517;&#39035;&#23558;&#20854;&#35774;&#32622;&#20026;&#20302;&#20110; --memory &#25165;&#33021;&#20351;&#20854;&#20248;&#20808;&#29983;&#25928;&#12290; &#22240;&#20026;&#23427;&#26159;&#36719;&#38480;&#21046;&#65292;&#25152;&#20197;&#19981;&#33021;&#20445;&#35777;&#23481;&#22120;&#19981;&#36229;&#36807;&#38480;&#21046;

--kernel-memory &#23481;&#22120;&#21487;&#20197;&#20351;&#29992;&#30340;&#26368;&#22823;&#20869;&#26680;&#20869;&#23384;&#37327;&#65292;&#26368;&#23567;&#20026; 4m&#65292;&#30001;&#20110;&#20869;&#26680;&#20869;&#23384;&#19982;&#29992;&#25143;&#31354;&#38388;&#20869;&#23384;&#38548;&#31163;&#65292;&#22240;&#27492;&#26080;&#27861;&#19982;&#29992;&#25143;&#31354;&#38388;&#20869;&#23384;&#30452;&#25509;&#20132;&#25442;&#65292;&#22240;&#27492;&#20869;&#26680;&#20869;&#23384;&#19981;&#36275;&#30340;&#23481;&#22120;&#21487;&#33021;&#20250;&#38459;&#22622;&#23487;&#20027;&#26426;&#36164;&#28304;&#65292;&#36825;&#20250;&#23545;&#20027;&#26426;&#21644;&#20854;&#20182;&#23481;&#22120;&#25110;&#32773;&#20854;&#20182;&#26381;&#21153;&#36827;&#31243;&#20135;&#29983;&#24433;&#21709;&#65292;&#22240;&#27492;&#19981;&#24314;&#35758;&#35774;&#32622;&#20869;&#26680;&#20869;&#23384;&#22823;&#23567;

--oom-kill-disable &#40664;&#35748;&#24773;&#20917;&#19979;&#65292;&#22914;&#26524;&#21457;&#29983;&#20869;&#23384;&#19981;&#36275;&#65288;OOM&#65289;&#38169;&#35823;&#65292;&#21017;&#20869;&#26680;&#23558;&#32456;&#27490;&#23481;&#22120;&#20013;&#30340;&#36827;&#31243;&#12290;&#35201;&#26356;&#25913;&#27492;&#34892;&#20026;&#65292;&#35831;&#20351;&#29992;&#35813; --oom-kill-disable &#36873;&#39033;&#12290;&#20165;&#22312;&#35774;&#32622;&#20102;&#35813; -m/--memory &#36873;&#39033;&#30340;&#23481;&#22120;&#19978;&#31105;&#29992;OOM&#12290;&#22914;&#26524; -m &#26410;&#35774;&#32622;&#35813;&#26631;&#24535;&#65292;&#21017;&#20027;&#26426;&#21487;&#33021;&#20250;&#29992;&#23436;&#20869;&#23384;&#65292;&#20869;&#26680;&#21487;&#33021;&#38656;&#35201;&#32456;&#27490;&#20027;&#26426;&#31995;&#32479;&#30340;&#36827;&#31243;&#20197;&#37322;&#25918;&#20869;
</pre>
</div>

<p>
范例:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker run -e <span style="color: #a0522d;">MYSQL_ROOT_PASSWORD</span>=123456 -it --rm -m 1g --oom-kill-disable mysql:5.7.29
</pre>
</div>

<p>
范例：<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#sysctl -a |grep swappiness
sysctl: reading key <span style="color: #8b2252;">"net.ipv6.conf.all.stable_secret"</span>
sysctl: reading key <span style="color: #8b2252;">"net.ipv6.conf.default.stable_secret"</span>
sysctl: reading key <span style="color: #8b2252;">"net.ipv6.conf.docker0.stable_secret"</span>
sysctl: reading key <span style="color: #8b2252;">"net.ipv6.conf.eth0.stable_secret"</span>
sysctl: reading key <span style="color: #8b2252;">"net.ipv6.conf.lo.stable_secret"</span>
vm.swappiness = 60
</pre>
</div>
</div>
</div>
<div id="outline-container-h:4b3918f7-bbf9-4e4a-a9ea-011931615741" class="outline-4">
<h4 id="h:4b3918f7-bbf9-4e4a-a9ea-011931615741">swap限制</h4>
<div class="outline-text-4" id="text-h:4b3918f7-bbf9-4e4a-a9ea-011931615741">
<div class="org-src-container">
<pre class="src src-shell">--memory-swap <span style="color: #b22222;">#</span><span style="color: #b22222;">&#21482;&#26377;&#22312;&#35774;&#32622;&#20102; --memory &#21518;&#25165;&#20250;&#26377;&#24847;&#20041;&#12290;&#20351;&#29992; Swap,&#21487;&#20197;&#35753;&#23481;&#22120;&#23558;&#36229;&#20986;&#38480;&#21046;&#37096;&#20998;&#30340;&#20869;&#23384;&#32622;&#25442;&#21040;&#30913;&#30424;&#19978;&#65292;WARNING: &#32463;&#24120;&#23558;&#20869;&#23384;&#20132;&#25442;&#21040;&#30913;&#30424;&#30340;&#24212;&#29992;&#31243;&#24207;&#20250;&#38477;&#20302;&#24615;&#33021;</span>
</pre>
</div>

<p>
不同的&#x2013;memory-swap 设置会产生不同的效果:<br>
<img src="./images/Snipaste_2023-04-28_17-54-31.png" alt="Snipaste_2023-04-28_17-54-31.png"><br>
</p>

<div class="org-src-container">
<pre class="src src-shell">-memory-swap <span style="color: #b22222;">#</span><span style="color: #b22222;">&#20540;&#20026;&#27491;&#25968;&#65292; &#37027;&#20040;--memory &#21644;--memory-swap &#37117;&#24517;&#39035;&#35201;&#35774;&#32622;&#65292;--memory-swap &#34920;&#31034;&#20320;&#33021;&#20351;&#29992;&#30340;&#20869;&#23384;&#21644; swap &#20998;&#21306;&#22823;&#23567;&#30340;&#24635;&#21644;&#65292;&#20363;&#22914;: --memory=300m, --memory-swap=1g, &#37027;&#20040;&#35813;&#23481;&#22120;&#33021;&#22815;&#20351;&#29992; 300m &#29289;&#29702;&#20869;&#23384;&#21644; 700m swap&#65292;&#21363;--memory &#26159;&#23454;&#38469;&#29289;&#29702;&#20869;&#23384;&#22823;&#23567;&#20540;&#19981;&#21464;&#65292;&#32780; swap &#30340;&#23454;&#38469;&#22823;&#23567;&#35745;&#31639;&#26041;&#24335;&#20026;(--memory-swap)-(--memory)=&#23481;&#22120;&#21487;&#29992; swap
</span>
--memory-swap <span style="color: #b22222;">#</span><span style="color: #b22222;">&#22914;&#26524;&#35774;&#32622;&#20026; 0&#65292;&#21017;&#24573;&#30053;&#35813;&#35774;&#32622;&#65292;&#24182;&#23558;&#35813;&#20540;&#35270;&#20026;&#26410;&#35774;&#32622;&#65292;&#21363;&#26410;&#35774;&#32622;&#20132;&#25442;&#20998;&#21306;
</span>
--memory-swap <span style="color: #b22222;">#</span><span style="color: #b22222;">&#22914;&#26524;&#31561;&#20110;--memory &#30340;&#20540;&#65292;&#24182;&#19988;--memory &#35774;&#32622;&#20026;&#27491;&#25972;&#25968;&#65292;&#23481;&#22120;&#26080;&#26435;&#35775;&#38382; swap
</span>
-memory-swap <span style="color: #b22222;">#</span><span style="color: #b22222;">&#22914;&#26524;&#26410;&#35774;&#32622;&#65292;&#22914;&#26524;&#23487;&#20027;&#26426;&#24320;&#21551;&#20102; swap&#65292;&#21017;&#23454;&#38469;&#23481;&#22120;&#30340;swap &#20540;&#26368;&#22823;&#20026; 2x( --memory)&#65292;&#21363;&#20004;&#20493;&#20110;&#29289;&#29702;&#20869;&#23384;&#22823;&#23567;&#65292;&#20363;&#22914;&#65292;&#22914;&#26524;--memory="300m"&#19982;--memory-swap&#27809;&#26377;&#35774;&#32622;&#65292;&#35813;&#23481;&#22120;&#21487;&#20197;&#20351;&#29992;300m&#24635;&#30340;&#20869;&#23384;&#21644;600m&#20132;&#25746;&#31354;&#38388;,&#20294;&#26159;&#24182;&#19981;&#20934;&#30830;(&#22312;&#23481;&#22120;&#20013;&#20351;&#29992;free &#21629;&#20196;&#25152;&#30475;&#21040;&#30340; swap &#31354;&#38388;&#24182;&#19981;&#31934;&#30830;&#65292;&#27605;&#31455;&#27599;&#20010;&#23481;&#22120;&#37117;&#21487;&#20197;&#30475;&#21040;&#20855;&#20307;&#22823;&#23567;&#65292;&#23487;&#20027;&#26426;&#30340; swap &#26159;&#26377;&#19978;&#38480;&#30340;&#65292;&#32780;&#19988;&#19981;&#26159;&#25152;&#26377;&#23481;&#22120;&#30475;&#21040;&#30340;&#32047;&#35745;&#22823;&#23567;)
</span>--memory-swap <span style="color: #b22222;">#</span><span style="color: #b22222;">&#22914;&#26524;&#35774;&#32622;&#20026;-1&#65292;&#22914;&#26524;&#23487;&#20027;&#26426;&#24320;&#21551;&#20102; swap&#65292;&#21017;&#23481;&#22120;&#21487;&#20197;&#20351;&#29992;&#20027;&#26426;&#19978; swap &#30340;&#26368;&#22823;&#31354;&#38388;</span>
</pre>
</div>

<p>
<b>注意: 在容器中执行free命令看到的是宿主机的内存和swap使用，而非容器自身的swap使用情况</b><br>
</p>

<p>
范例: 在容器中查看内存<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#free
total used free shared buff/cache available
Mem: 3049484 278484 1352932 10384 1418068 2598932
Swap: 1951740 0 1951740

[root@ubuntu1804 ~]#docker run -it --rm -m 2G centos:centos7.7.1908 bash
[root@f5d387b5022f /]# free
total used free shared buff/cache available
Mem: 3049484 310312 1320884 10544 1418288 2566872
Swap: 1951740 0 1951740
[root@f5d387b5022f /]#
</pre>
</div>
</div>
</div>
<div id="outline-container-h:f3ac8150-04f9-4d5c-bf27-e208ad8588fe" class="outline-4">
<h4 id="h:f3ac8150-04f9-4d5c-bf27-e208ad8588fe">stress-ng 压力测试工具</h4>
<div class="outline-text-4" id="text-h:f3ac8150-04f9-4d5c-bf27-e208ad8588fe">
<p>
stress-ng是一个压力测试工具，可以通过软件仓库进行安装，也提供了docker版本的容器<br>
</p>

<p>
范例: 软件包方式安装<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@centos7 ~]#yum -y install stress-ng
[root@ubuntu1804 ~]#apt -y install stress-ng
</pre>
</div>


<p>
假如一个容器未做内存使用限制，则该容器可以利用到系统内存最大空间，默认创建的容器没有做内存资源限制。<br>
</p>

<p>
范例: 默认一个workers 分配256M内存，2个即占512M内存<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker run --name c1 -it --rm lorel/docker-stress-ng --vm 2
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#22240;&#19978;&#19968;&#20010;&#21629;&#20196;&#26159;&#21069;&#21488;&#25191;&#34892;&#65292;&#19979;&#38754;&#22312;&#21478;&#19968;&#20010;&#32456;&#31471;&#31383;&#21475;&#20013;&#25191;&#34892;&#65292;&#21487;&#20197;&#30475;&#21040;&#21344;&#29992;512M&#24038;&#21491;&#20869;&#23384;
</span>[root@ubuntu1804 ~]#docker stats
CONTAINER ID NAME CPU % MEM USAGE / LIMIT
MEM % NET I/O BLOCK I/O PIDS
fd184869ff7e c1 91.00% 524.3MiB / 962MiB
54.50% 766B / 0B 860kB / 0B 5
</pre>
</div>


<p>
范例: 指定内存最大值<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker run --name c1 -it --rm -m 300m lorel/docker-stress-ng--vm 2

[root@ubuntu1804 ~]#vim /etc/default/grub
<span style="color: #a0522d;">GRUB_CMDLINE_LINUX</span>=<span style="color: #8b2252;">"cgroup_enable=memory swapaccount=1 net.ifnames=0"</span>

[root@ubuntu1804 ~]#update-grub
[root@ubuntu1804 ~]#reboot
[root@ubuntu1804 ~]#docker run --name c1 -it --rm -m 300m lorel/docker-stress-ng--vm 2

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#22312;&#21478;&#19968;&#20010;&#32456;&#31471;&#31383;&#21475;&#25191;&#34892;
</span>[root@ubuntu1804 ~]#docker stats --no-stream
CONTAINER ID NAME CPU % MEM USAGE / LIMIT
MEM % NET I/O BLOCK I/O PIDS
6a93f6b22034 c1 27.06% 297.2MiB / 300MiB
99.07% 1.45kB / 0B 4.98GB / 5.44GB 5
</pre>
</div>

<p>
范例:<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker run --name c2 -it --rm lorel/docker-stress-ng --vm 4

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#19968;&#27425;&#24615;&#26597;&#30475;&#36164;&#28304;&#20351;&#29992;&#24773;&#20917;
</span>[root@ubuntu1804 ~]#docker stats --no-stream
CONTAINER ID NAME CPU % MEM USAGE / LIMIT
MEM % NET I/O BLOCK I/O PIDS
fd5fff3c04f7 c2 21.20% 591.1MiB / 962MiB
61.45% 1.31kB / 0B 1.07GB / 46.6MB 9
</pre>
</div>

<p>
范例: 容器占用内存造成OOM<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker run -it --rm lorel/docker-stress-ng --vm 6

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21478;&#19968;&#20010;&#32456;&#31471;&#31383;&#20013;&#21516;&#26102;&#25191;&#34892;&#19979;&#38754;&#21629;&#20196;
</span>[root@ubuntu1804 ~]#docker run -it --rm lorel/docker-stress-ng --vm 6
[root@ubuntu1804 ~]#docker stats
CONTAINER ID NAME CPU % MEM USAGE / LIMIT
MEM % NET I/O BLOCK I/O PIDS
f33cebf5b55d c2 -- -- / --
-- -- -- --
b14b597c5a4f cool_banach -- -- / --
-- -- -- --
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#35266;&#23519;&#26085;&#24535;&#20986;&#29616;OOM&#29616;&#35937;
</span>[root@ubuntu1804 ~]#tail /var/log/syslog
</pre>
</div>

<p>
范例: 查看内存限制<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#21551;&#21160;&#20004;&#20010;&#24037;&#20316;&#36827;&#31243;&#65292;&#27599;&#20010;&#24037;&#20316;&#36827;&#31243;&#26368;&#22823;&#20801;&#35768;&#20351;&#29992;&#20869;&#23384; 256M&#65292;&#19988;&#23487;&#20027;&#26426;&#19981;&#38480;&#21046;&#24403;&#21069;&#23481;&#22120;&#26368;&#22823;&#20869;&#23384;
</span>[root@ubuntu1804 ~]#docker run -it --rm lorel/docker-stress-ng --vm 2
[root@ubuntu1804 ~]#ls /sys/fs/cgroup/memory/docker/

[root@ubuntu1804 ~]#cat /sys/fs/cgroup/memory/docker/13e46172e1ae8593569f05a3bebc7b41b7839da44369d43b29102661364ac2cd/memory.limit_in_bytes

9223372036854771712
[root@ubuntu1804 ~]#echo 2^63|bc
9223372036854775808
</pre>
</div>

<p>
范例: 内存限制200m<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#23487;&#20027;&#26426;&#38480;&#21046;&#23481;&#22120;&#26368;&#22823;&#20869;&#23384;&#20351;&#29992;:
</span>[root@ubuntu1804 ~]#docker run -it --rm -m 200M lorel/docker-stress-ng --vm 2 --vm-bytes 256M
[root@ubuntu1804 ~]#docker stats --no-stream
CONTAINER ID NAME CPU % MEM USAGE / LIMIT
MEM % NET I/O BLOCK I/O PIDS
f69729b2acc1 sleepy_haibt 85.71% 198MiB / 200MiB
98.98% 1.05kB / 0B 697MB / 60.4GB 5

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26597;&#30475;&#23487;&#20027;&#26426;&#22522;&#20110; cgroup &#23545;&#23481;&#22120;&#36827;&#34892;&#20869;&#23384;&#36164;&#28304;&#30340;&#22823;&#23567;&#38480;&#21046;
</span>[root@ubuntu1804 ~]#cat /sys/fs/cgroup/memory/docker/f69729b2acc16e032658a4efdab64d21ff97dcb6746d1cef451ed82d5c98a81f/memory.limit_in_bytes
209715200
[root@ubuntu1804 ~]#echo 209715200/1024/1024|bc
200
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21160;&#24577;&#20462;&#25913;&#20869;&#23384;&#38480;&#21046;
</span>[root@ubuntu1804 ~]#echo 300*1024*1024|bc
314572800
[root@ubuntu1804 ~]#echo 314572800 &gt;/sys/fs/cgroup/memory/docker/f69729b2acc16e032658a4efdab64d21ff97dcb6746d1cef451ed82d5c98a81f/memory.limit_in_bytes

[root@ubuntu1804 ~]#cat /sys/fs/cgroup/memory/docker/f69729b2acc16e032658a4efdab64d21ff97dcb6746d1cef451ed82d5c98a81f/memory.limit_in_bytes
314572800
</pre>
</div>

<p>
范例: 内存大小软限制<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker run -it --rm -m 256m --memory-reservation 128m --name xxx-c1 lorel/docker-stress-ng --vm 2 --vm-bytes 256M

[root@ubuntu1804 ~]#docker stats --no-stream
CONTAINER ID NAME CPU % MEM USAGE / LIMIT
MEM % NET I/O BLOCK I/O PIDS
aeb38acde581 xxx-c1 72.45% 253.9MiB / 256MiB
99.20% 976B / 0B 9.47GB / 39.4GB 5

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26597;&#30475;&#30828;&#38480;&#21046;
</span>[root@ubuntu1804 ~]#cat /sys/fs/cgroup/memory/docker/aeb38acde58155d421f998a54e9a99ab60635fe00c9070da050cc49a2f62d274/memory.limit_in_bytes
268435456
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26597;&#30475;&#36719;&#38480;&#21046;
</span>[root@ubuntu1804 ~]#cat /sys/fs/cgroup/memory/docker/aeb38acde58155d421f998a54e9a99ab60635fe00c9070da050cc49a2f62d274/memory.soft_limit_in_bytes
134217728

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#36719;&#38480;&#21046;&#19981;&#33021;&#39640;&#20110;&#30828;&#38480;&#21046;
</span>[root@ubuntu1804 ~]#docker run -it --rm -m 256m --memory-reservation 257m --name xxx-c1 lorel/docker-stress-ng --vm 2 --vm-bytes 256M
</pre>
</div>


<p>
<b>关闭OOM 机制:</b><br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;"># </span><span style="color: #b22222;">docker run -it --rm -m 256m --oom-kill-disable --name xxx-c1
</span>lorel/docker-stress-ng --vm 2 --vm-bytes 256M
<span style="color: #b22222;"># </span><span style="color: #b22222;">cat /sys/fs/cgroup/memory/docker/&#23481;&#22120; ID/memory.oom_control
</span>oom_kill_disable 1
under_oom 1
oom_kill 0
</pre>
</div>

<p>
范例: 关闭OOM机制<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#26597;&#30475;docker OOM&#26426;&#21046;&#40664;&#35748;&#20540;
</span>[root@ubuntu1804 ~]#cat /sys/fs/cgroup/memory/docker/memory.oom_control
oom_kill_disable 0
under_oom 0
oom_kill 0
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21551;&#21160;&#23481;&#22120;&#26102;&#20851;&#38381;OOM&#26426;&#21046;
</span>[root@ubuntu1804 ~]#docker run -it --rm -m 200m --oom-kill-disable lorel/docker-stress-ng --vm 2 --vm-bytes 256M

[root@ubuntu1804 ~]#docker stats --no-stream
CONTAINER ID NAME CPU % MEM USAGE / LIMIT
MEM % NET I/O BLOCK I/O PIDS
b655d88228c0 silly_borg 0.00% 197.2MiB / 200MiB
98.58% 1.31kB / 0B 1.84MB / 484MB 5

[root@ubuntu1804 ~]#cat /sys/fs/cgroup/memory/docker/b655d88228c04d7db6a6ad833ed3d05d4cd596ef09834382e17942db0295dc0c/memory.oom_control
oom_kill_disable 1
under_oom 1
oom_kill 0
[root@ubuntu1804 ~]#
</pre>
</div>

<p>
交换分区限制:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;"># </span><span style="color: #b22222;">docker run -it --rm -m 256m --memory-swap 512m --name xxx-c1 centos
</span>bash
<span style="color: #b22222;"># </span><span style="color: #b22222;">cat /sys/fs/cgroup/memory/docker/&#23481;&#22120; ID/memory.memsw.limit_in_bytes 536870912
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">&#36820;&#22238;&#20540;</span>
</pre>
</div>

<p>
7.3 容器的CPU限制<br>
7.3.1 容器的CPU限制介绍<br>
官方文档说明: <a href="https://docs.docker.com/config/containers/resource_constraints/">https://docs.docker.com/config/containers/resource_constraints/</a><br>
</p>

<p>
一个宿主机，有几十个核心的CPU，但是宿主机上可以同时运行成百上千个不同的进程用以处理不同的任务，多进程共用一个 CPU 的核心为可压缩资源，即一个核心的 CPU 可以通过调度而运行多个进程，但是同一个单位时间内只能有一个进程在 CPU 上运行，那么这么多的进程怎么在 CPU 上执行和调度的呢？<br>
</p>

<p>
Linux kernel 进程的调度基于CFS(Completely Fair Scheduler)，完全公平调度<br>
</p>

<p>
<b>服务器资源密集型</b><br>
</p>
<ul class="org-ul">
<li>CPU 密集型的场景: 优先级越低越好，计算密集型任务的特点是要进行大量的计算，消耗CPU 资源，比如计算圆周率、数据处理、对视频进行高清解码等等，全靠CPU 的运算能力。<br></li>
<li>IO 密集型的场景: 优先级值高点，涉及到网络、磁盘IO 的任务都是IO 密集型任务，这类任务的特点是 CPU 消耗很少，任务的大部分时间都在等待 IO 操作完成（因为 IO 的速度远远低于 CPU 和内存的速度），比如 Web 应用，高并发，数据量大的动态网站来说，数据库应该为IO 密集型<br></li>
</ul>


<p>
<b>CFS原理</b><br>
cfs定义了进程调度的新模型，它给cfs_rq（cfs的run queue）中的每一个进程安排一个虚拟时钟vruntime。如果一个进程得以执行，随着时间的增长，其vruntime将不断增大。没有得到执行的进程vruntime不变, 而调度器总是选择vruntime跑得最慢的那个进程来执行。这就是所谓的“完全公平”。为了区别不同优先级的进程，优先级高的进程vruntime增长得慢，以至于它可能得到更多的运行机会。CFS的意义在于， 在一个混杂着大量计算型进程和IO交互进程的系统中，CFS调度器相对其它调度器在对待IO交互进程要更加友善和公平。<br>
</p>
</div>
</div>
<div id="outline-container-h:f4cbd166-83cf-4ddc-be1a-fa4a5d3ed17d" class="outline-4">
<h4 id="h:f4cbd166-83cf-4ddc-be1a-fa4a5d3ed17d">配置默认的CFS调度程序</h4>
<div class="outline-text-4" id="text-h:f4cbd166-83cf-4ddc-be1a-fa4a5d3ed17d">
<p>
默认情况下，每个容器对主机的CPU周期的访问都是不受限制的。可以设置各种约束，以限制给定容器对主机CPU周期的访问。大多数用户使用并配置 <a href="https://docs.docker.com/config/containers/resource_constraints/#configure-the-default-cfs-scheduler">默认的CFS调度程序</a>。在Docker 1.13及更高版本中，还可以配置 <a href="https://docs.docker.com/config/containers/resource_constraints/#configure-the-realtime-scheduler">realtime scheduler</a>。<br>
</p>

<p>
CFS是用于常规Linux进程的Linux内核CPU调度程序。通过几个运行时标志,可以配置对容器拥有的CPU资源的访问量。使用这些设置时，Docker会在主机上修改容器cgroup的设置。<br>
</p>

<p>
选项 描述<br>
&#x2013;cpus=<br>
指定一个容器可以使用多少个可用的CPU核心资源。例如，如果主机有两个CPU，如果设置了 &#x2013;cpus="1.5" ，则可以保证容器最多使用1.5个的CPU(如果是4核CPU，那么还可以是4核心上每核用一点，但是总计是1.5核心的CPU)。这相当于设置 &#x2013;cpu-period="100000" 和 &#x2013;cpu-quota="150000" 。此设置可在Docker 1.13及更高版本中可用，目的是替代&#x2013;cpu-period和&#x2013;cpu-quota两个参数，从而使配置更简单，但是最大不能超出宿主机的CPU总核心数(在操作系统看到的CPU超线程后的数值)，此项较常用<br>
</p>

<p>
&#x2013;cpuperiod=<br>
过时选项,指定CPU CFS调度程序周期，必须与 &#x2013;cpu-quota 一起使用 。默认为100微秒。大多数用户不会更改默认设置。如果使用Docker 1.13或更高版本，请改用 &#x2013;cpus<br>
</p>

<p>
&#x2013;cpu-quota=<br>
过时选项,在容器上添加 CPU CFS 配额，计算方式为 cpu-quota / cpu-period的结果值，docker1.13 及以上版本通常使用&#x2013;cpus 设置此值<br>
</p>

<p>
&#x2013;cpusetcpus<br>
用于指定容器运行的 CPU 编号，也就是所谓的CPU绑定。如果一个或多个CPU，则容器可以使用逗号分隔的列表或用连字符分隔的CPU范围。第一个CPU的编号为0。有效值可能是 0-3 （使用第一，第二，第三和第四CPU）或1,3 （使用第二和第四CPU）<br>
</p>

<p>
&#x2013;cpu-shares<br>
用于设置 cfs 中调度的相对最大比例权重,cpu-share 的值越高的容器，将会分得更多的时间片(宿主机多核 CPU 总数为 100%，假如容器 A 为1024，容器 B为 2048，那么容器 B 将最大是容器 A 的可用 CPU 的两倍 )，默认的时间片1024，最大 262144。这是一个软限制。<br>
</p>
</div>
</div>
<div id="outline-container-h:58812ca9-527e-4f49-983b-5ee56e3302de" class="outline-4">
<h4 id="h:58812ca9-527e-4f49-983b-5ee56e3302de">使用stress-ng测试cpu配置</h4>
<div class="outline-text-4" id="text-h:58812ca9-527e-4f49-983b-5ee56e3302de">
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker run -it --rm --name xxx-c1 lorel/docker-stressng |grep cpu
-c N, --cpu N start N workers spinning on sqrt(rand())
      --cpu-ops N stop when N cpu bogo operations completed
-l P, --cpu-load P load CPU by P %%, <span style="color: #a0522d;">0</span>=sleep, <span style="color: #a0522d;">100</span>=full load (see -c)
      --cpu-method m specify stress cpu method m, default is all
Example: stress-ng --cpu 8 --io 4 --vm 2 --vm-bytes 128M --fork 4 --timeout 10s
</pre>
</div>

<p>
范例：不限制容器CPU<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#lscpu |grep CPU
CPU op-mode(s): 32-bit, 64-bit
<span style="color: #0000ff;">CPU</span>(s): 6
On-line CPU(s) list: 0-5
CPU family: 6
Model name: Intel(R) Core(TM) i7-4710HQ CPU @ 2.50GHz
CPU MHz: 2494.236
NUMA node0 CPU(s): 0-5

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21344;&#29992;4&#20010;CPU&#36164;&#28304;.&#20294;&#21482;&#26159;&#24179;&#22343;&#30340;&#20351;&#29992;CPU&#36164;&#28304;
</span>[root@ubuntu1804 ~]#docker run -it --rm lorel/docker-stress-ng --cpu 4

[root@ubuntu1804 ~]#docker stats --no-stream
CONTAINER ID NAME CPU % MEM USAGE / LIMIT
MEM % NET I/O BLOCK I/O PIDS
818a85e1da2f frosty_taussig 595.57% 1.037GiB / 2.908GiB
35.64% 1.12kB / 0B 0B / 0B 13

[root@ubuntu1804 ~]#cat /sys/fs/cgroup/cpuset/docker/818a85e1da2f9a4ef297178a9dc09b338b2308108195ad8d4197a1c47febcbff/cpuset.cpus
0-5
[root@ubuntu1804 ~]#top
</pre>
</div>

<p>
范例: 查看 stress-n 关于cpu的帮助范例:<br>
</p>

<p>
范例: 限制使用CPU<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker run -it --rm --cpus 1.5 lorel/docker-stress-ng --cpu 4

[root@ubuntu1804 ~]#docker stats --no-stream
CONTAINER ID NAME CPU % MEM USAGE / LIMIT
MEM % NET I/O BLOCK I/O PIDS
9f8b2e693113 busy_hodgkin 147.71% 786.8MiB / 2.908GiB
26.42% 836B / 0B 0B / 0B 13
[root@ubuntu1804 ~]#top
</pre>
</div>

<p>
范例: 限制CPU<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker run -it --rm --cpu-quota 2000 --cpu-period 1000 lorel/docker-stress-ng --cpu 4

[root@ubuntu1804 ~]#docker stats --no-stream
CONTAINER ID NAME CPU % MEM USAGE /
LIMIT MEM % NET I/O BLOCK I/O PIDS
bd949bb6698e affectionate_chebyshev 185.03% 1.037GiB /
2.908GiB 35.64% 836B / 0B 0B / 0B 13
[root@ubuntu1804 ~]#
</pre>
</div>

<p>
范例: 绑定CPU<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#19968;&#33324;&#19981;&#24314;&#35758;&#32465;&#22312;0&#21495;CPU&#19978;&#65292;&#22240;0&#21495;CPU&#19968;&#33324;&#20250;&#36739;&#24537;
</span>[root@ubuntu1804 ~]#docker run -it --rm --cpus 1.5 --cpuset-cpus 2,4-5 lorel/docker-stress-ng --cpu 4

[root@ubuntu1804 ~]#docker stats --no-stream
CONTAINER ID NAME CPU % MEM USAGE / LIMIT
MEM % NET I/O BLOCK I/O PIDS
585879094e73 hungry_albattani 154.35% 1.099GiB / 2.908GiB
37.79% 906B / 0B 0B / 0B 13

[root@ubuntu1804 ~]#cat /sys/fs/cgroup/cpuset/docker/585879094e7382d2ef700947b4454426eee7f943f8d1438fe42ce34df789227b/cpuset.cpus
2,4-5
[root@ubuntu1804 ~]#top
</pre>
</div>

<p>
范例: 多个容器的CPU利用率比例<br>
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#21516;&#26102;&#24320;&#20004;&#20010;&#23481;&#22120;
</span>[root@ubuntu1804 ~]#docker run -it --rm --name c1 --cpu-shares 1000 lorel/docker-stress-ng --cpu 4

[root@ubuntu1804 ~]#docker run -it --rm --name c2 --cpu-shares 500 lorel/docker-stress-ng --cpu 4

[root@ubuntu1804 ~]#docker stats --no-stream
CONTAINER ID NAME CPU % MEM USAGE / LIMIT
MEM % NET I/O BLOCK I/O PIDS
a1d4c6e6802d c2 195.88% 925.3MiB / 2.908GiB
31.07% 726B / 0B 0B / 0B 13
d5944104aff4 c1 398.20% 1.036GiB / 2.908GiB
35.64% 906B / 0B 0B / 0B 13
[root@ubuntu1804 ~]#

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26597;&#30475;c1&#23481;&#22120;&#30340;cpu&#21033;&#29992;&#27604;&#20363;
</span>[root@ubuntu1804 ~]#cat /sys/fs/cgroup/cpu,cpuacct/docker/d5944104aff40b7b76f536c45a68cd4b98ce466a73416b68819b9643e3f49da7/cpu.shares
1000

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26597;&#30475;c2&#23481;&#22120;&#30340;cpu&#21033;&#29992;&#27604;&#20363;
</span>[root@ubuntu1804 ~]#cat /sys/fs/cgroup/cpu,cpuacct/docker/a1d4c6e6802d1b846b33075f3c1e1696376009e85d9ff8756f9a8d93d3da3ca6/cpu.shares
500

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#20877;&#25171;&#24320;&#26032;&#30340;&#23481;&#22120;&#65292;cpu&#20998;&#37197;&#27604;&#20363;&#20250;&#21160;&#24577;&#35843;&#25972;
</span>[root@ubuntu1804 ~]#docker run -it --rm --name c3 --cpu-shares 2000 lorel/docker-stress-ng --cpu 4
[root@ubuntu1804 ~]#docker stats --no-stream
CONTAINER ID NAME CPU % MEM USAGE / LIMIT
MEM % NET I/O BLOCK I/O PIDS
c2d54818e1fe c3 360.15% 664.5MiB / 2.908GiB
22.31% 726B / 0B 1.64GB / 150MB 13
a1d4c6e6802d c2 82.94% 845.2MiB / 2.908GiB
28.38% 936B / 0B 103MB / 4.54MB 13
d5944104aff4 c1 181.18% 930.1MiB / 2.908GiB
31.23% 1.12kB / 0B 303MB / 19.8MB 13
</pre>
</div>


<p>
范例: 动态调整cpu shares值<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#echo 2000 &gt;/sys/fs/cgroup/cpu,cpuacct/docker/a1d4c6e6802d1b846b33075f3c1e1696376009e85d9ff8756f9a8d93d3da3ca6/cpu.shares

[root@ubuntu1804 ~]#docker stats --no-stream
CONTAINER ID NAME CPU % MEM USAGE / LIMIT
MEM % NET I/O BLOCK I/O PIDS
a1d4c6e6802d c2 389.31% 1.037GiB / 2.908GiB
35.64% 1.01kB / 0B 1.16GB / 14MB 13
d5944104aff4 c1 200.28% 1.036GiB / 2.908GiB
35.63% 1.19kB / 0B 2.66GB / 26.7MB 13
[root@ubuntu1804 ~]#
</pre>
</div>
</div>
</div>
</div>
</section>
<section id="outline-container-h:b1ea57c6-89bb-4607-a02f-38f5cb345522" class="outline-2">
<h2 id="h:b1ea57c6-89bb-4607-a02f-38f5cb345522">可视化图形工具Portainer</h2>
<div class="outline-text-2" id="text-h:b1ea57c6-89bb-4607-a02f-38f5cb345522">
</div>
<div id="outline-container-h:472b9e5f-1c0d-4139-8206-fad72db72b18" class="outline-3">
<h3 id="h:472b9e5f-1c0d-4139-8206-fad72db72b18">Portainer介绍</h3>
<div class="outline-text-3" id="text-h:472b9e5f-1c0d-4139-8206-fad72db72b18">
<p>
Portainer是一个可视化的容器镜像的图形管理工具，利用Portainer可以轻松构建，管理和维护Docker环境。 而且完全免费，基于容器化的安装方式，方便高效部署。<br>
</p>

<p>
官方站点: <a href="https://www.portainer.io/">https://www.portainer.io/</a><br>
</p>
</div>
</div>
<div id="outline-container-h:8e9f87e1-3e26-44e6-90d9-b3924ebd16b6" class="outline-3">
<h3 id="h:8e9f87e1-3e26-44e6-90d9-b3924ebd16b6">安装 Portainer</h3>
<div class="outline-text-3" id="text-h:8e9f87e1-3e26-44e6-90d9-b3924ebd16b6">
<p>
官方安装说明: <a href="https://www.portainer.io/installation/">https://www.portainer.io/installation/</a><br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@ubuntu1804 ~]#docker search portainer |head -n 3

<span style="color: #b22222;">#</span><span style="color: #b22222;">portainer&#39033;&#30446;&#24223;&#24323;
</span>[root@ubuntu1804 ~]#docker pull portainer/portainer

<span style="color: #b22222;">#</span><span style="color: #b22222;">portainer-ce&#39033;&#30446;&#20195;&#26367;portainer
</span>[root@ubuntu1804 ~]#docker pull portainer/portainer-ce
[root@ubuntu1804 ~]#docker volume create portainer_data
[root@ubuntu1804 ~]#docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -vportainer_data:/data portainer/portainer-ce
</pre>
</div>
</div>
</div>
<div id="outline-container-h:e23217cf-f634-4d75-b8a5-0413b6c43cea" class="outline-3">
<h3 id="h:e23217cf-f634-4d75-b8a5-0413b6c43cea">登录和使用Portainer</h3>
<div class="outline-text-3" id="text-h:e23217cf-f634-4d75-b8a5-0413b6c43cea">
<p>
用浏览器访问: <a href="http://localhost:9000">http://localhost:9000</a> 可以看到以下界面<br>
</p>

<p>
设置admin用户密码，需要输入两次超过8个字符的相同的密码<br>
</p>

<p>
docker 命令总结<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">attach  <span style="color: #b22222;"># </span><span style="color: #b22222;">&#24403;&#21069;shell&#19979;attach&#36830;&#25509;&#25351;&#23450;&#36816;&#34892;&#38236;&#20687;
</span>build   <span style="color: #b22222;"># </span><span style="color: #b22222;">&#36890;&#36807;dockerfile&#23450;&#21046;&#38236;&#20687;
</span>commit  <span style="color: #b22222;"># </span><span style="color: #b22222;">&#25552;&#20132;&#24403;&#21069;&#23481;&#22120;&#20026;&#26032;&#30340;&#38236;&#20687;
</span>cp      <span style="color: #b22222;"># </span><span style="color: #b22222;">&#20174;&#23481;&#22120;&#20013;&#25335;&#36125;&#25351;&#23450;&#25991;&#20214;&#25110;&#32773;&#30446;&#24405;&#21040;&#23487;&#20027;&#26426;&#20013;
</span>create  <span style="color: #b22222;"># </span><span style="color: #b22222;">&#21019;&#24314;&#19968;&#20010;&#26032;&#30340;&#23481;&#22120;&#65292;&#21516;run &#20294;&#19981;&#21551;&#21160;&#23481;&#22120;
</span>diff    <span style="color: #b22222;"># </span><span style="color: #b22222;">&#26597;&#30475;docker &#23481;&#22120;&#21464;&#21270;
</span>events  <span style="color: #b22222;"># </span><span style="color: #b22222;">&#20174;docker &#26381;&#21153;&#33719;&#21462;&#23481;&#22120;&#23454;&#26102;&#20107;&#20214;
</span><span style="color: #a020f0;">exec</span>    <span style="color: #b22222;"># </span><span style="color: #b22222;">&#22312;&#24050;&#23384;&#22312;&#30340;&#23481;&#22120;&#19978;&#36816;&#34892;&#21629;&#20196;
</span><span style="color: #483d8b;">export</span>  <span style="color: #b22222;"># </span><span style="color: #b22222;">&#23548;&#20986;&#23481;&#22120;&#30340;&#20869;&#23481;&#20316;&#20026;&#19968;&#20010; tar &#24402;&#26723;&#25991;&#20214;[&#23545;&#24212;import]
</span><span style="color: #483d8b;">history</span> <span style="color: #b22222;"># </span><span style="color: #b22222;">&#23637;&#31034;&#19968;&#20010;&#38236;&#20687;&#24418;&#25104;&#21382;&#21490;
</span>images  <span style="color: #b22222;"># </span><span style="color: #b22222;">&#21015;&#20986;&#31995;&#32479;&#24403;&#21069;&#38236;&#20687;
</span>import  <span style="color: #b22222;"># </span><span style="color: #b22222;">&#20174;tar&#21253;&#20013;&#30340;&#20869;&#23481;&#21019;&#24314;&#19968;&#20010;&#26032;&#30340;&#25991;&#20214;&#31995;&#32479;&#26144;&#20687;[&#23545;&#24212;export]
</span>info    <span style="color: #b22222;"># </span><span style="color: #b22222;">&#26174;&#31034;&#31995;&#32479;&#30456;&#20851;&#20449;&#24687;
</span>inspect <span style="color: #b22222;"># </span><span style="color: #b22222;">&#26597;&#30475;&#23481;&#22120;&#35814;&#32454;&#20449;&#24687;
</span><span style="color: #483d8b;">kill</span>    <span style="color: #b22222;"># </span><span style="color: #b22222;">kill &#25351;&#23450;&#23481;&#22120;load # &#20174;&#19968;&#20010;tar &#21253;&#20013;&#21152;&#36733;&#19968;&#20010;&#38236;&#20687;[&#23545;&#24212;save]
</span>login   <span style="color: #b22222;"># </span><span style="color: #b22222;">&#27880;&#20876;&#25110;&#32773;&#30331;&#38470;&#19968;&#20010;docker&#28304;&#26381;&#21153;&#22120;
</span><span style="color: #a020f0;">logout</span>  <span style="color: #b22222;"># </span><span style="color: #b22222;">&#20174;&#24403;&#21069;docker registry&#36864;&#20986;
</span>logs    <span style="color: #b22222;"># </span><span style="color: #b22222;">&#36755;&#20986;&#24403;&#21069;&#23481;&#22120;&#26085;&#24535;&#20449;&#24687;
</span>port    <span style="color: #b22222;"># </span><span style="color: #b22222;">&#26597;&#30475;&#26144;&#23556;&#31471;&#21475;&#23545;&#24212;&#30340;&#23481;&#22120;&#20869;&#37096;&#28304;&#31471;&#21475;
</span>pause   <span style="color: #b22222;"># </span><span style="color: #b22222;">&#26242;&#20572;&#23481;&#22120;
</span>ps      <span style="color: #b22222;"># </span><span style="color: #b22222;">&#21015;&#20986;&#23481;&#22120;&#21015;&#34920;
</span>pull    <span style="color: #b22222;"># </span><span style="color: #b22222;">&#20174;docker&#38236;&#20687;&#28304;&#26381;&#21153;&#22120;&#25289;&#21462;&#25351;&#23450;&#38236;&#20687;&#25110;&#32773;&#24211;&#38236;&#20687;
</span>push    <span style="color: #b22222;"># </span><span style="color: #b22222;">&#25512;&#36865;&#25351;&#23450;&#38236;&#20687;&#25110;&#32773;&#24211;&#38236;&#20687;&#33267;docker&#28304;&#26381;&#21153;&#22120;
</span>restart <span style="color: #b22222;"># </span><span style="color: #b22222;">&#37325;&#21551;&#36816;&#34892;&#30340;&#23481;&#22120;
</span>rm      <span style="color: #b22222;"># </span><span style="color: #b22222;">&#31227;&#38500;&#19968;&#20010;&#25110;&#32773;&#22810;&#20010;&#23481;&#22120;
</span>rmi     <span style="color: #b22222;"># </span><span style="color: #b22222;">&#31227;&#38500;&#19968;&#20010;&#25110;&#22810;&#20010;&#38236;&#20687;[&#26080;&#23481;&#22120;&#20351;&#29992;&#35813;&#38236;&#20687;&#25165;&#21487;&#21024;&#38500;&#65292;&#21542;&#21017;&#38656;&#35201;&#21024;&#38500;&#30456;&#20851;&#23481;&#22120;&#25165;&#21487;&#32487;&#32493;&#25110; -f &#24378;&#21046;&#21024;&#38500;]
</span>run     <span style="color: #b22222;"># </span><span style="color: #b22222;">&#21019;&#24314;&#19968;&#20010;&#26032;&#30340;&#23481;&#22120;&#24182;&#36816;&#34892;&#19968;&#20010;&#21629;&#20196;
</span>save    <span style="color: #b22222;"># </span><span style="color: #b22222;">&#20445;&#23384;&#19968;&#20010;&#38236;&#20687;&#20026;&#19968;&#20010;tar&#21253;[&#23545;&#24212;load]
</span>search  <span style="color: #b22222;"># </span><span style="color: #b22222;">&#22312;docker hub &#20013;&#25628;&#32034;&#38236;&#20687;
</span>start   <span style="color: #b22222;"># </span><span style="color: #b22222;">&#21551;&#21160;&#23481;&#22120;
</span>stop    <span style="color: #b22222;"># </span><span style="color: #b22222;">&#20572;&#27490;&#23481;&#22120;
</span>tag     <span style="color: #b22222;"># </span><span style="color: #b22222;">&#32473;&#28304;&#20013;&#38236;&#20687;&#25171;&#26631;&#31614;
</span>top     <span style="color: #b22222;"># </span><span style="color: #b22222;">&#26597;&#30475;&#23481;&#22120;&#20013;&#36816;&#34892;&#30340;&#36827;&#31243;&#20449;&#24687;
</span>unpause <span style="color: #b22222;"># </span><span style="color: #b22222;">&#21462;&#28040;&#26242;&#20572;&#23481;&#22120;
</span>version <span style="color: #b22222;"># </span><span style="color: #b22222;">&#26597;&#30475;docker&#29256;&#26412;&#21495;
</span><span style="color: #483d8b;">wait</span>    <span style="color: #b22222;"># </span><span style="color: #b22222;">&#25130;&#21462;&#23481;&#22120;&#20572;&#27490;&#26102;&#30340;&#36864;&#20986;&#29366;&#24577;&#20540;</span>
</pre>
</div>
</div>
</div>
</section>
<section id="outline-container-h:992ace4a-081c-48b8-a0a5-7fdd3909d89e" class="outline-2">
<h2 id="h:992ace4a-081c-48b8-a0a5-7fdd3909d89e">拓展</h2>
<div class="outline-text-2" id="text-h:992ace4a-081c-48b8-a0a5-7fdd3909d89e">
</div>
<div id="outline-container-h:071b57eb-9c77-4e55-bd05-005096bf91c9" class="outline-3">
<h3 id="h:071b57eb-9c77-4e55-bd05-005096bf91c9">多平台构建</h3>
<div class="outline-text-3" id="text-h:071b57eb-9c77-4e55-bd05-005096bf91c9">
<p>
<a href="https://docs.docker.com/build/concepts/overview/">https://docs.docker.com/build/concepts/overview/</a><br>
</p>

<p>
Linux 发行版通过 deb 或者 rpm 包所安装的 docker 内置了 buildx，不需要另行安装。<br>
</p>

<p>
如果你的 docker 没有 buildx 命令，可以下载二进制包进行安装：<br>
</p>
<ul class="org-ul">
<li>首先从 Docker buildx 项目的 release 页面找到适合自己平台的二进制文件。<br></li>
<li>下载二进制文件到本地并重命名为 docker-buildx，移动到 docker 的插件目录 ~/.docker/cli-plugins。<br></li>
<li>向二进制文件授予可执行权限。<br></li>
</ul>

<p>
如果本地的 docker 版本高于 19.03，可以通过以下命令直接在本地构建并安装，这种方式更为方便：<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #a0522d;">DOCKER_BUILDKIT</span>=1 docker build --platform=local -o . <span style="color: #8b2252;">"https://github.com/docker/buildx.git"</span>
mkdir -p ~/.docker/cli-plugins
mv buildx ~/.docker/cli-plugins/docker-buildx
</pre>
</div>

<p>
<a href="https://docs.docker.com/build/building/multi-platform/">https://docs.docker.com/build/building/multi-platform/</a><br>
</p>
</div>
<div id="outline-container-h:7c7d6c38-cb81-4e5d-b2d4-0972113f8ad6" class="outline-4">
<h4 id="h:7c7d6c38-cb81-4e5d-b2d4-0972113f8ad6">启用binfmt_misc</h4>
<div class="outline-text-4" id="text-h:7c7d6c38-cb81-4e5d-b2d4-0972113f8ad6">
<p>
CentOS用户建议Linux内核升级到4.x以上。<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">docker run --privileged --rm tonistiigi/binfmt --install all

<span style="color: #b22222;"># </span><span style="color: #b22222;">&#39564;&#35777;binfmt_misc&#26159;&#21542;&#24320;&#21551;
</span>ls -al /proc/sys/fs/binfmt_misc/
<span style="color: #b22222;"># </span><span style="color: #b22222;">&#39564;&#35777;&#26159;&#21542;&#21551;&#29992;&#20102;&#30456;&#24212;&#30340;&#22788;&#29702;&#22120;
</span>cat /proc/sys/fs/binfmt_misc/qemu-aarch64
</pre>
</div>
</div>
</div>
<div id="outline-container-h:6dafaaeb-0dc1-44a1-9ae9-4f1661838d96" class="outline-4">
<h4 id="h:6dafaaeb-0dc1-44a1-9ae9-4f1661838d96">从默认的构建器切换到多平台构建器</h4>
<div class="outline-text-4" id="text-h:6dafaaeb-0dc1-44a1-9ae9-4f1661838d96">
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;"># </span><span style="color: #b22222;">Switch to the new builder:
</span>docker buildx create --use --name mybuild
<span style="color: #b22222;"># </span><span style="color: #b22222;">&#21551;&#21160;&#26500;&#24314;&#22120;
</span>docker buildx inspect mybuild --bootstrap
<span style="color: #b22222;"># </span><span style="color: #b22222;">&#26597;&#30475;&#24403;&#21069;&#20351;&#29992;&#30340;&#26500;&#24314;&#22120;&#21450;&#26500;&#24314;&#22120;&#25903;&#25345;&#30340; CPU &#26550;&#26500;&#65292;&#21487;&#20197;&#30475;&#21040;&#25903;&#25345;&#24456;&#22810; CPU &#26550;&#26500;
</span>docker buildx ls
</pre>
</div>

<p>
禁用默认的 Attestations 功能,避免在合并镜像清单时出现错误<br>
</p>
<div class="org-src-container">
<pre class="src src-sh">cat &lt;&lt;\EOF&gt;&gt; ~/.bash_profile<span style="color: #ffa54f;">
#docker buildx  https://docs.docker.com/build/building/variables/#buildx_no_default_attestations
export BUILDX_NO_DEFAULT_ATTESTATIONS=1
EOF</span>
</pre>
</div>

<p>
参考：<a href="https://www.cloudnative101.net/posts/docker-multi-architecture-building-challenges/">构建多架构镜像，应对异构计算的挑战</a><br>
</p>
</div>
</div>
<div id="outline-container-h:bf4204c9-3aa9-449f-9cee-efe2e2c368d1" class="outline-4">
<h4 id="h:bf4204c9-3aa9-449f-9cee-efe2e2c368d1">构建多平台镜像</h4>
<div class="outline-text-4" id="text-h:bf4204c9-3aa9-449f-9cee-efe2e2c368d1">
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;"># </span><span style="color: #b22222;">&#21019;&#24314;&#19968;&#20010; Dockerfile
</span>FROM amazoncorretto:8u352
<span style="color: #b22222;"># </span><span style="color: #b22222;">openjdk:8-jre-slim
</span>
LABEL maintainer jasper.xu@xxx.com

ENV <span style="color: #a0522d;">PFGC_SERVICE_NAME</span>=rocketmq-exporter <span style="color: #8b2252;">\</span>
    <span style="color: #a0522d;">PFGC_SERVICE_PATH</span>=/opt/rocketmq-exporter <span style="color: #8b2252;">\</span>
    <span style="color: #a0522d;">PFGC_SERVICE_VERSION</span>=0.0.2

RUN ln -sf /usr/share/zoneinfo/Asia/Kolkata /etc/localtime <span style="color: #8b2252;">\</span>
    &amp;&amp; <span style="color: #483d8b;">echo</span> <span style="color: #8b2252;">'Asia/Kolkata'</span> &gt; /etc/timezone <span style="color: #8b2252;">\</span>
    &amp;&amp; mkdir -p ${<span style="color: #a0522d;">PFGC_SERVICE_PATH</span>}/

COPY ${<span style="color: #a0522d;">PFGC_SERVICE_NAME</span>}-${<span style="color: #a0522d;">PFGC_SERVICE_VERSION</span>}-SNAPSHOT.jar  ${<span style="color: #a0522d;">PFGC_SERVICE_PATH</span>}

EXPOSE 5557

WORKDIR ${<span style="color: #a0522d;">PFGC_SERVICE_PATH</span>}
</pre>
</div>
</div>
<div id="outline-container-h:4642b65d-04ac-43c7-8a38-2d0f2a096a12" class="outline-5">
<h5 id="h:4642b65d-04ac-43c7-8a38-2d0f2a096a12">使用 buildx 构建多架构的 Docker 镜像</h5>
<div class="outline-text-5" id="text-h:4642b65d-04ac-43c7-8a38-2d0f2a096a12">
<p>
利用缓存构建<br>
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#20026;&#20102;&#25552;&#21319;&#26500;&#24314;&#25928;&#29575;&#65292;&#21487;&#20197;&#21033;&#29992; Docker Buildx &#30340;&#32531;&#23384;&#26426;&#21046;&#12290;&#36825;&#23558;&#36991;&#20813;&#37325;&#22797;&#19979;&#36733;&#21644;&#26500;&#24314;&#30456;&#21516;&#30340;&#20381;&#36182;&#39033;&#65292;&#20174;&#32780;&#33410;&#30465;&#26102;&#38388;
</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#37197;&#32622;&#32531;&#23384;&#65292;&#24182;&#25512;&#36865;
</span>docker buildx build --platform linux/amd64,linux/arm64 -t user/app:latest --build-arg <span style="color: #a0522d;">BUILDKIT_INLINE_CACHE</span>=1 --cache-from=user/app:cache --push .
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#25512;&#36865;&#24102;&#32531;&#23384;&#30340;&#38236;&#20687;
</span>docker push user/app:cache
</pre>
</div>

<p>
构建支持 arm64 和 amd64的镜像<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">Docker Buildx &#25903;&#25345;&#21516;&#26102;&#26500;&#24314;&#22810;&#20010;&#26550;&#26500;&#30340;&#38236;&#20687;&#65292;&#24182;&#19988;&#21487;&#20197;&#23558;&#23427;&#20204;&#25171;&#21253;&#21040;&#19968;&#20010;&#22810;&#26550;&#26500;&#38236;&#20687;&#20013;&#36827;&#34892;&#25512;&#36865;
</span>docker buildx build --platform linux/amd64,linux/arm64 -t user/app:latest --push .

<span style="color: #b22222;"># </span><span style="color: #b22222;">&#38656;&#35201;&#25552;&#21069;&#36890;&#36807; docker login &#21629;&#20196;&#30331;&#24405;&#35748;&#35777;
</span><span style="color: #b22222;"># </span><span style="color: #b22222;">buildx &#20250;&#36890;&#36807; QEMU &#21644; binfmt_misc &#20998;&#21035;&#20026; 3 &#20010;&#19981;&#21516;&#30340; CPU &#26550;&#26500;&#65288;arm&#65292;arm64 &#21644; amd64&#65289;&#26500;&#24314; 3 &#20010;&#19981;&#21516;&#30340;&#38236;&#20687;&#12290;&#26500;&#24314;&#23436;&#25104;&#21518;&#65292;&#23601;&#20250;&#21019;&#24314;&#19968;&#20010; manifest list&#65292;&#20854;&#20013;&#21253;&#21547;&#20102;&#25351;&#21521;&#36825; 3 &#20010;&#38236;&#20687;&#30340;&#25351;&#38024;&#12290;
</span><span style="color: #b22222;"># </span><span style="color: #b22222;">&#29616;&#22312;&#23601;&#21487;&#20197;&#36890;&#36807; docker pull &#25289;&#21462;&#21018;&#21018;&#21019;&#24314;&#30340;&#38236;&#20687;&#20102;&#65292;Docker &#23558;&#20250;&#26681;&#25454;&#20320;&#30340; CPU &#26550;&#26500;&#25289;&#21462;&#21305;&#37197;&#30340;&#38236;&#20687;</span>
</pre>
</div>

<p>
创建 Manifest 并推送<br>
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#22312;&#26576;&#20123;&#24773;&#20917;&#19979;&#65292;&#20320;&#21487;&#33021;&#38656;&#35201;&#25163;&#21160;&#21019;&#24314;&#21644;&#25512;&#36865; Docker Manifest&#65292;&#36825;&#21487;&#20197;&#32467;&#21512;&#22810;&#20010;&#21333;&#26550;&#26500;&#38236;&#20687;&#21040;&#19968;&#20010;&#22810;&#26550;&#26500;&#38236;&#20687;&#20013;&#12290;
</span><span style="color: #b22222;">#</span><span style="color: #b22222;">1.&#21019;&#24314;&#22810;&#26550;&#26500;&#28165;&#21333;
</span>docker manifest create user/app:latest user/app:amd64 user/app:arm64
<span style="color: #b22222;">#</span><span style="color: #b22222;">2.&#27880;&#35299;&#27599;&#20010;&#26550;&#26500;&#30340;&#23646;&#24615;
</span>docker manifest annotate user/app:latest user/app:arm64 --arch arm64
docker manifest annotate user/app:latest user/app:amd64 --arch amd64
<span style="color: #b22222;">#</span><span style="color: #b22222;">3.&#25512;&#36865;&#22810;&#26550;&#26500;&#38236;&#20687;
</span>docker manifest push user/app:latest
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-h:8b73b117-34ae-4deb-8119-e18b45a2f166" class="outline-4">
<h4 id="h:8b73b117-34ae-4deb-8119-e18b45a2f166">保存到本地并推送到私有仓库</h4>
<div class="outline-text-4" id="text-h:8b73b117-34ae-4deb-8119-e18b45a2f166">
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;"># </span><span style="color: #b22222;">&#22914;&#26524;&#24819;&#23558;&#26500;&#24314;&#22909;&#30340;&#38236;&#20687;&#20445;&#23384;&#22312;&#26412;&#22320;&#65292;&#21487;&#20197;&#23558; type &#25351;&#23450;&#20026; docker&#65292;&#20294;&#24517;&#39035;&#20998;&#21035;&#20026;&#19981;&#21516;&#30340; CPU &#26550;&#26500;&#26500;&#24314;&#19981;&#21516;&#30340;&#38236;&#20687;&#65292;&#19981;&#33021;&#21512;&#24182;&#25104;&#19968;&#20010;&#38236;&#20687;&#65292;&#21363;&#65306;
</span>docker buildx build -t giaogiao/hello-arch --platform=linux/arm -o <span style="color: #a0522d;">type</span>=docker .
docker buildx build -t giaogiao/hello-arch --platform=linux/arm64 -o <span style="color: #a0522d;">type</span>=docker .
docker buildx build -t giaogiao/hello-arch --platform=linux/amd64 -o <span style="color: #a0522d;">type</span>=docker .
</pre>
</div>
</div>
</div>
<div id="outline-container-h:a8c381cc-dee0-4504-81d2-6cca5b6a71ab" class="outline-4">
<h4 id="h:a8c381cc-dee0-4504-81d2-6cca5b6a71ab">查看镜像支持的CPU架构</h4>
<div class="outline-text-4" id="text-h:a8c381cc-dee0-4504-81d2-6cca5b6a71ab">
<div class="org-src-container">
<pre class="src src-sh">docker inspect public.ecr.aws/ubuntu/mysql:8.0-22.04_edge
</pre>
</div>

<p>
platform段对应支持平台<br>
</p>
<pre class="example" id="orga5e35f5">
[root@proxy ~]# docker manifest inspect public.ecr.aws/ubuntu/mysql:8.0-22.04_edge
{
   "schemaVersion": 2,
   "mediaType": "application/vnd.docker.distribution.manifest.list.v2+json",
   "manifests": [
      {
         "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
         "size": 1620,
         "digest": "sha256:eae0acedcab5d0b39ef9be92ed2e1e17e41ea894d586dade0b5a90d254a4f283",
         "platform": {
            "architecture": "amd64",
            "os": "linux"
         }
      },
      {
         "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
         "size": 1620,
         "digest": "sha256:094e0938c81ae79e59c90ab3b0ffb85043f6dae9e7d3e5553fe2b0b00fb393d5",
         "platform": {
            "architecture": "s390x",
            "os": "linux"
         }
      },
      {
         "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
         "size": 1620,
         "digest": "sha256:49502011e2665acec7ab85899ebc4d5042cfe182a04f919f5249b05ab96a0485",
         "platform": {
            "architecture": "ppc64le",
            "os": "linux"
         }
      },
      {
         "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
         "size": 1620,
         "digest": "sha256:1a3d86e082d613da0beecfe24a4545813d2501b81e417eab6be0bda86f776535",
         "platform": {
            "architecture": "arm64",
            "os": "linux",
            "variant": "v8"
         }
      }
   ]
}
</pre>
</div>
</div>
<div id="outline-container-h:b36c4ecd-908f-4beb-a438-c041c7fcf113" class="outline-4">
<h4 id="h:b36c4ecd-908f-4beb-a438-c041c7fcf113">构建基础镜像</h4>
<div class="outline-text-4" id="text-h:b36c4ecd-908f-4beb-a438-c041c7fcf113">
<p>
多级构建能够有效减少镜像的层数和大小，同时将开发环境与生产环境分离。<br>
</p>
<div class="org-src-container">
<pre class="src src-sh">FROM --platform=$<span style="color: #a0522d;">BUILDPLATFORM</span> node:16 AS builder
WORKDIR /app
COPY package.json ./
RUN npm install
COPY . .

FROM --platform=$<span style="color: #a0522d;">TARGETPLATFORM</span> node:16-alpine
WORKDIR /app
COPY --from=builder /app .
CMD [<span style="color: #8b2252;">"node"</span>, <span style="color: #8b2252;">"app.js"</span>]
</pre>
</div>
</div>
<div id="outline-container-h:989f593c-d426-48da-82f9-69c9dbbc6dfd" class="outline-5">
<h5 id="h:989f593c-d426-48da-82f9-69c9dbbc6dfd">jdk amd 与 arm 平台</h5>
<div class="outline-text-5" id="text-h:989f593c-d426-48da-82f9-69c9dbbc6dfd">
<p>
基于ubuntu<br>
</p>
<div class="org-src-container">
<pre class="src src-sh">[root@ip-172-31-5-34 .jasper]# ll
-rw-r--r--.  1 root     root      75425137 Nov 19 18:05 jdk-8u431-linux-aarch64.tar.gz
-rw-r--r--.  1 root     root     148362647 Dec  2 18:44 jdk-8u431-linux-x64.tar.gz

cat &lt;&lt;\EOF&gt; Dockerfile<span style="color: #ffa54f;">
FROM ubuntu:25.04 AS builder

ENV LANG=en_US.UTF-8 JAVA_VERSION=1.8.0_431 JAVA_HOME=/usr/local/jdk1.8
ADD jdk-8u431-linux-x64.tar.gz /usr/local/amd
ADD jdk-8u431-linux-aarch64.tar.gz /usr/local/arm
RUN set -eux; \
        arch_tmp="$(arch)"; \
        case "$arch_tmp" in \
                'x86_64') \
             mv /usr/local/amd/jdk1.8.0_431 /usr/local/jdk1.8;; \
                'aarch64') \
             mv /usr/local/arm/jdk1.8.0_431 /usr/local/jdk1.8;; \
        esac


FROM ubuntu:25.04
ENV LANG=en_US.UTF-8 JAVA_VERSION=1.8.0_431 JAVA_HOME=/usr/local/jdk1.8

COPY --from=builder ${JAVA_HOME} /usr/local/jdk1.8
RUN set -x &amp;&amp; rm -rf ${JAVA_HOME}/*src.zip /tmp/*
RUN apt update &amp;&amp; apt install -y  net-tools iproute2 iputils-ping less telnet file curl &amp;&amp; cd /opt &amp;&amp; curl -O https://alibaba.github.io/arthas/arthas-boot.jar
ENV PATH=/usr/local/jdk1.8/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
EOF
</span>

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#30331;&#24405;ECR&#24182;&#21019;&#24314;&#20179;&#24211;
</span>aws ecr get-login-password --region ap-south-1 | docker login --username AWS --password-stdin xxxxx.dkr.ecr.ap-south-1.amazonaws.com
aws ecr create-repository --repository-name devops/jdk

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26500;&#24314;&#24182;&#25512;&#36865;
</span>docker buildx build -t xxxx.dkr.ecr.ap-south-1.amazonaws.com/devops/jdk:1.8 --platform=linux/arm64,linux/amd64 --push .

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26816;&#26597;Docker &#28165;&#21333;&#21015;&#34920;
</span>aws ecr batch-get-image --repository-name devops/jdk --image-ids <span style="color: #a0522d;">imageTag</span>=1.8 --query <span style="color: #8b2252;">'images[].imageManifest'</span> --output text
</pre>
</div>


<p>
基于centos<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">~]# ll
-rw-r--r-- 1 root root       951 Apr 19 10:33 Dockerfile
-rw-r--r-- 1 root root  74554190 Apr 18 14:16 jdk-8u361-linux-aarch64.tar.gz
-rw-r--r-- 1 root root 138762230 Apr 18 14:16 jdk-8u361-linux-x64.tar.gz

cat &lt;&lt;\EOF&gt; Dockerfile<span style="color: #ffa54f;">
FROM centos:centos7.9.2009 as builder

ENV LANG=en_US.UTF-8 JAVA_VERSION=1.8.0_361 JAVA_HOME=/usr/local/jdk1.8
ADD jdk-8u361-linux-x64.tar.gz /usr/local/amd
ADD jdk-8u361-linux-aarch64.tar.gz /usr/local/arm
RUN set -eux; \
        arch_tmp="$(arch)"; \
        case "$arch_tmp" in \
                'x86_64') \
             mv /usr/local/amd/jdk1.8.0_361 /usr/local/jdk1.8;; \
                'aarch64') \
             mv /usr/local/arm/jdk1.8.0_361 /usr/local/jdk1.8;; \
        esac


FROM centos:centos7.9.2009
ENV LANG=en_US.UTF-8 JAVA_VERSION=1.8.0_361 JAVA_HOME=/usr/local/jdk1.8

COPY --from=builder ${JAVA_HOME} /usr/local/jdk1.8
RUN set -x &amp;&amp; rm -rf ${JAVA_HOME}/*src.zip /tmp/*
RUN yum install net-tools iproute iputils less telnet -y &amp;&amp; yum install less which file -y &amp;&amp; yum clean all &amp;&amp; cd /opt &amp;&amp; curl -O https://alibaba.github.io/arthas/arthas-boot.jar
ENV PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/jdk1.8/bin
EOF
</span>
docker buildx build -t harbor.xxx.com/devops/serverjdk:20221205_1.8 --platform=linux/arm64,linux/amd64 --push .
</pre>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="outline-container-h:969bcc40-9fdd-460a-95ae-a9a6b50e82b1" class="outline-2">
<h2 id="h:969bcc40-9fdd-460a-95ae-a9a6b50e82b1">容器多进程管理</h2>
<div class="outline-text-2" id="text-h:969bcc40-9fdd-460a-95ae-a9a6b50e82b1">
<ul class="org-ul">
<li>s6-svscan<br></li>
<li>supervisord<br></li>
</ul>
</div>
</section>
<section id="outline-container-h:63f48071-3ed6-4909-8d0f-62ed03accd52" class="outline-2">
<h2 id="h:63f48071-3ed6-4909-8d0f-62ed03accd52">资源清理</h2>
<div class="outline-text-2" id="text-h:63f48071-3ed6-4909-8d0f-62ed03accd52">
<p>
Docker 18.09 引入了 BuildKit ，提升了构建过程的性能、安全、存储管理等能力。<br>
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#26597;&#30475;&#30913;&#30424;&#20351;&#29992;&#24773;&#20917;
</span>docker system df

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#26597;&#30475;&#25152;&#26377;&#24773;&#20917;
</span>docker system df -v

&#23637;&#31034;&#20197;&#19979;&#37096;&#20998;
Images space usage:
Containers space usage:
Local Volumes space usage:
Build cache usage: 
</pre>
</div>

<p>
清理<br>
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b22222;"># </span><span style="color: #b22222;">&#28165;&#29702;&#20851;&#38381;&#30340;&#23481;&#22120;&#12289;&#26080;&#29992;&#30340;&#25968;&#25454;&#21367;&#21644;&#32593;&#32476;&#31561;
</span>docker system prune

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#36830;&#21516;&#27809;&#26377;&#23481;&#22120;&#20351;&#29992;&#30340;&#38236;&#20687;&#19968;&#36215;&#28165;&#38500;
</span>docker system prune -a
</pre>
</div>

<p>
构建缓存清理<br>
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#28165;&#29702;&#25152;&#26377;&#26500;&#24314;&#32531;&#23384;
</span>docker builder prune

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#28165;&#29702;10&#22825;&#20043;&#21069;&#30340;&#32531;&#23384;
</span>docker builder prune --filter <span style="color: #8b2252;">'until=240h'</span>

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#31995;&#32479;crontab &#23450;&#26102;&#28165;&#29702;
</span>0 0 * * * echo <span style="color: #8b2252;">'y'</span>| docker builder prune
</pre>
</div>
</div>
</section>
<section id="outline-container-h:1e560131-863e-4fbb-94ea-a29776de706a" class="outline-2">
<h2 id="h:1e560131-863e-4fbb-94ea-a29776de706a">容器排查</h2>
<div class="outline-text-2" id="text-h:1e560131-863e-4fbb-94ea-a29776de706a">
</div>
<div id="outline-container-h:c60a118b-5116-408d-8a3d-fb2bd716d228" class="outline-3">
<h3 id="h:c60a118b-5116-408d-8a3d-fb2bd716d228">查看进程是否属于docker</h3>
<div class="outline-text-3" id="text-h:c60a118b-5116-408d-8a3d-fb2bd716d228">
<div class="org-src-container">
<pre class="src src-shell">ps -f  --ppid 1580
--------------

[root@mesos24 /usr/local/nginx/conf/vhosts]# ps -f  --ppid 1580
UID        PID  PPID  C STIME TTY          TIME CMD
root      3861  1580  0 Apr22 ?        05:00:54 docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 5001 -container-ip 172.17.0.3 -container-port 5000
root      3909  1580  0 Apr22 ?        00:03:15 /bin/s6-svscan /service
root      3973  1580  0 Apr22 ?        04:56:02 docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 80 -container-ip 172.17.0.4 -container-port 5001
root      4012  1580  0 Apr22 ?        06:16:01 docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 443 -container-ip 172.17.0.4 -container-port 5000
root      4051  1580  0 Apr22 ?        04:56:08 docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 5000 -container-ip 172.17.0.4 -container-port 5000
root      4088  1580  0 Apr22 ?        00:00:00 nginx: master process nginx -g daemon off;
root     48577  1580  0 May17 ?        03:27:59 docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 32769 -container-ip 172.17.0.2 -container-port 5000
root     48602  1580  0 May17 ?        09:02:11 registry serve /etc/docker/registry/config.yml
You have new mail<span style="color: #a020f0;"> in</span> /var/spool/mail/root
[root@mesos24 /usr/local/nginx/conf/vhosts]# ps -ef|grep nginx
root      4088  1580  0 Apr22 ?        00:00:00 nginx: master process nginx -g daemon off;
101       4121  4088  0 Apr22 ?        02:53:27 nginx: worker process
root     55752     1  1 11:06 ?        00:00:31 nginx: master process /usr/local/nginx-1.12.2/sbin/nginx
root     60243 55752  0 11:48 ?        00:00:00 nginx: worker process
root     60244 55752  0 11:48 ?        00:00:00 nginx: worker process
root     60245 55752  0 11:48 ?        00:00:00 nginx: worker process
root     60246 55752  0 11:48 ?        00:00:00 nginx: worker process
root     60267 55556  0 11:48 pts/2    00:00:00 grep --color=auto nginx
[root@mesos24 /usr/local/nginx/conf/vhosts]# ps -f  --ppid 4088
UID        PID  PPID  C STIME TTY          TIME CMD
101       4121  4088  0 Apr22 ?        02:53:27 nginx: worker process
</pre>
</div>

<p>
pstree或pgrep吧，就是pstree写脚本有点麻烦<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">[root@mesos24 /usr/local/nginx/conf/vhosts]# ll /proc/1580 |grep exe
lrwxrwxrwx  1 root root 0 Apr 22 09:23 exe -&gt; /usr/bin/docker-current
[root@mesos24 /usr/local/nginx/conf/vhosts]# pstree -p $(pgrep -f <span style="color: #8b2252;">"/usr/bin/docker-current"</span>)|grep nginx
                     |-nginx(4088)---nginx(4121)
</pre>
</div>
</div>
</div>
<div id="outline-container-h:1ed705e2-b568-4ad3-b08e-0d93e206287f" class="outline-3">
<h3 id="h:1ed705e2-b568-4ad3-b08e-0d93e206287f">找到本机docker进程</h3>
<div class="outline-text-3" id="text-h:1ed705e2-b568-4ad3-b08e-0d93e206287f">
<p>
有这样的情况，我们用ps命令发现的进程不一定是本机进程，可能是docker容器里的进程。那么有什么方法来确定是不是docker进程呢？<br>
</p>

<p>
方法1<br>
ps -efH 命令<br>
</p>

<p>
方法2<br>
systemd-cgls 命令展示所有的cgroups和在运行的进程。<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">[root@sw-edge ~]# systemd-cgls
&#9500;&#9472;1 /usr/lib/systemd/systemd --switched-root --system --deserialize 21
&#9500;&#9472;docker
&#9474; &#9492;&#9472;8bc37aa7fec9708d514b37a097dd710ae77f8ea17962a1cae6ef030f2a0f4b24
&#9474;   &#9500;&#9472;763 s6-svscan /etc/s6/ -t 5
&#9474;   &#9500;&#9472;780 s6-supervise 02-sw-edge-task01
</pre>
</div>
<p>
也可以用systemd-cgtop命令<br>
</p>

<p>
示例<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;"># </span><span style="color: #b22222;">top -p 2910 -b1
</span>  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
 2910 root      20   0   48.1g  47.8g   9704 S   0.0 78.7  38000:19 agent
[root@iz2zebtgnlb4lk5d6s0lagz ~] <span style="color: #a0522d;">eth0</span> = 10.16.30.8
<span style="color: #b22222;"># </span><span style="color: #b22222;">systemd-cgls |grep -C3 2910
</span>&#9474; &#9500;&#9472;kubepods-besteffort.slice
&#9474; &#9474; &#9500;&#9472;kubepods-besteffort-podc26d0a17_60be_4ae1_860e_35261a108ba8.slice
&#9474; &#9474; &#9474; &#9500;&#9472;docker-2c12d284f60e211e74c0ec6585e0dd358a8cf3819973ac49a19ab0bb095fe1b0.scope
&#9474; &#9474; &#9474; &#9474; &#9492;&#9472;2910 agent
&#9474; &#9474; &#9474; &#9492;&#9472;docker-ee47a832ee8313c211afee65f5aff04b43813ead87f381520195e1622216a767.scope

[root@iz2zebtgnlb4lk5d6s0lagz ~] <span style="color: #a0522d;">eth0</span> = 10.16.30.8
<span style="color: #b22222;"># </span><span style="color: #b22222;">docker ps |grep 2c12d2
</span>2c12d284f60e        e2fedec23950                                                        <span style="color: #8b2252;">"run.sh"</span>                 7 weeks ago         Up 7 weeks                              k8s_cluster-register_cattle-cluster-agent-57d964bc59-zd45n_cattle-system_c26d0a17-60be-4ae1-860e-35261a108ba8_0
</pre>
</div>

<p>
方法3<br>
the process run in a docker container is a child of a process named containerd-shim (in Docker v18.09.4)<br>
</p>

<p>
First figure out the process IDs of the containerd-shim processes.<br>
For each of them, find their child process.<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">pgrep containerd-shim
7105
7141
7248
</pre>
</div>

<p>
To find the child process of parent process 7105:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell">pgrep -P 7105
7127
</pre>
</div>

<p>
In the end you could get the list with:<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #a020f0;">for</span> i<span style="color: #a020f0;"> in</span> $(pgrep containerd-shim); <span style="color: #a020f0;">do</span> pgrep -P $<span style="color: #a0522d;">i</span>; <span style="color: #a020f0;">done</span>
7127
7166
7275
</pre>
</div>

<p>
ps -axfo pid,ppid,uname,cmd<br>
</p>

<p>
方法4<br>
docker ps<br>
</p>

<p>
方法5<br>
找到容器运行的进程<br>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #a0522d;">DID</span>=$(docker inspect -f <span style="color: #8b2252;">'{{.State.Pid}}'</span> &lt;Container ID&gt;);ps --ppid $<span style="color: #a0522d;">DID</span> -o pid,ppid,cmd


[root@sw-edge ~]# docker ps -q
8bc37aa7fec9
[root@sw-edge ~]# <span style="color: #a0522d;">DID</span>=$(docker inspect -f <span style="color: #8b2252;">'{{.State.Pid}}'</span> 8bc37aa7fec9);ps --ppid $<span style="color: #a0522d;">DID</span> -o pid,ppid,cmd
  PID  PPID CMD
  780   763 s6-supervise 02-sw-edge-task01
  781   763 s6-supervise 03-sw-edge-cron01
  782   763 s6-supervise 01-sw-edge-app01
</pre>
</div>
</div>
</div>
<div id="outline-container-h:78d10d28-62ec-4395-bd36-2735308c8097" class="outline-3">
<h3 id="h:78d10d28-62ec-4395-bd36-2735308c8097">通过docker overlay2 目录名查找对应容器名</h3>
<div class="outline-text-3" id="text-h:78d10d28-62ec-4395-bd36-2735308c8097">
<div class="org-src-container">
<pre class="src src-sehll">
cd /var/lib/docker/overlay2/
du -s ./* | sort -rn | more

oid="40235d8989bfbc6b95cdb5c28c1224728138ce746f0c81ca68a9ef1782f33541"

docker ps -q | xargs docker inspect --format '{{.State.Pid}}, {{.Id}}, {{.Name}}, {{.GraphDriver.Data.WorkDir}}' | grep $oid
docker image ls -q | xargs docker inspect --format '{{.Id}}, {{.RepoTags}}, {{.GraphDriver.Data.LowerDir}}, {{.GraphDriver.Data.UpperDir}}'|grep $oid

# 输出依次为，进程pid、容器ID、容器名、存储work路径，即可确定是哪个容器。


# diff 对应 容器
[root@ip-172-21-39-111 root]# pwd
/var/lib/docker/overlay2/40235d8989bfbc6b95cdb5c28c1224728138ce746f0c81ca68a9ef1782f33541/diff/root
[root@ip-172-21-39-111 root]# du -sh *
1.9G    logs
24K     nacos

# 对应容器中
bash-4.2# cd /root/
bash-4.2# du -sh *
1.9G    logs
24K     nacos
</pre>
</div>
</div>
</div>
</section>
<section id="outline-container-h:8c715c6e-270a-4af0-a2bb-9f0dc89dc0a2" class="outline-2">
<h2 id="h:8c715c6e-270a-4af0-a2bb-9f0dc89dc0a2">镜像加速</h2>
<div class="outline-text-2" id="text-h:8c715c6e-270a-4af0-a2bb-9f0dc89dc0a2">
<p>
临时使用：<br>
</p>
<div class="org-src-container">
<pre class="src src-sh">docker pull dockerpull.com/ikubernetes/demoapp:v2.1
</pre>
</div>

<p>
永久配置：<br>
</p>
<div class="org-src-container">
<pre class="src src-sh">sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &lt;&lt;-<span style="color: #8b2252;">'EOF'</span><span style="color: #ffa54f;">
{
    "registry-mirrors": [
        "https://docker.1ms.run",
        "https://docker.xuanyuan.me",
        "https://doublezonline.cloud",
        "https://dockerpull.com",
        "https://docker.anyhub.us.kg",
        "https://dockerhub.jobcher.com",
        "https://dockerhub.icu",
        "https://docker.awsl9527.cn"
    ]
}
EOF
</span>sudo systemctl daemon-reload &amp;&amp; sudo systemctl restart docker
</pre>
</div>

<p>
Docker 镜像加速列表<br>
</p>
<pre class="example" id="org6710dcc">
doublezonline.cloud
dockerproxy.com 
</pre>
</div>
<div id="outline-container-h:fac0024f-be54-4730-950b-acaec6e7edea" class="outline-3">
<h3 id="h:fac0024f-be54-4730-950b-acaec6e7edea">使用Github Action来拉取docker镜像</h3>
<div class="outline-text-3" id="text-h:fac0024f-be54-4730-950b-acaec6e7edea">
<p>
项目 <a href="https://github.com/wukongdaily/DockerTarBuilder">https://github.com/wukongdaily/DockerTarBuilder</a><br>
</p>

<p>
步骤<br>
</p>
<ul class="org-ul">
<li>fork项目DockerTarBuilder到自己的仓库<br></li>
<li>GitHub Action 来拉取和打包镜像<br>
<ul class="org-ul">
<li>点击 I understand my workflows, go ahead and enable them<br></li>
<li>然后选择对应的平台，填入镜像名，多个镜像用逗号隔开<br></li>
</ul></li>
<li>从 github 上下载压缩包<br></li>
<li>上传到自己的服务器上<br></li>
<li>解压加载镜像到自己的服务器上<br></li>
</ul>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b22222;"># </span><span style="color: #b22222;">&#35299;&#21387;
</span>unzip docker-images-tar.zip

<span style="color: #b22222;"># </span><span style="color: #b22222;">&#20877;&#35299;&#21387;
</span>tar -zxvf x86-64-images.tar.gz

<span style="color: #b22222;"># </span><span style="color: #b22222;">&#23548;&#20837;
</span>docker load -i alpine:latest-amd64.tar

<span style="color: #b22222;"># </span><span style="color: #b22222;">&#26597;&#30475;
</span>docker images ls
</pre>
</div>
</div>
</div>
<div id="outline-container-h:fdca5471-6384-4d4e-9d3a-d5dda0cac3da" class="outline-3">
<h3 id="h:fdca5471-6384-4d4e-9d3a-d5dda0cac3da">利用cloudflare代理DockerHub</h3>
<div class="outline-text-3" id="text-h:fdca5471-6384-4d4e-9d3a-d5dda0cac3da">
<p>
项目：<a href="https://github.com/cmliu/CF-Workers-docker.io">https://github.com/cmliu/CF-Workers-docker.io</a><br>
</p>

<p>
步骤<br>
</p>
<ul class="org-ul">
<li>fork项目到自己的仓库<br></li>
<li>部署方式<br>
<ul class="org-ul">
<li>Pages 方式部署<br></li>
<li>Workers 方式部署<br></li>
</ul></li>
</ul>

<p>
<b>Pages 方式部署</b><br>
</p>
<ul class="org-ul">
<li>打开cloudflare页面<br></li>
<li>点击 Worker和Pages &#x2013;&gt; 概述，点击新建<br>
<ul class="org-ul">
<li>选择 Pages 点击 连接到git<br></li>
<li>选择之前fork到自己仓库的仓库，然后点击 开始设置<br></li>
<li>保存并部署。<br></li>
<li>点击 继续处理项目<br></li>
<li>选择 自定义域 点击 设置自定义域 hub.aa.com，激活域，等待生效<br></li>
</ul></li>
<li>访问域名，会直接被代理到docker hub的主页。<br></li>
<li>修改docker的加速地址<br></li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &lt;&lt;-<span style="color: #8b2252;">'EOF'</span><span style="color: #ffa54f;">
{
  "registry-mirrors": ["https://hub.aa.com"]  # &#35831;&#26367;&#25442;&#20026;&#24744;&#33258;&#24049;&#30340;Worker&#33258;&#23450;&#20041;&#22495;&#21517;
}
EOF
</span>sudo systemctl daemon-reload
sudo systemctl restart docker
</pre>
</div>

<p>
为了防止被封，可以设置变量<br>
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">变量名</th>
<th scope="col" class="org-left">示例</th>
<th scope="col" class="org-left">必填</th>
<th scope="col" class="org-left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">URL302</td>
<td class="org-left"><a href="https://t.me/CMLiussss">https://t.me/CMLiussss</a></td>
<td class="org-left">❌</td>
<td class="org-left">主页302跳转</td>
</tr>

<tr>
<td class="org-left">URL</td>
<td class="org-left"><a href="https://www.baidu.com/">https://www.baidu.com/</a></td>
<td class="org-left">❌</td>
<td class="org-left">主页伪装(设为nginx则伪装为nginx默认页面)</td>
</tr>

<tr>
<td class="org-left">UA</td>
<td class="org-left">netcraft</td>
<td class="org-left">❌</td>
<td class="org-left">支持多元素, 元素之间使用空格或换行作间隔</td>
</tr>
</tbody>
</table>

<p>
如设置URL<br>
</p>
<ul class="org-ul">
<li>点击 Worker和Pages的中项目，打开设置&#x2013;&gt;环境变量<br></li>
<li>添加变量。URL = nginx 保存<br></li>
<li>点击部署，重新部署。<br></li>
<li>再访问你的域名，就会变成nginx的默认页面。但不影响镜像拉取。<br></li>
</ul>


<p>
<b>Workers 方式部署</b><br>
</p>

<ul class="org-ul">
<li>打开cloudflare页面<br></li>
<li>点击 Worker和Pages &#x2013;&gt; 概述，点击wokers<br>
<ul class="org-ul">
<li>点击 创建 Worker<br></li>
<li>设置自己的项目名称。如docker<br></li>
<li>点击 编辑代码<br></li>
<li>直接把 <a href="https://raw.githubusercontent.com/cmliu/CF-Workers-docker.io/main/_worker.js">_worker.js</a> 复制到部署的代码中<br></li>
<li>点击设置&#x2013;&gt;触发器，添加自定义域 hub.aa.com<br></li>
<li>点击设置&#x2013;&gt;变量，URL = nginx<br></li>
</ul></li>
<li>访问你的域名，就会变成nginx的默认页面。但不影响镜像拉取。<br></li>
</ul>
</div>
</div>
<div id="outline-container-h:02e6a941-be62-4487-8902-7652edf3a5df" class="outline-3">
<h3 id="h:02e6a941-be62-4487-8902-7652edf3a5df">nginx反向代理加速docker镜像</h3>
<div class="outline-text-3" id="text-h:02e6a941-be62-4487-8902-7652edf3a5df">
<p>
海外服务器nginx配置<br>
</p>
<div class="org-src-container">
<pre class="src src-sh">server {
        <span style="color: #b22222;">#</span><span style="color: #b22222;">&#21516;&#26102;&#30417;&#21548;80&#21644;443&#31471;&#21475;
</span>        listen     80;
        listen     443 ssl;
        server_name  docker.aa.com;<span style="color: #b22222;"># </span><span style="color: #b22222;">&#38656;&#35201;&#20462;&#25913;&#25104;&#33258;&#24049;&#30340;&#22495;&#21517;
</span>        charset utf-8;

        <span style="color: #a020f0;">if</span> ( $<span style="color: #a0522d;">scheme</span> = <span style="color: #8b2252;">'http'</span> ) {
            <span style="color: #a020f0;">return</span> 302 https://docker.aa.com/;<span style="color: #b22222;"># </span><span style="color: #b22222;">&#38656;&#35201;&#20462;&#25913;&#25104;&#33258;&#24049;&#30340;&#22495;&#21517;
</span>        }

        <span style="color: #b22222;">#</span><span style="color: #b22222;">&#35774;&#32622;&#35777;&#20070;&#37096;&#20998;
</span>        ssl_certificate ssl/fullchain.pem;
        ssl_certificate_key ssl/privkey.pem;
        ssl_ciphers <span style="color: #8b2252;">"EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !RC4"</span>;
        location / {
                    <span style="color: #b22222;"># </span><span style="color: #b22222;">Docker hub &#30340;&#23448;&#26041;&#38236;&#20687;&#20179;&#24211;
</span>                    proxy_pass https://registry-1.docker.io;  
                    proxy_set_header Host registry-1.docker.io;
                    proxy_set_header X-Real-IP $<span style="color: #a0522d;">remote_addr</span>;
                    proxy_set_header X-Forwarded-For $<span style="color: #a0522d;">proxy_add_x_forwarded_for</span>;
                    proxy_set_header X-Forwarded-Proto $<span style="color: #a0522d;">scheme</span>;  
                    <span style="color: #b22222;"># </span><span style="color: #b22222;">&#20851;&#38381;&#32531;&#23384;             
</span>                    proxy_buffering off;
                    <span style="color: #b22222;"># </span><span style="color: #b22222;">&#36716;&#21457;&#35748;&#35777;&#30456;&#20851;
</span>                    proxy_set_header Authorization $<span style="color: #a0522d;">http_authorization</span>;
                    proxy_pass_header  Authorization;
                    <span style="color: #b22222;"># </span><span style="color: #b22222;">&#23545; upstream &#29366;&#24577;&#30721;&#26816;&#26597;&#65292;&#23454;&#29616; error_page &#38169;&#35823;&#37325;&#23450;&#21521;
</span>                    proxy_intercept_errors on;
                    recursive_error_pages on;
                    <span style="color: #b22222;"># </span><span style="color: #b22222;">&#26681;&#25454;&#29366;&#24577;&#30721;&#25191;&#34892;&#23545;&#24212;&#25805;&#20316;&#65292;&#20197;&#19979;&#20026;381&#12289;302&#12289;387&#29366;&#24577;&#30721;&#37117;&#20250;&#35302;&#21457;
</span>                    error_page 301 302 <span style="color: #a0522d;">307</span> = @handle_redirect;
        }
        location @handle_redirect {
                    resolver 8.8.8.8;
                    <span style="color: #483d8b;">set</span> $<span style="color: #a0522d;">saved_redirect_location</span> <span style="color: #8b2252;">'$upstream_http_location'</span>;
                    proxy_pass $<span style="color: #a0522d;">saved_redirect_location</span>;
        }
}
</pre>
</div>


<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b22222;">#</span><span style="color: #b22222;">&#36890;&#36807;&#20195;&#29702;&#25289;&#21462;
</span>docker pull docker.abc.com/library/busybox:latest

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#27491;&#24120;&#25289;&#21462;
</span>sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &lt;&lt;-<span style="color: #8b2252;">'EOF'</span><span style="color: #ffa54f;">
{
  "registry-mirrors": ["https://docker.aa.com"]  # &#35831;&#26367;&#25442;&#20026;&#24744;&#33258;&#24049;&#30340;Worker&#33258;&#23450;&#20041;&#22495;&#21517;
}
EOF
</span>sudo systemctl daemon-reload
sudo systemctl restart docker
</pre>
</div>
</div>
</div>
<div id="outline-container-org6e7d1a5" class="outline-3">
<h3 id="org6e7d1a5">HTTP代理加速docker镜像</h3>
<div class="outline-text-3" id="text-org6e7d1a5">
<p>
海外服务器，安装ss服务和privoxy代理<br>
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b22222;">#</span><span style="color: #b22222;">1 &#23433;&#35013;ss&#26381;&#21153;
</span>yum install python-setuptools &amp;&amp; easy_install pip  
pip install shadowsocks

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21518;&#21488;&#36816;&#34892;&#21363;&#21487;&#65292;&#30417;&#21548;443&#31471;&#21475;
</span>sudo ssserver -p 443 -k password -m rc4-md5 --user nobody -d start  

<span style="color: #b22222;">#</span><span style="color: #b22222;">2 &#23433;&#35013;Privoxy &#23558;socket &#20195;&#29702;&#20026;http
</span>yum install privoxy

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#20462;&#25913;&#25991;&#20214;/etc/privoxy/config 
</span>listen-address  :8118  
enable-remote-toggle  1  
&#28982;&#21518;&#22312;&#25991;&#20214;&#26411;&#23614;&#28155;&#21152;&#65306; &#27880;&#24847;forward-socks5t&#37027;&#19968;&#34892;&#26368;&#21518;&#30340;&#19968;&#20010;&#28857;&#19981;&#35201;&#21024;&#38500;&#20102;
forward-socks5 /  :443 
listen-address  127.0.0.1:8118
forward-socks5t   /     127.0.0.1:1080 .
<span style="color: #b22222;">#</span><span style="color: #b22222;">---
</span>
service privoxy restart  
</pre>
</div>


<p>
本地机器，配置docker<br>
</p>

<p>
在Linux中，要http/https/ftp的代理配置方式很简单，直接配置它们的环境变量就可以。<br>
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #483d8b;">export</span> <span style="color: #a0522d;">http_proxy</span>=http://127.0.0.1:8118
<span style="color: #483d8b;">export</span> <span style="color: #a0522d;">https_proxy</span>=http://127.0.0.1:8118
<span style="color: #483d8b;">export</span> <span style="color: #a0522d;">ftp_proxy</span>=http://127.0.0.1:8118
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#22914;&#26524;&#26576;&#20123;&#22320;&#22336;&#19981;&#24819;&#35201;&#20351;&#29992;&#20195;&#29702;&#65292;&#21487;&#20197;&#37197;&#32622;&#22312;no_proxy&#21464;&#37327;&#19978;&#12290;
</span><span style="color: #483d8b;">export</span> <span style="color: #a0522d;">no_proxy</span>=<span style="color: #8b2252;">'a.test.com,127.0.0.1,2.2.2.2'</span>
</pre>
</div>

<p>
配置docker<br>
</p>
<div class="org-src-container">
<pre class="src src-sh">vi /etc/sysctl.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1

sysctl -p
vim /usr/lib/systemd/system/docker.service
<span style="color: #a0522d;">Environment</span>=<span style="color: #8b2252;">"HTTPS_PROXY=http://docker.xxx.com:8118"</span>
<span style="color: #a0522d;">Environment</span>=<span style="color: #8b2252;">"NO_PROXY=127.0.0.0/8,172.20.0.0/16"</span>

systemctl daemon-reload
systemctl restart docker

<span style="color: #b22222;">#</span><span style="color: #b22222;">&#25289;&#21462;&#27979;&#35797;
</span>docker pull quay.io/calico/cni:v3.2.0
</pre>
</div>
</div>
</div>
</section>
</div>
<div id="postamble" class="status">
    <div class=bar data-astro-cid-p3givckg>
        <div class=list data-astro-cid-p3givckg>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=simple-icons:gnuemacs height=1em viewBox="0 0 24 24" width=1em>
                    <title>emacs</title>
                    <symbol id=ai:simple-icons:gnuemacs>
                        <path d="M12 24C5.448 24 .118 18.617.118 12S5.448 0 12 0s11.882 5.383 11.882 12S18.552 24 12 24zM12 .661C5.813.661.779 5.748.779 12S5.813 23.339 12 23.339S23.221 18.253 23.221 12S18.187.661 12 .661zM8.03 20.197s.978.069 2.236-.042c.51-.045 2.444-.235 3.891-.552c0 0 1.764-.377 2.707-.725c.987-.364 1.524-.673 1.766-1.11c-.011-.09.074-.408-.381-.599c-1.164-.488-2.514-.4-5.185-.457c-2.962-.102-3.948-.598-4.472-.997c-.503-.405-.25-1.526 1.907-2.513c1.086-.526 5.345-1.496 5.345-1.496c-1.434-.709-4.109-1.955-4.659-2.224c-.482-.236-1.254-.591-1.421-1.021c-.19-.413.448-.768.804-.87c1.147-.331 2.766-.536 4.24-.56c.741-.012.861-.059.861-.059c1.022-.17 1.695-.869 1.414-1.976c-.252-1.13-1.579-1.795-2.84-1.565c-1.188.217-4.05 1.048-4.05 1.048c3.539-.031 4.131.028 4.395.398c.156.218-.071.518-1.015.672c-1.027.168-3.163.37-3.163.37c-2.049.122-3.492.13-3.925 1.046c-.283.599.302 1.129.558 1.46c1.082 1.204 2.646 1.853 3.652 2.331c.379.18 1.49.52 1.49.52c-3.265-.18-5.619.823-7.001 1.977c-1.562 1.445-.871 3.168 2.33 4.228c1.891.626 2.828.921 5.648.667c1.661-.09 1.923-.036 1.939.1c.023.192-1.845.669-2.355.816c-1.298.374-4.699 1.129-4.716 1.133z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:simple-icons:gnuemacs></use>
                </svg>
                <div class="content left" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Emacs</p>
                </div>
            </span>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=simple-icons:org height=1em viewBox="0 0 24 24" width=1em>
                    <title>org-mode</title>
                    <symbol id=ai:simple-icons:org>
                        <path d="M17.169 0c-.566.004-2.16 3.312-3.376 5.94a2.19 2.19 0 0 1-.408-1.267c-.03-.582-1.089.237-.936 1.275c-.068-.035-1.26.227-1.26.23c-.23-.93-.802-1.618-1.15-.563c-.701 1.663-.88 2.984.115 4.585c-.908 4.058-6.948 6.053-6.32 9.33c.175.004 1.634 3.48 6.337 2.057c5.557-1.577 8.624 2.116 8.978 2.375c.52.526-1.348-4.573-5.302-6.865c-2.339-1.276-.87-3.474-.703-4.25c0 0 1.874 1.312 3.232-.692c1.227.316 2.05-.224 3.105.158c.64.28 3.336.11 2.334-1.396c-.148.129.07.27-.075.46c-.043.056-.128.232-.408.315c-.314.149-.83.27-1.43-.37c-.434-.32-.748-.04-.992-.063c.152-.098.577-.315 1.264-.315c.388 0 .594.336.854.338c.174 0 .685-.262.787-.365c.63-.41.697-.278 1.012-.905c.17-.759-.215-.92-.332-1.129c-.032-.483-.436-.67-.919-.326c-1.106-.198-2.192-.105-2.728-.15c-1.175-.164-2.153-.786-2.153-.786c.143-.19.075-.6-.842-.628c-.315-.104-.45-.2-.745-.307c.61-1.37.674-2.007 1.418-4.004c.261-1.053 1.039-2.685.643-2.682zm-4.297 8.093c.03-.086.443.138.952.176c.395.03.805.048 1.296-.025c.03-.005.172.095-.15.194c-.02.01-.062-.01-.065.196c0 .022-.01.04-.02.046c-.15.152-.708.223-1.065.1c-.436-.17-.482-.316-.517-.443c-.305-.147-.47-.123-.43-.244zM9.685 10.2C8.86 9 8.929 8.36 8.96 7.256C7.961 8.288 6.855 8.3 5.18 8.58c-1.299.234-3.657 2.447-4.025 4.742c-.043.608-.08 2.183.424 3.498c.492 1.13.828 1.727 1.844 2.335c-.882-3.169 5.296-5.33 6.263-8.955z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:simple-icons:org></use>
                </svg>
                <div class="content left" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Orgmode</p>
                </div>
            </span>
            <a href=/donations.html class=entry data-astro-cid-p3givckg>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=simple-icons:astro height=1em viewBox="0 0 24 24" width=1em>
                    <title>Donations</title>
                    <symbol id=ai:simple-icons:astro>
                        <path d="M8.358 20.162c-1.186-1.07-1.532-3.316-1.038-4.944c.856 1.026 2.043 1.352 3.272 1.535c1.897.283 3.76.177 5.522-.678c.202-.098.388-.229.608-.36c.166.473.209.95.151 1.437c-.14 1.185-.738 2.1-1.688 2.794c-.38.277-.782.525-1.175.787c-1.205.804-1.531 1.747-1.078 3.119l.044.148a3.158 3.158 0 0 1-1.407-1.188a3.31 3.31 0 0 1-.544-1.815c-.004-.32-.004-.642-.048-.958c-.106-.769-.472-1.113-1.161-1.133c-.707-.02-1.267.411-1.415 1.09c-.012.053-.028.104-.045.165h.002zm-5.961-4.445s3.24-1.575 6.49-1.575l2.451-7.565c.092-.366.36-.614.662-.614c.302 0 .57.248.662.614l2.45 7.565c3.85 0 6.491 1.575 6.491 1.575L16.088.727C15.93.285 15.663 0 15.303 0H8.697c-.36 0-.615.285-.784.727l-5.516 14.99z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:simple-icons:astro></use>
                </svg>
                <div class="content left" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>打赏</p>
                </div>
            </span>
            </a>
            <span class=entry data-astro-cid-p3givckg>
                <svg xmlns="http://www.w3.org/2000/svg" class=heading data-astro-cid-p3givckg data-icon=simple-icons:copyright width="1em" height="1em" viewBox="0 0 24 24">
                    <title>Copyright</title>
                    <path fill="currentColor" d="M19 2a3 3 0 0 1 3 3v14a3 3 0 0 1-3 3H5a3 3 0 0 1-3-3V5a3 3 0 0 1 3-3zm-5 5h-4a1 1 0 0 0-1 1l.007.117A1 1 0 0 0 10 9h3v5a1 1 0 0 1-1.993.117L11 14a1 1 0 0 0-2 0a3 3 0 0 0 6 0V8a1 1 0 0 0-1-1" />
                    <use xlink:href=#ai:simple-icons:copyright></use>
                </svg>
                <div class="content left" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>© 2025 Jasper Hsu</p>
                </div>
            </span>
        </div>
        <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ class="list license" data-astro-cid-p3givckg>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=fa6-brands:creative-commons height=1em viewBox="0 0 496 512" width=0.97em>
                    <title>Creative Commons</title>
                    <symbol id=ai:fa6-brands:creative-commons>
                        <path d="m245.83 214.87l-33.22 17.28c-9.43-19.58-25.24-19.93-27.46-19.93c-22.13 0-33.22 14.61-33.22 43.84c0 23.57 9.21 43.84 33.22 43.84c14.47 0 24.65-7.09 30.57-21.26l30.55 15.5c-6.17 11.51-25.69 38.98-65.1 38.98c-22.6 0-73.96-10.32-73.96-77.05c0-58.69 43-77.06 72.63-77.06c30.72-.01 52.7 11.95 65.99 35.86zm143.05 0l-32.78 17.28c-9.5-19.77-25.72-19.93-27.9-19.93c-22.14 0-33.22 14.61-33.22 43.84c0 23.55 9.23 43.84 33.22 43.84c14.45 0 24.65-7.09 30.54-21.26l31 15.5c-2.1 3.75-21.39 38.98-65.09 38.98c-22.69 0-73.96-9.87-73.96-77.05c0-58.67 42.97-77.06 72.63-77.06c30.71-.01 52.58 11.95 65.56 35.86zM247.56 8.05C104.74 8.05 0 123.11 0 256.05c0 138.49 113.6 248 247.56 248c129.93 0 248.44-100.87 248.44-248c0-137.87-106.62-248-248.44-248zm.87 450.81c-112.54 0-203.7-93.04-203.7-202.81c0-105.42 85.43-203.27 203.72-203.27c112.53 0 202.82 89.46 202.82 203.26c-.01 121.69-99.68 202.82-202.84 202.82z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:fa6-brands:creative-commons></use>
                </svg>
                <div class="content right" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Creative Commons</p>
                </div>
            </span>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=fa6-brands:creative-commons-by height=1em viewBox="0 0 496 512" width=0.97em>
                    <title>Attribute</title>
                    <symbol id=ai:fa6-brands:creative-commons-by>
                        <path d="M314.9 194.4v101.4h-28.3v120.5h-77.1V295.9h-28.3V194.4c0-4.4 1.6-8.2 4.6-11.3c3.1-3.1 6.9-4.7 11.3-4.7H299c4.1 0 7.8 1.6 11.1 4.7c3.1 3.2 4.8 6.9 4.8 11.3zm-101.5-63.7c0-23.3 11.5-35 34.5-35s34.5 11.7 34.5 35c0 23-11.5 34.5-34.5 34.5s-34.5-11.5-34.5-34.5zM247.6 8C389.4 8 496 118.1 496 256c0 147.1-118.5 248-248.4 248C113.6 504 0 394.5 0 256C0 123.1 104.7 8 247.6 8zm.8 44.7C130.2 52.7 44.7 150.6 44.7 256c0 109.8 91.2 202.8 203.7 202.8c103.2 0 202.8-81.1 202.8-202.8c.1-113.8-90.2-203.3-202.8-203.3z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:fa6-brands:creative-commons-by></use>
                </svg>
                <div class="content right" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Attribute</p>
                </div>
            </span>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=fa6-brands:creative-commons-nc height=1em viewBox="0 0 496 512" width=0.97em>
                    <title>Noncommercial</title>
                    <symbol id=ai:fa6-brands:creative-commons-nc>
                        <path d="M247.6 8C387.4 8 496 115.9 496 256c0 147.2-118.5 248-248.4 248C113.1 504 0 393.2 0 256C0 123.1 104.7 8 247.6 8zM55.8 189.1c-7.4 20.4-11.1 42.7-11.1 66.9c0 110.9 92.1 202.4 203.7 202.4c122.4 0 177.2-101.8 178.5-104.1l-93.4-41.6c-7.7 37.1-41.2 53-68.2 55.4v38.1h-28.8V368c-27.5-.3-52.6-10.2-75.3-29.7l34.1-34.5c31.7 29.4 86.4 31.8 86.4-2.2c0-6.2-2.2-11.2-6.6-15.1c-14.2-6-1.8-.1-219.3-97.4zM248.4 52.3c-38.4 0-112.4 8.7-170.5 93l94.8 42.5c10-31.3 40.4-42.9 63.8-44.3v-38.1h28.8v38.1c22.7 1.2 43.4 8.9 62 23L295 199.7c-42.7-29.9-83.5-8-70 11.1c53.4 24.1 43.8 19.8 93 41.6l127.1 56.7c4.1-17.4 6.2-35.1 6.2-53.1c0-57-19.8-105-59.3-143.9c-39.3-39.9-87.2-59.8-143.6-59.8z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:fa6-brands:creative-commons-nc></use>
                </svg>
                <div class="content right" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Noncommercial</p>
                </div>
            </span>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=fa6-brands:creative-commons-sa height=1em viewBox="0 0 496 512" width=0.97em>
                    <title>Share Alike</title>
                    <symbol id=ai:fa6-brands:creative-commons-sa>
                        <path d="M247.6 8C389.4 8 496 118.1 496 256c0 147.1-118.5 248-248.4 248C113.6 504 0 394.5 0 256C0 123.1 104.7 8 247.6 8zm.8 44.7C130.2 52.7 44.7 150.6 44.7 256c0 109.8 91.2 202.8 203.7 202.8c103.2 0 202.8-81.1 202.8-202.8c.1-113.8-90.2-203.3-202.8-203.3zM137.7 221c13-83.9 80.5-95.7 108.9-95.7c99.8 0 127.5 82.5 127.5 134.2c0 63.6-41 132.9-128.9 132.9c-38.9 0-99.1-20-109.4-97h62.5c1.5 30.1 19.6 45.2 54.5 45.2c23.3 0 58-18.2 58-82.8c0-82.5-49.1-80.6-56.7-80.6c-33.1 0-51.7 14.6-55.8 43.8h18.2l-49.2 49.2l-49-49.2h19.4z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:fa6-brands:creative-commons-sa></use>
                </svg>
                <div class="content right" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Share Alike</p>
                </div>
            </span>
        </a>
    </div>
<!--
<script type="text/javascript" src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script type="text/javascript" src="https://unpkg.com/@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
<script type="text/javascript" src="https://unpkg.com/bootstrap@5.2.1/dist/js/bootstrap.min.js"></script>
<div id="back-to-top" class=""><svg viewBox="0 0 24 24"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path></svg></div>
-->
</div>
</body>
</html>
