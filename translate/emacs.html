<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>翻译: Emacs 编辑器</title>
<meta name="description" content="emacs手册 中文翻译" />
<meta name="keywords" content="计算机, 编辑器, Emacs" />
<meta name="generator" content="Org Mode" />
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="me" href="https://emacs.ch/@jasperhsu">
<meta name="google-adsense-account" content="ca-pub-1741779893655624">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1741779893655624" crossorigin="anonymous"></script>
<!-- from -->
<!--
<style>#back-to-top{background:#000;-webkit-border-radius:50%;-moz-border-radius:50%;border-radius:50%;bottom:20px;-webkit-box-shadow:0 2px 5px 0 rgba(0,0,0,.26);-moz-box-shadow:0 2px 5px 0 rgba(0,0,0,.26);box-shadow:0 2px 5px 0 rgba(0,0,0,.26);color:#fff;cursor:pointer;display:block;height:56px;opacity:1;outline:0;position:fixed;right:20px;-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none;-webkit-transition:bottom .2s,opacity .2s;-o-transition:bottom .2s,opacity .2s;-moz-transition:bottom .2s,opacity .2s;transition:bottom .2s,opacity .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:56px;z-index:1}#back-to-top svg{display:block;fill:currentColor;height:24px;margin:16px auto 0;width:24px}#back-to-top.hidden{bottom:-56px;opacity:0}</style>
-->
<link rel="stylesheet" href="/static/aandds.com/css/main.css">
<link rel="stylesheet" href="/static/aandds.com/css/drollery.min.css">
<script type="text/javascript" src="/static/aandds.com/js/main.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">翻译: Emacs 编辑器</h1>
</header><ul class="org-ul">
<li>TAGS: <a href="./index-emacs.html">Emacs</a></li>
</ul>

<p>
[ 最后修订与导出时间： <b>2026-02-16 13:35:12 +0800</b>  ，总字数： <b>127452</b> ]
</p>

<p>
<a href="https://www.gnu.org/software/emacs/manual/">GNU Emacs 在线手册</a>
</p>


<p>
Emacs 是一款功能先进、可扩展、可定制且自带文档的编辑器。本手册详细介绍 Emacs 的编辑使用方法及部分定制技巧，对应 GNU Emacs 30.2 版本。
</p>

<p>
GNU Emacs 官方网站：<a href="https://www.gnu.org/software/emacs/">https://www.gnu.org/software/emacs/</a>
</p>

<p>
如需查看其他格式的手册，请点击<a href="https://www.gnu.org/software/emacs/manual/emacs.html">此处</a>。
</p>

<p>
您也可通过自由软件基金会<a href="https://shop.fsf.org/product/emacs-manual/">FSF商店</a>购买纸质版本。
</p>

<p>
有关 Emacs 扩展开发的详细信息，请参阅《Emacs Lisp 参考手册》中的 “<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/index.html#Top">Emacs Lisp</a>” 章节。
</p>

<p>
本文档为《GNU Emacs 手册》，已更新至 Emacs 30.2 版本。
</p>

<p>
版权所有 © 1985–2025 自由软件基金会（Free Software Foundation, Inc.）
</p>

<blockquote>
<p>
您可以根据 GNU 自由文档许可证（GNU Free Documentation License）1.3 版或自由软件基金会发布的任何后续版本的条款，复制、分发和 / 或修改本文档；其中 “不可修改章节”（Invariant Sections）为《GNU 宣言》（The GNU Manifesto）、《发行条款》（Distribution）和《GNU 通用公共许可证》（GNU GENERAL PUBLIC LICENSE），“封面文字”（Front-Cover Texts）为 “一份 GNU 手册”（A GNU Manual），“封底文字”（Back-Cover Texts）如下（a）项所示。完整的许可证文本包含在标题为 “GNU 自由文档许可证”（GNU Free Documentation License）的章节中。
</p>

<p>
（a）自由软件基金会（FSF）的封底文字为：“您拥有复制和修改本 GNU 手册的自由。通过 FSF 购买副本将支持我们开发 GNU 软件并推广软件自由。”
</p>
</blockquote>

<nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#Distrib">发行说明</a></li>
<li><a href="#Intro">引言</a></li>
<li><a href="#Screen">1. 屏幕布局</a>
<ul>
<li><a href="#Point">1.1. 光标位置（Point）</a></li>
<li><a href="#Echo-Area">1.2. 回显区（Echo Area）</a></li>
<li><a href="#Mode-Line">1.3. 模式行（Mode Line）</a></li>
<li><a href="#Menu-Bar">1.4. 菜单栏（Menu Bar）</a></li>
</ul>
</li>
<li><a href="#User-Input">2. 用户输入类型</a></li>
<li><a href="#Keys">3. 按键（Keys）</a></li>
<li><a href="#Mouse-Input">4. 鼠标输入</a></li>
<li><a href="#Commands">5. 按键与命令</a></li>
<li><a href="#Other-Input">6. 触摸屏输入与虚拟键盘</a>
<ul>
<li><a href="#Touchscreens">6.1. 触摸屏上使用 Emacs</a></li>
<li><a href="#On_002dScreen-Keyboards">6.2. 搭配虚拟键盘使用 Emacs</a></li>
</ul>
</li>
<li><a href="#Entering-Emacs">7. 启动 Emacs</a></li>
<li><a href="#Exiting">8. 退出 Emacs</a></li>
<li><a href="#Basic">9. 基本编辑命令</a>
<ul>
<li><a href="#Inserting-Text">9.1. 插入文本</a></li>
<li><a href="#Moving-Point">9.2. 更改光标位置</a></li>
<li><a href="#Erasing">9.3. 删除文本</a></li>
<li><a href="#Basic-Undo">9.4. 撤销更改</a></li>
<li><a href="#Basic-Files">9.5. 文件操作</a></li>
<li><a href="#Basic-Help">9.6. 帮助功能</a></li>
<li><a href="#Blank-Lines">9.7. 空行处理</a></li>
<li><a href="#Continuation-Lines">9.8. 续行（Continuation Lines）</a></li>
<li><a href="#Position-Info">9.9. 光标位置信息</a></li>
<li><a href="#Arguments">9.10. 数字参数（Numeric Arguments）</a></li>
<li><a href="#Repeating">9.11. 重复执行命令</a></li>
</ul>
</li>
<li><a href="#Minibuffer">10. 迷你缓冲区（Minibuffer）</a>
<ul>
<li><a href="#Basic-Minibuffer">10.1. 使用迷你缓冲区</a></li>
<li><a href="#Minibuffer-File">10.2. 文件名专用迷你缓冲区</a></li>
<li><a href="#Minibuffer-Edit">10.3. 迷你缓冲区中的编辑操作</a></li>
<li><a href="#Completion">10.4. 自动补全（Completion）</a>
<ul>
<li><a href="#Completion-Example">10.4.1. 补全示例</a></li>
<li><a href="#Completion-Commands">10.4.2. 补全命令</a></li>
<li><a href="#Completion-Exit">10.4.3. 补全退出</a></li>
<li><a href="#Completion-Styles">10.4.4. 补全候选的选择规则</a></li>
<li><a href="#Completion-Options">10.4.5. 补全选项</a></li>
</ul>
</li>
<li><a href="#Minibuffer-History">10.5. 迷你缓冲区历史记录</a></li>
<li><a href="#Repetition">10.6. 重复执行迷你缓冲区命令</a></li>
<li><a href="#Passwords">10.7. 输入密码</a></li>
<li><a href="#Yes-or-No-Prompts">10.8. 确认提示（Yes or No Prompts）</a></li>
</ul>
</li>
<li><a href="#M_002dx">11. 通过名称执行命令</a></li>
<li><a href="#Help">12. 帮助功能</a>
<ul>
<li><a href="#Help-Summary">12.1. 帮助摘要</a></li>
<li><a href="#Key-Help">12.2. 按键相关文档</a></li>
<li><a href="#Name-Help">12.3. 按命令或变量名查询帮助</a></li>
<li><a href="#Apropos">12.4. 关键词检索帮助（Apropos）</a></li>
<li><a href="#Help-Mode">12.5. 帮助模式命令</a></li>
<li><a href="#Package-Keywords">12.6. 软件包关键词搜索</a></li>
<li><a href="#Language-Help">12.7. 国际语言支持相关帮助</a></li>
<li><a href="#Misc-Help">12.8. 其他帮助命令</a></li>
<li><a href="#Help-Files">12.9. 帮助文件</a></li>
<li><a href="#Help-Echo">12.10. 活动文本与工具提示帮助</a></li>
</ul>
</li>
<li><a href="#Mark">13. 标记与区域（Mark and Region）</a>
<ul>
<li><a href="#Setting-Mark">13.1. 设置标记</a></li>
<li><a href="#Marking-Objects">13.2. 标记文本对象的命令</a></li>
<li><a href="#Using-Region">13.3. 对区域执行操作</a></li>
<li><a href="#Mark-Ring">13.4. 标记环（Mark Ring）</a></li>
<li><a href="#Global-Mark-Ring">13.5. 全局标记环（Global Mark Ring）</a></li>
<li><a href="#Shift-Selection">13.6. 移位选择（Shift Selection）</a></li>
<li><a href="#Disabled-Transient-Mark">13.7. 禁用瞬时标记模式（Disabling Transient Mark Mode）</a></li>
</ul>
</li>
<li><a href="#Killing">14. 剪切与移动文本（Killing and Moving Text）</a>
<ul>
<li><a href="#Deletion-and-Killing">14.1. 删除与剪切</a>
<ul>
<li><a href="#Deletion">14.1.1. 删除操作</a></li>
<li><a href="#Killing-by-Lines">14.1.2. 按行剪切</a></li>
<li><a href="#Other-Kill-Commands">14.1.3. 其他剪切命令</a></li>
<li><a href="#Kill-Options">14.1.4. 剪切相关选项</a></li>
</ul>
</li>
<li><a href="#Yanking">14.2. 粘贴（Yanking）</a>
<ul>
<li><a href="#Kill-Ring">14.2.1. 剪切环（Kill Ring）</a></li>
<li><a href="#Earlier-Kills">14.2.2. 粘贴之前的剪切内容</a></li>
<li><a href="#Appending-Kills">14.2.3. 追加剪切内容（Appending Kills）</a></li>
</ul>
</li>
<li><a href="#Cut-and-Paste">14.3. 图形界面中的 “复制 - 粘贴” 操作</a>
<ul>
<li><a href="#Clipboard">14.3.1. 使用剪贴板</a></li>
<li><a href="#Primary-Selection">14.3.2. 与其他窗口应用程序的复制 - 粘贴</a></li>
<li><a href="#Secondary-Selection">14.3.3. 次要选择（Secondary Selection）</a></li>
</ul>
</li>
<li><a href="#Accumulating-Text">14.4. 文本累积（Accumulating Text）</a></li>
<li><a href="#Rectangles">14.5. 矩形操作（Rectangles）</a></li>
<li><a href="#CUA-Bindings">14.6. CUA 键绑定（CUA Bindings）</a></li>
</ul>
</li>
<li><a href="#Registers">15. 寄存器（Registers）</a>
<ul>
<li><a href="#Position-Registers">15.1. 在寄存器中保存位置</a></li>
<li><a href="#Text-Registers">15.2. 在寄存器中保存文本</a></li>
<li><a href="#Rectangle-Registers">15.3. 在寄存器中保存矩形</a></li>
<li><a href="#Configuration-Registers">15.4. 在寄存器中保存窗口与框架配置</a></li>
<li><a href="#Number-Registers">15.5. 在寄存器中存储数字</a></li>
<li><a href="#File-and-Buffer-Registers">15.6. 在寄存器中存储文件与缓冲区名称</a></li>
<li><a href="#Keyboard-Macro-Registers">15.7. 键盘宏寄存器（Keyboard Macro Registers）</a></li>
<li><a href="#Bookmarks">15.8. 书签（Bookmarks）</a></li>
</ul>
</li>
<li><a href="#Display">16. 显示控制</a>
<ul>
<li><a href="#Scrolling">16.1. 滚动操作</a></li>
<li><a href="#Recentering">16.2. 居中显示（Recentering）</a></li>
<li><a href="#Auto-Scrolling">16.3. 自动滚动</a></li>
<li><a href="#Horizontal-Scrolling">16.4. 水平滚动</a></li>
<li><a href="#Narrowing">16.5. 窄化显示（Narrowing）</a></li>
<li><a href="#View-Mode">16.6. 查看模式（View Mode）</a></li>
<li><a href="#Follow-Mode">16.7. 跟随模式（Follow Mode）</a></li>
<li><a href="#Faces">16.8. 文本外观（Text Faces）</a></li>
<li><a href="#Colors">16.9. 外观颜色设置</a>
<ul>
<li><a href="#Color-Names">16.9.1. 颜色名称</a></li>
<li><a href="#RGB-Triplets">16.9.2. RGB 三元组（RGB Triplets）</a></li>
</ul>
</li>
<li><a href="#Standard-Faces">16.10. 标准外观（Standard Faces）</a></li>
<li><a href="#Icons">16.11. 图标（Icons）</a></li>
<li><a href="#Text-Scale">16.12. 文本缩放（Text Scale）</a></li>
<li><a href="#Font-Lock">16.13. 字体锁定模式（Font Lock mode）</a>
<ul>
<li><a href="#Traditional-Font-Lock">16.13.1. 传统字体锁定</a></li>
<li><a href="#Parser_002dbased-Font-Lock">16.13.2. 基于解析器的字体锁定</a></li>
</ul>
</li>
<li><a href="#Highlight-Interactively">16.14. 交互式高亮（Interactive Highlighting）</a></li>
<li><a href="#Fringes">16.15. 窗口边缘（Window Fringes）</a></li>
<li><a href="#Displaying-Boundaries">16.16. 边界显示（Displaying Boundaries）</a></li>
<li><a href="#Useless-Whitespace">16.17. 无用空白字符（Useless Whitespace）</a></li>
<li><a href="#Selective-Display">16.18. 选择性显示（Selective Display）</a></li>
<li><a href="#Optional-Mode-Line">16.19. 模式行可选功能</a></li>
<li><a href="#Text-Display">16.20. 文本显示方式</a></li>
<li><a href="#Cursor-Display">16.21. 光标显示（Displaying the Cursor）</a></li>
<li><a href="#Line-Truncation">16.22. 行截断（Line Truncation）</a></li>
<li><a href="#Visual-Line-Mode">16.23. 视觉行模式（Visual Line Mode）</a></li>
<li><a href="#Display-Custom">16.24. 显示定制（Customization of Display）</a></li>
</ul>
</li>
<li><a href="#Search">17. 搜索与替换</a>
<ul>
<li><a href="#Incremental-Search">17.1. 增量搜索（Incremental Search）</a>
<ul>
<li><a href="#Basic-Isearch">17.1.1. 增量搜索基础</a></li>
<li><a href="#Repeat-Isearch">17.1.2. 重复增量搜索</a></li>
<li><a href="#Isearch-Yank">17.1.3. 增量搜索中的粘贴（Isearch Yanking）</a></li>
<li><a href="#Error-in-Isearch">17.1.4. 增量搜索错误处理</a></li>
<li><a href="#Special-Isearch">17.1.5. 增量搜索的特殊输入</a></li>
<li><a href="#Not-Exiting-Isearch">17.1.6. 不退出增量搜索</a></li>
<li><a href="#Isearch-Minibuffer">17.1.7. 迷你缓冲区搜索</a></li>
</ul>
</li>
<li><a href="#Nonincremental-Search">17.2. 非增量搜索（Nonincremental Search）</a></li>
<li><a href="#Word-Search">17.3. 单词搜索（Word Search）</a></li>
<li><a href="#Symbol-Search">17.4. 符号搜索（Symbol Search）</a></li>
<li><a href="#Regexp-Search">17.5. 正则表达式搜索（Regular Expression Search）</a></li>
<li><a href="#Regexps">17.6. 正则表达式语法</a></li>
<li><a href="#Regexp-Backslash">17.7. 正则表达式中的反斜杠</a></li>
<li><a href="#Regexp-Example">17.8. 正则表达式示例</a></li>
<li><a href="#Lax-Search">17.9. 搜索中的宽松匹配（Lax Matching During Searching）</a></li>
<li><a href="#Replace">17.10. 替换命令</a>
<ul>
<li><a href="#Unconditional-Replace">17.10.1. 无条件替换</a></li>
<li><a href="#Regexp-Replace">17.10.2. 正则表达式替换</a></li>
<li><a href="#Replacement-and-Lax-Matches">17.10.3. 替换命令与宽松匹配</a></li>
<li><a href="#Query-Replace">17.10.4. 查询替换（Query Replace）</a></li>
</ul>
</li>
<li><a href="#Other-Repeating-Search">17.11. 其他搜索与循环命令</a></li>
<li><a href="#Search-Customizations">17.12. 根据需求定制搜索</a></li>
</ul>
</li>
<li><a href="#Fixit">18. 拼写错误修正命令</a>
<ul>
<li><a href="#Undo">18.1. 撤销（Undo）</a></li>
<li><a href="#Transpose">18.2. 文本交换（Transposing Text）</a></li>
<li><a href="#Fixing-Case">18.3. 大小写转换（Case Conversion）</a></li>
<li><a href="#Spelling">18.4. 拼写检查与修正</a></li>
</ul>
</li>
<li><a href="#Keyboard-Macros">19. 键盘宏（Keyboard Macros）</a>
<ul>
<li><a href="#Basic-Keyboard-Macro">19.1. 基本使用</a></li>
<li><a href="#Keyboard-Macro-Ring">19.2. 键盘宏环（Keyboard Macro Ring）</a></li>
<li><a href="#Keyboard-Macro-Counter">19.3. 键盘宏计数器</a></li>
<li><a href="#Keyboard-Macro-Query">19.4. 带变量的宏执行（Executing Macros with Variations）</a></li>
<li><a href="#Save-Keyboard-Macro">19.5. 键盘宏的命名与保存</a></li>
<li><a href="#Edit-Keyboard-Macro">19.6. 编辑键盘宏</a></li>
<li><a href="#Keyboard-Macro-Step_002dEdit">19.7. 逐步编辑键盘宏（Stepwise Editing a Keyboard Macro）</a></li>
<li><a href="#Kmacro-Menu">19.8. 列出与编辑键盘宏</a></li>
</ul>
</li>
<li><a href="#Files">20. 文件处理</a>
<ul>
<li><a href="#File-Names">20.1. 文件名</a></li>
<li><a href="#Visiting">20.2. 打开文件（Visiting Files）</a></li>
<li><a href="#Saving">20.3. 保存文件</a>
<ul>
<li><a href="#Save-Commands">20.3.1. 保存文件命令</a></li>
<li><a href="#Backup">20.3.2. 备份文件（Backup Files）</a>
<ul>
<li><a href="#Backup-Names">20.3.2.1. 单一备份或编号备份</a></li>
<li><a href="#Backup-Deletion">20.3.2.2. 备份文件的自动删除</a></li>
<li><a href="#Backup-Copying">20.3.2.3. 复制备份与重命名备份</a></li>
</ul>
</li>
<li><a href="#Customize-Save">20.3.3. 文件保存定制</a></li>
<li><a href="#Interlocking">20.3.4. 防止同时编辑冲突</a></li>
<li><a href="#File-Shadowing">20.3.5. 文件影子（Shadowing Files）</a></li>
<li><a href="#Time-Stamps">20.3.6. 自动更新时间戳</a>
<ul>
<li><a href="#Time-Stamp-Customization">20.3.6.1. 时间戳定制</a></li>
<li><a href="#Time-Stamps-for-One-File">20.3.6.2. 强制单个文件的时间戳更新</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Reverting">20.4. 恢复缓冲区（Reverting a Buffer）</a></li>
<li><a href="#Auto-Revert">20.5. 自动恢复：保持缓冲区自动更新（Auto Revert）</a>
<ul>
<li><a href="#Non_002dFile-Buffers">20.5.1. 非文件缓冲区的自动恢复</a>
<ul>
<li><a href="#Auto-Reverting-the-Buffer-Menu">20.5.1.1. 缓冲区菜单的自动恢复</a></li>
<li><a href="#Auto-Reverting-Dired">20.5.1.2. Dired 缓冲区的自动恢复</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Auto-Save">20.6. 自动保存：防止数据丢失（Auto-Saving）</a>
<ul>
<li><a href="#Auto-Save-Files">20.6.1. 自动保存文件</a></li>
<li><a href="#Auto-Save-Control">20.6.2. 自动保存控制</a></li>
<li><a href="#Recover">20.6.3. 从自动保存文件恢复数据</a></li>
</ul>
</li>
<li><a href="#File-Aliases">20.7. 文件名别名（File Name Aliases）</a></li>
<li><a href="#Directories">20.8. 文件目录（File Directories）</a></li>
<li><a href="#Comparing-Files">20.9. 文件比较</a></li>
<li><a href="#Diff-Mode">20.10. 差异模式</a></li>
<li><a href="#Copying-and-Naming">20.11. 文件的复制、命名与重命名</a></li>
<li><a href="#Misc-File-Ops">20.12. 各类文件操作</a></li>
<li><a href="#Compressed-Files">20.13. 访问压缩文件</a></li>
<li><a href="#File-Archives">20.14. 文件归档包</a></li>
<li><a href="#Remote-Files">20.15. 远程文件</a></li>
<li><a href="#Quoted-File-Names">20.16. 带引用的文件名</a></li>
<li><a href="#File-Name-Cache">20.17. 文件名缓存</a></li>
<li><a href="#File-Conveniences">20.18. 查找文件的便捷功能</a></li>
<li><a href="#Image-Mode">20.19. 查看图像文件</a></li>
<li><a href="#Filesets">20.20. 文件集（Filesets）</a></li>
</ul>
</li>
<li><a href="#Buffers">21. 多缓冲区的使用</a>
<ul>
<li><a href="#Select-Buffer">21.1. 创建与选择缓冲区</a></li>
<li><a href="#List-Buffers">21.2. 列出已有缓冲区</a></li>
<li><a href="#Misc-Buffer">21.3. 缓冲区的各类杂项操作</a></li>
<li><a href="#Kill-Buffer">21.4. 关闭缓冲区</a></li>
<li><a href="#Several-Buffers">21.5. 对多个缓冲区执行批量操作</a></li>
<li><a href="#Indirect-Buffers">21.6. 间接缓冲区</a></li>
<li><a href="#Buffer-Convenience">21.7. 缓冲区操作的便捷功能与相关定制</a>
<ul>
<li><a href="#Uniquify">21.7.1. 让缓冲区名称唯一化</a></li>
<li><a href="#Icomplete">21.7.2. 迷你缓冲区快速选择（方式）</a></li>
<li><a href="#Buffer-Menus">21.7.3. 定制缓冲区菜单</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Windows">22. 多窗口</a>
<ul>
<li><a href="#Basic-Window">22.1. Emacs 窗口的概念</a></li>
<li><a href="#Split-Window">22.2. 拆分窗口</a></li>
<li><a href="#Other-Window">22.3. 使用其他窗口</a></li>
<li><a href="#Pop-Up-Window">22.4. 在另一窗口中显示内容</a></li>
<li><a href="#Change-Window">22.5. 删除与调整窗口大小</a></li>
<li><a href="#Displaying-Buffers">22.6. 在窗口中显示缓冲区</a>
<ul>
<li><a href="#Window-Choice">22.6.1. display-buffer 函数的工作原理</a></li>
<li><a href="#Temporary-Displays">22.6.2. 显示不可编辑缓冲区</a></li>
</ul>
</li>
<li><a href="#Window-Convenience">22.7. 窗口操作的便捷功能</a></li>
<li><a href="#Tab-Line">22.8. 窗口标签栏</a></li>
<li><a href="#Window-Tool-Bar">22.9. 窗口工具栏</a></li>
</ul>
</li>
<li><a href="#Frames">23. 框架与图形界面</a>
<ul>
<li><a href="#Mouse-Commands">23.1. 编辑相关的鼠标命令</a></li>
<li><a href="#Word-and-Line-Mouse">23.2. 针对单词与行的鼠标命令</a></li>
<li><a href="#Mouse-References">23.3. 用鼠标跟随引用链接</a></li>
<li><a href="#Menu-Mouse-Clicks">23.4. 菜单相关的鼠标点击操作</a></li>
<li><a href="#Mode-Line-Mouse">23.5. 模式行鼠标命令</a></li>
<li><a href="#Creating-Frames">23.6. 创建框架</a></li>
<li><a href="#Frame-Commands">23.7. 框架命令</a></li>
<li><a href="#Fonts">23.8. 字体设置</a></li>
<li><a href="#Speedbar">23.9. 速览栏框架</a></li>
<li><a href="#Multiple-Displays">23.10. 多显示器支持</a></li>
<li><a href="#Frame-Parameters">23.11. 框架参数</a></li>
<li><a href="#Scroll-Bars">23.12. 滚动条</a></li>
<li><a href="#Window-Dividers">23.13. 窗口分隔线</a></li>
<li><a href="#Drag-and-Drop">23.14. 拖放功能</a></li>
<li><a href="#Menu-Bars">23.15. 菜单栏</a></li>
<li><a href="#Tool-Bars">23.16. 工具栏</a></li>
<li><a href="#Tab-Bars">23.17. 标签栏</a></li>
<li><a href="#Dialog-Boxes">23.18. 使用对话框</a></li>
<li><a href="#Tooltips">23.19. 工具提示</a></li>
<li><a href="#Mouse-Avoidance">23.20. 鼠标避让功能</a></li>
<li><a href="#Text-Terminals">23.21. 文本终端</a></li>
<li><a href="#Text_002dOnly-Mouse">23.22. 文本终端中的鼠标使用</a></li>
</ul>
</li>
<li><a href="#International">24. 国际字符集支持</a>
<ul>
<li><a href="#International-Chars">24.1. 国际字符集简介</a></li>
<li><a href="#Language-Environments">24.2. 语言环境</a></li>
<li><a href="#Input-Methods">24.3. 输入方法</a></li>
<li><a href="#Select-Input-Method">24.4. 选择输入方法</a></li>
<li><a href="#Coding-Systems">24.5. 编码系统</a></li>
<li><a href="#Recognize-Coding">24.6. 编码系统识别</a></li>
<li><a href="#Specify-Coding">24.7. 指定文件的编码系统</a></li>
<li><a href="#Output-Coding">24.8. 为输出选择编码系统</a></li>
<li><a href="#Text-Coding">24.9. 为文件文本指定编码系统</a></li>
<li><a href="#Communication-Coding">24.10. 进程间通信的编码系统</a></li>
<li><a href="#File-Name-Coding">24.11. 文件名的编码系统</a></li>
<li><a href="#X-Coding">24.12. X 键盘输入的编码系统</a></li>
<li><a href="#Terminal-Coding">24.13. 终端 I/O 的编码系统</a></li>
<li><a href="#Fontsets">24.14. 字体集</a></li>
<li><a href="#Defining-Fontsets">24.15. 定义字体集</a></li>
<li><a href="#Modifying-Fontsets">24.16. 修改字体集</a></li>
<li><a href="#Undisplayable-Characters">24.17. 无法显示的字符</a></li>
<li><a href="#Unibyte-Mode">24.18. 单字节编辑模式</a></li>
<li><a href="#Charsets">24.19. 字符集</a></li>
<li><a href="#Bidirectional-Editing">24.20. 双向编辑</a></li>
</ul>
</li>
<li><a href="#Modes">25. 主模式与次模式</a>
<ul>
<li><a href="#Major-Modes">25.1. 主模式</a></li>
<li><a href="#Minor-Modes">25.2. 次模式</a></li>
<li><a href="#Choosing-Modes">25.3. 选择文件模式</a></li>
</ul>
</li>
<li><a href="#Indentation">26. 缩进</a>
<ul>
<li><a href="#Indentation-Commands">26.1. 缩进命令</a></li>
<li><a href="#Tab-Stops">26.2. 制表位</a></li>
<li><a href="#Just-Spaces">26.3. 制表符与空格的选择</a></li>
<li><a href="#Indent-Convenience">26.4. 缩进的便捷功能</a></li>
<li><a href="#Code-Alignment">26.5. 代码对齐</a></li>
</ul>
</li>
<li><a href="#Text">27. 自然语言相关命令</a>
<ul>
<li><a href="#Words">27.1. 单词操作</a></li>
<li><a href="#Sentences">27.2. 句子操作</a></li>
<li><a href="#Paragraphs">27.3. 段落操作</a></li>
<li><a href="#Pages">27.4. 页面操作</a></li>
<li><a href="#Quotation-Marks">27.5. 引号处理</a></li>
<li><a href="#Filling">27.6. 文本填充</a>
<ul>
<li><a href="#Auto-Fill">27.6.1. 自动填充模式</a></li>
<li><a href="#Fill-Commands">27.6.2. 显式填充命令</a></li>
<li><a href="#Fill-Prefix">27.6.3. 填充前缀</a></li>
<li><a href="#Adaptive-Fill">27.6.4. 自适应填充</a></li>
</ul>
</li>
<li><a href="#Case">27.7. 大小写转换命令</a></li>
<li><a href="#Text-Mode">27.8. 文本模式</a></li>
<li><a href="#Outline-Mode">27.9. 大纲模式</a>
<ul>
<li><a href="#Outline-Minor-Mode">27.9.1. 大纲次模式</a></li>
<li><a href="#Outline-Format">27.9.2. 大纲格式</a></li>
<li><a href="#Outline-Motion">27.9.3. 大纲移动命令</a></li>
<li><a href="#Outline-Visibility">27.9.4. 大纲可见性命令</a></li>
<li><a href="#Outline-Views">27.9.5. 多视图查看单个大纲</a></li>
<li><a href="#Foldout">27.9.6. 折叠编辑</a></li>
</ul>
</li>
<li><a href="#Org-Mode">27.10. 组织模式（Org Mode）</a>
<ul>
<li><a href="#Org-Organizer">27.10.1. 作为事务管理器的 Org 模式</a></li>
<li><a href="#Org-Authoring">27.10.2. 作为创作系统的 Org 模式</a></li>
</ul>
</li>
<li><a href="#TeX-Mode">27.11. TeX 模式</a>
<ul>
<li><a href="#TeX-Editing">27.11.1. TeX 编辑命令</a></li>
<li><a href="#LaTeX-Editing">27.11.2. LaTeX 编辑命令</a></li>
<li><a href="#TeX-Print">27.11.3. TeX 打印命令</a></li>
<li><a href="#TeX-Misc">27.11.4. TeX 模式杂项功能</a></li>
</ul>
</li>
<li><a href="#HTML-Mode">27.12. SGML 与 HTML 模式</a></li>
<li><a href="#Nroff-Mode">27.13. Nroff 模式</a></li>
<li><a href="#Enriched-Text">27.14. 富文本</a>
<ul>
<li><a href="#Enriched-Mode">27.14.1. 富文本模式</a></li>
<li><a href="#Hard-and-Soft-Newlines">27.14.2. 硬换行与软换行</a></li>
<li><a href="#Editing-Format-Info">27.14.3. 格式信息编辑</a></li>
<li><a href="#Enriched-Faces">27.14.4. 富文本中的外观样式</a></li>
<li><a href="#Enriched-Indentation">27.14.5. 富文本中的缩进</a></li>
<li><a href="#Enriched-Justification">27.14.6. 富文本中的对齐方式</a></li>
<li><a href="#Enriched-Properties">27.14.7. 设置其他文本属性</a></li>
</ul>
</li>
<li><a href="#Text-Based-Tables">27.15. 文本表格编辑</a>
<ul>
<li><a href="#Table-Definition">27.15.1. 什么是文本表格？</a></li>
<li><a href="#Table-Creation">27.15.2. 创建表格</a></li>
<li><a href="#Table-Recognition">27.15.3. 表格识别</a></li>
<li><a href="#Cell-Commands">27.15.4. 表格单元格操作命令</a></li>
<li><a href="#Cell-Justification">27.15.5. 单元格对齐方式</a></li>
<li><a href="#Table-Rows-and-Columns">27.15.6. 表格行与列操作</a></li>
<li><a href="#Table-Conversion">27.15.7. 纯文本与表格的相互转换</a></li>
<li><a href="#Table-Misc">27.15.8. 表格杂项功能</a></li>
</ul>
</li>
<li><a href="#Two_002dColumn">27.16. 双列编辑</a></li>
</ul>
</li>
<li><a href="#Programs">28. 程序编辑</a>
<ul>
<li><a href="#Program-Modes">28.1. 编程语言相关主模式</a></li>
<li><a href="#Defuns">28.2. 顶层定义（或函数定义）</a>
<ul>
<li><a href="#Left-Margin-Paren">28.2.1. 左边距约定</a></li>
<li><a href="#Moving-by-Defuns">28.2.2. 按函数定义移动</a></li>
<li><a href="#Moving-by-Sentences">28.2.3. 按句子移动</a></li>
<li><a href="#Imenu">28.2.4. 索引菜单（Imenu）</a></li>
<li><a href="#Which-Function">28.2.5. 函数定位模式</a></li>
</ul>
</li>
<li><a href="#Program-Indent">28.3. 程序缩进</a>
<ul>
<li><a href="#Basic-Indent">28.3.1. 基本程序缩进命令</a></li>
<li><a href="#Multi_002dline-Indent">28.3.2. 多行缩进</a></li>
<li><a href="#Lisp-Indent">28.3.3. 定制 Lisp 缩进</a></li>
<li><a href="#C-Indent">28.3.4. C 语言缩进命令</a></li>
<li><a href="#Custom-C-Indent">28.3.5. 定制 C 语言缩进</a></li>
</ul>
</li>
<li><a href="#Parentheses">28.4. 括号编辑相关命令</a>
<ul>
<li><a href="#Expressions">28.4.1. 配对括号的表达式</a></li>
<li><a href="#Moving-by-Parens">28.4.2. 括号结构内的光标移动</a></li>
<li><a href="#Matching">28.4.3. 括号匹配</a></li>
</ul>
</li>
<li><a href="#Comments">28.5. 注释处理</a>
<ul>
<li><a href="#Comment-Commands">28.5.1. 注释命令</a></li>
<li><a href="#Multi_002dLine-Comments">28.5.2. 多行注释</a></li>
<li><a href="#Options-for-Comments">28.5.3. 控制注释的相关选项</a></li>
</ul>
</li>
<li><a href="#Documentation">28.6. 文档查阅</a>
<ul>
<li><a href="#Info-Lookup">28.6.1. Info 文档查阅</a></li>
<li><a href="#Man-Page">28.6.2. 手册页查阅</a></li>
<li><a href="#Programming-Language-Doc">28.6.3. 编程语言文档查阅</a></li>
</ul>
</li>
<li><a href="#Hideshow">28.7. 代码折叠次模式</a></li>
<li><a href="#Symbol-Completion">28.8. 符号名称补全</a></li>
<li><a href="#MixedCase-Words">28.9. 混合大小写单词处理</a></li>
<li><a href="#Semantic">28.10. 语义分析（Semantic）</a></li>
<li><a href="#Misc-for-Programs">28.11. 其他程序编辑实用功能</a></li>
<li><a href="#C-Modes">28.12. C 语言及相关模式</a>
<ul>
<li><a href="#Motion-in-C">28.12.1. C 模式移动命令</a></li>
<li><a href="#Electric-C">28.12.2. C 语言自动缩进字符</a></li>
<li><a href="#Hungry-Delete">28.12.3. C 模式中的贪婪删除功能</a></li>
<li><a href="#Other-C-Commands">28.12.4. C 模式的其他命令</a></li>
</ul>
</li>
<li><a href="#Asm-Mode">28.13. 汇编语言模式</a></li>
<li><a href="#Fortran">28.14. Fortran 模式</a>
<ul>
<li><a href="#Fortran-Motion">28.14.1. 移动命令</a></li>
<li><a href="#Fortran-Indent">28.14.2. Fortran 缩进</a>
<ul>
<li><a href="#ForIndent-Commands">28.14.2.1. Fortran 缩进与填充命令</a></li>
<li><a href="#ForIndent-Cont">28.14.2.2. 续行</a></li>
<li><a href="#ForIndent-Num">28.14.2.3. 行号显示</a></li>
<li><a href="#ForIndent-Conv">28.14.2.4. 语法约定</a></li>
<li><a href="#ForIndent-Vars">28.14.2.5. Fortran 缩进相关变量</a></li>
</ul>
</li>
<li><a href="#Fortran-Comments">28.14.3. Fortran 注释</a></li>
<li><a href="#Fortran-Autofill">28.14.4. Fortran 模式下的自动填充</a></li>
<li><a href="#Fortran-Columns">28.14.5. Fortran 列检查</a></li>
<li><a href="#Fortran-Abbrev">28.14.6. Fortran 关键字缩写</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Building">29. 程序编译与测试</a>
<ul>
<li><a href="#Compilation">29.1. 在 Emacs 中运行编译</a></li>
<li><a href="#Compilation-Mode">29.2. 编译模式</a></li>
<li><a href="#Compilation-Shell">29.3. 编译用子 shell</a></li>
<li><a href="#Grep-Searching">29.4. 在 Emacs 中使用 Grep 搜索</a></li>
<li><a href="#Flymake">29.5. 实时语法错误检测</a></li>
<li><a href="#Debuggers">29.6. 在 Emacs 中运行调试器</a>
<ul>
<li><a href="#Starting-GUD">29.6.1. 启动 GUD 调试器</a></li>
<li><a href="#Debugger-Operation">29.6.2. 调试器操作</a></li>
<li><a href="#Commands-of-GUD">29.6.3. GUD 调试器命令</a></li>
<li><a href="#GUD-Customization">29.6.4. GUD 调试器定制</a></li>
<li><a href="#GDB-Graphical-Interface">29.6.5. GDB 图形界面</a>
<ul>
<li><a href="#GDB-User-Interface-Layout">29.6.5.1. GDB 图形界面布局</a></li>
<li><a href="#Source-Buffers">29.6.5.2. 源代码缓冲区</a></li>
<li><a href="#Breakpoints-Buffer">29.6.5.3. 断点缓冲区</a></li>
<li><a href="#Threads-Buffer">29.6.5.4. 线程缓冲区</a></li>
<li><a href="#Stack-Buffer">29.6.5.5. 堆栈缓冲区</a></li>
<li><a href="#Other-GDB-Buffers">29.6.5.6. 其他 GDB 缓冲区</a></li>
<li><a href="#Watch-Expressions">29.6.5.7. 监视表达式</a></li>
<li><a href="#Multithreaded-Debugging">29.6.5.8. 多线程调试</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Executing-Lisp">29.7. 执行 Lisp 表达式</a></li>
<li><a href="#Lisp-Libraries">29.8. Emacs Lisp 代码库</a></li>
<li><a href="#Lisp-Eval">29.9. 求值 Emacs Lisp 表达式</a></li>
<li><a href="#Lisp-Interaction">29.10. Lisp 交互缓冲区</a></li>
<li><a href="#External-Lisp">29.11. 运行外部 Lisp 解释器</a></li>
</ul>
</li>
<li><a href="#Maintaining">30. 大型程序维护</a>
<ul>
<li><a href="#Version-Control">30.1. 版本控制</a>
<ul>
<li><a href="#Introduction-to-VC">30.1.1. 版本控制简介</a>
<ul>
<li><a href="#Why-Version-Control_003f">30.1.1.1. 理解版本控制解决的问题</a></li>
<li><a href="#Version-Control-Systems">30.1.1.2. VC 支持的版本控制系统</a></li>
<li><a href="#VCS-Concepts">30.1.1.3. 版本控制的核心概念</a></li>
<li><a href="#VCS-Merging">30.1.1.4. 基于合并与基于锁定的版本控制</a></li>
<li><a href="#VCS-Changesets">30.1.1.5. 基于变更集与基于文件的版本控制</a></li>
<li><a href="#VCS-Repositories">30.1.1.6. 分布式与集中式代码仓库</a></li>
<li><a href="#Types-of-Log-File">30.1.1.7. 日志文件类型</a></li>
</ul>
</li>
<li><a href="#VC-Mode-Line">30.1.2. 版本控制与模式行</a></li>
<li><a href="#Basic-VC-Editing">30.1.3. 版本控制下的基本编辑</a>
<ul>
<li><a href="#VC-With-A-Merging-VCS">30.1.3.1. 基于合并的基本版本控制</a></li>
<li><a href="#VC-With-A-Locking-VCS">30.1.3.2. 基于锁定的基本版本控制</a></li>
<li><a href="#Advanced-C_002dx-v-v">30.1.3.3. C-x v v 中的高级控制</a></li>
</ul>
</li>
<li><a href="#Log-Buffer">30.1.4. 日志条目缓冲区的功能</a></li>
<li><a href="#Registering">30.1.5. 为文件注册版本控制</a></li>
<li><a href="#Old-Revisions">30.1.6. 查看与比较旧版本</a></li>
<li><a href="#VC-Change-Log">30.1.7. 版本控制变更日志</a></li>
<li><a href="#VC-Undo">30.1.8. 撤销版本控制操作</a></li>
<li><a href="#VC-Ignore">30.1.9. 忽略版本控制文件</a></li>
<li><a href="#VC-Directory-Mode">30.1.10. 版本控制目录模式</a>
<ul>
<li><a href="#VC-Directory-Buffer">30.1.10.1. 版本控制目录缓冲区</a></li>
<li><a href="#VC-Directory-Commands">30.1.10.2. 版本控制目录命令</a></li>
</ul>
</li>
<li><a href="#Branches">30.1.11. 版本控制分支</a>
<ul>
<li><a href="#Switching-Branches">30.1.11.1. 分支切换</a></li>
<li><a href="#Pulling-_002f-Pushing">30.1.11.2. 分支间的变更拉取 / 推送</a></li>
<li><a href="#Merging">30.1.11.3. 分支合并</a></li>
<li><a href="#Creating-Branches">30.1.11.4. 新建分支</a></li>
</ul>
</li>
<li><a href="#Miscellaneous-VC">30.1.12. 版本控制的杂项命令与功能</a>
<ul>
<li><a href="#Change-Logs-and-VC">30.1.12.1. 变更日志与版本控制</a></li>
<li><a href="#VC-Delete_002fRename">30.1.12.2. 删除与重命名版本控制文件</a></li>
<li><a href="#Revision-Tags">30.1.12.3. 版本标签</a></li>
<li><a href="#Version-Headers">30.1.12.4. 插入版本控制头信息</a></li>
<li><a href="#Editing-VC-Commands">30.1.12.5. 编辑版本控制命令</a></li>
<li><a href="#Preparing-Patches">30.1.12.6. 准备补丁文件</a></li>
</ul>
</li>
<li><a href="#Customizing-VC">30.1.13. 定制版本控制</a>
<ul>
<li><a href="#General-VC-Options">30.1.13.1. 通用选项</a></li>
<li><a href="#RCS-and-SCCS">30.1.13.2. RCS 与 SCCS 相关选项</a></li>
<li><a href="#CVS-Options">30.1.13.3. CVS 专用选项</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Projects">30.2. 项目管理</a>
<ul>
<li><a href="#Project-File-Commands">30.2.1. 作用于文件的项目命令</a></li>
<li><a href="#Project-Buffer-Commands">30.2.2. 作用于缓冲区的项目命令</a></li>
<li><a href="#Switching-Projects">30.2.3. 项目切换</a></li>
<li><a href="#Managing-Projects">30.2.4. 项目列表文件管理</a></li>
</ul>
</li>
<li><a href="#Change-Log">30.3. 变更日志</a>
<ul>
<li><a href="#Change-Log-Commands">30.3.1. 变更日志命令</a></li>
<li><a href="#Format-of-ChangeLog">30.3.2. ChangeLog 文件的格式</a></li>
</ul>
</li>
<li><a href="#Xref">30.4. 查找标识符引用</a>
<ul>
<li><a href="#Find-Identifiers">30.4.1. 查找标识符</a>
<ul>
<li><a href="#Looking-Up-Identifiers">30.4.1.1. 标识符查阅</a></li>
<li><a href="#Xref-Commands">30.4.1.2. xref 缓冲区中的可用命令</a></li>
<li><a href="#Identifier-Search">30.4.1.3. 基于标识符的搜索与替换</a></li>
<li><a href="#List-Identifiers">30.4.1.4. 标识符查询</a></li>
</ul>
</li>
<li><a href="#Tags-Tables">30.4.2. 标签表</a>
<ul>
<li><a href="#Tag-Syntax">30.4.2.1. 源文件标签语法</a></li>
<li><a href="#Create-Tags-Table">30.4.2.2. 创建标签表</a></li>
<li><a href="#Etags-Regexps">30.4.2.3. Etags 正则表达式</a></li>
</ul>
</li>
<li><a href="#Select-Tags-Table">30.4.3. 选择标签表</a></li>
</ul>
</li>
<li><a href="#EDE">30.5. Emacs 开发环境</a></li>
<li><a href="#Emerge">30.6. 使用 Emerge 合并文件</a>
<ul>
<li><a href="#Overview-of-Emerge">30.6.1. Emerge 概述</a></li>
<li><a href="#Submodes-of-Emerge">30.6.2. Emerge 的子模式</a></li>
<li><a href="#State-of-Difference">30.6.3. 差异状态</a></li>
<li><a href="#Merge-Commands">30.6.4. 合并命令</a></li>
<li><a href="#Exiting-Emerge">30.6.5. 退出 Emerge</a></li>
<li><a href="#Combining-in-Emerge">30.6.6. 合并两个版本的内容</a></li>
<li><a href="#Fine-Points-of-Emerge">30.6.7. Emerge 的细节要点</a></li>
</ul>
</li>
<li><a href="#Bug-Reference">30.7. 漏洞引用</a></li>
</ul>
</li>
<li><a href="#Abbrevs">31. 缩写</a>
<ul>
<li><a href="#Abbrev-Concepts">31.1. 缩写概念</a></li>
<li><a href="#Defining-Abbrevs">31.2. 定义缩写</a></li>
<li><a href="#Expanding-Abbrevs">31.3. 控制缩写展开</a></li>
<li><a href="#Abbrevs-Suggestions">31.4. 缩写建议</a></li>
<li><a href="#Editing-Abbrevs">31.5. 查看与编辑缩写</a></li>
<li><a href="#Saving-Abbrevs">31.6. 保存缩写</a></li>
<li><a href="#Dynamic-Abbrevs">31.7. 动态缩写展开</a></li>
<li><a href="#Dabbrev-Customization">31.8. 定制动态缩写</a></li>
</ul>
</li>
<li><a href="#Dired">32. 目录编辑器（Dired）</a>
<ul>
<li><a href="#Dired-Enter">32.1. 进入 Dired</a></li>
<li><a href="#Dired-Navigation">32.2. Dired 缓冲区中的导航</a></li>
<li><a href="#Dired-Deletion">32.3. 用 Dired 删除文件</a></li>
<li><a href="#Flagging-Many-Files">32.4. 批量标记多个文件</a></li>
<li><a href="#Dired-Visiting">32.5. 在目录编辑器中打开文件</a></li>
<li><a href="#Marks-vs-Flags">32.6. Dired 中的标记与标记符</a></li>
<li><a href="#Operating-on-Files">32.7. 对文件执行操作</a></li>
<li><a href="#Shell-Commands-in-Dired">32.8. Dired 中的 Shell 命令</a></li>
<li><a href="#Shell-Command-Guessing">32.9. Shell 命令自动推测</a></li>
<li><a href="#Transforming-File-Names">32.10. Dired 中的文件名转换</a></li>
<li><a href="#Comparison-in-Dired">32.11. 通过 Dired 对比文件</a></li>
<li><a href="#Subdirectories-in-Dired">32.12. Dired 中的子目录操作</a></li>
<li><a href="#Subdir-Switches">32.13. Dired 中的子目录切换</a></li>
<li><a href="#Subdirectory-Motion">32.14. 遍历子目录</a></li>
<li><a href="#Hiding-Subdirectories">32.15. 隐藏子目录</a></li>
<li><a href="#Dired-Updating">32.16. 更新 Dired 缓冲区</a></li>
<li><a href="#Dired-and-Find">32.17. Dired 与 find 命令</a></li>
<li><a href="#Wdired">32.18. 编辑 Dired 缓冲区</a></li>
<li><a href="#Image_002dDired">32.19. 在 Dired 中查看图片缩略图</a></li>
<li><a href="#Misc-Dired-Features">32.20. Dired 的其他功能</a></li>
</ul>
</li>
<li><a href="#Calendar_002fDiary">33. 日历与日记</a>
<ul>
<li><a href="#Calendar-Motion">33.1. 日历中的移动</a>
<ul>
<li><a href="#Calendar-Unit-Motion">33.1.1. 按标准时间长度移动</a></li>
<li><a href="#Move-to-Beginning-or-End">33.1.2. 星期、月份、年份的开始或结尾</a></li>
<li><a href="#Specified-Dates">33.1.3. 指定日期跳转</a></li>
</ul>
</li>
<li><a href="#Scroll-Calendar">33.2. 日历滚动</a></li>
<li><a href="#Counting-Days">33.3. 天数计算</a></li>
<li><a href="#General-Calendar">33.4. 日历杂项命令</a></li>
<li><a href="#Writing-Calendar-Files">33.5. 编写日历文件</a></li>
<li><a href="#Holidays">33.6. 节假日显示</a></li>
<li><a href="#Sunrise_002fSunset">33.7. 日出日落时间</a></li>
<li><a href="#Lunar-Phases">33.8. 月相显示</a></li>
<li><a href="#Other-Calendars">33.9. 与其他日历系统的转换</a>
<ul>
<li><a href="#Calendar-Systems">33.9.1. 支持的日历系统</a></li>
<li><a href="#To-Other-Calendar">33.9.2. 转换到其他日历系统</a></li>
<li><a href="#From-Other-Calendar">33.9.3. 从其他日历系统转换</a></li>
</ul>
</li>
<li><a href="#Diary">33.10. 日记</a>
<ul>
<li><a href="#Format-of-Diary-File">33.10.1. 日记文件</a></li>
<li><a href="#Displaying-the-Diary">33.10.2. 显示日记</a></li>
<li><a href="#Date-Formats">33.10.3. 日期格式</a></li>
<li><a href="#Adding-to-Diary">33.10.4. 添加日记条目的命令</a></li>
<li><a href="#Special-Diary-Entries">33.10.5. 特殊日记条目</a></li>
<li><a href="#Appointments">33.10.6. 约会提醒</a></li>
<li><a href="#Importing-Diary">33.10.7. 日记条目的导入与导出</a></li>
</ul>
</li>
<li><a href="#Daylight-Saving">33.11. 夏令时</a></li>
<li><a href="#Time-Intervals">33.12. 时间间隔求和</a></li>
<li><a href="#Advanced-Calendar_002fDiary-Usage">33.13. 日历与日记的高级功能</a>
<ul>
<li><a href="#Calendar-Customizing">33.13.1. 定制日历</a></li>
<li><a href="#Holiday-Customizing">33.13.2. 定制节假日</a></li>
<li><a href="#Mayan-Calendar">33.13.3. 玛雅日历转换</a></li>
<li><a href="#Date-Display-Format">33.13.4. 日期显示格式</a></li>
<li><a href="#Time-Display-Format">33.13.5. 时间显示格式</a></li>
<li><a href="#Diary-Customizing">33.13.6. 定制日记</a></li>
<li><a href="#Non_002dGregorian-Diary">33.13.7. 使用非公历的日记条目</a></li>
<li><a href="#Diary-Display">33.13.8. 日记显示</a></li>
<li><a href="#Fancy-Diary-Display">33.13.9. 高级日记显示</a></li>
<li><a href="#Sexp-Diary-Entries">33.13.10. Sexp 条目与高级日记显示</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Sending-Mail">34. 发送邮件</a>
<ul>
<li><a href="#Mail-Format">34.1. 邮件缓冲区格式</a></li>
<li><a href="#Mail-Headers">34.2. 邮件头字段</a></li>
<li><a href="#Mail-Aliases">34.3. 邮件别名</a></li>
<li><a href="#Mail-Commands">34.4. 邮件命令</a>
<ul>
<li><a href="#Mail-Sending">34.4.1. 邮件发送</a></li>
<li><a href="#Header-Editing">34.4.2. 邮件头编辑</a></li>
<li><a href="#Citing-Mail">34.4.3. 邮件引用</a></li>
<li><a href="#Mail-Misc">34.4.4. 邮件杂项功能</a></li>
</ul>
</li>
<li><a href="#Mail-Signature">34.5. 邮件签名</a></li>
<li><a href="#Mail-Amusements">34.6. 邮件娱乐功能</a></li>
<li><a href="#Mail-Methods">34.7. 邮件撰写方式</a></li>
</ul>
</li>
<li><a href="#Rmail">35. 使用 Rmail 阅读邮件</a>
<ul>
<li><a href="#Rmail-Basics">35.1. Rmail 基本概念</a></li>
<li><a href="#Rmail-Scrolling">35.2. 邮件内滚动</a></li>
<li><a href="#Rmail-Motion">35.3. 邮件间移动</a></li>
<li><a href="#Rmail-Deletion">35.4. 删除邮件</a></li>
<li><a href="#Rmail-Inbox">35.5. Rmail 文件与收件箱</a></li>
<li><a href="#Rmail-Files">35.6. 多个 Rmail 文件</a></li>
<li><a href="#Rmail-Output">35.7. 将邮件复制到外部文件</a></li>
<li><a href="#Rmail-Labels">35.8. 标签</a></li>
<li><a href="#Rmail-Attributes">35.9. Rmail 属性</a></li>
<li><a href="#Rmail-Reply">35.10. 发送回复</a></li>
<li><a href="#Rmail-Summary">35.11. 摘要</a>
<ul>
<li><a href="#Rmail-Make-Summary">35.11.1. 生成摘要</a></li>
<li><a href="#Rmail-Summary-Edit">35.11.2. 在摘要中编辑</a></li>
</ul>
</li>
<li><a href="#Rmail-Sorting">35.12. Rmail 文件排序</a></li>
<li><a href="#Rmail-Display">35.13. 邮件显示</a></li>
<li><a href="#Rmail-Coding">35.14. Rmail 与编码系统</a></li>
<li><a href="#Rmail-Editing">35.15. 邮件内编辑</a></li>
<li><a href="#Rmail-Digest">35.16. 邮件摘要</a></li>
<li><a href="#Rmail-Rot13">35.17. 阅读 Rot13 加密邮件</a></li>
<li><a href="#Movemail">35.18. movemail 程序</a></li>
<li><a href="#Remote-Mailboxes">35.19. 从远程邮箱获取邮件</a></li>
<li><a href="#Other-Mailbox-Formats">35.20. 从多种格式的本地邮箱获取邮件</a></li>
</ul>
</li>
<li><a href="#Gnus">36. 使用 Gnus 处理电子邮件与新闻组</a>
<ul>
<li><a href="#Buffers-of-Gnus">36.1. Gnus 缓冲区</a></li>
<li><a href="#Gnus-Startup">36.2. Gnus 启动流程</a></li>
<li><a href="#Gnus-Group-Buffer">36.3. 使用 Gnus 组缓冲区</a></li>
<li><a href="#Gnus-Summary-Buffer">36.4. 使用 Gnus 摘要缓冲区</a></li>
</ul>
</li>
<li><a href="#Host-Security">37. 主机安全</a></li>
<li><a href="#Network-Security">38. 网络安全</a></li>
<li><a href="#Document-View">39. 文档查看</a>
<ul>
<li><a href="#DocView-Navigation">39.1. DocView 导航</a></li>
<li><a href="#DocView-Searching">39.2. DocView 搜索</a></li>
<li><a href="#DocView-Slicing">39.3. DocView 切片</a></li>
<li><a href="#DocView-Conversion">39.4. DocView 格式转换</a></li>
</ul>
</li>
<li><a href="#Shell">40. 从 Emacs 运行 Shell 命令</a>
<ul>
<li><a href="#Single-Shell">40.1. 单个 Shell 命令</a></li>
<li><a href="#Interactive-Shell">40.2. 交互式子 shell</a></li>
<li><a href="#Shell-Mode">40.3. Shell 模式</a></li>
<li><a href="#Shell-Prompts">40.4. Shell 提示符</a></li>
<li><a href="#Shell-History">40.5. Shell 命令历史</a>
<ul>
<li><a href="#Shell-Ring">40.5.1. Shell 历史环</a></li>
<li><a href="#Shell-History-Copying">40.5.2. Shell 历史复制</a></li>
<li><a href="#History-References">40.5.3. Shell 历史引用</a></li>
</ul>
</li>
<li><a href="#Directory-Tracking">40.6. 目录跟踪</a></li>
<li><a href="#Shell-Options">40.7. Shell 模式选项</a></li>
<li><a href="#Terminal-emulator">40.8. Emacs 终端模拟器</a></li>
<li><a href="#Term-Mode">40.9. 终端模式</a></li>
<li><a href="#Remote-Host">40.10. 远程主机 Shell</a></li>
<li><a href="#Serial-Terminal">40.11. 串行终端</a></li>
</ul>
</li>
<li><a href="#Emacs-Server">41. 将 Emacs 用作服务器</a>
<ul>
<li><a href="#TCP-Emacs-server">41.1. TCP Emacs 服务器</a></li>
<li><a href="#Invoking-emacsclient">41.2. 调用 emacsclient</a></li>
<li><a href="#emacsclient-Options">41.3. emacsclient 选项</a></li>
</ul>
</li>
<li><a href="#Printing">42. 打印硬拷贝</a>
<ul>
<li><a href="#PostScript">42.1. PostScript 纸质打开</a></li>
<li><a href="#PostScript-Variables">42.2. PostScript 纸质打开相关变量</a></li>
<li><a href="#Printing-Package">42.3. 打印功能包</a></li>
</ul>
</li>
<li><a href="#Sorting">43. 文本排序</a></li>
<li><a href="#Picture-Mode">44. 图片编辑</a>
<ul>
<li><a href="#Basic-Picture">44.1. 图片模式基本编辑</a></li>
<li><a href="#Insert-in-Picture">44.2. 插入后移动控制</a></li>
<li><a href="#Tabs-in-Picture">44.3. 图片模式制表符</a></li>
<li><a href="#Rectangles-in-Picture">44.4. 图片模式矩形命令</a></li>
</ul>
</li>
<li><a href="#Editing-Binary-Files">45. 二进制文件编辑</a></li>
<li><a href="#Saving-Emacs-Sessions">46. 保存 Emacs 会话</a></li>
<li><a href="#Recursive-Edit">47. 递归编辑层级</a></li>
<li><a href="#Hyperlinking">48. 超链接与网页导航功能</a>
<ul>
<li><a href="#EWW">48.1. 使用 EWW 网页浏览</a></li>
<li><a href="#Embedded-WebKit-Widgets">48.2. 嵌入式 WebKit 组件</a></li>
<li><a href="#Browse_002dURL">48.3. 跟随 URL 链接</a></li>
<li><a href="#Goto-Address-mode">48.4. 激活 URL 链接</a></li>
<li><a href="#FFAP">48.5. 查找光标位置的文件与 URL</a></li>
</ul>
</li>
<li><a href="#Amusements">49. 游戏与其他娱乐功能</a></li>
<li><a href="#Packages">50. Emacs Lisp 软件包</a>
<ul>
<li><a href="#Package-Menu">50.1. 软件包菜单缓冲区</a></li>
<li><a href="#Package-Statuses">50.2. 软件包状态</a></li>
<li><a href="#Package-Installation">50.3. 软件包安装</a></li>
<li><a href="#Package-Files">50.4. 软件包文件与目录结构</a></li>
<li><a href="#Fetching-Package-Sources">50.5. 获取软件包源码</a>
<ul>
<li><a href="#Specifying-Package-Sources">50.5.1. 指定软件包源码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Customization">51. 定制</a>
<ul>
<li><a href="#Easy-Customization">51.1. 简易自定义界面</a>
<ul>
<li><a href="#Customization-Groups">51.1.1. 自定义组</a></li>
<li><a href="#Browsing-Custom">51.1.2. 浏览与搜索设置</a></li>
<li><a href="#Changing-a-Variable">51.1.3. 修改变量</a></li>
<li><a href="#Saving-Customizations">51.1.4. 保存自定义设置</a></li>
<li><a href="#Face-Customization">51.1.5. 自定义外观</a></li>
<li><a href="#Specific-Customization">51.1.6. 自定义特定项</a></li>
<li><a href="#Custom-Themes">51.1.7. 自定义主题</a></li>
<li><a href="#Creating-Custom-Themes">51.1.8. 创建自定义主题</a></li>
</ul>
</li>
<li><a href="#Variables">51.2. 变量</a>
<ul>
<li><a href="#Examining">51.2.1. 查看与设置变量</a></li>
<li><a href="#Hooks">51.2.2. 钩子</a></li>
<li><a href="#Locals">51.2.3. 局部变量</a></li>
<li><a href="#File-Variables">51.2.4. 文件中的局部变量</a>
<ul>
<li><a href="#Specifying-File-Variables">51.2.4.1. 指定文件变量</a></li>
<li><a href="#Safe-File-Variables">51.2.4.2. 文件变量的安全性</a></li>
</ul>
</li>
<li><a href="#Directory-Variables">51.2.5. 目录级局部变量</a>
<ul>
<li><a href="#EditorConfig-support">51.2.5.1. 通过 EditorConfig 设置目录级变量</a></li>
</ul>
</li>
<li><a href="#Connection-Variables">51.2.6. 连接级局部变量</a></li>
</ul>
</li>
<li><a href="#Key-Bindings">51.3. 按键绑定自定义</a>
<ul>
<li><a href="#Keymaps">51.3.1. 键映射</a></li>
<li><a href="#Prefix-Keymaps">51.3.2. 前缀键映射</a></li>
<li><a href="#Local-Keymaps">51.3.3. 局部键映射</a></li>
<li><a href="#Minibuffer-Maps">51.3.4. 迷你缓冲区键映射</a></li>
<li><a href="#Rebinding">51.3.5. 交互式修改键绑定</a></li>
<li><a href="#Init-Rebinding">51.3.6. 在初始化文件中重新绑定键</a></li>
<li><a href="#Modifier-Keys">51.3.7. 修饰键</a></li>
<li><a href="#Function-Keys">51.3.8. 重新绑定功能键</a></li>
<li><a href="#Named-ASCII-Chars">51.3.9. 命名 ASCII 控制字符</a></li>
<li><a href="#Mouse-Buttons">51.3.10. 重新绑定鼠标按钮</a></li>
<li><a href="#Disabling">51.3.11. 禁用命令</a></li>
</ul>
</li>
<li><a href="#Init-File">51.4. Emacs 初始化文件</a>
<ul>
<li><a href="#Init-Syntax">51.4.1. 初始化文件语法</a></li>
<li><a href="#Init-Examples">51.4.2. 初始化文件示例</a></li>
<li><a href="#Terminal-Init">51.4.3. 终端专用初始化</a></li>
<li><a href="#Find-Init">51.4.4. Emacs 查找初始化文件的方式</a></li>
<li><a href="#Init-Non_002dASCII">51.4.5. 初始化文件中的非 ASCII 字符</a></li>
<li><a href="#Early-Init-File">51.4.6. 早期初始化文件</a></li>
</ul>
</li>
<li><a href="#Authentication">51.5. 保存持久化认证信息</a></li>
</ul>
</li>
<li><a href="#Quitting">52. 退出与中止</a></li>
<li><a href="#Lossage">53. 处理 Emacs 故障</a>
<ul>
<li><a href="#Stuck-Recursive">53.1. 递归编辑层级</a></li>
<li><a href="#Screen-Garbled">53.2. 屏幕乱码</a></li>
<li><a href="#Text-Garbled">53.3. 文本乱码</a></li>
<li><a href="#Memory-Full">53.4. 内存不足</a></li>
<li><a href="#Crashing">53.5. Emacs 崩溃时</a></li>
<li><a href="#After-a-Crash">53.6. 崩溃后的恢复</a></li>
<li><a href="#Emergency-Escape">53.7. 紧急退出</a></li>
<li><a href="#DEL-Does-Not-Delete">53.8. 当 <code>DEL</code> 键无法删除时</a></li>
</ul>
</li>
<li><a href="#Bugs">54. 报告漏洞</a>
<ul>
<li><a href="#Known-Problems">54.1. 查看现有漏洞报告与已知问题</a></li>
<li><a href="#Bug-Criteria">54.2. 漏洞的判定标准</a></li>
<li><a href="#Understanding-Bug-Reporting">54.3. 理解漏洞报告</a></li>
<li><a href="#Checklist">54.4. 漏洞报告检查清单</a></li>
<li><a href="#Sending-Patches">54.5. 提交 GNU Emacs 补丁</a></li>
</ul>
</li>
<li><a href="#Contributing">55. 为 Emacs 开发做贡献</a>
<ul>
<li><a href="#Coding-Standards">55.1. 编码标准</a></li>
<li><a href="#Copyright-Assignment">55.2. 版权转让</a></li>
</ul>
</li>
<li><a href="#Service">56. 如何获取 GNU Emacs 相关帮助</a></li>
<li><a href="#Copying">附录 A GNU 通用公共许可证</a></li>
<li><a href="#GNU-Free-Documentation-License">附录 B GNU 自由文档许可证</a></li>
<li><a href="#Emacs-Invocation">附录 C Emacs 启动命令行参数</a>
<ul>
<li><a href="#Action-Arguments">C.1 动作参数</a></li>
<li><a href="#Initial-Options">C.2 初始选项</a></li>
<li><a href="#Command-Example">C.3 命令参数示例</a></li>
<li><a href="#Environment">C.4 环境变量</a>
<ul>
<li><a href="#General-Variables">C.4.1 通用变量</a></li>
<li><a href="#Misc-Variables">C.4.2 杂项变量</a></li>
<li><a href="#MS_002dWindows-Registry">C.4.3 MS-Windows 系统注册表</a></li>
</ul>
</li>
<li><a href="#Display-X">C.5 指定显示名称</a></li>
<li><a href="#Font-X">C.6 字体指定选项</a></li>
<li><a href="#Colors-X">C.7 窗口颜色选项</a></li>
<li><a href="#Window-Size-X">C.8 窗口大小与位置选项</a></li>
<li><a href="#Borders-X">C.9 内部边框与外部边框</a></li>
<li><a href="#Title-X">C.10 框架标题</a></li>
<li><a href="#Icons-X">C.11 图标</a></li>
<li><a href="#Misc-X">C.12 其他显示选项</a></li>
</ul>
</li>
<li><a href="#X-Resources">附录 D X 窗口系统选项与资源</a>
<ul>
<li><a href="#Resources">D.1 X 资源</a></li>
<li><a href="#Table-of-Resources">D.2 Emacs 的 X 资源表</a></li>
<li><a href="#Lucid-Resources">D.3 Lucid 菜单与对话框 X 资源</a></li>
<li><a href="#Motif-Resources">D.4 Motif 菜单 X 资源</a></li>
<li><a href="#GTK-resources">D.5 GTK+ 资源</a>
<ul>
<li><a href="#GTK-Resource-Basics">D.5.1 GTK+ 资源基础</a></li>
<li><a href="#GTK-Widget-Names">D.5.2 GTK+ 组件名称</a></li>
<li><a href="#GTK-Names-in-Emacs">D.5.3 Emacs 中的 GTK+ 组件名称</a></li>
<li><a href="#GTK-styles">D.5.4 GTK+ 样式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Antinews">附录 E Emacs 29 版本反向更新说明</a></li>
<li><a href="#Mac-OS-_002f-GNUstep">附录 F Emacs 与 macOS / GNUstep</a>
<ul>
<li><a href="#Mac-_002f-GNUstep-Basics">F.1 macOS 与 GNUstep 下的 Emacs 基本使用</a>
<ul>
<li><a href="#Grabbing-environment-variables">F.1.1 获取环境变量</a></li>
</ul>
</li>
<li><a href="#Mac-_002f-GNUstep-Customization">F.2 Mac / GNUstep 定制</a>
<ul>
<li><a href="#Modifier-keys">F.2.1 修饰键</a></li>
<li><a href="#Frame-Variables">F.2.2 框架变量</a></li>
<li><a href="#macOS-Trackpad_002fMousewheel-Variables">F.2.3 macOS 触控板 / 鼠标滚轮变量</a></li>
</ul>
</li>
<li><a href="#Mac-_002f-GNUstep-Events">F.3 macOS / GNUstep 下的窗口系统事件</a></li>
<li><a href="#GNUstep-Support">F.4 GNUstep 支持</a></li>
</ul>
</li>
<li><a href="#Haiku">附录 G Emacs 与 Haiku 系统</a>
<ul>
<li><a href="#Haiku-Basics">G.1 Haiku 系统下的安装与启动</a></li>
<li><a href="#Haiku-Fonts">G.2 Haiku 系统下的字体后端与选择</a></li>
</ul>
</li>
<li><a href="#Android">附录 H Emacs 与 Android 系统</a>
<ul>
<li><a href="#What-is-Android_003f">H.1 Android 版本历史</a></li>
<li><a href="#Android-Startup">H.2 在 Android 上启动 Emacs</a></li>
<li><a href="#Android-File-System">H.3 Emacs 在 Android 上可访问的文件</a></li>
<li><a href="#Android-Document-Providers">H.4 在 Android 上从其他程序访问文件</a></li>
<li><a href="#Android-Environment">H.5 在 Android 下运行 Emacs</a></li>
<li><a href="#Android-Windowing">H.6 Android 窗口系统</a></li>
<li><a href="#Android-Fonts">H.7 Android 下的字体后端与选择</a></li>
<li><a href="#Android-Troubleshooting">H.8 Android 启动问题排查</a></li>
<li><a href="#Android-Software">H.9 在 Android 上安装额外软件</a></li>
</ul>
</li>
<li><a href="#Microsoft-Windows">附录 I Emacs 与 Microsoft Windows/MS-DOS</a>
<ul>
<li><a href="#Windows-Startup">I.1 在 MS-Windows 上启动 Emacs 的方法</a></li>
<li><a href="#Text-and-Binary">I.2 文本文件与二进制文件</a></li>
<li><a href="#Windows-Files">I.3 MS-Windows 上的文件名</a></li>
<li><a href="#ls-in-Lisp">I.4 MS-Windows 上的 ls 命令模拟</a></li>
<li><a href="#Windows-HOME">I.5 MS-Windows 上的 HOME 目录与启动目录</a></li>
<li><a href="#Windows-Keyboard">I.6 MS-Windows 上的键盘使用</a></li>
<li><a href="#Windows-Mouse">I.7 MS-Windows 上的鼠标使用</a></li>
<li><a href="#Windows-Processes">I.8 Windows 9X/ME 与 Windows NT/2K/XP/Vista/7/8/10 上的子进程</a></li>
<li><a href="#Windows-Printing">I.9 MS-Windows 上的打印功能</a></li>
<li><a href="#Windows-Fonts">I.10 MS-Windows 上的字体指定</a></li>
<li><a href="#Windows-Misc">I.11 其他 Windows 专用功能</a></li>
<li><a href="#MS_002dDOS">I.12 Emacs 与 MS-DOS</a>
<ul>
<li><a href="#MS_002dDOS-Keyboard">I.12.1 MS-DOS 上的键盘使用</a></li>
<li><a href="#MS_002dDOS-Mouse">I.12.2 MS-DOS 上的鼠标使用</a></li>
<li><a href="#MS_002dDOS-Display">I.12.3 MS-DOS 上的显示</a></li>
<li><a href="#MS_002dDOS-File-Names">I.12.4 MS-DOS 上的文件名</a></li>
<li><a href="#MS_002dDOS-Printing">I.12.5 MS-DOS 上的打印功能</a></li>
<li><a href="#MS_002dDOS-and-MULE">I.12.6 MS-DOS 上的国际语言支持</a></li>
<li><a href="#MS_002dDOS-Processes">I.12.7 MS-DOS 上的子进程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Manifesto">GNU 宣言</a>
<ul>
<li><a href="#What_0027s-GNU_003f-Gnu_0027s-Not-Unix_0021">什么是 GNU？GNU 不是 Unix！</a></li>
<li><a href="#Why-I-Must-Write-GNU">我为何必须编写 GNU</a></li>
<li><a href="#Why-GNU-Will-Be-Compatible-with-Unix">为何 GNU 要与 Unix 兼容</a></li>
<li><a href="#How-GNU-Will-Be-Available">GNU 的获取方式</a></li>
<li><a href="#Why-Many-Other-Programmers-Want-to-Help">为何众多程序员愿意提供帮助</a></li>
<li><a href="#How-You-Can-Contribute">你如何能做出贡献</a></li>
<li><a href="#Why-All-Computer-Users-Will-Benefit">为何所有计算机用户都将受益</a></li>
<li><a href="#Some-Easily-Rebutted-Objections-to-GNU_0027s-Goals">对 GNU 目标的一些易反驳的反对意见</a></li>
</ul>
</li>
<li><a href="#Glossary">术语表</a></li>
<li><a href="#Acknowledgments">致谢</a></li>
<li><a href="#Key-Index">按键（字符）索引</a></li>
<li><a href="#Option-Index">命令行选项索引</a></li>
<li><a href="#Command-Index">命令与函数索引</a></li>
<li><a href="#Variable-Index">变量索引</a></li>
<li><a href="#Concept-Index">概念索引</a></li>
<li><a href="#h:A2EBE128-92C2-466C-B35A-D0315988F1F7">脚注</a></li>
</ul>
</div>
</nav>
<section id="outline-container-Distrib" class="outline-2">
<h2 id="Distrib">发行说明</h2>
<div class="outline-text-2" id="text-Distrib">
<p>
GNU Emacs 是一款自由软件，这意味着任何人都可以自由使用它，并在特定条件下自由地重新分发。GNU Emacs 并不属于公有领域，它受版权保护，其分发行为也有相关限制，但这些限制的设立，是为了保障每一位愿意遵守协作规范的使用者都能享有应有的自由。禁止的行为是，试图阻止他人进一步分享从你手中获得的任何版本的 GNU Emacs。具体的使用与分发条件详见随 Emacs 一同发布的《GNU 通用公共许可证》，本手册中也收录了该许可证的内容 <sup><a id="fnr.发行说明" class="footref" href="#fn.发行说明" role="doc-backlink">1</a></sup>。参见《<a href="#Copying">GNU 通用公共许可证</a>》章节。
</p>

<p>
获取 GNU Emacs 副本的一种方式，是从其他已拥有该软件的人处拷贝。你无需征求我们的许可，也不必告知其他任何人，直接复制即可。若你能接入互联网，可通过匿名文件传输协议（FTP）获取 GNU Emacs 的最新分发版本；更多相关信息，请访问我们的官方网站：<a href="https://www.gnu.org/software/emacs">https://www.gnu.org/software/emacs</a>。
</p>

<p>
你也可能在购买计算机时获得 GNU Emacs。计算机制造商可依据适用于所有用户的同一套条款，自由分发该软件的副本。这些条款要求制造商向你提供完整的源代码，其中需包含他们可能做出的任何修改，同时必须允许你依据《通用公共许可证》的常规条款，重新分发从他们那里获得的 GNU Emacs。换句话说，你获得这款程序时，它必须是自由的，这种自由不应只属于制造商。
</p>

<p>
如果你认为 GNU Emacs 对你有所帮助，不妨向自由软件基金会（Free Software Foundation）捐赠，以支持我们的工作。在美国，向自由软件基金会的捐赠可享受税收减免政策。若你在工作场所使用 GNU Emacs，建议你提议所在公司进行捐赠。捐赠渠道请访问：<a href="https://my.fsf.org/donate/">https://my.fsf.org/donate/</a>。关于其他可以提供帮助的方式，详见：<a href="https://www.gnu.org/help/help.html">https://www.gnu.org/help/help.html</a>。
</p>

<p>
我们同时发售本手册的纸质版，以及罗伯特・J・查塞尔所著《Emacs Lisp 编程入门》一书的纸质版。你可以访问我们的线上商店：<a href="https://shop.fsf.org/">https://shop.fsf.org/</a>。销售所得收入将全部用于支持基金会的使命：开发新的自由软件，并对包括 GNU Emacs 在内的现有程序进行优化改进。
</p>

<p>
若你需要联系自由软件基金会，可访问官网联系方式页面：<a href="https://www.fsf.org/about/contact/">https://www.fsf.org/about/contact/</a>，或写信至以下地址：
</p>

<blockquote>
<p>
自由软件基金会
</p>

<p>
米尔克街 31 号，邮编 # 960789
</p>

<p>
马萨诸塞州 波士顿，邮编 02196
</p>

<p>
美国
</p>
</blockquote>
</div>
</section>
<section id="outline-container-Intro" class="outline-2">
<h2 id="Intro">引言</h2>
<div class="outline-text-2" id="text-Intro">
<p>
你正在阅读的是 GNU Emacs 的相关内容，它是 Emacs 这款高级(advanced)、自文档化(self-documenthing)、可定制(customizable)、可扩展(extensible)编辑器的 GNU 实现版本。（GNU 的全称是 “GNU’s Not Unix”，其中首字母 “G” 发音并非不发声。）
</p>

<p>
我们称 Emacs 为高级编辑器，是因为它的功能远不止简单的文本插入与删除。它可以控制子进程、自动缩进程序代码、同时显示多个文件、像编辑本地文件一样编辑远程文件，此外还有诸多强大功能。Emacs 的编辑命令可基于字符、单词、行、句子、段落和页面执行操作，同时也适配各类编程语言中的表达式与注释。
</p>

<p>
自文档化(self-documenting)指的是，你可以随时使用一类名为 “帮助命令” 的特殊指令，查看当前可用的功能选项、查询任意命令的作用，或是检索与指定主题相关的所有命令。详见 “<a href="#Help">帮助</a>” 章节。
</p>

<p>
可定制(customizable)指的是，你能够以简单的方式轻松修改 Emacs 命令的行为。例如，若你使用的编程语言规定注释以 &lt;** 开头、以 **&gt; 结尾，你可以让 Emacs 的注释操作命令适配这类符号（详见 “<a href="#Comments">注释操作</a>” 章节）。再举个例子，你可以将上下左右这些基础光标移动命令，重新绑定到键盘上你觉得顺手的任意按键。详见 “<a href="#Customization">自定义</a>” 章节。
</p>

<p>
可扩展(extensible)指的是，你可以突破简单定制的范畴，创建全新的命令。新命令本质上是用 Lisp 语言编写的程序，可通过 Emacs 内置的 Lisp 解释器运行。即便是在编辑会话过程中，你也能重新定义已有命令，无需重启 Emacs。Emacs 的绝大多数编辑命令本身就是用 Lisp 编写的；仅有少数命令为追求执行效率而改用 C 语言实现，它们其实原本也可以用 Lisp 编写。编写扩展属于编程工作，但非编程人员也能直接使用现成的扩展功能。如果你想要学习 Emacs Lisp 编程，可参阅《<a href="https://www.gnu.org/software/emacs/manual/html_mono/eintr.html#Top">Emacs Lisp 编程入门</a>》一书的 “前言(Preface)” 章节。
</p>
</div>
</section>
<section id="outline-container-Screen" class="outline-2">
<h2 id="Screen"><span class="section-number-2">1.</span> 屏幕布局</h2>
<div class="outline-text-2" id="text-Screen">
<p>
在图形化显示器中（例如在 GNU/Linux 系统上使用 X 窗口系统时），Emacs 会占用一个图形化窗口。在文本终端中，Emacs 则会占据整个终端屏幕。我们将 Emacs 所占用的图形化窗口或终端屏幕统称为框架(frame)。Emacs 在这两种框架中的运行方式基本一致。默认情况下，启动 Emacs 只会打开一个框架，但你也可以根据需要创建更多框架（详见 “<a href="#Frames">框架与图形化显示</a>” 章节）。
</p>

<p>
每个框架都包含多个不同的区域(region)。框架顶部是菜单栏(menu bar)，你可以通过一系列菜单调用各类命令。在图形化显示器中，菜单栏正下方是工具栏(tool bar)，这是一排图标，点击即可执行相应的编辑命令。框架最底端是回显区(echo area)，这里会显示提示信息，同时也是你在 Emacs 发出询问时输入信息的区域。
</p>

<p>
框架的主要区域位于工具栏(tool bar)（若存在）下方、回显区上方，该区域被称为窗口(window)。在本手册后续内容中，“窗口(window)” 一词均指代此含义。图形化显示系统中 “窗口” 的常用定义与本书不同；前文已说明，我们将这类图形化窗口称为 “框架(frames)”。
</p>

<p>
Emacs 窗口是用于显示缓冲区(buffer)的区域 —— 缓冲区即你正在编辑或查看的文本或其他图形内容。在图形化显示器中，窗口的一侧会配有滚动条，拖动滚动条即可滚动浏览缓冲区内容。窗口的最后一行是模式行(mode line)，它会显示缓冲区的各类相关信息，例如是否存在未保存的修改、当前启用的编辑模式、光标所在的行号等。
</p>

<p>
启动 Emacs 时，框架中默认仅有一个窗口。不过，你可以将这个窗口进行水平或垂直分割，从而创建多个窗口，每个窗口都能独立显示一个缓冲区（详见 “<a href="#Windows">多窗口</a>” 章节）。
</p>

<p>
在任意时刻，都有且仅有一个窗口处于选中状态。在图形化显示器中，选中的窗口会显示一个更醒目的光标（通常为实心闪烁样式）；其他未选中的窗口则会显示较不显眼的光标（通常为空心方块样式）。在文本终端中，屏幕上只会显示一个光标，且该光标始终位于选中的窗口内。选中窗口所显示的缓冲区被称为当前缓冲区(current buffer)，所有编辑操作均在此缓冲区中进行。大多数 Emacs 命令都会默认作用于当前缓冲区；未选中窗口中显示的文本仅供参考。若你在图形化显示器中同时打开了多个框架，选中某一框架的同时，也会选中该框架内的一个窗口。
</p>

<ul class="org-ul">
<li><a href="#Point">光标位置（Point）</a></li>
<li><a href="#Echo-Area">回显区（Echo Area）</a></li>
<li><a href="#Mode-Line">模式行（Mode Line）</a></li>
<li><a href="#Menu-Bar">菜单栏（Menu Bar）</a></li>
</ul>
</div>
<div id="outline-container-Point" class="outline-3">
<h3 id="Point"><span class="section-number-3">1.1.</span> 光标位置（Point）</h3>
<div class="outline-text-3" id="text-Point">
<p>
选中窗口中的光标标记着大多数编辑命令的生效位置，该位置被称为光标位置(point) <sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>。许多 Emacs 命令可以将光标位置移动到缓冲区的不同地方；例如，你可以在目标位置单击鼠标左键（通常为鼠标的第一按键），以此来定位光标位置。
</p>

<p>
默认情况下，选中窗口中的光标会显示为实心方块，看起来是停留在某个字符之上，但你应当将光标位置理解为两个字符之间的间隙—— 它 <code>位于光标所覆盖字符的前方</code> 。举例来说，若文本内容为 frob 且光标覆盖在字母 b 上，那么光标位置就在字母 o 和 b 之间。此时若在该位置插入字符 !，文本会变为 fro!b，光标位置则会处于 ! 和 b 之间。如此一来，光标依旧会像之前一样覆盖在字母 b 上。
</p>

<p>
若你在 Emacs 中同时编辑多个文件（每个文件对应一个独立的缓冲区），那么每个缓冲区都有其专属的光标位置。即便某个缓冲区当前未被显示，当你后续再次打开它时，该缓冲区仍会保留此前的光标位置。此外，若同一个缓冲区在多个窗口中同时显示，这些窗口的每一个也会分别拥有独立的光标位置。
</p>

<p>
有关控制 Emacs 光标显示方式的相关选项，详见 “<a href="#Cursor-Display">光标显示</a>” 章节。
</p>
</div>
</div>
<div id="outline-container-Echo-Area" class="outline-3">
<h3 id="Echo-Area"><span class="section-number-3">1.2.</span> 回显区（Echo Area）</h3>
<div class="outline-text-3" id="text-Echo-Area">
<p>
框架最底端的一行区域是回显区(echo area)，它被用于显示各类用途的简短文本信息。
</p>

<p>
回显区之所以得名，是因为它的用途之一是回显功能—— 也就是在你输入多字符命令时，同步显示已输入的命令字符。单字符命令不会触发回显；而多字符命令（详见 “<a href="#Keys">按键</a>” 章节），若你在输入过程中停顿超过一秒钟，Emacs 就会回显该命令当前已输入的所有字符，以此提示你继续输入剩余部分。一旦回显功能触发，后续输入的命令字符就会实时显示在回显区中。这种设计既能让操作熟练的用户获得流畅的响应速度，又能为操作不熟练的用户提供充分的反馈信息。
</p>

<p>
当某个命令无法执行时，回显区也会用于显示错误提示信息。这类错误信息通常还会伴随蜂鸣提示音，或是屏幕闪烁的提醒效果。
</p>

<p>
部分命令会在回显区显示提示性信息，告知用户该命令已执行的操作，或是提供一些特定信息。与错误信息不同，这类提示性信息不会伴随蜂鸣或屏幕闪烁。例如，按下快捷键 <code>C-x =</code> （按住 Ctrl 键的同时按下 x 键，松开 Ctrl 键后再按下 = 键），回显区就会显示一条信息，内容包含光标位置处的字符详情、该字符在缓冲区中的位置，以及它在窗口中对应的列数。对于执行耗时较长的命令，在运行过程中往往会在回显区显示以 '&#x2026;' 结尾的提示信息（有时还会以百分比的形式标注进度），待命令执行完毕后，再在信息末尾补充显示 done（完成）。
</p>

<p>
回显区显示的所有提示性信息，都会自动保存到一个名为 <code>*Messages*</code> 的特殊缓冲区中。（关于缓冲区的概念，我们将在后续内容中介绍，详见 “<a href="#Buffers">使用多缓冲区</a>” 章节。）如果你错过了一条一闪而过的提示信息，只需切换到 <code>*Messages*</code> 缓冲区，就能重新查看该信息。 <code>*Messages*</code> 缓冲区的存储行数存在上限，这个上限由变量 <code>message-log-max</code> 定义。（变量的相关概念同样会在后续说明，详见 “<a href="#Variables">变量</a>” 章节。）当缓冲区内容达到行数上限时，每在末尾新增一行信息，就会自动删除缓冲区最开头的一行旧信息。
</p>

<p>
有关控制 Emacs 回显区使用方式的相关选项，详见 “<a href="#Display-Custom">显示自定义</a>” 章节。
</p>

<p>
回显区还会被用于显示迷你缓冲区(minibuffer)。迷你缓冲区是一个特殊的输入窗口，你可以在这里输入命令的参数，例如待编辑文件的名称。当迷你缓冲区处于激活状态时，回显区显示的文本会以提示字符串开头，同时激活状态的光标会出现在迷你缓冲区中 —— 此时迷你缓冲区会被临时认定为选中窗口。你可以随时按下 <code>C-g</code> 快捷键退出迷你缓冲区。详见 “<a href="#Minibuffer">迷你缓冲区</a>” 章节。
</p>
</div>
</div>
<div id="outline-container-Mode-Line" class="outline-3">
<h3 id="Mode-Line"><span class="section-number-3">1.3.</span> 模式行（Mode Line）</h3>
<div class="outline-text-3" id="text-Mode-Line">
<p>
每个窗口的底部都有一行模式行，用于显示当前缓冲区的状态信息。当框架中只有一个窗口时，模式行位于回显区(echo area)的正上方，也就是整个框架的倒数第二行。在图形化显示器中，模式行的外观呈现为一个 3D 立体方框样式。为了突出显示，Emacs 通常会将选中窗口的模式行设置为与未选中窗口不同的颜色。
</p>

<p>
模式行显示的文本遵循以下格式：
</p>
<div class="org-src-container">
<pre class="src src-shell">cs:ch-dfr buf pos line (major minor)
</pre>
</div>

<p>
在文本终端中，上述文本的后方会显示一串连字符，一直延伸至窗口的右边缘；而在图形化显示器中，这串连字符会被省略。
</p>

<p>
各部分含义说明:
</p>
<ul class="org-ul">
<li><p>
cs 及其后的冒号:
</p>

<p>
这部分用于描述当前缓冲区使用的字符编码集和换行符规则。通常情况下，Emacs 会自动处理这些设置，但有时查看这些信息也会很有帮助。
</p>

<ul class="org-ul">
<li>cs 代表缓冲区中文本的字符编码集（详见 “<a href="#Coding-Systems">编码系统</a>” 章节）。如果显示为连字符（'-'），表示未启用特殊的字符编码集处理（换行符规则可能除外，具体见下一段）；如果显示为等号（'='），表示完全不进行编码转换，这种情况通常用于编辑非文本类数据文件；其他字符则代表不同的编码系统，例如 1 代表 ISO Latin-1 编码。</li>

<li>在文本终端中，cs 前方还会显示两个额外字符，分别表示键盘输入和终端输出所使用的编码系统。此外，若你启用了输入法，cs 前方还会显示标识当前输入法的字符串（详见 “<a href="#Input-Methods">输入法</a>” 章节）。</li>

<li>cs 后方的字符通常是冒号。如果显示为其他字符，则说明该文件采用了非标准的换行符规则。文本文件的换行通常由换行符分隔，但有时也会采用另外两种规则：MS-DOS 系统的规则是用回车符加换行符表示换行，编辑这类文件时，冒号会变成反斜杠（\）或 (DOS)（具体显示取决于操作系统）；早期 Macintosh 系统的规则是用回车符替代换行符，编辑这类文件时，冒号会变成正斜杠（/）或 (Mac)。在部分系统中，对于使用换行符作为分隔符的文件，Emacs 会用 (Unix) 替代冒号进行显示。</li>

<li>对于通过 emacsclient 创建的框架（详见 “<a href="#Invoking-emacsclient">调用 emacsclient</a>” 章节），cs 后方的字符会显示为 @。这种标识常见于以守护进程模式运行的 Emacs 进程所创建的框架（详见 “<a href="#Emacs-Server">将 Emacs 用作服务器</a>” 章节）。</li>
</ul></li>

<li><p>
ch
</p>

<p>
这部分用于标识缓冲区的修改状态。如果窗口中显示的缓冲区内容与磁盘上对应的文件内容一致（即缓冲区未被修改），会显示两个连字符（'&#x2013;'）；如果缓冲区已被修改，则显示两个星号（**）；对于只读缓冲区，若内容已修改会显示 %*，未修改则显示 %%。
</p></li>

<li><p>
ch 后的字符
</p>

<p>
该位置通常显示为连字符（'-'）。但如果当前缓冲区的 default-directory（详见 “<a href="#File-Names">文件名</a>” 章节）指向远程主机，该位置会显示为 @。
</p></li>

<li><p>
d
</p>

<p>
仅当窗口被专用绑定到当前缓冲区时才会显示。若为强专用绑定，显示为大写字母 'D'；若为其他类型的专用绑定，显示为小写字母 'd'；若窗口未被专用绑定，则不显示该字符。详见《<a href="https://www.gnu.org/software/emacs/manual/elisp.html">Emacs Lisp 参考手册</a>》中关于专用窗口的内容。
</p>

<p>
若你按下 <code>M-x a u TAB</code> ，此时 TAB 键会查找以 “au” 开头的补全候选项。
</p>

<div class="org-src-container">
<pre class="src src-shell">U:**-  *Completions* All L1 (Completion List)
</pre>
</div></li>

<li><p>
fr
</p>

<p>
代表当前选中框架的名称（详见 “<a href="#Frames">框架与图形化显示</a>” 章节），仅在文本终端中显示。初始框架的名称为 'F1'。
</p></li>

<li><p>
buf
</p>

<p>
是窗口中显示的缓冲区名称，通常与你正在编辑的文件名一致。详见 “<a href="#Buffers">使用多缓冲区</a>” 章节。
</p></li>

<li><p>
pos
</p>

<p>
用于提示窗口外的文本位置情况：若缓冲区内容较少且全部能在窗口中显示，会显示 'All'；若当前查看的是缓冲区开头部分，显示 'Top'；若查看的是末尾部分，显示 'Bot'；其他情况则显示 'nn%'，其中 'nn' 代表窗口上方的内容占整个缓冲区的百分比。启用 <code>size-indication-mode</code> 后，还可以在模式行中显示缓冲区的大小。详见 “<a href="#Optional-Mode-Line">可选模式行功能</a>” 章节。
</p></li>

<li><p>
line
</p>

<p>
格式为字母 'L' 后接光标位置对应的行号。（启用 列号模式(<code>column-number-mode</code>) 后，还可以显示当前光标所在的列数。详见 “<a href="#Optional-Mode-Line">可选模式行功能</a>” 章节）。
</p></li>

<li><p>
(major minor)
</p>

<ul class="org-ul">
<li>major 代表缓冲区使用的 <code>主模式</code> 名称。主模式是缓冲区的核心编辑模式，例如文本模式、Lisp 模式、C 语言模式等。详见 “<a href="#Major-Modes">主模式</a>” 章节。部分主模式还会在名称后显示额外状态信息，例如编译缓冲区和 Shell 缓冲区会显示子进程的运行状态。</li>

<li>minor 列出当前启用的部分 <code>次模式</code> 。次模式是可选的编辑模式，能够在主模式的基础上提供额外功能。详见 “<a href="#Minor-Modes">次模式</a>“ 章节。</li>
</ul>

<p>
此外，部分功能即便不属于真正的次模式，只要处于开启状态，也会和次模式一同显示在该区域：
</p>

<ul class="org-ul">
<li>Narrow：表示当前缓冲区的编辑范围被限定在部分文本内容中（详见 “<a href="#Narrowing">范围限定</a>” 章节）。</li>

<li>Def：表示正在定义键盘宏（详见 “<a href="#Keyboard-Macros">键盘宏</a>” 章节）。</li>
</ul></li>
</ul>

<p>
补充说明
</p>

<p>
若 Emacs 处于 <code>递归编辑层级</code> ，包裹模式名称的圆括号会被方括号（[…]）包围；如果处于多层递归编辑状态，会显示双层方括号，以此类推。由于递归编辑层级是全局生效的，因此所有窗口的模式行都会显示对应的方括号标识。详见 “<a href="#Recursive-Edit">递归编辑层级</a>” 章节。
</p>

<p>
你既可以修改模式行(mode line)的外观样式，也可以调整其内容格式，具体方法详见 “<a href="#Optional-Mode-Line">可选模式行功能</a>” 章节。此外，模式行支持鼠标交互：点击模式行的不同区域可以执行对应的命令（详见 “<a href="#Mode-Line-Mouse">模式行鼠标命令</a>” 章节）；将鼠标悬停在模式行的交互区域时，还会弹出工具提示框，显示该区域可触发的命令说明（详见 “<a href="#Tooltips">工具提示</a>” 章节）。
</p>
</div>
</div>
<div id="outline-container-Menu-Bar" class="outline-3">
<h3 id="Menu-Bar"><span class="section-number-3">1.4.</span> 菜单栏（Menu Bar）</h3>
<div class="outline-text-3" id="text-Menu-Bar">
<p>
每个 Emacs 框架(frame)的顶部通常都会有一个菜单栏(menu bar)，你可以通过它执行各类常用操作。此处无需逐一列举这些操作，你自行查看会更为直观。
</p>

<p>
在支持鼠标的显示器上，你可以用鼠标从菜单栏中选择命令。菜单项右侧边缘的箭头，表示该选项会展开一个子菜单(submenu)；菜单项(menu item)末尾带有 '&#x2026;' 时，意味着执行该命令前，程序会提示你输入更多信息。
</p>

<p>
菜单栏中的部分命令同时配有常规的快捷键绑定(key bindings)；若存在快捷键，会直接显示在对应菜单项的后方。若要查看某菜单项对应的完整命令名称及文档说明，可按下快捷键 <code>C-h k</code> ，随后按照常规方式用鼠标选中该菜单项即可（详见 “<a href="#Key-Help">快捷键文档查询</a>” 章节）。
</p>

<p>
除了使用鼠标，你也可以按下功能键 F10 来激活菜单栏的首个选项（该操作会执行 menu-bar-open 命令）。激活后，你可以通过方向键，或是快捷键 C-b（左）、C-f（右）、C-p（上）、C-n（下）来浏览菜单。按下回车键（RET）即可执行选中的菜单项；按下 <code>C-g</code> 或连续三次按下 <code>ESC</code> 键可退出菜单浏览模式。（注意：如果 Emacs 是基于图形界面工具包编译的，菜单的绘制与控制将由该工具包接管，此时退出菜单浏览模式的快捷键序列可能与上文描述不同。）
</p>

<p>
在文本终端中，你可以选择在回显区(echo area)中访问菜单栏(menu-bar)。要实现此功能，需将变量 <code>tty-menu-open-use-tmm</code> 自定义设置为非空值（non-nil）。完成设置后，按下 <code>F10</code> 键将执行 <code>tmm-menubar</code> 命令，而非直接展开菜单。（你也可以按下 <code>M-`</code> 组合键，该快捷键始终会调用 <code>tmm-menubar</code> 命令。） <code>tmm-menubar</code> 命令支持通过键盘选择菜单项，选中的候选选项会显示在回显区中。你可以使用上下方向键在菜单中切换不同选项，按下回车键确认选择。此外，每个菜单项都会分配一个字母或数字作为快捷选择符（通常取自菜单项名称中的某个单词首字母），该字符与菜单项名称之间用 '==&gt;' 分隔，直接输入对应的字母或数字即可快速选中目标菜单项。
</p>
</div>
</div>
</section>
<section id="outline-container-User-Input" class="outline-2">
<h2 id="User-Input"><span class="section-number-2">2.</span> 用户输入类型</h2>
<div class="outline-text-2" id="text-User-Input">
<p>
GNU Emacs 主要为 <b>键盘操作</b> 而设计。尽管你可以通过鼠标点击菜单栏和工具栏来执行编辑命令，但这种方式的效率通常不如键盘操作高。
</p>

<p>
Emacs 的键盘输入基于一套 <b>高度扩展的 ASCII 字符集</b> 。普通字符（例如 a、B、3、= 以及空格字符(记为 SPC)）可直接敲击对应按键输入。控制字符（例如回车键 RET、制表符 TAB、删除键 DEL、退出键 ESC、功能键 F1、主页键 Home 以及左方向键 LEFT）同样通过这种方式输入，非英语键盘上的特定字符也是如此（详见 “<a href="#International">国际字符集支持</a>” 章节）。
</p>

<p>
Emacs 同样支持通过 <b>修饰键(modifier keys)</b> 输入控制字符。两种最常用的修饰键分别是 <b>Control 键</b> （通常标注为 Ctrl）与 <b>Meta 键</b> （通常标注为 Alt） <sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup>。例如，输入 Control-a 的操作是按住 Ctrl 键的同时按下 a 键，我们将其简写为 C-a。同理，Meta-a（简写为 M-a）的输入方式是按住 Alt 键并按下 a 键。修饰键也可搭配非字母数字类字符使用，例如 C-F1 或 M-LEFT。
</p>

<p>
你也可以通过以 <b>ESC 开头的双字符序列</b> 来输入 Meta 字符。例如，输入 <code>ESC</code> 后再按下 a，等效于输入 <code>M-a</code> ；输入 <code>ESC</code> 后再按下 <code>C-a</code> ，等效于输入 <code>C-M-a</code> （即同时按住 Ctrl 键和 Alt 键，再按下 a 键）。与  <code>Meta</code> 键的操作方式不同， <code>ESC</code> 键需要作为独立字符输入：输入时无需按住 <code>ESC</code> 键再敲击后续字符，而是先按下并松开 <code>ESC</code> 键，之后再输入目标字符。该功能在部分 <code>Meta</code> 键工作不稳定的文本终端中十分实用。
</p>

<p>
Emacs 还支持另外 3 种修饰键，详见 “<a href="#Modifier-Keys">修饰键</a>” 章节。
</p>

<p>
Emacs 对鼠标按键、鼠标滚轮，以及触控板、触摸屏等其他指针设备也提供了完善的支持，具体细节请参阅 “<a href="#Mouse-Input">鼠标输入</a>” 章节。
</p>

<p>
在图形化显示器中，窗口管理器可能会 <b>拦截部分键盘输入</b> ，包括 <code>M-TAB</code> 、 <code>M-SPC</code> 、 <code>C-M-d</code> 和 <code>C-M-l</code> 。若遇到此类问题，你可以通过自定义窗口管理器设置，使其不再拦截这些按键；也可以重新绑定受影响的 Emacs 命令（详见 “<a href="#Customization">自定义</a>” 章节）。
</p>

<p>
普通字符、控制字符，以及鼠标点击等非键盘输入，在 Emacs 中统称为 <b>输入事件</b> 。关于 Emacs 内部如何处理输入事件的详细说明，参见《Emacs Lisp 参考手册》中的 “<a href="elisp.html#Input-Events">输入事件</a>” 章节。
</p>
</div>
</section>
<section id="outline-container-Keys" class="outline-2">
<h2 id="Keys"><span class="section-number-2">3.</span> 按键（Keys）</h2>
<div class="outline-text-2" id="text-Keys">
<p>
部分 Emacs 命令仅需一个输入事件即可调用；例如， <code>C-f</code> 可在缓冲区中向前移动一个字符。另一些命令则需要两个或更多输入事件才能调用，比如 <code>C-x C-f</code> 与 <code>C-x 4 C-f</code> 。
</p>

<p>
<b>按键序列</b> （简称按键）是指一组具有独立意义的一个或多个输入事件。若某一按键序列可以调用命令，则称之为 <b>完整按键(complete key)</b> ；例如， <code>C-f</code> 、 <code>C-x C-f</code> 和 <code>C-x 4 C-f</code> 均属于完整按键。若某一按键序列长度不足以调用命令，则称之为 <b>前缀按键(prefix keys)</b> ；从上述示例可知， <code>C-x</code> 和 <code>C-x 4</code> 均为前缀按键。所有按键序列要么是完整按键，要么是前缀按键。
</p>

<p>
前缀按键可与后续输入事件组合，形成更长的按键序列。例如， <code>C-x</code> 属于前缀按键，因此单独按下 <code>C-x</code> 并不会调用命令；相反，Emacs 会等待后续输入（若停顿超过一秒，它会回显 <code>C-x</code> 按键以提示用户输入后续内容，详见《<a href="#Echo-Area">回显区</a>》章节）。 <code>C-x</code> 与下一个输入事件组合后，会生成一个双事件按键序列，该序列本身既可以是前缀按键（如 <code>C-x 4</code> ），也可以是完整按键（如  <code>C-x C-f</code> ）。按键序列的长度没有限制，但实际使用中很少超过三到四个输入事件。
</p>

<p>
无法在完整按键后追加输入事件。例如，由于 <code>C-f</code> 是完整按键，双事件序列 <code>C-f C-k</code> 会被视为两个独立的按键序列，而非一个。
</p>

<p>
默认情况下，Emacs 中的前缀按键(prefix keys)包括 C-c、C-h、C-x、C-x RET、C-x @、C-x a、C-x n、C-x r、C-x t、C-x v、C-x 4、C-x 5、C-x 6、ESC 和 M-g。（F1 和 F2 分别是 C-h 和 C-x 6 的别名）。该列表并非固定不变；用户可通过自定义 Emacs 来创建新的前缀按键，甚至可以移除部分标准前缀按键，但 <b>不建议多数用户这样操作</b> ；例如，若移除 <code>C-x 4</code> 的前缀定义，那么 <code>C-x 4 C-f</code> 将变成无效的按键序列。详见《<a href="#Key-Bindings">自定义按键绑定</a>》章节。
</p>

<p>
在按下前缀按键后，再按下帮助字符（ <code>C-h</code> 或 <code>F1</code> ），会显示所有以此前缀开头的命令列表。此规则有一个例外： <code>ESC C-h</code> 等价于 <code>C-M-h</code> ，二者功能完全不同。不过，用户可以使用 <code>F1</code> 来查看所有以 <code>ESC</code> 开头的命令列表，即 <code>ESC F1</code> 。
</p>
</div>
</section>
<section id="outline-container-Mouse-Input" class="outline-2">
<h2 id="Mouse-Input"><span class="section-number-2">4.</span> 鼠标输入</h2>
<div class="outline-text-2" id="text-Mouse-Input">
<p>
默认情况下，Emacs 支持所有常规鼠标操作，例如单击鼠标左键定位光标、拖动鼠标指针选中区域。所有鼠标操作都可用于绑定命令，绑定方式与将命令绑定到键盘事件的方式完全相同（详见《<a href="#Keys">按键</a>》章节）。本节概述 Emacs 中的鼠标使用方法；关于 Emacs 鼠标命令的更多细节，可参考《<a href="#Mouse-Commands">用于编辑的鼠标命令</a>》及其后续章节。
</p>

<p>
单击鼠标左键时，Emacs 会接收到 <code>mouse-1</code> 事件。若要查看该事件绑定的命令，你可以按下 <code>C-h c</code> ，随后单击鼠标左键。同理，鼠标中键对应的事件为 <code>mouse-2</code> ，鼠标右键对应的事件为 <code>mouse-3</code> 。如果你的鼠标带有滚轮，滚轮事件通常会被绑定为 <code>wheel-down</code> （滚轮向下）、 <code>wheel-up</code> （滚轮向上），或  <code>mouse-4</code> 、 <code>mouse-5</code> ，具体取决于操作系统的配置。
</p>

<p>
通常而言，旧式 X 系统与终端（详见《<a href="#Text_002dOnly-Mouse">在文本终端中使用鼠标</a>》）会上报 <code>mouse-4</code> 和 <code>mouse-5</code> 事件，其他所有系统则会上报 <code>wheel-down</code> 和 <code>wheel-up</code> 事件。
</p>

<p>
部分鼠标还配备了水平滚轮，触控板一般也支持水平滚动功能。在终端与旧式 X 系统之外的所有系统中，这类事件会被上报为 <code>wheel-left</code> （向左滚动）和 <code>wheel-right</code> （向右滚动）；而在终端与旧式 X 系统中，对应的事件名称为 <code>mouse-6</code> 和 <code>mouse-7</code> 。
</p>

<p>
你也可以将键盘修饰键与鼠标事件组合使用，例如，你可以绑定一个特殊命令，使其在按住 Meta 键并单击鼠标中键时触发。这种情况下，对应的事件名称为 <code>M-mouse-2</code> 。
</p>

<p>
在部分系统中，你还可以为触屏事件绑定处理命令。此类事件的名称为 <code>touchscreen-update</code> （触屏更新）与 <code>touchscreen-end</code> （触屏结束）。
</p>
</div>
</section>
<section id="outline-container-Commands" class="outline-2">
<h2 id="Commands"><span class="section-number-2">5.</span> 按键与命令</h2>
<div class="outline-text-2" id="text-Commands">
<p>
本手册中多处会介绍特定按键的功能，但 Emacs 并非直接为按键赋予含义，而是先为 <b>命名命令</b> 定义功能，再通过 <b>按键绑定</b> 的方式，将按键与命令关联，以此赋予按键对应的作用。
</p>

<p>
每个命令都有一个由程序员定义的名称，这类名称通常由若干英文单词通过连字符连接而成，例如 <code>next-line</code> （下移一行）或 <code>forward-word</code> （前移一词）。在 Emacs 内部，每个命令本质上是一种特殊的 Lisp 函数，命令对应的具体操作，都是通过执行该函数来完成的。相关内容可参见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/What-Is-a-Function.html#What-Is-a-Function">什么是函数</a>》章节。
</p>

<p>
按键与命令之间的绑定关系，会被记录在名为 <b>键映射表（keymaps）</b> 的表格中，详见《<a href="#Keymaps">键映射表</a>》章节。
</p>

<p>
当我们说 “快捷键 <code>C-n</code> 可实现垂直向下移动一行” 时，其实是简化了一个在日常使用中无需关注、但对 Emacs 定制至关重要的细节：真正执行 “垂直向下移动” 操作的是命令 <code>next-line</code> ， <code>C-n</code> 之所以能实现该功能，是因为它被绑定到了 <code>next-line</code> 命令上。如果你将 <code>C-n</code> 重新绑定到 <code>forward-word</code> 命令，那么此后按下 <code>C-n</code> 时，光标就会向前移动一个单词，而非向下移动一行。
</p>

<p>
在本手册中，我们常会将 <code>C-n</code> 这类按键直接称作 “命令”，但严格来说，按键只是被绑定到了对应的命令上。 一般情况下，我们会在提及触发命令的按键后，用 <b>括号</b> 标注出真正执行操作的命令名称。例如，“命令 <code>C-n</code> (<code>next-line</code>) 可使光标垂直向下移动”，这句话的含义是： <code>next-line</code> 命令的功能是让光标垂直下移，而快捷键 <code>C-n</code> 默认与该命令绑定。
</p>

<p>
既然我们正在讨论定制相关的内容，就需要向你介绍 <b>变量</b> 的概念。在对命令的描述中，你常会看到这样的表述：“若要修改此功能，请设置变量 <code>mumble-foo</code> ”。变量是用于存储数值的命名标识符，本手册中介绍的大部分变量都支持用户定制：Emacs 的部分命令或功能模块会读取这些变量的值，并根据你设定的数值调整自身的行为逻辑。在你暂时没有定制需求时，可以忽略这些变量相关的内容；当你需要进行定制时，先阅读《<a href="#Variables">变量</a>》章节的基础内容，再查看各具体变量的说明，就能理解其作用了。
</p>
</div>
</section>
<section id="outline-container-Other-Input" class="outline-2">
<h2 id="Other-Input"><span class="section-number-2">6.</span> 触摸屏输入与虚拟键盘</h2>
<div class="outline-text-2" id="text-Other-Input">
<p>
Emacs 最初的设计，默认其用户是在台式计算机或计算机终端上使用它，这类设备会配备键盘，或许还会搭配鼠标这类合适的指针设备（参见《<a href="#Mouse-Input">鼠标输入</a>》章节）。
</p>


<p>
Emacs 同样支持接收来自其他输入设备的指令，即使用户将它安装在那些用其他输入方式、取代了传统 “键盘 + 鼠标” 组合的计算机上，也能顺畅地与之交互。
</p>

<ul class="org-ul">
<li><a href="#Touchscreens">触摸屏上使用 Emacs</a></li>
<li><a href="#On_002dScreen-Keyboards">搭配虚拟键盘使用 Emacs</a></li>
</ul>
</div>
<div id="outline-container-Touchscreens" class="outline-3">
<h3 id="Touchscreens"><span class="section-number-3">6.1.</span> 触摸屏上使用 Emacs</h3>
<div class="outline-text-3" id="text-Touchscreens">
<p>
触摸屏输入，是指通过手指、手写笔等操控工具，在显示 Emacs 窗口的显示器或计算机终端上执行点触、移动等操作，以此对窗口内的内容进行控制。
</p>

<p>
系统会将操控工具的 <b>点触顺序</b> 与 <b>位置</b> 这两个要素，和预先定义好的操作模式（称为 “手势”）进行比对，一旦匹配成功，就会在操控工具下方的文本区域执行该手势对应的一系列操作。目前 Emacs 支持识别的手势包括以下几种：
</p>

<ul class="org-ul">
<li><p>
轻点（Tapping）
</p>

<p>
快速点触屏幕后抬起操控工具，该操作会选中被点触的窗口，并执行该窗口内此位置上绑定到 <code>mouse-1</code> 的命令。如果该位置存在链接（参见《<a href="#Mouse-References">使用鼠标跳转至引用内容</a>》章节），Emacs 会直接跳转至该链接（此行为与模拟 <code>mouse-1</code> 事件的操作有所区别）。
</p></li>

<li><p>
滚动（Scrolling）
</p>

<p>
在屏幕上执行垂直或水平方向的连续移动，窗口会以操控工具初始位置为基准，朝着移动的方向滚动内容。用户可通过配置选项 <code>touch-screen-enable-hscroll</code> ，控制该手势是否触发水平滚动功能（参见《<a href="#Horizontal-Scrolling">水平滚动</a>》章节）。
</p></li>

<li><p>
拖拽（Dragging）
</p>

<p>
长按屏幕（将操控工具置于屏幕上并保持片刻）后再移动到其他位置，该操作会将光标移动到操控工具的初始位置，且在移动过程中选中工具下方的文本，效果等同于按住鼠标左键并拖动鼠标。相关内容可参见《<a href="#Mouse-Commands">用于编辑的鼠标命令</a>》章节。
</p>

<p>
在触摸屏上精确定位操控工具存在一定难度，这会对文本选中操作造成影响。启用用户配置选项 <code>touch-screen-word-select</code> 后，拖拽操作会自动选中操控工具下方的 <b>完整单词</b> （默认情况下，选中范围仅会扩展至工具下方的单个字符）。
</p>

<p>
同理，单次手势操作有时难以精准选中目标文本的全部内容。若启用用户配置选项 <code>touch-screen-extend-selection</code> ，在窗口内的光标或选区标记位置轻点，即可启动一次新的 “拖拽” 手势，后续的移动操作会沿着移动方向扩展选区范围。
</p>

<p>
操控工具在屏幕上的遮挡，可能会导致用户难以精准调整选区范围，而在回显区显示光标位置可缓解这一问题。当变量 <code>touch-screen-preview-select</code> 的值非空时，在操控工具移动过程中，回显区（参见《<a href="#Echo-Area">回显区</a>》章节）会显示光标所在行的内容，下方还会额外显示一行，用于标注光标在该行内的相对位置。
</p></li>

<li><p>
捏合（Pinching）
</p>

<p>
将两个操控工具分开放置在屏幕上，再通过调整二者位置来增大或缩小间距，文本缩放比例（参见《<a href="#Text-Scale">文本缩放</a>》章节）会随间距的变化比例同步调整。
</p></li>
</ul>

<p>
当操控工具在屏幕上的停留时间超过 0.7 秒时，Emacs 会判定为一次长按操作。用户可通过自定义变量 <code>touch-screen-delay</code> ，调整该判定延迟的时长。
</p>
</div>
</div>
<div id="outline-container-On_002dScreen-Keyboards" class="outline-3">
<h3 id="On_002dScreen-Keyboards"><span class="section-number-3">6.2.</span> 搭配虚拟键盘使用 Emacs</h3>
<div class="outline-text-3" id="text-On_002dScreen-Keyboards">
<p>
当系统未连接物理键盘时，其窗口系统可能会提供一款屏幕内置的键盘 —— 即广泛使用的 <b>虚拟键盘(virtual keyboard)</b> 。该键盘包含多行可点击的按键，能够像实体键盘一样，向应用程序传递键盘输入指令。
</p>

<p>
由于虚拟键盘会占用宝贵的屏幕空间，因此当获得焦点的程序未请求文本输入时，虚拟键盘会处于隐藏状态。这就要求各类程序在准备好接收键盘输入后，主动将虚拟键盘调出。运行于 X 窗口系统的设备，会自动判断是否需要显示虚拟键盘；但在安卓等其他系统中，显示虚拟键盘的任务则由 Emacs 负责，触发场景通常为 <b>触摸屏轻点手势</b> （参见《<a href="#Touchscreens">在触摸屏上使用 Emacs</a>》章节），或是迷你缓冲区被调用时（参见《<a href="#Minibuffer">迷你缓冲区</a>》章节）。
</p>

<p>
当轻点手势触发某条命令执行时，Emacs 会在列表 <code>touch-screen-set-point-commands</code> 中检索该命令，以此判断它是否用于设置光标位置。若该命令存在于列表中，且新光标位置对应的文本并非只读状态，Emacs 会激活虚拟键盘，以便用户输入内容。
</p>

<p>
<code>touch-screen-set-point-commands</code> 的默认值仅包含命令 <code>mouse-set-point</code> （参见《<a href="#Mouse-Commands">用于编辑的鼠标命令</a>》章节），该命令是 <code>mouse-1</code> 的默认绑定命令，同时也是触摸屏轻点手势对应的默认命令。
</p>

<p>
用户配置选项 <code>touch-screen-display-keyboard</code> 可强制 Emacs 在 <b>所有轻点手势触发时都显示虚拟键盘</b> ，即便对应文本处于只读状态；该选项也支持局部缓冲区配置，在此情况下，只要轻点显示该缓冲区的窗口，Emacs 就会自动调出虚拟键盘。
</p>

<p>
除此之外，Emacs 还提供了若干用于显示或隐藏虚拟键盘的函数，具体细节可参见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/On_002dScreen-Keyboards.html#On_002dScreen-Keyboards">屏幕内置键盘</a>》章节。
</p>

<p>
由于 Emacs 在执行命令期间，可能无法调出虚拟键盘，因此它在那些通常不配备物理键盘的窗口系统中，实现了一项特殊功能：双击设备上始终存在的某个硬件按键，即可触发退出操作。相关内容可参见《<a href="#Quitting">退出与终止</a>》章节。
</p>

<p>
X 窗口系统默认未启用此类按键，但用户可通过变量 <code>x-quit-keysym</code> 进行配置；在安卓系统中，默认的触发按键为音量减小键，用户同样可通过变量 <code>android-quit-keycode</code> 对其进行修改。
</p>

<p>
大多数为虚拟键盘设计的输入法，其文本编辑逻辑与桌面端输入法存在差异。
</p>

<p>
在传统桌面窗口系统中，输入法会直接在屏幕上显示正在输入的字符内容，待用户确认后，再将对应的按键事件发送给 Emacs。
</p>

<p>
与之不同的是，虚拟键盘输入法会 <b>直接对各窗口帧的活动窗口执行文本编辑操作</b> ，这种方式在 X 窗口系统中被称为 <b>文本转换</b> 或 <b>字符串转换</b> 。
</p>

<p>
只要局部缓冲区变量 <code>text-conversion-style</code> 的值非空，Emacs 就会启用这类输入法，这一机制通常适用于 <code>text-mode</code> （文本模式）与 <code>prog-mode</code> （编程模式）的派生模式。
</p>

<p>
文本转换操作的执行是异步的：当 Emacs 收到输入法的转换请求，且当前未处于 “已读取前缀按键、等待完整按键序列” 的状态时（参见《<a href="#Keys">按键</a>》章节），就会触发文本转换。转换完成后，系统会发送一个 <code>text-conversion</code> 事件，具体可参见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Misc-Events.html#Misc-Events">杂项事件</a>》章节。
</p>

<p>
若输入法需要对缓冲区中的某一区域进行处理，该区域会被标记为 <b>待转换区域*（或 *称预处理区域</b> ）。变量 <code>text-conversion-face</code> 用于控制是否使用特殊的字体样式显示该区域，若启用，则可指定具体的字体样式。
</p>
</div>
</div>
</section>
<section id="outline-container-Entering-Emacs" class="outline-2">
<h2 id="Entering-Emacs"><span class="section-number-2">7.</span> 启动 Emacs</h2>
<div class="outline-text-2" id="text-Entering-Emacs">
<p>
调用 Emacs 的常规方式是在 Shell 中执行命令 <code>emacs</code> 。在图形界面终端中运行 Unix Shell 时，你可以通过 <code>emacs &amp;</code> 在后台启动 Emacs，这种方式不会占用终端窗口，你仍然可以在终端中执行其他 Shell 命令。（在微软视窗系统中启动 Emacs 的类似方法，参见《<a href="#Windows-Startup">微软视窗系统下的 Emacs 启动方式</a>》章节）。
</p>

<p>
Emacs 启动后，初始窗口会显示一个名为 <code>*GNU Emacs*</code> 的特殊缓冲区。这个启动界面包含了关于 Emacs 的介绍信息，以及对新手用户实用的常用任务链接。例如，激活 “Emacs Tutorial” 链接会打开 Emacs 教程，其功能等同于执行命令 <code>C-h t</code> (<code>help-with-tutorial</code>)。激活链接的方式有两种：一是将光标移至链接处并按下 <code>RET</code> （回车键），二是用 <code>mouse-1</code> (鼠标左键) 点击该链接。
</p>

<p>
你可以通过 <b>命令行参数</b> ，让 Emacs 在启动时直接打开一个或多个文件。例如，执行 <code>emacs foo.txt</code> 会启动 Emacs，并在缓冲区中显示文件 foo.txt 的内容。该功能主要是为了兼容其他编辑器 —— 这类编辑器通常设计为从 Shell 启动，用于短时间的编辑会话。若以这种方式启动 Emacs，初始窗口会被拆分为两个子窗口：一个显示指定的文件，另一个显示启动界面。相关内容参见《<a href="#Windows">多窗口</a>》章节。
</p>

<p>
通常情况下，每次编辑文件都重新启动 Emacs 既无必要，也会造成资源浪费。推荐的使用方式是：登录系统后只启动一次 Emacs，所有的编辑工作都在同一个 Emacs 会话中完成。关于打开多个文件的方法，参见《<a href="#Files">文件处理</a>》章节。采用这种方式使用 Emacs 时，会话会累积大量实用的上下文信息，例如 <b>king ring(剪切环)</b> 、 <b>registers(寄存器)</b> 、 <b>undo history(撤销历史)</b> 和 <b>mark ring data(标记环数据)</b> ，这些功能会让编辑操作更加便捷，本手册后续章节会对其进行详细介绍。
</p>

<p>
当 Emacs 处于运行状态时，若想从其他程序中编辑文件，你可以借助辅助程序 <code>emacsclient</code> ，在已有的 Emacs 会话中打开目标文件。相关内容参见《<a href="#Emacs-Server">将 Emacs 用作服务器</a>》章节。
</p>

<p>
Emacs 支持其他类型的命令行参数，例如指定加载特定的 Lisp 文件、设置初始窗口的位置等。具体内容参见《<a href="#Emacs-Invocation">Emacs 启动命令行参数</a>》章节。
</p>

<p>
若变量 <code>inhibit-startup-screen</code> 的值非空，Emacs 将不会显示启动界面。这种情况下，如果命令行中指定了一个或多个文件，Emacs 会直接显示这些文件；反之，会打开一个名为 <code>*scratch*</code> 的缓冲区，你可以在该缓冲区中交互式地执行 Emacs Lisp 表达式。相关内容参见《<a href="#Lisp-Interaction">Lisp 交互缓冲区</a>》章节。你可以通过 <b>自定义功能</b> （参见《<a href="#Easy-Customization">简易自定义界面</a>》章节），或编辑初始化文件（参见《<a href="#Init-File">Emacs 初始化文件</a>》章节）来设置 <code>inhibit-startup-screen</code> 的值 <sup><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink">4</a></sup>。
</p>

<p>
你也可以通过设置变量 <code>initial-buffer-choice</code> ，强制 Emacs 在启动时显示指定的文件或目录 —— 只需将该变量的值设为对应文件或目录的路径字符串即可。 <code>initial-buffer-choice</code> 的值也可以是一个无参函数，该函数需要返回一个缓冲区供 Emacs 显示。若 <code>initial-buffer-choice</code> 的值非空，即便命令行中指定了文件，Emacs 仍会加载这些文件，但不会在启动时直接显示。
</p>
</div>
</section>
<section id="outline-container-Exiting" class="outline-2">
<h2 id="Exiting"><span class="section-number-2">8.</span> 退出 Emacs</h2>
<div class="outline-text-2" id="text-Exiting">
<dl class="org-dl">
<dt><code>C-x C-c</code></dt><dd>退出 Emacs（执行 <code>save-buffers-kill-terminal</code> 命令）。</dd>

<dt><code>C-z</code></dt><dd>在文本终端中，挂起 Emacs；在图形界面中，将选中的窗口图标化（或 “最小化”）（执行 <code>suspend-frame</code> 命令）。</dd>
</dl>

<p>
退出 Emacs 即终止 Emacs 程序。操作方法为按下 <code>C-x C-c</code> (<code>save-buffers-kill-terminal</code>)。采用双字符按键序列是为了防止误触。若按下该组合键时，存在任何已修改但未保存的文件缓冲区，Emacs 会首先提示你保存这些缓冲区。若你未将所有缓冲区保存，程序会再次请求确认，因为未保存的修改将会丢失。此外，若仍有子进程在运行，Emacs 也会要求确认退出操作 —— 退出 Emacs 的同时会终止这些子进程（参见《<a href="#Shell">从 Emacs 执行 Shell 命令</a>》章节）。
</p>

<p>
若你将 Emacs 用作服务器， <code>C-x C-c</code> 的行为会略有不同。在客户端窗口中按下该组合键，只会关闭对应的客户端连接。详见《<a href="#Emacs-Server">将 Emacs 用作服务器</a>》章节。
</p>

<p>
你可以选择让 Emacs 在退出时记录特定的会话信息，例如当前打开的文件。这些信息会在下次启动 Emacs 时生效。详见《<a href="#Saving-Emacs-Sessions">保存 Emacs 会话</a>》章节。
</p>

<p>
若变量 <code>confirm-kill-emacs</code> 的值为非 nil，按下 <code>C-x C-c</code> 时，Emacs 会将该变量的值视作一个断言函数并调用它。若函数返回值为非 nil，则终止当前会话；反之，Emacs 会继续运行。将函数 <code>yes-or-no-p</code> 设为 <code>confirm-kill-emacs</code> 的值是一种便捷的用法。该变量的默认值为 <code>nil</code> 。
</p>

<p>
若变量 <code>confirm-kill-processes</code> 的值为 <code>nil</code> ，Emacs 在终止其启动的子进程前不会请求确认。该变量的默认值为 <code>t</code> 。
</p>

<p>
若需进一步自定义 Emacs 的退出行为，请参见《GNU Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Killing-Emacs.html#Killing-Emacs">退出 Emacs</a>》章节。
</p>

<p>
若需直接退出 Emacs 且不弹出保存提示，可执行命令 <code>M-x kill-emacs</code> 。
</p>

<p>
<code>C-z</code> 对应命令 <code>suspend-frame</code> 。在图形界面中，该命令会将选中的 Emacs 窗口最小化（或图标化），隐藏窗口的同时保留恢复的可能（具体隐藏方式取决于对应的窗口系统）。在文本终端中， <code>C-z</code> 会挂起 Emacs，临时暂停程序运行并将控制权交还给父进程（通常为 Shell）；在多数 Shell 环境中，你可以通过命令 <code>%emacs</code> 恢复挂起的 Emacs 进程。
</p>

<p>
文本终端通常会监听一些特殊字符，用于终止或挂起当前运行的程序。但在 Emacs 运行期间，终端的这一功能会被禁用。Emacs 将 <code>C-z</code> 和 <code>C-x C-c</code> 设为退出相关快捷键，灵感源于部分操作系统中用 <code>C-z</code> 和 <code>C-c</code> 终止或暂停程序的设计，但二者仅存在这一设计关联，与操作系统本身的功能并无直接联系。你可以自定义这些按键，将其绑定为任意命令（参见《<a href="#Keymaps">键盘映射</a>》章节）。
</p>
</div>
</section>
<section id="outline-container-Basic" class="outline-2">
<h2 id="Basic"><span class="section-number-2">9.</span> 基本编辑命令</h2>
<div class="outline-text-2" id="text-Basic">
<p>
本节将介绍文本输入、修改以及文件保存的基础操作。如果你是 Emacs 新手，建议先通过按下组合键 <code>C-h t</code> (<code>help-with-tutorial</code>) 运行 Emacs 实践教程。
</p>

<ul class="org-ul">
<li><a href="#Inserting-Text">插入文本</a></li>
<li><a href="#Moving-Point">更改光标位置</a></li>
<li><a href="#Erasing">删除文本</a></li>
<li><a href="#Basic-Undo">撤销更改</a></li>
<li><a href="#Basic-Files">文件操作</a></li>
<li><a href="#Basic-Help">帮助功能</a></li>
<li><a href="#Blank-Lines">空行处理</a></li>
<li><a href="#Continuation-Lines">续行（Continuation Lines）</a></li>
<li><a href="#Position-Info">光标位置信息</a></li>
<li><a href="#Arguments">数字参数（Numeric Arguments）</a></li>
<li><a href="#Repeating">重复执行命令</a></li>
</ul>
</div>
<div id="outline-container-Inserting-Text" class="outline-3">
<h3 id="Inserting-Text"><span class="section-number-3">9.1.</span> 插入文本</h3>
<div class="outline-text-3" id="text-Inserting-Text">
<p>
按下对应按键，即可输入普通可打印字符（例如 a、B、3、=）。输入的字符会被插入到光标位置的缓冲区中，且光标会随文本插入自动后移，始终停留在新插入文本的后方。相关概念详见<a href="#Point">光标</a>章节。
</p>

<p>
按下 <code>RET</code> 回车键(<code>newline</code>)可以换行并开始新的一行。（你的键盘上 <code>RET</code> 键可能标注为 <code>Return</code> 、 <code>Enter</code> ，或是一个指向左侧的特殊箭头符号，但本手册统一称其为 <code>RET</code> 。）该命令会在缓冲区中插入一个换行符，随后根据当前主模式自动缩进（详见<a href="#Indentation">缩进</a>章节）。
</p>
<ul class="org-ul">
<li>若光标位于行尾，执行该命令会在当前行下方新建一行空白行，并对新行进行缩进；</li>
<li>若光标位于行中间，则会在光标位置将当前行拆分为两行，并缩进新行。</li>
<li>如需关闭自动缩进功能，你可以选择禁用 Electric Indent 模式（详见<a href="#Indent-Convenience">缩进便捷功能</a>章节），或是按下 <code>C-j</code> 键 —— 该快捷键仅插入换行符，不会触发自动缩进。</li>
</ul>

<p>
正如本手册后续章节所述，你可以通过开启次要模式（minor mades）来修改 Emacs 的文本插入行为。例如：
</p>
<ul class="org-ul">
<li>自动换行模式（Auto Fill mode） 会在文本行过长时自动换行（详见<a href="#Filling">文本填充</a>章节）；</li>
<li>覆盖模式（Overwrite mode） 会让新输入的字符覆盖原有文本，而非将原有文本右移（详见<a href="#Minor-Modes">次要模式</a>章节）。</li>
</ul>

<p>
只有可打印字符能够通过按键直接输入；其他按键仅作为编辑命令触发相应功能，不会插入按键对应的字符。例如，默认情况下按下 <code>DEL</code> 键会执行 <code>delete-backward-char</code> 命令（部分模式会将其绑定为其他命令），而非插入一个字面意义上的 DEL 字符（ASCII 编码为 127）。
</p>

<p>
若要插入非打印字符，或是键盘上没有对应按键的字符，需要先按下 <code>C-q</code> (<code>quoted-insert</code>) 进行转义。 <code>C-q</code> 有两种使用方式：
</p>
<ul class="org-ul">
<li>按下 <code>C-q</code> 后，再按下任意非打印字符（包括 <code>C-g</code> ），即可插入该字符本身。例如 <code>C-q DEL</code> 会插入一个字面意义上的 DEL 字符。</li>
<li>按下 <code>C-q</code> 后，输入一串八进制数字，即可插入对应八进制编码的字符。你可以输入任意位数的八进制数字，遇到非数字字符时，输入序列即终止。
<ul class="org-ul">
<li>若终止符为 <code>RET</code> ，则该 <code>RET</code> 仅用于结束序列，不会额外执行换行操作；</li>
<li><p>
若终止符为其他非数字字符，则该字符会在终止序列后作为普通输入生效。例如，输入 <code>C-q 1 0 1 B</code> 会插入字符 AB（八进制 101 对应 ASCII 字符 A）。
</p>

<p>
注意：在普通的非二进制覆盖模式下，八进制序列输入功能会被禁用。这样设计是为了方便你直接插入数字字符，而非用其覆盖原有文本。
</p></li>
</ul></li>
</ul>

<p>
若你希望使用十进制或十六进制编码（而非八进制）插入字符，可以将变量 <code>read-quoted-char-radix</code> 的值设为 10（十进制）或 16（十六进制）。当基数设为 16 时，字母 a 到 f 会被当作数字的一部分参与编码，且不区分大小写。
</p>

<p>
部分常用的 Unicode 字符可通过以 <code>C-x 8</code> 开头的快捷键插入。例如：
</p>
<ul class="org-ul">
<li>按下 <code>C-x 8 [</code> 会插入左单引号 ‘（Unicode 编码 U+2018，也被称为左弯引号）；</li>
<li>同理， <code>C-x 8 ]</code> 、 <code>C-x 8 {</code> 、 <code>C-x 8 }</code> 会分别插入右单引号 ’、左双引号 “ 和右双引号 ”。</li>
<li>此外，若你的键盘上的 <code>Alt</code> 键可正常工作，按下 <code>Alt+[</code> 等效于 <code>C-x 8 [</code> （插入左单引号），以此类推（除非 <code>Alt</code> 键后紧跟的是 <code>RET</code> 键）。若要查看所有支持 <code>C-x 8</code> 快捷键的字符，可按下 <code>C-x 8 C-h</code> 查询。</li>
</ul>

<p>
你也可以使用命令 <code>C-x 8 RET</code> (<code>insert-char</code>) 插入字符：该命令会通过迷你缓冲区提示你输入目标字符的 Unicode 名称或编码。
</p>
<ul class="org-ul">
<li>输入名称时，命令支持补全功能（详见<a href="#Completion">补全</a>章节）；</li>
<li>输入编码时，需使用十六进制数（Unicode 标准格式），或带基数标识的数字（例如八进制数 <code>#o23072</code> ）。相关规则详见《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Integer-Basics.html#Integer-Basics">整数基础</a>章节。</li>
<li>输入完成后，对应字符会被插入到缓冲区中。</li>
</ul>

<p>
以下几种操作均可插入同一个左单引号 ‘ 字符：
</p>

<div class="org-src-container">
<pre class="src src-shell">C-x 8 RET left single quotation mark RET
C-x 8 RET left sin TAB RET <span style="color: #b22222;">#</span><span style="color: #b22222;">&#21033;&#29992;&#34917;&#20840;&#21151;&#33021;
</span>C-x 8 RET 2018 RET         <span style="color: #b22222;">#</span><span style="color: #b22222;">&#36755;&#20837;&#21313;&#20845;&#36827;&#21046;&#32534;&#30721;&#65289;
</span>C-x 8 [
Alt+[   <span style="color: #b22222;">#</span><span style="color: #b22222;">&#33509; Alt &#38190;&#21487;&#29992;
</span><span style="color: #ff00ff;">`       #&#22312;&#26234;&#33021;&#24341;&#21495;&#27169;&#24335;&#65288;Electric Quote mode&#65289; &#19979;</span>
</pre>
</div>

<p>
在执行 <code>C-q</code> 或 <code>C-x 8 ...</code> 类命令时，可添加数字参数（详见<a href="#Arguments">数字参数</a>章节），指定要插入的字符重复次数。
</p>

<p>
除 <code>C-x 8</code> 外，你还可以通过以下方式插入特殊字符：先按下 <code>C-u C-x \ iso-transl RET</code> 选择对应的临时输入法，随后按下 <code>C-x \ [</code> ，同样可以插入左单引号 ‘（详见<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Select-Input-Method.html#transient-input-method">临时输入法</a>章节）。
</p>

<p>
此外，在部分场景下，即便不使用 <code>C-x 8</code> 类命令，输入特定格式的引号也会自动转换为弯引号：
­ 输入 <code>`like this'</code> （使用反引号和单引号），会自动转换为 <code>‘like this’</code> ；
­ 输入 <code>``like this''</code> （使用双反引号和双单引号），会自动转换为 <code>“like this”</code> 。相关规则详见<a href="#Quotation-Marks">引号格式</a>章节。
</p>
</div>
</div>
<div id="outline-container-Moving-Point" class="outline-3">
<h3 id="Moving-Point"><span class="section-number-3">9.2.</span> 更改光标位置</h3>
<div class="outline-text-3" id="text-Moving-Point">
<p>
若要执行 <b>插入字符之外</b> 的操作，你必须掌握移动光标的方法（详见<a href="#Point">光标</a>章节）。快捷键 <code>C-f</code> 、 <code>C-b</code> 、 <code>C-n</code> 、 <code>C-p</code> 分别用于将光标向右、向左、向下、向上移动。你也可以使用多数键盘上的 <code>arrow keys(方向键)</code> :  <code>RIGHT</code> 、 <code>LEFT</code> 、 <code>DOWN</code> 、和 <code>UP</code> 移动光标，但许多 Emacs 用户认为，方向键的操作效率低于控制键，原因是操作方向键时需要移动手部位置。
</p>

<p>
你还可以点击鼠标左键，将光标移动到点击的位置。Emacs 同时提供了多种功能更丰富的快捷键，可实现光标的灵活移动。
</p>

<dl class="org-dl">
<dt><code>C-f</code></dt><dd>向前移动一个字符 (<code>forward-char</code>)</dd>
<dt><code>RIGHT</code></dt><dd>对应命令 (<code>right-char</code>) 功能与 <code>C-f</code> 类似，但在从右至左排版的段落中行为会有差异（详见<a href="#Bidirectional-Editing">双向文本编辑</a>章节）</dd>
<dt><code>C-b</code></dt><dd>向后移动一个字符 (<code>backward-char</code>)</dd>
<dt><code>LEFT</code></dt><dd>对应命令 (<code>left-char</code>) 功能与 <code>C-b</code> 类似，但在从右至左排版的段落中行为会有差异（详见<a href="#Bidirectional-Editing">双向文本编辑</a>章节）</dd>
<dt><code>C-n</code></dt><dd></dd>

<dt><code>DOWN</code></dt><dd>向下移动一行 (<code>next-line</code>) 。该命令会尽量保持光标水平位置不变，例如若光标初始在某行中间位置，移动后会停在下一行的对应水平位置</dd>
<dt><code>C-p</code></dt><dd></dd>

<dt><code>UP</code></dt><dd>向上移动一行 (<code>previous-line</code>) 。与 <code>C-n</code> 类似，该命令会保持光标在该行的水平位置</dd>
<dt><code>C-a</code></dt><dd></dd>

<dt><code>Home</code></dt><dd>移动到行首 (<code>move-beginning-of-line</code>)</dd>
<dt><code>C-e</code></dt><dd></dd>

<dt><code>End</code></dt><dd>移动到行尾 (<code>move-end-of-line</code>)</dd>
<dt><code>M-f</code></dt><dd>向前移动一个单词 (<code>forward-word</code>)。详见<a href="#Words">单词</a>章节</dd>
<dt><code>C-RIGHT</code></dt><dd></dd>

<dt><code>M-RIGHT</code></dt><dd>功能与 <code>M-f</code> 类似，但在从右至左排版的段落中会向后移动一个单词（详见<a href="#Bidirectional-Editing">双向文本编辑</a>章节）</dd>
<dt><code>M-b</code></dt><dd>向后移动一个单词 (<code>backward-word</code>)。详见<a href="#Words">单词</a>章节</dd>
<dt><code>C-LEFT</code></dt><dd></dd>

<dt><code>M-LEFT</code></dt><dd>功能与 <code>M-b</code> 类似，但在从右至左排版的段落中会向前移动一个单词（详见<a href="#Bidirectional-Editing">双向文本编辑</a>章节）</dd>
<dt><code>M-r</code></dt><dd><p>
在不移动屏幕文本的前提下，将光标定位到窗口内垂直居中行的左边缘；连续重复执行该命令时，光标会按循环顺序依次定位到窗口的首行、末行左边缘，以此类推，对应命令 (<code>move-to-window-line-top-bottom</code>) 。
</p>
<ul class="org-ul">
<li>若带数字参数，则表示将光标定位到从窗口顶部向下数的第 n 行（参数 0 代表窗口首行）；</li>
<li>若参数为负数，则表示从窗口底部向上数的第 n 行（参数 -1 代表窗口末行）。</li>
</ul>

<p>
关于数字参数的更多用法，详见<a href="#Arguments">数字参数</a>章节。
</p></dd>

<dt><code>M-&lt;</code></dt><dd>移动到缓冲区开头 (<code>beginning-of-buffer</code>) 。若带数字参数 <code>n</code> ，则移动到距离缓冲区开头 <code>n/10</code> 比例的位置。在图形界面中，快捷键 <code>C-HOME</code> 等效于此命令。</dd>

<dt><code>M-&gt;</code></dt><dd>移动到缓冲区末尾 (<code>end-of-buffer</code>) 。在图形界面中，快捷键 <code>C-END</code> 等效于此命令。</dd>

<dt><code>C-v</code></dt><dd></dd>


<dt><code>PageDown</code></dt><dd></dd>

<dt><code>next</code> </dt><dd>向下滚动一屏内容，并在需要时将光标移动到屏幕可视区域内 (<code>scroll-up-command</code>)，详见<a href="#Scrolling">滚动</a>章节。</dd>

<dt><code>M-v</code></dt><dd></dd>

<dt><code>PageUp</code></dt><dd></dd>

<dt><code>prior</code></dt><dd>向上滚动一屏内容，并在需要时将光标移动到屏幕可视区域内 (<code>scroll-down-command</code>)，详见<a href="#Scrolling">滚动</a>章节。
<ul class="org-ul">
<li>快捷键命名逻辑：在 Emacs 术语中， <code>prior</code> 对应键盘上的 <code>PageUp</code> 键， <code>next</code> 对应 <code>PageDown</code> 键，两者仅命名不同，功能完全一致。</li>
</ul></dd>

<dt><code>M-g c</code></dt><dd>读取一个数字 <code>n</code> ，并将光标移动到缓冲区的第 <code>n</code> 个字符位置（缓冲区起始位置为 1）。若光标当前位于或紧邻缓冲区中的某个数字，则该数字会作为 <code>n</code> 的默认值，直接按下 <code>RET</code> 回车键即可使用。你也可以通过给 <code>M-g c</code> 添加数字前缀参数的方式指定 n。</dd>

<dt><code>M-g M-g</code></dt><dd></dd>

<dt><code>M-g g</code></dt><dd><p>
读取一个数字 <code>n</code> ，并将光标移动到第 <code>n</code> 行的开头（对应命令 <code>goto-line</code> ，缓冲区首行编号为 1）。若光标当前位于或紧邻缓冲区中的某个数字，则该数字会作为 <code>n</code> 的默认值，直接按下 <code>RET</code> 回车键即可使用。你也可以通过给 <code>M-g M-g</code> 添加数字前缀参数的方式指定 n。若为该命令添加普通前缀参数，其行为会有所不同，详见<a href="#Minibuffer-History">创建与选择缓冲区</a>章节；此外，你也可以使用 <code>goto-line-relative</code> 命令，将光标移动到相对于受限缓冲区可见部分的指定行。
</p>

<p>
<code>goto-line</code> 命令拥有独立的历史记录列表（详见<a href="#Minibuffer-History">迷你缓冲区历史</a>章节）。通过自定义用户选项 <code>goto-line-history-local</code> ，你可以选择让所有缓冲区共享同一历史列表（默认行为），或是为每个缓冲区分别配置独立的历史列表。
</p></dd>

<dt><code>M-g TAB</code></dt><dd>读取一个数字 <code>n</code> ，并将光标移动到当前行的第 <code>n</code> 列（最左侧列编号为 0）。若为该命令添加前缀参数，则直接以参数的数值作为目标列号。</dd>

<dt><code>C-x C-n</code></dt><dd>将光标当前所在列设为当前缓冲区的半永久目标列（对应命令 <code>set-goal-column</code> ）。当半永久目标列生效时， <code>C-n</code> 、 <code>C-p</code> 、 <code>PageUp</code> 和 <code>PageDown</code> 命令在垂直移动光标后，会自动将光标定位到该目标列，或尽可能接近该列的位置。目标列设置会一直生效，直至被手动取消。</dd>

<dt><code>C-u C-x C-n</code></dt><dd>取消半永久目标列设置。此后 <code>C-n</code> 和 <code>C-p</code> 命令会恢复默认行为，即保持光标水平位置不变。</dd>
</dl>

<p>
当缓冲区中的某行文本长度超过窗口宽度时，Emacs 通常会将其拆分为多行显示，这种显示行也被称为 <b>可视行(visul lines)</b> 。为方便操作， <code>C-n</code> 、 <code>C-p</code> 以及方向键 <code>down</code> 、 <code>up</code> 均基于可视行移动光标。若你希望这些命令基于 <b>逻辑行(logical line)</b> （即缓冲区中实际存储的文本行）移动，可将变量 <code>line-move-visual</code> 的值设为 <code>nil</code> ；此时若某一逻辑行被拆分为多行可视行，光标会直接跳过额外的可视行。相关细节详见<a href="#Continuation-Lines">续行</a>章节，变量设置方法详见<a href="#Variables">变量</a>章节。
</p>

<p>
与 <code>C-n</code> 、 <code>C-p</code> 不同，Emacs 中大多数针对行的命令均基于逻辑行(logical lines)执行。例如 <code>C-a</code> (<code>move-beginning-of-line</code> 移动到行首) 和 <code>C-e</code> （ <code>move-end-of-line</code> 移动到行尾）命令，分别作用于逻辑行的开头和结尾。后续遇到基于可视行工作的命令（如 <code>C-n</code> 、 <code>C-p</code> ）时，我们会特别指出。
</p>

<p>
当 <code>line-move-visual</code> 的值为 <code>nil</code> 时，你还可以将变量 <code>track-eol</code> 设为非 nil 值。此时若光标初始位于某逻辑行的行尾，执行 <code>C-n</code> 或 <code>C-p</code> 命令后，光标会移动到下一行或上一行的行尾。该变量的默认值为 <code>nil</code> 。
</p>

<p>
默认情况下，若在缓冲区的最后一行执行 <code>C-n</code> 命令，光标会停在该行末尾不再移动。但如果你将变量 <code>next-line-add-newlines</code> 设为非 nil 值，在缓冲区最后一行执行 <code>C-n</code> 时，Emacs 会自动在末尾新建一行，并将光标移动到新行中。
</p>
</div>
</div>
<div id="outline-container-Erasing" class="outline-3">
<h3 id="Erasing"><span class="section-number-3">9.3.</span> 删除文本</h3>
<div class="outline-text-3" id="text-Erasing">
<dl class="org-dl">
<dt><code>DEL</code></dt><dd></dd>

<dt><code>BACKSPACE</code></dt><dd>删除光标前的字符；若 <b>选区处于激活状态</b> ，则删除选区内的文本 (<code>delete-backward-char</code>)</dd>
<dt><code>Delete</code></dt><dd>删除光标后的字符或 <b>字符簇</b> ；若选区处于激活状态，则删除选区内的文本 (<code>delete-forward-char</code>)</dd>
<dt><code>C-d</code></dt><dd>删除光标后的字符 (<code>delete-char</code>)</dd>
<dt><code>C-k</code></dt><dd>剪切至行尾 (<code>kill-line</code>)</dd>
<dt><code>M-d</code></dt><dd>向前剪切至下一个单词的末尾 (<code>kill-word</code>) 即移除光标右边一整个词</dd>
<dt><code>M-DEL</code></dt><dd></dd>

<dt><code>C-&lt;backspace&gt;</code></dt><dd></dd>

<dt><code>M-BACKSPACE</code></dt><dd>向后剪切至前一个单词的开头 (<code>backward-kill-word</code>)，即移除光标左侧一整个词</dd>
</dl>

<p>
<code>DEL</code> (<code>delete-backward-char</code>) 命令会删除光标前的字符，并将光标及后方所有字符向前移动一位。若光标原本位于行首，执行该命令会删除前一行的换行符，从而将当前行与上一行合并。
</p>

<p>
但如果 <b>选区处于激活状态</b> ，DEL 命令的行为会变为删除选区内的所有文本。关于选区的详细说明，详见<a href="#Mark">标记与选区</a>章节。
</p>

<p>
在大多数键盘上， <code>DEL</code> 键标注的是 <code>BACKSPACE</code> ，但本手册统一称其为 DEL（注意不要与 <code>Delete</code> 键混淆，后文会介绍 <code>Delete</code> 键的功能）。在部分文本终端中，Emacs 可能无法正确识别 <code>DEL</code> 键，若遇到此问题可参考<a href="#DEL-Does-Not-Delete">当 <code>DEL</code> 键无法删除时</a>章节的解决方案。
</p>

<p>
<code>Delete</code> (<code>delete-forward-char</code>) 命令的删除方向与 <code>DEL</code> 相反：它会删除光标后的字符，也就是光标当前所在位置的字符。若光标原本位于行尾，执行该命令会将当前行与下一行合并。和 <code>DEL</code> 命令一样，当选区处于激活状态时，该命令会删除选区内的文本（详见<a href="#Mark">标记与选区</a>章节）。
</p>

<p>
此外，若光标后的字符与后续字符组合成一个 <b>字符簇</b> （即多个字符合并为一个显示单元）， <code>Delete</code> 命令会一次性删除整个字符簇序列。这一点与 <code>DEL</code> 命令不同 —— <code>DEL</code> 命令始终只会删除单个字符，即便该字符属于某个字符簇。
</p>

<p>
<code>C-d</code> (<code>delete-char</code>) 命令同样用于删除光标后的字符，功能与 <code>Delete</code> 键类似，但 <b>该命令不会受选区激活状态的影响</b> ，始终只删除光标后的单个字符。
</p>

<p>
关于上述删除命令的更多详细信息，详见<a href="#Deletion">删除操作</a>章节。
</p>

<p>
<code>C-k</code> (<code>kill-line</code>) 命令用于一次性剪切整行内容。
</p>
<ul class="org-ul">
<li>若在一行文本的开头或中间位置按下 <code>C-k</code> ，该命令会剪切从光标位置到行尾的所有文本；</li>
<li>若在行尾按下 <code>C-k</code> ，该命令会将当前行与下一行合并。</li>
</ul>

<p>
关于 <code>C-k</code> 及相关命令的更多信息，详见<a href="#Killing">剪切与移动文本</a>章节。
</p>
</div>
</div>
<div id="outline-container-Basic-Undo" class="outline-3">
<h3 id="Basic-Undo"><span class="section-number-3">9.4.</span> 撤销更改</h3>
<div class="outline-text-3" id="text-Basic-Undo">
<dl class="org-dl">
<dt><code>C-/</code></dt><dd></dd>

<dt><code>C-x u</code></dt><dd></dd>

<dt><code>C-_</code></dt><dd>撤销一条撤销记录项 —— 通常对应一次命令的操作效果（ <code>undo</code> 撤销功能）。（在纯文本模式的显示终端中，第一个快捷键可能无法使用）</dd>
</dl>

<p>
Emacs 会记录缓冲区文本中发生的所有更改操作，因此你可以撤销近期的修改。这项功能通过 <code>undo</code> 实现，该命令绑定了三组快捷键： <code>C-/</code> 、 <code>C-x u</code> 和 <code>C-_</code> 。默认情况下，执行该命令会撤销上一次的修改操作，并将光标移回修改前的位置。需要注意的是，撤销命令 <b>仅作用于缓冲区的文本更改</b> ，无法用于撤销光标的移动操作。
</p>

<p>
在支持所有按键组合 <code>Control</code> 修饰键的终端上，调用撤销功能最便捷的方式是使用 <code>C-/</code> ，因为该快捷键无需搭配 <code>Shift</code> 键。而在仅支持 ASCII 控制字符的终端中， <code>C-/</code> 这一组合键本身并不存在，但在多数此类终端中，按下 <code>C-/</code> 实际会向 Emacs 发送 <code>C-_</code> 指令；此外还有不少终端允许你在输入 <code>C-_</code> 时省略 Shift 键（等效于按下 <code>C--</code> ），因此这种方式也成了调用撤销功能的便捷选择。
</p>

<p>
尽管每次编辑命令通常会在撤销记录中生成独立的条目，但一些极为简单的命令可能会被合并为一条记录。反之，对于部分复杂命令，一条撤销记录有时仅能覆盖其操作的一部分内容。
</p>

<p>
重复按下 <code>C-/</code> （或其等效快捷键），每一次重复操作都会撤销更早的一项修改，直至撤销记录的上限。若所有已记录的修改操作都已被撤销，撤销命令会输出一条错误提示信息，且不会执行任何操作。
</p>

<p>
如需了解撤销命令的更多详情，请参见《<a href="#Undo">撤销</a>》章节。
</p>
</div>
</div>
<div id="outline-container-Basic-Files" class="outline-3">
<h3 id="Basic-Files"><span class="section-number-3">9.5.</span> 文件操作</h3>
<div class="outline-text-3" id="text-Basic-Files">
<p>
你在 Emacs 缓冲区中输入的文本，仅会在当前 Emacs 会话期间保留。若要将文本永久保存，你必须将其写入 <code>文件</code> 中。
</p>

<p>
假设你的主目录下有一个名为 <code>test.emacs</code> 的文件。若要在 Emacs 中开始编辑该文件，输入以下指令：
</p>

<div class="org-src-container">
<pre class="src src-shell">C-x C-f test.emacs RET
</pre>
</div>

<p>
在此命令中，文件名是作为 <code>C-x C-f</code> (<code>find-file</code>) 命令的参数传入的。该命令会通过 <code>minibuffer迷你缓冲区</code> 读取参数，你需要按下回车键（ <code>RET</code> ）来确认参数输入（详见《<a href="#Minibuffer">迷你缓冲区</a>》章节）。
</p>

<p>
Emacs 执行这条命令的方式是 <code>访问</code> 该文件：它会创建一个新的缓冲区，将文件内容复制到该缓冲区中，随后显示这个缓冲区以供编辑。如果你修改了缓冲区中的文本，可以按下 <code>C-x C-s</code> (<code>save-buffer</code>)，将修改后的内容写回 <code>test.emacs</code> 文件，实现文本的永久保存。在执行保存操作之前，修改后的文本仅存在于 Emacs 缓冲区中，源文件 test.emacs 不会发生任何变化。
</p>

<p>
若要新建一个文件，只需直接使用 <code>C-x C-f</code> 命令访问这个尚不存在的文件即可。此时 Emacs 会创建一个空缓冲区，你可以在其中输入需要写入该文件的文本内容。当你第一次按下 <code>C-x C-s</code> 保存这个缓冲区时，Emacs 才会在系统中实际创建该文件。
</p>

<p>
如需了解在 Emacs 中使用文件的更多详情，请参见《<a href="#Files">文件处理</a>》章节。
</p>
</div>
</div>
<div id="outline-container-Basic-Help" class="outline-3">
<h3 id="Basic-Help"><span class="section-number-3">9.6.</span> 帮助功能</h3>
<div class="outline-text-3" id="text-Basic-Help">
<p>
如果你忘记了某个按键的功能，可以按下 <code>C-h k</code> (<code>describe-key</code>)，紧接着按下想要查询的按键；例如，输入 <code>C-h k C-n</code> 就能查看 <code>C-n</code> 按键的作用。
</p>

<p>
前缀键 <code>C-h</code> 代表 “帮助” 功能。功能键 <code>F1</code> 是 <code>C-h</code> 的等效快捷键。除了 <code>C-h k</code> 之外，还有许多其他的帮助命令，可提供各类不同的帮助信息。
</p>

<p>
有关详情，请参见《<a href="#Help">帮助</a>》章节。
</p>
</div>
</div>
<div id="outline-container-Blank-Lines" class="outline-3">
<h3 id="Blank-Lines"><span class="section-number-3">9.7.</span> 空行处理</h3>
<div class="outline-text-3" id="text-Blank-Lines">
<p>
本节介绍用于插入和删除空行的专用命令与操作技巧。
</p>
<dl class="org-dl">
<dt>C-o</dt><dd>在光标后方插入一行空行 (<code>open-line</code>) 。</dd>
<dt>C-x C-o</dt><dd>将连续的多行空行删减为仅保留一行 (<code>delete-blank-lines</code>) 。</dd>
</dl>

<p>
我们此前已经了解到，按下 <code>RET</code> (<code>newline</code>) 可以新建一行文本。不过，先插入一行空行，再在空行中输入目标文本，会让操作过程更清晰易见。使用快捷键 <code>C-o</code> (<code>open-line</code>)即可轻松实现这个操作，该命令会在光标位置后方插入一个换行符，同时保持光标停留在换行符之前。执行 C-o 后，你就可以直接在新行中输入文本内容。
</p>

<p>
连续按下多次 <code>C-o</code> ，即可插入多行空行；也可以为该命令指定 <b>数字参数</b> ，以此设定需要插入的空行数量，具体用法详见《<a href="#Arguments">数字参数</a>》章节。若你设置了 <b>填充前缀</b> ，当在行首位置按下 <code>C-o</code> 时，该命令会自动在新插入的空行中添加填充前缀，相关内容详见《<a href="#Fill-Prefix">填充前缀</a>》章节。
</p>

<p>
删除多余空行的便捷方法是使用命令 <code>C-x C-o</code> (<code>delete-blank-lines</code>) 。当光标处于连续多行空行的范围内时， <code>C-x C-o</code> 会将这些空行删减为仅保留一行；当光标位于单行空行上时， <code>C-x C-o</code> 会直接删除这行空行；当光标位于非空行上时， <code>C-x C-o</code> 会删除该行之后的所有空行（如果存在的话）。
</p>
</div>
</div>
<div id="outline-container-Continuation-Lines" class="outline-3">
<h3 id="Continuation-Lines"><span class="section-number-3">9.8.</span> 续行（Continuation Lines）</h3>
<div class="outline-text-3" id="text-Continuation-Lines">
<p>
有时，缓冲区中的一行文本——即 <b>logical line逻辑行</b> ——过长而无法完全显示在窗口内，Emacs会将其显示为两行或多行 <b>screen lines 屏幕行</b> （或 <b>visual lines视觉行</b> ）。这称为 <code>line wrapping换行</code> 或 <code>continuation续行</code> ，而较长的逻辑行则被称为 <code>continued line续行</code> 。在图形界面中，Emacs 会通过左右窗口边缘的弯曲小箭头，以此标记续行的起止；在文本终端中，Emacs 则会在屏幕行的右边界显示一个反斜杠字符 ‘\‘ 来标识续行。
</p>

<p>
大多数针对 “行” 执行操作的命令，作用对象都是 <b>逻辑行</b> 而非屏幕行。例如， <code>C-k</code> 命令会删除一整行逻辑行。但前文提到的 <code>C-n</code> (<code>next-line</code>) 和 <code>C-p</code> (<code>previous-line</code>) 是两个特殊例外：它们的作用是分别将光标向下或向上移动 <b>一行屏幕行</b> （详见《<a href="#Moving-Point">光标位置调整</a>》章节）。
</p>

<p>
Emacs 也可以选择对过长的逻辑行执行 <b>truncate截断</b> 而非续行处理。截断模式下，每条逻辑行仅占用一行屏幕行；如果逻辑行长度超过窗口宽度，超出部分将不会被显示。在图形化界面中，被截断的行会在窗口右侧提示区显示一个小型直箭头；在文本终端中，该行的右边界则会显示一个美元符号 $。详见《<a href="#Line-Truncation">行截断</a>》章节。
</p>

<p>
默认情况下，续行的折行位置是窗口的右边缘。由于折行可能发生在单词的中间位置，这类续行的可读性会比较差。常规的解决方法是在逻辑行过长之前手动插入换行符，将其拆分为较短的行。如果你需要，也可以启用 <code>auto-fill-mode</code> 自动填充模式，让 Emacs 在逻辑行长度达到阈值时自动插入换行符。详见《<a href="#Filling">文本填充</a>》章节。
</p>

<p>
默认状态下，每条续行的首字符都会对齐到其所在屏幕行的行首位置。次要模式 <code>visual-wrap-prefix-mode</code> 及其全局版本 <code>global-visual-wrap-prefix-mode</code> （详见《<a href="#Minor-Modes">次要模式</a>》章节），可以让续行在显示时自动根据该行上下文生成 <b>填充前缀</b> （详见《<a href="#Fill-Prefix">填充前缀</a>》章节）并进行缩进。这些前缀仅用于显示效果，不会对缓冲区中的文本内容产生任何修改。
</p>

<p>
在某些场景下，你可能需要编辑包含大量超长逻辑行的文件，此时逐一添加换行符来拆分这些行并不现实。这种情况下，你可以启用 <b>Visual Line mode 视觉行模式</b> ，该模式支持 <b>word wrapping按单词折行</b> ：Emacs 不会在窗口右边缘的位置强制折行，而是会在最接近右边缘的单词边界处（即空格或制表符的位置）进行折行。同时，视觉行模式还会重新定义部分编辑命令（如 <code>C-a</code> 、 <code>C-n</code> 、 <code>C-k</code> ）的作用对象，使其针对 <b>屏幕行</b> 而非逻辑行执行操作。详见《<a href="#Visual-Line-Mode">视觉行模式</a>》章节。
</p>
</div>
</div>
<div id="outline-container-Position-Info" class="outline-3">
<h3 id="Position-Info"><span class="section-number-3">9.9.</span> 光标位置信息</h3>
<div class="outline-text-3" id="text-Position-Info">
<p>
本节介绍用于获取缓冲区各部分尺寸与位置信息，以及统计单词和行数的命令。
</p>

<dl class="org-dl">
<dt><code>M-x what-line</code></dt><dd>显示光标所在行的行号。</dd>
<dt><code>M-x line-number-mode</code></dt><dd></dd>

<dt><code>M-x column-number-mode</code></dt><dd>切换当前行号或列号的自动显示功能。相关内容请参考《<a href="#Optional-Mode-Line">可选模式行功能</a>》。若你希望在每一行前方显示行号，请参考《<a href="#Display-Custom">显示自定义</a>》。</dd>
<dt><code>M-=</code></dt><dd>统计并显示选区范围内的行数、句数、单词数和字符数 (<code>count-words-region</code>) 。关于选区的说明，请参考《<a href="#Mark">标记与选区</a>》。</dd>
<dt><code>M-x count-words</code></dt><dd>统计并显示整个缓冲区的行数、句数、单词数和字符数。若选区处于激活状态（详见《<a href="#Mark">标记与选区</a>》），则会改为统计选区范围内的对应数据。</dd>
<dt><code>C-x =</code></dt><dd>显示光标后一个字符的字符编码、光标在缓冲区中的字符位置，以及光标所在列号 (<code>what-cursor-position</code>) 。</dd>
<dt><code>M-x hl-line-mode</code></dt><dd>启用或关闭当前行的高亮显示功能。相关内容请参考《<a href="#Cursor-Display">光标显示</a>》。</dd>
<dt><code>M-x size-indication-mode</code></dt><dd>切换缓冲区大小的自动显示功能。相关内容请参考《<a href="#Optional-Mode-Line">可选模式行功能</a>》。</dd>
</dl>

<p>
<code>M-x what-line</code> 命令会在回显区显示当前行的行号。由于模式行本身就会显示当前行号（详见《<a href="#Mode-Line">模式行</a>》），该命令通常显得有些多余。但在缓冲区被缩窄的情况下，模式行仅会显示相对于当前可访问区域的行号（详见《<a href="#Narrowing">缓冲区缩窄</a>》）。相比之下， <code>what-line</code> 会同时显示相对于缩窄区域的行号，以及相对于整个缓冲区的行号。
</p>

<p>
<code>M-=</code> (<code>count-words-region</code>) 会在回显区输出一条消息，报告选区范围内的行数、句数、单词数和字符数（选区的概念解释见《<a href="#Mark">标记与选区</a>》）。若带上前缀参数执行 <code>C-u M-=</code> ，该命令则会统计整个缓冲区的对应数据。
</p>

<p>
<code>M-x count-words</code> 命令的功能与上述命令一致，只是调用方式不同。当选区处于激活状态时，它会统计选区数据；反之，则统计整个缓冲区的数据。
</p>

<p>
<code>C-x =</code> (<code>what-cursor-position</code>) 会显示当前光标位置的相关信息，以及该位置对应的缓冲区内容。它会在回显区输出如下格式的一行内容：
</p>

<div class="org-src-container">
<pre class="src src-shell">Char: c (99, <span style="color: #b22222;">#</span><span style="color: #b22222;">o143, #x63) point=28062 of 36168 (78%) column=53
</span>
&#23383;&#31526;&#65306;c(&#21313;&#36827;&#21046; 99&#65292;&#20843;&#36827;&#21046; <span style="color: #b22222;">#</span><span style="color: #b22222;">o143&#65292;&#21313;&#20845;&#36827;&#21046; #x63) &#20809;&#26631;&#20301;&#32622;=28062/36168&#65288;78%&#65289; &#21015;&#21495;=53</span>
</pre>
</div>

<p>
在 “Char:” 之后，显示的是光标所在位置的缓冲区字符；括号内的内容依次为该字符对应的十进制、八进制和十六进制编码。关于 <code>C-x =</code> 命令显示字符信息的更多细节，请参考《<a href="#International-Chars">国际字符集简介</a>》。“point=” 后面的数字是光标在缓冲区中的字符计数位置（缓冲区第一个字符的位置为 1，第二个为 2，以此类推）；其后的数字代表缓冲区的总字符数；括号内的百分比表示光标位置占总字符数的比例。“column=” 后面的数字是光标在窗口中的水平位置，即相对于窗口左边缘的列数。
</p>

<p>
若用户选项 <code>what-cursor-show-names</code> 的值不为 nil，则还会显示该字符在 Unicode 字符数据库中定义的名称。此时，括号内的内容会变为：
</p>

<div class="org-src-container">
<pre class="src src-shell">(99, <span style="color: #b22222;">#</span><span style="color: #b22222;">o143, #x63, LATIN SMALL LETTER C)</span>
</pre>
</div>

<p>
当缓冲区被缩窄，导致开头和结尾的部分文本暂时无法访问时， <code>C-x =</code> 会额外显示一行描述当前可访问范围的内容。例如：
</p>
<div class="org-src-container">
<pre class="src src-shell">Char: C (67, <span style="color: #b22222;">#</span><span style="color: #b22222;">o103, #x43) point=252 of 889 (28%) &lt;231-599&gt; column=0</span>
</pre>
</div>

<p>
其中，额外显示的两个数字分别代表光标允许处于的最小和最大字符位置，这两个数值之间的字符即为当前可访问的内容。相关内容请参考《<a href="#Narrowing">缓冲区缩窄</a>》。
</p>

<p>
与之相关但功能不同的还有 <code>display-line-numbers-mode</code> （详见《<a href="#Display-Custom">显示自定义</a>》）。
</p>
</div>
</div>
<div id="outline-container-Arguments" class="outline-3">
<h3 id="Arguments"><span class="section-number-3">9.10.</span> 数字参数（Numeric Arguments）</h3>
<div class="outline-text-3" id="text-Arguments">
<p>
在数学与计算机领域的术语中，参数（ <code>argument</code> ） 指的是 “传递给函数或操作的数据”。你可以为任意 Emacs 命令指定一个数值参数（也称为 prefix argument前缀参数）。部分命令会将该参数解读为重复执行的次数。例如，为 <code>C-f</code> 命令指定参数 10 时，光标会向前移动 10 个字符，而非默认的 1 个。对于这类命令，不指定参数等效于参数值为 1，而负参数则会让命令的执行方向或作用效果反向。
</p>

<p>
<b>指定数值参数的常用方式</b>
</p>

<p>
指定数值参数最简便的方法是：按住 Meta 键的同时输入数字或负号。例如：
</p>

<div class="org-src-container">
<pre class="src src-shell">M-5 C-n
</pre>
</div>

<p>
该操作会让光标向下移动 5 行。 <code>M-1</code> 、 <code>M-2</code> 等按键，以及 <code>M--</code> ，都被绑定到了对应的命令 (<code>digit-argument</code> 与 <code>negative-argument</code>)，其作用是为后续要执行的命令设置参数。不带数字的 <code>M--</code> 默认表示参数值为 -1。
</p>

<p>
若要输入多位数的参数，输入第一个数字时需要按住 Meta 键，后续数字则无需再按住。例如，要向下移动 50 行，可按下：
</p>

<div class="org-src-container">
<pre class="src src-shell">M-5 0 C-n
</pre>
</div>

<p>
需要注意的是，这个操作 <b>并不会</b> 像你可能预想的那样，先插入 5 个字符 0 再向下移动 1 行 —— 这里的 0 会被视作前缀参数的一部分。
</p>

<p>
（如果确实需要插入 5 个字符 0 该怎么做？可以按下 <code>M-5 C-u 0</code> 。其中 <code>C-u</code> 的作用是终止前缀参数的输入，让后续的按键触发你真正要执行的命令。请注意， <code>C-u</code> 的这个用法仅适用于此场景，其常规作用见下文说明。）
</p>

<p>
除了 M-1、M-2 这种方式，还可以通过 <code>C-u</code> (<code>universal-argument</code>) 搭配数字来指定数值参数；若要指定负参数，则输入 <code>C-u</code> 后接负号与数字即可。不带数字的负号默认表示参数值为 -1。
</p>

<p>
<b>C-u 的特殊用法</b>
</p>

<p>
单独按下 <code>C-u</code> 有一个特殊含义 ——“ <b>4 倍执行</b> ”：它会将后续命令的默认执行次数乘以 4。连续按下两次 C-u（即 <code>C-u C-u</code> ）则是乘以 16。例如， <code>C-u C-u C-f</code> 会让光标向前移动 16 个字符。其他实用的组合操作包括：
</p>
<ul class="org-ul">
<li><code>C-u C-n</code> ：向下移动 4 行</li>
<li><code>C-u C-u C-n</code> ：向下移动 16 行（约占屏幕的一部分）</li>
<li><code>C-u C-u C-o</code> ：插入 16 个空行</li>
<li><code>C-u C-k</code> ：删除 4 行文本</li>
</ul>

<p>
<b>为自插入字符指定数值参数</b>
</p>

<p>
在输入一个自插入字符之前指定数值参数，可以一次性插入该字符的多个副本。如果该字符不是数字，操作会非常直观：
</p>
<ul class="org-ul">
<li>例如 <code>C-u 6 4 a</code> 会插入 64 个字符 a。</li>
<li>但这个方法不适用于插入数字字符 —— <code>C-u 6 4 1</code> 会被识别为指定参数值为 641，而非插入 64 个字符 1。若要实现后者，需要用另一个 <code>C-u</code> 分隔参数与要插入的数字，例如按下 <code>C-u 6 4 C-u 1</code> ，即可插入 64 个字符 1。</li>
</ul>

<p>
<b>命令对数值参数的不同解读方式</b>
</p>

<ul class="org-ul">
<li><p>
忽略参数值，仅判断是否存在参数
</p>

<p>
部分命令只关心是否传入了参数，而不关注参数的具体数值。例如命令 <code>M-q</code> (<code>fill-paragraph</code> 段落重排)：无参数时仅对段落进行换行整理；有参数时则会同时对文本进行两端对齐处理。（关于 <code>M-q</code> 的更多信息，请参考《<a href="#Filling">文本填充</a>》章节）。对于这类命令，只需按下一次 <code>C-u</code> 来指定参数即可。
</p></li>

<li><p>
参数作为重复次数，但无参数时执行特殊逻辑
</p>

<p>
部分命令会将参数值作为重复次数，但无参数时会执行特殊操作。例如命令 <code>C-k</code> (<code>kill-line</code>) ：传入参数 n 时，会删除 n 行文本（包含行尾的换行符）；但无参数时的行为特殊 —— 它会删除光标到下一个换行符之间的文本；若光标恰好位于行尾，则直接删除该行的换行符。因此，连续执行两次无参数的 <code>C-k</code> 可以删除一行非空文本，效果等同于执行带参数 1 的 <code>C-k</code> 命令。（关于 <code>C-k</code> 的更多信息，请参考《<a href="#Killing">文本的删除与移动</a>》章节）。
</p></li>

<li><p>
特殊的参数处理规则
</p>

<p>
少数命令会将单独的 <code>C-u</code> 与普通数值参数区别对待，还有极少数命令会将仅含负号的参数（ <code>M--</code> ）与参数值 -1 区别对待。这些特殊情况会在对应命令的说明中提及；设计这些特殊规则的目的是让单个命令的使用更便捷，相关细节可查阅命令的文档字符串。
</p></li>
</ul>

<p>
<b>术语说明</b>
</p>

<p>
我们使用 <code>prefix argument 前缀参数</code> 这一术语，是为了强调这类参数需要在命令执行之前输入，以此区分迷你缓冲区参数（参考《<a href="#Minibuffer">迷你缓冲区</a>》章节）—— 这类参数需要在调用命令之后输入。
</p>

<p>
在图形化界面中， <code>C-0</code> 、 <code>C-1</code> 等按键的作用与 <code>M-0</code> 、 <code>M-1</code> 等完全相同。
</p>
</div>
</div>
<div id="outline-container-Repeating" class="outline-3">
<h3 id="Repeating"><span class="section-number-3">9.11.</span> 重复执行命令</h3>
<div class="outline-text-3" id="text-Repeating">
<p>
许多简单命令（例如通过单个按键或 <code>M-x 命令名 RET</code> 调用的命令），都可以通过为其指定一个用作 <b>重复次数</b> 的数值参数来重复执行（详见《<a href="#Arguments">数值参数</a>》章节）。但如果待重复的命令需要提示输入内容，或者会以其他方式使用数值参数，这种方法就不再适用。
</p>

<p>
命令 <code>C-x z</code> (<code>repeat</code>) 提供了另一种多次重复执行 Emacs 命令的方式。该命令会重复执行 <b>上一条</b> Emacs 命令，无论这条命令原本是什么。重复执行时会沿用该命令上一次使用的参数，不会在每次重复时重新读取新参数。
</p>

<p>
若要将命令重复执行多次，只需在按下 <code>C-x z</code> 后继续输入更多的 <code>z</code> ：每多输入一个 <code>z</code> ，命令就会再重复执行一次。当你输入 <code>z</code> 以外的字符，或按下鼠标按键时，重复执行的操作就会终止。
</p>

<p>
举个例子，假设你按下 <code>C-u 2 0 C-d</code> 删除了 20 个字符。此时你可以通过输入 <code>C-x z z z</code> ，将这条删除命令（包含它的参数）再重复执行 3 次，总共删除 80 个字符。其中第一次的 <code>C-x z</code> 会让命令重复执行 1 次，后续每多输入一个 <code>z</code> ，就会再重复执行 1 次。
</p>

<p>
你还可以激活 <code>repeat-mode</code> 重复模式，该模式允许你通过输入单个字符，来重复执行那些绑定在 <b>两个或更多按键组合</b> 上的命令。例如，在你按下 <code>C-x u</code> （ <code>undo</code> 详见《<a href="#Undo">撤销</a>》章节）撤销最近一次编辑操作后，可以继续输入 <code>u u u…</code> 来撤销更多次编辑。同理，若要切换到相隔多个窗口的目标窗口，你可以直接输入 <code>C-x o o o…</code> ，而无需重复按下完整的 <code>C-x o C-x o C-x o…</code> 组合键。
</p>

<p>
这个功能的实现逻辑是：当你按下调用命令的完整按键序列后，Emacs 会进入一个 <b>临时重复模式</b> ；可供重复执行的单键快捷操作会显示在回显区中。
</p>

<p>
并非所有命令都支持在 <code>repeat-mode</code> 重复模式下重复执行；你可以输入 <code>M-x describe-repeat-maps RET</code> 查看支持该功能的命令列表。
</p>

<p>
临时重复模式启用的单键快捷操作 <b>不必完全相同</b> ：例如，在你按下 <code>C-x {</code> 后，输入 {、}、^、v 中的任意一个字符，或是以任意顺序混合输入这些字符，都能以对应的方式调整选中窗口的大小。类似地，在按下 <code>M-g n</code> 或 <code>M-g p</code> 后，以任意顺序输入一系列 n 或 p，就能重复执行 <code>next-error</code> 下一个错误和 <code>previous-error</code> 上一个错误命令，在 <code>*compilation*</code> （编译）或 <code>*grep*</code> （全局搜索）缓冲区中进行导航（详见《<a href="#Compilation-Mode">编译模式</a>》章节）。
</p>

<p>
当你输入除重复命令绑定按键之外的任意按键时，临时重复模式会立即退出，且你输入的这个按键会按常规逻辑执行对应的操作。你也可以自定义一个专用按键，使其仅用于退出临时重复模式，而不执行该按键本身对应的命令。要实现这个功能，只需将用户选项 <code>repeat-exit-key</code> 自定义为目标按键即可；一个很自然的选择是将 <code>RET</code> （回车键）设为退出键。
</p>

<p>
最后，你还可以设置让重复链在闲置一段时间后自动中断：将用户选项 <code>repeat-exit-timeout</code> 自定义为指定的闲置时长（单位为秒），超过这个时长后，临时重复模式就会自动关闭。
</p>
</div>
</div>
</section>
<section id="outline-container-Minibuffer" class="outline-2">
<h2 id="Minibuffer"><span class="section-number-2">10.</span> 迷你缓冲区（Minibuffer）</h2>
<div class="outline-text-2" id="text-Minibuffer">
<p>
<code>minibuffer</code> 迷你缓冲区是 Emacs 命令读取复杂参数的区域，例如文件名、缓冲区名称、Emacs 命令名或 Lisp 表达式。我们将其称为 “minibuffer迷你缓冲区”，是因为它是一块占用屏幕空间较小的专用缓冲区。你可以在迷你缓冲区中使用常规的 Emacs 编辑命令，对参数文本进行编辑。
</p>

<ul class="org-ul">
<li><a href="#Basic-Minibuffer">使用迷你缓冲区</a></li>
<li><a href="#Minibuffer-File">文件名专用迷你缓冲区</a></li>
<li><a href="#Minibuffer-Edit">迷你缓冲区中的编辑操作</a></li>
<li><a href="#Completion">自动补全（Completion）</a></li>
<li><a href="#Minibuffer-History">迷你缓冲区历史记录</a></li>
<li><a href="#Repetition">重复执行迷你缓冲区命令</a></li>
<li><a href="#Passwords">输入密码</a></li>
<li><a href="#Yes-or-No-Prompts">确认提示（Yes or No Prompts）</a></li>
</ul>
</div>
<div id="outline-container-Basic-Minibuffer" class="outline-3">
<h3 id="Basic-Minibuffer"><span class="section-number-3">10.1.</span> 使用迷你缓冲区</h3>
<div class="outline-text-3" id="text-Basic-Minibuffer">
<p>
当迷你缓冲区处于激活状态时，它会显示在回显区中，且带有一个光标。迷你缓冲区的开头会显示一段提示信息，通常以冒号结尾。这段提示会说明当前需要输入的参数类型，以及该参数的用途。提示信息会使用 <code>minibuffer-prompt</code> 这个显示样式进行高亮（详见《<a href="#Faces">文本显示样式</a>》章节）。
</p>

<p>
输入迷你缓冲区参数最简便的方式是：直接输入文本内容，然后按下回车键（ <code>RET</code> ）提交参数并退出迷你缓冲区。此外，你也可以按下 <code>C-g</code> 键，通过取消当前请求参数的命令来退出迷你缓冲区（详见《<a href="#Quitting">退出与终止</a>》章节）。
</p>

<p>
在某些情况下，提示信息中会在冒号前的括号内显示一个默认参数。如果你直接按下回车键，程序就会使用这个默认参数执行命令。例如，读取缓冲区名称的命令通常会将某个缓冲区名称设为默认值；你按下回车键后，命令就会对这个默认缓冲区执行操作。你可以通过用户选项 <code>minibuffer-default-prompt-format</code> 来自定义默认参数的显示方式。
</p>

<p>
如果你启用了"Minibuffer Electric Default 迷你缓冲区动态默认模式" （这是一个全局次要模式），那么一旦你修改了迷你缓冲区中的内容，Emacs 就会自动隐藏默认参数（因为此时按下回车键提交的不再是该默认值）。当你恢复迷你缓冲区的原始文本内容后，提示信息会再次显示默认参数。要启用这个次要模式，可输入 <code>M-x minibuffer-electric-default-mode</code> 执行命令。
</p>

<p>
由于迷你缓冲区显示在回显区中，它的使用可能会与回显区的其他用途产生冲突。如果迷你缓冲区处于激活状态时，系统输出了错误信息或提示信息，该信息会以方括号包裹的形式，显示在迷你缓冲区文本的后方，持续几秒钟后自动消失；或者在你输入任意内容后立即消失。在迷你缓冲区的使用过程中，Emacs 不会回显你按下的按键。
</p>

<p>
使用迷你缓冲区时，你可以切换到其他frame(框架)，方便查阅需要输入的文本内容（详见《<a href="#Frame-Commands">框架命令</a>》章节）。默认情况下，处于激活状态的迷你缓冲区会跟随切换到新的frame。如果你将用户选项 <code>minibuffer-follows-selected-frame</code> 的值设为 nil，迷你缓冲区就会停留在最初打开它的frame，你必须切换回该frame，才能完成（或终止）当前命令。若将该选项的值设为一个既非 nil 也非 t 的值，那么只有在当前命令中打开了递归迷你缓冲区后（详见《Emacs Lisp 手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Recursive-Mini.html#Recursive-Mini">递归迷你缓冲区</a>》章节），迷你缓冲区才会跟随切换frame。这个选项的主要作用是让 Emacs 的行为与 28.1 版本之前的旧逻辑保持（大致）一致。请注意，当你最终完成迷你缓冲区的操作后，命令的执行效果始终会作用于最初打开迷你缓冲区的那个frame。唯一的例外情况是：如果该frame已经不存在，命令才会在当前选中的frame(框架)中执行。
</p>
</div>
</div>
<div id="outline-container-Minibuffer-File" class="outline-3">
<h3 id="Minibuffer-File"><span class="section-number-3">10.2.</span> 文件名专用迷你缓冲区</h3>
<div class="outline-text-3" id="text-Minibuffer-File">
<p>
诸如 <code>C-x C-f</code> (<code>find-file</code>) 这类命令，会通过迷你缓冲区读取文件名参数（详见《<a href="#Basic-Files">文件</a>》章节）。当迷你缓冲区用于读取文件名时，其初始文本通常会以一个斜杠结尾，这段文本即为默认目录。例如，迷你缓冲区可能会显示如下内容：
</p>

<div class="org-src-container">
<pre class="src src-shell">Find file: /u2/emacs/src/
</pre>
</div>

<p>
这里的 'Find file:' 是提示信息，'<i>u2/emacs/src</i>' 是默认目录。此时若输入 <code>buffer.c</code> 作为参数，就代表指定了文件 <code>/u2/emacs/src/buffer.c</code> 。关于默认目录的更多信息，请参考《<a href="#File-Names">文件名</a>》章节。
</p>

<p>
你可以按下 <code>M-n</code> 来调取其他可选的文件名默认值，相关操作详见《<a href="#Minibuffer-History">迷你缓冲区历史记录</a>》章节。
</p>

<p>
你可以使用 <code>..</code> 来指定上级目录下的文件：路径 <code>/a/b/../foo.el</code> 等价于 <code>/a/foo.el</code> 。此外，也可以按下 <code>M-DEL</code> 来反向删除目录名称（详见《<a href="#Words">单词操作</a>》章节）。
</p>

<p>
若要指定一个完全不同目录下的文件，你可以按下 <code>C-a C-k</code> 清除整个默认目录文本（详见《<a href="#Minibuffer-Edit">迷你缓冲区中的编辑操作</a>》章节）。或者你也可以忽略默认目录，直接在其后方输入以斜杠或波浪号开头的绝对文件名。例如，你可以通过以下方式指定文件 <code>/etc/termcap</code> ：
</p>

<div class="org-src-container">
<pre class="src src-shell">Find file: /u2/emacs/src//etc/termcap
</pre>
</div>

<p>
连续两个斜杠会让 Emacs 忽略这对斜杠中第二个斜杠之前的所有内容。在上面的例子中， <code>/u2/emacs/src/</code> 会被忽略，因此你实际指定的参数是 <code>/etc/termcap</code> 。如果终端支持的话，文件名中被忽略的部分会显示为灰色。（若要关闭该灰色显示功能，可执行命令 <code>M-x file-name-shadow-mode</code> 关闭文件名遮蔽模式。）
</p>

<p>
在补全远程文件名时（详见《<a href="#Remote-Files">远程文件</a>》章节），连续两个斜杠的行为会略有不同：它只会让 Emacs 忽略文件名部分，保留其余内容（如连接方式、主机地址、用户名等）不变。连续输入三个斜杠，则会忽略远程文件名中的所有内容。相关细节请参考《<a href="https://www.gnu.org/software/emacs/manual/html_node/tramp/index.html">Tramp 手册</a>》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/tramp/File-name-completion.html#File-name-completion">文件名补全</a>》小节。
</p>

<p>
Emacs 会将 <code>~/</code> 解析为你的主目录。因此路径 <code>~/foo/bar.txt</code> 指的是，位于主目录下 <code>foo</code> 目录中的文件 <code>bar.txt</code> 。除此之外， <code>~user-id/</code> 表示登录名为 <code>user-id</code> 的用户对应的主目录。波浪号之前的所有前置目录名称都会被忽略：例如路径 <code>/u2/emacs/~/foo/bar.txt</code> 等价于 <code>~/foo/bar.txt</code> 。
</p>

<p>
在 MS-Windows 和 MS-DOS 操作系统中，用户不一定都有主目录，因此 Emacs 会采用多种替代方案。关于 MS-Windows 系统的相关配置，请参考《<a href="#Windows-HOME">MS-Windows中的 HOME 目录与启动目录</a>》章节；关于 MS-DOS 操作系统的配置，请参考《<a href="#MS_002dDOS-File-Names">MS-DOS 操作系统中的文件名</a>》章节。在这些系统中， <code>~user-id/</code> 格式仅对当前用户生效，也就是说，只有当用户标识与当前登录用户的用户名一致时，该格式才能正常解析。
</p>

<p>
若要阻止 Emacs 在读取文件名时自动插入默认目录，可将变量 <code>insert-default-directory</code> 的值设为 nil。设置后，迷你缓冲区的初始状态会变为空白，但相对文件名参数的解析仍然会基于原有的默认目录。
</p>

<p>
你同样可以在迷你缓冲区中输入远程文件名，相关内容请参考《<a href="#Remote-Files">远程文件</a>》章节。
</p>
</div>
</div>
<div id="outline-container-Minibuffer-Edit" class="outline-3">
<h3 id="Minibuffer-Edit"><span class="section-number-3">10.3.</span> 迷你缓冲区中的编辑操作</h3>
<div class="outline-text-3" id="text-Minibuffer-Edit">
<p>
迷你缓冲区本质上也是一个 Emacs 缓冲区，只是特性比较特殊，你可以使用常规的 Emacs 命令编辑参数文本。（但提示信息是 <code>read-only</code> 只读的，无法修改。）
</p>

<p>
由于在迷你缓冲区中按下 <code>RET</code> 键的作用是提交参数，因此无法用它来插入换行符。若要插入换行，你可以按下 <code>C-q C-j</code> ，这个组合键会插入一个 <code>C-j</code> 控制字符，其功能与换行符完全等价（详见《<a href="#Inserting-Text">插入文本</a>》章节）。除此之外，也可以使用 <code>C-o</code> (<code>open-line</code>) 命令来实现换行（详见《<a href="#Blank-Lines">空行操作</a>》章节）。
</p>

<p>
在迷你缓冲区中，按键 <code>TAB</code> 、 <code>SPC</code> 和 <code>?</code> 通常会被绑定到补全命令，让你无需手动输入完整文本，就能快速补全目标内容，相关内容详见《<a href="#Completion">补全功能</a>》章节。和 <code>RET</code> 键类似，你可以通过 <code>C-q</code> 来插入 <code>TAB</code> 、 <code>SPC</code> 或 <code>?</code> 这些字符本身。如果希望按下 <code>SPC</code> 和 <code>?</code> 时直接插入字符，而非触发补全功能，可以在初始化文件中添加以下配置：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(keymap-unset minibuffer-local-completion-map <span style="color: #8b2252;">"SPC"</span>)
(keymap-unset minibuffer-local-completion-map <span style="color: #8b2252;">"?"</span>)
</pre>
</div>

<p>
为了操作便利，在迷你缓冲区中按下 <code>C-a</code> ( <code>move-beginning-of-line</code> 移动到行首) 时，光标会跳到参数文本的开头，而非提示信息的开头。例如，你可以通过 <code>C-a C-k</code> 的组合操作快速清除整个参数文本。
</p>

<p>
当迷你缓冲区处于激活状态时，回显区的表现和普通 Emacs 窗口基本一致。比如，你可以按下 <code>C-x o</code> 切换到其他窗口，在那里编辑文本后，再切回迷你缓冲区窗口继续输入参数。你甚至可以在其他窗口中剪切文本，回到迷你缓冲区后将其粘贴到参数中。不过迷你缓冲区窗口也存在一些限制，比如无法对其执行拆分操作（详见《<a href="#Windows">多窗口</a>》章节）。
</p>

<p>
默认情况下，迷你缓冲区窗口只占用一行屏幕空间。但如果输入的文本超过一行，它会自动扩展高度以容纳内容。变量 <code>resize-mini-windows</code> 用于控制迷你缓冲区的自动调整行为，其默认值为 <code>grow-only</code> ，也就是前面所说的 “只自动扩展，不自动收缩”。若将该变量设为 <code>t</code> ，当删除迷你缓冲区中的部分文本行后，窗口也会自动收缩，最小会缩至一行高度。若设为 nil，迷你缓冲区窗口不会自动调整大小，但你可以用常规的窗口调整命令手动修改其尺寸（详见《<a href="#Windows">多窗口</a>》章节）。
</p>

<p>
变量 <code>max-mini-window-height</code> 用于限制迷你缓冲区窗口的最大高度。若将其设为浮点数，代表窗口最大高度为框架高度的对应比例；若设为整数，则代表窗口最大可占用的行数；若设为 <code>nil</code> ，则禁用迷你缓冲区的自动调整功能。该变量的默认值为 0.25。
</p>

<p>
当某些命令在其他窗口中显示帮助文本时，你可以在迷你缓冲区中按下 <code>C-M-v</code> 来滚动查看这些帮助信息。同时也支持使用 <code>M-PageUp</code> 和 <code>M-PageDown</code> （等价于 <code>M-prior</code> 和 <code>M-next</code> ）来滚动，这个功能在查看冗长的补全候选列表时尤为实用（详见《<a href="#Other-Window">使用其他窗口</a>》章节）。
</p>

<p>
默认情况下，Emacs 不允许在迷你缓冲区处于激活状态时，调用那些同样会使用迷你缓冲区的命令。若要启用这一功能，需要将变量 <code>enable-recursive-minibuffers</code> 的值设为 <code>t</code> 。当迷你缓冲区被递归调用时，你可能还需要启用 <code>minibuffer-depth-indicate-mode</code> ，让提示信息中显示当前的递归深度。
</p>

<p>
迷你缓冲区处于激活状态时，通常会进入 <code>minibuffer-mode</code> （迷你缓冲区模式）。这是一个 Emacs 内部模式，没有额外的特殊功能。
</p>

<p>
当迷你缓冲区未激活时，会处于 <code>minibuffer-inactive-mode</code> （迷你缓冲区非激活模式），此时在该区域单击鼠标左键，会打开 <code>*Messages*</code> 缓冲区。如果你的迷你缓冲区有专用的框架，Emacs 还会在该区域识别部分快捷键，例如按下 <code>n</code> 键可以新建一个框架。
</p>
</div>
</div>
<div id="outline-container-Completion" class="outline-3">
<h3 id="Completion"><span class="section-number-3">10.4.</span> 自动补全（Completion）</h3>
<div class="outline-text-3" id="text-Completion">
<p>
你通常可以借助一项名为 <b>completion补全</b> 的功能来辅助输入参数。该功能的作用是：在你输入部分参数文本后，Emacs 能够根据已输入的内容，自动补全剩余的全部或部分文本。
</p>

<p>
当补全功能可用时，迷你缓冲区中的部分按键（通常是 <code>TAB</code> 、 <code>RET</code> 和 <code>SPC</code> ）会被重新绑定为专用的补全命令（详见《<a href="#Completion-Commands">补全命令</a>》章节）。这些命令会依据当前请求参数的命令所提供的补全候选列表，尝试补全迷你缓冲区中的文本。你通常可以按下 <code>?</code> 来查看完整的补全候选列表。
</p>

<p>
尽管补全功能通常在迷你缓冲区中使用，但该功能有时也可在普通缓冲区中启用。相关内容详见《<a href="#Symbol-Completion">符号名称补全</a>》章节。
</p>
<ul class="org-ul">
<li><a href="#Completion-Example">补全示例</a></li>
<li><a href="#Completion-Commands">补全命令</a></li>
<li><a href="#Completion-Exit">补全退出</a></li>
<li><a href="#Completion-Styles">补全候选的选择规则</a></li>
<li><a href="#Completion-Options">补全选项</a></li>
</ul>
</div>
<div id="outline-container-Completion-Example" class="outline-4">
<h4 id="Completion-Example"><span class="section-number-4">10.4.1.</span> 补全示例</h4>
<div class="outline-text-4" id="text-Completion-Example">
<p>
通过一个简单示例或许能更好地理解补全功能。 <code>M-x</code> 命令会通过迷你缓冲区读取待执行的命令名，因此补全功能的实现逻辑是：将迷你缓冲区中的输入文本与已有的 Emacs 命令名进行匹配。假设你希望执行 <code>auto-fill-mode</code> （自动填充模式）命令，既可以直接输入 <code>M-x auto-fill-mode RET</code> 来调用，不过使用补全功能会更便捷。
</p>

<p>
若你按下 <code>M-x a u TAB</code> ，此时 TAB 键会查找以 “au” 开头的补全候选项（本例中即命令名）。符合条件的命令有多个，包括 <code>auto-fill-mode</code> 和 <code>autoconf-mode</code> 等，但这些命令名的共同前缀是 “auto”，因此迷你缓冲区中的 “au” 会补全为 “auto”。（在你的 Emacs 会话中，可能还定义了更多命令。例如，若存在一个名为 <code>authorize-me</code> 的命令，Emacs 最多只能补全到 “aut” 这一步。）
</p>

<p>
如果立即再次按下 <code>TAB</code> ，由于无法确定下一个字符（可能是 “-”、“a” 或 “c”），TAB 不会添加任何字符，而是会在另一个窗口中显示所有可能的补全候选列表。
</p>

<p>
接下来输入 “-f”，此时迷你缓冲区中的内容为 “auto-f”，而以该字符串开头的命令名只有 <code>auto-fill-mode</code> 。若此时按下 <code>TAB</code> ，补全功能会将参数剩余部分 “auto-fill-mode” 填充到迷你缓冲区中。
</p>

<p>
由此可见，只需输入 <code>a u TAB - f TAB</code> ，就能完成 "auto-fill-mode" 命令名的输入。
</p>

<p>
即便光标不在迷你缓冲区的末尾， <code>TAB</code> 键同样可以触发补全。这种情况下，补全功能会同时在光标位置和迷你缓冲区末尾填充文本。例如，你先输入 <code>M-x autocm</code> ，再按下 <code>C-b</code> 将光标移到 “m” 之前，此时按下 <code>TAB</code> ，Emacs 会在光标位置插入文本 “onf-”，并在迷你缓冲区末尾插入 “ode”，最终迷你缓冲区中的内容会变为 “autoconf-mode”。
</p>
</div>
</div>
<div id="outline-container-Completion-Commands" class="outline-4">
<h4 id="Completion-Commands"><span class="section-number-4">10.4.2.</span> 补全命令</h4>
<div class="outline-text-4" id="text-Completion-Commands">
<p>
以下是启用补全功能时，迷你缓冲区（minibuffer）中定义的 <code>list of the completion补全命令列表</code> 。
</p>

<dl class="org-dl">
<dt><code>TAB</code></dt><dd>尽可能补全迷你缓冲区中的文本；若无法补全，则显示所有可能的补全候选列表</dd>
<dt><code>SPC</code></dt><dd>（空格键）  补全光标位置之前的文本，仅补全到下一个连字符或空格处</dd>
<dt><code>C-x UP</code></dt><dd>调用迷你缓冲区历史记录进行文本补全</dd>
<dt><code>C-x DOWN</code></dt><dd>调用迷你缓冲区默认值进行文本补全</dd>
<dt><code>RET</code></dt><dd>（回车键） 将迷你缓冲区中的文本作为参数提交，提交前可能会先执行补全操作。详情参见《<a href="#Completion-Exit">补全退出</a>》</dd>
<dt><code>?</code></dt><dd>显示补全候选列表及若干实用快捷键绑定 (<code>minibuffer-completion-help</code>)</dd>
<dt><code>M-DOWN</code></dt><dd></dd>

<dt><code>M-UP</code></dt><dd>遍历补全候选列表</dd>
<dt><code>M-v</code></dt><dd></dd>

<dt><code>M-g M-c</code></dt><dd></dd>

<dt><code>PageUp</code></dt><dd></dd>

<dt><code>prior</code></dt><dd>在迷你缓冲区中操作时，切换到显示补全列表的窗口</dd>
<dt><code>RET</code></dt><dd>在补全缓冲区中， 选中光标所在位置的补全候选</dd>
<dt><code>mouse-1</code></dt><dd></dd>

<dt><code>mouse-2</code></dt><dd>（鼠标按键）   在补全缓冲区中，点击鼠标选中对应位置的补全候选</dd>
<dt><code>TAB</code></dt><dd></dd>

<dt><code>RIGHT</code></dt><dd></dd>

<dt><code>n</code></dt><dd>在补全缓冲区中， 移动到下一个补全候选</dd>
<dt><code>S-TAB</code></dt><dd></dd>

<dt><code>LEFT</code></dt><dd></dd>

<dt><code>p</code></dt><dd>在补全缓冲区中，移动到上一个补全候选</dd>
<dt><code>q</code></dt><dd>关闭补全窗口，切换回迷你缓冲区窗口</dd>
<dt><code>z</code></dt><dd>关闭并删除补全缓冲区及其对应的窗口</dd>
</dl>

<p>
<code>TAB</code> (<code>minibuffer-complete</code>) 是最基础的补全命令。它会搜索所有与迷你缓冲区现有文本匹配的补全候选，并尽可能完成补全。补全候选的筛选规则详见《<a href="#Completion-Styles">补全候选的选择方式</a>》。
</p>

<p>
<code>SPC</code> (<code>minibuffer-complete-word</code>) 的补全逻辑与 <code>TAB</code> 类似，但仅补全到下一个连字符或空格为止。例如：若迷你缓冲区中已有文本 'auto-f'，按下空格键后，补全结果为 'auto-fill-' （而非完整的 'auto-fill-mode'）；再次按下空格键，才会补全为完整的 'auto-fill-mode' 。注意：该命令不适用于包含空格的参数类型（如文件名）。
</p>

<p>
当 <code>TAB</code> 或 <code>SPC</code> 无法完成补全时，会在新窗口中显示匹配的补全候选列表（若存在候选），同时展示若干用于选择候选的实用命令。你也可以按下 <code>?</code> (<code>minibuffer-completion-help</code>) ，主动调出补全列表和帮助信息。补全列表的相关操作命令如下：
</p>

<p>
在迷你缓冲区或补全缓冲区中，按下 <code>M-DOWN</code> (<code>minibuffer-next-completion</code>) 和 <code>M-UP</code> (<code>minibuffer-previous-completion</code>) 可遍历补全缓冲区中的候选。当变量 <code>minibuffer-completion-auto-choose</code> 设为非 nil（默认配置）时，遍历操作会同时将当前候选插入迷你缓冲区；若该变量设为 <code>nil</code> ，可按下 <code>M-RET</code> (<code>minibuffer-choose-completion</code>) 将候选插入迷你缓冲区。默认情况下，按下 <code>M-RET</code> 会退出迷你缓冲区；若添加前缀参数（ <code>C-u M-RET</code> ），则仅插入候选，不退出迷你缓冲区。
</p>

<p>
在迷你缓冲区中按下 <code>M-v</code> ，可切换到显示补全列表的窗口 (<code>switch-to-completions</code>)，方便后续操作。 <code>PageUp</code> 、 <code>prior</code> 、 <code>M-g M-c</code> 也可实现该功能。你也可以通过其他方式切换窗口（详见《<a href="#Windows">多窗口操作</a>》）。
</p>

<p>
在补全缓冲区中，按下 <code>RET</code> 可选中光标所在候选 (<code>choose-completion</code>) ；点击鼠标左键（ <code>mouse-1</code> ）或中键（ <code>mouse-2</code> ）也可选中对应位置的候选。若添加前缀参数（ <code>C-u RET</code> ），则仅将光标所在候选插入迷你缓冲区，不退出迷你缓冲区，便于重新选择其他候选。
</p>

<p>
在补全缓冲区中，按下 <code>TAB</code> 、 <code>RIGHT</code> 或 <code>n</code> 可移动到下一个补全候选 (<code>next-completion</code>) ；按下 <code>S-TAB</code> 、 <code>LEFT</code> 或 <code>p</code> 可移动到上一个补全候选 (<code>previous-completion</code>) 。
</p>

<p>
你还可以基于当前命令的迷你缓冲区输入历史完成补全：按下 <code>C-x UP</code> (<code>minibuffer-complete-history</code>) ，其功能与 <code>TAB</code> 类似，但补全候选来源为迷你缓冲区历史记录，而非默认候选池。类似地， <code>C-x DOWN</code> (<code>minibuffer-complete-defaults</code>) 会调用当前命令提供的默认输入项进行补全。
</p>

<p>
最后，按下 <code>q</code> 会关闭补全窗口并切换回迷你缓冲区窗口 (<code>quit-window</code>) ；按下 <code>z</code> 会直接关闭并删除补全缓冲区及其窗口 (<code>kill-current-buffer</code>)。
</p>

<p>
若将变量 <code>minibuffer-visible-completions</code> 自定义为非 nil 值，箭头键的绑定功能会发生变化：此时箭头键不再用于移动迷你缓冲区中的光标，而是像默认的元箭头键（M-方向箭头）一样遍历补全候选；同时，按下 <code>RET</code> 会选中当前候选（功能等同于默认的 <code>M-RET</code> ）。按下 <code>C-g</code> 会隐藏补全窗口，但保持迷你缓冲区处于激活状态，你可以继续在提示符后输入内容。
</p>
</div>
</div>
<div id="outline-container-Completion-Exit" class="outline-4">
<h4 id="Completion-Exit"><span class="section-number-4">10.4.3.</span> 补全退出</h4>
<div class="outline-text-4" id="text-Completion-Exit">
<p>
当一个命令通过带补全功能的迷你缓冲区读取参数时，它同时会控制你按下 <code>RET</code> 回车键 (<code>minibuffer-complete-and-exit</code>) 提交参数时的行为。该行为分为四种类型：
</p>

<ul class="org-ul">
<li><p>
<code>Strict completion严格补全</code> 仅接受精确匹配的补全结果。只有当迷你缓冲区中的文本本身是精确匹配项，或者可以补全为某个精确匹配项时，按下 <code>RET</code> 回车键才会退出迷你缓冲区。反之，Emacs 会拒绝退出迷你缓冲区；它会尝试执行补全操作，若无法完成补全，则会在迷你缓冲区文本后短暂显示"[Not match]"。（你仍然可以按下 <code>C-g</code> 取消该命令，从而退出迷你缓冲区。）
</p>

<p>
使用这种行为的命令示例是 <code>M-x</code> ，因为对它而言，接受一个不存在的命令名是没有意义的。
</p></li>

<li><p>
<code>Cautious completion谨慎补全</code> 的行为与严格补全类似，区别在于只有当文本本身已是精确匹配项时，按下 <code>RET</code> 回车键才会退出。如果文本可以补全为某个精确匹配项，按下 <code>RET</code> 回车键只会执行补全操作，但不会立即退出；你需要再次按下 <code>RET</code> 回车键才能退出迷你缓冲区。
</p>

<p>
例如，读取必须已存在的文件对应的文件名时，就会使用谨慎补全。
</p></li>

<li><code>Permissive completion宽松补全</code> 允许输入任意内容；补全候选项仅作为参考建议。按下 <code>RET</code> 回车键不会触发补全操作，只会直接提交你当前输入的内容作为参数。</li>

<li><p>
<code>Permissive completion with confirmation带确认的宽松补全</code> 的行为与宽松补全基本一致，仅存在一个例外情况：当你按下制表键（ <code>TAB</code> ）并将文本补全至某个中间状态（即尚未形成精确匹配的补全结果）时，若紧接着按下 <code>RET</code> 回车键，系统不会直接提交该参数。取而代之的是，Emacs 会在文本后短暂显示"[Confirm]"以要求你确认；再次按下 <code>RET</code> 回车键，即可确认并提交该文本。这种机制可以避免一个常见误操作 —— 用户在未意识到 <code>TAB</code> 制表键未完成预期补全的情况下，误按 <code>RET</code> 回车键提交内容。
</p>

<p>
你可以通过自定义变量 <code>confirm-nonexistent-file-or-buffer</code> 来调整上述确认行为。该变量的默认值为 <code>after-completion</code> ，对应上述的默认行为。若将其值改为 <code>nil</code> ，Emacs 将不再要求确认，直接退化为宽松补全模式。若将其值设为其他非 nil 的值，无论前序操作是否为按下 <code>TAB</code> 制表键，Emacs 都会要求你进行确认。
</p>

<p>
大多数读取文件名的命令（如 <code>C-x C-f</code> ）和读取缓冲区名的命令（如 <code>C-x b</code> ），都会采用这种带确认的宽松补全行为。
</p></li>
</ul>
</div>
</div>
<div id="outline-container-Completion-Styles" class="outline-4">
<h4 id="Completion-Styles"><span class="section-number-4">10.4.4.</span> 补全候选的选择规则</h4>
<div class="outline-text-4" id="text-Completion-Styles">
<p>
补全命令的工作原理是，从一长串可能的补全候选项中，筛选出与你在迷你缓冲区中输入内容相匹配的较小子集。在《<a href="#Completion-Example">补全示例</a>》一节中，我们给出了一个此类匹配的简单案例。判断何为匹配项的过程十分精细复杂，Emacs 会尝试在大多数情况下提供合理的补全结果。
</p>

<p>
Emacs 会借助 <b>一种或多种 completion styles补全风格</b> 来执行补全操作 —— 补全风格是一套判定迷你缓冲区文本与补全候选项是否匹配的标准。补全过程中，Emacs 会依次尝试每种补全风格：若某一种风格筛选出一个或多个匹配项，这些匹配项就会被作为补全候选项列表；若该风格未筛选出任何匹配项，Emacs 就会继续尝试下一种风格。
</p>

<p>
列表变量 <code>completion-styles</code> 用于指定要使用的补全风格，列表中的每个元素都是一种补全风格的名称（一个 Lisp 符号）。所有可用的风格符号都存储在变量 <code>completion-styles-alist</code> 中（参见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Completion-Variables.html#Completion-Variables">补全变量</a>》一节）。默认的补全风格按顺序排列如下：
</p>

<dl class="org-dl">
<dt><code>basic</code> （基础风格）</dt><dd>匹配的补全候选项，其开头部分必须与迷你缓冲区中光标之前的文本完全一致。此外，若迷你缓冲区中光标之后还有文本内容，则补全候选项的剩余部分必须包含该文本作为子串。</dd>

<dt><code>partial-completion</code> （部分补全风格）</dt><dd><p>
这种主动的补全风格会将迷你缓冲区中的文本按连字符或空格分割为多个单词，再对每个单词分别进行补全。（例如，补全命令名时，输入 "em-l-m" 会被补全为 "emacs-lisp-mode"。）
</p>

<p>
除此之外，迷你缓冲区文本中的星号 '*' 会被当作通配符 —— 它可以匹配补全候选项对应位置上的任意字符序列。
</p></dd>

<dt><code>emacs22</code> （Emacs22 风格）</dt><dd>这种补全风格与 basic 风格类似，区别在于它会忽略迷你缓冲区中光标之后的文本。该风格以此命名，是因为它与 Emacs 22 版本中的补全行为完全一致。</dd>
</dl>


<p>
以下额外的补全风格同样已被定义，你可以根据需要将它们添加到 <code>completion-styles</code> 中（参见《<a href="#Customization">自定义</a>》一节）：
</p>

<dl class="org-dl">
<dt><code>substring</code> （子串风格）</dt><dd><p>
匹配的补全候选项，必须同时包含迷你缓冲区中光标之前的文本和光标之后的文本作为子串，且两个子串的顺序需与原文本一致。
</p>

<p>
例如，若迷你缓冲区中的文本为 'foobar'，且光标位于 'foo' 与 'bar' 之间，那么 'afoobbarc' 会被判定为匹配项（其中 a、b、c 可以是任意字符串，包括空字符串）。
</p></dd>

<dt><code>flex</code> （灵活风格）</dt><dd>这种主动的补全风格也被称为 <code>flx</code> 、 <code>fuzzy模糊补全</code> 或 <code>scatter分散补全</code> ，它会尝试基于 <b>有序子串</b> 进行补全。例如，它会将 'foo' 判定为与 'frodo' 或 'fbarbazoo' 相匹配。</dd>

<dt><code>initials</code> （首字母风格）</dt><dd>这种补全风格的匹配策略非常主动，它会尝试针对缩写词和首字母缩写进行补全。例如，补全命令名时，它会将 'lch' 匹配为 'list-command-history'。</dd>
</dl>

<p>
还有一种极为简单的补全风格名为 <code>emacs21</code> 。在该风格下，若迷你缓冲区中的文本为 'foobar'，则只有以 'foobar' 开头的候选项会被视为匹配项。
</p>

<p>
你可以通过设置变量 <code>completion-category-overrides</code> ，在不同场景下使用不同的补全风格。例如，该变量的默认配置规定，针对缓冲区名称仅使用 <code>basic</code> 和 <code>substring</code> 这两种补全风格。
</p>
</div>
</div>
<div id="outline-container-Completion-Options" class="outline-4">
<h4 id="Completion-Options"><span class="section-number-4">10.4.5.</span> 补全选项</h4>
<div class="outline-text-4" id="text-Completion-Options">
<p>
在补全 <b>区分大小写的参数</b> （例如命令名）时，大小写是有意义的。例如，补全命令名时，输入 'AU' 不会补全为 'auto-fill-mode'。而在补全不区分大小写的参数时，大小写差异会被忽略。
</p>

<p>
补全文件名时，若变量 <code>read-file-name-completion-ignore-case</code> 的值为非 nil，则大小写差异会被忽略。该变量的默认值在区分大小写文件名的系统（如 GNU/Linux）上为 <code>nil</code> ；在不区分大小写文件名的系统（如微软 Windows）上为非 nil。补全缓冲区名时，若变量 <code>read-buffer-completion-ignore-case</code> 的值为非 nil，则大小写差异会被忽略，该变量的默认值为 nil。
</p>

<p>
补全文件名时，Emacs 通常会忽略某些被判定为 <b>不太可能</b> 被选中的候选项，具体由列表变量 <code>completion-ignored-extensions</code> 决定。该列表中的每个元素都应为一个字符串；任何文件名以该字符串结尾的文件，都会被排除在补全候选项之外。若列表元素以斜杠（/）结尾，则代表该元素是一个子目录名。 <code>completion-ignored-extensions</code> 的标准值包含多个元素，例如 ".o"、".elc" 和 ”~“ 。举例来说，若某个目录下存在 "foo.c" 和 "foo.elc" 两个文件，输入 'foo' 会补全为 'foo.c'。但如果 <b>所有</b> 可能的补全候选项的后缀都属于被忽略的字符串，那么这些候选项将不会被忽略：以上述例子来说，输入 'foo.e' 会补全为 'foo.elc'。需要注意的是，当 Emacs 在补全列表中展示候选项时，会忽略 <code>completion-ignored-extensions</code> 这个变量的配置。
</p>

<p>
Shell 补全是文件名补全的扩展版本，具体可参见《<a href="#Shell-Options">Shell 模式选项</a>》一节。
</p>

<p>
若将 <code>completion-auto-help</code> 的值设为 <code>nil</code> ，补全命令将不会自动显示补全列表缓冲区；你必须手动输入 <code>?</code> 来查看候选项列表。若该变量的值为 <code>lazy</code> ，Emacs 仅会在第二次尝试补全时展示补全列表缓冲区。也就是说，若当前无内容可补全，第一次按下 <code>TAB</code> 会提示 “Next char not unique 后续字符不唯一”；第二次按下 <code>TAB</code> 才会弹出补全列表缓冲区。若该变量的值为 <code>always</code> ，则每次尝试补全时，补全列表缓冲区都会自动显示。
</p>

<p>
补全列表缓冲区首次显示后，其后续的显示状态同样由 <code>completion-auto-help</code> 控制。若该变量的值为 <code>t</code> 或 <code>lazy</code> ，当 Emacs 能够完成补全时，展示补全候选项的窗口会自动收起；而当你输入新内容后再次出现无法补全的情况时，该窗口可能会重新弹出。若变量值为 <code>always</code> ，则只有当你退出补全操作时，该窗口才会收起。若变量值为 <code>visible</code> ，则该配置属于混合模式：在决定是否弹出补全列表窗口时，它的行为与 <code>t</code> 一致；在决定是否收起该窗口时，它的行为与 <code>always</code> 一致。
</p>

<p>
Emacs 支持在弹出补全列表窗口时，自动选中该窗口。若要启用此功能，可将用户选项 <code>completion-auto-select</code> 自定义为 <code>t</code> ，这会改变 <code>TAB</code> 键在补全窗口弹出时的行为：按下 <code>TAB</code> 会切换到补全列表缓冲区，之后你可以通过光标移动命令选中目标候选项，并按下 <code>RET</code> 确认选择。若 <code>completion-auto-select</code> 的值为 <code>second-tab</code> ，则第一次按下 <code>TAB</code> 会弹出补全列表缓冲区，第二次按下 <code>TAB</code> 才会切换到该缓冲区。
</p>

<p>
当补全列表窗口被选中时（无论是通过自定义 <code>completion-auto-select</code> 实现，还是手动按下 <code>C-x o</code> 切换窗口），按下 <code>UP and DOWN</code> 上下方向键 ( <code>previous-line-completion</code> 和 <code>next-line-completion</code> ) 可以在补全候选项之间逐行切换；若在按下方向键时附带数字前缀参数，则可以一次跳过对应行数的候选项。若变量 <code>completion-auto-wrap</code> 的值为非 nil，那么当光标移动到候选项列表的顶端或底端时，会自动循环到另一端。
</p>

<p>
若变量 <code>completion-cycle-threshold</code> 的值为非 nil，补全命令可以循环遍历所有补全候选项。在默认情况下，当迷你缓冲区中的文本存在多个补全候选项时，补全命令会补全到这些候选项的最长公共子串。若将 <code>completion-cycle-threshold</code> 的值改为 <code>t</code> ，补全命令会优先补全为第一个候选项；此后每次调用补全命令，都会循环替换为下一个候选项。若将该变量的值设为一个数字 <code>n</code> ，则只有当候选项数量小于等于 <code>n</code> 时，补全命令才会触发这种循环补全的行为。
</p>

<p>
默认情况下，Emacs 会弹出一个新的缓冲区来展示补全候选项，且候选项会按 <code>horizontal</code> 水平方向排列，排列的列数取决于当前窗口的宽度。你可以通过自定义用户选项 <code>completions-format</code> 来修改这一排列方式。若该选项的值为 <code>vertical</code> ，Emacs 会改为垂直排列候选项；若值为 <code>one-column</code> ，则所有候选项会被排列在同一列中。
</p>

<p>
用户选项 <code>completions-sort</code> 用于控制 <code>*Completions*</code> 缓冲区中候选项的排序规则，其默认值为 <code>alphabetical</code> ，即按字母顺序排序。若值为 <code>nil</code> ，则禁用排序功能；若值为 <code>historical</code> ，则会先按字母顺序排序，再根据迷你缓冲区的历史记录调整候选项的顺序。该选项的值也可以是一个函数，Emacs 会将补全候选项列表传入该函数，函数需返回排序后的候选项列表。
</p>

<p>
若变量 <code>completions-max-height</code> 的值为非 nil，则该变量会限制补全窗口的大小。其取值为行数，且包含模式行、标题行以及底部分隔线（若存在）。如果需要更精细地控制补全窗口的显示属性，可以使用变量 <code>display-buffer-alist</code> （具体可参见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Buffer-Display-Action-Alists.html#Buffer-Display-Action-Alists">缓冲区显示的动作列表</a>》一节）。
</p>

<p>
变量 <code>completions-header-format</code> 是一个格式规范字符串，用于控制补全候选项列表上方的信息提示行。若该字符串中包含 '%s' 占位符，则该占位符会被替换为补全列表缓冲区中展示的候选项数量。若要隐藏该信息提示行，可将该变量自定义为 <code>nil</code> 。该变量的值（即提示行字符串）可以设置文本属性，从而改变提示行的视觉外观；常用的属性包括 <code>face</code> （字体）和 <code>cursor-intangible</code> （光标不可见）（具体可参见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Special-Properties.html#Special-Properties">具有特殊含义的属性</a>》一节）。
</p>

<p>
若变量 <code>completions-highlight-face</code> 指向某个有效的字体（face），则当前补全候选项（即按下 <code>RET</code> 或鼠标点击时会被选中的候选项）会用该字体高亮显示。该变量的默认值为 <code>completions-highlight</code> ；若将其设为 <code>nil</code> ，则会禁用高亮功能。此特性依赖于特殊文本属性 <code>cursor-face</code> 实现。
</p>
</div>
</div>
</div>
<div id="outline-container-Minibuffer-History" class="outline-3">
<h3 id="Minibuffer-History"><span class="section-number-3">10.5.</span> 迷你缓冲区历史记录</h3>
<div class="outline-text-3" id="text-Minibuffer-History">
<p>
你在迷你缓冲区中输入的所有内容都会保存到 <b>minibuffer histroy list迷你缓冲区历史记录列表</b> 中，方便你后续随时复用。这其中包含补全候选内容（例如文件名、缓冲区名称、命令名称等）以及其他任何类型的迷你缓冲区输入。你可以使用以下命令，快速将历史输入或备选输入调取到迷你缓冲区中：
</p>

<dl class="org-dl">
<dt><code>M-p</code></dt><dd>跳转到迷你缓冲区历史记录的上一项，即更早输入的参数 (<code>previous-history-element</code>)。</dd>
<dt><code>M-n</code></dt><dd>跳转到迷你缓冲区历史记录的下一项 (<code>next-history-element</code>)。</dd>
<dt><code>UP</code></dt><dd>↑（上箭头）</dd>
<dt><code>DOWN</code></dt><dd>↓ （下箭头）  功能类似 <code>M-p</code> 和 <code>M-n</code> ，但会优先在当前多行历史项内向上或向下跳转一行，再切换至上或下一条历史记录 (<code>previous-line-or-history-element</code> 和 <code>next-line-or-history-element</code>)</dd>
<dt><code>M-r regexp RET</code></dt><dd>跳转到历史记录中更早且匹配该正则表达式的项 (<code>previous-matching-history-element</code>)</dd>
<dt><code>M-s 正则表达式 回车</code></dt><dd>跳转到历史记录中更晚且匹配该正则表达式的项
(<code>next-matching-history-element</code>)</dd>
</dl>

<p>
在迷你缓冲区中，按下 <code>M-p</code> (<code>previous-history-element</code>) 会逐条遍历历史记录列表，每按一次就会将历史记录中更早的一项调取到迷你缓冲区，并覆盖当前内容。按下 <code>M-n</code> (<code>next-history-element</code>) 则会反向遍历历史记录，将更新的条目调取到迷你缓冲区。
</p>

<p>
若在迷你缓冲区中按下 <code>M-n</code> 时，历史记录中已经没有更新的条目（例如你此前从未按过 <code>M-p</code> ），Emacs 会尝试从 <b>默认参数列表</b> 中调取内容：这些是你大概率会输入的常用值。你可以将这个过程理解为遍历 “future history未来历史记录”。
</p>

<p>
文件名对应的 “future history” 包含多种实用备选内容，例如当前光标所在位置的文件名或网址。这类场景下，“future history” 的默认内容由选项 <code>file-name-at-point-functions</code> 所指定的函数控制。默认情况下，该选项会调用 <code>ffap</code> 包（参见《<a href="#FFAP">定位光标处的文件与网址</a>》章节），此包会根据光标周围的文本内容自动推测默认的文件或网址。若要关闭该推测功能，可将该选项自定义为 <code>nil</code> ，此时文件名的 “未来历史记录” 将只包含当前缓冲区打开的文件（若有）以及默认目录。
</p>

<p>
上下箭头键的功能与 <code>M-p</code> 、 <code>M-n</code> 类似，但如果当前历史项是多行内容，它们会先在该多行内容内向上或向下跳转一行，再切换到上一条或下一条历史记录。
</p>

<p>
如果你编辑了通过 <code>M-p</code> 或 <code>M-n</code> 调取到迷你缓冲区的文本， <b>不会修改</b> 该内容在历史记录列表中的原始条目。但当你提交编辑后的内容时，该内容会被添加到历史记录列表的末尾。
</p>

<p>
你可以使用 <code>M-r</code> (<code>previous-matching-history-element</code>) 搜索历史记录中更早的匹配项，使用 <code>M-s</code> (<code>next-matching-history-element</code>) 搜索更新的匹配项。这两个命令都会要求你输入一个正则表达式作为参数，并将第一个匹配的条目调取到迷你缓冲区。关于正则表达式的语法说明，参见《<a href="#Regexps">正则表达式语法</a>》章节。若为命令添加数字前缀参数 <code>n</code> ，则会调取第 <code>n</code> 个匹配项。这两个命令比较特殊：即便它们是在迷你缓冲区中被调用，依然会通过迷你缓冲区读取正则表达式参数。正则表达式中的大写字母会使搜索过程区分大小写（参见《<a href="#Lax-Search">搜索过程中的宽松匹配</a>》章节）。
</p>

<p>
你也可以使用 <b>增量搜索</b> 功能遍历历史记录，详情参见《<a href="#Isearch-Minibuffer">迷你缓冲区搜索</a>》章节。
</p>

<p>
Emacs 会为不同类型的参数维护 <b>独立的历史记录列表</b> 。例如，所有读取文件名的命令会共用一个文件名历史列表；其他独立的历史列表还包括：缓冲区名称列表、命令名称列表（供 <code>M-x</code> 使用）以及命令参数列表（供 <code>query-replace</code> 这类命令使用）。
</p>

<p>
变量 <code>history-length</code> 用于指定迷你缓冲区历史记录列表的 <b>最大长度</b> ：当列表长度超出限制时，新增条目会自动删除最旧的条目。若将该变量设为 <code>t</code> ，则历史记录列表无长度限制。
</p>

<p>
变量 <code>history-delete-duplicates</code> 用于指定是否 <b>删除历史记录中的重复项</b> ：若该变量值为非 nil，新增条目时会删除列表中所有与之内容相同的旧条目。该变量的默认值为 <code>nil</code> 。
</p>
</div>
</div>
<div id="outline-container-Repetition" class="outline-3">
<h3 id="Repetition"><span class="section-number-3">10.6.</span> 重复执行迷你缓冲区命令</h3>
<div class="outline-text-3" id="text-Repetition">
<p>
所有使用过一次迷你缓冲区的命令，都会连同其参数值一起被记录在一个特殊的历史列表 —— 命令历史列表中，你可以借此重复执行整条命令。尤其是 <code>M-x</code> 的每次调用都会被记录在内，因为 <code>M-x</code> 本身就是通过迷你缓冲区来读取命令名称的。
</p>

<dl class="org-dl">
<dt><code>C-x ESC ESC</code></dt><dd>从命令历史列表中重新执行最近一条使用过迷你缓冲区的命令 (<code>repeat-complex-command</code>)</dd>
<dt><code>M-x list-command-history</code></dt><dd>显示完整的命令历史列表，列出所有可通过 <code>C-x ESC ESC</code> 重复执行的命令，按从新到旧的顺序排列。</dd>
</dl>

<p>
<code>C-x ESC ESC</code> 用于重新执行最近一条调用过迷你缓冲区的命令。不带参数时，它会重复执行最后一条该类命令；带数字前缀参数时，则指定要重复的命令位置：参数 1 代表最后一条，2 代表倒数第二条，以此类推。
</p>

<p>
<code>C-x ESC ESC</code> 的工作原理是，将此前执行的命令转换为一段 <b>Lisp 表达式</b> ，并在迷你缓冲区中初始化显示这段表达式文本。即便你不懂 Lisp 语言，也能轻松识别出当前显示的待重复命令。直接按下回车键（ <code>RET</code> ），就会原封不动地重复执行该命令；你也可以先编辑这段 Lisp 表达式来修改命令，再按下 <code>RET</code> 回车执行。执行后的命令会被添加到命令历史列表的头部，除非它与列表中最新的条目完全相同。
</p>

<p>
在 <code>C-x ESC ESC</code> 唤起的迷你缓冲区中，你可以使用常规的迷你缓冲区历史记录命令（参见《<a href="#Minibuffer-History">迷你缓冲区历史记录</a>》章节）来遍历历史列表。找到想要重复的历史命令后，可像平常一样编辑其表达式，再按回车键执行。
</p>

<p>
严格来说， <b>增量搜索</b> 并没有使用迷你缓冲区。因此，尽管它的行为类似复杂命令，但默认不会出现在 <code>C-x ESC ESC</code> 对应的历史列表中。若要让增量搜索命令被纳入该历史列表，可将变量 <code>isearch-resume-in-command-history</code> 的值设为非 nil。详情参见《<a href="#Incremental-Search">增量搜索</a>》章节。
</p>

<p>
所有此前调用过迷你缓冲区的命令，会以 Lisp 列表的形式存储在变量 <code>command-history</code> 中。列表中的每个元素都是一段 Lisp 表达式，描述了一条命令及其对应的参数。Lisp 程序可通过调用函数 <code>eval</code> ，传入 <code>command-history</code> 中的元素来重新执行对应命令。
</p>
</div>
</div>
<div id="outline-container-Passwords" class="outline-3">
<h3 id="Passwords"><span class="section-number-3">10.7.</span> 输入密码</h3>
<div class="outline-text-3" id="text-Passwords">
<p>
有时你需要在 Emacs 中输入密码。例如，当你通过 FTP 等网络协议让 Emacs 访问另一台机器上的文件时，往往需要提供密码才能获取该机器的访问权限（参见《<a href="#Remote-Files">远程文件</a>》章节）。
</p>

<p>
输入密码的操作和使用迷你缓冲区类似。Emacs 会在回显区显示一个提示（如"Password: "）；输入所需密码后，按下回车键（ <code>RET</code> ）提交即可。为防止他人窥看密码，你输入的每个字符都会以星号（“*”）代替原本的样式显示。
</p>

<p>
输入密码时，迷你缓冲区的大部分功能和命令都无法使用。此时没有历史记录和补全功能，且在提交密码前，你无法切换窗口或执行 Emacs 的其他任何操作。
</p>

<p>
输入密码的过程中，你可以按下删除键（ <code>DEL</code> ）向后删除，移除最后输入的一个字符。快捷键 <code>C-u</code> 会清空当前已输入的所有内容。 <code>C-g</code> 可退出密码提示（参见《<a href="#Quitting">退出与终止</a>》章节）。 <code>C-y</code> 会将当前的剪切内容粘贴到密码输入框中（参见《<a href="#Killing">文本的剪切与移动</a>》章节）。按下制表键（ <code>TAB</code> ）可以切换密码的可见状态。你既可以按回车键（ <code>RET</code> ），也可以按退出键（ <code>ESC</code> ）来提交密码。其他任何可插入字符的按键会将对应的字符输入到密码中，除此之外的所有输入都会被忽略。
</p>

<p>
模式行中还会有一个图标用于指示密码的可见状态。在该图标上单击鼠标左键（ <code>mouse-1</code> ），同样可以切换密码的可见性。
</p>
</div>
</div>
<div id="outline-container-Yes-or-No-Prompts" class="outline-3">
<h3 id="Yes-or-No-Prompts"><span class="section-number-3">10.8.</span> 确认提示（Yes or No Prompts）</h3>
<div class="outline-text-3" id="text-Yes-or-No-Prompts">
<p>
Emacs 命令在执行过程中，可能会要求你回答一个 "是/否" 类问题。这类询问主要分为两种类型。
</p>

<p>
第一种是结尾标注 “(y or n)” 的是 / 否询问。你只需按下单个按键（'y' 代表是，'n' 代表否），即可立即退出迷你缓冲区并提交响应。例如，当你按下 <code>C-x C-w</code> （ <code>write-file</code> 写入文件命令）保存缓冲区，并输入了一个已存在的文件名时，Emacs 会弹出如下提示：
</p>

<div class="org-src-container">
<pre class="src src-shell">File &#8216;foo.el&#8217; exists; overwrite? (y or n)
</pre>
</div>

<p>
第二种是结尾标注 “(yes or no)” 的是 / 否询问（如果你自定义了 <code>yes-or-no-prompt</code> 变量，则会显示该变量的值），这类询问通常用于 <b>误操作会引发严重后果</b> 的场景。例如，当你对一个包含未保存修改的文件访问缓冲区执行 <code>C-x k</code> （ <code>kill-buffer</code> 关闭缓冲区命令）时，Emacs 会在迷你缓冲区中弹出如下提示：
</p>

<div class="org-src-container">
<pre class="src src-shell">Buffer foo.el modified; <span style="color: #483d8b;">kill</span> anyway? (yes or no)
</pre>
</div>

<p>
此时你需要在迷你缓冲区中完整输入 "yes" 或 "no"，再按下回车键（ <code>RET</code> ）来提交响应。
</p>

<p>
对于这两种是 / 否询问，迷你缓冲区都支持前文所述的基础操作：你可以用 <code>C-l</code> 重定所选窗口的显示中心，用 <code>C-v</code> （或 <code>PageDown</code> ）向下滚动、 <code>M-v</code> （或 <code>PageUp</code> ）向上滚动该窗口，用 <code>C-x o</code> 切换到其他窗口，用 <code>M-p</code> 和 <code>M-n</code> 执行历史记录相关命令等。按下 <code>C-g</code> 可以取消当前询问，同时退出迷你缓冲区和发起询问的命令（参见《<a href="#Quitting">退出与终止</a>》章节）。
</p>
</div>
</div>
</section>
<section id="outline-container-M_002dx" class="outline-2">
<h2 id="M_002dx"><span class="section-number-2">11.</span> 通过名称执行命令</h2>
<div class="outline-text-2" id="text-M_002dx">
<p>
每个 Emacs 命令都有一个可用于执行它的名称。为方便使用，许多命令还配有快捷键绑定。你既可以通过按下快捷键来执行这些命令，也可以通过输入命令名称来执行。大多数 Emacs 命令没有快捷键绑定，因此 <b>通过名称执行是唯一的方式</b> 。（有关如何设置快捷键绑定的方法，参见《<a href="#Key-Bindings">自定义快捷键绑定</a>》章节。）
</p>

<p>
按照惯例，命令名称由一个或多个单词组成，单词之间用连字符分隔；例如 <code>auto-fill-mode</code> （自动换行模式）或 <code>manual-entry</code> （手动录入）。命令名称大多使用完整的英文单词，以便于记忆。
</p>

<p>
若要通过名称执行命令，需先按下 <code>M-x</code> ，接着输入命令名称，最后按下回车键（ <code>RET</code> ）确认。 <code>M-x</code> 会借助迷你缓冲区读取命令名称，迷你缓冲区开头会显示字符串 'M-x' 作为提示，提醒你输入需要执行的命令名称。按下 <code>RET</code> 回车键后，迷你缓冲区会关闭并执行该命令。关于迷你缓冲区的更多信息，参见《<a href="#Minibuffer">迷你缓冲区</a>》章节。
</p>

<p>
你可以使用补全功能来输入命令名称。例如，要调用 <code>forward-char</code> （向前移动字符）命令，你可以直接输入：
</p>


<div class="org-src-container">
<pre class="src src-shell">M-x forward-char RET
</pre>
</div>

<p>
或者使用补全的方式输入：
</p>
<div class="org-src-container">
<pre class="src src-shell">M-x forw TAB c RET
</pre>
</div>

<p>
需要注意的是， <code>forward-char</code> 与按下快捷键 <code>C-f</code> 所执行的是同一个命令。即便命令有对应的快捷键绑定，也不会影响你通过名称执行它。
</p>

<p>
当 <code>M-x</code> 对命令进行补全时，会忽略所有在 Emacs 早期主版本中被标记为废弃的命令；对于这类命令，你必须输入完整的名称才能执行。而在当前 Emacs 版本中被标记为废弃的命令，仍会出现在补全列表里。（废弃命令指的是已有更新、更优替代方案，且计划在未来某个 Emacs 版本中移除的命令。）
</p>

<p>
此外， <code>M-x</code> 的补全功能可以排除与当前缓冲区主模式（参见《<a href="#Major-Modes">主模式</a>》章节）和次要模式（参见《<a href="#Minor-Modes">次要模式</a>》章节）不相关、且通常无法在当前模式下工作的命令。默认情况下，不会排除任何命令，但你可以自定义选项 <code>read-extended-command-predicate</code> ，将这些不相关的命令从补全结果中剔除。
</p>

<p>
与之相反，Emacs 也可以只显示与当前缓冲区密切相关的命令。 <code>M-S-x</code> （即 “Meta 键 + Shift 键 + x 键”）命令的工作方式与 <code>M-x</code> 类似，但它不会列出 Emacs 支持的所有（或大部分）命令，只会显示那些被标记为 “属于” 当前主模式或已启用的次要模式的命令。
</p>

<p>
若要取消 <code>M-x</code> 操作且不执行任何命令，无需输入命令名称，直接按下 <code>C-g</code> 即可。这会让你回到正常的命令操作状态。
</p>

<p>
如果要向通过 <code>M-x</code> 调用的命令传递数值参数，需要在按下 <code>M-x</code> 之前指定该数值参数。在读取命令名称的过程中，参数值会显示在迷你缓冲区的提示信息中，最终 <code>M-x</code> 会将该参数传递给对应的命令。例如，要向 <code>forward-char</code> 命令传递数值参数 42，可以输入：
</p>

<div class="org-src-container">
<pre class="src src-shell">C-u 42 M-x forward-char RET
</pre>
</div>

<p>
当你通过 <code>M-x</code> 执行的命令存在对应的快捷键绑定时，Emacs 会在命令执行完毕后，在回显区提示该快捷键。例如，若你输入 <code>M-x forward-word</code> ，回显区会显示该命令也可通过按下 <code>M-f</code> 来执行。你可以通过将变量 <code>suggest-key-bindings</code> 的值设为 <code>nil</code> ，来关闭这类提示信息。该变量的值也可以设为一个数字，此时 Emacs 会将快捷键提示信息显示对应秒数后再清除。默认情况下，提示信息会显示 2 秒。
</p>

<p>
此外，当 <code>suggest-key-bindings</code> 的值不为 nil 时， <code>M-x</code> 的补全列表中会为所有带有快捷键绑定的命令，显示对应的等效快捷键。
</p>

<p>
对于没有快捷键绑定的命令，在 <code>M-x</code> 提示符下，你无需输入完整的命令名称即可调用。如果命令的简写形式比完整名称短很多，且变量 <code>extended-command-suggest-shorter</code> 的值不为 nil，Emacs 会在回显区提示该简写形式。 <code>suggest-key-bindings</code> 的设置同样会影响这类提示信息的显示。
</p>

<p>
在本手册中，当提及通过名称执行命令时，我们通常会省略用于确认命令名称的回车键（ <code>RET</code> ）。因此，我们可能会写成 <code>M-x auto-fill-mode</code> ，而非 <code>M-x auto-fill-mode RET</code> 。只有在需要强调的情况下（例如命令后需要跟参数时），才会特别提及回车键。
</p>

<p>
<code>M-x</code> 的底层实现是通过执行 <code>execute-extended-command</code> 命令完成的，该命令的作用是读取另一个命令的名称并调用它。
</p>
</div>
</section>
<section id="outline-container-Help" class="outline-2">
<h2 id="Help"><span class="section-number-2">12.</span> 帮助功能</h2>
<div class="outline-text-2" id="text-Help">
<p>
Emacs 提供了种类丰富的帮助命令，所有命令均可通过前缀键 <code>C-h</code> （或等效的功能键 <code>F1</code> ）调用。下文将对这些帮助命令进行详细说明。你也可以按下 <code>C-h C-h</code> 来查看完整的帮助命令列表 (<code>help-for-help</code>) 。在命令列表界面，可使用 <code>SPC</code> （空格键）和 <code>DEL</code> （删除键）滚动列表，然后输入想要执行的帮助命令；若要取消操作，按下 <code>C-g</code> 即可。
</p>

<p>
许多帮助命令会在一个特殊的 <b>help buffer帮助缓冲区</b> 中展示信息。在该缓冲区中，你可以用 <code>SPC</code> 和 <code>DEL</code> 滚动内容，按下 <code>RET</code> （回车键）则可跳转至超链接。详情参见《<a href="#Help-Mode">帮助模式</a>》章节。
</p>

<p>
默认情况下，帮助命令会在独立窗口中打开帮助缓冲区，但不会自动选中该窗口。这一行为由变量 <code>help-window-select</code> 控制：它的默认值为 <code>nil</code> ；若将其自定义为 <code>t</code> ，帮助命令会强制选中帮助窗口；若设为 <code>other</code> ，则仅当选中的frame中存在两个以上窗口时，才会选中帮助窗口。
</p>

<p>
与之相对， <code>*Help*</code> 缓冲区中的许多命令会弹出新窗口来展示执行结果。例如，点击链接查看源代码、或使用 <code>i</code> 命令查看手册条目时，默认都会弹出新窗口。如果将变量 <code>help-window-keep-selected</code> 的值改为非 nil，系统就会复用当前显示 <code>*Help*</code> 缓冲区的窗口，而非新建窗口。
</p>

<p>
若你想使用某个功能，但不清楚它的名称或查找路径，我们推荐三种方法：首先尝试关键词检索命令，其次检索手册索引，接着查阅常见问题（FAQ）和软件包关键词，最后再尝试列出外部软件包。
</p>

<dl class="org-dl">
<dt><code>C-h a TOPICS RET</code></dt><dd>检索名称匹配参数 <code>TOPICS</code> 的命令。参数可以是单个关键词、多个空格分隔的关键词，或正则表达式（详情参见《<a href="#Regexps">正则表达式</a>》章节）。<a href="#Apropos">Apropos</a></dd>
<dt><code>C-h d TOPICS RET</code></dt><dd>类似上一条命令，但检索范围是文档字符串的文本内容，而非命令与函数的名称。</dd>
<dt><code>C-h r i TOPIC RET</code></dt><dd>在 Emacs 信息手册的索引中检索 <code>TOPIC</code> ，并展示首个匹配结果。按下 <code>,</code> 逗号可查看后续匹配项。</dd>
<dt><code>C-h r s TOPIC RET</code></dt><dd>类似上一条命令，但检索范围是手册的正文内容，而非索引。</dd>
<dt><code>C-h C-f</code></dt><dd>通过信息阅读器（Info）打开 Emacs 常见问题（FAQ）文档。</dd>
<dt><code>C-h p</code></dt><dd>根据关键词展示可用的 Emacs 软件包（详情参见《<a href="#Package-Keywords">软件包关键词搜索</a>》章节）。</dd>
<dt><code>M-x list-packages</code></dt><dd>展示所有外部软件包的列表（详情参见《<a href="#Packages">软件包</a>》章节）。</dd>
</dl>

<p>
此外，在其他多种场景下， <code>C-h</code> 或 <code>F1</code> 也代表 “帮助” 功能。例如，在按下前缀键后再按这两个键，即可查看该前缀键后续可搭配的按键列表。（此场景下也可使用 <code>?</code> 键替代。少数前缀键不支持通过 <code>C-h</code> 或 <code>?</code> 查看后续按键 —— 因为这些按键被定义了其他功能，但所有前缀键均支持 <code>F1</code> 来触发帮助。）
</p>

<p>
目录
</p>

<ul class="org-ul">
<li><a href="#Help-Summary">帮助摘要</a>：所有帮助命令的简明列表</li>
<li><a href="#Key-Help">按键相关文档</a>：查询 Emacs 中按键的功能</li>
<li><a href="#Name-Help">按命令或变量名查询帮助</a>：查询命令、变量或函数名称的相关信息</li>
<li><a href="#Apropos">关键词检索帮助（Apropos）</a>：查询与指定主题相关的内容</li>
<li><a href="#Help-Mode">帮助模式命令</a>：帮助模式与帮助缓冲区的特殊功能</li>
<li><a href="#Package-Keywords">软件包关键词搜索</a>：通过关键词（主题）查找 Lisp 程序库</li>
<li><a href="#Language-Help">国际语言支持相关帮助</a>：与国际化语言支持相关的帮助</li>
<li><a href="#Misc-Help">其他帮助命令</a>：各类杂项帮助命令</li>
<li><a href="#Help-Files">帮助文件</a>：用于展示辅助帮助文件的命令</li>
<li><a href="#Help-Echo">活动文本与工具提示帮助</a>：活动文本的帮助信息与工具提示（“气泡帮助”）</li>
</ul>
</div>
<div id="outline-container-Help-Summary" class="outline-3">
<h3 id="Help-Summary"><span class="section-number-3">12.1.</span> 帮助摘要</h3>
<div class="outline-text-3" id="text-Help-Summary">
<p>
以下是用于查阅内置文档的帮助命令汇总，其中大部分命令会在后续章节展开详细说明。
</p>

<dl class="org-dl">
<dt><code>C-h a topics RET</code></dt><dd>显示名称匹配指定主题的命令列表 (<code>apropos-command</code>) 。详情参见《<a href="#Apropos">关键词检索</a>》章节。</dd>
<dt><code>C-h b</code></dt><dd>显示当前所有生效的按键绑定；展示顺序为：次要模式绑定 → 主模式绑定 → 全局绑定（对应函数 <code>describe-bindings</code> ）。详情参见《其他帮助命令》章节。</dd>
<dt><code>C-h C-q</code></dt><dd>切换显示一个窗口，该窗口用于展示常用命令及其对应的按键绑定。详情参见《<a href="#Misc-Help">其他帮助命令</a>》章节。</dd>
<dt><code>C-h c key</code></dt><dd>显示该按键序列所绑定命令的名称 (<code>describe-key-briefly</code>) 。此处的 c 代表 “字符（character）”。若需查看该按键的完整信息，可使用 <code>C-h k</code> 命令。详情参见《<a href="#Key-Help">按键相关文档</a>》章节。</dd>
<dt><code>C-h d topics RET</code></dt><dd>显示文档字符串内容匹配指定主题的命令与变量列表 (<code>apropos-documentation</code>) 。详情参见《<a href="#Apropos">关键词检索</a>》章节。</dd>
<dt><code>C-h e</code></dt><dd>显示 <code>*Messages*</code> 缓冲区的内容 (<code>view-echo-area-messages</code>) 。详情参见《<a href="#Misc-Help">其他帮助命令</a>》章节。</dd>
<dt><code>C-h f 函数名 RET</code></dt><dd>显示名为函数名的 Lisp 函数文档 (<code>describe-function</code>) 。由于 Emacs 命令本质上也是 Lisp 函数，该命令同样适用于查询命令；你也可以使用 <code>C-h x</code> 命令查询。详情参见《<a href="#Name-Help">按命令或变量名查询帮助</a>》章节。</dd>
<dt><code>C-h h</code></dt><dd>显示 <code>HELLO</code> 文件，该文件包含多种字符集的示例文本。</dd>
<dt><code>C-h i</code></dt><dd>启动 Info——GNU 官方文档阅读器（对应函数 <code>info</code> ）。Emacs 手册可在 Info 中查阅。详情参见《<a href="#Misc-Help">其他帮助命令</a>》章节。</dd>
<dt><code>C-h k key</code></dt><dd>显示该按键序列所绑定命令的名称与完整文档 (<code>describe-key</code>) 。详情参见《<a href="#Key-Help">按键相关文档</a>》章节。</dd>
<dt><code>C-h l</code></dt><dd>显示你最近输入的 300 次按键记录 (<code>view-lossage</code>) 。详情参见《<a href="#Misc-Help">其他帮助命令</a>》章节。</dd>
<dt><code>C-h m</code></dt><dd>显示当前主模式与已启用次要模式的文档说明 (<code>describe-mode</code>) 。详情参见《<a href="#Misc-Help">其他帮助命令</a>》章节。</dd>
<dt><code>C-h n</code></dt><dd>显示 Emacs 近期更新内容的公告 (<code>view-emacs-news</code>) 。详情参见《<a href="#Help-Files">帮助文件</a>》章节。</dd>
<dt><code>C-h o 符号</code></dt><dd>显示名为符号的 Lisp 符号文档 (<code>describe-symbol</code>) 。该命令可查询各类符号：函数、变量、以及显示样式（face）均适用。详情参见《<a href="#Name-Help">按命令或变量名查询帮助</a>》章节。</dd>
<dt><code>C-h p</code></dt><dd>根据主题关键词查找软件包 (<code>inder-by-keyword</code>) 。详情参见《<a href="#Package-Keywords">软件包关键词检索</a>》章节。查询结果会以软件包菜单缓冲区的形式列出。详情参见《<a href="#Packages">Emacs Lisp 软件包</a>》章节。</dd>
<dt><code>C-h P 软件包名 RET</code></dt><dd>显示指定软件包名对应的软件包文档 (<code>describe-package</code>) 。详情参见《<a href="#Package-Keywords">软件包关键词检索</a>》章节。</dd>
<dt><code>C-h r</code></dt><dd>在 Info 中打开 Emacs 手册 (<code>info-emacs-manual</code>) 。</dd>
<dt><code>C-h s</code></dt><dd>显示当前语法表的内容 (<code>describe-syntax</code>) 。详情参见《<a href="#Misc-Help">其他帮助命令</a>》章节。语法表定义了各类字符的属性，例如哪些字符属于左分隔符、哪些字符属于单词组成部分等。详情参见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Tables.html#Syntax-Tables">语法表</a>》章节。</dd>
<dt><code>C-h t</code></dt><dd>启动 Emacs 交互式教程 (<code>help-with-tutorial</code>) 。</dd>
<dt><code>C-h v var RET</code></dt><dd>显示名为变量名的 Lisp 变量文档 (<code>describe-variable</code>) 。详情参见《<a href="#Name-Help">按命令或变量名查询帮助</a>》章节。</dd>
<dt><code>C-h w command RET</code></dt><dd>显示触发指定命令名对应命令的按键序列 (<code>where-is</code>) 。详情参见《<a href="#Key-Help">按键相关文档</a>》章节。</dd>
<dt><code>C-h x command RET</code></dt><dd>显示指定命令名对应命令的文档 (<code>describe-command</code>) 。详情参见《<a href="#Name-Help">按命令或变量名查询帮助</a>》章节。</dd>
<dt><code>C-h C coding RET</code></dt><dd>描述指定编码名对应的编码系统 (<code>describe-coding-system</code>) 。详情参见《<a href="#Coding-Systems">编码系统</a>》章节。</dd>
<dt><code>C-h C RET</code></dt><dd>描述当前正在使用的编码系统。</dd>
<dt><code>C-h F command RET</code></dt><dd>启动 Info 并跳转到记录指定 Emacs 命令名文档的节点 (<code>Info-goto-emacs-command-node</code>) 。详情参见《<a href="#Name-Help">按命令或变量名查询帮助</a>》章节。</dd>
<dt><code>C-h I method RET</code></dt><dd>描述指定输入法名对应的输入法 (<code>describe-input-method</code>) 。详情参见《<a href="#Select-Input-Method">选择输入法</a>》章节。</dd>
<dt><code>C-h K key</code></dt><dd>启动 Info 并跳转到记录指定按键序列文档的节点 (<code>Info-goto-emacs-key-command-node</code>) 。详情参见《<a href="#Key-Help">按键相关文档</a>》章节。</dd>
<dt><code>C-h L language-env RET</code></dt><dd>显示指定语言环境名所使用的字符集、编码系统与输入法信息 (<code>describe-language-environment</code>) 。详情参见《<a href="#Language-Environments">语言环境</a>》章节。</dd>
<dt><code>C-h S 符号 RET</code></dt><dd>根据当前编辑文件对应的编程语言，显示该符号的 Info 文档 (<code>info-lookup-symbol</code>) 。详情参见《<a href="#Misc-Help">其他帮助命令</a>》章节。</dd>
<dt><code>C-h .</code></dt><dd>若光标位于特殊文本区域内，显示该区域对应的帮助信息 (<code>display-local-help</code>) 。（例如 <code>*Help*</code> 缓冲区中的超链接就属于这类特殊文本区域。）详情参见《<a href="#Help-Echo">活动文本与工具提示帮助</a>》章节。若带前缀参数执行该命令（即 <code>C-u C-h .</code> ），且光标位于按钮(button)或控件(widget)之上，该命令会弹出一个新缓冲区，展示对应按钮 / 控件的详细描述。</dd>
</dl>
</div>
</div>
<div id="outline-container-Key-Help" class="outline-3">
<h3 id="Key-Help"><span class="section-number-3">12.2.</span> 按键相关文档</h3>
<div class="outline-text-3" id="text-Key-Help">
<p>
获取按键序列相关信息的帮助命令为 <code>C-h c</code> (<code>describe-key-briefly</code> ，简要描述按键功能) 和 <code>C-h k</code> (<code>describe-key</code>) 。
</p>

<p>
按下 <code>C-h c 后再输入目标按键</code> ，会在回显区显示该按键所绑定的命令名称。例如，执行 <code>C-h c C-f</code> 会显示命令 'forward-char'（向前移动字符）。
</p>

<p>
<code>C-h k key</code> 命令的作用与 <code>C-h c key</code> 类似，但会提供更详细的信息：它会打开一个帮助缓冲区，其中包含该命令的文档字符串，详细说明命令的具体功能。
</p>

<p>
<code>C-h K key</code> 命令则会跳转到 Emacs 手册中，对应该按键所绑定命令的说明章节。
</p>

<p>
<code>C-h c</code> 、 <code>C-h k</code> 和 <code>C-h K</code> 适用于所有类型的按键序列，包括功能键、菜单操作和鼠标事件（ <code>C-h c</code> 会忽略鼠标移动事件除外）。例如，按下 <code>C-h k</code> 后，你可以从菜单栏中选择一个菜单项，查看该菜单项所执行命令的文档字符串。
</p>

<p>
<code>C-h w command RET</code> 会列出该命令所绑定的所有按键，结果会显示在回显区。如果提示该命令未绑定任何按键，则意味着你必须通过 <code>M-x</code> 来调用这个命令。 <code>C-h w</code> 对应的底层命令是 <code>where-is</code> 。
</p>

<p>
Emacs 的部分模式会用到各类按钮（参见《Emacs Lisp 参考手册》的 “<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Buttons.html#Buttons">按钮</a>” 章节）和控件（参见《<a href="https://www.gnu.org/software/emacs/manual/html_node/widget/Introduction.html#Introduction">Emacs Widget 控件使用入门</a>》），点击这些元素可以执行相应操作。若要查看这些按钮最终调用的函数，你可以将光标移到按钮上方，然后执行 <code>button-describe</code> 和 <code>widget-describe</code> 命令。
</p>

<p>
<code>M-x which-key</code> 是一个全局次要模式，专门用于帮助用户探索 Emacs 的按键映射表。当你输入了不完整的命令前缀时，它会以弹窗形式显示对应的按键绑定关系。
</p>
</div>
</div>
<div id="outline-container-Name-Help" class="outline-3">
<h3 id="Name-Help"><span class="section-number-3">12.3.</span> 按命令或变量名查询帮助</h3>
<div class="outline-text-3" id="text-Name-Help">
<p>
<code>C-h x command RET</code> (<code>describe-command</code>) 会在一个窗口中显示指定命令的文档说明。例如，执行
</p>

<div class="org-src-container">
<pre class="src src-shell">C-h x auto-fill-mode RET
</pre>
</div>

<p>
会展示自动换行模式 (<code>auto-fill-mode</code>) 的相关文档。对于那些未绑定到任何按键的命令（这类命令通常需要通过 <code>M-x</code> 调用），这是获取其文档的常用方式。
</p>

<p>
<code>C-h f function RET</code> (<code>describe-function</code>) 用于显示 Lisp 函数的文档说明，该命令主要面向 Lisp 程序中调用的函数。比如，当你编写了表达式 <code>(make-vector len)</code> ，想要确认 <code>make-vector</code> 的用法是否正确时，只需输入 <code>C-h f make-vector RET</code> 即可查看文档。此外，由于 Emacs 中所有命令本质上都是 Lisp 函数，因此你也可以用这个命令查看任意命令的文档。
</p>

<p>
若直接按下 <code>C-h f RET</code> ，该命令会解析光标所在位置周围最内层的 Lisp 表达式，并展示其调用函数的文档 —— 前提是该函数名是已定义的合法 Lisp 函数（输入参数时，这个函数名会作为默认值显示）。例如，当光标位于文本 "(make-vector (car x)" 之后时，包含光标的最内层列表是以 "(make-vector" 开头的，此时按下 <code>C-h f RET</code> ，就会显示 <code>make-vector</code> 函数的文档。
</p>

<p>
<code>C-h f</code> 也可用于校验函数名的拼写是否正确。如果 <code>C-h f</code> 在迷你缓冲区的提示符中，将光标所在位置的函数名作为默认值显示，就说明这个名称是已定义的 Lisp 函数。若你并不需要查看该函数的文档，按下 <code>C-g</code> 即可取消 <code>C-h f</code> 命令的执行。
</p>

<p>
<code>describe-function</code> 命令展示的函数文档，不仅包含 <b>函数的文档字符串和签名</b> ，还会附带一些辅助信息，比如函数类型、定义该函数的文件路径、函数是否已被标记为废弃。文档中被加粗强调的部分，通常可以通过点击或按下回车键，跳转到更多相关内容。
</p>

<p>
如果函数的类型是已知的，会通过 <b>函数类型说明符</b> 来标注（参见《Emacs Lisp 参考手册》中的 “<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Type-Specifiers.html#Type-Specifiers">类型说明符</a>” 章节）。只有当 Lisp 程序手动声明了函数类型，或者编译器自动推导出了函数类型时，该标注才会显示。需要注意的是，函数类型推导功能仅在启用 <b>原生编译</b> 时生效（参见《Emacs Lisp 参考手册》中的 “<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/native-compilation.html#native-compilation">原生编译”</a> 章节）。
</p>

<p>
若你查询的是一个 <b>自动加载函数</b> ，且其自动加载定义（参见《Emacs Lisp 参考手册》中的 “<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Autoload.html#Autoload">自动加载</a>” 章节）中未提供文档字符串，那么 <code>*Help*</code> 帮助缓冲区中将不会显示任何文档内容。这种情况下，如果变量 <code>help-enable-symbol-autoload</code> 的值不为 nil，Emacs 会尝试加载该函数的定义文件，以查找是否存在对应的文档字符串。
</p>

<p>
使用 <code>M-x shortdoc</code> 命令，你可以获取与特定主题相关的函数概览。执行该命令后，它会提示你输入感兴趣的主题（例如 <code>string</code> ，即字符串），然后弹出一个缓冲区，列出所有与字符串处理相关的常用函数。
</p>

<p>
你还可以设置让 <code>C-h f</code> 弹出的 <code>*Help*</code> 缓冲区中，在展示函数和命令文档的同时附带 <b>使用示例</b> 。要实现这个功能，需在你的初始化文件中添加以下配置（参见《<a href="#Init-File">Emacs 初始化文件</a>》章节）：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'help-fns-describe-function-functions
          #'shortdoc-help-fns-examples-function)
</pre>
</div>

<p>
<code>C-h v</code> (<code>describe-variable</code>) 的功能与 <code>C-h f</code> 类似，区别在于它用于展示 Lisp 变量的文档，而非 Lisp 函数。如果光标所在位置或前方的符号是已定义的 Lisp 变量，该变量名会作为默认值填充到输入参数中。详情参见 “<a href="#Variables">变量</a>” 章节。
</p>

<p>
只要你安装了 Emacs 的源码文件，描述变量和函数的帮助缓冲区中，通常会包含指向对应源码的超链接（参见 “<a href="#Hyperlinking">超链接与网页导航功能</a>” 章节）。
</p>

<p>
若要在手册中查找某个命令的文档说明，可以使用 <code>C-h F</code> (<code>Info-goto-emacs-command-node</code>) 。该命令支持检索多种手册，而不仅限于 Emacs 官方手册，并能自动定位到对应的章节。
</p>

<p>
<code>C-h o</code> (<code>describe-symbol</code>) 的功能涵盖了 <code>C-h f</code> 和 <code>C-h v</code> ，它可以描述任意符号—— 无论是函数、变量还是面（face）。如果某个符号拥有多重定义（例如，既被定义为函数，又被定义为变量），该命令会依次展示它的所有文档说明。
</p>

<p>
<code>C-h 4 s</code> (<code>elp-find-source</code>) 会切换到一个新的缓冲区，打开当前帮助文档中所描述对象的 <b>源码定义文件</b> 。
</p>

<p>
如果用户选项 <code>completions-detailed</code> 的值不为 nil，部分命令在展示补全候选时会附带详细信息。例如，执行 <code>C-h o TAB</code> 键，补全列表中会包含每个符号文档字符串的第一行内容，同时标注该符号的类型（如函数、变量等）。具体附带的详细信息会根据所使用的命令有所不同。
</p>
</div>
</div>
<div id="outline-container-Apropos" class="outline-3">
<h3 id="Apropos"><span class="section-number-3">12.4.</span> 关键词检索帮助（Apropos）</h3>
<div class="outline-text-3" id="text-Apropos">
<p>
<code>apropos关键词检索</code> 类命令可以解答这类问题：“有哪些用于文件操作的命令？”更准确地说，你需要输入一个 <code>apropos pattern检索模式串</code> ，这个模式串可以是单个单词、一组用空格分隔的单词，或是一个正则表达式。
</p>

<p>
下述所有关键词检索命令，都会在迷你缓冲区中读取检索模式串，搜索匹配该模式的目标对象，并在新窗口中展示检索结果。
</p>


<dl class="org-dl">
<dt><code>C-h a</code></dt><dd>搜索命令 (<code>apropos-command</code>) 。若带上前缀参数执行，则同时搜索非交互式函数</dd>
<dt><code>M-x apropos</code></dt><dd>搜索函数与变量，可同时匹配交互式函数（即命令）与非交互式函数</dd>
<dt><code>M-x apropos-user-option</code></dt><dd>搜索用户可自定义的变量。若带上前缀参数执行，则同时搜索不可自定义的变量</dd>
<dt><code>M-x apropos-variable</code></dt><dd>搜索所有变量。若带上前缀参数执行，则仅搜索可自定义变量</dd>
<dt><code>M-x apropos-local-variable</code></dt><dd>仅搜索缓冲区局部变量</dd>
<dt><code>M-x apropos-value</code></dt><dd>搜索值匹配指定模式的变量。若带上前缀参数执行，则同时搜索定义匹配模式的函数、以及属性匹配模式的 Lisp 符号</dd>
<dt><code>M-x apropos-local-value</code></dt><dd>仅搜索值匹配指定模式的缓冲区局部变量</dd>
<dt><code>C-h d</code></dt><dd>搜索文档字符串匹配指定模式的函数与变量（对应底层函数 apropos-documentation）</dd>
</dl>

<p>
最简单的检索模式串是 <b>单个单词</b> ，任何名称中包含该单词的对象都会被匹配。例如，要查找所有文件相关的命令，输入 <code>C-h a file RET</code> 即可。执行后会列出所有名称含 'file' 的命令，比如 <code>copy-file</code> 、 <code>find-file</code> 等。每条命令都会附带简短描述，以及当前可调用它的快捷键列表。以 <code>find-file</code> 为例，检索结果会标注它的快捷键是 <code>C-x C-f</code> 。
</p>

<p>
默认情况下，展示检索结果的 apropos 缓冲区不会被自动选中。若要让 Emacs 自动选中该缓冲区，可将变量 <code>help-window-select</code> 设为任意非 nil 值。
</p>

<p>
对于 apropos 缓冲区中列出的函数定义、变量或符号属性，若想查看其详细信息，可使用 <code>mouse-1</code> 鼠标左键或 <code>mouse-2</code> 中键点击对应条目，或移动光标到条目后按下 <code>RET</code> 回车键。
</p>

<p>
当检索模式串包含 <b>多个单词</b> 时，目标对象的名称必须至少包含其中两个单词，才算匹配成功。例如，若想查找 “删除光标前方文本块” 的命令，可输入 <code>C-h a kill back backward behind before RET</code> 。实际存在的命令 <code>kill-backward</code> 会被匹配到；如果存在 <code>kill-text-before</code> 这类命令，也会被匹配到，因为它的名称包含了模式串中的两个单词。
</p>

<p>
若需要更高的检索灵活性，可直接输入 <b>正则表达式</b> （参见《<a href="#Regexps">正则表达式语法</a>》章节）。当模式串中包含正则表达式的特殊字符 ”^$*+?.\[“ 时，Emacs 会自动将其解析为正则表达式。
</p>

<p>
遵循 Emacs 命令的命名规范，以下这些单词在检索模式串中非常实用。通过在 <code>C-h a</code> 中使用它们，你也能逐步熟悉 Emacs 的命名习惯：
</p>

<p>
char（字符）、line（行）、word（单词）、sentence（句子）、paragraph（段落）、region（区域）、page（页）、sexp（S 表达式）、list（列表）、defun（函数定义）、rect（矩形区域）、buffer（缓冲区）、frame（框架）、window（窗口）、face（外观）、file（文件）、dir（目录）、register（寄存器）、mode（模式）、beginning（开头）、end（结尾）、forward（向前）、backward（向后）、next（下一个）、previous（上一个）、up（向上）、down（向下）、search（搜索）、goto（跳转至）、kill（剪切）、delete（删除）、mark（标记）、insert（插入）、yank（粘贴）、fill（填充）、indent（缩进）、case（大小写）、change（修改）、set（设置）、what（查询）、list（列出）、find（查找）、view（查看）、describe（描述）、default（默认）。
</p>

<p>
若变量 <code>apropos-do-all</code> 的值为非 nil，则大多数关键词检索命令的执行效果，等同于带前缀参数执行的效果。但存在一个例外：不带前缀参数执行 <code>apropos-variable</code> 时，无论 <code>apropos-do-all</code> 的值是什么，都会始终搜索所有变量。
</p>


<p>
默认情况下，除 <code>apropos-documentation</code> 外，所有关键词检索命令都会按 <b>字母顺序</b> 排列结果。若将变量 <code>apropos-sort-by-scores</code> 设为非 nil，这些命令会尝试评估结果的相关度，将最相关的结果排在前面。而 <code>apropos-documentation</code> 命令默认按 <b>相关度</b> 排序结果；若要改为按字母顺序排序，可将变量 <code>apropos-documentation-sort-by-scores</code> 设为 nil。
</p>
</div>
</div>
<div id="outline-container-Help-Mode" class="outline-3">
<h3 id="Help-Mode"><span class="section-number-3">12.5.</span> 帮助模式命令</h3>
<div class="outline-text-3" id="text-Help-Mode">
<p>
帮助缓冲区的主模式为帮助模式。该模式包含查看模式的所有命令（参见《<a href="#View-Mode">查看模式》</a>相关内容）；例如，按 <code>SPC</code> 空格键可向下滚动，按 <code>DEL</code> 删除键或 <code>S-SPC</code> 可向上滚动。同时它还提供了若干专属的特殊命令：
</p>


<dl class="org-dl">
<dt><code>RET</code></dt><dd>跳转到光标所在位置的交叉引用 (<code>help-follow</code>)</dd>
<dt><code>TAB</code></dt><dd>将光标向前移动至下一个超链接 (<code>forward-button</code>)</dd>
<dt><code>S-TAB</code></dt><dd>将光标向后移动至上一个超链接 (<code>backward-button</code>)</dd>
<dt><code>mouse-1</code></dt><dd></dd>

<dt><code>mouse-2</code></dt><dd>跳转到点击的超链接</dd>
<dt><code>n</code></dt><dd></dd>

<dt><code>p</code></dt><dd>在帮助缓冲区中向前或向后翻页</dd>
<dt><code>C-c C-c</code></dt><dd>显示光标所在位置符号的全部相关文档 (<code>help-follow-symbol</code>)</dd>
<dt><code>C-c C-f</code></dt><dd></dd>

<dt><code>r</code></dt><dd>向前翻阅帮助命令的操作历史 (<code>help-go-forward</code>)</dd>
<dt><code>C-c C-b</code></dt><dd></dd>

<dt><code>l</code></dt><dd>向后翻阅帮助命令的操作历史 (<code>help-go-back</code>)</dd>
<dt><code>s</code></dt><dd>查看当前帮助主题的源码（若有源码可查） (<code>help-view-source</code>)</dd>
<dt><code>i</code></dt><dd>在手册中检索当前主题 (<code>help-goto-info</code>)</dd>
<dt><code>I</code></dt><dd>在 Emacs Lisp 手册中检索当前主题 (<code>help-goto-lispref-info</code>)</dd>
<dt><code>c</code></dt><dd>自定义光标所在的变量或显示样式 (<code>help-customize</code>)</dd>
</dl>

<p>
在帮助缓冲区的文档中，函数名、变量名或显示样式名（参见文《<a href="#Faces">本显示样式</a>》相关内容）通常会显示为 <b>underlined hyperlink带下划线的超链接</b> 。若要查看其关联文档，可将光标移至对应位置并按 <code>RET</code> 回车 (<code>help-follow</code>) ，或用 <code>mouse-1</code> 鼠标左键 /  <code>mouse-2</code> 中键点击该超链接。此操作会替换帮助缓冲区的原有内容；若要回溯操作记录，可按 <code>C-c C-b</code> 或 <code>l</code> (<code>help-go-back</code>) 。回溯过程中，可按 <code>C-c C-f</code> 或 <code>r</code> (<code>help-go-forward</code>) 向前恢复操作。
</p>

<p>
在帮助缓冲区中切换超链接时，按 <code>TAB</code> (<code>forward-button</code>) 可跳至下一个超链接，按 <code>S-TAB</code> 可返回上一个超链接。这些命令为循环执行；例如，在最后一个超链接处按制表符，光标会跳回第一个超链接。
</p>

<p>
默认情况下，帮助缓冲区中的许多超链接会被引号包裹。若将用户选项 <code>help-clean-buttons</code> 设为非空值，缓冲区中的这些引号会被自动移除。
</p>

<p>
部分帮助命令生成的帮助缓冲区（例如展示大量按键绑定的 <code>C-h b</code> 命令）会通过 <code>^L</code> 字符将内容分块为多个页面。在这类缓冲区中，按 <code>n</code> (<code>help-goto-next-page</code>) 可跳至下一页开头，按 <code>p</code> (<code>help-goto-previous-page</code>) 可返回上一页开头。通过该方式可快速在帮助缓冲区的不同文档板块间导航。
</p>

<p>
帮助缓冲区中还可包含指向 Info 手册、源码定义和网页地址的超链接。前两种链接会在 Emacs 中直接打开，网页地址则会通过 <code>browse-url</code> 命令调用浏览器打开（参见<a href="#Browse_002dURL">超链接跳转</a>相关内容）。
</p>

<p>
若要查看文档中任意符号的全部相关信息，可将光标移至该符号处并按 <code>C-c C-c</code> (<code>help-follow-symbol</code>) 。该操作会展示该符号的所有相关文档 —— 包括其作为变量、函数和、and/or 显示样式的相关说明。
</p>
</div>
</div>
<div id="outline-container-Package-Keywords" class="outline-3">
<h3 id="Package-Keywords"><span class="section-number-3">12.6.</span> 软件包关键词搜索</h3>
<div class="outline-text-3" id="text-Package-Keywords">
<p>
Emacs 中大多数可选功能都归类为软件包。Emacs 内置了数百个软件包，还可通过网络安装更多软件包（参见《<a href="#Packages">Emacs Lisp 软件包</a>》章节）。
</p>

<p>
为方便查找与特定主题相关的软件包，多数软件包会根据其功能关联一个或多个关键词。按下 <code>C-h p</code> (<code>finder-by-keyword</code>) 可调出软件包关键词列表，同时显示各关键词的含义说明。若要查看某一关键词对应的软件包列表，在该关键词所在行按下 <code>RET</code> 回车键即可；相关软件包列表会在「软件包菜单」缓冲区中展示（参见《<a href="#Package-Menu">软件包菜单缓冲区</a>》章节）。
</p>

<p>
按下 <code>C-h P</code> (<code>describe-package</code>) 后，Emacs 会提示你输入软件包名称（参见《<a href="#Packages">Emacs Lisp 软件包</a>》章节），并在帮助缓冲区中展示该软件包的属性信息及所实现的功能。该缓冲区会以按钮形式列出与该软件包关联的所有关键词，使用鼠标左键或鼠标中键点击任意按钮，即可查看该关键词对应的其他软件包列表。
</p>
</div>
</div>
<div id="outline-container-Language-Help" class="outline-3">
<h3 id="Language-Help"><span class="section-number-3">12.7.</span> 国际语言支持相关帮助</h3>
<div class="outline-text-3" id="text-Language-Help">
<p>
若需查看特定语言环境的相关信息（参见《<a href="#Language-Environments">语言环境</a>》章节），按下 <code>C-h L</code> (<code>describe-language-environment</code>) 即可。该操作会调出帮助缓冲区，展示此语言环境所支持的语言，同时列出其关联的字符集、编码体系、输入方法，以及该语言环境的示例文本。
</p>

<p>
命令 <code>C-h h</code> (<code>view-hello-file</code>) 会打开 <code>etc/HELLO</code> 文件，该文件通过展示多种语言的 “你好” 表达，直观演示各类字符集的使用。
</p>

<p>
命令 <code>C-h I</code> (<code>describe-input-method</code>) 用于说明输入方法 —— 可指定某一输入方法进行查看，默认情况下则展示当前正在使用的输入方法（参见《<a href="#Input-Methods">输入方法</a>》章节）。
</p>

<p>
命令 <code>C-h C</code> (<code>describe-coding-system</code>) 用于解读编码体系 —— 可指定某一编码体系进行查看，默认情况下则展示当前正在使用的编码体系（参见《<a href="#Coding-Systems">编码体系</a>》章节）。
</p>
</div>
</div>
<div id="outline-container-Misc-Help" class="outline-3">
<h3 id="Misc-Help"><span class="section-number-3">12.8.</span> 其他帮助命令</h3>
<div class="outline-text-3" id="text-Misc-Help">
<p>
<code>C-h i</code> (<code>info</code>) 可启动 Info 程序，该程序用于浏览结构化的文档文件。 <code>C-h 4 i</code> (<code>info-other-window</code>) 功能与之相同，区别在于会在另一个窗口中显示 Info 缓冲区。Emacs 的完整手册及 GNU 系统的其他众多手册均可在 Info 中查阅。进入 Info 后按下 <code>h</code> 键，即可运行 Info 的使用教程。
</p>

<p>
若为 <code>C-h i</code> 指定数字参数 <code>n</code> ，该命令会选中名为 ”*info*&lt;n&gt;“ 的 Info 缓冲区，此功能便于你同时浏览多本 Info 手册。若仅将 <code>C-u</code> 作为前缀参数， <code>C-h i</code> 会提示你输入文档文件名，你可借此浏览在 Info 顶层菜单中无入口的文件。
</p>

<p>
前文提及的帮助命令 <code>C-h F functions RET</code> 与 <code>C-h K key</code> ，会直接进入 Info 并跳转到对应函数或按键的说明文档。
</p>

<p>
在编辑程序时，若该编程语言有对应的 Info 版手册，你可使用 <code>C-h S</code> (<code>info-lookup-symbol</code>) ，在对应手册中查找某个符号（关键字、函数或变量）的相关条目。该命令的具体工作方式由当前主模式决定。
</p>

<p>
若遇到意外情况，且不确定自己按下了哪些按键，可使用 <code>C-h l</code> (<code>view-lossage</code>) 。 <code>C-h l</code> 会显示你最近输入的按键序列及其触发的命令。Emacs 默认保存最近的 300 次按键记录，你可通过 <code>lossage-size</code> 命令修改该数值。若发现记录中有不熟悉的命令，可使用 <code>C-h k</code> 或 <code>C-h f</code> 查询其功能。
</p>

<p>
如需查看近期的回显消息，可使用 <code>C-h e</code> (<code>view-echo-area-messages</code>)，该命令会打开保存此类消息的 <code>*Messages*</code> 缓冲区。
</p>

<p>
Emacs 的每种主模式通常会重新定义部分按键，并对编辑的工作方式做出其他调整。 <code>C-h m</code> (<code>describe-mode</code>) 会显示当前主模式的说明文档，文档中通常会介绍该模式下修改后的命令、功能，以及对应的按键绑定。
</p>

<p>
<code>C-h b</code> (<code>describe-bindings</code>) 与 <code>C-h s</code> (<code>describe-syntax</code>) 可展示 Emacs 当前运行环境的其他相关信息。 <code>C-h b</code> 会显示当前所有生效的按键绑定列表，顺序依次为：当前次要模式的局部绑定、当前主模式定义的局部绑定，最后是全局绑定（参见《<a href="#Key-Bindings">自定义按键绑定</a>》章节）。 <code>C-h s</code> 会显示语法表的内容，并对每个字符的语法规则做出解释（参见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Tables.html#Syntax-Tables">语法表</a>》章节）。
</p>

<p>
<code>C-h C-q</code> (<code>help-quick-toggle</code>) 可切换一个辅助缓冲区的显示与隐藏，该缓冲区展示了 Emacs 最常用的命令及其对应的按键绑定（也被称作 “速查手册”），其内容由 <code>help-quick</code> 命令生成。缓冲区中所有按键绑定均为可点击按钮，使用 mouse-1 鼠标左键或 mouse-2 中键点击，即可查看该按键序列所绑定命令的说明文档。
</p>

<p>
在按下某个前缀键后，再输入 <code>C-h</code> 、 <code>?</code> 或 <code>F1</code> (<code>describe-prefix-bindings</code>) ，即可查看该前缀键对应的所有子命令列表。（少数前缀键不支持全部上述按键 —— 这类前缀键为相关按键定义了专属绑定。ESC 就是其中之一： <code>ESC C-h</code> 与  <code>ESC ?</code>  实际对应的是 <code>C-M-h</code> (<code>mark-defun</code>) 和 <code>M-?</code> (<code>xref-find-references</code>) ，但 <code>ESC F1</code> 可正常生效。）
</p>

<p>
最后，执行 <code>M-x describe-keymap</code> 命令，程序会带补全功能提示你输入键盘映射表名称，确认后将显示该键盘映射表中所有的按键绑定。
</p>
</div>
</div>
<div id="outline-container-Help-Files" class="outline-3">
<h3 id="Help-Files"><span class="section-number-3">12.9.</span> 帮助文件</h3>
<div class="outline-text-3" id="text-Help-Files">
<p>
除内置文档和手册外，Emacs 还包含若干其他说明文件，内容涉及复制条款、版本说明、调试方法、问题反馈指引等。你可通过以下命令查看这些文件，除快捷键 <code>C-h g</code> 外，其余命令均为 <code>C-h C-字符</code> 的形式。
</p>

<dl class="org-dl">
<dt><code>C-h C-c</code></dt><dd>显示 Emacs 的复制与再分发规则 (<code>describe-copying</code>) 。</dd>
<dt><code>C-h C-d</code></dt><dd>显示 Emacs 调试相关帮助 (<code>view-emacs-debugging</code>) 。</dd>
<dt><code>C-h C-e</code></dt><dd>显示获取外部包的相关信息 (<code>view-external-packages</code>) 。</dd>
<dt><code>C-h C-f</code></dt><dd>显示 Emacs 常见问题解答列表 (<code>view-emacs-FAQ</code>) 。</dd>
<dt><code>C-h g</code></dt><dd>打开 GNU 项目的介绍页面 (<code>describe-gnu-project</code>) 。</dd>
<dt><code>C-h C-m</code></dt><dd>显示 Emacs 手册印刷版的订购信息 (<code>view-order-manuals</code>) 。</dd>
<dt><code>C-h C-n</code></dt><dd>显示版本更新日志，列出当前 Emacs 版本的新功能 (<code>view-emacs-news</code>) 。</dd>
<dt><code>C-h C-o</code></dt><dd>显示 Emacs 及其他 GNU 软件最新版本的订购与下载方式 (<code>describe-distribution</code>) 。</dd>
<dt><code>C-h C-p</code></dt><dd>显示已知的 Emacs 问题列表，部分问题会附带建议的解决办法 (<code>view-emacs-problems</code>) 。</dd>
<dt><code>C-h C-t</code></dt><dd>显示 Emacs 的待办事项列表 (<code>view-emacs-todo</code>) 。</dd>
<dt><code>C-h C-w</code></dt><dd>显示 GNU Emacs 无任何担保的完整详细说明 (<code>describe-no-warranty</code>) 。</dd>
</dl>
</div>
</div>
<div id="outline-container-Help-Echo" class="outline-3">
<h3 id="Help-Echo"><span class="section-number-3">12.10.</span> 活动文本与工具提示帮助</h3>
<div class="outline-text-3" id="text-Help-Echo">
<p>
在 Emacs 中， <b>active text活动文本</b> （即响应鼠标点击或 <code>RET</code> 回车键执行特定操作的文本）通常配有对应的帮助文本。这类文本包括 Emacs 缓冲区中的超链接，以及模式行的部分内容。在图形化显示界面中，或是部分支持鼠标追踪的文本终端中，将鼠标移至活动文本上方时，相关帮助文本会以 <b>tooltip 工具提示</b> 的形式显示，详见「<a href="#Tooltips">工具提示</a>」相关说明。
</p>

<p>
在不支持鼠标追踪的终端中，可键入快捷键 <code>C-h .</code> (<code>display-local-help</code>) ，显示光标所在位置的缓冲区活动文本的帮助文本，该内容会展示在回显区。若希望光标所在位置存在可用帮助文本时，自动显示对应的帮助信息，可将变量 <code>help-at-pt-display-when-idle</code> 的值设为 t。
</p>
</div>
</div>
</section>
<section id="outline-container-Mark" class="outline-2">
<h2 id="Mark"><span class="section-number-2">13.</span> 标记与区域（Mark and Region）</h2>
<div class="outline-text-2" id="text-Mark">
<p>
Emacs 与诸多其他应用程序一样，允许你选中缓冲区文本中的任意部分，并调用针对该 <code>select text选中文本</code> 执行操作的命令。在 Emacs 中，我们将选中的文本称为 <b>region区域</b> ；其处理方式与其他程序中选中文本的处理方式十分相似，但也存在一些重要区别。
</p>

<p>
区域指的是 <b>标记</b> 与当前 <b>光标位置</b> 之间的缓冲区文本部分。你可以通过在某处设置标记（例如使用 <code>C-SPC</code> 命令），再将光标移动至希望作为区域结束位置的地方，来定义一个区域。（你也可以使用鼠标来定义区域。）
</p>

<p>
无论标记和光标在文本中哪个位置更靠前，区域始终覆盖两者之间的范围；每次移动光标，区域都会随之改变。
</p>

<p>
在文本的某个位置设置标记后，标记会 <b>activates被激活</b> 。当标记处于激活状态时，我们也称区域处于激活状态；Emacs 会通过 <b>region face区域面</b> 为区域内的文本添加高亮，以此标示出区域的范围（参见「<a href="#Face-Customization">自定义样式</a>」相关内容）。
</p>

<p>
执行部分非移动类命令后（包括所有会修改缓冲区文本的命令），Emacs 会自动 <b>deactivates取消标记的激活状态</b> ，区域的高亮效果也会随之消失。你也可以在任何时候键入 <code>C-g</code> ，手动取消标记的激活状态（参见「<a href="#Quitting">退出与终止操作</a>」相关内容）。
</p>

<p>
许多命令会将其操作的文本范围限定在 <b>激活的区域</b> 内。例如， <code>M-%</code> 命令（用于替换匹配的文本）默认会作用于缓冲区中所有可访问的文本部分，但如果存在激活的区域，该命令将仅对该区域内的文本生效。
</p>

<p>
即便标记未被激活，它依然具有实用价值。例如，你可以通过标记环跳转到之前设置过的标记位置（参见「<a href="#Mark-Ring">标记环</a>」相关内容）。此外，部分命令即便针对未激活的区域，也能执行相应操作（例如 <code>upcase-region</code> 命令，用于将区域文本转为大写）。你也可以通过 <code>C-x C-x</code> 这类命令，重新激活区域。
</p>

<p>
上述行为是 Emacs 交互会话中的默认行为，被称为 <b>临时标记模式</b> （Transient Mark mode）。关闭临时标记模式后，Emacs 会切换至另一种行为模式，在该模式下，区域通常不会被高亮显示（参见「<a href="#Disabled-Transient-Mark">关闭临时标记模式</a>」相关内容）。
</p>

<p>
在一个缓冲区中设置标记，不会对其他缓冲区中的标记产生任何影响。当你回到一个存在激活标记的缓冲区时，标记会停留在之前的位置。当多个窗口显示同一个缓冲区时，各窗口的光标位置可以不同，因此对应的区域也会不同，但所有窗口会共享同一个标记位置（参见「<a href="#Windows">多窗口</a>」相关内容）。通常情况下，只有 <b>选中的窗口</b> 会为其对应的区域添加高亮；但如果将变量 <code>highlight-nonselected-windows</code> 的值设为非 nil，每个窗口都会为自身对应的区域添加高亮。
</p>

<p>
Emacs 中还有另一种区域类型：矩形区域（参见「<a href="#Rectangles">矩形区域</a>」相关内容）。
</p>

<ul class="org-ul">
<li><a href="#Setting-Mark">设置标记</a></li>
<li><a href="#Marking-Objects">标记文本对象的命令</a></li>
<li><a href="#Using-Region">对区域执行操作</a></li>
<li><a href="#Mark-Ring">标记环（Mark Ring）</a></li>
<li><a href="#Global-Mark-Ring">全局标记环（Global Mark Ring）</a></li>
<li><a href="#Shift-Selection">移位选择（Shift Selection）</a></li>
<li><a href="#Disabled-Transient-Mark">禁用瞬时标记模式（Disabling Transient Mark Mode）</a></li>
</ul>
</div>
<div id="outline-container-Setting-Mark" class="outline-3">
<h3 id="Setting-Mark"><span class="section-number-3">13.1.</span> 设置标记</h3>
<div class="outline-text-3" id="text-Setting-Mark">
<p>
以下是若干用于设置标记的命令：
</p>
<dl class="org-dl">
<dt><code>C-SPC</code></dt><dd>在光标位置设置标记并将其激活 (<code>set-mark-command</code>) 。</dd>
<dt><code>C-@</code></dt><dd>与上一命令功能相同。</dd>
<dt><code>C-x C-x</code></dt><dd>在光标位置设置标记并将其激活，随后将光标移至标记原位置 (<code>exchange-point-and-mark</code> ，交换光标与标记位置）。</dd>
<dt><code>Drag-mouse-1</code></dt><dd>鼠标左键拖动。在拖动鼠标划过的文本范围两端分别设置光标与标记。</dd>
<dt><code>mouse-3</code></dt><dd>鼠标右键点击。在当前光标位置设置标记，随后将光标移至鼠标点击处 (<code>mouse-save-then-kill</code>) 。</dd>
<dt>按住 SHIFT 的光标移动键</dt><dd>若标记未激活，则在光标位置设置标记，再移动光标（详见「<a href="#Shift-Selection">移位选择</a>」相关内容）。</dd>
</dl>

<p>
设置标记最常用的方式是按下 <code>C-SPC</code> (<code>set-mark-command</code>)<sup><a id="fnr.5" class="footref" href="#fn.5" role="doc-backlink">5</a></sup>。该操作会在当前光标位置设置并激活标记，之后你可移动光标，标记将停留在原位置。若标记已存在于当前光标位置，该命令不会重复设置标记，仅激活已有的标记。
</p>

<p>
例如，若你希望将缓冲区中的部分文本转换为大写，可将光标移至目标文本的一端，按下 <code>C-SPC</code> ，再移动光标至目标文本的另一端，此时目标文本会被高亮显示。接着按下 <code>C-x C-u</code> (<code>upcase-region</code> ，将区域文本转为大写) ，该命令会将区域内的文本转换为大写，随后自动取消标记的激活状态。
</p>

<p>
只要标记处于激活状态，你可按下 <code>C-g</code> 取消其激活（详见「<a href="#Quitting">退出与终止操作</a>」）。大多数对区域执行操作的命令都会自动取消标记激活，如上述示例中的 <code>C-x C-u</code> 。
</p>

<p>
标记不仅可用于定义待操作的区域，还可用于标记缓冲区中的某个位置（连续按下 <code>C-SPC C-SPC</code> ），后续可通过 <code>C-u C-SPC</code> 跳回该位置（详见「<a href="#Mark-Ring">标记环</a>」相关内容）。
</p>

<p>
命令 <code>C-x C-x</code> (<code>exchange-point-and-mark</code>) 用于交换光标与标记的位置。当你希望保留当前光标位置，仅调整区域的另一端（标记位置）时，该命令非常实用。若需要，再次按下 <code>C-x C-x</code> ，可将标记移至新位置，同时将光标恢复至原始位置。默认情况下，若标记处于未激活状态，该命令会先重新激活上一次设置的标记，确保区域保持高亮；但如果为该命令添加前缀参数执行，它会保持标记未激活、区域不高亮的状态，你可通过这种方式跳至标记位置，效果与 <code>C-u C-SPC</code> 类似。
</p>

<p>
你也可通过鼠标设置标记：按住鼠标左键（ <code>down-mouse-1</code> ）并拖动划过一段文本，鼠标按下处会被设为标记，松开处则为光标位置。此外，点击鼠标右键（ <code>mouse-3</code> ）会在当前光标位置设置标记，再将光标移至点击位置。有关这些鼠标命令的详细说明，参见「<a href="#Mouse-Commands">编辑相关的鼠标命令</a>」。
</p>

<p>
最后，你还可在按下Shift 键的同时，按下部分光标移动命令（如 <code>S-RIGHT</code> 、 <code>S-C-f</code> 、 <code>S-C-n</code> 等）设置标记，这种方式被称为“shift-selection”移位选择。该操作会在移动光标前，于当前光标位置设置标记 —— 但仅当此前未通过移位选择或鼠标命令激活标记时生效。通过鼠标命令和移位选择设置的标记，与常规标记的行为略有不同：后续任何未按住 Shift 的光标移动命令，都会自动取消其激活状态（详见「<a href="#Shift-Selection">移位选择</a>」）。
</p>

<p>
许多插入文本的命令（如 <code>C-y</code> (<code>yank</code> ，粘贴) 会在插入文本的另一端设置标记，但不会激活该标记。这一设计能让你轻松返回该位置（详见「<a href="#Mark-Ring">标记环</a>」），当回显区显示 “Mark set（标记已设置）“ 时，即表示当前执行的命令完成了该操作。
</p>

<p>
在 X 窗口系统中，每当激活的区域发生变化，Emacs 会将区域内的文本保存至主选择区（primary selection），你可通过点击鼠标中键（ <code>mouse-2</code> ），将该文本插入其他 X 应用程序中（详见「<a href="#Primary-Selection">与其他窗口应用程序的剪切和粘贴</a>」）。
</p>
</div>
</div>
<div id="outline-container-Marking-Objects" class="outline-3">
<h3 id="Marking-Objects"><span class="section-number-3">13.2.</span> 标记文本对象的命令</h3>
<div class="outline-text-3" id="text-Marking-Objects">
<p>
以下命令可在单词、列表、段落、页面等文本对象的两端定位光标与标记：
</p>
<dl class="org-dl">
<dt><code>M-@</code></dt><dd>将标记设到下一个单词的末尾 (<code>mark-word</code>) ，执行后光标位置不变。</dd>
<dt><code>C-M-@</code></dt><dd>将标记设到下一个平衡表达式的末尾之后 (<code>mark-sexp</code>) ，执行后光标位置不变。</dd>
<dt><code>M-h</code></dt><dd>将光标移至当前段落开头，并将标记设到段落末尾 (<code>mark-paragraph</code>) 。</dd>
<dt><code>C-M-h</code></dt><dd>将光标移至当前函数定义开头，并将标记设到定义末尾 (<code>mark-defun</code>) 。</dd>
<dt><code>C-x C-p</code></dt><dd>将光标移至当前页面开头，并将标记设到页面末尾 (<code>mark-page</code>) 。</dd>
<dt><code>C-x h</code></dt><dd>将光标移至缓冲区开头，并将标记设到缓冲区末尾 (<code>mark-whole-buffer</code>) 。</dd>
</dl>

<p>
<code>M-@</code> (<code>mark-word</code>) 会把标记定位到下一个单词的末尾（关于单词的定义详见「<a href="#Words">单词</a>」相关内容）。重复执行该命令，会将标记逐个单词向后移动，从而扩展选中的区域。一个例外情况是：若标记处于激活状态且位于光标前方， <code>M-@</code> 会将标记从当前位置逐个单词向前移动。
</p>

<p>
该命令也可接收数字参数 <code>n</code> ，指示将标记向后移动 <code>n</code> 个单词；若传入负参数 <code>-n</code> ，则将标记向前移动 <code>n</code> 个单词。
</p>

<p>
类似地， <code>C-M-@</code> (<code>mark-sexp</code>) 会把标记定位到下一个平衡表达式的末尾（关于括号平衡表达式详见「<a href="#Expressions">带配对括号的表达式</a>」相关内容）。重复执行该命令，会将区域扩展至后续的表达式；传入正、负数字参数时，会将标记按指定数量的表达式向前或向后移动。
</p>

<p>
上述列表中的其他命令会同时调整光标与标记的位置，以此在缓冲区中划定一个文本对象的范围： <code>M-h</code> (<code>mark-paragraph</code>) 用于标记段落（详见「<a href="#Paragraphs">段落</a>」相关内容）， <code>C-M-h</code> (<code>mark-defun</code>) 用于标记顶层函数定义（详见「<a href="#Moving-by-Defuns">按函数定义移动</a>」相关内容）， <code>C-x C-p</code> (<code>mark-page</code>) 用于标记页面（详见「<a href="#Pages">页面</a>」相关内容）。重复执行这些命令，作用同样是扩展区域至相邻的同类文本对象；数字参数也可指定标记需要移动过的文本对象数量。
</p>

<p>
<code>C-x h</code> (<code>mark-whole-buffer</code>) 会将光标置于缓冲区开头、标记置于缓冲区末尾，从而将整个缓冲区设为选中区域
</p>
</div>
</div>
<div id="outline-container-Using-Region" class="outline-3">
<h3 id="Using-Region"><span class="section-number-3">13.3.</span> 对区域执行操作</h3>
<div class="outline-text-3" id="text-Using-Region">
<p>
定义好区域后，可通过以下方式对其执行各类操作：
</p>

<ul class="org-ul">
<li><code>C-w</code> 删除区域内容（参见「<a href="#Killing">文本的删除与移动</a>」）。</li>
<li><code>M-w</code> 将区域内容复制到删除环（参见「<a href="#Yanking">粘贴操作</a>」）。</li>
<li><code>C-x C-l</code> 或 <code>C-x C-u</code> 转换区域内容大小写（参见「<a href="#Case">大小写转换命令</a>」）。</li>
<li><code>C-u C-/</code> 撤销区域内的修改操作（参见「<a href="#Undo">撤销</a>」）。</li>
<li><code>M-%</code> 替换区域内的文本（参见「<a href="#Query-Replace">查询替换</a>」）。</li>
<li><code>C-x TAB</code> 或 <code>C-M-\</code> 对区域内容进行缩进（参见「<a href="#Indentation">缩进</a>」）。</li>
<li><code>M-x fill-region</code> 将区域内容按文本格式进行填充排版（参见「<a href="#Filling">文本填充</a>」）。</li>
<li><code>M-$</code> 检查区域内单词的拼写（参见「<a href="#Spelling">拼写检查与修正</a>」）。</li>
<li><code>M-x eval-region</code> 将区域内容作为 Lisp 代码执行（参见「<a href="#Lisp-Eval">Emacs Lisp 表达式的执行</a>」）。</li>
<li><code>C-x r s</code> 将区域内容保存到寄存器（参见「<a href="#Registers">寄存器</a>」）。</li>
<li>将区域内容保存到缓冲区或文件中（参见「<a href="#Accumulating-Text">文本累积</a>」）。</li>
</ul>

<p>
部分命令在标记未激活时执行默认操作，标记激活时则对区域进行操作。例如 <code>M-$</code> (<code>ispell-word</code>) ，默认会检查光标所在单词的拼写，标记激活时则检查区域内文本的拼写（参见「<a href="#Spelling">拼写检查与修正</a>」）。通常情况下，若区域为空（即标记与光标位置重合），这类命令会执行默认操作。若希望命令对空区域也执行区域操作，可将变量 <code>use-empty-active-region</code> 设为 <code>t</code> 。
</p>

<p>
如「<a href="#Erasing">文本擦除</a>」章节所述， <code>DEL</code> (<code>backward-delete-char</code> ，向前删除字符) 和 <code>Delete</code> (<code>delete-forward-char</code> ，向后删除字符) 命令也遵循此规则：标记激活时，这两个命令会删除区域内的文本。（例外情况：若为命令指定非 1 的数字参数 <code>n</code> ，无论标记是否激活，命令都会删除 <code>n</code> 个字符。）若将变量 <code>delete-active-region</code> 设为 <code>nil</code> ，这两个命令在标记激活时将不再执行特殊操作；若将该变量值设为 <code>kill</code> ，这两个命令会将区域内容删除并保存到删除环，而非直接擦除（参见「<a href="#Killing">文本的删除与移动</a>」）。
</p>

<p>
另有部分命令始终对区域进行操作，无默认行为，这类命令的名称中通常包含 “region”（区域），例如 <code>C-w</code> (<code>kill-region</code> ，删除区域) 和 <code>C-x C-u</code> (<code>upcase-region</code> ，区域内容转大写) 。标记未激活时，这些命令会对 <b>非激活区域</b> —— 即光标与上一次设置标记的位置之间的文本 —— 进行操作（参见「<a href="#Mark-Ring">标记环</a>」）。若要禁用此行为，可将变量 <code>mark-even-if-inactive</code> 设为 <code>nil</code> ，此后标记未激活时，执行这类命令会直接抛出错误。
</p>

<p>
默认情况下，即便标记处于激活状态，文本插入操作仍正常执行 —— 例如输入 a 会插入字符 a，随后取消标记的激活状态。次要模式「删除选中内容模式（Delete Selection mode）」会修改此行为：启用该模式后，标记激活时执行文本插入，会先删除区域内的文本，再插入新内容。不过可通过自定义选项 <code>delete-selection-temporary-region</code> 调整该行为，该选项默认值为 <code>nil</code> ；若将其设为 <code>t</code> ， <b>仅临时激活的区域</b> 会被新内容替换，临时激活区域包括通过鼠标拖动（参见「<a href="#Setting-Mark">设置标记</a>」）、移位选择（参见「<a href="#Shift-Selection">移位选择</a>」）设置的区域，以及临时标记模式禁用时通过 <code>C-u C-x C-x</code> 激活的区域。若将 <code>delete-selection-temporary-region</code> 设为 <code>selection</code> ，则仅鼠标拖动或移位选择激活的临时区域会被替换，通过 <code>C-u C-x C-x</code> 激活的临时区域不会被替换。键入 <code>M-x delete-selection-mode</code> 可切换 <code>delete-selection-mode删除选中内容模式</code> 的启用与禁用状态。
</p>
</div>
</div>
<div id="outline-container-Mark-Ring" class="outline-3">
<h3 id="Mark-Ring"><span class="section-number-3">13.4.</span> 标记环（Mark Ring）</h3>
<div class="outline-text-3" id="text-Mark-Ring">
<p>
每个缓冲区都会通过 <b>mark ring标记环</b> 记录标记的历史位置，设置标记的命令会将旧标记压入该标记环中。标记环的用途之一，就是记录你可能需要返回的位置。
</p>

<dl class="org-dl">
<dt><code>C-SPC C-SPC</code></dt><dd>设置标记并将其压入标记环，且不激活该标记。</dd>
<dt><code>C-u C-SPC</code></dt><dd>将光标移至标记的上一位置，并从历史标记环中恢复标记位置。</dd>
</dl>

<p>
当你希望用标记记录一个后续可能返回的位置时，命令 <code>C-SPC C-SPC</code> 会非常实用。该操作会将当前光标位置压入标记环，且不会激活标记（激活标记会让 Emacs 高亮显示对应区域）。这一操作实际是连续两次执行 <code>C-SPC</code> (<code>set-mark-command</code>) ：第一次按下 <code>C-SPC</code> 用于设置标记，第二次则用于取消标记的激活状态。（若临时标记模式处于关闭状态， <code>C-SPC C-SPC</code> 会临时激活该模式，详见「<a href="#Disabled-Transient-Mark">关闭临时标记模式</a>」相关内容。）
</p>

<p>
若要返回标记记录的位置，可带前缀参数执行 <code>set-mark-command</code> 命令： <code>C-u C-SPC</code> 。该操作会将光标移至标记的上一位置，若标记原本处于激活状态，则会将其取消激活。后续每一次按下 <code>C-u C-SPC</code> ，都会跳转到标记环中存储的更早一个位置，通过这种方式遍历的位置不会从环中丢失，而是会被移至标记环的末尾。
</p>

<p>
若将变量 <code>set-mark-command-repeat-pop</code> 设为非 nil 值，那么在按下 <code>C-u C-SPC</code> 后，可直接按下 <code>C-SPC</code> 替代 <code>C-u C-SPC</code> ，实现标记环的循环遍历。该变量的默认值为 <code>nil</code> 。
</p>

<p>
<b>每个缓冲区都有独立的标记环</b> ，所有编辑命令均使用当前缓冲区的标记环，因此 <code>C-u C-SPC</code> 的跳转操作始终在当前缓冲区中进行，不会跳至其他缓冲区。
</p>

<p>
变量 <code>mark-ring-max</code> 用于指定标记环中可保存的最大记录数，默认值为 16 条。当标记环中的记录达到该上限，且有新标记被压入时，最早存入的那条记录会被丢弃。重复按下 <code>C-u C-SPC</code> ，会在当前标记环中存储的所有位置间循环跳转。
</p>

<p>
若你需要反复返回同一个位置，标记环的操作方式可能不够便捷。这种情况下，你可将该位置记录到寄存器中，方便后续快速调取（详见「<a href="#Position-Registers">在寄存器中保存位置</a>」相关内容）。
</p>
</div>
</div>
<div id="outline-container-Global-Mark-Ring" class="outline-3">
<h3 id="Global-Mark-Ring"><span class="section-number-3">13.5.</span> 全局标记环（Global Mark Ring）</h3>
<div class="outline-text-3" id="text-Global-Mark-Ring">
<p>
除了每个缓冲区各自拥有的普通标记环外，Emacs 还配有一个 <code>global mark ring</code> 全局标记环。若在上一次设置标记后切换过缓冲区，那么每次你设置新标记时，该标记会被同时记录在当前缓冲区的标记环与全局标记环中。因此，全局标记环会记录你曾操作过的缓冲区序列，且为每个缓冲区留存一处标记设置的位置。全局标记环的最大记录数由变量 <code>global-mark-ring-max</code> 控制，默认值为 16 条。
</p>

<p>
需注意， <b>仅当通过命令新建标记时</b> ，该标记才会被记录到全局标记环中。若只是激活已存在的标记（例如在已有标记的位置按下 <code>C-SPC</code> ，详见「<a href="#Setting-Mark">设置标记</a>」章节），并不会将该标记压入全局标记环。
</p>

<p>
命令 <code>C-x C-SPC</code> (<code>pop-global-mark</code>) 会跳转到全局标记环中最新记录对应的缓冲区与位置，同时会对全局标记环进行轮循 —— 连续按下 <code>C-x C-SPC</code> ，会依次跳转到更早记录的缓冲区及对应标记位置。
</p>
</div>
</div>
<div id="outline-container-Shift-Selection" class="outline-3">
<h3 id="Shift-Selection"><span class="section-number-3">13.6.</span> 移位选择（Shift Selection）</h3>
<div class="outline-text-3" id="text-Shift-Selection">
<p>
在按下光标移动命令的同时按住 Shift 键，会先设置标记，再移动光标，使区域覆盖从光标原始位置到新位置的范围。该功能被称为 <b>shift-selection 移位选择</b> ，其文本选中方式与其他编辑器的操作逻辑相近。
</p>

<p>
通过移位选择设置的标记，行为与前文所述的常规标记略有不同。其一，除了常规的标记取消激活方式（如修改缓冲区文本、按下  <code>C-g</code> ）外， <b>任何未按住 Shift 键的光标移动命令</b> ，都会触发标记的取消激活；其二，后续再次按下的移位光标移动命令，不会重新设置标记。因此，连续执行一系列移位光标移动命令，可对选中区域进行连续调整。
</p>

<p>
仅当移位后的光标移动键 <b>未绑定至其他独立命令</b> 时，移位选择功能才会生效（参见「<a href="#Customization">自定义配置</a>」相关内容）。例如，若将  <code>S-C-f</code> 绑定至其他命令，按下 <code>S-C-f</code> 时会执行该绑定命令，而非触发 <code>C-f</code> (<code>forward-char</code>) 对应的移位选择操作。
</p>

<p>
通过鼠标命令设置的标记，与移位选择设置的标记行为 <b>完全一致</b> （参见「<a href="#Setting-Mark">设置标记</a>」相关内容）。例如，通过鼠标拖动划定区域后，可继续使用移位光标移动命令扩展该区域。无论以哪种方式设置标记，只要按下未按住 Shift 键的光标移动命令，都会取消标记的激活状态。
</p>

<p>
若要关闭移位选择功能，可将变量 <code>shift-select-mode</code> 的值设为 <code>nil</code> ，此操作不会禁用通过鼠标命令设置标记的功能。若将该变量值设为 <code>permanent</code> ，未经过移位转换的光标移动键将不会触发标记的取消激活；例如，此前命令划定的区域可通过移位选择继续扩展，未按住 Shift 键的光标移动键也能对移位选择划定的区域进行扩展。
</p>
</div>
</div>
<div id="outline-container-Disabled-Transient-Mark" class="outline-3">
<h3 id="Disabled-Transient-Mark"><span class="section-number-3">13.7.</span> 禁用瞬时标记模式（Disabling Transient Mark Mode）</h3>
<div class="outline-text-3" id="text-Disabled-Transient-Mark">
<p>
标记与区域的默认行为 —— 设置标记时会激活标记并高亮显示区域 —— 由 <b>临时标记模式</b> （Transient Mark mode） 实现。该模式为次要模式，在交互会话中默认启用，可通过 <code>M-x transient-mark-mode</code> 命令切换开关，也可通过「Options选项」菜单中的「Highlight Active Region 高亮激活区域」菜单项进行操作。关闭该模式后，Emacs 会切换为另一套操作方式：
</p>

<ul class="org-ul">
<li><p>
执行 <code>C-SPC</code> 、 <code>C-x C-x</code> 等命令设置标记时， <b>不会高亮显示区域</b> 。因此无法通过视觉判断标记的位置，只能手动记忆。
</p>

<p>
解决这一问题的常用方法是，设置标记后尽快使用，避免忘记其位置；也可通过 <code>C-x C-x</code> 命令查看标记位置，该命令会交换光标与标记的位置（参见「<a href="#Setting-Mark">设置标记</a>」章节）。
</p></li>

<li>部分原本在标记激活时会对区域执行操作的命令，将不再具备该行为。例如默认情况下，若标记处于激活状态， <code>M-%</code> (<code>qurey-replace</code>) 会在区域内执行替换操作；而关闭临时标记模式后，该命令会始终从光标位置开始，执行至缓冲区末尾。这类存在行为差异的命令，会在其自身的文档说明中明确标注。</li>
</ul>

<p>
关闭临时标记模式后，可通过 <code>C-SPC C-SPC</code> 或 <code>C-u C-x C-x</code> <b>临时激活</b> 该模式。
</p>

<dl class="org-dl">
<dt><code>C-SPC C-SPC</code></dt><dd>在光标位置设置标记（与普通的 <code>C-SPC</code> 操作一致），并一次性启用临时标记模式，直至标记被取消激活为止。（这并非独立命令，而是连续执行两次 <code>C-SPC</code> 命令的效果。）</dd>

<dt><code>C-u C-x C-x</code></dt><dd>交换光标与标记的位置，激活标记并临时启用临时标记模式，直至标记下一次被取消激活。（这是带前缀参数执行 <code>C-x C-x</code> 命令 <code>exchange-point-and-mark</code> 的效果。）</dd>
</dl>

<p>
上述命令在设置 或者 激活标记的同时，仅会在 <b>标记激活期间</b> 临时启用临时标记模式。使用该操作的一个常见原因是：关闭临时标记模式后，部分命令会对整个缓冲区而非区域执行操作，而临时启用该模式，就能让这些命令重新对区域生效。
</p>

<p>
通过鼠标（参见「<a href="#Setting-Mark">设置标记</a>」章节）或移位选择（参见「<a href="#Shift-Selection">移位选择</a>」章节）划定区域时，Emacs 也会以同样的方式 <b>临时激活临时标记模式</b> ，并高亮显示该区域。
</p>
</div>
</div>
</section>
<section id="outline-container-Killing" class="outline-2">
<h2 id="Killing"><span class="section-number-2">14.</span> 剪切与移动文本（Killing and Moving Text）</h2>
<div class="outline-text-2" id="text-Killing">
<p>
在 Emacs 中， <code>killing</code> 指擦除文本并将其复制到 <code>kill ring</code> 删除环中， <code>yanking</code> 指将删除环中的文本重新插入到缓冲区中。（部分应用程序将类似操作称为「cutting剪切」和「pasting粘贴」。）之所以称其为删除环，是因为可以将其想象成一组按环形排列的文本块，你能以循环的方式访问其中的内容，详见「<a href="#Kill-Ring">删除环</a>」相关章节。
</p>

<p>
killing删除与yanking粘贴是 Emacs 中移动或复制文本最常用的方式，该方式的灵活性极高，因为 Emacs 提供了针对多种不同语法单元的删除命令。
</p>
<ul class="org-ul">
<li><a href="#Deletion-and-Killing">删除与剪切</a></li>
<li><a href="#Yanking">粘贴（Yanking）</a></li>
<li><a href="#Cut-and-Paste">图形界面中的 “复制 - 粘贴” 操作</a></li>
<li><a href="#Accumulating-Text">文本累积（Accumulating Text）</a></li>
<li><a href="#Rectangles">矩形操作（Rectangles）</a></li>
<li><a href="#CUA-Bindings">CUA 键绑定（CUA Bindings）</a></li>
</ul>
</div>
<div id="outline-container-Deletion-and-Killing" class="outline-3">
<h3 id="Deletion-and-Killing"><span class="section-number-3">14.1.</span> 删除与剪切</h3>
<div class="outline-text-3" id="text-Deletion-and-Killing">
<p>
大多数从缓冲区中清除文本的命令，会将清除的文本保存至删除环中（参见「<a href="#Kill-Ring">删除环</a>」）。这类命令被称为 <b>kill commands删除命令</b> ，其名称中通常包含 “kill” 一词（例如  <code>kill-line</code> ）。删除环会存储近期多次执行删除操作的文本，而非仅保留最后一次的内容，因此删除操作的安全性很高：你无需过度担心丢失之前删除的文本。 删除环为 <b>所有缓冲区共享</b> ，因此在一个缓冲区中删除的文本，可粘贴至另一个缓冲区中。
</p>

<p>
当你使用 <code>C-/</code> (<code>undo</code> 撤销) 来撤销某一删除命令时（参见「<a href="#Undo">撤销</a>」），被删除的文本会恢复至缓冲区，但不会从删除环中移除。
</p>

<p>
在图形化显示界面中，执行删除操作的同时，还会将文本复制到系统剪贴板，详见「<a href="#Cut-and-Paste">图形化界面中的『剪切 - 粘贴』操作</a>』。
</p>

<p>
仅清除文本但 <b>不将其保存至删除环</b> 的命令，被称为 <b>delete commands 擦除命令</b> ，其名称中通常包含 “delete” 一词。这类命令包括 <code>C-d</code> (<code>delete-char</code> ，向前擦除字符) 和 <code>DEL</code> (<code>delete-backward-char</code> ，向后擦除字符) —— 二者均一次仅擦除一个字符，以及所有仅用于擦除空格或换行符的命令。通常，若某一命令会清除大量有效文本，其执行的是删除(kill)操作而非擦除操作。
</p>

<p>
你也可通过鼠标执行删除与粘贴操作，详见「<a href="#Cut-and-Paste">图形化界面中的『剪切 - 粘贴』操作</a>」。
</p>

<ul class="org-ul">
<li><a href="#Deletion">删除操作</a></li>
<li><a href="#Killing-by-Lines">按行剪切</a></li>
<li><a href="#Other-Kill-Commands">其他剪切命令</a></li>
<li><a href="#Kill-Options">剪切相关选项</a></li>
</ul>
</div>
<div id="outline-container-Deletion" class="outline-4">
<h4 id="Deletion"><span class="section-number-4">14.1.1.</span> 删除操作</h4>
<div class="outline-text-4" id="text-Deletion">
<p>
<code>delete</code> 擦除指清除文本且 <b>不将其保存至删除环</b> 的操作。Emacs 中的擦除命令，大多仅用于清除单个字符或空白字符。
</p>

<dl class="org-dl">
<dt><code>DEL</code></dt><dd></dd>

<dt><code>BACKSPACE</code></dt><dd>删除前一个字符；若区域处于激活状态，则删除区域内的文本 (<code>delete-backward-char</code>) 。</dd>
<dt><code>Delete</code></dt><dd>删除后一个字符；若区域处于激活状态，则删除区域内的文本 (<code>delete-forward-char</code>) 。</dd>
<dt><code>C-d</code></dt><dd>删除后一个字符 (<code>delete-char</code>) 。</dd>
<dt><code>M-\</code></dt><dd>删除光标位置前后的空格与制表符 (<code>delete-horizontal-space</code>) 。</dd>
<dt><code>M-x just-one-space</code></dt><dd>删除光标位置前后的空格与制表符，仅保留一个空格。</dd>
<dt><code>M-SPC</code></dt><dd>以灵活的方式删除光标位置前后的空格与制表符 (<code>cycle-spacing</code>) 。</dd>
<dt><code>C-x C-o</code></dt><dd>删除当前行前后的空行 (<code>delete-blank-lines</code>) 。</dd>
<dt><code>M-^</code></dt><dd>删除两行之间的换行符及换行符后的所有缩进，将两行合并为一行 (<code>delete-indentation</code>) 。</dd>
</dl>

<p>
前文已介绍过 "basic deletion commands基础擦除命令" <code>DEL</code> (<code>delete-backward-char</code>) 、 <code>Delete</code> (<code>delete-forward-char</code>) 与 <code>C-d</code> (<code>delete-char</code>) ，详见「<a href="#Erasing">文本擦除</a>」章节。为这些命令指定数字参数时，会按参数值删除对应数量的字符；若省略参数或参数为 1，当区域处于激活状态时， <code>DEL</code> 与 <code>Delete</code> 命令会删除区域内的所有文本，详见「<a href="#Using-Region">对区域进行操作</a>」章节。
</p>

<p>
其余擦除命令均仅用于清除空白字符（空格、制表符、换行符）。
</p>

<p>
<code>M-\</code> (<code>delete-horizontal-space</code>) 会删除光标位置前后所有的空格与制表符；若为该命令添加前缀参数，则仅删除光标位置之前的空格与制表符。
</p>

<p>
<code>M-x just-one-space</code> 会删除光标位置前后的制表符与空格，且无论原位置有多少个空格（即便无空格），均在光标前保留一个空格。为该命令指定正数字参数 <code>n</code> 时，会在光标前保留 <code>n</code> 个空格；若参数为负数字 <code>-n</code> ，则除了删除空格与制表符外，还会删除换行符，并在光标前保留 <code>-n</code> 个空格。
</p>

<p>
<code>cycle-spacing</code> (<code>M-SPC</code>) 可看作是功能更灵活的 <code>just-one-space</code> 命令。若连续重复执行该命令，它会按照 <code>cycle-spacing-actions</code> 变量定义的规则，循环执行不同的空白字符清理操作。默认规则为：第一次执行等同于 <code>just-one-space</code> 命令，第二次执行等同于 <code>delete-horizontal-space</code> 命令（删除光标前后所有空白字符），第三次执行恢复光标位置原本的空白字符布局，后续按此规则循环。若为该命令添加前缀参数，所有循环操作都会沿用该参数值。用户可通过自定义 <code>cycle-spacing-actions</code> 变量添加更多清理规则，具体可参考该变量的文档说明。
</p>

<p>
<code>C-x C-o</code> (<code>delete-blank-lines</code>) 会删除当前行之后的所有空行；若当前行本身为空行，则同时删除当前行之前的所有空行（仅保留当前行这一个空行）；若缓冲区中仅有这一个空行，则直接删除该行。
</p>

<p>
<code>M-^</code> (<code>delete-indentation</code>) 会删除换行符及其周围的所有空格，将当前行与上一行合并为一行，通常仅在合并处保留一个空格，详见「<a href="#Indentation">M-^ 命令说</a>明」。
</p>

<p>
<code>delete-duplicate-lines</code> 命令会在区域内查找重复的行，并删除每行的多余副本，仅保留一份。默认保留每组重复行中的第一行；若为该命令添加前缀参数 <code>C-u</code> ，则保留每组重复行中的最后一行；若添加前缀参数 <code>C-u C-u</code> ，则仅查找相邻的重复行（该模式执行效率更高，适用于已排序的文本）；若添加前缀参数 <code>C-u C-u C-u</code> ，则会保留重复的空行不做删除。
</p>
</div>
</div>
<div id="outline-container-Killing-by-Lines" class="outline-4">
<h4 id="Killing-by-Lines"><span class="section-number-4">14.1.2.</span> 按行剪切</h4>
<div class="outline-text-4" id="text-Killing-by-Lines">
<dl class="org-dl">
<dt><code>C-k</code></dt><dd>剪切行尾剩余内容，或剪切一行或多行内容 (<code>kill-line</code>) 。</dd>
<dt><code>C-S-backspace</code></dt><dd>一次性剪切整行内容 (<code>kill-whole-line</code>) 。</dd>
</dl>

<p>
最简单的剪切命令是 <code>C-k</code> (<code>kill-line</code>) 。若在行尾使用该命令，它会剪切行尾的换行符，将下一行合并至当前行（因此空行会被彻底删除）。若不在行尾， <code>C-k</code> 会剪切从光标位置到行尾的所有文本；若光标原本就在行首，执行后该行会变为空行。
</p>

<p>
判断适用上述哪种情况时，会忽略行尾的空格和制表符。只要光标位于行中最后一个非空白字符之后，即可确定 <code>C-k</code> 会剪切换行符。若要剪切一整行非空内容，需将光标移至行首，连续按两次 <code>C-k</code> 。
</p>

<p>
此处的「line行」指 <b>逻辑文本行</b> ，而非屏幕显示行（详见「<a href="#Continuation-Lines">折行</a>」相关说明）。
</p>

<p>
当给 <code>C-k</code> 传入正数值参数 <code>n</code> 时，它会剪切 <code>n</code> 行内容及其后续的换行符（光标之前的当前行文本不会被剪切）。若传入负数值参数 <code>-n</code> ，它会剪切当前行之前的 <code>n</code> 行内容，以及光标之前的当前行文本。若给 <code>C-k</code> 传入参数 0，则仅剪切光标之前的当前行文本。
</p>

<p>
若变量 <code>kill-whole-line</code> 的值为非空（non-nil），在行首执行 <code>C-k</code> 会剪切包含后续换行符在内的整行内容。该变量的默认值为空（nil）。
</p>

<p>
<code>C-S-backspace</code> (<code>kill-whole-line</code>) 会剪切包含换行符在内的整行内容，与光标在该行中的位置无关。注意，许多文本终端会限制输入 <code>C-S-backspace</code> 这个按键组合。
</p>
</div>
</div>
<div id="outline-container-Other-Kill-Commands" class="outline-4">
<h4 id="Other-Kill-Commands"><span class="section-number-4">14.1.3.</span> 其他剪切命令</h4>
<div class="outline-text-4" id="text-Other-Kill-Commands">
<dl class="org-dl">
<dt><code>C-w</code></dt><dd>剪切区域内的文本 (<code>kill-region</code>) 。</dd>
<dt><code>M-w</code></dt><dd>将区域内的文本复制到剪切环 (<code>kill-ring-save</code>) 。</dd>
<dt><code>M-d</code></dt><dd>剪切下一个单词 (<code>kill-word</code>) ，详见「<a href="#Words">单词</a>」相关说明。</dd>
<dt><code>M-DEL</code></dt><dd>向前剪切一个单词 (<code>backward-kill-word</code>) 。</dd>
<dt><code>C-x DEL</code></dt><dd>向前剪切至句子开头 (<code>backward-kill-sentence</code>) ，详见「<a href="#Sentences">句子</a>」相关说明。</dd>
<dt><code>M-k</code></dt><dd>剪切至句子末尾 (<code>kill-sentence</code>) 。</dd>
<dt><code>C-M-k</code></dt><dd>剪切后续的匹配表达式 (<code>kill-sexp</code>) ，详见「<a href="#Expressions">括号匹配表达式</a>」相关说明。</dd>
<dt><code>M-z char</code></dt><dd>剪切至指定字符的下一次出现位置（含该字符） (<code>zap-to-char</code>) 。</dd>
<dt><code>M-x zap-up-to-char char</code></dt><dd>剪切至指定字符的下一次出现位置（不含该字符）。</dd>
</dl>

<p>
最常用的剪切命令之一是 <code>C-w</code> (<code>kill-region</code>) ，该命令会剪切区域内的所有文本（详见「<a href="#Mark">标记与区域</a>」相关说明）。与之对应， <code>M-w</code> (<code>kill-ring-save</code>) 会将区域内的文本复制到剪切环，而不会从缓冲区中删除该文本。若按下 <code>C-w</code> 或 <code>M-w</code> 时标记处于未激活状态，命令会作用于光标位置与上一次设置标记的位置之间的文本（详见「<a href="#Using-Region">区域操作</a>」相关说明）。
</p>

<p>
Emacs 还提供了剪切特定语法单元的命令：可通过 <code>M-DEL</code> 和 <code>M-d</code> 剪切单词（详见「<a href="#Words">单词</a>」）；通过 <code>C-M-k</code> 剪切括号匹配表达式（详见「<a href="#Expressions">括号匹配表达式</a>」）；通过 <code>C-x DEL</code> 和 <code>M-k</code> 剪切句子（详见「<a href="#Sentences">句子</a>」）。
</p>

<p>
<code>M-z</code> (<code>zap-to-char</code>) 命令将剪切与搜索结合：输入一个字符后，命令会从光标位置开始，剪切至该字符在缓冲区中下一次出现的位置（包含该字符本身）。传入数字参数表示重复执行次数；传入负数值参数则表示 <b>向前搜索</b> 并剪切光标之前的内容。该命令会保留此前输入过的字符历史，可通过 <code>M-p</code> / <code>M-n</code> 按键调取，此功能在需要通过复杂输入法输入目标字符时尤为实用。与之类似的 <code>zap-up-to-char</code> 命令，同样剪切至指定字符的下一次出现位置，但 <b>不包含该字符本身</b> ，数字参数的作用同样为重复执行次数。
</p>
</div>
</div>
<div id="outline-container-Kill-Options" class="outline-4">
<h4 id="Kill-Options"><span class="section-number-4">14.1.4.</span> 剪切相关选项</h4>
<div class="outline-text-4" id="text-Kill-Options">
<p>
部分专用缓冲区包含 <code>read-only text</code> 只读文本，这类文本无法修改，因此也无法被剪切。 <code>kill commands</code> 剪切命令在只读缓冲区中会以特殊方式工作：光标会遍历目标文本并将其复制到剪切环，却不会从缓冲区中实际删除该文本。默认情况下，执行此操作时编辑器还会发出提示音并显示错误信息。但如果将变量 <code>kill-read-only-ok</code> 设为非空值，编辑器仅会在回显区打印一条提示信息，说明文本未被删除的原因。
</p>

<p>
在将剪切内容存入剪切环（kill ring）之前，你可以通过 <code>kill-transform-function</code> 函数对目标字符串进行转换。该函数会接收待剪切的字符串作为参数，返回值为你希望存入剪切环的字符串；若返回 <code>nil</code> ，则该字符串不会被存入剪切环。例如，若你希望永远不将纯空白字符串存入杀环，可使用以下配置：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq</span> kill-transform-function
      (<span style="color: #a020f0;">lambda</span> (string)
        (<span style="color: #a020f0;">and</span> (not (string-blank-p string))
             string)))
</pre>
</div>

<p>
若将变量 <code>kill-do-not-save-duplicates</code> 设为非空值，连续执行的多次相同剪切操作，最终仅会在剪切环中生成一条条目，不会产生重复内容。
</p>

<p>
若启用次要模式 <code>kill-ring-deindent-mode</code> ，存入剪切环的文本会自动减少缩进量，减少的幅度与被保存文本第一行的缩进量一致。也就是说，若被保存文本的第一行有n列的缩进，该模式会从每一行的缩进中均移除n列的空白。
</p>
</div>
</div>
</div>
<div id="outline-container-Yanking" class="outline-3">
<h3 id="Yanking"><span class="section-number-3">14.2.</span> 粘贴（Yanking）</h3>
<div class="outline-text-3" id="text-Yanking">
<p>
<code>Yanking</code> 粘贴指重新插入此前被剪切的文本。移动或复制文本的常规方式为：先将文本剪切，再在其他位置将其粘贴。
</p>

<dl class="org-dl">
<dt><code>C-y</code></dt><dd>将最近一次剪切的内容粘贴到缓冲区的光标位置 (<code>yank</code>) 。</dd>
<dt><code>M-y</code></dt><dd>将刚粘贴的文本替换为更早一次剪切的文本块 (<code>yank-pop</code>) ，或支持从过往所有剪切的文本块列表中选择粘贴内容，详见「<a href="#Earlier-Kills">粘贴更早的剪切内容</a>」。</dd>
<dt><code>C-M-w</code></dt><dd>让后续执行的命令（若为剪切命令）将内容追加至前一次的剪切结果中（追加下一次剪切命令），详见「<a href="#Appending-Kills">追加剪切内容</a>」。</dd>
</dl>

<p>
基础的粘贴命令为 <code>C-y</code> (<code>yank</code>) ，该命令会插入最近一次剪切的内容，光标停留在插入文本的末尾；同时会在插入文本的开头位置设置标记（标记处于未激活状态），若需要跳转到该位置，可使用 <code>C-u C-SPC</code> 快捷键实现（详见「<a href="#Mark-Ring">标记环</a>」）。
</p>

<p>
若使用纯前缀参数执行该命令 <code>C-u C-y</code> ，光标会停留在插入文本的前方，并将标记设置在插入文本的末尾。使用其他任意前缀参数时，可指定粘贴更早一次的剪切内容：例如 <code>C-u 4 C-y</code> ，会重新插入倒数第四次剪切的内容，详见「<a href="#Earlier-Kills">粘贴更早的剪切内容</a>」。
</p>

<p>
在图形化界面及支持该功能的文本模式界面中， <code>C-y</code> 会首先检查：其他应用程序是否在 Emacs 最后一次剪切操作之后，向系统剪贴板写入了新的文本。若检测到新内容，C-y会优先插入系统剪贴板中的文本。因此，Emacs 会将其他应用中执行的剪贴板「cut剪切」或「copy复制」操作，视作 Emacs 自身的剪切操作来处理；区别在于，这些外部操作的内容 <b>不会被记录在 Emacs 的kill ring剪切环中</b> 。相关细节详见「<a href="#Cut-and-Paste">图形化界面中的 “剪切与粘贴” 操作</a>」。
</p>


<ul class="org-ul">
<li><a href="#Kill-Ring">剪切环（Kill Ring）</a></li>
<li><a href="#Earlier-Kills">粘贴之前的剪切内容</a></li>
<li><a href="#Appending-Kills">追加剪切内容（Appending Kills）</a></li>
</ul>
</div>
<div id="outline-container-Kill-Ring" class="outline-4">
<h4 id="Kill-Ring"><span class="section-number-4">14.2.1.</span> 剪切环（Kill Ring）</h4>
<div class="outline-text-4" id="text-Kill-Ring">
<p>
<code>kill ring</code> 剪切环是此前被剪切的文本块构成的列表。Emacs 中 <b>仅有一个剪切环</b> ，由所有缓冲区共享，因此你可在一个缓冲区中剪切文本，再在另一个缓冲区中粘贴，这也是将文本从一个缓冲区移至另一缓冲区的常规方式。（此外还有多种实现方法：例如可将文本存入寄存器，详见「<a href="#Registers">寄存器</a>」章节；也可参考「<a href="#Accumulating-Text">文本累加</a>」章节，了解其他文本移动方式。）
</p>

<p>
剪切环中的最大条目数由变量 <code>kill-ring-max</code> 控制，其默认值为 120。当剪切环达到该数量上限后，若执行新的剪切操作，Emacs 会删除剪切环中最旧的条目，为新内容腾出空间。
</p>

<p>
剪切环的实际内容存储在名为 <code>kill-ring</code> 的变量中，你可通过快捷键 <code>C-h v kill-ring</code> 查看剪切环的全部内容。
</p>
</div>
</div>
<div id="outline-container-Earlier-Kills" class="outline-4">
<h4 id="Earlier-Kills"><span class="section-number-4">14.2.2.</span> 粘贴之前的剪切内容</h4>
<div class="outline-text-4" id="text-Earlier-Kills">
<p>
正如「<a href="#Yanking">粘贴</a>」章节所述，你可以为快捷键 <code>C-y</code> 添加数字参数，来粘贴并非最近一次的删除文本。如果你能记清想要调用删除环中的哪一项内容，这个方法会非常实用。若记不清，可使用 <code>M-y</code> (<code>yank-pop</code>) 命令遍历所有删除记录，或从中选中某条更早的删除内容。
</p>

<p>
如果上一个执行的命令是粘贴类命令， <code>M-y</code> 会将当前已粘贴的文本，替换为删除环中更早一条的删除内容。因此，若要恢复倒数第二次的删除文本，需先执行 <code>C-y</code> 粘贴最后一次的删除内容，再执行 <code>M-y</code> 将其替换为前一次的删除内容。该操作 <b>仅在执行C-y或其他M-y命令后有效</b> （若在其他命令后调用 <code>M-y</code> ，执行逻辑会有所不同，详见下文）。
</p>

<p>
你可以通过 <b>最后粘贴指针</b> 来理解 <code>M-y</code> 的这一运行模式：该指针始终指向删除环中的某一条目。每次执行删除操作时，最后粘贴指针会移动到删除环头部新生成的条目处。 <code>C-y</code> 会粘贴该指针指向的条目；在 <code>C-y</code> 或其他 <code>M-y</code> 之后执行 <code>M-y</code> ，会将最后粘贴指针移动到上一条目，同时缓冲区中的文本会同步替换为该条目内容。连续执行多次 <code>M-y</code> ，可将指针移动到删除环中的任意条目，从而将任意删除内容调入缓冲区。当指针到达删除环末尾时，再次执行 <code>M-y</code> 会循环回到第一条目。
</p>

<p>
<code>M-y</code> 仅会移动删除环中的最后粘贴指针， <b>不会改变删除环中条目的顺序</b> —— 删除环始终保持「头部为最近一次删除内容，尾部为仍保留的最早一次删除内容」的顺序。
</p>

<p>
在 <code>C-y</code> 或 <code>M-y</code> 之后执行 <code>M-y</code> 时，也可为其添加数字参数，该参数用于指定最后粘贴指针需要向前移动的条目数。负数字参数会让指针向删除环头部移动；若指针已在头部，会循环到尾部并继续向前移动。
</p>

<p>
当你找到目标文本并将其调入缓冲区后，即可停止执行 <code>M-y</code> ，此时最后粘贴的文本会保留在缓冲区中。该文本仅是删除环条目的一份副本，因此在缓冲区中编辑它， <b>不会改变删除环中原有的内容</b> 。只要未执行新的删除操作，最后粘贴指针会始终停留在删除环的当前位置，重复执行 <code>C-y</code> 会粘贴同一条历史删除内容的另一份副本。
</p>

<p>
为 <code>C-y</code> 添加数字参数执行时，最后粘贴指针也会同步指向此次粘贴的条目。
</p>

<p>
你也可在非粘贴类命令后调用 <code>M-y</code> ，此时 <code>M-y</code> 会在迷你缓冲区中弹出提示，让你选择某条历史删除内容。你可使用 <b>迷你缓冲区历史命令</b> （参见「<a href="#Minibuffer-History">迷你缓冲区历史</a>」）遍历或搜索删除环中的条目，直至找到想要重新插入的内容；也可使用补全命令（参见「<a href="#Completion-Commands">补全命令</a>」），对删除环条目列表进行补全匹配，或弹出 <code>*Completions*</code> （补全）缓冲区，从候选条目中选择目标内容。选中删除环条目后，你还可在迷你缓冲区中对其进行编辑。最后按下 <code>RET</code> （回车）退出迷你缓冲区，选中的删除环条目文本就会插入到缓冲区中。与在粘贴命令后执行 <code>M-y</code> 的情况相同，最后粘贴指针会指向此次刚粘贴的文本（无论该文本是某条原始历史删除内容，还是你编辑后再插入的删除环条目 —— 若为后者，编辑后的条目会被添加到删除环的头部）。因此，这种情况下执行 <code>C-y</code> ，也会粘贴刚插入的文本的另一份副本。
</p>

<p>
在非粘贴类命令后，使用纯前缀参数 (<code>C-u M-y</code>) 调用 <code>M-y</code> 时，该命令会将光标定位在插入文本的前方，并在文本末尾设置标记，与 <code>C-y</code> 的默认行为一致。
</p>
</div>
</div>
<div id="outline-container-Appending-Kills" class="outline-4">
<h4 id="Appending-Kills"><span class="section-number-4">14.2.3.</span> 追加剪切内容（Appending Kills）</h4>
<div class="outline-text-4" id="text-Appending-Kills">
<p>
默认情况下，每一个删除命令都会向删除环中新增一条独立条目。但 <b>连续执行的两个或多个删除命令</b> ，会将其删除的文本合并为删除环中的单一条目，如此一来，单次执行 <code>C-y</code> 即可将所有文本作为一个整体粘贴回来，与删除前的原貌一致。
</p>

<p>
因此，若你希望将一段文本作为整体粘贴，无需用单个命令一次性删除全部内容；你可以逐行、逐个单词地连续执行删除操作，直至删完目标文本，后续仍能一次性将其全部恢复。
</p>

<p>
从光标处向前删除的命令，会将删除的文本追加到上一次删除内容的末尾；从光标处向后删除的命令，会将删除的文本添加到上一次删除内容的开头。通过这种方式，无论你混合执行多少次向前、向后的删除命令，所有被删除的文本都会按原有顺序合并为删除环中的单一条目，不会发生内容错乱。为删除命令添加数字参数，并不会打断这种删除内容的追加序列。例如，假设缓冲区中有如下文本：
</p>

<div class="org-src-container">
<pre class="src src-shell">This is a line &#8727;of sample text.
</pre>
</div>

<p>
其中 <code>∗</code> 为光标位置。若你依次执行 <code>M-d</code> （删除后一个单词）、 <code>M-DEL</code> （删除前一个单词）、 <code>M-d</code> 、 <code>M-DEL</code> ，交替进行向前、向后删除，最终删除环中会新增单一条目a line of sample，而缓冲区中剩余文本为 "This is text." （注意is与text之间的两个空格，可使用 <code>M-SPC</code> 或 <code>M-q</code> 整理）。
</p>

<p>
删除上述相同文本的另一种方式：先执行 <code>M-b M-b</code> 将光标向前移动两个单词，再执行 <code>C-u M-d</code> 向前一次性删除四个单词。这种操作在缓冲区和删除环中产生的结果，与前一种交替删除的方式完全一致。即便执行 <code>M-f M-f</code> 将光标后移两个单词，再执行 <code>C-u M-DEL</code> 向后一次性删除四个单词，最终结果也毫无差别 —— 删除环中该条目内的文本，始终与删除前其在缓冲区中的原有顺序保持一致。
</p>

<p>
若某一删除命令与上一次删除命令之间，插入了 <b>其他非删除命令</b> （仅添加数字参数除外），则该命令会在删除环中新建一条独立条目。但你可通过提前执行 <code>C-M-w</code> (<code>append-next-kill</code> 追加下一次删除) ，强制让该删除命令与上一次的删除内容合并。 <code>C-M-w</code> 的作用是：告知其后紧跟的命令（若为删除命令），将此次删除的内容视作上一次删除序列的一部分。与常规的追加规则一致，若该删除命令为向前删除，则将文本追加到上一次删除内容的末尾；若为向后删除，则将文本添加到上一次删除内容的开头。通过这种方式，你可以删除缓冲区中多处不连续的文本，并将其全部累积为一个整体，后续在某一位置一次性粘贴回来。
</p>

<p>
执行 <code>M-w</code> (<code>kill-ring-save</code> 保存到删除环，即复制) 后，紧跟的删除命令不会将删除的文本，追加到 <code>M-w</code> 复制到删除环中的内容之后。
</p>
</div>
</div>
</div>
<div id="outline-container-Cut-and-Paste" class="outline-3">
<h3 id="Cut-and-Paste"><span class="section-number-3">14.3.</span> 图形界面中的 “复制 - 粘贴” 操作</h3>
<div class="outline-text-3" id="text-Cut-and-Paste">
<p>
在大多数图形化桌面环境中，你可通过名为 <b>clipboard剪贴板</b> 的系统功能，在不同应用程序间传输数据（通常为文本）。在 X 窗口系统中，还有另外两种类似的功能可用： <b>主选择区</b> 和 <b>次选择区</b> 。当 Emacs 在图形化显示界面中运行时，其删除和粘贴命令会与这些系统功能集成，因此你能轻松在 Emacs 与其他图形化应用之间传输文本。
</p>

<p>
默认情况下，Emacs 将 <b>UTF-8</b> 用作程序间文本传输的编码系统。若你发现粘贴的文本与预期不符，可通过键入 <code>C-x RET x</code> 或 <code>C-x RET X</code> 指定其他编码系统；也可通过自定义 <code>x-select-request-type</code> 变量，请求使用不同的数据类型。详见《<a href="#Communication-Coding">进程间通信的编码系统</a>》章节。
</p>

<ul class="org-ul">
<li><a href="#Clipboard">使用剪贴板</a></li>
<li><a href="#Primary-Selection">与其他窗口应用程序的复制 - 粘贴</a></li>
<li><a href="#Secondary-Selection">次要选择（Secondary Selection）</a></li>
</ul>
</div>
<div id="outline-container-Clipboard" class="outline-4">
<h4 id="Clipboard"><span class="section-number-4">14.3.1.</span> 使用剪贴板</h4>
<div class="outline-text-4" id="text-Clipboard">
<p>
<code>clipboard</code> 剪贴板是绝大多数图形化应用程序用于 <b>剪切粘贴</b> 的系统功能。当系统存在剪贴板时，Emacs 的删除和粘贴命令会直接调用该功能。
</p>

<p>
当你通过 <code>C-w</code> (<code>king-region</code>) 这类命令删除文本，或通过 <code>M-w</code> (<code>kill-ring-save</code>) 这类命令将文本复制至删除环时， <b>该文本也会同时存入系统剪贴板</b> 。
</p>

<p>
Emacs 的删除命令向剪贴板写入文本时，剪贴板中原有的内容默认会被覆盖。你可手动配置 Emacs，将剪贴板原有内容保存至删除环，避免旧数据丢失：若将变量 <code>save-interprogram-paste-before-kill</code> 设为数字值，当剪贴板原有内容的字符数小于该数字时，会自动将其复制到删除环；若将该变量设为非 nil 的其他值，则无论内容大小，都会始终将剪贴板原有内容复制到删除环 —— 但此设置可能因剪贴板内容过大，导致 Emacs 内存占用过高。
</p>

<p>
<code>C-y</code> (<code>yank</code>) 这类粘贴命令同样会调用剪贴板。若 <b>剪贴板的归属权属于其他应用程序</b> （即你在其他应用中执行剪切 / 复制操作的时间，晚于在 Emacs 中执行最后一次删除命令的时间），Emacs 会优先从 <b>系统剪贴板</b> 粘贴内容，而非从自身的 kill rang删除环中读取。
</p>

<p>
默认情况下，使用 <code>M-y</code> (<code>yank-pop</code>) 遍历 Emacs 删除环的操作， <b>不会修改系统剪贴板的内容</b> ；若将变量 <code>yank-pop-change-selection</code> 设为t，则执行 <code>M-y</code> 时，会将当前遍历到的粘贴内容同步保存至系统剪贴板。
</p>

<p>
若要禁止 Emacs 的  <code>kill 删除</code> 、粘贴命令访问系统剪贴板，将变量 <code>select-enable-clipboard</code> 设为 <code>nil</code> 即可。
</p>

<p>
程序可向剪贴板存入纯文本以外的内容，例如网页浏览器中对图片执行「复制图片」操作后，图片数据会被存入剪贴板。在支持该功能的平台上，你可通过 Emacs 的 <code>yank-media</code> 命令粘贴这类对象 —— <b>仅在支持该特性的编辑模式下可用</b> （详见《Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Yanking-Media.html#Yanking-Media">粘贴媒体内容</a>」章节）。
</p>

<p>
许多 X 窗口桌面环境支持 <b>clipboard manager剪贴板管理器功能</b> ：若 Emacs 是当前剪贴板数据的归属程序，且系统中正在运行剪贴板管理器，那么退出 Emacs 时，Emacs 会将剪贴板数据传输至剪贴板管理器，避免数据丢失。部分场景下，该传输过程可能导致 Emacs 退出卡顿；若要禁止此行为，将变量 <code>x-select-enable-clipboard-manager</code> 设为 <code>nil</code> 即可。
</p>

<p>
由于包含 <b>空字节（NUL）</b> 的字符串在通过剪贴板传输时，通常会被截断，因此 Emacs 会在将这类字符串传输至系统剪贴板前，自动将空字节替换为转义字符“\0”。
</p>

<p>
在Emacs 24 版本之前，其删除和粘贴命令默认调用的是主选择区（详见「<a href="#Primary-Selection">与其他窗口应用的剪切粘贴</a>」小节），而非系统剪贴板。若你希望恢复旧版行为，需同时完成以下配置：将 <code>select-enable-clipboard</code> 设为 <code>nil</code> 、 <code>select-enable-primary</code> 设为 <code>t</code> 、 <code>mouse-drag-copy-region</code> 设为 <code>t</code> 。配置后，你可通过以下命令显式操作系统剪贴板：
</p>
<ul class="org-ul">
<li><code>clipboard-kill-region</code> ：删除指定区域文本，并将其保存至剪贴板；</li>
<li><code>clipboard-kill-ring-save</code> ：将指定区域文本复制至 Emacs 删除环，同时保存至剪贴板；</li>
<li><code>clipboard-yank</code> ：在光标位置粘贴系统剪贴板中的内容。</li>
</ul>
</div>
</div>
<div id="outline-container-Primary-Selection" class="outline-4">
<h4 id="Primary-Selection"><span class="section-number-4">14.3.2.</span> 与其他窗口应用程序的复制 - 粘贴</h4>
<div class="outline-text-4" id="text-Primary-Selection">
<p>
在 X 窗口系统、PGTK 图形工具包及 Haiku 系统中，存在 <b>primary selection主选择区</b> 功能，其中会保存 X 应用中最后一次选中的文本（通常通过鼠标拖动选中）。通常情况下，在其他 X 应用中单击 <code>mouse-2</code> 鼠标中键，即可将该文本插入对应位置。主选择区与剪贴板相互独立，其内容的留存性更低 —— 每次用鼠标选中新文本时，主选择区的内容就会被覆盖，而剪贴板的内容仅会被显式的剪切或复制命令覆盖。
</p>

<p>
在 X 窗口系统中，只要 Emacs 的 <b>区域处于激活</b> 状态（参见《<a href="#Mark">标记与区域</a>》），区域内的文本就会自动保存到主选择区。无论该区域是通过鼠标拖动、点击创建（参见《<a href="#Mouse-Commands">编辑相关的鼠标命令</a>》），还是通过键盘命令创建（例如按下 <code>C-SPC</code> 设置标记后移动光标），此规则均适用。
</p>

<p>
若将变量 <code>select-active-regions</code> 设为 <code>only</code> ，Emacs 仅会将 <b>临时激活的区域</b> （即通过鼠标或移位选择创建的区域，参见《<a href="#Shift-Selection">移位选择</a>》）保存至主选择区；若将该变量设为 <code>nil</code> ，Emacs 则完全不会将激活区域的内容保存到主选择区。
</p>

<p>
要将主选择区的内容插入 Emacs 缓冲区，在目标位置单击 <code>mouse-2</code> (<code>mouse-yank-primary</code>) 即可（参见《<a href="#Mouse-Commands">编辑相关的鼠标命令</a>》）。若已启用 <code>select-enable-primary</code> 变量（参见《<a href="#Clipboard">使用剪贴板</a>》），也可使用 Emacs 常规的粘贴命令 <code>C-y</code> 来插入该文本。
</p>

<p>
默认情况下，即便在其他程序中选中了文本，Emacs 的区域仍会保持激活状态，这与 X 窗口系统的常规行为不符。若希望当其他程序向主选择区存入数据后，Emacs 自动取消区域激活，启用全局次要模式 <code>lost-selection-mode</code> 即可。
</p>

<p>
MS-Windows微软视窗系统本身不提供主选择区功能，但 Emacs 会通过内部 <b>存储选中的文本</b> ，在单个 Emacs 会话中模拟该功能。因此，所有与主选择区相关的功能和命令，在视窗系统中对 <b>同一 Emacs 会话内</b> 的剪切粘贴操作均有效，与在 X 窗口系统中的表现一致；但跨 Emacs 会话，或与其他应用程序之间的剪切粘贴，该模拟功能则无法生效。
</p>
</div>
</div>
<div id="outline-container-Secondary-Selection" class="outline-4">
<h4 id="Secondary-Selection"><span class="section-number-4">14.3.3.</span> 次要选择（Secondary Selection）</h4>
<div class="outline-text-4" id="text-Secondary-Selection">
<p>
除主选择区外，X 窗口系统还提供了另一项功能相似的机制，即 <code>secondary selection次选择区</code> 。如今鲜有 X 应用程序会用到次选择区，但你可以通过以下 Emacs 命令对其进行操作：
</p>

<dl class="org-dl">
<dt><code>M-Drag-mouse-1</code> 拖动鼠标左键</dt><dd><p>
设置次选择区，选区的一端为按下鼠标键的位置，另一端为松开鼠标键的位置（对应命令 <code>mouse-set-secondary</code> ）。拖动过程中，选中的文本会以次选择区面版的样式高亮显示。若将鼠标拖至窗口顶部或底部外侧，窗口会自动滚动，该行为与 <code>mouse-set-region</code> 命令一致（参见《<a href="#Mouse-Commands">编辑相关的鼠标命令</a>》）。
</p>

<p>
该命令不会修改Emacs 的 kill ring删除环。
</p></dd>
<dt><code>M-mouse-1</code> 单击鼠标左键</dt><dd>设置次选择区的一个端点 (<code>mouse-start-secondary</code>) ；可配合 <code>M-mouse-2</code> 单击鼠标右键设定另一个端点，完成选区的创建。执行该命令新建次选择区时，会取消当前已存在的任意次选择区。</dd>

<dt><code>M-mouse-3</code> 单击鼠标右键</dt><dd>设置次选择区 (<code>mouse-secondary-save-then-kill</code>) ，选区的一端为单击该按键的位置，另一端为之前通过 <code>M-mouse-1</code> 单击鼠标左键指定的位置。该操作会同时将选中的文本存入 Emacs 的删除环。若在同一位置再次执行 <code>M-mouse-3</code> 单击鼠标右键，则会删除刚通过次选择区选中的文本。</dd>
<dt><code>M-mouse-2</code> 单击鼠标中键</dt><dd>将次选择区的内容插入到单击位置，且光标会定位在粘贴文本的末尾 (<code>mouse-yank-secondary</code>) 。</dd>
</dl>

<p>
对 <code>M-mouse-1</code> 单击鼠标左键执行双击或三击操作时，会按单词、按行进行选区匹配，行为与普通的鼠标左键双击 / 三击基本一致。
</p>

<p>
若变量 <code>mouse-yank-at-point</code> 设为非 nil 值，则 <code>M-mouse-2</code> 单击鼠标中键会在当前光标位置粘贴内容，此时鼠标单击的具体位置、甚至单击的是框架中的哪个窗口，均不影响粘贴结果（参见《<a href="#Mouse-Commands">编辑相关的鼠标命令</a>》）。该用户选项同样会作用于交互式搜索：若其值为非 nil，在框架内任意位置通过鼠标执行的粘贴操作，都会将对应文本添加至搜索字符串中。
</p>
</div>
</div>
</div>
<div id="outline-container-Accumulating-Text" class="outline-3">
<h3 id="Accumulating-Text"><span class="section-number-3">14.4.</span> 文本累积（Accumulating Text）</h3>
<div class="outline-text-3" id="text-Accumulating-Text">
<p>
通常我们通过 <code>killing删除 + yanking粘贴</code> 的方式复制或移动文本，但如需将某段文本复制到多个位置，或把多处分散的文本复制到同一位置，还有其他更便捷的方法。本节将介绍把分散的文本片段累积到缓冲区或文件中的相关命令。
</p>

<dl class="org-dl">
<dt><code>M-x append-to-buffer</code></dt><dd>将选中的区域文本追加至指定缓冲区的内容中。</dd>
<dt><code>M-x prepend-to-buffer</code></dt><dd>将选中的区域文本前置插入至指定缓冲区的内容中。</dd>
<dt><code>M-x copy-to-buffer</code></dt><dd>将选中的区域文本复制到指定缓冲区，清空该缓冲区原有的所有内容。</dd>
<dt><code>M-x insert-buffer</code></dt><dd>将指定缓冲区的全部内容，插入到当前缓冲区的光标位置。</dd>
<dt><code>M-x append-to-file</code></dt><dd>将选中的区域文本追加至指定文件的末尾。</dd>
</dl>

<p>
若要将文本累积到缓冲区中，可使用 <code>M-x append-to-buffer</code> 。执行该命令时，会先提示你输入缓冲区名称，随后将选中区域的文本副本插入至该指定缓冲区；若指定的缓冲区不存在，该命令会自动创建。文本的插入位置为 <b>目标缓冲区的当前光标处</b> ：若该缓冲区此前被用于编辑，复制的文本会从光标当前位置开始，插入到缓冲区原有文本的中间位置。
</p>

<p>
执行后，目标缓冲区的光标会停留在复制文本的末尾，因此连续执行 <code>M-x append-to-buffer</code> 时，文本会按照 <b>复制的先后顺序</b> 累积到指定缓冲区中。严格来说，该命令并非始终将文本追加到缓冲区原有内容的末尾 —— 仅当目标缓冲区的光标处于末尾位置时，才会实现「追加」效果。但如果仅使用该命令修改某一缓冲区，光标会始终保持在缓冲区末尾，也就始终实现追加。
</p>

<p>
<code>M-x prepend-to-buffer</code> 的功能与 <code>M-x append-to-buffer</code> 基本一致，唯一区别是：执行后目标缓冲区的光标会停留在复制文本的前方，因此连续执行该命令时，文本会按与复制顺序相反的方式添加。 <code>M-x copy-to-buffer</code> 与之类似，但会先 <b>清空目标缓冲区的所有原有内容</b> ，最终该缓冲区中仅保留本次新复制的文本。
</p>

<p>
使用 <code>C-x x i</code> (<code>insert-buffer</code>) 命令，可从其他缓冲区中调取累积的文本。执行该命令时会提示输入缓冲区名称，随后将该缓冲区的全部文本副本插入到 <b>当前缓冲区的光标位置</b> ，且光标会停留在插入文本的开头；同时会将插入文本的末尾位置添加到 <b>mark ring标记环</b> 中，且不会激活标记。关于缓冲区的基础信息，可参见《<a href="#Buffers">使用多个缓冲区</a>》章节。
</p>

<p>
除了将文本累积到缓冲区，也可使用 <code>M-x append-to-file</code> 直接将文本追加到文件中。执行该命令时会提示输入文件名，随后将选中区域的文本添加到指定文件的末尾，且修改会 <b>立即同步到磁盘上的文件</b> 。
</p>

<p>
注意： <code>append-to-file</code> 该命令仅适用于 <b>未在 Emacs 中打开</b> 的文件。若对 Emacs 中正在编辑的文件执行此命令，会在 Emacs 后台修改文件内容，可能导致部分编辑操作的内容丢失。
</p>

<p>
另一种文本移动的方法是将文本存储到寄存器中，相关操作可参见《<a href="#Registers">寄存器</a>》章节。
</p>
</div>
</div>
<div id="outline-container-Rectangles" class="outline-3">
<h3 id="Rectangles"><span class="section-number-3">14.5.</span> 矩形操作（Rectangles）</h3>
<div class="outline-text-3" id="text-Rectangles">
<p>
<code>Rectangle</code> 矩形操作命令作用于文本的 <b>矩形区域</b> ：即某几行范围内、指定两列之间的所有字符。Emacs 提供了多种矩形操作命令，可实现矩形区域的删除、粘贴、清空、填充空白或指定文本，或直接删除矩形区域等功能。矩形命令适用于多列格式的文本编辑，也可将普通文本转换为多列格式，或反向转换。
</p>

<p>
要为命令指定操作的矩形区域，需在矩形的 <b>一个对角</b> 设置标记，将光标置于 <b>对角的另一端</b> ，这样定义的矩形区域被称为 <b>region-rectangle区域矩形</b> 。若光标与标记处于同一列，该区域矩形为空；若处于同一行，该区域矩形的高度为一行。
</p>

<p>
区域矩形的控制方式与普通区域基本一致，但需注意：同一组光标与标记的位置组合，会根据调用命令的不同，被解析为 <b>普通区域</b> 或 <b>矩形区域</b> 。
</p>

<p>
也可通过鼠标标记矩形区域： <code>C-M-mouse-1</code> 按住并拖动鼠标左键，从矩形的一个对角拖至另一个对角即可。
</p>

<p>
<b>矩形操作核心快捷键</b>
</p>

<dl class="org-dl">
<dt><code>C-x r k</code></dt><dd>删除区域矩形内的文本，并将其内容保存为 <b>the last killed rectangle最近一次删除的矩形</b> (<code>kill-rectangle</code>) 。</dd>
<dt><code>C-x r M-w</code></dt><dd>将区域矩形内的文本保存为最近一次删除的矩形，不删除原文本 (<code>copy-rectangle-as-kill</code>) 。</dd>
<dt><code>C-x r d</code></dt><dd>直接删除区域矩形内的文本 (<code>delete-rectangle</code>) 。</dd>
<dt><code>C-x r y</code></dt><dd>粘贴最近一次删除的矩形，其左上角对齐当前光标位置 (<code>yank-rectangle</code>) 。</dd>
<dt><code>C-x r o</code></dt><dd>插入空格填充到当前区域矩形，将原矩形内的内容向右推移 (<code>open-rectangle</code>) 。</dd>
<dt><code>C-x r N</code></dt><dd>在区域矩形的左侧边缘插入行号，将原矩形内的内容向右推移 (<code>rectangle-number-lines</code>) 。</dd>
<dt><code>C-x r c</code></dt><dd>将区域矩形内的所有内容替换为空格，实现清空效果 (<code>clear-rectangle</code>) 。</dd>
<dt><code>M-x delete-whitespace-rectangle</code></dt><dd>删除指定矩形区域内每行的空白字符，从矩形左边缘对应的列开始执行。</dd>
<dt><code>C-x r t 字符串 RET</code></dt><dd>将矩形区域内的每行内容替换为指定字符串 (<code>string-rectangle</code>) 。</dd>
<dt><code>M-x string-insert-rectangle RET 字符串 RET</code></dt><dd>在矩形区域的每行插入指定字符串。</dd>
<dt><code>C-x SPC</code></dt><dd>切换矩形标记模式 (<code>rectangle-mark-mode</code>) 。该模式激活时，区域矩形会高亮显示，可调整其大小，且标准的删除、粘贴命令会直接作用于该矩形区域。</dd>
</dl>

<p>
<b>矩形操作的分类与核心逻辑</b>
</p>

<p>
矩形操作主要分为两类： <b>erase擦除 / insert插入矩形的命令</b> ，以及 <b>make blank rectangles创建空白矩形的命令</b> 。
</p>

<p>
一、擦除矩形区域的两种方式
</p>
<ul class="org-ul">
<li><code>C-x r d</code> (<code>delete-rectangle</code>) ：直接删除矩形内的文本，不保存；</li>
<li><code>C-x r k</code> (<code>kill-rectangle</code>) ：删除文本并将其保存为 <code>last killed rectanle最近一次删除的矩形</code> 。</li>
</ul>

<p>
两种方式的擦除效果一致：均会删除矩形内每行的指定文本，若该行擦除位置后还有其他文本，后续文本会向左移动填补空白。
</p>

<p>
注意：删除矩形并非普通意义上的「删除」—— 矩形内容不会存入 <b>删除环</b> ，而是保存在一个专门的区域，且该区域仅记录 <b>最近一次删除的矩形</b> 。这是因为矩形粘贴与普通线性文本的粘贴逻辑差异极大，需使用专用的粘贴命令，且矩形操作不支持 <b>粘贴循环</b> 功能。
</p>

<p>
<code>C-x r M-w</code> (<code>copy-rectangle-as-kill</code>) 是矩形操作的「复制」命令，等同于普通文本的 <code>M-w</code> ：仅将矩形内容记录为最近一次删除的矩形，不会从缓冲区中删除原文本。
</p>

<p>
二、矩形粘贴
</p>

<p>
执行 <code>C-x r y</code> (<code>yank-rectangle</code>) 可粘贴最近一次删除的矩形：矩形的第一行插入在光标位置，第二行插入在光标正下方同一列的位置，后续行依次向下排列，受影响的行数由保存的矩形高度决定。
</p>

<p>
示例：将两个单列列表合并为双列列表，可将其中一个单列列表作为矩形删除，再将其粘贴至另一个列表的右侧。
</p>

<p>
此外，还可通过 <code>C-x r r r</code> 寄存器和 <code>C-x r i r</code> 寄存器，将矩形内容存入寄存器或从寄存器中调取，详见《<a href="#Rectangle-Registers">将矩形保存至寄存器</a>》章节。
</p>

<p>
三、创建空白矩形
</p>

<p>
有两个命令可创建空白矩形：
</p>
<ul class="org-ul">
<li><code>C-x r c</code> (<code>clear-rectangle</code>) ：将现有区域矩形内的文本替换为空格，保留矩形区域的占位；</li>
<li><code>C-x r o</code> (<code>open-rectangle</code>) ：直接插入一个空白的矩形区域，原区域内容向右推移。</li>
</ul>

<p>
四、其他常用矩形命令
</p>

<ul class="org-ul">
<li><code>delete-whitespace-rectangle</code> ：删除矩形区域内每行的水平空白字符，以矩形 <b>左边缘的列</b> 为起始位置，矩形的右边缘对该命令无影响；</li>
<li><code>C-x r N</code> (<code>rectangle-number-lines</code>) ：在区域矩形的左侧边缘插入行号，默认从数字 1 开始（对应矩形的第一行）。若添加前缀参数，命令会提示输入起始行号，以及行号的格式化字符串（详见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Formatting-Strings.html#Formatting-Strings">格式化字符串</a>》章节）；</li>
<li><code>C-x r t</code> (<code>string-rectangle</code>) ：将矩形区域内的每行内容替换为指定字符串，字符串的宽度无需与矩形宽度一致：若字符串更短，矩形右侧的文本会向左移动；若字符串更长，矩形右侧的文本会向右移动；</li>
<li><code>string-insert-rectangle</code> ：与 <code>string-rectangle</code> 类似，但不会替换原内容，仅在矩形区域的每行插入指定字符串，原文本向右推移。</li>
</ul>

<p>
<b>矩形标记模式（Rectangle Mark Mode）</b>
</p>

<p>
<code>C-x SPC</code> (<code>rectangle-mark-mode</code>) 用于切换区域的高亮类型（必要时会先激活普通区域）：模式启用时，高亮显示 <b>区域矩形</b> ，调整区域大小的命令（如 <code>C-f</code> 、 <code>C-n</code> 等）会 <b>按矩形方式</b> 调整，且删除、粘贴命令会直接作用于该矩形区域（详见《<a href="#Killing">删除与移动文本</a>》章节）。该模式仅在 <b>区域处于激活状态</b> 时有效。
</p>

<p>
区域矩形仅在 <b>标记激活</b> 时生效。尤其当 <b>临时标记模式</b> 关闭时（详见《<a href="#Disabled-Transient-Mark">关闭临时标记模式</a>》），除了按下 <code>C-x SPC</code> ，还需手动激活标记。
</p>

<p>
与普通区域不同，区域矩形的对角可延伸至 <b>缓冲区末尾之外</b> ，也可定位在光标通常无法进入的空白区域内（例如 <code>TAB</code> 制表符的中间位置）。
</p>

<p>
当区域处于激活状态且开启矩形标记模式时，执行 <code>C-x C-x</code> 会调用 <code>rectangle-exchange-point-and-mark</code> 命令，该命令会在区域矩形的 <b>四个对角之间循环切换</b> 光标与标记的位置。若要在对标记文本执行操作前调整区域矩形的尺寸，该命令会非常实用。
</p>
</div>
</div>
<div id="outline-container-CUA-Bindings" class="outline-3">
<h3 id="CUA-Bindings"><span class="section-number-3">14.6.</span> CUA 键绑定（CUA Bindings）</h3>
<div class="outline-text-3" id="text-CUA-Bindings">
<p>
执行命令 <code>M-x cua-mode</code> 可配置一套与 <b>通用用户访问（CUA）</b> 系统兼容的键位绑定，该系统被广泛应用于其他各类应用程序中。
</p>

<p>
启用 CUA 模式后，按键 <code>C-x</code> 、 <code>C-c</code> 、 <code>C-v</code> 和 <code>C-z</code> 将分别执行剪切（kill删除）、复制、粘贴(yank)和撤销命令。 <b>仅当区域处于激活状态时</b> ， <code>C-x</code> 和 <code>C-c</code> 才会执行剪切、复制操作；若区域未激活，这两个按键仍会作为 <b>prefix keys前缀键</b> 生效，因此 <code>C-x C-c</code> 这类标准 Emacs 命令依然可以正常使用。需注意，这意味着变量 <code>mark-even-if-inactive</code> 对 <code>C-x</code> 和 <code>C-c</code> 不产生任何作用（参见《<a href="#Using-Region">对区域执行操作</a>》章节）。
</p>

<p>
若标记处于激活状态，想要输入 <code>C-x C-f</code> 这类 Emacs 标准命令，可采用以下两种方法：一是按住 <code>Shift</code> 键同时按下前缀键，例如 <code>S-C-x C-f</code> ；二是快速连续按下两次前缀键，例如 <code>C-x C-x C-f</code> 。
</p>

<p>
若希望保留下文所述 CUA 模式的其他功能，仅禁用其对 Emacs 标准键位绑定的覆盖，可将变量 <code>cua-enable-cua-keys</code> 设为 <code>nil</code> 。
</p>

<p>
CUA 模式默认会激活 <b>删除选区模式</b> （参见《<a href="#Mouse-Commands">编辑相关的鼠标命令</a>》章节），此时输入的文本会替换激活的区域。若想使用 CUA 模式但关闭该行为，将变量 <code>cua-delete-selection</code> 设为 <code>nil</code> 即可。
</p>

<p>
CUA 模式对矩形操作提供了增强支持，包括 <b>矩形区域高亮显示</b> 功能：按下 <code>C-RET</code> 即可开始标记矩形，通过移动命令扩展矩形范围，再使用 <code>C-x</code> 或 <code>C-c</code> 对其执行剪切或复制操作。按下 <code>RET</code> 可将光标移动至矩形的下一个（顺时针方向）角点，方便向任意方向扩展矩形。在该模式下，输入的普通文本会插入到矩形每一行的左侧或右侧（与光标所处的一侧保持一致）。
</p>

<p>
即便不激活 CUA 模式，也可通过调用 <code>cua-rectangle-mark-mode</code> 命令，使用这套矩形操作增强功能。此外还有标准的 <code>rectangle-mark-mode</code> 命令可供使用，详见《<a href="#Rectangles">矩形操作</a>》章节。
</p>

<p>
在 CUA 模式下，可为剪切、复制、粘贴命令添加 <b>单个数字的前缀参数</b> ，轻松将文本和矩形存入或调取自寄存器。例如， <code>C-1 C-c</code> 会将区域内容复制到寄存器 <code>1</code> 中， <code>C-2 C-v</code> 会粘贴寄存器 <code>2</code> 中的内容。
</p>

<p>
CUA 模式还提供 <b>全局标记</b> 功能，便于在不同缓冲区之间移动和复制文本：按下 <code>C-S-SPC</code> 可切换全局标记的开启与关闭状态。当全局标记开启时，所有被剪切或复制的文本会自动插入到全局标记位置，输入的文本也会插入至全局标记处，而非当前光标位置。
</p>

<p>
示例：若要将多个缓冲区中的单词复制到某一缓冲区的单词列表中，可先在目标缓冲区中设置全局标记，然后导航至每个需要添加的单词处，标记该单词（例如使用 <code>S-M-f</code> ），通过 <code>C-c</code> 或 <code>M-w</code> 将其复制到列表中，最后按下 <code>RET</code> 在目标列表的该单词后插入换行符即可。
</p>
</div>
</div>
</section>
<section id="outline-container-Registers" class="outline-2">
<h2 id="Registers"><span class="section-number-2">15.</span> 寄存器（Registers）</h2>
<div class="outline-text-2" id="text-Registers">
<p>
Emacs <code>registers寄存器</code> 是可用于保存文本、矩形、位置及其他内容的独立存储区域，方便后续调用。文本或矩形一旦存入寄存器，可单次或多次复制到缓冲区中；位置一旦存入寄存器，也可单次或多次跳转到该位置。
</p>

<p>
每个寄存器均有一个 <b>a single character单字符名称</b> ，下文统一用 <code>r</code> 表示；该字符可以是字母（如“a”）或数字（如“1”）， <b>大小写敏感</b> ，因此寄存器“a”与寄存器“A”并非同一个。也可使用非字母数字字符命名寄存器，例如通过 <code>C-q C-d</code> 的方式将 “C-d” 设为寄存器名。
</p>

<p>
一个寄存器可存储的内容类型包括：位置、文本片段、矩形、数字、窗口或框架配置、缓冲区名或文件名，但 <b>同一时间仅能存储一种内容</b> 。存入寄存器的内容会一直保留，直至向该寄存器存入其他内容。若要查看寄存器 <code>r</code> 中存储的内容，可使用 <code>M-x view-register</code> 命令：
</p>

<dl class="org-dl">
<dt><code>M-x view-register RET r</code></dt><dd>显示寄存器 <code>r</code> 中存储内容的描述信息。</dd>
</dl>

<p>
所有需要指定寄存器的命令，默认情况下会经过短暂延迟后，弹出一个 <code>preview window预览窗口</code> ，列出当前已存在的寄存器（若有）及其对应值。寄存器的提示相关行为（包括预览功能）可通过自定义变量 <code>register-use-preview</code> 实现，该变量可设置为以下值：
</p>

<dl class="org-dl">
<dt><code>traditional</code></dt><dd>默认值，Emacs 表现与 29 版本之前的所有版本一致：经过指定延迟后显示已有寄存器的预览，直接输入寄存器名即可覆盖该寄存器的原有值。预览的延迟时长由可自定义变量 <code>register-preview-delay</code> 指定（单位为秒）；将该变量设为 <code>nil</code> 则禁用预览功能（但在 Emacs 提示输入寄存器时，仍可通过按下 <code>C-h</code> 或 <code>F1</code> 显式调出预览窗口）。</dd>

<dt><code>t</code></dt><dd><p>
启用更灵活的寄存器预览功能。Emacs 提示输入寄存器时会 <b>立即弹出预览窗口</b> （ <code>register-preview-delay</code> 不再生效），且预览窗口支持导航：可通过 <code>C-n</code> 、 <code>C-p</code> （或上下方向键）在预览窗口的寄存器间切换。在此模式下，若要覆盖已有寄存器的值，需通过导航选中该寄存器或直接输入其名称后，按下 <code>RET</code> 确认。
</p>

<p>
此外，预览窗口显示的寄存器会根据调出预览的命令进行过滤：例如 <code>insert-register</code> 命令调出的预览，仅显示可插入缓冲区的寄存器内容，隐藏存储窗口配置、位置及其他不可插入内容的寄存器。
</p></dd>

<dt><code>insist</code></dt><dd>行为与 <code>t</code> 一致，额外支持直接 <b>再次按下寄存器名对应的按键</b> 退出迷你缓冲区，无需按 <code>RET</code> 确认。</dd>

<dt><code>nil</code></dt><dd>行为接近 <code>traditional</code> ，但预览窗口会 <b>无延迟弹出</b> ，且寄存器列表会根据命令进行过滤。</dd>

<dt><code>never</code></dt><dd>行为与 <code>nil</code> 一致，且 <b>直接禁用预览功能</b> 。</dd>
</dl>

<p>
<code>Bookmarks书签</code> 用于记录文件及其对应的位置，方便再次打开该文件时快速跳转到对应位置。书签的设计思路与寄存器相似，因此也在本章介绍。
</p>

<ul class="org-ul">
<li><a href="#Position-Registers">在寄存器中保存位置</a></li>
<li><a href="#Text-Registers">在寄存器中保存文本</a></li>
<li><a href="#Rectangle-Registers">在寄存器中保存矩形</a></li>
<li><a href="#Configuration-Registers">在寄存器中保存窗口与框架配置</a></li>
<li><a href="#Number-Registers">在寄存器中存储数字</a></li>
<li><a href="#File-and-Buffer-Registers">在寄存器中存储文件与缓冲区名称</a></li>
<li><a href="#Keyboard-Macro-Registers">键盘宏寄存器（Keyboard Macro Registers）</a></li>
<li><a href="#Bookmarks">书签（Bookmarks）</a></li>
</ul>
</div>
<div id="outline-container-Position-Registers" class="outline-3">
<h3 id="Position-Registers"><span class="section-number-3">15.1.</span> 在寄存器中保存位置</h3>
<div class="outline-text-3" id="text-Position-Registers">
<dl class="org-dl">
<dt><code>C-x r SPC r</code></dt><dd>将光标位置与当前缓冲区记录至寄存器 <code>r</code> 中 (<code>point-to-register</code>) 。</dd>
<dt><code>C-x r j r</code></dt><dd>跳转到寄存器 <code>r</code> 中保存的缓冲区及对应光标位置 (<code>jump-to-register</code>) 。</dd>
</dl>

<p>
按下 <code>C-x r SPC</code> (<code>point-to-register</code>) ，随后输入字符 <code>r</code> ，即可将当前的 <b>光标位置</b> 和 <b>所属缓冲区</b> 一同保存至寄存器 <code>r</code> 。该寄存器会一直保留此信息，直至向其中存入其他内容。
</p>

<p>
执行 <code>C-x r j r</code> 命令，会切换至寄存器 <code>r</code> 中记录的缓冲区，设置标记点，并将光标移动到该寄存器保存的位置（若光标已处于记录的位置，或连续调用该命令时，不会重复设置标记点）。寄存器内的内容不会因该操作发生改变，因此你可以无限次跳转到这个保存的位置。
</p>

<p>
若使用 <code>C-x r j</code> 跳转到已保存的位置，但该位置所属的缓冲区已被关闭，Emacs 会尝试通过重新打开原文件来重建该缓冲区。当然，此功能仅对原本关联了文件的缓冲区生效。
</p>
</div>
</div>
<div id="outline-container-Text-Registers" class="outline-3">
<h3 id="Text-Registers"><span class="section-number-3">15.2.</span> 在寄存器中保存文本</h3>
<div class="outline-text-3" id="text-Text-Registers">
<p>
若你需要多次插入同一段文本的副本，从删除环中粘贴会十分不便 —— 因为后续每一次的删除操作，都会让该文本条目在删除环中不断后移。此时可将文本存入寄存器，后续再从寄存器中调取使用，这是更优的替代方案。
</p>

<dl class="org-dl">
<dt><code>C-x r s r</code></dt><dd>将选中的区域文本复制到寄存器 <code>r</code> 中 (<code>copy-to-register</code>) 。</dd>
<dt><code>C-x r i r</code></dt><dd>从寄存器 <code>r</code> 中插入文本至缓冲区 (<code>insert-register</code>) 。</dd>
<dt><code>M-x append-to-register RET r</code></dt><dd><p>
将选中的区域文本追加到寄存器 <code>r</code> 中已存储的文本末尾。
</p>

<p>
当寄存器 <code>r</code> 中存储的是文本时，你可使用 <code>C-x r +</code> (<code>increment-register</code>) 向该寄存器追加内容。请注意，若寄存器 <code>r</code> 中存储的是数字， <code>C-x r +</code> 命令的执行行为会有所不同，详见《<a href="#Number-Registers">在寄存器中存储数字</a>》章节。
</p></dd>

<dt><code>M-x prepend-to-register RET r</code></dt><dd>将选中的区域文本添加到寄存器 <code>r</code> 中已存储的文本开头。</dd>
</dl>

<p>
执行 <code>C-x r s r</code> 会将区域内的文本副本存入名为 <code>r</code> 的寄存器。若标记处于未激活状态，Emacs 会先将标记重新激活在其上次被设置的位置，该命令执行完毕后标记会被取消激活，相关说明详见《<a href="#Mark">标记与区域</a>》章节。带前缀参数执行该命令（ <code>C-u C-x r s r</code> ）时，会将文本复制到寄存器 <code>r</code> 的同时，从缓冲区中删除该区域的文本；你可将此操作理解为将区域文本移动到寄存器中。
</p>

<p>
执行 <code>M-x append-to-register RET r</code> ，会将区域文本的副本追加至名为 <code>r</code> 的寄存器中已存储的文本末尾。若带前缀参数执行该命令，文本追加完成后，缓冲区中的对应区域会被删除。 <code>prepend-to-register</code> 命令的功能与之类似，区别仅在于该命令会将区域文本添加到寄存器内文本的开头，而非末尾。
</p>

<p>
当你使用 <code>append-to-register</code> 和 <code>prepend-to-register</code> 命令收集文本时，可能需要用分隔符将各段收集的文本区分开。这种情况下，你可 <b>配置一个寄存器分隔符</b> <code>register-separator</code>  ，并将分隔符文本存入该寄存器。例如，若要在文本收集过程中使用两个换行符作为分隔符，可进行如下设置：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq</span> register-separator ?+)
(set-register register-separator <span style="color: #8b2252;">"\n\n"</span>)
</pre>
</div>

<p>
执行 <code>C-x r i r</code> 会将寄存器 <code>r</code> 中的文本插入到缓冲区中。默认情况下，光标会停留在插入文本的末尾，标记会被设置在插入文本的开头，且标记不会被激活。若带前缀参数执行该命令，光标会被置于插入文本的开头，标记则会设置在文本末尾。
</p>
</div>
</div>
<div id="outline-container-Rectangle-Registers" class="outline-3">
<h3 id="Rectangle-Registers"><span class="section-number-3">15.3.</span> 在寄存器中保存矩形</h3>
<div class="outline-text-3" id="text-Rectangle-Registers">
<p>
寄存器中可存储矩形区域，而非仅能存储线性文本。关于如何在缓冲区中指定矩形区域的基础说明，详见《<a href="#Rectangles">矩形操作</a>》章节。
</p>

<dl class="org-dl">
<dt><code>C-x r r r</code></dt><dd>将区域矩形复制至寄存器 <code>r</code> 中 (<code>copy-rectangle-to-register~</code>) 。带前缀参数执行时，会同时从缓冲区中删除该矩形区域。</dd>
<dt><code>C-x r i r</code></dt><dd>插入寄存器 <code>r</code> 中存储的矩形区域（若该寄存器内保存的是矩形） (<code>insert-register</code>) 。</dd>
</dl>

<p>
前文《<a href="#Text-Registers">将文本保存到寄存器</a>》中介绍的 <code>C-x r i r</code> (<code>insert-register</code>) 命令，若目标寄存器中存储的是矩形区域，该命令会插入此矩形，而非文本字符串。
</p>
</div>
</div>
<div id="outline-container-Configuration-Registers" class="outline-3">
<h3 id="Configuration-Registers"><span class="section-number-3">15.4.</span> 在寄存器中保存窗口与框架配置</h3>
<div class="outline-text-3" id="text-Configuration-Registers">
<p>
你可将选中框架的窗口配置保存至寄存器，甚至能将所有框架中所有窗口的配置一并保存，后续再恢复该配置。关于窗口配置的相关信息，详见《<a href="#Window-Convenience">窗口操作便捷功能</a>》章节。
</p>

<dl class="org-dl">
<dt><code>C-x r w r</code></dt><dd>将选中框架的窗口状态保存至寄存器 <code>r</code> (<code>window-configuration-to-register</code>) 。</dd>
<dt><code>C-x r f r</code></dt><dd>将所有框架的状态（包括其下所有窗口，亦称为 <b>框架集</b> ）保存至寄存器 <code>r</code> (<code>frameset-to-register</code>) 。</dd>
</dl>

<p>
可使用 <code>C-x r j r</code> 恢复窗口或框架配置，该命令与恢复光标位置的命令为同一个。恢复框架配置时，所有未包含在该配置中的现有框架会变为不可见状态；若你希望直接删除这些框架，可执行 <code>C-u C-x r j r</code> 。
</p>
</div>
</div>
<div id="outline-container-Number-Registers" class="outline-3">
<h3 id="Number-Registers"><span class="section-number-3">15.5.</span> 在寄存器中存储数字</h3>
<div class="outline-text-3" id="text-Number-Registers">
<p>
Emacs 提供了专门命令，可将数字存入寄存器、将寄存器中的数字以十进制形式插入缓冲区，还能对寄存器内的数字执行自增操作。这些命令在编写键盘宏时会十分实用（详见《<a href="#Keyboard-Macros">键盘宏</a>》章节）。
</p>

<dl class="org-dl">
<dt><code>C-u number C-x r n r</code></dt><dd>将指定数字存入寄存器 <code>r</code> (<code>number-to-register</code>) 。</dd>
<dt><code>C-u number C-x r + r</code></dt><dd>若寄存器 <code>r</code> 中存储的是数字，将该寄存器内的数字与指定数字相加（即完成自增指定数值的操作）。请注意，若寄存器 <code>r</code> 中存储的是文本， <code>C-x r +</code> (<code>increment-register</code>) 的执行行为会有所不同，详见《<a href="#Text-Registers">将文本保存到寄存器</a>》章节。</dd>
<dt><code>C-x r i r</code></dt><dd>将寄存器 <code>r</code> 中的数字插入至缓冲区中。</dd>
</dl>

<p>
<code>C-x r i</code> 是通用命令，既可插入寄存器中的数字，也可插入寄存器内存储的其他任意类型内容。执行 <code>C-x r +</code> 时若未指定数字参数，会将寄存器内的数值自增 1；执行 <code>C-x r n</code> 时若未指定数字参数，会将0存入目标寄存器。
</p>
</div>
</div>
<div id="outline-container-File-and-Buffer-Registers" class="outline-3">
<h3 id="File-and-Buffer-Registers"><span class="section-number-3">15.6.</span> 在寄存器中存储文件与缓冲区名称</h3>
<div class="outline-text-3" id="text-File-and-Buffer-Registers">
<p>
若你需要频繁打开某些文件，可将其文件名存入寄存器，后续访问会更为便捷。将文件名存入寄存器 <code>r</code> 的 Lisp 代码如下：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(set-register r '(file . name))
</pre>
</div>

<p>
例如，执行代码：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(set-register ?z '(file . <span style="color: #8b2252;">"/gd/gnu/emacs/19.0/src/ChangeLog"</span>))
</pre>
</div>

<p>
即可将示例中的文件名存入寄存器 "z"。
</p>

<p>
要打开寄存器 <code>r</code> 中存储的文件名对应的文件，键入 <code>C-x r j r</code> 即可（该命令与跳转到保存的光标位置、恢复框架配置的命令为同一个）。
</p>

<p>
同理，若你需要频繁切换至某些缓冲区，也可将其缓冲区名存入寄存器。例如，若你经常打开 <code>*Messages*</code> 缓冲区，可执行以下代码将该缓冲区名存入寄存器 <code>m</code> ：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(set-register ?m '(buffer . <span style="color: #8b2252;">"*Messages*"</span>))
</pre>
</div>

<p>
要切换至寄存器 <code>r</code> 中存储的缓冲区名对应的缓冲区，键入 <code>C-x r j r</code> 即可。
</p>
</div>
</div>
<div id="outline-container-Keyboard-Macro-Registers" class="outline-3">
<h3 id="Keyboard-Macro-Registers"><span class="section-number-3">15.7.</span> 键盘宏寄存器（Keyboard Macro Registers）</h3>
<div class="outline-text-3" id="text-Keyboard-Macro-Registers">
<p>
若你需要频繁执行某一键盘宏（详见《<a href="#Keyboard-Macros">键盘宏</a>》章节），将其存入寄存器或进行保存会更为便捷（详见《<a href="#Save-Keyboard-Macro">键盘宏的命名与保存</a>》章节）。按下 <code>C-x C-k x r</code> (<code>kmacro-to-register</code>) ，可将最近录制的键盘宏存入寄存器 <code>r</code> 中。
</p>

<p>
要执行寄存器 <code>r</code> 中存储的键盘宏，键入 <code>C-x r j r</code> 即可（该命令与跳转到保存的位置、恢复框架集的命令为同一个）。
</p>
</div>
</div>
<div id="outline-container-Bookmarks" class="outline-3">
<h3 id="Bookmarks"><span class="section-number-3">15.8.</span> 书签（Bookmarks）</h3>
<div class="outline-text-3" id="text-Bookmarks">
<p>
<code>Bookmarks</code> 书签的作用与寄存器有相似之处，均可记录供跳转的位置；但与寄存器不同的是，书签支持长命名，且会自动永久保存，跨 Emacs 会话生效。书签的典型用法，是记录你在不同文件中阅读到的位置。
</p>

<dl class="org-dl">
<dt><code>C-x r m RET</code></dt><dd>为当前打开的文件，在光标位置创建书签（使用文件名作为默认书签名称）。</dd>
<dt><code>C-x r m 书签名称 RET</code></dt><dd>在光标位置创建指定名称的书签 (<code>bookmark-set</code>) 。</dd>
<dt><code>C-x r M 书签名称 RET</code></dt><dd>功能与 <code>C-x r m</code> 一致，但不会覆盖已存在的同名书签。</dd>
<dt><code>C-x r b 书签名称 RET</code></dt><dd>跳转到指定名称的书签位置 (<code>bookmark-jump</code>) 。</dd>
<dt><code>C-x r l</code></dt><dd>列出所有已创建的书签 (<code>list-bookmarks</code>) 。</dd>
<dt><code>M-x bookmark-save</code></dt><dd>将当前所有书签的配置保存至默认书签文件。</dd>
</dl>

<p>
要记录当前打开文件中的光标位置，可执行 <code>C-x r m</code> 命令，该命令会以当前文件名作为默认书签名称创建书签。若为每个书签按其指向的文件命名，后续即可通过 <code>C-x r b</code> (<code>bookmark-jump</code>) 便捷地重新打开对应文件，同时直接跳转到书签记录的位置。
</p>

<p>
在图形化显示界面中，执行 <code>C-x r m</code> 创建书签时，除记录位置外，还会在书签对应行的左侧页边距（参见《<a href="#Fringes">窗口页边距</a>》章节）显示一个特殊图标，标识该位置存在书签。该功能可通过用户选项 <code>bookmark-fringe-mark</code> 控制：将其设为 <code>nil</code> 即可关闭页边距书签标识，默认值为 <code>bookmark-mark</code> （即用于标识书签的位图图标）。后续通过 <code>C-x r b</code> 跳转到该书签时，页边距的书签标识会重新显示。
</p>

<p>
<code>C-x r M</code> (<code>bookmark-set-no-overwrite</code>) 命令的功能与 <code>C-x r m</code> 基本一致，区别在于：若指定的书签名称已存在，该命令会抛出错误提示，而非直接覆盖原有书签。
</p>

<p>
键入 <code>C-x r l</code> (<code>list-bookmarks</code>) 可在独立缓冲区中列出所有书签；切换至该书签缓冲区后，你可对书签定义进行编辑，或为书签添加注释。在书签缓冲区中键入 <code>C-h m</code> ，可查看其专属编辑命令的更多说明。
</p>

<p>
当你关闭 Emacs 时，若书签配置有过修改，Emacs 会自动保存书签；你也可在任意时刻执行 <code>M-x bookmark-save</code> 命令手动保存。书签默认保存至文件 <code>~/.emacs.d/bookmarks</code> （为兼容旧版 Emacs，若存在文件 <code>~/.emacs.bmk</code> ，则会优先使用该文件）。书签相关命令会自动加载默认书签文件，正是通过这种 <b>自动保存与加载</b> 的机制，实现书签的跨 Emacs 会话永久保存。
</p>

<p>
若将变量 <code>bookmark-save-flag</code> 设为1，则每次执行书签创建命令后，Emacs 都会自动保存书签配置；即便 Emacs 意外崩溃，也不会丢失书签数据。该变量若设为数字值，代表每完成指定次数的书签修改后，自动执行一次保存操作；若将其设为 <code>nil</code> ，则 Emacs 仅会在你显式执行 <code>M-x bookmark-save</code> 时，才保存书签配置。
</p>

<p>
变量 <code>bookmark-default-file</code> 用于指定书签的默认保存文件。
</p>

<p>
若将变量 <code>bookmark-use-annotations</code> 设为 <code>t</code> ，创建书签时会弹出提示，让你为书签添加注释；当书签存在注释时，后续跳转到该书签位置，注释会自动在独立窗口中显示。
</p>

<p>
书签记录位置时，会同时保存位置周边的上下文内容，因此即便文件内容有轻微修改， <code>bookmark-jump</code> 仍能准确定位到书签位置。变量 <code>bookmark-search-size</code> 用于指定书签位置两侧需要记录的上下文字符数（注意：对于打开的加密文件，无论该变量如何设置，书签文件中都不会保存任何上下文内容）。
</p>

<p>
以下是书签的一些附加操作命令：
</p>

<dl class="org-dl">
<dt><code>M-x bookmark-load RET 文件名 RET</code></dt><dd>加载指定文件中的书签配置列表。除默认书签文件外，你可通过该命令与 <code>bookmark-write</code> 命令，管理其他书签配置文件。</dd>
<dt><code>M-x bookmark-write RET 文件名 RET</code></dt><dd>将当前所有书签配置保存至指定文件。</dd>
<dt><code>M-x bookmark-delete RET 书签名称 RET</code></dt><dd>删除指定名称的书签。</dd>
<dt><code>M-x bookmark-insert-location RET 书签名称 RET</code></dt><dd>在缓冲区中插入指定书签指向的文件名。</dd>
<dt><code>M-x bookmark-insert RET 书签名称 RET</code></dt><dd>在缓冲区中插入指定书签指向文件的全部内容。</dd>
</dl>
</div>
</div>
</section>
<section id="outline-container-Display" class="outline-2">
<h2 id="Display"><span class="section-number-2">16.</span> 显示控制</h2>
<div class="outline-text-2" id="text-Display">
<p>
由于大缓冲区的内容无法在窗口中完整显示，Emacs 只能展示其中一部分内容。本章将介绍用于指定文本显示区域、设置文本显示方式的相关命令与变量。
</p>

<ul class="org-ul">
<li><a href="#Scrolling">滚动操作</a></li>
<li><a href="#Recentering">居中显示（Recentering）</a></li>
<li><a href="#Auto-Scrolling">自动滚动</a></li>
<li><a href="#Horizontal-Scrolling">水平滚动</a></li>
<li><a href="#Narrowing">窄化显示（Narrowing）</a></li>
<li><a href="#View-Mode">查看模式（View Mode）</a></li>
<li><a href="#Follow-Mode">跟随模式（Follow Mode）</a></li>
<li><a href="#Faces">文本外观（Text Faces）</a></li>
<li><a href="#Colors">外观颜色设置</a></li>
<li><a href="#Standard-Faces">标准样式（Standard Faces）</a></li>
<li><a href="#Icons">图标（Icons）</a></li>
<li><a href="#Text-Scale">文本缩放（Text Scale）</a></li>
<li><a href="#Font-Lock">字体锁定模式（Font Lock mode）</a></li>
<li><a href="#Highlight-Interactively">交互式高亮（Interactive Highlighting）</a></li>
<li><a href="#Fringes">窗口边缘（Window Fringes）</a></li>
<li><a href="#Displaying-Boundaries">边界显示（Displaying Boundaries）</a></li>
<li><a href="#Useless-Whitespace">无用空白字符（Useless Whitespace）</a></li>
<li><a href="#Selective-Display">选择性显示（Selective Display）</a></li>
<li><a href="#Optional-Mode-Line">模式行可选功能</a></li>
<li><a href="#Text-Display">文本显示方式</a></li>
<li><a href="#Cursor-Display">光标显示（Displaying the Cursor）</a></li>
<li><a href="#Line-Truncation">行截断（Line Truncation）</a></li>
<li><a href="#Visual-Line-Mode">视觉行模式（Visual Line Mode）</a></li>
<li><a href="#Display-Custom">显示定制（Customization of Display）</a></li>
</ul>
</div>
<div id="outline-container-Scrolling" class="outline-3">
<h3 id="Scrolling"><span class="section-number-3">16.1.</span> 滚动操作</h3>
<div class="outline-text-3" id="text-Scrolling">
<p>
若窗口尺寸不足以显示缓冲区中的全部文本，只会展示其中一部分。 <code>Scrolling commands</code> 滚动命令可更改窗口中显示的缓冲区内容范围。
</p>

<p>
向前滚动 或 向上滚动 会推进窗口中显示的缓冲区内容；换言之，是让缓冲区文本相对窗口向上移动。向后滚动 或 向下滚动 会显示缓冲区中更靠前的内容，同时让文本相对窗口向下移动。
</p>

<p>
在 Emacs 中，“scrolling up向上滚动”或“scrolling down向下滚动” 指代 <b>文本在窗口中的移动方向</b> ，而非窗口相对文本的移动方向。该术语在 “向上滚动”“向下滚动” 的现代含义普及前便已被 Emacs 采用，因此会出现一个看似反常的结果：按 <code>PageDown</code> 键，在 Emacs 的定义中属于 <b>向上滚动</b> 。
</p>

<p>
窗口中显示的缓冲区内容始终包含 <b>光标位置</b> 。若将光标移至窗口可视区域的下方或上方，Emacs 会自动执行滚动，让光标回到可视区域内（参见「<a href="#Auto-Scrolling">自动滚动</a>」）。你也可以通过以下命令手动执行滚动：
</p>

<p>
<b>基础滚动命令</b>
</p>
<dl class="org-dl">
<dt><code>C-v</code> / <code>PageDown</code> / <code>next</code></dt><dd>向前滚动近一整屏 (<code>scroll-up-command</code>)</dd>
<dt><code>M-v</code> / <code>PageUp</code> / <code>prior</code></dt><dd>向后滚动 (<code>scroll-down-command</code>)</dd>
</dl>

<p>
<code>C-v</code> (<code>scroll-up-command</code>) 会向前滚动近整个窗口高度的内容，效果为将窗口底部的两行文本移至顶部，后续拼接此前未显示的内容。若光标原本在滚出窗口顶部的文本区域，滚动后光标会停在窗口新的首行。 <code>PageDown</code> （或 <code>next</code> ）键与 <code>C-v</code> 功能完全等效。
</p>

<p>
<code>M-v</code> (<code>scroll-down-command</code>) 的向后滚动逻辑与之类似， <code>PageUp</code> （或 <code>prior</code> ）键与 <code>M-v</code> 功能完全等效。
</p>

<p>
这些滚动命令执行后保留的 <b>重叠行数</b> 由变量 <code>next-screen-context-lines</code> 控制，其默认值为 <code>2</code> 。你可以为这些命令添加数字前缀参数 <code>n</code> ，实现滚动 <code>n</code> 行的效果；此时 Emacs 会尽量保持光标位置不变，让文本与光标同步上下移动。带负参数的 <code>C-v</code> 等效于 <code>M-v</code> ，反之亦然。
</p>

<p>
默认情况下，若窗口已到达缓冲区开头或末尾、无法继续滚动，这些命令会触发错误（通过蜂鸣或屏幕闪烁提示）。若将变量 <code>scroll-error-top-bottom</code> 设为 <code>t</code> ，命令会将光标移至当前可滚动的最远位置；若光标已处于该位置，才会触发错误。
</p>

<p>
<b>保持光标屏幕位置</b>
</p>

<p>
部分用户希望滚动命令能让光标停在 <b>屏幕固定位置</b> ，这样滚动回同一屏时，光标可便捷地回到原位置。可通过变量 <code>scroll-preserve-screen-position</code> 启用该功能：
</p>
<ul class="org-ul">
<li>若值为 <code>t</code> ：当滚动命令将光标移出窗口时，Emacs 会调整光标位置，让光标在屏幕上的位置保持不变（而非移至窗口首行 / 末行）；</li>
<li>若值为其他非nil值：即便滚动命令未将光标移出窗口，Emacs 也会按上述规则调整光标位置。</li>
</ul>

<p>
该变量对本节介绍的所有滚动命令、鼠标滚轮滚动均生效（参见「<a href="#Mouse-Commands">编辑用鼠标命令</a>」）；通常，所有带有非nil属性 <code>scroll-command</code> 的命令都会受其影响（参见《Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Property-Lists.html#Property-Lists">属性列表</a>」）。当 <code>isearch-allow-scroll</code> 为非nil时，该属性还会让 Emacs 在调用此类滚动命令时，不退出增量搜索模式（参见「<a href="#Not-Exiting-Isearch">不退出增量搜索</a>」）。
</p>

<p>
<b>优化高速滚动性能</b>
</p>

<p>
当长按 <code>C-v</code> 、 <code>M-v</code> 等键触发 <b>键盘自动重复</b> 时，Emacs 有时无法跟上快速的滚动请求，会出现显示不更新、长时间无法响应输入的情况。可将变量 <code>fast-but-imprecise-scrolling</code> 设为非nil值，缓解该卡顿问题：该设置会让滚动命令跳过对滚过区域未做字体高亮的文本的着色（参见「<a href="#Font-Lock">字体锁定模式</a>」），直接默认使用默认字体样式。
</p>

<p>
注意：若当前使用的字体并非统一尺寸，即便单次滚动（非自动重复），该设置也可能导致 Emacs 滚动到缓冲区的轻微错误位置。
</p>

<p>
作为 <code>fast-but-imprecise-scrolling</code> 的替代方案，你也可以启用 <b>即时锁定延迟字体</b> 高亮（参见「<a href="#Font-Lock">字体锁定模式</a>」）：将变量 <code>jit-lock-defer-time</code> 自定义为一个较小的正数（如 0.25，若打字速度快，可设为 0.1）。该设置能让长按 <code>C-v</code> 时的滚动更流畅，但滚动到缓冲区新区域时，窗口内容会短暂处于未着色状态。
</p>

<p>
第三种优化方案是设置变量 <code>redisplay-skip-fontification-on-input</code> ：若值为非nil，当有未处理的输入时，Emacs 会跳过部分字体高亮操作。通常，若有未处理的输入，Emacs 本就会完全跳过重绘，因此该设置基本不影响显示，却能通过避免不必要的着色让滚动更顺滑。
</p>

<p>
<b>其他滚动命令</b>
</p>
<ul class="org-ul">
<li><code>M-x scroll-up</code> / <code>M-x scroll-down</code> ：与 <code>scroll-up-command</code> / <code>scroll-down-command</code> 功能类似，但 <b>不遵循</b>  <code>scroll-error-top-bottom</code> 变量的设置。Emacs 24 版本前，这两个命令是默认的上下滚动命令。</li>
<li><code>M-x scroll-up-line</code>  / <code>M-x scroll-down-line</code> ：让当前窗口逐行上下滚动。</li>
</ul>

<p>
若你打算常用上述命令，可为其绑定快捷键（参见「<a href="#Init-Rebinding">在初始化文件中重新绑定按键</a>」）。
</p>

<p>
<b>图形化界面滚动</b>
</p>

<p>
在图形化显示界面中，你也可以通过 <b>滚动条</b> 实现窗口滚动（参见「<a href="#Scroll-Bars">滚动条</a>」）。
</p>
</div>
</div>
<div id="outline-container-Recentering" class="outline-3">
<h3 id="Recentering"><span class="section-number-3">16.2.</span> 居中显示（Recentering）</h3>
<div class="outline-text-3" id="text-Recentering">
<dl class="org-dl">
<dt><code>C-l</code></dt><dd>滚动选中的窗口，使当前行成为文本的正中间行；连续重复执行该命令时，会按循环顺序依次将当前行设为顶行、底行，依此类推。该命令也可能会重新刷新屏幕 (<code>recenter-top-bottom</code>) 。</dd>
<dt><code>C-M-S-l</code></dt><dd>滚动另一个窗口；效果等同于对另一个窗口执行 <code>C-l</code> 命令。</dd>
<dt><code>M-x recenter</code></dt><dd>滚动选中的窗口，使当前行成为文本的正中间行，也可能会重新刷新屏幕。</dd>
<dt><code>C-M-l</code></dt><dd>通过启发式滚动，将有效信息显示在屏幕中 (<code>reposition-window</code>) 。</dd>
</dl>

<p>
<code>C-l</code> (<code>recenter-top-bottom</code>) 命令用于为选中的窗口重定中心，通过滚动让当前屏幕行恰好处于窗口正中间，或尽可能接近正中间的位置。
</p>

<p>
连续两次按下 <code>C-l</code> (<code>C-l C-l</code>)，会滚动窗口使光标位于屏幕最顶行；第三次按下 <code>C-l</code> ，会让光标位于屏幕最底行。每一次连续按下的 <code>C-l</code> ，都会在这三个位置间循环切换。
</p>

<p>
你可以通过自定义列表变量 <code>recenter-positions</code> 来修改循环顺序。该列表的每个元素可以是符号 top（顶部）、middle（中间）、bottom（底部），也可以是数字：整数表示将当前行移动到指定的屏幕行号，0.0 到 1.0 之间的浮点数则表示将当前行定位在窗口顶部起的指定百分比位置。默认的列表值为 <code>(middle top bottom)</code> ，即上述的循环顺序。此外，若将变量 <code>scroll-margin</code> 设为非零值 <code>n</code> ， <code>C-l</code> 命令会始终让光标与窗口顶部、底部保持至少 <code>n</code> 行的屏幕间距（参见「<a href="#Auto-Scrolling">自动滚动</a>」章节）。
</p>

<p>
你也可以为 <code>C-l</code> 命令添加前缀参数：单纯的前缀参数 <code>C-u C-l</code> 仅将光标所在行重定到窗口中心；正数值参数 <code>n</code> 会将光标所在行移至窗口顶部向下数第 <code>n</code> 行的位置；参数 <code>0</code> 会将光标所在行移至窗口顶行；负数值参数 <code>−n</code> 会将光标所在行移至窗口底部向上数第 <code>n</code> 行的位置。当指定了参数时， <code>C-l</code> 命令不会清空屏幕，也不会在不同屏幕位置间循环。
</p>

<p>
若变量 <code>recenter-redisplay</code> 设为非 nil 值，每次执行 <code>C-l</code> 命令都会清空并重新刷新屏幕；其特殊值 <code>tty</code> （默认值）表示仅在文本终端窗口中执行该刷新操作。当屏幕因任何原因出现显示错乱时，重新刷新屏幕会非常有用（参见「<a href="#Screen-Garbled">屏幕显示错乱</a>」章节）。
</p>

<p>
更基础的命令 <code>M-x recenter</code> 与 <code>recenter-top-bottom</code> 功能类似，但不会在不同屏幕位置间循环。
</p>

<p>
<code>C-M-l</code> (<code>reposition-window</code>) 会通过启发式方式滚动当前窗口，旨在将有效信息展示在屏幕中。例如，在 Lisp 文件中，该命令会尽可能将当前整个函数定义（defun）完整显示在屏幕内。
</p>
</div>
</div>
<div id="outline-container-Auto-Scrolling" class="outline-3">
<h3 id="Auto-Scrolling"><span class="section-number-3">16.3.</span> 自动滚动</h3>
<div class="outline-text-3" id="text-Auto-Scrolling">
<p>
当光标移出文本的可视区域时，Emacs 会执行 <code>automatic scrolling</code> 自动滚动。默认情况下，自动滚动会将光标垂直居中在窗口中，不过有多种方式可以修改这一行为。
</p>

<p>
若将变量 <code>scroll-conservatively</code> 设为较小的数值 <code>n</code> ，当光标仅小幅移出屏幕（不超过n行）时，Emacs 会仅滚动必要的距离，将光标拉回屏幕可视范围；若此操作仍无法让光标显示，Emacs 会滚动至恰好让光标在窗口中居中的位置。若将 <code>scroll-conservatively</code> 设为较大的数值（大于 100），无论光标移出多远，自动滚动都不会让光标居中；Emacs 始终仅滚动必要距离让光标进入可视范围，光标最终会出现在窗口顶部或底部，具体取决于滚动方向。 <code>scroll-conservatively</code> 的默认值为 <code>0</code> ，即始终让光标在窗口中居中。需要注意的是，在迷你缓冲区窗口中，默认的滚动行为始终为保守模式，因为变量 <code>scroll-minibuffer-conservatively</code> 的默认值为非空，且该变量的优先级高于 <code>scroll-conservatively</code> 。
</p>

<p>
控制自动滚动的另一种方式是自定义变量 <code>scroll-step</code> ，其值决定了光标移出屏幕时，自动滚动的行数。若滚动该行数后仍无法让光标回到可视范围，则会将光标居中显示。 <code>scroll-step</code> 的默认值为 0，这一设置（在默认情况下）会让滚动后光标始终保持居中。
</p>

<p>
第三种控制自动滚动的方式是自定义变量 <code>scroll-up-aggressively</code> 和 <code>scroll-down-aggressively</code> ，这两个变量可直接指定滚动后光标的垂直位置。 <code>scroll-up-aggressively</code> 的值可以是 <code>nil</code> （默认值），也可以是 0 到 1 之间的浮点数 <code>f</code> 。若设为浮点数，当光标超出窗口下边缘（即向前滚动）时，Emacs 会滚动窗口，使光标到窗口下边缘的距离为窗口高度的 <code>f</code> 倍。因此， <code>f</code> 值越大，滚动的激进程度越高，会有更多新文本进入可视范围。默认值 <code>nil</code> 等效于 0.5。
</p>

<p>
同理，当光标超出窗口上边缘（即向后滚动）时，会使用变量 <code>scroll-down-aggressively</code> 。其值指定了滚动后光标与窗口上边缘的距离比例，与 <code>scroll-up-aggressively</code> 一致，值越大，滚动的激进程度越高。
</p>

<p>
请注意，变量 <code>scroll-conservatively</code> 、 <code>scroll-step</code> 以及 <code>scroll-up-aggressively</code> / <code>scroll-down-aggressively</code> 对自动滚动的控制方式相互矛盾，因此你应仅选择其中一种方式来自定义自动滚动。若同时自定义了多个变量，其优先级顺序为： <code>scroll-conservatively</code> 最高，其次是 <code>scroll-step</code> ，最后是 <code>scroll-up-aggressively</code> / <code>scroll-down-aggressively</code> 。
</p>

<p>
变量 <code>scroll-margin</code> 会限制光标能靠近窗口顶部或底部的距离（即便激进滚动设置的比例 <code>f</code> ，超出了窗口上下边距之间的区域比例）。其值为屏幕行数，当光标与窗口顶部或底部的距离小于该行数时，Emacs 会执行自动滚动。 <code>scroll-margin</code> 的默认值为 0。默认情况下，有效边距的大小被限制为窗口高度的四分之一，不过可通过自定义变量 <code>~maximum-scroll-margin</code> ，将该限制提高至窗口高度的一半（也可降低至 0）。
</p>
</div>
</div>
<div id="outline-container-Horizontal-Scrolling" class="outline-3">
<h3 id="Horizontal-Scrolling"><span class="section-number-3">16.4.</span> 水平滚动</h3>
<div class="outline-text-3" id="text-Horizontal-Scrolling">
<p>
<code>Horizontal scrolling</code> 水平滚动指将窗口内的所有行向侧面偏移，使左边缘附近的部分文本不显示。当窗口中的文本被水平滚动时，文本行将 truncated被截断 而非折行显示（参见《<a href="#Line-Truncation">行截断</a>》相关内容）。若窗口显示的是被截断的文本，每当光标移出屏幕的左边缘或右边缘时，Emacs 会执行自动水平滚动。默认情况下，窗口内的所有行会一起进行水平滚动；但如果将变量 <code>auto-hscroll-mode</code> 设为特殊值 <code>current-line</code> ，则仅显示光标的那一行会被滚动。若要完全关闭自动水平滚动，将变量 <code>auto-hscroll-mode</code> 设为 <code>nil</code> 即可。注意，当自动水平滚动关闭后，若光标移出屏幕边缘，光标会消失以作提示（在文本终端中，光标则会停留在边缘位置）。
</p>

<p>
变量 <code>hscroll-margin</code> 用于控制光标距离窗口左右边缘多近时触发自动水平滚动，其单位为列。例如，若该值设为 5，当光标移动到距离某一边缘 5 列范围内时，会触发水平滚动并远离该边缘。
</p>

<p>
变量 <code>hscroll-step</code> 决定了光标过近边缘时，窗口的滚动列数。默认值 0 表示将光标在窗口中水平居中；正整数值表示滚动的具体列数；0 到 1 之间的浮点数则表示按窗口宽度的该比例进行滚动。
</p>

<p>
你也可以通过以下命令执行显式水平滚动：
</p>
<dl class="org-dl">
<dt><code>C-x &lt;</code></dt><dd>向左滚动当前窗口中的文本 (<code>scroll-left</code>) 。</dd>
<dt><code>C-x &gt;</code></dt><dd>向右滚动 (<code>scroll-right</code>) 。</dd>
</dl>

<p>
<code>C-x &lt;</code> (<code>scroll-left</code>) 会将选中窗口的文本向左滚动窗口的完整宽度减两列的距离（换言之，窗口内的文本相对窗口向左移动）。若带数字参数 <code>n</code> ，则向左滚动 <code>n</code> 列。
</p>

<p>
当文本被向左滚动后，若光标移出窗口左边缘，光标会固定在窗口左边缘，直至光标移回文本的显示区域。此行为与 <code>auto-hscroll-mode</code> 的当前设置无关 —— 对于向左滚动的文本，该变量仅影响窗口右边缘处的行为。
</p>

<p>
<code>C-x &gt;</code> (<code>scroll-right</code>) 的向右滚动行为与之类似。当窗口恢复正常显示（每行均从窗口左边缘开始）后，无法再继续向右滚动，此时执行该操作无任何效果。这意味着你无需为 <code>C-x &gt;</code> 精确计算参数，任何足够大的参数都能恢复正常显示。
</p>

<p>
若通过上述命令对窗口进行水平滚动，该操作会为自动水平滚动设置一个下限。自动水平滚动仍会继续作用于窗口，但向右滚动的距离绝不会超过你此前通过 <code>scroll-left</code> 命令设置的距离。当 <code>auto-hscroll-mode</code> 设为 <code>current-line</code> 时，除显示光标的行外，其他所有行都会按该最小距离滚动。
</p>

<p>
在图形化显示界面中，若开启可选的 <code>horizontal-scroll-bar-mode</code> （水平滚动条模式），你可通过水平滚动条对窗口进行水平滚动，参见《<a href="#Scroll-Bars">滚动条</a>》相关内容
</p>
</div>
</div>
<div id="outline-container-Narrowing" class="outline-3">
<h3 id="Narrowing"><span class="section-number-3">16.5.</span> 窄化显示（Narrowing）</h3>
<div class="outline-text-3" id="text-Narrowing">
<p>
<code>Narrowing</code> 内容窄化指将操作焦点限定在缓冲区的某一部分，使其余部分暂时无法访问。仍可操作的这部分区域被称为 <b>accessible portion可访问区域</b> 。取消窄化、让整个缓冲区恢复可访问状态的操作，称为 <b>widening内容展宽</b> 。缓冲区当前生效的窄化范围，被称为缓冲区的 <b>restriction访问限制</b> 。
</p>

<p>
通过内容窄化隐藏无关内容，能让你更专注地处理单个子程序或段落；同时，它也可用于限制替换命令或重复执行的键盘宏的作用范围。
</p>

<p>
<b>窄化相关核心命令</b>
</p>
<dl class="org-dl">
<dt><code>C-x n n</code></dt><dd>窄化至光标与标记之间的区域 (<code>narrow-to-region</code>) 。</dd>
<dt><code>C-x n w</code></dt><dd>展宽缓冲区，恢复全部内容的可访问性 (<code>widen</code>) 。</dd>
<dt><code>C-x n p</code></dt><dd>窄化至光标所在的当前页面 (<code>narrow-to-page</code>) 。</dd>
<dt><code>C-x n d</code></dt><dd>窄化至光标所在的当前函数定义块 (<code>narrow-to-defun</code>) 。</dd>
</dl>

<p>
当缓冲区被窄化到某一部分后，该部分会呈现为缓冲区的全部内容：你无法看到其余部分，无法将光标移至该区域外（移动命令无法超出可访问区域），也无法对不可访问部分进行任何修改。但这些内容并未被删除，若你保存文件，所有不可访问的文本都会被一并保存。只要窄化状态生效，模式行中会显示Narrow（窄化）字样，提示当前的窄化状态。
</p>

<p>
核心的窄化命令为  <code>C-x n n</code> (<code>narrow-to-region</code>) ，执行该命令后，缓冲区的访问限制会被设定为当前选中的区域，仅该区域内的文本可访问，区域之前和之后的所有文本均变为不可访问，光标与标记的位置不会发生改变。
</p>

<p>
此外，可使用  <code>C-x n p</code> (<code>narrow-to-page</code>) 窄化至光标所在的当前页面（关于页面的定义，参见 “<a href="#Pages">页面</a>” 相关章节）； <code>C-x n d</code> (<code>narrow-to-defun</code>) 可窄化至包含光标在内的当前函数定义块（参见 “<a href="#Defuns">顶层定义 或 函数定义块</a>“ 相关章节）。
</p>

<p>
取消窄化的唯一方式是执行 <code>C-x n w</code> (<code>widen</code>) 进行内容展宽，该操作会清除缓冲区的访问限制，恢复全部文本的可访问性。
</p>

<p>
你可通过 <code>C-x =</code> 命令查看当前窄化的具体范围信息（参见 “<a href="#Position-Info">光标位置信息</a>” 相关章节）。
</p>

<p>
由于对于不了解窄化功能的用户而言，该操作极易造成操作困惑，因此 <code>narrow-to-region</code>  默认是 <b>禁用命令</b> 。首次尝试执行该命令时，Emacs 会弹出确认提示，并提供启用该命令的选项；若你选择启用，后续执行该命令将不再需要确认（关于禁用命令的相关说明，参见 “<a href="#Disabling">禁用命令</a>” 相关章节）。
</p>
</div>
</div>
<div id="outline-container-View-Mode" class="outline-3">
<h3 id="View-Mode"><span class="section-number-3">16.6.</span> 查看模式（View Mode）</h3>
<div class="outline-text-3" id="text-View-Mode">
<p>
<code>M-x view-mode</code> 查看模式是一种次要模式，可按整屏顺序浏览缓冲区内容。该模式提供了便捷的缓冲区滚动命令，但不支持对内容进行修改。除常规的 Emacs 光标移动命令外，可按下 <code>SPC</code> （空格） 向下滚动一整屏，按下 <code>S-SPC</code> 或 <code>DEL</code> 向上滚动，按下s 启动增量搜索。
</p>

<p>
按下 <code>q</code> (View-quit) 会关闭查看模式，并切回开启该模式前的缓冲区及光标位置。按下 <code>e</code> (<code>View-exit</code>) 会关闭查看模式，同时保留当前的缓冲区及光标位置。
</p>

<p>
执行 <code>M-x view-buffer会</code> 提示选择一个已存在的 Emacs 缓冲区，切换至该缓冲区并启用查看模式。执行 <code>M-x view-file</code> 会提示选择一个文件，打开该文件并同时启用查看模式。
</p>
</div>
</div>
<div id="outline-container-Follow-Mode" class="outline-3">
<h3 id="Follow-Mode"><span class="section-number-3">16.7.</span> 跟随模式（Follow Mode）</h3>
<div class="outline-text-3" id="text-Follow-Mode">
<p>
<code>Follow mode</code> 跟随模式是一种次要模式，可让两个显示同一缓冲区的窗口，如同一个纵向的超大虚拟窗口般同步滚动。使用跟随模式的操作方法为：先打开一个仅含单个窗口的框架，通过 <code>C-x 3</code> 将其拆分为两个左右并排的窗口，再执行 <code>M-x follow-mode</code> 即可启用。启用后，你可在任意一个窗口中编辑缓冲区、滚动页面，另一个窗口会自动同步跟随操作。
</p>

<p>
在跟随模式下，若将光标从一个窗口的可视区域移出，移入另一个窗口的可视区域时，系统会自动选中该窗口 —— 这一逻辑同样将两个窗口视作同一个大窗口的不同部分。
</p>

<p>
再次执行 <code>M-x follow-mode</code> ，即可关闭跟随模式。
</p>
</div>
</div>
<div id="outline-container-Faces" class="outline-3">
<h3 id="Faces"><span class="section-number-3">16.8.</span> 文本外观（Text Faces）</h3>
<div class="outline-text-3" id="text-Faces">
<p>
Emacs 可以用多种不同样式显示文本，这些样式称为 <b>外观</b> （face）。
</p>

<p>
每个外观可以指定多种外观属性，例如字体、高度、粗细、倾斜度、前景色与背景色，以及下划线或上划线。大多数主模式会通过字体锁定模式（Font Lock mode）自动为文本分配外观。关于这些外观如何分配的更多信息，参见<a href="#Font-Lock">字体锁定模式</a>。
</p>

<p>
要查看当前已定义的外观及其显示效果，输入 <code>M-x list-faces-display</code> 。如果带上前缀参数，该命令会提示输入一个正则表达式，并只显示名称与该正则表达式匹配的外观（参见<a href="#Regexps">正则表达式语法</a>）。
</p>

<p>
同一个外观在不同 <b>框架（frame）</b> 中可能显示不同。例如，某些文本终端不支持所有外观属性，尤其是字体、高度和宽度，还有些终端只支持有限的颜色范围。此外，为了可读性，大多数 Emacs 外观都被定义为：在浅色和深色框架背景下使用不同属性。默认情况下，Emacs 会根据每个框架当前的背景色，自动选择使用哪一组外观属性。不过，你可以通过给变量 <code>frame-background-mode</code> 赋予一个非 nil 的值来覆盖这一行为：
</p>
<ul class="org-ul">
<li>值为 <code>dark</code> 会让 Emacs 把所有框架当作 <b>深色背景</b> 处理；</li>
<li>值为 <code>light</code> 则当作 <b>浅色背景</b> 处理。</li>
</ul>

<p>
你可以自定义外观以修改其属性，并将这些自定义设置保存到未来的 Emacs 会话中。详情参见<a href="#Face-Customization">自定义外观</a>。
</p>

<p>
<code>default</code> （默认）外观是显示文本的基础外观，它的所有属性都已完整定义。它的背景色也会被用作框架的背景色。参见<a href="#Colors">外观颜色</a>。
</p>

<p>
另一个特殊外观是 <code>cursor</code> （光标）外观。在图形界面下，该外观的背景色用于绘制文本光标；此外观的其他属性均无效。光标下方文本的前景色取自底层文本的背景色。在文本终端中，文本光标的样式由终端决定，而非 <code>cursor</code> 外观。
</p>

<p>
你还可以使用 X 资源来指定任意特定外观的属性。参见 <a href="#Resources">X 资源</a>。
</p>

<p>
Emacs 可以显示 <b>变宽字体</b> ，但部分 Emacs 命令（尤其是缩进相关命令）不会考虑字符的显示宽度变化。因此，我们建议 <b>不要对大多数外观使用变宽字体</b> ，特别是由字体锁定模式分配的外观。
</p>
</div>
</div>
<div id="outline-container-Colors" class="outline-3">
<h3 id="Colors"><span class="section-number-3">16.9.</span> 外观颜色设置</h3>
<div class="outline-text-3" id="text-Colors">
<p>
外观可设置不同的前景色和背景色。为外观指定颜色时（例如自定义面版的场景，参见「<a href="#Face-Customization">自定义外观</a>」），可使用 <code>color name</code> 颜色名称或 <code>RGB triplet</code> RGB 三元组两种方式。
</p>
<ul class="org-ul">
<li><a href="#Color-Names">颜色名称</a></li>
<li><a href="#RGB-Triplets">RGB 三元组（RGB Triplets）</a></li>
</ul>
</div>
<div id="outline-container-Color-Names" class="outline-4">
<h4 id="Color-Names"><span class="section-number-4">16.9.1.</span> 颜色名称</h4>
<div class="outline-text-4" id="text-Color-Names">
<p>
颜色名称为 pre-defined name预定义名称，例如深橙色（'dark orange'）、中海绿色（'medium sea green'）。键入命令 <code>M-x list-colors-display</code> 可查看颜色名称列表；通过自定义变量 <code>list-colors-sort</code> ，可控制颜色的显示顺序。在图形化显示器中执行该命令，会显示 Emacs 支持的所有颜色名称（均为 X11 标准颜色名称，定义于 X 系统的 <code>rgb.txt</code> 文件）；在文本终端中执行该命令，仅会显示可在该类终端上正常显示的少量颜色子集。即便在文本终端中，Emacs 仍能识别所有 X11 颜色名称；若为某一面版指定了 X11 颜色名称对应的颜色，终端会自动匹配最相近的颜色进行显示。
</p>
</div>
</div>
<div id="outline-container-RGB-Triplets" class="outline-4">
<h4 id="RGB-Triplets"><span class="section-number-4">16.9.2.</span> RGB 三元组（RGB Triplets）</h4>
<div class="outline-text-4" id="text-RGB-Triplets">
<p>
RGB 三元组为 "#RRGGBB" 格式的字符串，其中红、绿、蓝三原色的分量各由一个十六进制数表示，取值范围为00（亮度为 0）至FF（最大亮度）。每个颜色分量也可使用 1 位、3 位或 4 位十六进制数表示，因此红色可写作 <code>#F00</code> 、 <code>#fff000000</code> 或 <code>#ffff00000000</code> ， <b>注意各分量的位数必须保持一致</b> 。十六进制数中的 A-F 字符，大小写均可。
</p>

<p>
执行 <code>M-x list-colors-display</code> 命令时，也会同时显示每个命名颜色对应的 RGB 三元组，例如中海绿色（medium sea green）对应的 RGB 三元组为 <code>#3CB371</code> 。
</p>

<p>
你可通过命令 <code>M-x set-face-foreground</code> 和 <code>M-x set-face-background</code> ，分别修改面版的前景色和背景色。执行该类命令时，迷你缓冲区会提示你输入面版名称和颜色（支持补全），确认后即可为该面版应用指定颜色。这两个命令的效果会作用于所有 Emacs 窗口，但与使用自定义缓冲区或 X 资源的方式不同，其设置不会在后续的 Emacs 会话中保留。你也可通过窗口参数，为指定的单个窗口设置前景色和背景色，参见「<a href="#Frame-Parameters">框架参数</a>」章节。
</p>
</div>
</div>
</div>
<div id="outline-container-Standard-Faces" class="outline-3">
<h3 id="Standard-Faces"><span class="section-number-3">16.10.</span> 标准外观（Standard Faces）</h3>
<div class="outline-text-3" id="text-Standard-Faces">
<p>
以下是用于指定文本显示样式的标准样式，可将其应用于特定文本以实现对应的显示效果。
</p>

<dl class="org-dl">
<dt><code>default</code></dt><dd>（默认样式）该样式适用于未指定任何样式的普通文本，其背景色会作为 Emacs 窗口的背景色。</dd>
<dt><code>bold</code></dt><dd>（粗体样式）使用默认字体的粗体变体。</dd>
<dt><code>italic</code></dt><dd>（斜体样式）使用默认字体的斜体变体。</dd>
<dt><code>bold-italic</code></dt><dd>（粗斜体样式）使用默认字体的粗斜体变体。</dd>
<dt><code>underline</code></dt><dd>（下划线样式）为文本添加下划线样式。</dd>
<dt><code>fixed-pitch</code></dt><dd>（等宽样式）强制使用 fixed-width 等宽字体。可根据需求自定义该样式，替换为其他等宽字体，但不可将其设为 variable-width 变宽字体。</dd>
<dt><code>fixed-pitch-serif</code></dt><dd>（衬线等宽样式）与等宽样式功能一致，区别在于该样式使用 serifs 带衬线的字体，视觉上更接近传统打字机的字体样式。</dd>
<dt><code>variable-pitch</code></dt><dd>（变宽样式）强制使用变宽（即比例）字体，其字体大小与默认样式（通常为等宽字体）的字体大小保持一致。</dd>
<dt><code>variable-pitch-text</code></dt><dd>（文本变宽样式）继承自变宽样式，字体尺寸略大于变宽样式。与等宽字体同高度的比例字体，视觉上通常会显得更小，可读性也会随之降低。因此在显示大篇幅文本时，该样式是比变宽样式（尺寸略小）更优的选择。</dd>
<dt><code>shadow</code></dt><dd>（浅显样式）用于让文本比周围的普通文本更不显眼，通常通过使用灰色调，与黑色或白色的默认前景色形成对比来实现该效果。</dd>
</dl>

<p>
以下是一组不完整的样式列表，这类样式用于为特定目的临时高亮文本的特定部分（许多其他模式也会为此定义专属样式表）。
</p>
<dl class="org-dl">
<dt><code>highlight</code></dt><dd>（高亮样式）在多种场景下用于文本高亮，例如鼠标光标移至超链接上时的文本高亮。</dd>
<dt><code>isearch</code></dt><dd>（增量搜索高亮样式）用于高亮增量搜索的当前匹配结果（参见<a href="#Incremental-Search">增量搜索</a>）。</dd>
<dt><code>query-replace</code></dt><dd>（查询替换高亮样式）用于高亮查询替换的当前匹配结果（参见<a href="#Replace">替换命令</a>）。</dd>
<dt><code>lazy-highlight</code></dt><dd>（延迟高亮样式）用于高亮增量搜索和查询替换中的非当前匹配结果（延迟匹配项）。</dd>
<dt><code>region</code></dt><dd>（选区样式）用于显示激活的文本选区（参见<a href="#Mark">《标记与选区</a>》）。当 Emacs 编译时启用 GTK+ 支持时，该样式的颜色会继承当前的 GTK+ 主题。</dd>
<dt><code>secondary-selection</code></dt><dd>（二级选区样式）用于显示 X 系统的二级选区（参见<a href="#Secondary-Selection">二级选区</a>）。</dd>
<dt><code>trailing-whitespace</code></dt><dd>（行尾空白样式）当变量 <code>show-trailing-whitespace</code> 非空时，用于高亮行尾的多余空格和制表符（参见<a href="#Useless-Whitespace">无用空白字符</a>）。</dd>
<dt><code>escape-glyph</code></dt><dd>（转义符号样式）用于显示控制字符和转义序列（参见<a href="#Text-Display">文本的显示方式</a>）。</dd>
<dt><code>homoglyph</code></dt><dd>（形近字符样式）用于显示形近字符，即外观相似但实际并非所代表的字符（参见<a href="#Text-Display">文本的显示方式</a>）。</dd>
<dt><code>nobreak-space</code></dt><dd>（不换行空格样式）用于显示不换行空格字符（参见<a href="#Text-Display">文本的显示方式</a>）。</dd>
<dt><code>nobreak-hyphen</code></dt><dd>（不换行连字符样式）用于显示不换行连字符（参见<a href="#Text-Display">文本的显示方式</a>）。</dd>
</dl>

<p>
以下样式用于控制 Emacs 框架各组成部分的显示样式：
</p>
<dl class="org-dl">
<dt><code>mode-line</code></dt><dd><p>
（模式行样式）是模式行的基础样式，同时也适用于标题行，且在未使用工具包菜单时适用于菜单栏。默认情况下，在图形化显示器中会为其添加阴影效果以实现凸起视觉感；在文本终端中，其显示样式为默认样式的反色。
</p>

<p>
模式行实际使用的 <code>mode-line-active</code> 和 <code>mode-line-inactive</code> 均继承自该样式。
</p></dd>
<dt><code>mode-line-active</code></dt><dd>（激活模式行样式）与 <code>mode-line</code> 样式一致，专用于当前选中窗口的模式行。该样式继承自 <code>mode-line</code> ，因此对模式行样式的修改会作用于所有窗口的模式行。</dd>
<dt><code>mode-line-inactive</code></dt><dd>（非激活模式行样式） 与 <code>mode-line</code> 一致，专用于非选中窗口的模式行（当变量 <code>mode-line-in-non-selected-windows</code> 非空时生效）。该样式继承自 <code>mode-line</code> ，因此对模式行样式的修改会作用于所有窗口的模式行。</dd>
<dt><code>mode-line-highlight</code></dt><dd>（模式行高亮样式） 与 <code>highlight</code> 样式功能一致，专用于模式行上的鼠标敏感文本区域。鼠标指针悬停在该类文本区域时，通常会弹出工具提示（参见<a href="#Tooltips">工具提示</a>）。</dd>
<dt><code>mode-line-buffer-id</code></dt><dd>（模式行缓冲区标识样式）用于模式行中显示缓冲区标识的部分。</dd>
<dt><code>header-line</code></dt><dd>（标题行样式） 与 <code>mode-line</code> 样式功能类似，专用于窗口的标题行；标题行显示在窗口顶部，模式行则显示在窗口底部。大多数窗口无标题行，仅部分特殊模式（如 info mode信息模式）会生成标题行。</dd>
<dt><code>header-line-highlight</code></dt><dd>（标题行高亮样式）与高亮样式、模式行高亮样式功能一致，专用于标题行上的鼠标敏感文本区域。该样式为独立样式，因标题行样式的自定义设置可能与高亮样式不兼容。</dd>
<dt><code>tab-line</code></dt><dd>（标签行样式）与 <code>mode-line</code> 样式功能类似，专用于窗口的标签行；标签行显示在窗口顶部，以标签形式展示窗口的各个缓冲区（参见<a href="#Tab-Line">窗口标签行</a>）。</dd>
<dt><code>vertical-border</code></dt><dd>（垂直边框样式）在文本终端中，用于显示窗口之间的垂直分隔线。</dd>
<dt><code>minibuffer-prompt</code></dt><dd>（迷你缓冲区提示符样式） 用于显示迷你缓冲区中的提示符字符串。默认情况下，Emacs 会自动将该样式添加至变量 <code>minibuffer-prompt-properties</code> 的取值中；该变量是一个文本属性列表（参见《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Text-Properties.html#Text-Properties">文本属性</a>），用于控制提示符文本的显示（进入迷你缓冲区时该变量生效）。</dd>
<dt><code>fringe</code></dt><dd>（边距样式）在图形化显示器中，用于显示窗口左右两侧的边距区域（边距是 Emacs 窗口中，文本区域与窗口左右边框之间的窄条区域）（参见<a href="#Fringes">窗口边距</a>）。</dd>
<dt><code>cursor</code></dt><dd>（光标样式）该样式的 <code>:background</code> 属性用于指定文本光标的颜色（参见<a href="#Cursor-Display">光标的显示</a>）。</dd>
<dt><code>tooltip</code></dt><dd>（工具提示样式）用于显示工具提示的文本。默认情况下，若 Emacs 编译时启用 GTK+ 支持，工具提示会由 GTK+ 渲染，该样式将失效（参见<a href="#Tooltips">工具提示</a>）。</dd>
<dt><code>mouse</code></dt><dd>（鼠标指针样式）用于指定鼠标指针的颜色。</dd>
</dl>

<p>
以下外观样式同样用于控制 Emacs 窗口各组成部分的显示样式，但仅在文本终端中，或Emacs 基于 X 系统编译且未启用工具包支持时生效。其他场景下，对应窗口组件的显示样式由系统全局设置决定。
</p>
<dl class="org-dl">
<dt><code>scroll-bar</code></dt><dd>（滚动条样式）用于指定滚动条的视觉样式（参见<a href="#Scroll-Bars">滚动条</a>）。</dd>
<dt><code>tool-bar</code></dt><dd>（工具栏样式）用于指定工具栏图标的颜色（参见<a href="#Tool-Bars">工具栏</a>）。</dd>
<dt><code>tab-bar</code></dt><dd>（标签栏样式）用于指定标签栏图标的颜色（参见<a href="#Tab-Bars">标签栏</a>）。</dd>
<dt><code>menu</code></dt><dd>（菜单样式）用于指定 Emacs 菜单的颜色和字体（参见<a href="#Menu-Bars">菜单栏</a>）。</dd>
<dt><code>tty-menu-enabled-face</code></dt><dd>（终端可用菜单项样式）在文本模式终端中，用于显示可用的菜单项。</dd>
<dt><code>tty-menu-disabled-face</code></dt><dd>（终端禁用菜单项样式）在文本模式终端中，用于显示禁用的菜单项。</dd>
<dt><code>tty-menu-selected-face</code></dt><dd>（终端选中菜单项样式）在文本模式终端中，用于显示待选中的菜单项（单击鼠标或按下 <code>RET</code> 回车键即可选中该菜单项）</dd>
</dl>
</div>
</div>
<div id="outline-container-Icons" class="outline-3">
<h3 id="Icons"><span class="section-number-3">16.11.</span> 图标（Icons）</h3>
<div class="outline-text-3" id="text-Icons">
<p>
Emacs 会在部分场景下显示可点击的按钮（或其他信息类图标），你可自定义这些图标的显示样式。
</p>

<p>
此处的核心自定义项为用户选项 <code>icon-preference</code> （图标偏好）。通过该选项，你可以向 Emacs 设定自己对图标的整体显示偏好。该选项的取值为 <b>图标类型列表</b> ，Emacs 会选用列表中首个受支持的图标类型。目前支持的图标类型包括：
</p>

<dl class="org-dl">
<dt><code>image</code></dt><dd>使用图像作为图标显示</dd>
<dt><code>emoji</code></dt><dd>使用彩色表情符号作为图标显示</dd>
<dt><code>symbol</code></dt><dd>使用单色符号作为图标显示</dd>
<dt><code>text</code></dt><dd>使用简单文本作为图标显示</dd>
</dl>

<p>
此外，你可通过命令 <code>M-x customize-icon</code> 对单个图标进行个性化设置，主题也可进一步修改所有图标的显示样式。
</p>

<p>
若需快速查看某一图标的说明信息，可使用命令 <code>M-x describe-icon</code> 。
</p>
</div>
</div>
<div id="outline-container-Text-Scale" class="outline-3">
<h3 id="Text-Scale"><span class="section-number-3">16.12.</span> 文本缩放（Text Scale）</h3>
<div class="outline-text-3" id="text-Text-Scale">
<p>
要增大当前缓冲区中默认面版的字体大小，可按下 <code>C-x C-+</code> 或 <code>C-x C-=</code> ；要减小字体大小，按下 <code>C-x C--</code> ；恢复默认（全局）字体大小则按下 <code>C-x C-0</code> 。这些快捷键均绑定至同一个命令 <code>text-scale-adjust</code> ，该命令会根据最后按下的按键判断执行的操作，并通过修改默认面版的高度属性相应调整字体大小。
</p>

<p>
大多数面版并未显式设置 <code>:height</code> 属性，因此会继承默认面版的高度，这类面版的字体大小也会随上述命令同步缩放。
</p>

<p>
对于默认面版之外、显式设置了 <code>:height</code> 属性的面版，其字体大小不会受上述命令影响； <code>header-line</code> 标题行面版为特例：即便显式设置了 <code>:height</code> 属性，该面版仍会随命令同步缩放。
</p>

<p>
同理，当鼠标指针置于缓冲区文本区域时，按住 <code>Ctrl</code> 键滚动鼠标滚轮，也会根据滚动方向增大或减小相关面版的字体大小。
</p>

<p>
执行上述缩放命令时，后续的调节按键可省略前置的 <code>C-x</code> 和修饰键直接重复按下。例如， <code>C-x  C-= C-=   C-=  与  C-x  C-=  =  =</code> 两种操作，均可将面版高度增大三级。每级缩放会将文本高度乘以1.2的系数，若需修改该系数，可自定义变量 <code>text-scale-mode-step</code> 。为 <code>text-scale-adjust</code> 命令传入数字参数0，效果与按下 <code>C-x C-0=</code> 一致，均可恢复默认的文本高度。
</p>

<p>
若要全局修改所有区域的字体大小，可按下C-x C-M-+、C-x C-M-=、C-x C-M&#x2013; 或C-x C-M-0，也可同时按住Ctrl 键和 Meta 键滚动鼠标滚轮。若希望全局修改字体大小时，Emacs 窗口也随之自动调整尺寸，可自定义变量 <code>global-text-scale-adjust-resizes-frames</code> （参见<a href="#Easy-Customization">简易自定义界面</a>）。
</p>

<p>
命令 <code>text-scale-increase</code> 和 <code>text-scale-decrease</code> ，分别实现与 <code>C-x C-+</code> 、 <code>C-x C--</code> 完全相同的功能，仅调整当前缓冲区的字体大小。相比绑定 <code>text-scale-adjust</code> ，直接绑定这两个命令可能会更便捷。
</p>

<p>
命令 <code>text-scale-set</code> 可根据其前缀参数，将当前缓冲区的字体大小缩放至指定的绝对级别。
</p>

<p>
当当前文本的缩放比例非 1 时，上述所有缩放命令会自动启用次要模式 <code>text-scale-mode</code> ；缩放比例恢复为 1 时，该模式则会自动关闭。
</p>

<p>
命令 <code>text-scale-pinch</code> 支持通过触控板的捏合手势调整文本缩放比例：将两根手指放在触控板上相互靠近或远离，命令会根据手指间的距离变化放大或缩小文本。该功能仅在部分搭载兼容硬件的系统上可用。
</p>

<p>
命令 <code>mouse-wheel-text-scale</code> 也可调整文本缩放比例，该命令通常在按住 <code>Ctrl</code> 键滚动鼠标滚轮时触发，向下滚动滚轮会放大文本，向上滚动滚轮则会缩小文本。
</p>
</div>
</div>
<div id="outline-container-Font-Lock" class="outline-3">
<h3 id="Font-Lock"><span class="section-number-3">16.13.</span> 字体锁定模式（Font Lock mode）</h3>
<div class="outline-text-3" id="text-Font-Lock">
<p>
字体锁定模式是一种次要模式，仅作用于单个缓冲区，该模式会为缓冲区中的文本分配对应面版（即进行字体着色）。每个缓冲区的主模式会告知字体锁定模式需要对哪些文本进行着色；例如，编程语言相关主模式会为注释、字符串、函数名等语法相关结构进行字体着色。
</p>

<p>
支持字体锁定模式的主模式会默认启用该功能。在当前缓冲区中切换其开关状态，可执行命令 <code>M-x font-lock-mode</code> ；传入正数值参数会强制启用字体锁定模式，传入负数或 0 参数则会关闭该模式。
</p>

<p>
执行命令 <code>M-x global-font-lock-mode</code> 可在所有缓冲区中统一切换字体锁定模式的开关。若要让该设置在后续的 Emacs 会话中生效，可自定义变量 <code>global-font-lock-mode</code> （参见<a href="#Easy-Customization">简易自定义界面</a>），或在初始化文件中添加以下代码行：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(global-font-lock-mode 0)
</pre>
</div>

<p>
若你已关闭全局字体锁定模式，仍可通过将函数 <code>font-lock-mode</code> 添加至模式钩子，为特定主模式单独启用字体锁定功能（参见<a href="#Hooks">钩子</a>）。例如，为 C 语言文件编辑启用该模式，可添加以下配置：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'c-mode-hook 'font-lock-mode)
</pre>
</div>

<p>
字体锁定模式会使用多个特定命名的面版完成着色工作，包括 <code>font-lock-string-face</code> （字符串着色面版）、 <code>font-lock-comment-face</code> （注释着色面版）等。查看所有相关面版的最简方式为执行 <code>M-x customize-group RET font-lock-faces RET</code> ，随后可在该自定义缓冲区中修改这些面版的显示样式（参见<a href="#Face-Customization">自定义面版</a>）。
</p>

<p>
对超大缓冲区进行字体着色会消耗较多时间。为避免打开文件时出现长时间卡顿，Emacs 初始状态下仅会对缓冲区的可见区域进行着色。当你滚动浏览缓冲区时，新进入可见区域的文本会在显示的同时完成着色；这种字体锁定方式被称为 <b>即时锁定</b> （Just-In-Time (or JIT)）。你可通过自定义 <code>jit-lock自定义组</code> 中的相关变量，控制即时锁定的行为，包括设置让 Emacs 在空闲时执行着色操作（参见<a href="#Specific-Customization">自定义特定项</a>）。
</p>

<p>
主模式用于判断缓冲区中哪些文本需要着色、以及为其分配何种面版的依据，来自多种不同的文本分析方式：
</p>

<ul class="org-ul">
<li>基于正则表达式，检索关键字及其他文本模式（参见<a href="#Regexp-Search">正则表达式搜索</a>）；</li>

<li>基于内置的语法表，识别文本中语法上彼此独立的部分（参见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Tables.html#Syntax-Tables">语法表</a>》章节）；</li>

<li>通过专用类库（如 tree-sitter 类库，参见《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Parsing-Program-Source.html#Parsing-Program-Source">程序源代码解析</a>章节）或外部程序，调用完整解析器生成的语法树进行分析。</li>

<li><a href="#Traditional-Font-Lock">传统字体锁定</a></li>
<li><a href="#Parser_002dbased-Font-Lock">基于解析器的字体锁定</a></li>
</ul>
</div>
<div id="outline-container-Traditional-Font-Lock" class="outline-4">
<h4 id="Traditional-Font-Lock"><span class="section-number-4">16.13.1.</span> 传统字体锁定</h4>
<div class="outline-text-4" id="text-Traditional-Font-Lock">
<p>
提供字体锁定信息的「Traditional传统」方法，基于正则表达式搜索，以及借助 Emacs 内置语法表开展的句法分析。本小节将介绍，针对采用这些传统方法的主模式，字体锁定功能的使用与自定义方式。
</p>

<p>
对于支持该特性的主模式，你可通过自定义变量 <code>font-lock-maximum-decoration</code> ，控制字体锁定模式的着色精细程度。该变量的取值可为数字（数字 1 代表最低程度的着色，部分模式支持最高至 3 级的着色程度）；也可为 <code>t</code> ，表示「尽可能高的着色程度」（默认值）。若要让该自定义设置对某一文件缓冲区生效，需在打开文件前完成 <code>font-lock-maximum-decoration</code> 的配置；若已打开文件后才修改该变量，需关闭该缓冲区，重新打开文件使设置生效。
</p>

<p>
你也可为特定主模式单独指定不同的着色等级。例如，要将 C/C++ 模式的着色等级设为 1，其他模式使用默认等级，可将该变量设为以下值：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">'((c-mode . 1) (c++-mode . 1)))
</pre>
</div>

<p>
注释与字符串的着色（或称「句法性」着色），依赖对缓冲区文本句法结构的分析。为提升处理速度，包括 Lisp 模式在内的部分模式遵循一项特殊约定： <b>最左侧列中的左括号或左大括号，始终表示函数定义（defun）的起始位置，因此永远处于任意字符串或注释之外</b> 。因此，若左括号或左大括号出现在字符串或注释内部，请勿将其放在最左侧列。详情参见「<a href="#Left-Margin-Paren">左边界约定</a>」相关内容。
</p>

<p>
绝大多数模式都已预置字体锁定的高亮匹配规则，但若你需要为额外的内容模式添加着色，可使用函数 <code>font-lock-add-keywords</code> ，为特定模式自定义高亮匹配规则。例如，要在 C 语言的注释中高亮显示”FIXME:“字样，可使用以下代码：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'c-mode-hook
          (<span style="color: #a020f0;">lambda</span> ()
           (font-lock-add-keywords nil
            '((<span style="color: #8b2252;">"\\&lt;</span><span style="color: #8b2252; font-weight: bold;">\\</span><span style="color: #8b2252; font-weight: bold;">(</span><span style="color: #8b2252;">FIXME</span><span style="color: #8b2252; font-weight: bold;">\\</span><span style="color: #8b2252; font-weight: bold;">)</span><span style="color: #8b2252;">:"</span> 1
               font-lock-warning-face t)))))
</pre>
</div>

<p>
若要从字体锁定的高亮匹配规则中移除关键词，可使用函数 <code>font-lock-remove-keywords</code> ，详情参见《Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Search_002dbased-Fontification.html#Search_002dbased-Fontification">基于搜索的着色</a>」章节。此外，你也可通过自定义 <code>font-lock-ignore</code> 选项，选择性禁用部分关键词的高亮效果，详情参见《Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Customizing-Keywords.html#Customizing-Keywords">自定义关键词</a>」章节。
</p>
</div>
</div>
<div id="outline-container-Parser_002dbased-Font-Lock" class="outline-4">
<h4 id="Parser_002dbased-Font-Lock"><span class="section-number-4">16.13.2.</span> 基于解析器的字体锁定</h4>
<div class="outline-text-4" id="text-Parser_002dbased-Font-Lock">
<p>
若你的 Emacs 编译时集成了 tree-sitter 库，便可利用该库对缓冲区文本的解析结果实现文本着色。这一方式通常比上一小节所述的「传统方法」更快、更精准，因为 tree-sitter 库为其所支持的编程语言及其他格式文本，提供了功能完善的专用解析器。基于 tree-sitter 库开发的主模式均命名为 <code>foo-ts-mode</code> 格式，其中的 '<code>-ts-</code>' 后缀即表示该模式启用了此解析库。本小节将介绍基于 tree-sitter 库的字体锁定功能相关用法。
</p>

<p>
对于基于 tree-sitter 的主模式，你可通过自定义变量 <code>treesit-font-lock-level</code> ，控制其字体锁定模式的着色精细程度。该变量的取值为 1 至 4 之间的整数，各等级对应的着色范围如下：
</p>

<dl class="org-dl">
<dt>等级 1</dt><dd>仅对注释，以及函数定义中的函数名进行着色。</dd>
<dt>等级 2</dt><dd>在等级 1 基础上，新增对关键字、字符串和数据类型的着色。</dd>
<dt>等级 3</dt><dd>默认着色等级；在等级 2 基础上，新增对赋值语句、数字等内容的着色。</dd>
<dt>等级 4</dt><dd>最高着色等级；在等级 3 基础上，对所有可着色内容进行标注，包括运算符、分隔符、方括号、其他标点符号、函数调用中的函数名、属性查找表达式、变量等。</dd>
</dl>

<p>
上述各类句法范畴的具体判定标准，由对应主模式及 tree-sitter 为该模式所属语言提供的解析器语法共同决定。但总体而言，这些范畴均遵循该主模式所支持的编程语言或文件格式的通用规范。变量 <code>treesit-font-lock-feature-list</code> 的缓冲区局部值，存储了基于 tree-sitter 的主模式所支持的所有着色特性，其中每个子列表对应一个着色等级，展示该等级所包含的具体着色特性。
</p>

<p>
通过 <code>M-x customize-variable</code> 命令修改 <code>treesit-font-lock-level</code> 的取值后（参见「<a href="#Specific-Customization">自定义特定项</a>」），该设置会立即在当前 Emacs 会话的所有已打开缓冲区中生效，且后续打开的文件也会沿用此设置。
</p>
</div>
</div>
</div>
<div id="outline-container-Highlight-Interactively" class="outline-3">
<h3 id="Highlight-Interactively"><span class="section-number-3">16.14.</span> 交互式高亮（Interactive Highlighting）</h3>
<div class="outline-text-3" id="text-Highlight-Interactively">
<p>
<code>Highlight Changes mode</code> 变更高亮模式是一种次要模式，会为缓冲区中 <b>最近修改过的内容</b> 应用不同的文本外观，实现高亮标记。启用或关闭该模式可执行命令 <code>M-x highlight-changes-mode</code> 。
</p>

<p>
Hi Lock 模式是一款次要模式，可高亮显示缓冲区中与 <b>你指定的正则表达式</b> 相匹配的文本。例如，可通过该模式高亮程序源文件中某个变量的所有引用、某程序大量输出结果中的特定内容，或是一篇文章里的指定名称。启用或关闭 Hi Lock 模式执行命令 <code>M-x hi-lock-mode</code> ；若要为所有缓冲区全局启用该模式，可执行 <code>M-x global-hi-lock-mode</code> ，或在 <code>.emacs</code> 配置文件中添加代码 <code>(global-hi-lock-mode 1)</code> 。
</p>

<p>
Hi Lock 模式的工作逻辑与字体锁定模式类似（参见<a href="#Font-Lock">字体锁定模式</a>相关内容），区别在于前者需由用户显式指定要高亮的正则表达式。可通过以下命令对该模式的高亮规则进行控制（下述以 <code>C-x w</code> 开头的快捷键已被弃用，官方推荐使用全局的 <code>M-s h</code> 系列快捷键，这些旧快捷键将在未来的 Emacs 版本中移除）。
</p>

<dl class="org-dl">
<dt><code>M-s h r 正则表达式 回车 外观 回车</code></dt><dd></dd>

<dt><code>C-x w h regexp RET face RET</code></dt><dd><p>
使用指定的文本外观，高亮所有匹配该正则表达式的文本 (<code>highlight-regexp</code>) 。该高亮效果会在缓冲区存续期间一直保留。例如，要使用默认高亮外观（黄色背景）标记所有 “whim” 单词，可输入 <code>M-s h r whim RET RET</code> 。任意文本外观均可用于高亮，Hi Lock 模式自身提供了多款专属外观，且已预加载至默认外观列表中；在命令提示选择外观时，可通过 <code>M-n</code> 和 <code>M-p</code> 循环切换该列表中的外观。若为该命令添加数字前缀参数，仅会对正则表达式中的对应子表达式匹配内容进行高亮。
</p>

<p>
若将选项 <code>hi-lock-auto-select-face</code> 设为非 nil 值，该命令（及其他所有需要选择外观的 Hi Lock 命令）会自动从默认外观列表中选取下一个外观，无需手动交互选择。
</p>

<p>
该命令可多次执行，为不同正则表达式配置不同的高亮方式。
</p></dd>

<dt><code>M-s h u regexp RET</code></dt><dd></dd>

<dt><code>C-x w r regexp RET</code></dt><dd>取消指定正则表达式对应的高亮效果 (<code>unhighlight-regexp</code>) 。若通过菜单调用该命令，可从列表中选择要取消的正则表达式；若通过键盘调用，需在迷你缓冲区中操作 —— 迷你缓冲区会默认显示最近添加的高亮正则表达式，按 <code>M-n</code> 可切换至更早添加的表达式，按M-p可切换至更新的表达式（也可手动输入表达式，支持补全功能）。当要取消的表达式出现在迷你缓冲区时，按 <code>RET</code> 回车即可退出迷你缓冲区并取消对应高亮。</dd>

<dt><code>M-s h l regexp RET face RET</code></dt><dd></dd>

<dt><code>C-x w l regexp RET face RET</code></dt><dd>使用指定的文本外观， <b>高亮所有包含该正则表达式匹配内容的整行文本</b>  (<code>highlight-lines-matching-regexp</code>) 。</dd>

<dt><code>M-s h p phrase RET face RET</code></dt><dd></dd>

<dt><code>C-x w p 短语 回车 外观 回车</code></dt><dd>使用指定的文本外观，高亮匹配该短语的内容 (<code>highlight-phrase</code>) 。该短语可是任意正则表达式，且命令会自动将短语中的 <b>空格</b> 匹配为任意空白字符，将短语中 <b>首字母小写的字符</b> 设为大小写不敏感匹配。</dd>

<dt><code>M-s h .</code></dt><dd></dd>

<dt><code>C-x w .</code></dt><dd>使用下一个可用的高亮外观，高亮 <b>光标附近的符号</b>  (<code>highlight-symbol-at-point</code>) 。</dd>

<dt><code>M-s h w</code></dt><dd></dd>

<dt><code>C-x w b</code></dt><dd><p>
将当前所有的「高亮正则表达式 / 外观」匹配对，插入到 <b>光标所在的缓冲区位置</b> ，并为其添加注释分隔符，避免该内容干扰程序运行 (<code>hi-lock-write-interactive-patterns</code>) 。
</p>

<p>
若执行 <code>M-x hi-lock-find-patterns</code> ，或在 Hi Lock 模式启用状态下打开某文件（该操作会自动调用 <code>hi-lock-find-patterns</code> ），程序会从文件的注释中 <b>提取合适的高亮匹配</b> 对并生效。
</p></dd>

<dt><code>M-s h f</code></dt><dd></dd>

<dt><code>C-x w i</code></dt><dd><p>
从当前缓冲区的注释中提取「正则表达式 / 外观」匹配对 (<code>hi-lock-find-patterns</code>) 。借助该功能，你可先通过 <code>highlight-regexp</code> 交互式添加高亮匹配对，再通过 <code>hi-lock-write-interactive-patterns</code> 将其保存到文件中，对其进行编辑（例如为正则表达式中不同括号匹配的部分配置不同高亮外观），最后通过该命令让 Hi Lock 模式根据编辑后的匹配实现高亮。
</p>

<p>
变量 <code>hi-lock-file-patterns-policy</code> 用于控制：在打开文件时，Hi Lock 模式是否 <b>自动提取并应用</b> 文件中包含的高亮匹配对。其取值可为： <code>nil</code> （从不自动高亮）、 <code>ask</code> （询问用户，为默认值）、或一个函数。若设为函数， <code>hi-lock-find-patterns</code> 会将提取到的匹配对作为参数调用该函数；若函数返回非 nil 值，则应用这些匹配对。注意，若直接调用 <code>hi-lock-find-patterns</code> ，无论该变量取何值，都会对提取到的匹配对执行高亮。
</p>

<p>
此外，若当前主模式的符号存在于列表 <code>hi-lock-exclude-modes</code> 中，调用 <code>hi-lock-find-patterns</code> 时将 <b>不执行任何操作</b> 。
</p></dd>
</dl>
</div>
</div>
<div id="outline-container-Fringes" class="outline-3">
<h3 id="Fringes"><span class="section-number-3">16.15.</span> 窗口边缘（Window Fringes）</h3>
<div class="outline-text-3" id="text-Fringes">
<p>
在图形化显示界面中，每个 Emacs 窗口的左右两侧默认都会显示窄版的 <b>fringes窗口边缘</b> 区域。该区域用于显示各类符号，以此标注窗口中文本的相关状态信息。你可执行命令 <code>M-x fringe-mode</code> ，切换窗口边缘的显示状态或修改其宽度；该命令会作用于所有框架，若仅需修改当前选中框架的窗口边缘，可使用 <code>M-x set-fringe-style</code> 。通过自定义变量 <code>fringe-mode</code> ，可将你对窗口边缘的设置永久保存。
</p>

<p>
窗口边缘最常用的功能，是标记 <b>continuation line折行文本</b> （参见《<a href="#Continuation-Lines">折行</a>》相关内容）：当一行文本被拆分为多个 screen lines 屏幕行显示时，除首个屏幕行外，其余所有屏幕行对应的左侧边缘会显示弯曲箭头，表明此位置并非文本的实际起始处；除最后一个屏幕行外，其余所有屏幕行对应的右侧边缘也会显示弯曲箭头，表明此位置并非文本的实际结束处。若文本的显示方向为从右到左（参见《<a href="#Bidirectional-Editing">双向编辑</a>》相关内容），窗口边缘中弯曲箭头的含义会相应互换。
</p>

<p>
窗口边缘也会用于标记 <b>line truncation行截断</b> 状态（参见行《<a href="#Line-Truncation">截断</a>》相关内容）：当某行文本因水平滚动而有部分内容超出可视范围时，边缘会显示短水平箭头，箭头方向即为未显示内容的所在方向。用鼠标点击该箭头，窗口会沿箭头方向水平滚动，展示隐藏的文本内容。
</p>

<p>
此外，窗口边缘还可标注其他文本状态，例如缓冲区边界（参见《<a href="#Displaying-Boundaries">显示边界</a>》相关内容）、窗口末尾附近的未使用行（参见 <a href="#Useless-Whitespace">indicate-empty-lines</a> 相关配置），以及正在调试的程序当前的执行位置（参见 <a href="#Debuggers">Emacs 下运行调试器</a>相关内容）。
</p>

<p>
当某行文本的宽度与窗口宽度完全一致，且光标处于该行末尾时，窗口边缘区域也会被用于绘制光标。若要关闭该功能，可将变量 <code>overflow-newline-into-fringe</code> 设为 <code>nil</code> ，此时 Emacs 会对宽度与窗口完全一致的文本行执行折行或截断处理。
</p>

<p>
若你通过自定义 <code>fringe-mode</code> ，隐藏了窗口单侧或双侧的边缘区域，原本显示在边缘处的各类状态标记功能将无法使用。但 <b>折行与行截断的标记</b> 是例外情况：当窗口边缘不可用时，Emacs 会使用每行最左侧和最右侧的字符位，通过特殊 ASCII 字符标记折行与行截断状态（参见<a href="#Continuation-Lines">折行</a>、<a href="#Line-Truncation">行截断</a>相关内容）。这一处理会减少每行可用于显示文本的宽度，因为用于标记折行和截断的字符位会被专门预留，无法再显示普通文本。由于缓冲区中的文本可能包含双向显示内容，即同时存在从左到右和从右到左的段落（参见<a href="#Bidirectional-Editing">双向编辑</a>相关内容），因此即便是仅隐藏单侧的窗口边缘，Emacs 仍会在窗口两侧各预留一个字符位，用于标注折行和截断状态 —— 这是因为在从右到左的段落中，这类标记会显示在窗口的对侧位置。
</p>
</div>
</div>
<div id="outline-container-Displaying-Boundaries" class="outline-3">
<h3 id="Displaying-Boundaries"><span class="section-number-3">16.16.</span> 边界显示（Displaying Boundaries）</h3>
<div class="outline-text-3" id="text-Displaying-Boundaries">
<p>
Emacs 可显示 <b>fill-column填充列</b> 位置的标记（参见<a href="#Fill-Commands">显式填充命令</a>相关内容）。填充列标记是一项实用功能，在编程模式及其派生模式中尤为常用（参见<a href="#Major-Modes">主模式</a>相关内容），用于标记一个特定列的位置，该列对程序源代码的格式化排版具有特殊意义。此功能的生效前提是，缓冲区使用 <b>fixed-pitch font等宽字体</b> —— 即除全角字符外，所有字符在显示时宽度一致；若缓冲区使用 variable-pitch fonts变宽字体，不同行的填充列标记可能出现对不齐的情况。
</p>

<p>
要启用填充列标记的显示功能，可使用次要模式 <code>display-fill-column-indicator-mode</code> 和 <code>global-display-fill-column-indicator-mode</code> ，二者分别用于在当前缓冲区本地启用、在所有缓冲区全局启用该标记。
</p>

<p>
你也可通过设置两个缓冲区局部变量 <code>display-fill-column-indicator</code> 和 <code>display-fill-column-indicator-character</code> ，来启用填充列标记并控制标记所使用的字符。注意，只有当两个变量均设为非 nil 值时，填充列标记才会显示（启用上述次要模式会自动为这两个变量赋值）。
</p>

<p>
可通过以下 2 个缓冲区局部变量和 1 个文本外观，对该模式进行自定义配置：
</p>

<dl class="org-dl">
<dt><code>display-fill-column-indicator-column</code></dt><dd><p>
指定填充列标记的显示列号。该变量可设为正整数（表示具体列号），也可设为特殊值t（表示使用变量 <code>fill-column</code> 的取值作为标记列号）；
</p>

<p>
设为其他任意值则会禁用填充列标记，该变量默认值为 <code>t</code> 。
</p></dd>

<dt><code>display-fill-column-indicator-character</code></dt><dd><p>
指定用于填充列标记的字符。该字符可为任意有效字符，若字体支持，也可使用 Unicode 字符；变量设为 <code>nil</code> 则禁用填充列标记。
</p>

<p>
当通过 <code>display-fill-column-indicator-mode</code> 或 <code>global-display-fill-column-indicator-mode</code> 启用该模式时，若此变量为非 nil 值，将使用该变量指定的字符作为标记；若为 =nil=，Emacs 会默认使用字符U+2502（细竖线绘制符），若该字符无法显示，则回退使用竖线符号 "|"。
</p></dd>

<dt><code>fill-column-indicator</code></dt><dd>指定用于显示填充列标记的文本外观。该外观默认继承 <code>shadow</code> 外观的属性，但不包含背景色；若要修改填充列标记的颜色，仅需设置该外观的前景色即可。</dd>
</dl>

<p>
在图形化显示界面中，Emacs 还可在 <b>窗口边缘</b> 区域标记缓冲区的边界。启用该功能后，缓冲区的首行和末行会在边缘区域显示角度图标，同时可搭配上下箭头图标，标识当前窗口是否可进行滚动操作。
</p>

<p>
缓冲区局部变量 <code>indicate-buffer-boundaries</code> ，用于控制缓冲区边界和窗口滚动状态在边缘区域的显示方式：
</p>

<ul class="org-ul">
<li>若变量值设为 <code>left</code> 或 <code>right</code> ，则角度图标和箭头图标会一同显示在左侧边缘或右侧边缘区域；</li>

<li>若变量值设为 <b>关联列表</b> （参见《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Association-Lists.html#Association-Lists">关联列表</a>相关内容），列表中的每个元素均为 <b>(标记类型。显示位置)</b> 的形式，用于指定单个标记的显示位置。其中，标记类型可为 top（顶部）、bottom（底部）、up（向上）、down（向下），或特殊值 t（为列表中未指定的标记设置默认显示位置）；显示位置可为 left（左侧）、right（右侧），或 nil（不显示该标记）。</li>
</ul>

<p>
例如，设置值为 <code>((top . left) (t . right))</code> ，表示将顶部角度图标显示在左侧边缘，底部角度图标和上下箭头图标均显示在右侧边缘；若仅需在左侧边缘显示角度图标、不显示箭头图标，可将变量值设为 <code>((top . left) (bottom . left))</code> 。
</p>
</div>
</div>
<div id="outline-container-Useless-Whitespace" class="outline-3">
<h3 id="Useless-Whitespace"><span class="section-number-3">16.17.</span> 无用空白字符（Useless Whitespace）</h3>
<div class="outline-text-3" id="text-Useless-Whitespace">
<p>
编辑时很容易在 <b>行尾</b> 无意间留下多余的空格，或在 <b>缓冲区末尾</b> 留下空行。多数情况下，这些尾随空白字符不会产生实际影响，但有时会造成不必要的麻烦。
</p>

<p>
将缓冲区局部变量 <code>show-trailing-whitespace</code> 设为 t，即可让行尾的尾随空白字符变为可见状态，Emacs 会通过 <code>trailing-whitespace</code> 文本外观对其进行标记显示。
</p>

<p>
该功能在 <b>光标位于含空白字符的行尾</b> 时会暂时失效。严格来说，此时的空白字符仍属于尾随空白，但在输入新文本的过程中，对其进行特殊标记会影响视觉体验，而光标所处的位置本身就足以提示用户此处存在空白字符。
</p>

<p>
执行命令 <code>M-x delete-trailing-whitespace</code> 可删除所有尾随空白字符，该命令会清除缓冲区中 <b>每行行尾</b> 的所有多余空格，以及 <b>缓冲区末尾</b> 的所有空行；若要保留缓冲区末尾的空行，可将变量 <code>delete-trailing-lines</code> 设为 <code>nil</code> 。若当前区域处于激活状态，该命令仅会删除该区域内每行行尾的多余空格。
</p>

<p>
在图形化显示界面中，Emacs 可在 <b>左侧窗口边缘</b> 通过小图标标记出窗口末尾的未使用行（参见<a href="#Fringes">窗口边缘</a>相关内容）。该图标会显示在所有不对应缓冲区文本的屏幕行处，因此缓冲区末尾的空行会因 <b>缺少该图标</b> 而变得醒目。启用该功能需将缓冲区局部变量 <code>indicate-empty-lines</code> 设为非 nil 值；若要为所有新建缓冲区启用该功能，可设置该变量的默认值，例如添加配置 <code>(setq-default indicate-empty-lines t)</code> 。
</p>

<p>
<b>空白字符模式</b> 是一款缓冲区局部次要模式，可通过 <b>特殊文本外观标记或特殊符号替代显示</b> 的方式，让缓冲区中的各类空白字符可视化。执行 <code>M-x whitespace-mode</code> 可切换该模式的开启与关闭。需可视化的空白字符类型由列表变量 <code>whitespace-style</code> 决定，执行 <code>M-x whitespace-toggle-options</code> 可在当前缓冲区中单独开启或关闭该列表中的任意配置项。以下是该变量的部分可选配置项（完整列表参见该变量的官方文档）：
</p>

<dl class="org-dl">
<dt><code>face</code></dt><dd>启用所有基于特殊文本外观的空白字符可视化功能。该配置项具有特殊含义：若列表中缺少此项，则除space-mark、tab-mark和newline-mark外，其余所有可视化功能均失效。</dd>
<dt><code>trailing</code></dt><dd>高亮显示行尾的尾随空白字符。</dd>
<dt><code>tabs</code></dt><dd>高亮显示制表符。</dd>
<dt><code>spaces</code></dt><dd>高亮显示普通空格和不换行空格字符。</dd>
<dt><code>lines</code></dt><dd>高亮显示超过 80 列的长行，可通过自定义变量 <code>whitespace-line-column</code> 修改列数限制。</dd>
<dt><code>newline</code></dt><dd>高亮显示换行符。</dd>
<dt><code>missing-newline-at-eof</code></dt><dd>若缓冲区末尾未以换行符结尾，则高亮显示最后一个字符。</dd>
<dt><code>empty</code></dt><dd>高亮显示缓冲区开头和 / 或末尾的空行。</dd>
<dt><code>big-indent</code></dt><dd>高亮显示过深的缩进。默认情况下，连续至少 4 个制表符或 32 个普通空格组成的缩进会被高亮，可通过自定义正则表达式 <code>whitespace-big-indent-regexp</code> 修改该判定规则。</dd>
<dt><code>space-mark</code></dt><dd>使用特殊符号替代显示普通空格和不换行空格。</dd>
<dt><code>tab-mark</code></dt><dd>使用特殊符号替代显示制表符。</dd>
<dt><code>newline-mark</code></dt><dd>使用特殊符号替代显示换行符。</dd>
</dl>

<p>
<b>全局空白字符模式</b> 是一款全局次要模式，可让所有缓冲区中的空白字符实现可视化，执行 <code>M-x global-whitespace-toggle-options</code> 可单独切换该模式下的各项功能。
</p>
</div>
</div>
<div id="outline-container-Selective-Display" class="outline-3">
<h3 id="Selective-Display"><span class="section-number-3">16.18.</span> 选择性显示（Selective Display）</h3>
<div class="outline-text-3" id="text-Selective-Display">
<p>
Emacs 支持隐藏 <b>缩进量超过指定列数</b> 的行，你可利用该功能快速概览程序的部分内容结构。
</p>

<p>
在当前缓冲区中，带数字参数 <code>n</code> 执行快捷键 <code>C-x $</code> (<code>set-selective-display</code>) ，即可让缩进量不少于 n 列的行从屏幕中隐藏。若某条可见行后紧跟一行或多行隐藏行，该行末尾会显示三个点（…），作为隐藏内容的标识。
</p>

<p>
快捷键 <code>C-n</code> 和 <code>C-p</code> 在跳转行时，会直接跳过隐藏的行，如同这些行不存在一般。
</p>

<p>
被隐藏的行仍会保留在缓冲区中，且绝大多数编辑命令会照常识别这些行，因此光标位置可能会出现在隐藏文本的中间。出现这种情况时，光标会显示在 <b>前一可见行的末尾、三个点之后</b> ；若光标位于可见行的末尾（换行符之前），则会显示在 <b>三个点之前</b> 。
</p>

<p>
不带任何参数执行 <code>C-x $</code> ，即可恢复显示所有被隐藏的行。
</p>

<p>
若将变量 <code>selective-display-ellipses</code> 设为 <code>nil</code> ，那么紧跟隐藏行的可见行末尾将 <b>不再显示三个点</b> ，此时缓冲区中无任何视觉标识提示隐藏行的存在。该变量被设置后会自动成为缓冲区局部变量。
</p>

<p>
你也可使用 《<a href="#Outline-Mode">大纲模式</a>》 实现缓冲区文本的部分隐藏，这是另一种文本隐藏的实现方式。
</p>
</div>
</div>
<div id="outline-container-Optional-Mode-Line" class="outline-3">
<h3 id="Optional-Mode-Line"><span class="section-number-3">16.19.</span> 模式行可选功能</h3>
<div class="outline-text-3" id="text-Optional-Mode-Line">
<p>
模式行中的缓冲区百分比 <code>pos</code> 表示窗口顶部之上的内容占整个缓冲区的比例。你可执行命令 <code>M-x size-indication-mode</code> 开启大小指示模式，额外显示缓冲区的字符规模，该数值会紧跟在缓冲区百分比后展示，格式如下：
</p>

<div class="org-src-container">
<pre class="src src-shell">pos of size
</pre>
</div>

<p>
其中 <code>size</code> 是缓冲区字符数的 <b>人性化可读表示</b> ，会使用缩写单位：k代表 10^3、M代表 10^6、G代表 10^9，依此类推。
</p>

<p>
开启行号模式后，光标所在的当前行号会显示在模式行中，可通过命令 <code>M-x line-number-mode</code> 开关该模式（默认处于开启状态）。行号会显示在缓冲区百分比 <code>pos</code> 之后，以字母"<code>L</code>"标识行号属性。
</p>

<p>
同理，执行 <code>M-x column-number-mode</code> 开启列号模式，即可在模式行显示光标当前的列号，列号以字母 '<code>C</code>' 标识。若同时开启行号和列号模式，行号和列号会以 <b>括号包裹</b> 的形式显示（行号在前、列号在后），而不是分别标注 '<code>L</code>'和 '<code>C</code>'，例如显示为：'<code>(561,2)</code>'。有关次要模式的详细介绍及上述命令的使用方法，参见「<a href="#Minor-Modes">次要模式</a>」相关内容。
</p>

<p>
列号模式下，显示的列号以窗口左边界为0 起始位计数；若希望列号从 1 开始计数，可将变量 <code>column-number-indicator-zero-based</code> 设为 <code>nil</code> 。
</p>

<p>
若你对缓冲区进行了窄化操作（参见「<a href="#Narrowing">窄化</a>」相关内容），模式行显示的行号为相对窄化后可访问区域的行号，因此该数值不能作为 <code>goto-line</code> 命令的参数（ <code>what-line</code> 命令可显示相对于整个文件的绝对行号）。你可使用 <code>goto-line-relative</code> 命令，将光标移至窄化后缓冲区可访问区域的指定相对行号位置。
</p>

<p>
若缓冲区体积过大（字符数超过变量 <code>line-number-display-limit</code> 的取值），Emacs 将不会计算行号（因计算过程会大幅卡顿），模式行也不会显示行号；若要取消该限制，将 <code>line-number-display-limit</code> 设为 <code>nil</code> 即可。
</p>

<p>
若缓冲区中的行过长，行号计算也会变慢。因此，当光标附近行的平均字符宽度超过变量 <code>line-number-display-limit-width</code> 的取值时，Emacs 同样不会显示行号，该变量的默认值为 200 个字符。
</p>

<p>
Emacs 支持在所有窗口的模式行中可选显示系统时间和负载，执行命令 <code>M-x display-time</code> 或自定义选项 <code>display-time-mode</code> 即可启用该功能。模式行中新增的相关信息格式如下：
</p>

<div class="org-src-container">
<pre class="src src-shell">hh:mmPM l.ll
</pre>
</div>

<p>
其中 <code>hh</code> 为小时、 <code>mm</code> 为分钟，其后始终跟随 <code>AM</code> （上午）或 <code>PM</code> （下午）； <code>l.ll</code> 为系统最近几分钟的平均负载值，即系统中处于运行或就绪状态（等待可用处理器）的进程数量（若操作系统不支持，部分字段可能不会显示）。若偏好 24 小时制时间显示，将变量 <code>display-time-24hr-format</code> 设为 <code>t</code> 即可。
</p>

<p>
若你存在未读邮件，模式行的系统负载值后会显示单词'<code>Mail</code>'。在图形化显示界面中，可通过自定义变量 <code>display-time-use-mail-icon</code> ，使用图标替代Mail文字，节省模式行的显示空间；也可自定义 <code>display-time-mail-face</code> 文本外观，让邮件提示标识更醒目。你可通过 <code>display-time-mail-file</code> 指定待检查的邮件文件，或设置 <code>display-time-mail-directory</code> 指定收件目录（该目录下所有非空的普通文件均会被视为新收到的邮件）。
</p>

<p>
在笔记本电脑上运行 Emacs 时，执行命令 <code>display-battery-mode</code> 或自定义变量 <code>display-battery-mode</code> ，即可在模式行中 <b>显示电池电量</b> 。变量 <code>battery-mode-line-format</code> 决定了电池电量的显示格式，具体的模式行提示信息因操作系统而异，通常会以百分比形式展示当前电池电量占总电量的比例。变量 <code>battery-update-functions中</code> 的函数会在模式行更新后运行，可基于电池状态触发自定义操作。
</p>

<p>
在图形化显示界面中，模式行默认以 3D 方框样式绘制；若你不喜欢该效果，可通过自定义 <code>mode-line</code> 文本外观，将其 <code>box</code> 属性设为 <code>nil</code> 来关闭 3D 效果，详情参见「<a href="#Face-Customization">自定义文本外观</a>」相关内容。
</p>

<p>
默认情况下，未选中窗口的模式行会使用 <code>mode-line-inactive</code> 外观显示，仅选中窗口的模式行使用 <code>mode-line</code> 外观，该设计可清晰区分当前选中的窗口。当迷你缓冲区被选中时，由于其无模式行，触发迷你缓冲区的原窗口会继续使用 <code>mode-line</code> 外观显示模式行，因此常规的迷你缓冲区操作不会改变任何窗口的模式行显示样式。
</p>

<p>
若要关闭 <code>mode-line-inactive</code> 外观的使用，将变量 <code>mode-line-in-non-selected-windows</code> 设为 <code>nil</code> 即可，此后所有窗口的模式行均会使用 <code>mode-line</code> 外观显示。
</p>

<p>
你可通过自定义变量 <code>eol-mnemonic-unix</code> 、 <code>eol-mnemonic-dos</code> 、 <code>eol-mnemonic-mac</code> 和 <code>eol-mnemonic-undecided</code> ，为每种换行格式设置自定义的字符串，实现模式行中换行格式标识的个性化显示。
</p>
</div>
</div>
<div id="outline-container-Text-Display" class="outline-3">
<h3 id="Text-Display"><span class="section-number-3">16.20.</span> 文本显示方式</h3>
<div class="outline-text-3" id="text-Text-Display">
<p>
绝大多数字符为 <b>printing character可打印字符</b> ：这类字符出现在缓冲区中时，会直接按字面形式显示在屏幕上。可打印字符包括 ASCII 数字、字母、标点符号，以及众多非 ASCII 字符。
</p>

<p>
ASCII 字符集中包含 <b>非打印control characters控制字符</b> ，其中有两个字符会以特殊形式显示：换行符（Unicode 编码点 U+000A）的显示方式为另起一行，制表符（U+0009）则会显示为连续空格，直至下一个制表位（默认每 8 列一个制表位）。每个制表符对应的空格数由缓冲区局部变量 <code>tab-width</code> 控制，该变量的取值必须是 1 到 1000 之间的整数（包含边界值）。注意，缓冲区中制表符的显示方式，与制表键（ <code>TAB</code> ）作为命令的定义无任何关联。
</p>

<p>
其余 ASCII 控制字符（编码小于 U+0020，即八进制 40、十进制 32），会以脱字符 '<code>^</code>' 后跟对应非控制形式字符的样式显示，并应用 <code>escape-glyph</code> 文本外观。例如，'contraol-A' 控制字符 A（U+0001）会显示为'<code>^A</code>'。
</p>

<p>
编码为 U+0080（八进制 200）至 U+009F（八进制 237）的原始字节，会以八进制转义序列的形式显示，同样应用escape-glyph外观。例如，编码 U+0098（八进制 230）会显示为'<code>\230</code>'。若将缓冲区局部变量 <code>ctl-arrow</code> 设为 <code>nil</code> ，所有 ASCII 控制字符都会改为以八进制转义序列显示，而非脱字符转义序列（你也可设置让原始字节以十六进制形式显示，参见变量<a href="#Display-Custom">display-raw-bytes-as-hex</a>）。
</p>

<p>
部分非 ASCII 字符的视觉外观，与 ASCII 空格或连字符（减号）完全相同。若这类字符在你不知情的情况下被插入缓冲区（例如通过粘贴操作），可能会引发问题 —— 比如源代码编译器通常不会将非 ASCII 空格识别为空白字符。为解决该问题，Emacs 会对这类字符做特殊显示处理：U+00A0 不换行空格，以及 Unicode 水平空格类的其他字符，会应用 <code>nobreak-space</code> 外观显示；U+00AD 软连字符、U+2010 连字符、U+2011 非断连字符，会应用 <code>nobreak-hyphen</code> 外观显示。若要关闭该特殊显示功能，将变量 <code>nobreak-char-display</code> 设为 <code>nil</code> 即可。若该变量设为非 nil 且非 t 的取值，Emacs 会将这类字符显示为 <b>高亮反斜杠</b> 后跟普通空格或连字符的形式。
</p>

<p>
你可通过显示表自定义任意特定编码字符的显示方式，详情参见《Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Display-Tables.html#Display-Tables">显示表</a>」章节。
</p>

<p>
在图形化显示界面中，部分字符可能在 Emacs 可用的所有字体中均无对应字形。这类 <b>glyphless characters无字形字符</b> 默认会显示为包含其十六进制编码的方框。同理，在文本终端中，无法通过终端编码显示的字符（参见「<a href="#Terminal-Coding">终端输入输出的编码系统</a>」），默认会显示为问号。你可通过自定义变量 <code>glyphless-char-display-control</code> ，控制无字形字符的显示方式；也可自定义 <code>glyphless-char</code> 文本外观，让这类字符在屏幕上更醒目。具体细节参见《Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Glyphless-Chars.html#Glyphless-Chars">无字形字符的显示</a>」章节。
</p>

<p>
启用 <code>glyphless-display-mode</code> 次要模式，可切换当前缓冲区中无字形字符的显示样式 —— 切换后，无字形字符会显示为方框，内部标注其字符名称的缩写。
</p>

<p>
Emacs 会自动检测当前显示设备是否支持显示弯引号 ( <code>‘</code> 和 <code>’</code> ) 。默认情况下，若检测到设备支持，Emacs 会将消息和帮助文本中的 ASCII 引号 (‘ <code>`</code> ’ 和 ‘ <code>'</code> ’) 自动转换为这类弯引号。你可通过自定义用户选项 <code>text-quoting-style</code> ，调整或禁止该转换行为，详情参见《Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Keys-in-Documentation.html#Keys-in-Documentation">文档中的按键</a>」章节。
</p>

<p>
若检测到弯引号 <code>‘</code> 、 <code>’</code> 、 <code>“</code> 和 <code>”</code> 的显示效果与 ASCII 字符完全一致，这些弯引号会应用 <code>homoglyph</code> 外观显示；若检测到设备不支持显示某类弯引号，该弯引号会替换为对应的 ASCII 近似字符 <code>`</code> 、 <code>'</code> 、 和 <code>"</code> ，并同样应用 <code>homoglyph</code> 外观。
</p>
</div>
</div>
<div id="outline-container-Cursor-Display" class="outline-3">
<h3 id="Cursor-Display"><span class="section-number-3">16.21.</span> 光标显示（Displaying the Cursor）</h3>
<div class="outline-text-3" id="text-Cursor-Display">
<p>
在文本终端中，光标的显示样式由终端本身控制，Emacs 基本无法干预。部分终端提供两种光标样式可选：常规可见的静态光标，以及高亮显示的闪烁光标。Emacs 默认使用高亮 <b>闪烁光标</b> ，并在启动或恢复 Emacs 时自动切换至该样式；若 Emacs 启动或恢复时，变量 <code>visible-cursor</code> 的值为 <code>nil</code> ，则会使用常规静态光标。
</p>

<p>
在图形化显示界面中，文本光标的多项属性均可自定义。若要修改光标颜色，可调整cursor文本外观的: <code>background</code> （背景色）属性（参见<a href="#Face-Customization">自定义文本外观</a>相关内容）。（该外观的其他属性均无实际效果，光标覆盖区域的文本会使用框架的背景色绘制。）若要修改光标形状，可自定义缓冲区局部变量 <code>cursor-type</code> ，其可选值包括：
</p>

<ul class="org-ul">
<li><code>box</code> ：方块光标（默认样式）</li>
<li><code>(box . size)</code> ：方块光标（当遮罩图像的宽或高超过 size 像素时，光标变为空心方块）</li>
<li><code>hollow</code> ：空心方块光标</li>
<li><code>bar</code> ：竖线光标</li>
<li><code>(bar . n)</code> ：宽度为 n 像素的竖线光标</li>
<li><code>hbar</code> ：横线光标</li>
<li><code>(hbar . n)</code> ：高度为 n 像素的横线光标</li>
<li><code>nil</code> ：隐藏光标</li>
</ul>

<p>
默认情况下，若 Emacs 在 10 次光标闪烁期间未接收到任何输入，光标会停止闪烁；任意输入事件都会重置闪烁计数。你可通过自定义变量 <code>blink-cursor-blinks</code> 控制闪烁次数，该变量的取值为无输入时的最大闪烁次数；将其设为 0 或负数，光标会一直闪烁。若要彻底关闭光标闪烁，可将变量 <code>blink-cursor-mode</code> 设为 nil（参见<a href="#Easy-Customization">简易自定义界面</a>），或在初始化文件中添加以下配置行：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(blink-cursor-mode 0)
</pre>
</div>

<p>
此外，你也可通过自定义列表变量 <code>blink-cursor-alist</code> ，修改光标熄灭时的显示样式。该列表的每个元素均为 <code>(on-type . off-type)</code> 的形式，含义为：若光标闪烁亮起时为 <code>on-type</code> 亮灯样式（可为上述任意光标类型），则熄灭时显示为 <code>off-type</code> 熄灯样式。
</p>

<p>
部分字符（如制表符）为 <b>宽字符</b> ，光标默认定位在这类字符上时，仍会以默认字符宽度绘制。若要让光标自动拉伸以覆盖整个宽字符，可将变量 <code>x-stretch-cursor</code> 设为非 nil 值。
</p>

<p>
默认情况下， <b>未选中窗口</b> 中的光标会显示为不闪烁的空心方块（若为竖线光标，则显示为更细的竖线）。若要隐藏未选中窗口中的光标，可将变量 <code>cursor-in-non-selected-windows</code> 设为 <code>nil</code> 。
</p>

<p>
若要让光标辨识度更高，你可启用行高亮模式（HL Line mode）—— 这是一款次要模式，会高亮显示光标所在的整行文本。执行 <code>M-x hl-line-mode</code> 可在当前缓冲区中开关该模式，执行 <code>M-x global-hl-line-mode</code> 可全局开关该模式。
</p>
</div>
</div>
<div id="outline-container-Line-Truncation" class="outline-3">
<h3 id="Line-Truncation"><span class="section-number-3">16.22.</span> 行截断（Line Truncation）</h3>
<div class="outline-text-3" id="text-Line-Truncation">
<p>
作为折行显示的替代方案（参见<a href="#Continuation-Lines">折行</a>相关内容），Emacs 可通过 <b>truncation行截断</b> 方式显示长行。行截断指的是，超出屏幕或窗口宽度的字符会被直接隐藏，不再显示。在图形化显示界面中，窗口边缘会显示一个小直箭头，标记行的左侧或右侧存在截断内容；在文本终端中，会在最右侧或最左侧列显示 ‘$’ 符号作为截断标识。
</p>

<p>
水平滚动会自动触发行截断（参见<a href="#Horizontal-Scrolling">水平滚动</a>相关内容）。你也可通过快捷键 <code>C-x x t</code> (<code>toggle-truncate-lines</code>) ，为特定缓冲区手动启用行截断功能，该命令的实现原理是修改缓冲区局部变量 <code>truncate-lines</code> 的取值：当该变量为非 nil 值时，长行将被截断显示；当该变量为 <code>nil</code> 值时，长行将折行显示为多个屏幕行。无论通过何种方式设置 <code>truncate-lines</code> ，该变量都会自动成为当前缓冲区的局部变量；在未手动设置前，该变量会使用默认值 <code>nil</code> （即折行显示）。
</p>

<p>
由于行截断与自动换行（下一节将介绍）功能互斥，执行 <code>toggle-truncate-lines</code> 命令启用行截断时，会同时禁用自动换行功能。
</p>

<p>
当拆分后的窗口宽度过窄时，Emacs 可能会自动启用行截断。相关控制变量为 <code>truncate-partial-width-windows</code> ，详情参见<a href="#Split-Window">窗口拆分</a>相关内容。
</p>
</div>
</div>
<div id="outline-container-Visual-Line-Mode" class="outline-3">
<h3 id="Visual-Line-Mode"><span class="section-number-3">16.23.</span> 视觉行模式（Visual Line Mode）</h3>
<div class="outline-text-3" id="text-Visual-Line-Mode">
<p>
作为普通折行显示的另一种替代方案（参见<a href="#Continuation-Lines">折行</a>相关内容），Emacs 支持使用 <b>word wrap自动换行</b> 功能。开启该功能后，较长的逻辑行会被拆分为两个或多个screen lines屏幕行（也称作「visual lines视觉行」），这一点与普通折行显示类似；不同的是，Emacs 会尝试 <b>在窗口右边缘附近的单词边界处进行换行</b> （若文本显示方向为从右到左，则在窗口左边缘的单词边界处换行）。这种换行方式不会在单词中间拆分文本，能让内容更易阅读。
</p>

<p>
自动换行功能由视觉行模式开启，该模式是一款可选的次要模式。在当前缓冲区中执行命令 <code>M-x visual-line-mode</code> 即可开启视觉行模式，重复执行该命令则关闭此模式；也可通过菜单栏操作：在「Options选项」菜单中选择「'<code>Line Wrapping in this Buffer</code>'本缓冲区的换行方式」子菜单，再点击「'<code>Word Wrap (Visual Line mode)</code>'自动换行（视觉行模式）」选项。视觉行模式开启后，模式行的模式显示区域会出现字符串wrap作为标识。执行命令 <code>M-x global-visual-line-mode</code> ，可对所有缓冲区全局切换视觉行模式的开启与关闭。
</p>

<p>
由于自动换行与上一节介绍的行截断功能互斥，开启视觉行模式的同时会自动禁用行截断功能。
</p>

<p>
在视觉行模式下，部分编辑命令的操作对象会从 <b>logical lines逻辑行</b> 变为 <b>screen lines视觉行</b> ：
</p>
<ul class="org-ul">
<li><code>C-a</code> (<code>beginning-of-visual-line</code>)：将光标移至当前视觉行的行首</li>
<li><code>C-e</code> (<code>end-of-visual-line</code>)：将光标移至当前视觉行的行尾</li>
<li><code>C-k</code> (<code>kill-visual-line</code>)：删除光标至当前视觉行尾的文本</li>
</ul>

<p>
若要按 <b>逻辑行</b> 进行光标移动，可使用命令 <code>M-x next-logical-line</code> 和 <code>M-x previous-logical-line</code> ，二者分别将光标移至下一个和上一个逻辑行，且操作效果不受视觉行模式开启状态的影响。若你频繁使用这两个命令，可为其绑定快捷键，具体方法参见「<a href="#Init-Rebinding">在初始化文件中重新绑定按键</a>」相关内容。
</p>

<p>
默认情况下，自动换行产生的视觉行 <b>不会在窗口边缘显示标识</b> 。视觉行模式常被用于编辑包含大量长逻辑行的文件，若为每个折行的视觉行都添加边缘标识，会造成视觉干扰；你可通过自定义变量 <code>visual-line-fringe-indicators</code> ，修改这一默认设置。
</p>

<p>
Emacs 默认仅在空格、制表符这类空白字符后进行换行，不会在「全角空格」等空白字符后折行。Emacs 提供了 <code>word-wrap-whitespace-mode</code> 次要模式，开启后可在当前模式下启用自定义规则的自动换行，并通过用户选项 <code>word-wrap-whitespace-characters</code> 设置允许触发换行的字符；该模式也提供全局版本 <code>global-word-wrap-whitespace-mode</code> ，可对所有缓冲区生效。
</p>

<p>
当文本中混合了中日韩（CJK）字符与拉丁字符时，仅在空白字符后换行会导致排版效果异常（原因是中日韩字符无需通过空白字符分隔单词）。此时可自定义选项 <code>word-wrap-by-category</code> ，让 Emacs 允许在所有属于 '<code>|</code>' 字符类的字符后换行（参见《Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Categories.html#Categories">字符类</a>」章节），该设置能更好地支持中日韩字符的排版。此外，若通过 Emacs 的自定义界面设置该变量，程序会自动加载 <code>kinsoku.el</code> 文件；该文件加载后，Emacs 会 <b>遵循禁则排版规则</b> 进行换行，即属于 '<code>&gt;</code>' 字符类的字符（如 U+FF0C 全角逗号）不会出现在行首，属于 '<code>&lt;</code>' 字符类的字符（如 U+300A 左双角括号）不会出现在行尾。
</p>

<p>
你可通过命令 <code>char-category-set</code> 和 <code>category-set-mnemonics</code> 查看某个字符所属的字符类；也可将光标移至目标字符处，执行 <code>C-u C-x =</code> ，在弹出的信息报告中查看「category（字符类）」部分的内容。若要为字符添加字符类属性，可使用命令 <code>modify-category-entry</code> 。
</p>
</div>
</div>
<div id="outline-container-Display-Custom" class="outline-3">
<h3 id="Display-Custom"><span class="section-number-3">16.24.</span> 显示定制（Customization of Display）</h3>
<div class="outline-text-3" id="text-Display-Custom">
<p>
本节介绍用于控制 Emacs 界面各类外观细节的变量，初级用户可跳过本节内容。
</p>

<p>
若希望 Emacs 为缓冲区中的每一行显示行号，可自定义缓冲区局部变量 <code>display-line-numbers</code> （该变量默认值为 <code>nil</code> ）。其支持多种取值，对应不同的行号显示模式：
</p>

<dl class="org-dl">
<dt><code>t</code></dt><dd>在每一行显示缓冲区文本的 <b>non-continuation screen line非折行屏幕行</b> 前，显示 <b>绝对行号</b> 。若为折行屏幕行，或整行屏幕行仅显示展示字符串 / 覆盖字符串，则不会为该行编号。</dd>
<dt><code>relative</code></dt><dd>在显示缓冲区文本的非折行屏幕行前，显示 <b>相对行号</b> 。行号以光标所在行为基准，距离当前行越远，行号数值向上下两侧依次递增。</dd>
<dt><code>visual</code></dt><dd>让 Emacs 按 <b>视觉效果统计行号</b> —— 仅对实际显示在界面上的行计数（忽略文本隐藏部分的所有行），折行后占用多个屏幕行的逻辑行，会为每个屏幕行依次编号。显示的行号为相对行号，规则与上述 <code>relative</code> 取值一致。该模式适用于大纲模式等支持文本折叠的模式（参见大纲模式），也适合需要按屏幕行精确移动光标的场景。</dd>
<dt><code>其他值</code></dt><dd>任何非 nil 的其他取值，均按 <code>t</code> 模式处理。</dd>
</dl>

<p>
执行命令 <code>M-x display-line-numbers-mode</code> ，可便捷开启行号显示功能，该模式也提供全局版本 <code>global-display-line-numbers-mode</code> 。用户选项 <code>display-line-numbers-type</code> 用于指定上述两个模式启用时，采用的具体行号显示子模式。
</p>

<p>
注意，即便全局开启 <code>display-line-numbers-mode</code> ， <b>迷你缓冲区和工具提示</b> 区域也不会显示行号。
</p>

<p>
当 Emacs 显示相对行号时，可自定义光标所在行的行号显示规则。默认情况下，即便其他行均为相对行号，光标所在行仍会显示 <b>绝对行号</b> 。若将变量 <code>display-line-numbers-current-absolute</code> 设为 <code>nil</code> ，光标所在行的显示行号会变为0。若你无需关注当前行的绝对行号，且希望为大缓冲区的文本预留更多水平显示空间，该设置会非常实用。
</p>

<p>
在经过窄化的缓冲区中（参见<a href="#Narrowing">窄化</a>），行号默认从窄化区域的起始位置开始计数。若将变量 <code>display-line-numbers-widen</code> 设为非 nil 值，行号会忽略所有窄化操作，从缓冲区的第一个字符开始计数。
</p>

<p>
若变量 <code>display-line-numbers-offset</code> 的取值非 0，该数值会被叠加到每个绝对行号上，且行号始终从缓冲区起始位置开始计数（效果等同于 <code>display-line-numbers-widen</code> 设为非 nil）。若该变量设为 0，或行号非绝对行号模式，则此变量不产生任何效果。
</p>

<p>
在选择性显示模式（参见<a href="#Selective-Display">选择性显示</a>）及其他会隐藏大量行的模式中（如大纲模式、Org 模式），你可自定义变量 <code>display-line-numbers-width-start</code> 和 <code>display-line-numbers-grow-only</code> ，或将 <code>display-line-numbers-width</code> 设为足够大的数值，避免行号预留显示区域出现偶尔的计算错误。
</p>

<p>
行号会通过专用的 <code>line-number</code> 文本外观显示，光标所在行的行号则使用 <code>line-number-current-line</code> 外观显示，你可通过该设置让当前行号呈现独特样式，便于快速定位光标所在行。此外，还可使用 <code>line-number-major-tick</code> 和 <code>line-number-minor-tick</code> 外观，高亮显示行号为特定数字倍数的行，分别自定义变量 <code>display-line-numbers-major-tick</code> 和 <code>display-line-numbers-minor-tick</code> 即可设置对应的倍数。
</p>

<p>
若将变量 <code>visible-bell</code> 设为非 nil 值，当 Emacs 原本需要发出提示音时，会改为让整个屏幕闪烁。若你的终端不支持屏幕闪烁功能，该变量将无效。
</p>

<p>
变量 <code>echo-keystrokes</code> 用于控制多字符按键的回显功能，其取值为触发回显所需的暂停秒数；若设为 0，则表示完全禁用回显。该取值仅在存在可回显内容时生效（参见<a href="#Echo-Area">回显区</a>）。
</p>

<p>
若变量 <code>echo-keystrokes-help</code> 设为非 nil 值（默认值），根据  <code>echo-keystrokes</code> 规则回显的多字符按键序列，会附带一段简短的帮助文本 —— 按下对应按键可调用 <code>describe-prefix-bindings</code> 命令（参见<a href="#Misc-Help">其他帮助命令</a>），查看已输入前缀对应的所有命令列表。相关的帮助功能可参见  <a href="#Key-Help">which-key</a>。
</p>

<p>
在图形化显示界面中，当 Emacs 处于忙碌状态时，鼠标指针会变为沙漏样式。若要禁用该功能，将变量 <code>display-hourglass</code> 设为 <code>nil</code> 即可。变量 <code>hourglass-delay</code> 用于设置 Emacs 忙碌多久后显示沙漏指针，单位为秒，默认值为 1。
</p>

<p>
当鼠标指针位于 Emacs 框架内时，每次输入字符插入文本时，Emacs 会将鼠标指针隐藏，避免其遮挡文本（准确来说，仅在输入自插入字符时会隐藏指针，参见<a href="#Inserting-Text">插入文本</a>）。移动鼠标指针后，其会重新显示。若要禁用该功能，将变量 <code>make-pointer-invisible</code> 设为 <code>nil</code> 即可。
</p>

<p>
在图形化显示界面中，变量 <code>underline-minimum-offset</code> 用于设置带下划线文本的基线与下划线之间的最小距离，单位为像素，默认值为 1。增大该数值，可提升部分字体下带下划线文本的可读性（但 Emacs 绝不会将下划线绘制到当前行区域之外）。变量 <code>x-underline-at-descent-line</code> 用于控制下划线的绘制位置，默认值为 <code>nil</code> ，表示在字体的基线位置绘制；若设为 <code>t</code> ，则在字体的下沿线位置绘制。（若为带下划线的文本设置了非默认的行间距，参见《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Line-Height.html#Line-Height">行高</a>章节，Emacs 会将下划线绘制到额外行间距的下方。）
</p>

<p>
变量 <code>overline-margin</code> 用于设置文本上方上划线的垂直位置（包含上划线自身的高度），单位为像素，默认值为 2。
</p>

<p>
在部分文本终端中，粗体与反显模式同时使用时，会导致文本难以辨认。调用函数 <code>tty-suppress-bold-inverse-default-colors</code> 并传入非 nil 参数，可在该场景下屏蔽粗体的显示效果。
</p>

<p>
原始字节默认以八进制格式显示，例如十进制值为 128 的字节会显示为 <code>\200</code> 。若要改为十六进制格式显示（如 <code>\x80</code> ），将变量 <code>display-raw-bytes-as-hex</code> 设为 <code>t</code> 即可。从包含 Emacs 会话的终端复制文本，或终端的 <code>escape-glyph</code> 外观与默认外观一致时，解析原始字节需格外注意。例如，Emacs 默认会将十进制值 128 的字节，显示为与字符 <code>\</code> 、 <code>2</code> 、 <code>0</code>  、 <code>0</code> 完全相同的样式；十六进制显示的问题会更严重 —— 原始字节 128 后跟字符 <code>7</code> 会显示为 <code>\x807</code> ，而 Emacs Lisp 会将其解析为单个字符 U+0807 撒玛利亚字母 IT；对应的八进制显示 <code>\2007</code> 则不会出现该混淆问题，因为八进制转义序列最多包含三位数字。
</p>
</div>
</div>
</section>
<section id="outline-container-Search" class="outline-2">
<h2 id="Search"><span class="section-number-2">17.</span> 搜索与替换</h2>
<div class="outline-text-2" id="text-Search">
<p>
与其他编辑器相同，Emacs 提供了字符串查找命令，也支持将指定字符串替换为其他字符串；同时还提供了同类功能的命令，可基于匹配模式而非固定字符串进行查找和替换。
你也可通过 <code>xref</code> 工具在多个文件中执行搜索替换操作（参见《<a href="#Identifier-Search">通过标识符进行搜索与替换</a>》），或使用 Dired 中的 <code>A</code> 命令（参见《<a href="#Operating-on-Files">文件操作</a>》），亦可调用 <code>grep</code> 程序完成该操作（参见《<a href="#Grep-Searching">在 Emacs 中使用 Grep 搜索</a>》）。
</p>

<ul class="org-ul">
<li><a href="#Incremental-Search">增量搜索（Incremental Search）</a></li>
<li><a href="#Nonincremental-Search">非增量搜索（Nonincremental Search）</a></li>
<li><a href="#Word-Search">单词搜索（Word Search）</a></li>
<li><a href="#Symbol-Search">符号搜索（Symbol Search）</a></li>
<li><a href="#Regexp-Search">正则表达式搜索（Regular Expression Search）</a></li>
<li><a href="#Regexps">正则表达式语法</a></li>
<li><a href="#Regexp-Backslash">正则表达式中的反斜杠</a></li>
<li><a href="#Regexp-Example">正则表达式示例</a></li>
<li><a href="#Lax-Search">搜索中的宽松匹配（Lax Matching During Searching）</a></li>
<li><a href="#Query-Replace">查询替换（Query Replace）</a></li>
<li><a href="#Other-Repeating-Search">其他搜索与循环命令</a></li>
<li><a href="#Search-Customizations">根据需求定制搜索</a></li>
</ul>
</div>
<div id="outline-container-Incremental-Search" class="outline-3">
<h3 id="Incremental-Search"><span class="section-number-3">17.1.</span> 增量搜索（Incremental Search）</h3>
<div class="outline-text-3" id="text-Incremental-Search">
<p>
Emacs 中的核心搜索命令为 <code>incremental增量搜索</code> ：键入搜索字符串的第一个字符后，搜索即刻开始。在输入搜索字符串的过程中，Emacs 会实时展示当前已键入内容的匹配位置。当键入的字符足以定位到目标位置时，即可停止输入。根据后续的操作需求，你可选择是否通过回车键显式终止本次搜索。
</p>
<dl class="org-dl">
<dt><code>C-s</code></dt><dd>正向增量搜索 (<code>isearch-forward</code>) 。</dd>
<dt><code>C-r</code></dt><dd>反向增量搜索 (<code>isearch-backward</code>) 。</dd>
</dl>

<p>
你也可通过菜单栏的 '<code>Edit-&gt;Search</code>' 菜单调用增量搜索功能。
</p>

<ul class="org-ul">
<li><a href="#Basic-Isearch">增量搜索基础</a></li>
<li><a href="#Repeat-Isearch">重复增量搜索</a></li>
<li><a href="#Isearch-Yank">增量搜索中的粘贴（Isearch Yanking）</a></li>
<li><a href="#Error-in-Isearch">增量搜索错误处理</a></li>
<li><a href="#Special-Isearch">增量搜索的特殊输入</a></li>
<li><a href="#Not-Exiting-Isearch">不退出增量搜索</a></li>
<li><a href="#Isearch-Minibuffer">迷你缓冲区搜索</a></li>
</ul>
</div>
<div id="outline-container-Basic-Isearch" class="outline-4">
<h4 id="Basic-Isearch"><span class="section-number-4">17.1.1.</span> 增量搜索基础</h4>
<div class="outline-text-4" id="text-Basic-Isearch">
<dl class="org-dl">
<dt><code>C-s</code></dt><dd>启动正向增量搜索 (<code>isearch-forward</code>) 。</dd>
<dt><code>C-r</code></dt><dd>启动反向增量搜索 (<code>isearch-backward</code>) 。</dd>
</dl>

<p>
按下 <code>C-s</code> (<code>isearch-forward</code>) 会开启正向增量搜索，该命令会读取键盘输入的字符，并将光标移至缓冲区中 <b>下一个</b> 匹配字符组合的末尾位置。
</p>

<p>
例如，按下 <code>C-s</code> 后再键入字母 <code>F</code> ，光标会跳至起始位置之后缓冲区中第一个 F 的后方；若接着键入字母 O，光标会移至第一个 FO 的后方，该 FO 中的 F 未必是此前找到的第一个 F；再键入一个 O，光标则会移至第一个 FOO 的后方。
</p>

<p>
搜索过程的每一步，Emacs 都会使用 <code>isearch</code> 文本外观，高亮显示当前匹配内容 —— 即缓冲区中与搜索字符串相匹配的文本（参见<a href="#Faces">文本外观</a>）。有关自定义该高亮效果的各类选项，可参见<a href="#Search-Customizations">根据需求自定义搜索行为</a>章节。当前的搜索字符串也会同时显示在回显区中。
</p>

<p>
若输入搜索字符串时出现错误，按下 <code>DEL</code> (<code>isearch-delete-char</code>) 即可撤销，每按一次  <code>DEL</code> 键，都会取消搜索过程中最后输入的一个内容项。当你键入的命令导致 <b>搜索字符串、光标位置、搜索结果的成败状态、搜索方向、当前搜索结果的另一端位置或搜索的循环匹配状态</b> 发生变化时，Emacs 都会记录一个新的 <code>input item</code> 输入内容项。有关处理搜索失败的更多方法，可参见<a href="#Error-in-Isearch">增量搜索中的错误处理</a>章节。
</p>

<p>
当光标定位到目标位置后，按下回车键 <code>RET</code> (<code>isearch-exit</code>) 即可结束搜索，光标将停留在搜索定位的位置。此外， <b>所有在搜索中无特殊含义的命令</b> ，都会先终止搜索，再执行该命令本身。例如，按下 <code>C-a</code> 会先退出搜索，再将光标移至行首；按下方向键会先退出搜索，再执行对应的光标移动操作，依此类推。仅当你接下来要输入的是可打印字符、 <code>DEL</code> 键、 <code>RET</code> 回车键，或搜索中的其他特殊字符（ <code>C-q</code> 、 <code>C-w</code> 、 <code>C-r</code> 、 <code>C-s</code> 、 <code>C-y</code> 、 <code>M-y</code> 、 <code>M-r</code> 、 <code>M-c</code> 、 <code>M-e</code> ，以及下文将介绍的部分字符）时，才需要先按 <code>RET</code> 回车键退出搜索。你也可自定义退出搜索的相关命令，具体参见<a href="#Not-Exiting-Isearch">不退出增量搜索的操作</a>章节。
</p>

<p>
有一个特殊情况：若 <b>搜索字符串为空</b> 时按下 <code>RET</code> 回车键，会直接启动 <b>非增量搜索</b> （参见<a href="#Nonincremental-Search">非增量搜索</a>章节）。（该行为可自定义，参见<a href="#Search-Customizations">根据需求自定义搜索行为</a>章节。）
</p>

<p>
若要放弃搜索并返回搜索起始位置，按下 <code>ESC ESC ESC</code> (<code>isearch-cancel</code>) 或 <code>C-g C-g</code> (<code>isearch-abort</code>) 即可。
</p>

<p>
退出增量搜索时，Emacs 会将光标的原始位置添加到 <b>标记环</b> 中，且不会激活标记；你可通过按下 <code>C-u C-SPC</code> 或 <code>C-x C-x</code> ，回到启动搜索前的光标位置（参见<a href="#Mark-Ring">标记环</a>章节）。注意，该功能仅在 <b>标记未被激活</b> 时生效；若启动搜索时标记已处于激活状态，按下 <code>C-u C-SPC</code> 或 <code>C-x C-x</code> 都会直接跳至标记位置。
</p>

<p>
若要进行反向搜索，可按下 <code>C-r</code> (<code>isearch-backward</code>) 而非 <code>C-s</code> 来启动搜索。反向搜索会查找 <b>起始位置之前</b> 结束的匹配内容，这与正向搜索查找起始位置之后开始的匹配内容的规则相对应。
</p>
</div>
</div>
<div id="outline-container-Repeat-Isearch" class="outline-4">
<h4 id="Repeat-Isearch"><span class="section-number-4">17.1.2.</span> 重复增量搜索</h4>
<div class="outline-text-4" id="text-Repeat-Isearch">
<p>
若你正向搜索 “FOO” 并找到匹配项，却并非目标结果 —— 你要找的 “FOO” 出现在缓冲区更靠后的位置，此时可再次按下 <code>C-s</code> (isearch-repeat-forward)跳至该搜索字符串的下一个匹配项，或按下 <code>C-r</code> (<code>isearch-repeat-backward</code>) 跳至上一个匹配项，这些命令可重复执行任意次数。你也可为 <code>C-s</code> 和 <code>C-r</code> 添加数字前缀参数 <code>n</code> ，直接定位到第 <code>n</code> 个下一个或上一个匹配项。若跳转过度，可按下 <code>DEL</code> 键撤销部分 <code>C-s</code> 的执行结果。同理，在反向增量搜索中，每次按下 <code>C-r</code> (<code>isearch-repeat-backward</code>) 都会重复执行反向搜索。
</p>

<p>
在增量搜索过程中稍作停顿，Emacs 会高亮显示屏幕上该搜索字符串的 <b>所有其他潜在匹配项</b> ，帮你预判按下 <code>C-s</code> 或 <code>C-r</code> 重复搜索时可跳转的位置。这些其他匹配项会采用与当前匹配项不同的样式高亮，使用可自定义的 <code>lazy-highlight</code> 文本外观（参见<a href="#Faces">文本外观</a>）。若你不需要该功能，可将变量 <code>isearch-lazy-highlight</code> 设为 <code>nil</code> 来禁用。有关匹配项高亮的其他自定义设置，参见<a href="#Search-Customizations">根据需求自定义搜索行为</a>章节。
</p>

<p>
退出某次搜索后，只需连续按下 <code>C-s C-s</code> ，即可再次搜索相同的字符串。第一个 <code>C-s</code> 用于调用增量搜索功能，第二个 <code>C-s</code> 表示再次搜索上一次的搜索字符串。同理，连续按下 <code>C-r C-r</code> 会反向搜索上一次的搜索字符串。判定上一次的搜索字符串时，无论该字符串此前是通过 <code>C-s</code> 还是 <code>C-r</code> 搜索的，均无影响。
</p>

<p>
若你正在执行正向搜索，却发现目标内容出现在搜索起始位置之前，可按下 <code>C-r</code> 切换为反向搜索，且搜索字符串保持不变。同理，在反向搜索中按下 <code>C-s</code> ，即可切换为正向搜索。
</p>

<p>
默认情况下，当你切换搜索方向时，首次键入的方向切换命令会让光标停留在原匹配项上，仅移动至该匹配项的另一端。若希望切换方向后直接跳至其他匹配项，可将变量 <code>isearch-repeat-on-direction-change</code> 设为 <code>t</code> 。
</p>

<p>
若搜索已无匹配结果，你仍按下 <code>C-s</code> 尝试重复搜索，搜索会从 <b>缓冲区起始位置</b> 重新开始；若反向搜索已无匹配结果，按下 <code>C-r</code> 重复搜索，会从 <b>缓冲区末尾位置</b> 重新开始。这种行为被称为 <b>wrapping around循环匹配</b> ，发生后搜索提示中会显示 “Wrapped”（已循环）。若你继续搜索并越过最初的搜索起始位置，提示会变为 “Overwrapped”（过度循环），表示你正在重新访问已经查看过的匹配项。
</p>

<p>
你可通过自定义用户选项 <code>isearch-wrap-pause</code> ，控制搜索无更多匹配项时的行为：
</p>

<ul class="org-ul">
<li>设为 t（默认值）：触发错误提示（再次重复搜索会执行循环匹配）；</li>
<li>设为 no：发出提示音，且在定位到最后一个匹配项后立即执行循环匹配；</li>
<li>设为 no-ding：不发出提示音，直接执行循环匹配；
当取值为 no 或 no-ding 时，键入字符时搜索也会尝试执行循环匹配；</li>
<li>设为 nil：永不执行循环匹配，仅在最后一个匹配项处停止搜索。</li>
</ul>

<p>
若要复用此前的搜索字符串，可使用 <b>search ring搜索环</b> 功能。按下 <code>M-p</code> (<code>isearch-ring-retreat</code>)和 <code>M-n</code> (<code>isearch-ring-advance</code>)（下翻搜索环）可遍历搜索环，选择要复用的搜索字符串。这两个命令会将选中的搜索环项显示在迷你缓冲区中，你可对其进行编辑，按下 <code>C-s</code> / <code>C-r</code> 或 <code>RET</code> 回车键即可确认该字符串并开始搜索。搜索环中可保存的最近使用的搜索字符串数量，由变量 <code>search-ring-max</code> 指定，默认值为 16。
</p>

<p>
若你希望在迷你缓冲区中编辑当前搜索字符串，且 <b>不使用搜索环中的项替换</b> 它，可按下 <code>M-e</code> (<code>isearch-edit-string</code>) ，或在迷你缓冲区中单击鼠标左键。编辑完成后，按下 <code>RET</code> 回车键、 <code>C-s</code> 或 <code>C-r</code> ，即可结束编辑并开始搜索该字符串；按下 <code>C-f</code> 或右方向键，可将搜索起始缓冲区中光标后方的字符添加至当前搜索字符串中。
</p>
</div>
</div>
<div id="outline-container-Isearch-Yank" class="outline-4">
<h4 id="Isearch-Yank"><span class="section-number-4">17.1.3.</span> 增量搜索中的粘贴（Isearch Yanking）</h4>
<div class="outline-text-4" id="text-Isearch-Yank">
<p>
多数情况下，你会希望将光标所在位置或其附近的文本作为搜索字符串，本节介绍的命令可让你便捷地实现这一操作。
</p>

<p>
<code>C-w</code> (<code>isearch-yank-word-or-char</code>) 会将光标处的下一个字符或单词追加至搜索字符串中，这是查找光标处文本其他匹配项的简便方法（程序会通过启发式规则判断撷取单个字符还是整词）。带数字前缀参数 <code>n</code> 执行该命令，会追加后续 <code>n</code> 个字符或 <code>n</code> 个单词。
</p>

<p>
<code>C-M-w</code> (<code>isearch-yank-symbol-or-char</code>) 会将光标处的下一个字符或符号追加至搜索字符串中，适用于快速查找光标处符号的其他匹配项（程序会通过启发式规则判断撷取单个字符还是整符号）。带数字前缀参数 n 执行该命令，会追加后续 n 个字符或 n 个符号。
</p>

<p>
<code>M-s C-e</code> (<code>isearch-yank-line</code>) 会将当前行光标后的剩余内容追加至搜索字符串中；若光标已位于行尾，则追加下一行内容。带数字前缀参数 <code>n</code> 执行该命令，会追加后续 <code>n</code> 行内容。
</p>

<p>
类似地， <code>C-M-z</code> (<code>isearch-yank-until-char</code>) 会将从光标位置开始，到指定字符下一次出现位置前的所有内容追加至搜索字符串（不包含该指定字符）。该命令在键盘宏中尤为实用，例如在编程语言或标记语言中，可通过指定字符定位语法单元的边界。带数字前缀参数 <code>n</code> 执行该命令，会追加从光标位置到指定字符第 <code>n</code> 次出现位置前的所有内容。
</p>

<p>
在增量搜索过程中， <code>C-y</code> (<code>isearch-yank-kill</code>) 会将当前剪切板中的内容追加至搜索字符串。若在增量搜索中按下 <code>C-y</code> 后再执行 <code>M-y</code> (<code>isearch-yank-pop</code>) ，会用更早的剪切内容替换此前追加的文本，其作用与常规的 <code>M-y</code> (<code>yank-pop</code>) 命令一致。在回显区 <code>mouse-2</code> 单击鼠标右键，会将当前的 X 窗口选择文本追加至搜索字符串 (<code>isearch-yank-x-selection</code>) ，参见<a href="#Primary-Selection">与其他窗口程序的剪切粘贴</a> 。
</p>

<p>
<code>C-M-d</code> (<code>isearch-del-char</code>) 会删除搜索字符串的最后一个字符， <code>C-M-y</code> (<code>isearch-yank-char</code>) 会将光标后的单个字符追加至搜索字符串。也可通过其他方式添加光标后的字符：按下 <code>M-e</code> 进入迷你缓冲区（参见<a href="#Repeat-Isearch">重复执行增量搜索</a>），在迷你缓冲区的搜索字符串末尾按下 <code>C-f</code> 或 <code>RIGHT</code> 右方向键，每按一次都会将光标后的下一个字符追加至搜索字符串。
</p>

<p>
默认情况下，若搜索为不区分大小写模式，撷取并追加至搜索字符串的文本会被转换为小写，以保持搜索的大小写无关性（参见<a href="#Lax-Search">大小写折叠</a>）。但如果变量 <code>search-upper-case</code> （参见 <a href="#Lax-Search">search-upper-case</a>）的取值并非 <code>not-yanks</code> ，该小写转换行为会被禁用。
</p>

<p>
若要将光标附近的文本拉取为初始搜索字符串，启动新的增量搜索，可按下 <code>M-s M-.</code> ，该快捷键执行 <code>isearch-forward-thing-at-point</code> 命令。若区域处于激活状态，命令会将区域内的文本撷取为搜索字符串；若区域未激活，程序会尝试撷取光标附近的网址、符号或表达式。具体撷取的内容类型由用户选项 <code>isearch-forward-thing-at-point</code> 定义。
</p>
</div>
</div>
<div id="outline-container-Error-in-Isearch" class="outline-4">
<h4 id="Error-in-Isearch"><span class="section-number-4">17.1.4.</span> 增量搜索错误处理</h4>
<div class="outline-text-4" id="text-Error-in-Isearch">
<p>
若输入的搜索字符串完全无匹配结果，回显区会显示 “搜索失败（Failing I-Search）”，同时光标会移至 Emacs 能匹配到该字符串最长前缀的位置后方。例如，若你搜索 “FOOT” 但缓冲区中无该内容，光标可能会停在 “FOOL” 里的 “FOO” 后方。回显区中，搜索字符串里无匹配结果的部分，会使用 <code>isearch-fail</code> 文本外观高亮显示。
</p>

<p>
此时你可执行多种操作：若输入的搜索字符串存在拼写错误，可按 <code>DEL</code> 键撤销上一个输入项（参见<a href="#Basic-Isearch">增量搜索基础操作</a>），按 <code>C-M-d</code> 键逐个删除字符，或按 <code>M-e</code> 键编辑搜索字符串；若你希望停留在当前匹配到的位置，按 <code>RET</code> 回车键即可；也可按 <code>C-g</code> 键，该操作会从搜索字符串中移除无匹配结果的字符（如 “FOOT” 中的 “T”），仅保留能匹配到的部分（如 “FOOT” 中的 “FOO”）。若此时再次按下 <code>C-g</code> 键，则会彻底取消本次搜索，将光标恢复至搜索启动时的位置。
</p>

<p>
退出命令 <code>C-g</code> 在搜索过程中会执行特殊操作，具体行为取决于当前的搜索状态：若搜索已匹配到指定内容并处于等待输入状态，按 <code>C-g</code> 键会直接彻底取消搜索，将光标移回搜索启动的初始位置；若按下 <code>C-g</code> 键时，搜索字符串中仍有未匹配到的字符 —— 无论 Emacs 仍在尝试搜索该部分，还是已确认搜索失败 —— 这些未匹配的字符都会从搜索字符串中被移除。移除后搜索会恢复为成功状态并等待后续输入，因此再次按下 <code>C-g</code> 键，才会彻底取消本次搜索。
</p>
</div>
</div>
<div id="outline-container-Special-Isearch" class="outline-4">
<h4 id="Special-Isearch"><span class="section-number-4">17.1.5.</span> 增量搜索的特殊输入</h4>
<div class="outline-text-4" id="text-Special-Isearch">
<p>
除前文介绍的字符外，在增量搜索过程中键入部分其他字符会触发特殊功能，本节将对其逐一说明。
</p>

<p>
按下 <code>M-s SPC</code> ，可切换宽松空格匹配的开启 / 关闭状态（参见<a href="#Lax-Search">宽松空格匹配</a>）。
</p>

<p>
按下 <code>M-c</code> 或 <code>M-s c</code> ，可切换搜索的大小写敏感状态（参见<a href="#Lax-Search">大小写折叠</a>）。若搜索字符串中包含大写字母，搜索默认会开启大小写敏感模式。
</p>

<p>
按下 <code>M-s '</code> ，可切换搜索是否将相似且等效的字符判定为匹配项（参见<a href="#Lax-Search">字符折叠</a>）。若搜索字符串中包含带重音的字符，本次搜索会自动禁用字符折叠功能。
</p>

<p>
按下 <code>M-s i</code> (<code>isearch-toggle-invisible</code>) ，可切换搜索是否查找由覆盖属性隐藏的文本（参见<a href="#Outline-Visibility">大纲模式中的搜索</a>）。若希望所有增量搜索都能查找因文本属性或覆盖属性而隐藏的文本中的匹配项，可将变量 <code>search-invisible</code> 自定义为 <code>t</code> 。
</p>

<p>
按下 <code>M-r</code> 或 <code>M-s r</code> (<code>isearch-toggle-regexp</code>) ，可在普通增量搜索与正则表达式增量搜索间切换（参见<a href="#Regexp-Search">正则表达式搜索</a>）。
</p>

<p>
按下 <code>M-s _</code> ，可切换符号模式的开启 / 关闭状态（参见<a href="#Symbol-Search">符号搜索</a>）。
</p>

<p>
若要搜索换行符，可在输入搜索字符串时按下 <code>C-j</code> 。
</p>

<p>
若要搜索非 ASCII 字符，可在增量搜索过程中使用以下任意一种方法：
</p>
<ul class="org-ul">
<li>按下 <code>C-q</code> (<code>isearch-quote-char</code>) ，随后键入非图形字符或一组八进制数字，即可将对应字符添加至搜索字符串，其用法与在缓冲区中使用 <code>C-q</code> 插入字符一致（参见<a href="#Inserting-Text">插入文本</a>）。例如，在增量搜索中按下 <code>C-q C-s</code> ，会将 'control-S' 控制字符 S 添加至搜索字符串。</li>
<li><p>
使用输入法（参见<a href="#Input-Methods">输入法</a>）。若启动搜索时当前缓冲区已启用某输入法，在输入搜索字符串时，迷你缓冲区会沿用该输入法。输入搜索字符串期间，可按下 <code>C-\</code> (<code>isearch-toggle-input-method</code>) 切换输入法状态；也可按下 <code>C-^</code> (<code>isearch-toggle-specified-input-method</code>) ，根据提示选择并启用非默认输入法。当增量搜索中启用输入法时，搜索提示会显示该输入法的助记符，格式如下：
</p>

<div class="org-src-container">
<pre class="src src-shell">I-search [im]:
</pre>
</div>

<p>
其中的输入法助记符 <code>im</code> 为当前激活输入法的标识。在增量搜索中启用的任意输入法，后续会一直保持在当前缓冲区的启用状态。此外，可按下 <code>C-x \</code> (<code>isearch-transient-input-method</code>) 临时启用临时输入法（参见<a href="#Select-Input-Method">临时输入法</a>），通过该输入法向搜索字符串中插入单个字符，插入完成后输入法会自动禁用。
</p></li>

<li>按下 <code>C-x 8 RET</code> (<code>isearch-char-by-name</code>) ，随后键入字符的 Unicode 名称或十六进制编码点，即可将指定字符添加至搜索字符串，其用法与常规的 <code>insert-char</code> 命令一致（参见<a href="#Inserting-Text">插入文本</a>）。</li>
</ul>


<p>
你也可在搜索字符串中包含表情符号序列：按下 <code>C-x 8 e RET</code> (<code>isearch-emoji-by-name</code>) ，随后键入表情符号的 Unicode 名称（例如 <code>smiling face</code> 微笑脸、 <code>heart with arrow</code> 带箭头的心形），即可将指定表情符号添加至搜索字符串。若不清楚目标表情符号的名称，可使用 <code>C-x 8 e l</code> (<code>emoji-list</code>) 和 <code>C-x 8 e d</code> (<code>emoji-describe</code>) 命令查询（参见<a href="#Input-Methods">输入法</a>）。
</p>

<p>
在增量搜索中按下 <code>M-s o</code> ，会调用 <code>isearch-occur</code> 命令，该命令会以当前搜索字符串为检索条件执行 <code>occur</code> 命令（参见 <a href="#Other-Repeating-Search">occur 命令</a>）。
</p>

<p>
在增量搜索中按下 <code>M-%</code> (<code>isearch-query-replace</code>) ，会调用查询替换或正则表达式查询替换命令（具体取决于当前搜索模式），并将当前搜索字符串设为待替换的目标字符串。若为该命令添加负的数字前缀参数，会执行反向替换（参见<a href="#Query-Replace">查询替换</a>）。按下 <code>C-M-%</code> (<code>isearch-query-replace-regexp</code>) ，会调用正则表达式查询替换命令，并将当前搜索字符串设为待替换的正则表达式。
</p>

<p>
在增量搜索中按下 <code>M-TAB</code> ，会调用 <code>isearch-complete</code> 命令，该命令会以搜索环（你此前使用过的所有搜索字符串）为补全候选列表，尝试对当前搜索字符串进行补全（参见<a href="#Completion">补全功能</a>）。在许多操作系统中， <code>M-TAB</code> 快捷键会被窗口管理器拦截；若你需要使用该功能，需将 <code>isearch-complete</code> 命令重新绑定至其他快捷键（参见<a href="#Rebinding">交互式修改按键绑定</a>）。
</p>

<p>
按下 <code>M-s h r</code> (<code>isearch-highlight-regexp</code>) ，可退出搜索并保持匹配项的高亮状态。该命令会调用 <code>highlight-regexp</code> 命令（参见<a href="#Highlight-Interactively">交互式高亮</a>），将由当前搜索字符串转换而来的正则表达式作为检索条件，并提示你选择用于高亮的文本外观。若希望高亮包含匹配项的整行文本（而非仅高亮匹配项本身），可按下 <code>M-s h l</code> (<code>isearch-highlight-lines-matching-regexp</code>) 。无论使用上述哪种高亮方式，按下 <code>M-s h u</code> (<code>unhighlight-regexp</code>) 即可取消所有高亮效果。
</p>

<p>
当增量搜索处于激活状态时，按下 <code>C-h C-h</code> (<code>isearch-help-map</code>) 可打开交互式帮助选项，其中包含所有特殊快捷键的列表。这些快捷键均属于按键映射表 <code>isearch-mode-map</code> （参见<a href="#Keymaps">按键映射表</a>）。
</p>

<p>
当增量搜索处于激活状态时，按下 <code>M-s M-&gt;</code> 会跳至搜索字符串的最后一个匹配项，按下 <code>M-s M-&lt;</code> 会跳至搜索字符串的第一个匹配项。若为这两个命令添加数字前缀参数 <code>n</code> ，会分别从缓冲区起始位置和末尾位置开始计数，跳至搜索字符串的第 <code>n</code> 个匹配项。
</p>
</div>
</div>
<div id="outline-container-Not-Exiting-Isearch" class="outline-4">
<h4 id="Not-Exiting-Isearch"><span class="section-number-4">17.1.6.</span> 不退出增量搜索</h4>
<div class="outline-text-4" id="text-Not-Exiting-Isearch">
<p>
本节介绍如何控制在键入 <b>搜索中无特定含义</b> 的命令时，是否先退出搜索再执行该命令；同时还将说明三类特殊命令，键入这类命令时无需退出当前增量搜索，尽管其本身并非增量搜索的内置命令。
</p>

<p>
默认情况下，若键入的命令未被增量搜索绑定相关功能，Emacs 会 <b>先退出搜索，再执行该命令</b> ，因此该命令会作用于启动搜索的原缓冲区。但如果将变量 <code>search-exit-option</code> 自定义为 <code>append</code> ，增量搜索无法解析的键入字符会直接 <b>追加至搜索字符串中</b> 。借助该设置，你可将 <code>C-a</code> 等控制字符纳入搜索字符串 —— 这类字符在默认情况下会触发退出搜索，并在缓冲区中执行其绑定的命令。
</p>

<dl class="org-dl">
<dt>前缀参数</dt><dd><p>
在增量搜索中，当你键入用于指定数字前缀参数的命令时（参见<a href="#Arguments">数字参数</a>），该参数默认会作用于搜索的下一个操作，或退出搜索后执行的命令。换言之，输入前缀参数本身不会终止增量搜索。
</p>

<p>
在早期的 Emacs 版本中，输入前缀参数总会终止搜索。若要恢复该旧版行为，可将变量 <code>isearch-allow-prefix</code> 设为 <code>nil</code> 。
</p>

<p>
当 <code>isearch-allow-scroll</code> 为非 nil 值时（见下文），无论 <code>isearch-allow-prefix</code> 是否为 <code>nil</code> ，前缀参数均会遵循上述默认行为，即不会终止搜索。
</p></dd>

<dt>滚动命令</dt><dd><p>
默认情况下，执行滚动命令会退出增量搜索。但如果将变量 <code>isearch-allow-scroll</code> 设为非 nil 值，即可在不退出搜索的前提下，使用滚动条，以及 <code>C-v</code> 、 <code>M-v</code> 、 <code>C-l</code> 等键盘滚动命令（参见<a href="#Scrolling">滚动</a>）—— 这类命令的 <code>scroll-command</code> 属性均为非 nil。该特性仅适用于通过 <b>绑定的快捷键</b> 调用这些命令，键入 <code>M-x</code> 仍会触发退出搜索。你可按常规方式为这些滚动命令添加前缀参数。
</p>

<p>
该特性默认会防止当前匹配项被滚动至视野外；若将 <code>isearch-allow-scroll</code> 自定义为特殊值 <code>unlimited</code> ，则会取消该限制。
</p>

<p>
<code>isearch-allow-scroll</code> 特性还会作用于其他部分命令，例如 <code>C-x 2</code> (<code>split-window-below</code>) 和 <code>C-x ^</code> (<code>enlarge-window</code>)（放大窗口）—— 这类命令并非严格意义上的滚动命令，但会影响文本在屏幕上的显示位置。事实上，所有 <code>isearch-scroll</code> 属性为非 nil 的命令，都会受该特性影响。因此，你可通过修改这些命令的属性，控制其是否被该特性作用。
</p>

<p>
例如，若希望在后续所有 Emacs 会话的增量搜索中，均可使用 <code>C-h l</code> 命令，可先通过 <code>C-h c</code> 查询该快捷键绑定的命令（参见<a href="#Key-Help">按键的文档说明</a>），即 <code>view-lossage</code> ；随后在初始化文件中添加以下配置行（参见<a href="#Init-File">Emacs 初始化文件</a>）：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(put 'view-lossage 'isearch-scroll t)
</pre>
</div>

<p>
该特性可应用于所有不会永久修改以下内容的命令：光标位置、缓冲区内容、匹配数据、当前缓冲区，以及选中的窗口和框架。且该命令本身不能尝试执行增量搜索。当 <code>isearch-allow-scroll</code> 为 <code>nil</code> 时（默认值），该特性会被禁用。
</p>

<p>
同理，若将变量 <code>isearch-allow-motion</code> 设为非 nil 值，即可在不退出搜索的前提下，使用 <code>M-&lt;</code> 、 <code>M-&gt;</code> 、 <code>C-v</code> 、 <code>M-v</code> 等键盘移动命令，分别跳至缓冲区中当前搜索字符串的第一个匹配项、最后一个匹配项、当前窗口后方的第一个匹配项和当前窗口前方的最后一个匹配项。
</p>

<p>
执行这些移动命令时，搜索方向默认不会改变；若将变量 <code>isearch-motion-changes-direction</code> 设为非 nil 值，则会改变搜索方向：执行 <code>M-&lt;</code> 和 <code>C-v</code> 后搜索方向为正向，执行 <code>M-&gt;</code> 和 <code>M-v</code> 后搜索方向为反向。
</p></dd>

<dt>移动命令</dt><dd><p>
若将 <code>isearch-yank-on-move</code> 自定义为 <code>shift</code> ，你可在按住 <code>shift</code> 键的同时键入光标移动命令，以此扩展搜索字符串。该操作会将当前缓冲区中，光标移动后新位置之前的文本撷取并追加至搜索字符串。
</p>

<p>
若将 <code>isearch-yank-on-move</code> 设为 <code>t</code> ，无需按住 <code>Shift</code> 键，键入光标移动命令即可扩展搜索字符串；但该效果仅适用于符号上带有 <code>isearch-move</code> 属性的特定移动命令。
</p></dd>
</dl>
</div>
</div>
<div id="outline-container-Isearch-Minibuffer" class="outline-4">
<h4 id="Isearch-Minibuffer"><span class="section-number-4">17.1.7.</span> 迷你缓冲区搜索</h4>
<div class="outline-text-4" id="text-Isearch-Minibuffer">
<p>
若在迷你缓冲区处于激活状态时启动增量搜索，Emacs 会对迷你缓冲区的内容进行检索。与搜索普通缓冲区不同，搜索字符串不会显示在回显区中，因为该区域会被用于显示迷你缓冲区本身的内容。
</p>

<p>
若在迷你缓冲区中执行增量搜索未找到匹配结果，Emacs 会尝试 <b>检索迷你缓冲区的历史记录</b> （参见<a href="#Minibuffer-History">迷你缓冲区历史记录</a>）。你可将迷你缓冲区及其历史记录视作一系列连续的页面：最早的历史记录项位于第一页，当前的迷你缓冲区内容则在最后一页。正向搜索（ <code>C-s</code> ）会向后检索后续页面的内容，反向搜索（ <code>C-r</code> ）则会向前检索更早页面的内容。与搜索普通缓冲区的规则一致，无匹配结果的搜索会执行循环检索，从最后一页跳转至第一页，或从第一页跳转至最后一页。
</p>

<p>
当当前匹配项出现在某条历史记录项中时，该历史记录项会被调取至迷你缓冲区中。若你以常规方式退出增量搜索（例如按下 <code>RET</code> 回车键），该历史记录项会保留在迷你缓冲区中；若通过按下 <code>C-g</code> 取消搜索，迷你缓冲区的内容会恢复为启动搜索时的状态。
</p>
</div>
</div>
</div>
<div id="outline-container-Nonincremental-Search" class="outline-3">
<h3 id="Nonincremental-Search"><span class="section-number-3">17.2.</span> 非增量搜索（Nonincremental Search）</h3>
<div class="outline-text-3" id="text-Nonincremental-Search">
<p>
Emacs 也提供常规的非增量搜索命令，这类命令要求你在搜索开始前输入 <b>完整的搜索字符串</b> 。
</p>

<dl class="org-dl">
<dt><code>C-s RET string RET</code></dt><dd>搜索指定字符串。</dd>
<dt><code>C-r RET string RET</code></dt><dd>反向搜索指定字符串。</dd>
</dl>

<p>
启动非增量搜索时，先按下 <code>C-s RET</code> ，此时会调出迷你缓冲区用于输入搜索字符串；输入完成后按 <code>RET</code> 回车键确认，搜索随即执行。若未找到该字符串，搜索命令会触发错误提示。
</p>

<p>
按下 <code>C-s RET</code> 时， <code>C-s</code> 会照常调用增量搜索功能，而该功能被专门设定为：当你输入的搜索字符串为空时，自动调用非增量搜索命令（空参在增量搜索中并无实际作用）。 <code>C-r RET</code> 的执行逻辑同理，会调用反向非增量搜索命令。
</p>

<p>
非增量搜索也可通过菜单栏的 '<code>Edit-&gt;Search</code>' 菜单调用。
</p>

<p>
你也可使用两个更简洁的命令： <code>M-x search-forward</code> （正向搜索）和 <code>M-x search-backward</code> （反向搜索）。这两个命令仅对指定的字面字符串进行检索，除了大小写折叠外，不支持任何宽松搜索相关特性（参见<a href="#Lax-Search">搜索中的宽松匹配</a>）。
</p>
</div>
</div>
<div id="outline-container-Word-Search" class="outline-3">
<h3 id="Word-Search"><span class="section-number-3">17.3.</span> 单词搜索（Word Search）</h3>
<div class="outline-text-3" id="text-Word-Search">
<p>
<code>ward search单词搜索</code> 会查找连续的单词序列，且忽略单词之间的标点符号类型。例如，若你输入的搜索字符串是由单个空格分隔的两个单词，该搜索会匹配这两个单词以一个或多个空格、换行符或其他标点符号分隔的任意序列。此功能在搜索文本文档时尤为实用，你无需担心目标单词之间是用换行符还是空格分隔。需注意，编程语言对应的主模式或其他专用模式可修改单词的定义，以适配其语法需求。
</p>

<dl class="org-dl">
<dt><code>M-s w</code></dt><dd>若增量搜索已激活，切换单词搜索模式 (<code>isearch-toggle-word</code>)；若未激活，启动正向增量单词搜索 (<code>isearch-forward-word</code>) 。</dd>
<dt><code>M-s w RET words RET</code></dt><dd>执行正向非增量单词搜索，查找指定单词序列。</dd>
<dt><code>M-s w C-r RET words RET</code></dt><dd>执行反向非增量单词搜索，查找指定单词序列。</dd>
<dt><code>M-s M-w</code></dt><dd>在网络上搜索选区中的文本内容。</dd>
</dl>

<p>
启动正向增量单词搜索，按下 <code>M-s w</code> 即可。若增量搜索尚未激活，该快捷键会执行 <code>isearch-forward-word</code> 命令；若增量搜索已激活（无论正向还是反向）， <code>M-s w</code> 会执行 <code>isearch-toggle-word</code> 命令，切换为单词搜索模式，且保持搜索方向和当前搜索字符串不变。再次按下 <code>M-s w</code> ，可关闭单词搜索模式。
</p>

<p>
启动非增量单词搜索，按下 <code>M-s w RET</code> 执行正向搜索，按下 <code>M-s w C-r RET</code> 执行反向搜索，二者分别对应 <code>word-search-forward</code> 和 <code>word-search-backward</code> 命令。
</p>

<p>
增量单词搜索与非增量单词搜索的匹配规则略有不同：非增量单词搜索中，搜索字符串中的每个单词都必须与完整的单词精确匹配；增量单词搜索的匹配规则则更为宽松，在你输入搜索字符串的过程中，其首个和最后一个单词无需匹配完整单词，目的是让匹配过程能随你的输入实时增量进行。这一额外的宽松规则不适用于延迟高亮功能（参见<a href="#Incremental-Search">增量搜索</a>），该功能始终会匹配完整的单词。输入搜索字符串时，搜索提示中会显示 “待匹配（Pending）”，直至你按下 <code>C-s</code> 等重复搜索的快捷键。
</p>

<p>
单词搜索命令不执行字符折叠，切换宽松空格匹配模式（参见<a href="#Lax-Search">宽松空格匹配</a>）对其也无任何效果。
</p>

<p>
在网络上搜索选区中的文本，按下 <code>M-s M-w</code> 即可。该命令会通过互联网搜索选区中的单词，使用的搜索引擎地址由变量 <code>eww-search-prefix</code> 指定（参见《Emacs 网页浏览器手册》中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/eww/Basics.html#Basics">EWW</a> 相关内容）。若选区未激活，或选区中无任何单词，该命令会提示用户输入待搜索的网址或关键词。
</p>

<p>
你也可通过 <code>RFC</code> 2229 定义的 <code>DICT</code> 协议查询词典服务器，查找单词的释义。Emacs 内置了该协议的客户端，按下 <code>M-x dictionary-search RET</code> ，即可连接至 <code>DICT</code> 词典服务器，查询指定单词的所有可用释义。该命令会提示用户输入待查询单词，默认使用光标所在位置的单词，随后请求词典服务器在一个或多个词典中返回该单词的释义。默认情况下，该命令会先尝试连接本地主机上的 <code>DICT</code> 词典服务器，若连接失败，经用户确认后会尝试连接 <code>dict.org</code> 服务器；可自定义变量 <code>dictionary-server</code> ，将其设为字符串类型的服务器地址，指定唯一使用的词典服务器（若仅需查询本地服务器，设为 “localhost” 即可）。通常， <code>dictionary-search</code> 命令会让服务器在其所有可用词典中检索单词，若为该命令添加数字前缀参数，其会提示用户指定单个词典进行检索。服务器的所有可用词典列表，可通过下方所述的 <code>*Dictionary*</code> 缓冲区中显示的「选择词典（Select dictionary）」按钮查看。
</p>

<p>
首次使用 <code>dictionary-search</code> 命令时，Emacs 会新建一个 <code>*Dictionary*</code> 缓冲区，并在其中启用专用模式。该缓冲区提供了选择词典、搜索其他单词释义等功能按钮，后续执行的 <code>dictionary-search</code> 命令会复用此缓冲区。若需新建一个同类缓冲区（例如在另一本词典中查询其他单词），按下 <code>M-x dictionary RET</code> 即可。
</p>

<p>
若在某一缓冲区中启用 <code>dictionary-tooltip-mode</code> 模式，Emacs 会自动查询鼠标指针所在位置单词的释义，并在工具提示中显示。当你阅读包含大量陌生单词的文本时，该功能会非常实用。
</p>

<p>
关于 dictionary-search 命令的其他配置选项，参见词典自定义组（参见<a href="#Specific-Customization">自定义特定项</a>）。
</p>
</div>
</div>
<div id="outline-container-Symbol-Search" class="outline-3">
<h3 id="Symbol-Search"><span class="section-number-3">17.4.</span> 符号搜索（Symbol Search）</h3>
<div class="outline-text-3" id="text-Symbol-Search">
<p>
<code>symbol search符号搜索</code> 与普通搜索极为相似，区别在于 <b>搜索内容的边界必须与符号的边界相匹配</b> 。此处的「symbol符号」含义由主模式决定，通常指源代码中的语法标记，例如 Emacs Lisp 模式中的 Lisp 符号。举例来说，若对 Lisp 符号 <code>forward-word</code> 执行增量符号搜索，该搜索不会匹配 <code>isearch-forward-word</code> 。因此，该功能主要适用于搜索源代码。
</p>

<dl class="org-dl">
<dt><code>M-s _</code></dt><dd>若增量搜索已激活，切换符号搜索模式 (<code>isearch-toggle-symbol</code>) ；若未激活，启动正向增量符号搜 (<code>isearch-forward-symbol</code>) 。</dd>
<dt><code>M-s .</code></dt><dd>启动正向增量符号搜索，且会将光标附近找到的符号预先加入搜索字符串。</dd>
<dt><code>M-s _ RET symbol RET</code></dt><dd>执行正向非增量符号搜索，查找指定符号。</dd>
<dt><code>M-s _ C-r RET symbol RET</code></dt><dd>执行反向非增量符号搜索，查找指定符号。</dd>
</dl>

<p>
启动正向增量符号搜索，按下 <code>M-s _</code> 即可（若待搜索符号就在光标附近，也可按下 <code>M-s .</code> ）。若增量搜索尚未激活， <code>M-s _</code> 会执行 <code>isearch-forward-symbol</code> 命令， <code>M-s .</code> 会执行 <code>isearch-forward-symbol-at-point</code> 命令。为 <code>M-s .</code> 添加数字前缀参数 <code>n</code> 时，该命令会查找光标处符号的第 <code>n</code> 个后续匹配项；若 <code>n</code> 为负值，则执行反向搜索。若增量搜索已激活，按下 <code>M-s _</code> 会切换至符号搜索模式，同时保留原有的搜索方向和当前搜索字符串；再次按下 <code>M-s _</code> ，即可关闭符号搜索模式。在增量符号搜索中，输入搜索字符串的过程中， <b>仅要求搜索字符串的开头与符号的开头相匹配</b> ，且搜索提示中会显示「待匹配（Pending）」，直至按下 <code>C-s</code> 等重复搜索的快捷键。
</p>

<p>
启动非增量符号搜索，按下 <code>M-s _ RET</code> 执行正向搜索，按下 <code>M-s _ C-r RET</code> 执行反向搜索。在非增量符号搜索中， <b>要求搜索字符串的开头与结尾分别与符号的开头和结尾严格匹配</b> 。
</p>

<p>
符号搜索命令不执行字符折叠，切换宽松空格匹配模式（参见<a href="#Lax-Search">宽松空格匹配</a>）对其也无任何效果。
</p>
</div>
</div>
<div id="outline-container-Regexp-Search" class="outline-3">
<h3 id="Regexp-Search"><span class="section-number-3">17.5.</span> 正则表达式搜索（Regular Expression Search）</h3>
<div class="outline-text-3" id="text-Regexp-Search">
<p>
<code>regular expression</code> 正则表达式（简称regexp）是一种匹配模式，可匹配一类符合规则的备选字符串。Emacs 同时提供了增量和非增量两种正则表达式搜索方式，正则表达式的语法将在下一节中讲解。
</p>

<dl class="org-dl">
<dt><code>C-M-s</code></dt><dd>启动正向增量正则表达式搜索 (<code>isearch-forward-regexp</code>) 。</dd>
<dt><code>C-M-r</code></dt><dd>启动反向增量正则表达式搜索 (<code>isearch-backward-regexp</code>)。</dd>
</dl>

<p>
启动正向增量正则表达式搜索可按下 <code>C-M-s</code> ，也可给 <code>C-s</code> 添加任意数值的前缀参数后执行，或在正向增量搜索中键入 <code>M-r</code> 切换。该命令与 <code>C-s</code> 的操作方式一致，会增量式读取输入的搜索字符串，但不会将其作为固定字符串去精确匹配缓冲区文本，而是将其视作正则表达式进行匹配。每向搜索字符串中添加字符，正则表达式就会相应延长，Emacs 也会用新的正则表达式重新执行搜索。执行反向增量正则表达式搜索，可按下 <code>C-M-r</code> 、给  <code>C-r</code> 添加前缀参数执行，或在反向增量搜索中键入 <code>M-r</code> 切换。
</p>

<p>
普通增量搜索中的所有特殊快捷键（参见<a href="#Special-Isearch">增量搜索的特殊输入</a>），在增量正则表达式搜索中均有类似功能。例如，启动搜索后立即按下 <code>C-s</code> ，会调取上一次使用的增量正则表达式搜索串并执行正向搜索。增量正则表达式搜索和普通增量搜索拥有相互独立的默认搜索串，且各自配有独立的搜索环，均可通过 <code>M-p</code> 和 <code>M-n</code> 进行遍历。搜索环中可保存的正则表达式最大数量由变量 <code>regexp-search-ring-max</code> 指定，默认值为 16。
</p>

<p>
与普通增量搜索不同，增量正则表达式搜索 <b>默认不启用lax space宽松空格匹配</b> ，可按下 <code>M-s SPC</code> (<code>isearch-toggle-lax-whitespace</code>) 切换该功能。启用后，在增量正则表达式搜索中键入的任意空格，均可匹配一个或多个空白字符组成的任意序列。变量 <code>search-whitespace-regexp</code> 用于指定宽松空格匹配所使用的正则表达式，详情参见<a href="#Special-Isearch">增量搜索的特殊输入</a>。
</p>

<p>
此外，增量正则表达式搜索 <b>不支持字符折叠功能</b> （参见<a href="#Lax-Search">搜索中的宽松匹配</a>）。若在增量正则表达式搜索中按下 <code>M-s '</code> 尝试切换字符折叠，搜索会自动转为普通字符串搜索，此前输入的匹配模式也会被当作字面量字符串解析。
</p>

<p>
在某些情况下，为增量正则表达式搜索的匹配串添加字符，可能会导致光标回退并重新执行搜索。例如，当你已搜索过 '<code>foo</code>' ，再为其添加 '<code>\|bar</code>' 后，光标会回退重新检索 —— 这是为了匹配出现在首个foo之前的首个bar（此时搜索提示会显示「待匹配（Pending）」，告知用户程序正在重新计算匹配结果），相关语法详情参见<a href="#Regexps">正则表达式语法</a>。
</p>

<p>
正向和反向正则表达式搜索并非对称操作，因为 Emacs 中的正则表达式匹配始终 <b>正向执行</b> ，从正则表达式的起始位置开始匹配。因此，正向正则表达式搜索会正向扫描文本，在每个可能的起始位置尝试正向匹配；反向正则表达式搜索会反向扫描文本，但同样在每个可能的起始位置执行正向匹配，这两种搜索方式并非镜像关系。
</p>

<p>
非增量正则表达式搜索可通过 <code>re-search-forward</code> 和 <code>re-search-backward</code> 命令实现，可通过 <code>M-x</code> 直接调用，也可在增量正则表达式搜索中按下 <code>C-M-s RET</code> 或 <code>C-M-r RET</code> 触发。通过 <code>M-x</code> 直接调用这两个命令时，程序会严格按照你指定的正则表达式执行搜索，因此除大小写折叠外，不支持任何宽松搜索特性（参见<a href="#Lax-Search">搜索中的宽松匹配</a>）。
</p>

<p>
若为增量正则表达式搜索命令添加前缀参数执行，该命令会切换为普通字符串搜索，功能与 <code>isearch-forward</code> 和 <code>isearch-backward</code> 一致，详情参见<a href="#Incremental-Search">增量搜索</a>。
</p>
</div>
</div>
<div id="outline-container-Regexps" class="outline-3">
<h3 id="Regexps"><span class="section-number-3">17.6.</span> 正则表达式语法</h3>
<div class="outline-text-3" id="text-Regexps">
<p>
本节（以及本手册整体）介绍的是用户日常使用的正则表达式特性。更多主要用于 Lisp 程序的扩展特性，参见《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Regular-Expressions.html#Regular-Expressions">正则表达式</a>相关章节。
</p>

<p>
正则表达式拥有专属语法：其中少量字符为 <b>special constructs特殊构造符</b> ，其余均为 <b>ordinary普通字符</b> 。普通字符仅匹配其自身，无其他匹配效果。特殊字符包括 '<code>$^.*+?[\</code>' 仅在作为方括号表达式的结束符 '<code>]</code>' 时具有特殊性（见下文）； '-' 仅在方括号表达式内具有特殊性。正则表达式中出现的其他所有字符均为普通字符，除非其前带有反斜杠 '\' 转义（在 Lisp 程序中使用正则表达式时，每个 '\' 都必须写为双反斜杠 '\\' ，参见本节末尾示例）。
</p>

<p>
例如， 'f'并非特殊字符，因此属于普通字符，正则表达式 'f' 仅匹配字符串 'f' ，不匹配其他任何字符串（也不匹配 'ff'）。同理， 'o' 作为正则表达式仅匹配 'o'。（当忽略大小写匹配时，这些正则表达式也会匹配 'F' 和 'O' ，我们将此视为「匹配相同字符串」的扩展规则，而非例外情况。）
</p>

<p>
任意两个正则表达式 <code>a</code> 和 <code>b</code> 均可进行 <b>拼接</b> ，拼接后的正则表达式匹配规则为：若字符串的开头部分能匹配 <code>a</code> ，剩余部分能匹配 <code>b</code> ，则该字符串可被拼接后的正则表达式匹配。一个简单的例子是，将 'f' 和 'o' 拼接得到正则表达式 'fo'，其仅匹配字符串 'fo' 。若要实现更复杂的匹配效果，就需要使用特殊字符。以下是所有正则表达式特殊字符的说明：
</p>

<dl class="org-dl">
<dt><code>.</code> (句点)</dt><dd>特殊字符，匹配除换行符外的任意单个字符。例如，正则表达式 ‘a.b’ 匹配以 ‘a’ 开头、以 ‘b’ 结尾的任意三字符字符串。</dd>
<dt><code>*</code></dt><dd><p>
本身并非独立构造符，而是后缀操作符，表示将其前面的正则表达式重复匹配任意次数（包括 0 次），且遵循 <b>贪婪匹配原则</b> （尽可能多匹配）。因此， ‘o*’ 匹配任意数量的 ‘o’，也包括空字符串。
</p>

<p>
<code>*</code> 始终作用于其前方最小的有效正则表达式。因此， ‘fo*’ 表示 ‘o’ 可重复匹配，而非 ‘fo’整体，该表达式可匹配f、fo、foo等字符串。
</p>

<p>
正则表达式匹配器处理 <code>*</code> 构造符的逻辑为：首先尽可能多地匹配 ‘*’ 修饰的表达式，再继续匹配模式的剩余部分；若剩余部分匹配失败，则进行 <b>回溯</b> ，舍弃部分 ’*‘ 的匹配结果，直至模式剩余部分能成功匹配。例如，用 ‘ca*ar’ 匹配字符串 ‘caaar’ 时， ‘a*’ 最初会匹配全部 3 个 ‘a’ ，但模式剩余部分为 ‘ar’ ，而字符串中仅剩 ‘r’ ，因此此次匹配失败；随后进行回溯， ‘a*’ 仅匹配 2 个 ‘a’，此时正则表达式的剩余部分可成功匹配，整体匹配完成。
</p></dd>

<dt><code>+</code></dt><dd>后缀操作符，与 ‘*’ 类似，但要求其前方的表达式至少匹配 1 次。因此， ‘ca+r’ 可匹配 ‘car’ 、 ‘caaaar’，但不匹配 ‘cr’ ；而 ‘ca*r’ 可匹配上述三个字符串。</dd>
<dt><code>?</code></dt><dd>后缀操作符，与 ‘*’ 类似，但其前方的表达式匹配 0 次或 1 次，二者择一。因此， ‘ca?r’ 仅匹配 ‘car’ 或 ‘cr’ ，无其他匹配结果。</dd>
<dt><code>*?、+?、??</code></dt><dd><p>
上述操作符的 <b>non-greedy非贪婪匹配</b> 变体。默认的 ‘*’ 、 ‘+’ 、‘?’ 为贪婪匹配，即在保证整个正则表达式能匹配的前提下，尽可能多匹配字符；后缀添加 ‘?’ 后，变为非贪婪匹配，即在保证整个正则表达式能匹配的前提下， <b>尽可能少匹配字符</b> 。
</p>

<p>
例如， ‘ab*’ 和 ‘ab*?’ 均可匹配字符串 ‘a’ 和 ‘abbbb’ ；但用二者匹配文本 ‘abbb’ 时， ‘ab*’ 会匹配整个字符串（ <b>贪婪匹配，最长有效匹配</b> ），而 ‘ab*?’ 仅匹配 ‘a’ （ <b>非贪婪匹配，最短有效匹配</b> ）。
</p>

<p>
非贪婪操作符会在指定起始位置匹配 <b>最短的有效字符串</b> ；但在正向搜索中，始终会选择 <b>最早出现的有效起始位置</b> 进行匹配。例如，用 ‘a.*?$’ 匹配文本 ‘abbab’ （后接换行符）时，该表达式会匹配整个字符串 —— 因为从第一个 ‘a’ 开始即可完成匹配，匹配器会优先选择该起始位置。
</p></dd>

<dt><code>[…]</code></dt><dd><p>
也称作 bracket expression备选字符集，匹配集合中的任意单个字符。
</p>

<p>
最简单的情况是，方括号之间的所有字符即为该集合的匹配范围。例如， ‘[ad]’ 匹配单个 ‘a’ 或单个 ‘d’； ‘[ad]*’ 匹配由任意数量a和d组成的字符串（包括空字符串）。由此可得， ‘c[ad]*r’ 可匹配 ‘cr’ 、‘car’ 、 ‘cdr’ 、 ‘caddaar’ 等字符串。
</p>

<p>
在字符集中，可通过 <b>连字符 ‘-’ 连接起始和结束字符，表示字符范围</b> 。例如， ‘[a-z]’ 匹配任意小写 ASCII 字母；字符范围可与单个字符自由混合，如 ‘[a-z\(%.]’ 匹配任意小写 ASCII 字母，或 ‘\)’ 、 ‘%’ 、 ‘.’ 。再如， ‘[α-ωί]’ 匹配所有小写希腊字母。
</p>

<p>
字符集中还可包含 <b>special character classes特殊字符类</b> ，以 ‘[:’ 开头、 ‘:]’ 结尾的内容即为字符类，嵌在方括号表达式内使用。例如，  <code>[[:alnum:]]</code> 匹配任意字母或数字。字符类的完整列表参见《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Char-Classes.html#Char-Classes">字符类</a>相关章节。
</p>

<p>
若要在字符集中包含 ‘]’ ，必须将其设为 <b>第一个字符</b> ，例如 ‘[]a]’ 匹配 ‘]’ 或 ‘a’ ；若要包含 ‘-’ ，可将其设为字符集的 <b>最后一个字符</b> ，也可放在开头或字符范围之后，例如 ‘[]-]’ 匹配 ‘]’ 和 ‘-’ 。
</p>

<p>
若要在字符集中包含 ‘^’ ，可将其放在 <b>除开头外的任意位置</b> （在开头时，字符集会变为补集 —— 见下文）。
</p>

<p>
在 <b>忽略大小写</b> 的搜索中使用字符范围时，范围的首尾字符需统一大小写（均大写、均小写），或均为非字母字符。 ‘A-z’ 这类混合大小写的字符范围，其匹配行为未被明确定义，且在未来的 Emacs 版本中可能发生变化。
</p></dd>

<dt><code>[^ …]</code></dt><dd><p>
以 ‘[^’ 开头的方括号表达式为 <b>complemented character set补集字符集</b> ，匹配 <b>除指定字符外的任意单个字符</b> 。例如， ‘ <code>[^a-z0-9A-Z]</code> ’ 匹配所有非 ASCII 字母和数字的字符。
</p>

<p>
‘^’ 仅在字符集开头时具有特殊性，其余位置均为普通字符； ‘^’ 后的第一个字符，其 ‘-’ 和 ‘]’ 均无特殊性（即无需转义即可直接表示自身）。
</p>

<p>
补集字符集 <b>可以匹配换行符</b> ，除非将换行符明确列入不匹配的字符中。这一点与 <code>grep</code> 等程序中的正则表达式处理逻辑不同。
</p></dd>

<dt><code>^</code></dt><dd><p>
特殊字符，匹配空字符串，但 <b>仅在被匹配文本的行首生效</b> ，其余位置均匹配失败。因此， ‘ <code>^foo</code> ’ 仅匹配出现在行首的 ‘foo’ 。
</p>

<p>
出于历史兼容性考虑， ‘^’ 仅在 <b>正则表达式的开头</b> ，或 ‘\(’ 、‘\|’ 之后使用时，才具有行首匹配的含义。
</p></dd>

<dt><code>$</code></dt><dd><p>
其用法与脱字符 ‘^’ 类似，但仅在行尾位置完成匹配。例如，正则表达式 ‘x+$’ 可匹配行尾由一个或多个 ‘x’ 组成的字符串。
</p>

<p>
出于历史兼容性考量， ‘$’ 仅在正则表达式的末尾，或在 ‘\)’ 、 ‘\|’ 之前使用时，才具备上述行尾匹配的含义。
</p></dd>

<dt><code>\</code></dt><dd><p>
拥有两个功能：转义特殊字符（包括自身 ‘\’ ），以及引入扩展的特殊构造符。
</p>

<p>
由于 ‘\’ 的转义作用， '<code>\$</code>' 作为正则表达式仅匹配 '<code>$</code>' ， ‘\[’ 仅匹配 ‘[’ ，依此类推。
</p>

<p>
以 ‘\’ 开头的扩展特殊构造符，参见下一节内容。
</p></dd>
</dl>

<p>
注意：出于历史兼容性，若特殊字符出现在 <b>其特殊含义无意义的上下文</b> 中，会被当作普通字符处理。例如， ‘*foo’ 中的 ‘*’ 会被视为普通字符，因为其前方无任何可被修饰的表达式。不建议依赖此行为编写正则表达式，无论特殊字符出现在何处，都建议通过转义明确其普通字符的含义。
</p>

<p>
’\‘ <b>反斜杠在方括号表达式内无特殊性</b> ，因此无法取消 ‘-’ 、 ‘^’ 、 ‘]’ 的特殊含义。当这些字符无特殊含义时，无需为其添加反斜杠——这一操作无任何实际意义；而当它们具有特殊含义时，反斜杠可合法地加在其前方，例如 ‘[^\]’ （在 Lisp 字符串语法中需写为 "<code>[^\\]</code>"），该表达式匹配除反斜杠外的任意单个字符。
</p>
</div>
</div>
<div id="outline-container-Regexp-Backslash" class="outline-3">
<h3 id="Regexp-Backslash"><span class="section-number-3">17.7.</span> 正则表达式中的反斜杠</h3>
<div class="outline-text-3" id="text-Regexp-Backslash">
<p>
在绝大多数情况下，反斜杠 '<code>\</code>' 后接任意字符，仅会匹配该字符本身。但存在若干例外情况：以 '<code>\</code>' 开头的双字符序列拥有特殊含义，而该序列的第二个字符单独使用时，始终为普通字符。以下是所有以 '<code>\</code>' 构成的特殊构造符说明：
</p>

<dl class="org-dl">
<dt><code>\|</code></dt><dd><p>
表示匹配备选项。在两个正则表达式 <code>a</code> 和 <code>b</code> 之间加入 '<code>\|</code>' ，构成的新表达式可匹配任意能被 <code>a</code> 或 <code>b</code> 匹配的文本。其匹配逻辑为：先尝试用 <code>a</code> 匹配，若匹配失败，再尝试用 <code>b</code> 匹配。
</p>

<p>
例如， '<code>foo\|bar</code>' 仅匹配 'foo' 或 'bar' ，不匹配其他任何字符串。
</p>

<p>
'<code>\|</code>' 的作用范围为 <b>其两侧最大的有效正则表达式</b> ，仅能通过圆括号组 '<code>\( … \)</code>' 限定其作用范围。
</p>

<p>
正则表达式的完整回溯机制可处理 '<code>\|</code>' 的多次嵌套使用场景。
</p></dd>

<dt><code>\( … \)</code></dt><dd><p>
表示分组构造符，主要有三项作用：
</p>
<ol class="org-ol">
<li>为其他操作符包裹一组由 '<code>\|</code>' 分隔的备选项。例如， '<code>\(foo\|bar\)x</code>' 可匹配 'foox' 或 'barx' ；</li>
<li>为后缀操作符 '<code>*</code>' 、 '<code>+</code>' 、 '<code>?</code>' 包裹复杂的表达式，使其成为操作符的作用对象。例如， '<code>ba\(na\)*</code>' 可匹配 'banana' 、 'bananana' 等包含任意数量（0 个及以上） 'na' 的字符串；</li>
<li>记录匹配到的子串，供后续引用使用。</li>
</ol>

<p>
上述第三项作用并非括号分组的固有属性，而是为同一 '<code>\( … \)</code>' 构造符赋予的另一重独立功能。实际使用中，这两种含义通常不会产生冲突；若出现冲突，可使用下文介绍的匿名分组解决。
</p></dd>

<dt><code>\(?: … \)</code></dt><dd>表示 <b>shy group匿名分组</b> ，该分组不会记录匹配到的子串，也无法通过后文的 '<code>\d</code>' 语法引用（见下文）。此构造符在正则表达式的机械拼接场景中十分实用，可仅为语法需求添加分组，而不会干扰需要被引用的分组的编号顺序。</dd>

<dt><code>\d</code></dt><dd><p>
表示反向引用，匹配第 <code>d</code> 个 '<code>\( … \)</code>' 分组此前匹配到的完全相同的文本。
</p>

<p>
当 '<code>\( … \)</code>' 分组完成匹配后，正则表达式匹配器会记录该分组匹配到的文本的起始和结束位置。在正则表达式的后续位置，使用 '<code>\</code>' 后接数字 <code>d</code> ，即可表示「匹配第 <code>d</code> 个 '<code>\( … \)</code>' 分组匹配到的文本」。
</p>

<p>
正则表达式中出现的前 9 个 '<code>\( … \)</code>' 分组，会按照左括号在表达式中出现的先后顺序，被依次分配编号1至9。因此，可使用 '<code>\1</code>' 至 '<code>\9</code>' 引用对应分组匹配到的文本。
</p>

<p>
例如， '<code>\(.*\)\1</code>' 可匹配任意无换行符、且由两个完全相同的子串拼接而成的字符串。其中 '<code>\(.*\)</code>' 会匹配前半部分（可为任意内容），而后续的 '<code>\1</code>' 则必须匹配与前半部分完全一致的文本。
</p>

<p>
若某个 '<code>\( … \)</code>' 分组因后接 '<code>*</code>' 等操作符而完成多次匹配，匹配器 <b>仅会记录最后一次的匹配结果</b> 。
</p></dd>

<dt><code>\{m\}</code></dt><dd>作为后缀操作符，表示 <b>精确匹配 m 次</b> ，即其前方的正则表达式必须连续匹配恰好 <code>m</code> 次。例如， '<code>x\{4\}'</code> 仅匹配字符串 'xxxx' ，不匹配其他任何内容。</dd>

<dt><code>\{m,n\}</code></dt><dd>作为后缀操作符，表示 <b>匹配 m 至 n 次</b> ，即其前方的正则表达式必须连续匹配至少 <code>m</code> 次、至多 <code>n</code> 次。若省略 <code>n</code> ，则表示无上限，仅要求前方表达式匹配至少 <code>m</code> 次。

<ul class="org-ul">
<li>'<code>\{0,1\}</code>' 与 '<code>?</code>' 等价；</li>
<li>'<code>\{0,\}</code>' 与 '<code>*</code>' 等价；</li>
<li>'<code>\{1,\}</code>' 与 '<code>+</code>' 等价。</li>
</ul></dd>

<dt><code>\`</code></dt><dd>匹配空字符串，且仅在被匹配的字符串 或 缓冲区（或其可访问部分）的起始位置生效。</dd>

<dt><code>\'</code></dt><dd>匹配空字符串，且仅在被匹配的字符串 或 缓冲区（或其可访问部分）的结束位置生效。</dd>

<dt><code>\=</code></dt><dd>匹配空字符串，且仅在当前光标位置生效。</dd>

<dt><code>\b</code></dt><dd><p>
表示 <b>单词边界</b> ，匹配空字符串，且仅在单词的起始或结束位置生效。因此， '<code>\bfoo\b</code>' 可匹配作为独立单词出现的 'foo' ， '<code>\bballs?\b</code>' 可匹配作为独立单词出现的 'ball' 或 'balls' 。
</p>

<p>
无论缓冲区首尾的相邻字符为何， '<code>\b</code>' 均可在缓冲区的起始和结束位置匹配。
</p></dd>

<dt><code>\B</code></dt><dd>匹配空字符串，且仅在非单词边界的位置生效（与 '<code>\b</code>' 含义相反）。</dd>
<dt><code>\&lt;</code></dt><dd>匹配空字符串，且仅在单词的起始位置生效。仅当缓冲区起始位置后接单词构成字符时， '<code>\&lt;</code>' 才可在该位置匹配。</dd>
<dt><code>\&gt;</code></dt><dd>匹配空字符串，且仅在单词的结束位置生效。仅当缓冲区的内容以单词构成字符结尾时， '<code>\&gt;</code>' 才可在缓冲区结束位置匹配。</dd>
<dt><code>\w</code></dt><dd>匹配任意单词构成字符，具体的字符范围由 Emacs 的语法表定义，参见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Tables.html#Syntax-Tables">语法表</a>》相关章节。</dd>

<dt><code>\W</code></dt><dd>匹配任意非单词构成字符（与 '<code>\w</code>' 含义相反）。</dd>
<dt><code>\_&lt;</code></dt><dd>表示符号边界，匹配空字符串，且仅在符号的起始位置生效。符号指由一个或多个符号构成字符组成的序列，而符号构成字符指语法类型为 '<code>w</code>' （单词）或 '<code>_</code>' （下划线）的字符。仅当缓冲区起始位置后接符号构成字符时， '<code>\_&lt;</code>' 才可在该位置匹配。与单词规则一致，符号构成字符的范围也由语法表定义。</dd>

<dt><code>\_&gt;</code></dt><dd>匹配空字符串，且仅在符号的结束位置生效。仅当缓冲区的内容以符号构成字符结尾时， '<code>\_&gt;</code>' 才可在缓冲区结束位置匹配。</dd>

<dt><code>\sc</code></dt><dd>匹配任意语法类型为 <code>c</code> 的字符。其中 <code>c</code> 为指定语法类别的标识字符，例如 '<code>w</code>' 代表单词构成字符、 '<code>-</code>' 或 ' ' 代表空白字符、 '<code>.</code>' 代表普通标点字符等。语法类别的完整列表参见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Class-Table.html#Syntax-Class-Table">语法类代表格</a>》。</dd>

<dt><code>\Sc</code></dt><dd>匹配任意语法类型非 <code>c</code> 的字符（与 '<code>\sc</code>' 含义相反）。</dd>

<dt><code>\cc</code></dt><dd>匹配任意属于类别 <code>c</code> 的字符。例如， '<code>\cc</code>' 匹配中文字符、 '<code>\cg</code>' 匹配希腊字符等。若要查看所有已定义的字符类别，可执行命令 <code>M-x describe-categories RET</code> 。</dd>

<dt><code>\Cc</code></dt><dd>匹配任意不属于类别 <code>c</code> 的字符（与 '<code>\cc</code>' 含义相反）。</dd>
</dl>

<p>
所有与单词、语法相关的构造符，其行为均由语法表的配置决定，参见《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Tables.html#Syntax-Tables">语法表</a>相关章节。
</p>
</div>
</div>
<div id="outline-container-Regexp-Example" class="outline-3">
<h3 id="Regexp-Example"><span class="section-number-3">17.8.</span> 正则表达式示例</h3>
<div class="outline-text-3" id="text-Regexp-Example">
<p>
以下为一个正则表达式示例 —— 该表达式与 Emacs 默认用于识别句子结尾（不含后续空格）的正则表达式类似，对应变量为 <code>sentence-end-base</code> ：
</p>

<div class="org-src-container">
<pre class="src src-shell">[.?!][]<span style="color: #8b2252;">\"')}]*</span>
</pre>
</div>

<p>
该表达式由两个连续的部分构成：第一部分是匹配句点、'?' 问号或 '!' 感叹号的字符集，第二部分是匹配 '<code>]</code>' 右括号、引号或 ')' 圆括号、'}'大括号的字符集，且第二部分可匹配零次或多次。
</p>
</div>
</div>
<div id="outline-container-Lax-Search" class="outline-3">
<h3 id="Lax-Search"><span class="section-number-3">17.9.</span> 搜索中的宽松匹配（Lax Matching During Searching）</h3>
<div class="outline-text-3" id="text-Lax-Search">
<p>
通常情况下，你会希望搜索命令忽略输入的搜索字符串与待搜索文本之间的某些细微差异。例如，不同长度的空白字符序列通常被视为等效；字母的大小写差异通常不影响匹配，这类规则被称为 <b>character equivalence字符等效性</b> 。
</p>

<p>
本节将介绍 Emacs 的 <code>lax search 宽松搜索</code> 特性，以及如何根据自身需求对其进行定制。
</p>

<p>
默认情况下，搜索命令会执行 <b>lax space matching宽松空格匹配</b> ：搜索字符串中的单个空格或连续空格序列，可匹配文本中任意一个或多个空白字符组成的序列。更准确地说，Emacs 会将搜索字符串中的每段空格序列，匹配为用户选项 <code>search-whitespace-regexp</code> 所指定的正则表达式。该选项的默认值将任意空格和制表符序列视为空白字符，因此搜索字符串 'foo bar' 可匹配文本中的 'foo bar' 、'foo  bar'、'foo   bar' 等形式（但不匹配 'foobar'）。若你希望让空格同时匹配换行符、空格和制表符组成的序列，可自定义该选项，将其值设为正则表达式 '<code>[ \t\n]+</code>' （增量正则表达式搜索的默认行为与此不同，参见<a href="#Regexp-Search">正则表达式搜索</a>章节）。
</p>

<p>
若你需要让空白字符 <b>精确匹配</b> ，可在增量搜索过程中按下 <code>M-s SPC</code> (<code>isearch-toggle-lax-whitespace</code>) 关闭宽松空格匹配，再次按下该快捷键则可重新开启。若要对所有搜索禁用宽松空格匹配，可将 <code>search-whitespace-regexp</code> 设为 <code>nil</code> ，此时搜索字符串中的每个空格将仅匹配文本中的单个空格。
</p>

<p>
在 Emacs 中，若你输入的搜索字符串均为小写字母，搜索命令默认 <b>会忽略待搜索文本的大小写</b> 。例如，搜索 'foo' 时，文本中的 'Foo' 和 'fOO' 也会被匹配。正则表达式（尤其是字符集）的匹配规则同理， '<code>[ab]</code>' 会匹配'a' 、 'A' 、 'b' 、 'B' 。该特性被称为 <b>case folding大小写折叠</b> ，增量搜索和非增量搜索模式均支持此特性。
</p>

<p>
若搜索字符串中 <b>任意位置包含大写字母</b> ，则搜索会变为 <b>大小写敏感</b> 模式。例如，搜索 'Foo' 时，不会匹配文本中的 'foo' 或 'FOO' 。该规则同时适用于正则表达式搜索和字面字符串搜索，若将搜索字符串中的大写字母删除，大小写敏感的效果也会随之消失。变量 <code>search-upper-case</code> 用于控制该特性：若其值为非nil，搜索字符串中的大写字母会触发大小写敏感搜索；若设为 <code>nil</code> ，则会禁用大写字母的该作用。该变量的默认值为 <code>not-yanks</code> ，此配置下，若搜索字符串包含大写字母则开启大小写敏感，同时会将撷取到搜索字符串中的文本（参见<a href="#Isearch-Yank">增量搜索中的文本撷取</a>）转换为小写，使这类搜索默认保持大小写不敏感。
</p>

<p>
若将变量 <code>case-fold-search</code> 设为 <code>nil</code> ，则所有字符 <b>必须完全精确匹配</b> （包括大小写）。该变量为缓冲区局部变量，修改其值通常仅对当前缓冲区生效，除非你更改其默认值（参见<a href="#Locals">局部变量</a>章节）。该变量同样适用于非增量搜索，包括替换命令（参见<a href="#Replace">替换命令</a>章节）和迷你缓冲区历史记录匹配命令（参见<a href="#Minibuffer-History">迷你缓冲区历史记录</a>章节）执行的搜索。
</p>

<p>
在增量搜索过程中，按下 <code>M-c</code> 或 <code>M-s c</code> (<code>isearch-toggle-case-fold</code>) 可切换本次搜索的大小写敏感状态。该切换效果仅对当前增量搜索有效，但会覆盖因在当前搜索字符串中添加或删除大写字母而产生的大小写匹配规则。
</p>

<p>
另有多个相关变量用于控制特定命令或操作的搜索与匹配大小写敏感性，例如 <code>tags-case-fold-search</code> 控制 <code>find-tag</code> 命令的大小写敏感性。若要查找这类变量，可执行 <code>M-x apropos-variable RET case-fold-search RET</code> 。
</p>

<p>
大小写折叠会忽略字符间的大小写差异，使大写字符与对应小写字符相互匹配。 <b>character folding字符折叠</b> 是大小写折叠的扩展特性，它会忽略相似字符之间更广泛的差异。例如，开启字符折叠后，字母 <code>a</code> 会匹配其所有带重音的变体（如 <code>ä</code> 和 <code>á</code> ），即匹配时会忽略区分这些变体的变音符号；此外， <code>a</code> 还会匹配其他外形相似、或在图形表示中包含 <code>a</code> 的字符，如 Unicode 字符 U+00AA（阴性序数指示符）和 U+24D0（圆形小写字母 a）。同理，ASCII 双引号 <code>"</code> 会匹配 Unicode 标准中定义的所有双引号变体。字符折叠甚至可让一个或多个字符组成的序列，匹配另一个不同长度的字符序列，例如双字符序列 <code>ff</code> 会匹配 Unicode 字符 U+FB00（拉丁文连字小写 ff），序列 <code>(a)</code> 会匹配 U+249C（带圆括号的拉丁文小写字母 a）。那些并非完全相同、但在字符折叠规则下可相互匹配的字符序列，被称为 <b>equivalent character sequences等效字符序列</b> 。
</p>

<p>
通常情况下，Emacs 的搜索命令 <b>默认不执行字符折叠</b> ，即不会匹配等效字符序列。你可通过将变量 <code>search-default-mode</code> 自定义为 <code>char-fold-to-regexp</code> 来启用该特性（参见<a href="#Search-Customizations">根据需求自定义搜索行为</a>章节）。在增量搜索过程中，按下 <code>M-s '</code> (<code>isearch-toggle-char-fold</code>) 可切换本次搜索的字符折叠状态，该效果仅对当前搜索有效（替换命令的默认行为与此不同，由独立选项控制，参见<a href="#Replacement-and-Lax-Matches">替换命令与宽松匹配</a>章节）。
</p>

<p>
默认情况下，若在搜索字符串中输入某字符的显式变体（如 <code>ä</code> ），不会匹配其基础字符（如 <code>a</code> ）。但如果将变量 <code>char-fold-symmetric</code> 自定义为 <code>t</code> ，搜索命令会将等效字符同等对待：在搜索字符串中使用任意一个等效字符，都会匹配待搜索文本中的所有等效字符，因此输入带重音的 <code>ä</code> 时，会同时匹配基础字母a及其所有变体（如 <code>á</code> ）。
</p>

<p>
你可通过可自定义变量 <code>char-fold-include</code> 添加新的字符折叠规则，或通过 <code>char-fold-exclude</code> 移除现有规则；也可将 <code>char-fold-override</code> 自定义为 <code>t</code> ，此时会禁用所有默认字符等效性规则，仅保留你通过 <code>char-fold-include</code> 自行添加的规则。
</p>
</div>
</div>
<div id="outline-container-Replace" class="outline-3">
<h3 id="Replace"><span class="section-number-3">17.10.</span> 替换命令</h3>
<div class="outline-text-3" id="text-Replace">
<p>
Emacs 提供了多个用于执行查找替换操作的命令。除简单的 <code>M-x replace-string</code> （字符串替换）命令外，还有 <code>M-%</code> （查询替换）命令，该命令会逐个定位搜索模式的匹配项，并询问你是否执行替换。
</p>

<p>
替换命令默认对 <b>从光标位置到缓冲区末尾</b> 的文本生效 ；当选区处于激活状态时，替换操作将仅作用于选区内的文本（参见<a href="#Mark">标记与选区</a>）。基础替换命令可将一个 <code>search string搜索字符串</code> （或正则表达式）替换为一个指定的 <code>replacement string替换字符串</code> 。你也可以使用 <code>expand-region-abbrevs</code> 命令（参见<a href="#Expanding-Abbrevs">缩写展开的控制</a>），并行执行多项替换操作。
</p>

<ul class="org-ul">
<li><a href="#Unconditional-Replace">无条件替换</a></li>
<li><a href="#Regexp-Replace">正则表达式替换</a></li>
<li><a href="#Replacement-and-Lax-Matches">替换命令与宽松匹配</a></li>
<li><a href="#Query-Replace">查询替换（Query Replace）</a></li>
</ul>
</div>
<div id="outline-container-Unconditional-Replace" class="outline-4">
<h4 id="Unconditional-Replace"><span class="section-number-4">17.10.1.</span> 无条件替换</h4>
<div class="outline-text-4" id="text-Unconditional-Replace">
<dl class="org-dl">
<dt><code>M-x replace-string RET string RET newstring RET</code></dt><dd>将字符串的每一处匹配项替换为新字符串。</dd>
</dl>

<p>
若要将光标位置之后的所有 'foo' 替换为 'bar' ，可执行命令 <code>M-x replace-string</code> ，并传入两个参数 'foo' 和 'bar' 。替换操作仅作用于光标位置之后的文本，因此如果需要覆盖整个缓冲区，必须先将光标移至缓冲区起始位置。从光标处到缓冲区末尾的所有匹配项都会被替换；若要将替换范围限定在缓冲区的某一部分，需先选中该区域。当区域处于激活状态时，替换操作将仅在该区域内进行（详见《<a href="#Mark">标记与区域</a>》章节）。
</p>

<p>
<code>replace-string</code> 命令执行完毕后，光标会停留在最后一个被替换的匹配项位置。该命令执行前的光标位置会被添加到标记环中，但不会激活标记；可使用 <code>C-u C-SPC</code> 快捷键返回该位置（详见《<a href="#Mark-Ring">标记环</a>》章节）。
</p>

<p>
若为该命令添加前缀参数，则仅会替换那些被单词边界包围的匹配项。
</p>

<p>
关于替换命令中大小写敏感性与字符折叠的详细说明，详见《<a href="#Replacement-and-Lax-Matches">替换命令与宽松匹配</a>》章节。
</p>
</div>
</div>
<div id="outline-container-Regexp-Replace" class="outline-4">
<h4 id="Regexp-Replace"><span class="section-number-4">17.10.2.</span> 正则表达式替换</h4>
<div class="outline-text-4" id="text-Regexp-Replace">
<p>
<code>M-x replace-string</code> 命令用于替换指定字符串的 <b>精确匹配项</b> 。与之类似的命令 <code>M-x replace-regexp</code> ，则可替换符合指定正则表达式模式的 <b>任意匹配</b> 内容（详见《<a href="#Regexps">正则表达式语法</a>》章节）。
</p>

<dl class="org-dl">
<dt><code>M-x replace-regexp RET regexp RET newstring RET</code></dt><dd>将所有匹配该正则表达式的内容替换为新字符串。</dd>
</dl>

<p>
在 <code>replace-regexp</code> 命令中， newstring新字符串并非必须是固定文本：它可以 <b>引用正则表达式匹配结果的全部或部分内容</b> 。新字符串中的 '<code>\&amp;</code>' 代表被替换的 <b>整个匹配内容</b> ；新字符串中的 '<code>\d</code>' （其中 <code>d</code> 是从 1 开始的数字），代表正则表达式中 <b>第 d 个带括号的分组所匹配的内容</b> （这一用法被称为 “反向引用”）。 '<code>\#</code>' 代表当前命令 <b>已完成的替换次数</b> ，以十进制数字表示 —— 第一次替换时， '<code>\#</code>' 代表 0；第二次替换时，代表 1，依此类推。例如：
</p>


<div class="org-src-container">
<pre class="src src-shell">M-x replace-regexp RET c[ad]+r RET <span style="color: #8b2252;">\&amp;</span>-safe RET
</pre>
</div>

<p>
可将（例如） 'cadr' 替换为 'cadr-safe' ，将 'cddr' 替换为 'cddr-safe' 。
</p>

<div class="org-src-container">
<pre class="src src-shell">M-x replace-regexp RET <span style="color: #8b2252;">\(</span>c[ad]+r<span style="color: #8b2252;">\)</span>-safe RET \1 RET
</pre>
</div>

<p>
则可实现上述操作的逆向转换。若需在替换文本中包含反斜杠 '<code>\</code>' ，必须输入 '<code>\\</code>' 。
</p>

<p>
如果希望在 <b>每次替换时手动输入部分替换字符串</b> ，可在替换字符串中使用 '<code>\?</code>' 。执行替换时，Emacs 会在迷你缓冲区中打开替换字符串供你编辑，光标会自动定位在 '<code>\?</code>' 所在的位置。
</p>

<p>
本小节的剩余内容适用于 <b>特定专业任务</b> ，且需要掌握 Lisp 语言相关知识，多数读者可跳过此部分。
</p>

<p>
你可以使用 Lisp 表达式来计算替换字符串的部分内容。具体方法是，在替换字符串中写入 '<code>\,</code>' ，并在其后跟上对应的表达式。每次替换时，Emacs 会计算该表达式的值，将其直接转换为文本（若表达式的值为字符串，则直接使用字符串内容），并将该文本代入替换字符串，替代原表达式的位置。若表达式为一个符号，那么符号名称后的一个空格会被视为符号名称的一部分，表达式的值会同时替换符号名称与该空格。
</p>

<p>
在这类表达式内部，你可以使用一些特殊序列。与常规用法一致， '<code>\&amp;</code>' 和 '<code>\d</code>' 分别代表整个匹配内容的字符串形式，以及对应子匹配内容的字符串形式。其中 <code>d</code> 可以是多位数字；若第 <code>d</code> 个带括号的分组未匹配到任何内容， '<code>\d</code>' 的值则为 <code>nil</code> 。你也可以使用 '<code>\#&amp;</code>' 和 '<code>\#d</code>'，将对应匹配内容 <b>以数字形式引用</b> （此用法仅在匹配内容或子匹配内容为数字格式时有效）。此处的 '<code>\#</code>' 同样代表已完成的替换次数。
</p>

<p>
例如，我们可以通过以下方式交换文本中的 x 和 y：
</p>

<div class="org-src-container">
<pre class="src src-shell">M-x replace-regexp RET <span style="color: #8b2252;">\(</span>x<span style="color: #8b2252;">\)\|</span>y RET
<span style="color: #8b2252;">\,</span>(<span style="color: #a020f0;">if</span> \1 <span style="color: #8b2252;">"y"</span> <span style="color: #8b2252;">"x"</span>) RET
</pre>
</div>

<p>
在通过 '<code>\</code>' , 构造替换字符串时， <code>format</code> 函数往往能发挥重要作用（详见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Formatting-Strings.html#Formatting-Strings">格式化字符串</a>》章节）。例如，要在第 73 至 80 列的位置添加连续编号的字符串（如 'ABC00042'），且仅在这些列原本无内容时执行添加操作，可执行以下命令：
</p>

<div class="org-src-container">
<pre class="src src-shell">M-x replace-regexp RET ^.<span style="color: #8b2252;">\{</span>0,72<span style="color: #8b2252;">\}</span>$ RET
<span style="color: #8b2252;">\,</span>(format <span style="color: #8b2252;">"%-72sABC%05d"</span> <span style="color: #8b2252;">\&amp;</span> <span style="color: #8b2252;">\#</span>) RET
</pre>
</div>
</div>
</div>
<div id="outline-container-Replacement-and-Lax-Matches" class="outline-4">
<h4 id="Replacement-and-Lax-Matches"><span class="section-number-4">17.10.3.</span> 替换命令与宽松匹配</h4>
<div class="outline-text-4" id="text-Replacement-and-Lax-Matches">
<p>
本节介绍替换命令在宽松匹配下的行为（参见<a href="#Lax-Search">搜索中的宽松匹配</a>）及其自定义方法。总体而言，替换命令的默认匹配规则，相较于对应的搜索命令会更为严格。
</p>

<p>
与增量搜索不同，替换命令默认不启用宽松空格匹配（参见<a href="#Lax-Search">宽松空格匹配</a>）。若要为替换操作启用该功能，需将变量 <code>replace-lax-whitespace</code> 设为非nil值（该设置仅影响 Emacs 查找待替换文本的方式，不作用于替换文本本身）。
</p>

<p>
配套变量 <code>replace-regexp-lax-whitespace</code> ，用于控制 <code>query-replace-regexp</code> 命令在查找匹配模式时，是否启用宽松空格匹配。
</p>

<p>
若替换命令的第一个参数（搜索串） <b>全部由小写字母组成</b> ，则在查找待替换匹配项时会忽略大小写 —— 此行为的前提是 <code>case-fold-search</code> 和 <code>search-upper-case</code> 均为非nil值。若 <code>search-upper-case</code> （参见 <a href="#Lax-Search">search-upper-case</a>）设为 <code>nil</code> ，则搜索是否忽略大小写仅由 <code>case-fold-search</code> 单独决定，与第一个参数的字母大小写无关。若 <code>case-fold-search</code> 设为 <code>nil</code> ，则所有搜索均始终区分大小写。
</p>

<p>
此外，若替换命令的第二个参数（替换串） <b>全部或部分为小写字母</b> ， <b>替换命令会尝试保留每个匹配项的大小写格式</b> 。例如执行命令：
</p>

<div class="org-src-container">
<pre class="src src-shell">M-x replace-string RET foo RET bar RET
</pre>
</div>

<p>
会将小写的 'foo' 替换为小写的 'bar' 、全大写的 'FOO' 替换为 'BAR' 、首字母大写的 'Foo' 替换为 'Bar' （小写、全大写、首字母大写，是 <code>replace-string</code> 命令唯一能识别的三种大小写格式）。
</p>

<p>
需注意，Emacs 会通过分析 <b>待替换文本中的每个单词</b> ，决定是否对替换文本进行大写或首字母大写转换；仅当待替换文本的所有单词采用 <b>相同的大小写格式</b> 时，才会保留其格式。例如执行命令：
</p>

<div class="org-src-container">
<pre class="src src-shell">M-x replace-string RET foo bar RET baz quux RET
</pre>
</div>

<p>
会将 'Foo Bar' 替换为 'Baz Quux' ，原因是 'Foo Bar' 中的两个单词均为首字母大写格式；而对于 'Foo bar' ，该命令会将其替换为 'baz quux' （即保持替换文本的原始大小写不变），因为 'Foo bar' 中的两个单词大小写格式不同。
</p>

<p>
关于何为 “word单词”，由当前缓冲区生效的语法表决定（参见《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Tables.html#Syntax-Tables">语法表</a>章节）；例如在文本模式中， 'Foo_Bar' 会被视为两个单词，而在部分支持编程语言的主模式中，它可能被视作单个单词。
</p>

<p>
若替换串中包含 <b>大写字母</b> ，则该部分内容在每次插入时，均会保持大写形式。若第一个参数（搜索串）中包含大写字母，第二个参数（替换串）会 <b>严格按照输入内容原样替换</b> ，不进行任何大小写转换。同理，若 <code>case-replace</code> 或 <code>case-fold-search</code> 任一变量设为 <code>nil</code> ，替换操作也会直接执行，不做大小写转换。
</p>

<p>
替换命令在查找待替换文本时， <b>默认不启用字符折叠</b> （参见<a href="#Lax-Search">字符折叠</a>）。若要在 <code>query-replace</code> 和 <code>replace-string</code> 命令的匹配过程中启用字符折叠，需将变量 <code>replace-char-fold</code> 设为非nil值（该设置仅影响 Emacs 查找待替换文本的方式，不作用于替换文本本身，也对 <code>replace-regexp</code> 命令无效）。
</p>
</div>
</div>
<div id="outline-container-Query-Replace" class="outline-4">
<h4 id="Query-Replace"><span class="section-number-4">17.10.4.</span> 查询替换（Query Replace）</h4>
<div class="outline-text-4" id="text-Query-Replace">
<dl class="org-dl">
<dt><code>M-% string RET newstring RET</code></dt><dd>将指定字符串的部分匹配项替换为新字符串。</dd>
<dt><code>C-M-% regexp RET newstring RET</code></dt><dd>将指定正则表达式的部分匹配项替换为新字符串。</dd>
</dl>

<p>
若你无需替换foo的所有匹配项，仅需修改其中一部分为bar，可使用 <code>M-%</code> (<code>query-replace</code>) 命令。该命令会逐个查找foo的匹配项，高亮展示每个匹配项并询问是否执行替换。除了交互式确认这一特性，该命令的其余行为与 <code>replace-string</code> （无条件替换）完全一致（参见<a href="#Unconditional-Replace">无条件替换</a>）；特别地，在默认开启 <code>case-replace</code> 的情况下，命令会自动保留匹配项的大小写格式（参见<a href="#Replacement-and-Lax-Matches">替换命令与宽松匹配</a>）。带数字前缀参数执行该命令时，仅会匹配以单词分隔符为边界的完整单词匹配项；带负的前缀参数执行时，会反向向前查找并替换匹配项。
</p>

<p>
<code>C-M-%</code> 命令执行的是正则表达式的交互式查询替换 (<code>query-replace-regexp</code>) ，其行为与 <code>replace-regexp</code> （正则表达式替换）一致，仅增加了交互式确认替换的步骤。
</p>

<p>
你可复用上述命令的历史替换规则：当 <code>query-replace</code> 或 <code>query-replace-regexp</code> 命令提示输入搜索串时，按下 <code>M-p</code> 和 <code>M-n</code> 可翻阅历史替换记录，记录将以 '<code>from -&gt; to</code>' 原内容 -&gt; 替换内容的形式展示（其中原内容为搜索模式，替换内容为目标字符串，分隔符由变量 <code>query-replace-from-to-separator</code> 定义），按下 <code>RET</code> 回车键即可选中并复用该条替换规则。若将该变量设为 <code>nil</code> ，替换记录将不会被加入命令历史，也无法被复用。
</p>

<p>
这类交互式替换命令会通过 <code>query-replace</code> 高亮样式标记当前匹配项，将变量 <code>query-replace-highlight</code> 设为 <code>nil</code> 可关闭该高亮；同时会像增量搜索一样，通过 <code>lazy-hightlight</code> 延迟高亮标记其他匹配项（参见<a href="#Incremental-Search">增量搜索</a>），将 <code>query-replace-lazy-highlight</code> 设为 <code>nil</code> 可关闭此效果。默认情况下， <code>query-replace-regexp</code> 会在迷你缓冲区中展示当前匹配项经替换后的结果；若希望保留 '<code>\&amp;</code>' 、 '<code>\n</code>' 等特殊序列不被展开，可自定义 <code>query-replace-show-replacement</code> 变量。与增量搜索中通过 <code>search-highlight-submatches</code> 高亮子表达式匹配项的功能类似（参见<a href="#Search-Customizations">根据需求自定义搜索行为</a>），变量 <code>query-replace-highlight-submatches</code> 用于控制正则表达式替换命令是否高亮子表达式的匹配项。
</p>

<p>
将变量 <code>query-replace-skip-read-only</code> 设为非 nil 值后，替换命令会忽略只读文本中的匹配项，该变量默认值为 <code>nil</code> （即不忽略只读文本中的匹配项）。
</p>

<p>
当命令定位到字符串或正则表达式的匹配项并发出询问时，可输入以下字符执行对应操作：
</p>

<dl class="org-dl">
<dt><code>SPC</code></dt><dd></dd>

<dt><code>y</code></dt><dd>将当前匹配项替换为新字符串，继续查找下一个匹配项。</dd>

<dt><code>DEL</code></dt><dd></dd>

<dt><code>Delete</code></dt><dd></dd>

<dt><code>BACKSPACE</code></dt><dd></dd>

<dt><code>n</code></dt><dd>跳过当前匹配项，不执行替换，直接查找下一个。</dd>

<dt><code>, (逗号)</code></dt><dd><p>
替换当前匹配项并展示替换结果，随后需再次输入字符决定后续操作。因替换已完成，此场景下删除键和空格的作用一致，均为跳至下一个匹配项。
</p>

<p>
此时可按下 <code>C-r</code> （详见下文）编辑已替换的文本，也可使用撤销命令（如 <code>C-x u</code> ，参见<a href="#Undo">撤销操作</a>）撤销本次替换； <b>撤销操作会直接退出交互式查询替换</b> ，若需继续替换，需通过 <code>C-x ESC ESC RET</code> 重新启动命令（参见<a href="#Repetition">重复迷你缓冲区命令</a>）。
</p></dd>

<dt><code>RET</code></dt><dd></dd>

<dt><code>q</code></dt><dd>直接退出命令，不再执行后续任何替换。</dd>

<dt><code>. (句点)</code></dt><dd>替换当前匹配项，且替换后直接退出命令，不再查找后续匹配项。</dd>

<dt><code>! (感叹号)</code></dt><dd>无需再次确认，直接替换剩余所有匹配项。</dd>

<dt><code>^ (脱字符)</code></dt><dd>返回上一个匹配项的位置（或原匹配项的位置），适用于误操作修改匹配项，或需要重新检查上一个匹配项的场景。</dd>

<dt><code>u</code></dt><dd>撤销最后一次的替换操作，并回到该次替换的匹配项位置。</dd>

<dt><code>U</code></dt><dd>撤销本次命令中所有的替换操作，回到第一次替换的匹配项位置。</dd>

<dt><code>C-r</code></dt><dd>进入递归编辑模式，适用于无需直接替换、需手动编辑当前匹配项的场景。编辑完成后，按下 <code>C-M-c</code> 退出递归编辑模式，继续查找下一个匹配项（参见<a href="#Recursive-Edit">递归编辑模式</a>）。</dd>

<dt><code>C-w</code></dt><dd>删除当前匹配项，随后进入与 <code>C-r</code> 相同的递归编辑模式，可手动输入文本替代被删除的匹配项；编辑完成后，按下 <code>C-M-c</code> 退出递归编辑模式，继续查找下一个匹配项。</dd>

<dt><code>e</code></dt><dd>在迷你缓冲区中编辑新的替换字符串，按下回车键退出迷你缓冲区后，会用编辑后的内容替换当前匹配项，且该内容会成为后续所有匹配项的默认替换字符串。</dd>

<dt><code>E</code></dt><dd>功能与 <code>e</code> 类似，但本次替换会 <b>严格按替换串的原始大小写执行</b> 。例如，原替换规则为将foo替换为bar时，Foo会默认被替换为Bar；按下 <code>E</code> 后，当前匹配项会直接替换为小写的bar，不做大小写适配。</dd>

<dt><code>C-l</code></dt><dd>重绘屏幕刷新显示，操作后需再次输入字符，决定当前匹配项的处理方式。</dd>

<dt><code>Y (大写)</code></dt><dd>在多缓冲区替换场景中（如 <code>Dired</code> 的 <code>Q</code> 命令，对选中文件执行交互式查询替换），替换当前缓冲区及剩余所有缓冲区中的全部未处理匹配项。该操作会对本次及后续所有替换询问均自动回答 “yes”，无需用户再手动确认。</dd>

<dt><code>N (大写)</code></dt><dd>在多缓冲区替换场景中，跳过当前缓冲区的剩余所有匹配项，直接切换至下一个缓冲区。该操作会对当前替换询问回答 “no”，并放弃当前缓冲区的所有后续替换询问，继续处理序列中的下一个缓冲区。</dd>

<dt><code>C-h</code></dt><dd></dd>

<dt><code>?</code></dt><dd></dd>

<dt><code>F1</code></dt><dd>展示上述所有操作选项的汇总提示信息，查看后需再次输入字符，决定当前匹配项的处理方式。</dd>
</dl>

<p>
除上述字符外，输入 <b>其他任意字符都会直接退出 query-replace交互式查询替换</b> ，且该字符会被重新读取作为按键序列的一部分执行对应操作。例如，输入 <code>C-k</code> 会先退出 <code>query-replace</code> 命令，再执行 “删除至行尾” 的操作；输入 <code>C-g</code> 则会直接退出 <code>query-replace</code> ，无其他后续操作。
</p>

<p>
若替换命令已退出，需重新启动时，可按下 <code>C-x ESC ESC</code> —— 该快捷键会重复执行上一次的交互式查询替换（因命令的参数均通过迷你缓冲区读取），详见 <a href="#Repetition">C-x ESC ESC</a> 相关说明。
</p>

<p>
变量 <code>search-invisible</code> 决定了交互式查询替换命令对隐藏文本的处理方式，参见<a href="#Outline-Visibility">大纲模式中的搜索</a>。
</p>

<p>
关于对选中文件执行交互式查询替换的 Dired <code>Q</code> 命令，参见<a href="#Operating-on-Files">文件操作</a>相关章节；此外，在 Dired 中通过正则表达式匹配重命名、复制或创建文件链接的相关命令，参见 <a href="#Transforming-File-Names">Dired 中的文件名转换</a>。
</p>
</div>
</div>
</div>
<div id="outline-container-Other-Repeating-Search" class="outline-3">
<h3 id="Other-Repeating-Search"><span class="section-number-3">17.11.</span> 其他搜索与循环命令</h3>
<div class="outline-text-3" id="text-Other-Repeating-Search">
<p>
以下是一些用于查找正则表达式匹配项的其他命令。若模式中不包含大写字母且 <code>case-fold-search</code> 变量非空，这些命令在匹配时均忽略大小写。除始终搜索整个缓冲区的 <code>multi-occur</code> 和 <code>multi-occur-in-matching-buffers</code> 外，所有命令均作用于 <b>从光标位置到缓冲区末尾</b> 的文本；若选区处于激活状态，则作用于选区。
</p>

<dl class="org-dl">
<dt><code>M-x multi-isearch-buffers</code></dt><dd>提示输入一个或多个缓冲区名称，按 <code>RET</code> 回车键结束；随后在这些缓冲区中 <b>启动多缓冲区增量搜索</b> 。（若在某个缓冲区中搜索失败，按下下一个 <code>C-s</code> 会尝试在指定的下一个缓冲区中继续搜索，依此类推。）带前缀参数执行时，会提示输入一个正则表达式，并在匹配该正则表达式的所有缓冲区中启动多缓冲区增量搜索。</dd>
<dt><code>M-x multi-isearch-buffers-regexp</code></dt><dd>该命令与 <code>multi-isearch-buffers</code> 功能基本一致，区别在于它执行的是 <b>多缓冲区增量正则表达式搜索</b> 。</dd>
<dt><code>M-x multi-isearch-files</code></dt><dd>提示输入一个或多个文件名，按 <code>RET</code> 回车键结束；随后在这些文件中启动 <b>多文件增量搜索</b> 。（若在某个文件中搜索失败，按下下一个 <code>C-s</code> 会尝试在指定的下一个文件中继续搜索，依此类推。）带前缀参数执行时，会提示输入一个正则表达式，并在匹配该正则表达式的所有文件中启动多文件增量搜索。</dd>
<dt><code>M-x multi-isearch-files-regexp</code></dt><dd><p>
该命令与 <code>multi-isearch-files</code> 功能基本一致，区别在于它执行的是 <b>多文件增量正则表达式搜索</b> 。
</p>

<p>
在部分设置了缓冲区局部变量 <code>multi-isearch-next-buffer-function</code> 的模式中（例如Change Log mode变更日志模式），多文件增量搜索会被自动激活。
</p></dd>

<dt><code>M-x occur</code></dt><dd></dd>

<dt><code>M-s o</code></dt><dd><p>
提示输入一个正则表达式，随后显示缓冲区中 <b>所有包含该匹配项的行</b> 的列表。在提示界面按下 <code>M-n</code> ，可复用之前增量搜索使用过的搜索字符串。匹配到的文本会通过 <code>match</code> （字体样式）高亮显示。带数字参数 <code>n</code> 执行时，会在每个匹配行的前后各显示 <code>n</code> 行上下文内容。
</p>

<p>
上下文的默认行数由变量 <code>list-matching-lines-default-context-lines</code> 指定。当变量 <code>list-matching-lines-jump-to-current-line</code> 非空时，当前行会以 <code>list-matching-lines-current-line-face</code> 样式高亮显示，且光标会定位到该行后的第一个匹配项处。
</p>

<p>
若增量搜索正在进行，直接按下 <code>M-s o</code> 即可基于 <b>当前的搜索字符串</b> 执行该命令。
</p>

<p>
注意：输入的正则表达式匹配项会被扩展为 <b>整行匹配</b> ，且若某个匹配项的起始位置在前一个匹配项的结束位置之前，该匹配项将不被计入。
</p>

<p>
<code>*Occur*</code> 缓冲区以Occur 模式作为主模式：
</p>
<ul class="org-ul">
<li>按下 <code>n</code> 和 <code>p</code> 键可跳至下一个 / 上一个匹配项；带数字前缀参数时，可按指定次数跳至对应匹配项（数字键绑定了 ～digit-argument～ ，因此输入 <code>5 n</code> 即可跳至后面第 <code>5</code> 个匹配项，无需先按 <code>C-u</code> ）；</li>
<li>按下空格键（ <code>SPC</code> ）和删除键（ <code>DEL</code> ）可上下滚动 <code>*Occur*</code> 缓冲区；</li>
<li>点击某个匹配项，或将光标移至该匹配项处并按回车键，会跳转到被搜索的原始缓冲区中对应的位置；</li>
<li>按下 <code>o</code> 和 <code>C-o</code> 可在另一个窗口中显示该匹配项（=C-o= 不会选中新窗口）；</li>
<li>也可使用 M-g M-n（next-error，下一个错误）命令逐个访问所有匹配项（参见编译模式）；</li>
<li>按下 <code>q</code> 可关闭显示 <code>*Occur*</code> 缓冲区的窗口，并将该缓冲区隐藏。</li>
</ul>

<p>
在 <code>*Occur*</code> 缓冲区中按下 <code>e</code> ，会将该缓冲区设为可写状态并进入Occur 编辑模式，此时可编辑匹配行，且所有编辑操作会同步至原始缓冲区的对应文本。按下 <code>C-c C-c</code> 可退出 Occur 编辑模式，恢复为普通 Occur 模式。
</p>

<p>
命令 <code>M-x list-matching-lines</code> 是 <code>M-x occur</code> 的同义词。
</p></dd>

<dt><code>M-x multi-occur</code></dt><dd>该命令与 <code>occur</code> 功能基本一致，区别在于它可在 <b>多个缓冲区中同时搜索</b> ，执行时会提示逐个指定需要搜索的缓冲区名称。</dd>
<dt><code>M-x multi-occur-in-matching-buffers</code></dt><dd>该命令与 ～multi-occur～ 功能类似，区别在于 <b>待搜索的缓冲区</b> 通过 <b>匹配已访问文件名的正则表达式</b> 指定；带前缀参数执行时，会改为通过正则表达式匹配 <b>缓冲区名称</b> 来指定待搜索缓冲区。</dd>
<dt><code>M-x how-many</code></dt><dd>提示输入一个正则表达式，随后 <b>统计并打印</b> 光标位置之后的缓冲区中该表达式的匹配次数；若选区处于激活状态，则仅统计选区中的匹配次数。</dd>
<dt><code>M-x flush-lines</code></dt><dd>提示输入一个正则表达式，随后 <b>删除</b> 光标位置之后的文本中 <b>所有包含该匹配项的行</b> ；命令执行完毕后，会打印被删除的匹配行数量。

<ul class="org-ul">
<li>若当前行中光标位置之后存在匹配项，该行会被删除；</li>
<li>若选区处于激活状态，则仅对选区生效：若某行部分包含在选区内，且其匹配项 <b>完全位于选区内</b> ，该行会被删除；</li>
<li>若某个匹配项跨越多行，这些行都会被一并删除；该命令会先删除匹配行，再继续查找下一个匹配项，因此会忽略在前一个匹配项结束行的同一行起始的新匹配项。</li>
</ul></dd>

<dt><code>M-x keep-lines</code></dt><dd>提示输入一个正则表达式，随后 <b>删除</b> 光标位置之后的文本中 <b>所有不包含该匹配项的行</b> ；
<ul class="org-ul">
<li>若光标未位于行首，该命令始终保留当前行；</li>
<li>若选区处于激活状态，则仅对选区生效：永远不会删除仅部分包含在选区内的行（行尾的换行符视为该行的一部分）；</li>
<li>若某个匹配项跨越多行，这些行都会被一并保留。</li>
</ul></dd>

<dt><code>M-x kill-matching-lines</code></dt><dd>功能与 <code>flush-lines</code> 一致，区别在于该命令会 <b>将被删除的匹配行</b> 添加至 <b>删除环（kill ring）</b> 中，且所有匹配行会被合并为单个字符串（包含行之间的换行符）后存入删除环。</dd>
<dt><code>M-x copy-matching-lines</code></dt><dd>功能与 <code>kill-matching-lines</code> 一致，区别在于该命令不会 <b>从缓冲区中删除匹配行</b> ，仅将其复制至删除环。</dd>
</dl>
</div>
</div>
<div id="outline-container-Search-Customizations" class="outline-3">
<h3 id="Search-Customizations"><span class="section-number-3">17.12.</span> 根据需求定制搜索</h3>
<div class="outline-text-3" id="text-Search-Customizations">
<p>
本节介绍其他章节未提及的各类搜索相关自定义配置。
</p>

<p>
增量搜索的默认模式由变量 <code>search-default-mode</code> 指定，其值可为 <code>nil</code> 、 <code>t</code> 或一个函数：
</p>

<ul class="org-ul">
<li>若值为 <code>nil</code> ，默认执行 <b>字面量搜索</b> ，不进行字符折叠，但会根据 <code>case-fold-search</code> 和~search-whitespace-regexp~ 分别开启大小写折叠和宽松空白匹配（参见「<a href="#Lax-Search">搜索中的宽松匹配</a>」）；</li>
<li>若值为 <code>t</code> ，增量搜索默认执行 <b>正则表达式搜索</b> ；</li>
<li>该变量的默认值为一个函数，仅会执行大小写折叠和宽松空白匹配。</li>
</ul>

<p>
正在进行的增量搜索中， <b>当前匹配项</b> 会通过 <code>isearch</code> 面（字体样式）高亮显示，将变量 <code>search-highlight</code> 设为 <code>nil</code> 可关闭该高亮效果。
</p>

<p>
当搜索正则表达式时（例如使用快捷键 <code>C-M-s</code> ），子表达式的高亮规则由变量 <code>search-highlight-submatches</code> 决定：
</p>

<ul class="org-ul">
<li>若该变量值为 <code>nil</code> ，子表达式无特殊高亮；</li>
<li>若值非nil，正则表达式中由 '<code>\( … \)</code>' 定义的子表达式匹配到的文本，会用不同的面进行高亮。</li>
</ul>

<p>
默认情况下，Emacs 定义了两个专用高亮面： <code>isearch-group-1</code> 和 <code>isearch-group-2</code> 。基于这两个面的规则： <b>奇数序号的子表达式</b> 由 <code>isearch-group-1</code> 高亮， <b>偶数序号的子表达式</b> 由 <code>isearch-group-2</code> 高亮。例如搜索正则表达式 '<code>foo-\([0-9]+\)\([a-z]+\)</code>' 时， '<code>[0-9]+</code>' 匹配的内容会显示 <code>isearch-group-1</code> 样式， '<code>[a-z]+</code>' 匹配的内容会显示 <code>isearch-group-2</code> 样式。
</p>

<p>
若按相同命名规则自定义更多高亮面（如 <code>isearch-group-3</code> 、 <code>isearch-group-4</code> 等），则第 <code>M</code> 、 <code>N+M</code> 、 <code>2N+M</code> 个（以此类推）子表达式会由 <code>isearch-group-M</code> 高亮，其中 <code>N</code> 为所有 <code>isearch-group-M</code> 格式高亮面的总数。
</p>

<p>
当前屏幕中 <b>可见的其他匹配项</b> ，会通过 <code>lazy-highlight</code> 面样式进行高亮，将变量 <code>isearch-lazy-highlight</code> 设为 <code>nil</code> 可关闭该懒高亮效果。以下是用于自定义懒高亮的其他变量：
</p>

<dl class="org-dl">
<dt><code>lazy-highlight-initial-delay</code></dt><dd>高亮可见匹配项前的等待时间，单位为秒。仅当搜索字符串的长度小于 <code>lazy-highlight-no-delay-length</code> 的取值时，该配置才生效。</dd>
<dt><code>lazy-highlight-no-delay-length</code></dt><dd>当搜索字符串的长度大于或等于该变量的取值时，懒高亮会立即触发，无等待时间。</dd>
<dt><code>lazy-highlight-interval</code></dt><dd>依次高亮多个匹配项时的时间间隔，单位为秒。</dd>
<dt><code>lazy-highlight-max-at-a-time</code></dt><dd>一次最多高亮的匹配项数量，达到该数量后会先检查用户输入再继续。若该值设置过大，高亮过程会耗时较久；此期间若按下 <code>C-s</code> 或 <code>C-r</code> 继续搜索，Emacs 需完成所有高亮后才会响应，因此 <b>更小的取值</b> 能提升 Emacs 的响应速度。</dd>
<dt><code>isearch-lazy-count</code></dt><dd>在搜索提示栏中显示当前匹配项的序号和匹配项的总数。</dd>
<dt><code>lazy-count-prefix-format</code></dt><dd></dd>

<dt><code>lazy-count-suffix-format</code></dt><dd>这两个变量共同决定了 <code>isearch-lazy-count</code> 的显示格式，用于定义当前匹配数和总匹配数的前后缀样式。</dd>
</dl>

<p>
默认情况下，若增量搜索中搜索字符串为空，按下回车键（ <code>RET</code> ）会启动非增量搜索（实际流程为：先允许编辑搜索字符串，再次按下回车键后执行搜索）。若将变量 <code>search-nonincremental-instead</code> 设为 <code>nil</code> ，则无论搜索字符串是否为空，按下回车键都会直接退出增量搜索。
</p>

<p>
默认情况下，增量搜索和查询替换命令会 <b>匹配不可见文本</b> ，但当当前匹配项离开该不可见文本区域后，会立即隐藏相关匹配的高亮。若将变量 <code>isearch-hide-immediately</code> 设为 <code>nil</code> ，则找到匹配项的不可见文本会保持显示，直到搜索或替换命令执行完毕。
</p>

<p>
在低速终端中进行增量搜索（例如通过低速网络连接远程机器的显示器），搜索过程中需要重绘屏幕的大部分区域，操作体验会较差。Emacs 为低速终端提供了专用的显示模式：搜索时会弹出一个独立的小窗口，仅在该窗口中显示匹配项周边的文本。小窗口的重绘速度更快，能有效缓解低速终端的操作卡顿问题。相关配置变量如下：
</p>

<ul class="org-ul">
<li><code>search-slow-speed</code> ：设置波特率阈值，当终端波特率低于该值时，Emacs 会自动启用该低速终端显示模式；</li>
<li><code>search-slow-window-lines</code> ：控制搜索结果弹出窗口的行数，默认值为 1 行。该窗口默认出现在启动 <b>搜索的缓冲区窗口底部</b> ；若该变量取负值，则窗口会显示在顶部，且窗口行数为该负值的绝对值。</li>
</ul>
</div>
</div>
</section>
<section id="outline-container-Fixit" class="outline-2">
<h2 id="Fixit"><span class="section-number-2">18.</span> 拼写错误修正命令</h2>
<div class="outline-text-2" id="text-Fixit">
<p>
本章介绍在编辑过程中发现错误时可使用的实用命令。其中最基础的是撤销命令 <code>C-/</code> （同时绑定至 <code>C-x u</code> 和 <code>C-_</code> ）。该命令可撤销单个操作命令、某一命令的部分执行结果（如查询替换的部分操作），或连续的多次字符输入操作。连续按下 <code>C-/</code> 可依次撤销更早的修改操作，直至达到撤销记录的存储上限。
</p>

<p>
除本章介绍的命令外，你也可使用删除类命令清除文本，例如 <code>DEL</code> (delete-backward-char) 。这类命令已在本手册的前文介绍，详见「<a href="#Erasing">文本删除</a>」章节。
</p>

<ul class="org-ul">
<li><a href="#Undo">撤销（Undo）</a></li>
<li><a href="#Transpose">文本交换（Transposing Text）</a></li>
<li><a href="#Fixing-Case">大小写转换（Case Conversion）</a></li>
<li><a href="#Spelling">拼写检查与修正</a></li>
</ul>
</div>
<div id="outline-container-Undo" class="outline-3">
<h3 id="Undo"><span class="section-number-3">18.1.</span> 撤销（Undo）</h3>
<div class="outline-text-3" id="text-Undo">
<p>
撤销命令可还原缓冲区文本中近期的修改操作。每个缓冲区会单独记录自身的修改，撤销命令始终作用于 <b>当前缓冲区</b> 。你可以根据缓冲区的记录，撤销其中所有的修改操作。通常，每个编辑命令都会在撤销记录中生成一条独立条目；但为了提升撤销操作的灵活性，部分命令（如查询替换）会将自身的修改拆分为多条记录。连续的字符输入操作则通常会合并为 <b>单条撤销记录</b> ，让撤销操作更简洁。
</p>

<p>
<b>撤销快捷键</b>
</p>

<dl class="org-dl">
<dt><code>C-/</code></dt><dd></dd>

<dt><code>C-x u</code></dt><dd></dd>

<dt><code>C-_</code></dt><dd>撤销当前缓冲区撤销记录中的一条条目 (<code>undo</code>) 。</dd>
</dl>

<p>
<b>基础撤销操作</b> 
</p>

<p>
要执行撤销，按下 <code>C-/</code> （或其等效快捷键 <code>C-_</code> 、 <code>C-x u</code> ） <sup><a id="fnr.6" class="footref" href="#fn.6" role="doc-backlink">6</a></sup> 即可。该操作会还原缓冲区中最近一次的修改，并将光标移回修改前的位置。连续按下 <code>C-/</code> （或其等效快捷键），可依次还原当前缓冲区中更早的修改。若所有已记录的修改均已被还原，执行撤销命令会触发错误提示。
</p>

<p>
<b>撤销序列的中断与重做</b>
</p>

<p>
除撤销命令外的任意操作，都会中断连续的撤销序列。从操作执行的那一刻起，你此前完成的整段撤销操作，会自身被写入撤销记录。因此，若要重新应用已被撤销的修改，可按下 <code>C-f</code> （前移字符）或其他无副作用的命令中断撤销序列，随后多次按下 <code>C-/</code> ，撤销部分此前的撤销操作即可。
</p>

<p>
若你希望继续执行撤销，而非重做已完成的撤销操作，可使用 <code>M-x undo-only</code> 命令。该命令功能与 <code>undo</code> 一致，但不会重做已被撤销的修改。与之互补的是 <code>M-x undo-redo</code> 命令，它可撤销此前的撤销操作，且自身不会被记录为可撤销的操作。
</p>

<p>
<b>恢复意外修改的缓冲区</b>
</p>

<p>
若发现缓冲区被意外修改，最简便的恢复方式是反复按下 <code>C-/</code> ，直至模式行开头的星号消失（参见「<a href="#Mode-Line">模式行</a>」章节）。当撤销命令让模式行的星号消失时，意味着缓冲区内容已恢复至最近一次读取或保存文件时的状态。若你不确定是否是有意修改了缓冲区，可先按一次 <code>C-/</code> ，看到最近一次的修改被还原后，即可判断该修改是否为操作失误：若是意外修改，保持撤销后的状态即可；若是有意修改，按上述方法重做该修改即可。
</p>

<p>
此外，你也可使用 <code>M-x revert-buffer</code> 命令，丢弃缓冲区自最近一次打开或保存后所有的修改（参见「<a href="#Reverting">还原缓冲区</a>」章节）。
</p>

<p>
<b>选区的选择性撤销</b>
</p>

<p>
当存在激活的选区时，执行任意撤销操作都会触发选择性撤销：仅还原选区内最近一次的修改，而非整个缓冲区的修改。但当瞬时标记模式关闭时（参见「<a href="#Disabled-Transient-Mark">关闭瞬时标记模式</a>」）， <code>C-/</code> 会始终作用于整个缓冲区，忽略选区的存在。这种情况下，可为撤销命令添加前缀参数来执行选择性撤销：按下 <code>C-u C-/</code> 即可；若要继续还原同一选区内更早的修改，直接重复执行撤销命令即可，无需再添加前缀参数。
</p>

<p>
<b>无撤销记录的特殊缓冲区</b>
</p>

<p>
部分专用缓冲区不会生成撤销记录： <b>名称以空格开头</b> 的缓冲区始终不会记录，这类缓冲区由 Emacs 内部使用，用于存储用户通常不会查看或编辑的文本。
</p>

<p>
<b>撤销记录的内存限制</b> 
</p>

<p>
当某个缓冲区的撤销信息占用空间过大时，Emacs 会在垃圾回收过程中 <b>不定期丢弃最旧的记录</b> 。你可通过设置变量 <code>undo-limit</code> 、 <code>undo-strong-limit</code> 和 <code>undo-outer-limit</code> ，指定 Emacs 保留的撤销信息容量，变量值均以字节为单位。
</p>
<ul class="org-ul">
<li><code>undo-limit</code> （软限制）：Emacs 会保留足够多的命令撤销数据，直至达到该容量上限，甚至可小幅超出，但不会保留超出部分的更早命令数据，默认值为 160000 字节。</li>
<li><code>undo-strong-limit</code> （硬限制）：更严格的容量上限，若某条历史命令的撤销数据会让总占用量超出该值，该命令的记录会被直接丢弃（最近一次的修改记录除外），默认值为 240000 字节。</li>
</ul>

<p>
无论上述两个变量的取值如何， <b>最近一次的修改记录永远不会被丢弃</b> ，除非其占用空间超过 <code>undo-outer-limit</code> （默认值为 24000000 字节）。当达到该极限时，Emacs 会丢弃此次的撤销数据并向你发出警告 —— 这是 <b>唯一无法撤销上一条命令</b> 的情况。若出现该问题，你可增大 <code>undo-outer-limit</code> 的取值，降低后续出现该情况的概率；但如果该命令并非预期会生成超大撤销数据，这很可能是程序漏洞，建议你进行反馈（参见「<a href="#Bugs">漏洞反馈</a>」章节）。
</p>
</div>
</div>
<div id="outline-container-Transpose" class="outline-3">
<h3 id="Transpose"><span class="section-number-3">18.2.</span> 文本交换（Transposing Text）</h3>
<div class="outline-text-3" id="text-Transpose">
<dl class="org-dl">
<dt><code>C-t</code></dt><dd>调换两个字符 (<code>transpose-chars</code>) 。</dd>
<dt><code>M-t</code></dt><dd>调换两个单词 (<code>transpose-words</code>) 。</dd>
<dt><code>C-M-t</code></dt><dd>调换两个配对表达式 (<code>transpose-sexps</code>) 。</dd>
<dt><code>C-x C-t</code></dt><dd>调换两行文本 (<code>transpose-lines</code>) 。</dd>
<dt><code>M-x transpose-sentences</code></dt><dd>调换两个句子 (<code>transpose-sentences</code>) 。</dd>
<dt><code>M-x transpose-paragraphs</code></dt><dd>调换两个段落 (<code>transpose-paragraphs</code>) 。</dd>
<dt><code>M-x transpose-regions</code></dt><dd>调换两个区域的文本。</dd>
</dl>

<p>
相邻两个字符输反是最常见的输入错误，可使用 <code>C-t</code> 命令 (<code>transpose-chars</code>) 修正。默认情况下， <code>C-t</code> 会调换 <b>光标两侧</b> 的两个字符；若光标位于行尾，该命令不会将行尾字符与换行符无效调换，而是调换该行的 <b>最后两个字符</b> 。因此，若发现字符输反后立即操作，直接按 <code>C-t</code> 即可修正；若发现较晚，需先将光标移至输反的两个字符之间，再按下 <code>C-t</code> 。若你误将单词末尾的字符与后方的空格调换，可使用单词移动命令（ <code>M-f</code> 、 <code>M-b</code> 等）快速定位光标；其他情况则常用反向搜索（ <code>C-r</code> ）定位，详见「<a href="#Search">搜索与替换</a>」章节。
</p>

<p>
<code>M-t</code> 命令会调换 <b>光标前的单词</b> 与 <b>光标后的单词</b>  (<code>transpose-words</code>) ，执行时光标会向前跳过一个单词，同时将光标前方或包含光标的单词一并向前拖动(PS：这里的前方指光标右边)，单词之间的标点符号位置保持不变。例如，文本 'FOO, BAR' 经调换后会变成 'BAR, FOO' ，而非 'BAR FOO,' 。若光标位于行尾，该命令会将光标前的单词与下一行的第一个单词调换。
</p>

<p>
<code>C-M-t</code> (<code>transpose-sexps</code>) 是功能类似的配对表达式调换命令（详见「<a href="#Expressions">带配对括号的表达式</a>」）， <code>C-x C-t</code> (<code>transpose-lines</code>) 用于调换两行文本。 <code>M-x transpose-sentences</code> 和 <code>M-x transpose-paragraphs</code> 则分别用于调换句子和段落，这两个命令的工作逻辑与 <code>M-t</code> 一致，仅调换的文本单位不同。
</p>

<p>
为调换命令添加数字前缀参数，该参数会作为重复执行的次数：命令会将光标前方或包含光标的字符（/ 单词 / 表达式 / 行），跨越多个同类文本单位进行调换。例如，按下 = C-u 3 C-t= ，会将光标前的字符向前跨 3 个字符调换，将文本 '<code>f∗oobar</code>' 转换为 '<code>oobf∗ar</code>'，效果等同于连续按 3 次 <code>C-t</code> ；按下 <code>C-u -4 M-t</code> ，会将光标前的单词向后跨 4 个单词调换；按下 <code>C-u - C-M-t</code> ，可撤销普通 <code>C-t</code> 命令的调换效果。
</p>

<p>
数字前缀参数为 0时被赋予特殊含义（若无特殊定义，重复次数为 0 的命令将无任何操作）：调换光标后结束的文本单位，与标记后结束的文本单位（字符 / 单词 / 表达式 / 行）。
</p>

<p>
<code>M-x transpose-regions</code> 命令用于调换两类文本：一类是光标与标记之间的文本，另一类是标记环中最后两个标记之间的文本（详见「<a href="#Setting-Mark">设置标记</a>」）。若为该命令添加数字前缀参数，会将光标与标记之间的文本，与标记环中向前数指定次数的 <b>连续两个标记之间</b> 的文本进行调换。该命令最适合一次性调换多段字符、单词、句子或段落。
</p>
</div>
</div>
<div id="outline-container-Fixing-Case" class="outline-3">
<h3 id="Fixing-Case"><span class="section-number-3">18.3.</span> 大小写转换（Case Conversion）</h3>
<div class="outline-text-3" id="text-Fixing-Case">
<dl class="org-dl">
<dt><code>M-- M-l</code></dt><dd>将最后一个单词转换为小写。注意， <code>M--</code> 即Meta键-减号。</dd>
<dt><code>M-- M-u</code></dt><dd>将最后一个单词全部转换为大写。</dd>
<dt><code>M-- M-c</code></dt><dd>将最后一个单词转换为首字母大写、其余小写的格式。</dd>
</dl>

<p>
输错单词大小写是极为常见的输入错误。因此，大小写转换命令 <code>M-l</code> 、 <code>M-u</code> 、 <code>M-c</code>  搭配负参数使用时，会触发一项特殊功能：执行命令时光标不会移动。当你发现刚输入的最后一个单词大小写有误，只需直接执行对应的大小写转换命令，即可继续后续输入，无需调整光标位置。详见「<a href="#Case">大小写转换命令</a>」章节。
</p>
</div>
</div>
<div id="outline-container-Spelling" class="outline-3">
<h3 id="Spelling"><span class="section-number-3">18.4.</span> 拼写检查与修正</h3>
<div class="outline-text-3" id="text-Spelling">
<p>
本节介绍用于检查单个单词或部分缓冲区文本拼写的命令。这些命令仅在安装了拼写检查程序（Hunspell、Aspell、Ispell 或 Enchant 中的任意一款）时才能运行。上述程序并非 Emacs 的组成部分，但通常会预装在 GNU/Linux 及其他自由操作系统中。详见《Aspell 使用手册》中的 <a href="http://aspell.net/man-html/index.html#Top">Aspell</a> 相关章节。
</p>

<p>
若仅安装了一款拼写检查程序，首次调用本节所述命令时，Emacs 会自动检测并加载该程序。若安装了多款，则可通过自定义变量 <code>ispell-program-name</code> 来指定使用哪一款。
</p>

<dl class="org-dl">
<dt><code>M-$</code></dt><dd>检查并纠正光标所在位置单词的拼写 (<code>ispell-word</code>) 。若选区处于激活状态，则检查选区范围内所有单词</dd>
<dt><code>C-u M-$</code></dt><dd>若上一次拼写检查操作被中断，执行此命令可恢复该操作 (<code>ispell-continue</code>)</dd>
<dt><code>M-x ispell</code></dt><dd>检查并纠正整个缓冲区的拼写。若选区处于激活状态，则仅检查选区内容</dd>
<dt><code>M-x ispell-buffer</code></dt><dd>检查并纠正整个缓冲区的拼写</dd>
<dt><code>M-x ispell-region</code></dt><dd>检查并纠正选区范围内的拼写</dd>
<dt><code>M-x ispell-message</code></dt><dd>检查并纠正邮件草稿的拼写，自动排除引用内容</dd>
<dt><code>M-x ispell-comments-and-strings</code></dt><dd>检查并纠正缓冲区或选区中代码的注释与字符串内容的拼写</dd>
<dt><code>M-x ispell-comment-or-string-at-point</code></dt><dd>检查光标所在位置的代码注释或字符串的拼写</dd>
<dt><code>M-x ispell-change-dictionary RET dict RET</code></dt><dd>重启拼写检查进程，并指定使用 词典名 对应的词典</dd>
<dt><code>M-x ispell-kill-ispell</code></dt><dd>终止拼写检查子进程</dd>
<dt><code>M-TAB</code></dt><dd></dd>

<dt><code>ESC TAB</code></dt><dd></dd>

<dt><code>C-M-i</code></dt><dd>基于拼写词典及其他补全来源，补全光标前方的单词 (<code>completion-at-point</code>)</dd>
<dt><code>M-x flyspell-mode</code></dt><dd>启用 Flyspell 模式，该模式会高亮显示所有拼写错误的单词</dd>
<dt><code>M-x flyspell-prog-mode</code></dt><dd>启用适用于编程场景的 Flyspell 模式，仅检查代码注释与字符串中的拼写</dd>
</dl>

<p>
<b>基础拼写检查操作流程</b>
</p>

<p>
要检查并选择性纠正光标附近或前方单词的拼写，可按下 <code>M-$</code> (<code>ispell-word</code>) 。若选区已激活， <code>M-$</code> 会检查选区中所有单词（详见 “<a href="#Mark">标记与选区</a>” 章节）。当暂态标记模式关闭时， <code>M-$</code> 会忽略选区，始终作用于光标附近的单词（详见 “<a href="#Disabled-Transient-Mark">关闭暂态标记模式</a>” 章节）。若带前缀参数执行 <code>C-u M-$</code> ，则会调用 <code>ispell-continue</code> 命令，恢复此前被 <code>X</code> 或 <code>C-g</code> 中断的拼写检查操作。
</p>

<p>
同理， <code>M-x ispell</code> 命令会在选区激活时检查选区，否则检查整个缓冲区。 <code>ispell-buffer</code> 和 <code>ispell-region</code> 命令则分别明确指定对整个缓冲区或选区进行拼写检查。编写电子邮件时，可使用 <code>M-x ispell-message</code> 命令，该命令会检查整个缓冲区，但自动排除缩进内容或疑似引用自其他邮件的文本（详见 “<a href="#Sending-Mail">发送邮件</a>” 章节）。处理源代码时，可使用 <code>ispell-comments-and-strings</code> 或 <code>ispell-comment-or-string-at-point</code> 命令，仅检查注释或字符串字面量的拼写。
</p>

<p>
<b>拼写错误的处理方式</b>
</p>

<p>
当拼写检查命令检测到疑似拼写错误的单词时，会提示用户进行处理。程序通常会显示一份带编号的近似单词列表 —— 即与错误单词拼写相近的正确词汇。此时需输入单个字符来执行相应操作，有效操作指令如下：
</p>

<dl class="org-dl">
<dt><code>digit</code></dt><dd>数字键。仅本次将错误单词替换为列表中对应编号的近似单词。</dd>
<dt><code>SPC</code></dt><dd>跳过当前单词 —— 标记其为拼写错误，但不做修改。</dd>
<dt><code>r new RET</code></dt><dd>仅本次将错误单词替换为输入的 “新单词”（替换后的字符串会被重新扫描，排查是否存在其他拼写错误）。</dd>
<dt><code>R new RET</code></dt><dd>将错误单词替换为输入的 “新单词”，并启动查询替换功能，可选择在缓冲区其他位置批量替换该单词（替换后的内容会被重新扫描）。</dd>
<dt><code>a</code></dt><dd>接受当前单词 —— 在本次编辑会话中，将其视为正确拼写。</dd>
<dt><code>A</code></dt><dd>接受当前单词 —— 在本次编辑会话及当前缓冲区内，将其视为正确拼写。</dd>
<dt><code>i</code></dt><dd>将当前单词添加到个人词典文件中，此后即使重启 Emacs，该单词也会被识别为正确拼写。</dd>
<dt><code>m</code></dt><dd>功能与 <code>i</code> 类似，同时可指定词典补全信息。</dd>
<dt><code>u</code></dt><dd>将当前单词的小写形式添加到个人词典文件中。</dd>
<dt><code>l word RET</code></dt><dd>在词典中搜索与 “待查单词” 匹配的词汇，搜索结果将作为新的近似单词列表，可输入对应数字键选择替换。“待查单词” 中可使用 '<code>*</code>' 作为通配符。</dd>
<dt><code>C-g</code></dt><dd></dd>

<dt><code>X</code></dt><dd>中断交互式拼写检查，将光标停留在正在检查的单词处。后续可通过 <code>C-u M-$</code> 恢复检查。</dd>
<dt><code>x</code></dt><dd>退出交互式拼写检查，并将光标返回至检查开始前的位置。</dd>
<dt><code>q</code></dt><dd>退出交互式拼写检查，并终止拼写检查子进程。</dd>
<dt><code>C-r</code></dt><dd>进入递归编辑模式（详见 “<a href="#Recursive-Edit">递归编辑层级</a>” 章节）。按下 <code>C-M-c</code> 退出递归编辑后，拼写检查会自动恢复。该模式可在不中断检查的前提下查看缓冲区文本，但禁止在递归编辑期间修改缓冲区内容，尤其不能改动疑似拼写错误的单词 —— 退出递归编辑时，所有修改都会被撤销。若需修改错误单词，应使用 <code>r</code> 或 <code>R</code> 指令，或按下 <code>X</code> 中断检查、编辑文本后，再用 <code>C-u M-$</code> 恢复。</dd>
<dt>-<code>C-z</code></dt><dd>挂起 Emacs 或最小化当前窗口。</dd>
<dt>-<code>?</code></dt><dd>显示所有操作指令的说明列表。</dd>
</dl>

<p>
<b>单词补全功能</b>
</p>

<p>
使用 <code>M-TAB</code> (<code>completion-at-point</code>) 可补全光标所在位置的单词。输入单词前缀后按下 <code>M-TAB</code> ，即可从补全列表中选择所需词汇。若窗口管理器拦截了 <code>M-TAB</code> 快捷键，可改用 <code>ESC TAB</code> 或 <code>C-M-i</code> 。
</p>

<p>
<b>拼写检查子进程管理</b>
</p>

<p>
拼写检查子进程启动后会保持运行状态，等待后续操作，因此后续拼写检查命令的执行速度会更快。若需终止该进程，可执行 <code>M-x ispell-kill-ispell</code> 命令。通常无需手动终止，因为该进程仅在执行拼写纠错时占用系统资源，闲置时不会消耗处理器性能。
</p>

<p>
<b>词典配置说明</b>
</p>

<p>
拼写检查程序会从两类词典中查询拼写规则：标准词典与个人词典。
</p>

<ul class="org-ul">
<li>标准词典：由变量 <code>ispell-local-dictionary</code> 指定；若该变量值为 <code>nil</code> ，则使用 <code>ispell-dictionary</code> 的值；若两个变量均为 <code>nil</code> ，则使用拼写程序的默认词典。执行 <code>M-x ispell-change-dictionary</code> 命令可设置当前缓冲区的标准词典，并重启子进程以应用新词典。</li>

<li>个人词典：由变量 <code>ispell-personal-dictionary</code> 指定；若该变量值为空，拼写程序会在各程序的默认路径下查找个人词典。</li>
</ul>

<p>
拼写检查所用的词典通常对应特定语言，默认语言由系统环境与区域设置决定。若需检查其他语言文本的拼写，需同时修改标准词典与个人词典，可通过 <code>ispell-change-dictionary</code> 命令完成配置。
</p>

<p>
Hunspell 特殊功能：Hunspell 支持同时加载多本词典进行拼写检查。若需启用该功能，需在使用 Hunspell 检查混合语言文本前，执行 <code>M-x ispell-hunspell-add-multi-dic</code> 命令，按提示输入以逗号分隔的多语言词典名称列表（例如 'en_US' , 'de_DE' , 'ru_RU' ）。配置完成后，检查混合上述语言的文本时无需频繁切换词典。
</p>

<p>
注意：若多种语言使用同一套书写系统，可能出现 “某单词在一种语言中拼写错误，但在另一语言词典中被判定为正确” 的情况，此时该拼写错误可能被遗漏。
</p>

<p>
<b>单词补全词典</b>
</p>

<p>
单词补全功能使用独立的词典，其文件名由变量 <code>ispell-complete-word-dict</code> 指定。补全词典需与拼写检查词典区分开，因为补全功能无法利用拼写检查所依赖的单词词根与词缀信息来识别单词变体。部分语言仅提供拼写检查词典，无对应的单词补全词典。
</p>

<p>
<b>Flyspell Mode</b>
</p>

<p>
Flyspell 模式是一种次要模式，可在输入文本时自动进行拼写检查。当检测到无法识别的单词时，会高亮标记该单词。执行 <code>M-x flyspell-mode</code> 可在当前缓冲区切换该模式的开关状态。若需在所有文本模式缓冲区中默认启用该模式，可将 <code>flyspell-mode</code> 添加至 <code>text-mode-hook</code> （详见 “<a href="#Hooks">钩子函数</a>” 章节）。
</p>

<p>
注意：由于 Flyspell 模式需要检查光标经过的每个单词，可能会降低光标移动与滚动操作的速度。此外，该模式不会自动检查未输入或未经过的文本，需手动执行 <code>flyspell-region</code> 或 <code>flyspell-buffer</code> 命令进行检查。
</p>

<p>
默认情况下， Flyspell 模式会高亮标记所有输入、修改或光标经过的错误单词。若将变量 <code>flyspell-check-changes</code> 自定义为非空值，则仅检查输入或编辑过的单词。
</p>

<p>
当 Flyspell 模式高亮标记某个错误单词时，可通过以下方式纠错：
</p>

<ul class="org-ul">
<li><code>mouse-2</code> 鼠标中键点击该单词 (<code>flyspell-correct-word</code>) ，会弹出包含候选纠正词与操作选项的菜单；若需改为 <code>mouse-3</code> 鼠标右键弹出菜单，启用 <code>context-menu-mode</code> 即可。</li>
<li>按下 <code>C-.</code> 或 <code>ESC TAB</code> (<code>flyspell-auto-correct-word</code>) ，会依次推荐多个候选纠正词。</li>
<li>按下 <code>C-c $</code> (<code>flyspell-correct-word-before-point</code>) ，会弹出候选纠正词菜单。当然，也可直接手动编辑单词进行纠错。</li>
</ul>

<p>
<b>Flyspell Prog Mode</b>
</p>

<p>
该模式的功能与普通 Flyspell 模式类似，但仅检查代码注释与字符串常量中的拼写，非常适合编辑程序代码。执行 <code>M-x flyspell-prog-mode</code> 可在当前缓冲区切换该模式的开关状态。若需在所有编程模式缓冲区中默认启用该模式，可将 <code>flyspell-prog-mode</code> 添加至 <code>prog-mode-hook</code> （详见 “<a href="#Hooks">钩子函数</a>” 章节）。
</p>
</div>
</div>
</section>
<section id="outline-container-Keyboard-Macros" class="outline-2">
<h2 id="Keyboard-Macros"><span class="section-number-2">19.</span> 键盘宏（Keyboard Macros）</h2>
<div class="outline-text-2" id="text-Keyboard-Macros">
<p>
本章将介绍如何记录一系列编辑命令，以便后续便捷地重复执行。
</p>

<p>
<code>keyboard macro</code> 键盘宏是由 Emacs 用户自定义的命令，用于替代另一组按键序列。例如，若你需要连续四十次输入 <code>C-n M-d C-d</code> 这组操作，可自定义一个执行该操作的键盘宏，随后只需再调用此宏 39 次，即可大幅提升操作效率。
</p>

<p>
定义键盘宏的方式，是通过执行并记录构成该宏的一系列命令。换言之，在定义键盘宏的过程中，其对应的操作会被首次执行。通过这种方式，你能直观看到各命令的执行效果，无需在脑中推演操作结果。完成宏的定义后，该键盘宏即被创建，且实际上已执行过一次；后续只需调用此宏，就能重复执行整套操作。
</p>

<p>
键盘宏与 Emacs 普通命令的区别在于：键盘宏基于 Emacs 命令语言编写，而非 Lisp 语言。这让新手能更轻松地编写键盘宏，也让它作为临时快捷操作时更易用。但 Emacs 命令语言的编程能力有限，无法编写具备智能逻辑或通用型的功能，这类需求则需要使用 Lisp 语言实现。
</p>

<ul class="org-ul">
<li><a href="#Basic-Keyboard-Macro">基本使用</a></li>
<li><a href="#Keyboard-Macro-Ring">键盘宏环（Keyboard Macro Ring）</a></li>
<li><a href="#Keyboard-Macro-Counter">键盘宏计数器</a></li>
<li><a href="#Keyboard-Macro-Query">带变量的宏执行（Executing Macros with Variations）</a></li>
<li><a href="#Save-Keyboard-Macro">键盘宏的命名与保存</a></li>
<li><a href="#Edit-Keyboard-Macro">编辑键盘宏</a></li>
<li><a href="#Keyboard-Macro-Step_002dEdit">逐步编辑键盘宏（Stepwise Editing a Keyboard Macro）</a></li>
<li><a href="#Kmacro-Menu">列出与编辑键盘宏</a></li>
</ul>
</div>
<div id="outline-container-Basic-Keyboard-Macro" class="outline-3">
<h3 id="Basic-Keyboard-Macro"><span class="section-number-3">19.1.</span> 基本使用</h3>
<div class="outline-text-3" id="text-Basic-Keyboard-Macro">
<dl class="org-dl">
<dt><code>F3</code></dt><dd>开始定义键盘宏 (<code>kmacro-start-macro-or-insert-counter</code>) 。</dd>
<dt><code>F4</code></dt><dd>若正处于键盘宏定义状态，则结束定义；否则，执行最近定义的键盘宏 (<code>kmacro-end-or-call-macro</code>) 。</dd>
<dt><code>C-u F3</code></dt><dd>重新执行上一个键盘宏，随后将后续按键追加至该宏的定义中。</dd>
<dt><code>C-u C-u F3</code></dt><dd>直接将后续按键追加至上一个键盘宏的定义，不重新执行该宏。</dd>
<dt><code>C-x C-k r</code></dt><dd>在区域内所有行首执行最近定义的键盘宏 (<code>apply-macro-to-region-lines</code>) 。</dd>
<dt><code>C-x (</code></dt><dd>开始定义键盘宏（旧式快捷键，对应函数 <code>kmacro-start-macro</code> ）；带前缀参数时，将后续操作追加至上一个宏的定义。</dd>
<dt><code>C-x )</code></dt><dd>结束键盘宏定义（旧式快捷键，对应函数 <code>kmacro-end-macro</code> ）；前缀参数作为该宏的执行重复次数。</dd>
<dt><code>C-x e</code></dt><dd>执行最近定义的键盘宏 (<code>kmacro-end-and-call-macro</code>) ；前缀参数作为执行重复次数。</dd>
</dl>

<p>
定义键盘宏时，按下 <code>F3</code> 即可启动。此后你输入的所有按键，会在正常执行操作的同时，被记录为键盘宏的定义内容。此时模式行中会显示 '<code>Def</code>' 标识，提醒当前处于宏定义状态。定义完成后，按下 <code>F4</code> (<code>kmacro-end-or-call-macro</code>) 即可终止宏定义。例如：
</p>

<div class="org-src-container">
<pre class="src src-shell">F3 M-f foo F4
</pre>
</div>

<p>
该操作会定义一个键盘宏，功能为：向前移动一个单词，然后插入文本「foo」。注意， <code>F3</code> 和 <code>F4</code> 本身不会被纳入宏的定义内容。
</p>

<p>
宏定义完成后，按下 <code>F4</code> 即可调用该宏。对于上述示例，调用宏的效果与直接输入 <code>M-f foo</code> 完全一致。（ 需 <b>注意 <code>F4</code> 命令的双重作用</b> ：若处于宏定义过程中，它是结束定义的快捷键；若未处于定义状态，则用于调用最近的键盘宏。）你也可以为 <code>F4</code> 指定数字前缀参数n，表示将该宏连续执行 <code>n</code> 次。若前缀参数为 0，宏会无限重复执行，直至触发错误或你按下 <code>C-g</code> 终止（在 MS-DOS 系统中为 <code>C-Break</code> ）。
</p>

<p>
上述示例体现了键盘宏的一个实用技巧：若你需要在文本中按固定间隔重复某一操作，可将 <b>移动类命令</b> 纳入宏的定义。在该示例中，重复调用宏会在每一个后续单词后插入字符串「foo」，实现按间隔批量操作。
</p>

<p>
终止键盘宏定义后，按下 <code>C-u F3</code> 可将后续按键追加至该宏的定义末尾。该操作等效于重新按下 <code>F3</code> 启动定义，并手动重新输入宏的原有所有内容，因此会先重新执行一次该宏的原有定义。若将变量 <code>kmacro-execute-before-append</code> 的值设为 <code>nil</code> ，则追加定义前不会重新执行原有宏（该变量默认值为 <code>t</code> ）。若想直接追加定义而不执行原有宏，可按下 <code>C-u C-u F3</code> 。
</p>

<p>
当宏定义中包含需要通过迷你缓冲区读取参数的命令时，你在迷你缓冲区中输入的内容，会与该命令一同被记录到宏定义中。因此回放该宏时，该命令会使用定义宏时输入的相同参数。例如：
</p>

<div class="org-src-container">
<pre class="src src-shell">F3 C-a C-k C-x b foo RET C-y C-x b RET F4
</pre>
</div>

<p>
该操作定义的键盘宏，功能为：删除当前行，将其粘贴至缓冲区「foo」，随后返回原缓冲区。
</p>

<p>
绝大多数键盘命令在宏定义中均可正常使用，仅存在少量例外：
</p>
<ul class="org-ul">
<li>按下 <code>C-g</code> (<code>keyboard-quit</code>) 会直接终止当前的键盘宏定义；</li>
<li>按下 <code>C-M-c</code> (<code>exit-recursive-edit</code>) 的行为不可靠：若退出的是宏定义过程中启动的递归编辑，其行为符合预期；但若退出的是调用键盘宏前就已启动的递归编辑，该操作会同时终止键盘宏的执行；</li>
<li>鼠标事件同样存在不确定性：尽管宏定义中可以记录鼠标操作，但回放宏时，鼠标事件会使用 <b>定义宏时的原始鼠标位置</b> ，而非回放时的鼠标位置，其执行效果难以预测。</li>
</ul>

<p>
命令 <code>C-x C-k r</code> (<code>apply-macro-to-region-lines</code>) 的作用是，在选中区域内 <b>所有行的行首</b> 执行最近定义的键盘宏。该命令会逐行执行：先将光标移至行首，再调用键盘宏。
</p>

<p>
除上述 <code>F3</code> 和 <code>F4</code> 的新式快捷键外，Emacs 还支持一套定义和执行键盘宏的 <b>旧式快捷键</b> ：
</p>
<ul class="org-ul">
<li><code>C-x (</code> (<code>kmacro-start-macro</code>) 启动宏定义，与 <code>F3</code> 一致，带前缀参数时会将操作追加至上一个宏；</li>
<li><code>C-x )</code> (<code>kmacro-end-macro</code>) 结束宏定义；</li>
<li><code>C-x e</code> (<code>kmacro-end-and-call-macro</code>) 执行最近定义的宏。</li>
</ul>

<p>
若在宏定义过程中按下 <code>C-x e</code> ，会直接终止定义并立即执行该宏。在首次按下 <code>C-x e</code> 后，可连续按下 <code>e</code> 键，多次重复执行该宏；也可像 <code>F4</code> 一样，为 <code>C-x e</code> 指定前缀参数，作为宏的执行重复次数。
</p>

<p>
为 <code>C-x )</code> 指定数字前缀参数时，表示定义完成后立即重复执行该宏。由于宏的定义过程本身就是首次执行，因此 <code>C-u 4 C-x )</code> 表示在定义完成后，再额外执行该宏 3 次。
</p>

<p>
执行耗时较长的键盘宏时，有时需要手动触发屏幕重绘，以查看宏的执行进度，此时可使用命令 <code>C-x C-k d</code> 。举一个简单的示例： <code>C-x ( M-f C-x C-k d C-x )</code> 定义的宏，在执行 <code>C-u 42 C-x e</code> 时，会在每次迭代中触发一次屏幕重绘。
</p>
</div>
</div>
<div id="outline-container-Keyboard-Macro-Ring" class="outline-3">
<h3 id="Keyboard-Macro-Ring"><span class="section-number-3">19.2.</span> 键盘宏环（Keyboard Macro Ring）</h3>
<div class="outline-text-3" id="text-Keyboard-Macro-Ring">
<p>
所有已定义的键盘宏都会记录在 <b>键盘宏环</b> 中。Emacs 中仅有一个键盘宏环，供所有缓冲区共享使用。
</p>
<dl class="org-dl">
<dt><code>C-x C-k C-k</code></dt><dd>执行宏环首位置的键盘宏 (<code>kmacro-end-or-call-macro-repeat</code>) 。</dd>
<dt><code>C-x C-k C-n</code></dt><dd>轮换键盘宏环至下一个宏（更早定义的宏）(<code>kmacro-cycle-ring-next</code>) 。</dd>
<dt><code>C-x C-k C-p</code></dt><dd>轮换键盘宏环至上一个宏（更晚定义的宏）(<code>kmacro-cycle-ring-previous</code>) 。</dd>
</dl>

<p>
所有对键盘宏环进行操作的命令，均使用统一的 <code>C-x C-k</code> 前缀。这类命令中的绝大多数，可连续执行和重复调用，无需再次输入 <code>C-x C-k</code> 前缀。例如：
</p>

<div class="org-src-container">
<pre class="src src-shell">C-x C-k C-p C-p C-k C-k C-k C-n C-n C-k C-p C-k C-d
</pre>
</div>

<p>
该操作的执行逻辑为：将键盘宏环轮换至倒数第二个宏，执行当前宏环首位置的该宏三次，轮换回宏环原本的首位置宏并执行一次，再轮换至上一个宏并执行，最后将该宏从宏环中删除。
</p>

<p>
命令 <code>C-x C-k C-k</code> (<code>kmacro-end-or-call-macro-repeat</code>) 用于执行宏环首位置的键盘宏。执行后可直接按下 <code>C-k</code> 重复调用该宏，也可直接按下 <code>C-n</code> 或 <code>C-p</code> 对宏环进行轮换操作。
</p>

<p>
若正处于键盘宏定义状态， <code>C-x C-k C-k</code> 的功能与 <code>F4</code> 一致，区别在于执行该命令后，可直接使用本节的大部分快捷键，无需再次输入 <code>C-x C-k</code> 前缀。例如，直接按下 <code>C-k</code> 即可重新执行该宏。
</p>

<p>
命令 <code>C-x C-k C-n</code> (<code>kmacro-cycle-ring-next</code>) 和 <code>C-x C-k C-p</code> (<code>kmacro-cycle-ring-previous</code>) 用于轮换键盘宏环，将下一个 / 上一个键盘宏移至宏环的首位置，新的宏环首位置宏的定义内容会显示在回显区中。操作后可直接连续按下 <code>C-n</code> 或 <code>C-p</code> 继续轮换宏环，直至目标宏出现在宏环首位置；若要立即执行新的宏环首位置宏，直接按下 <code>C-k</code> 即可。
</p>

<p>
请注意，Emacs 将 <b>宏环首位置的宏</b> 视作最近定义的键盘宏。例如，按下 <code>F4</code> 会执行该宏，执行 <code>C-x C-k n</code> 可为该宏命名。
</p>

<p>
键盘宏环中可存储的宏的最大数量，由可自定义变量 <code>kmacro-ring-max</code> 决定。
</p>
</div>
</div>
<div id="outline-container-Keyboard-Macro-Counter" class="outline-3">
<h3 id="Keyboard-Macro-Counter"><span class="section-number-3">19.3.</span> 键盘宏计数器</h3>
<div class="outline-text-3" id="text-Keyboard-Macro-Counter">
<p>
每个键盘宏都配有一个关联的 <b>计数器</b> ，启动宏定义时，该计数器会初始化为 0。借助这个当前计数器，你可以在缓冲区中插入一个数值，该数值会根据宏的调用次数动态变化。默认情况下，每当计数器的数值被插入缓冲区时，其值会自动递增。
</p>

<p>
除当前计数器外，键盘宏还会维护一个 <b>历史计数器</b> ，用于记录当前计数器上一次被递增或设置时的数值。请注意，若将当前计数器的递增值设为 0（例如执行 <code>C-u 0 C-x C-k C-i</code> ），当前计数器的数值也会被记录为历史计数器的数值。
</p>

<dl class="org-dl">
<dt><code>F3</code></dt><dd>在键盘宏定义过程中，将键盘宏计数器的当前值插入缓冲区 (<code>kmacro-start-macro-or-insert-counter</code>) 。</dd>
<dt><code>C-x C-k C-i</code></dt><dd>将键盘宏计数器的当前值插入缓冲区 (<code>kmacro-insert-counter</code>) 。</dd>
<dt><code>C-x C-k C-c</code></dt><dd>设置键盘宏计数器的数值 (<code>kmacro-set-counter</code>) 。</dd>
<dt><code>C-x C-k C-a</code></dt><dd>将前缀参数的值累加至键盘宏计数器 (<code>kmacro-add-counter</code>) 。</dd>
<dt><code>C-x C-k C-f</code></dt><dd>指定键盘宏计数器的插入格式 (<code>kmacro-set-format</code>) 。</dd>
</dl>

<p>
在定义键盘宏时，执行命令 <code>F3</code> (<code>kmacro-start-macro-or-insert-counter</code>) 会将该宏计数器的当前值插入缓冲区，且计数器值自动加 1。（若未处于宏定义状态， <code>F3</code> 的功能为启动宏定义，详见「<a href="#Basic-Keyboard-Macro">基础使用</a>」章节。）你可以通过指定数字前缀参数，设置非 1 的自定义递增值；若仅指定 <code>C-u</code> 作为前缀，该操作会插入 <b>历史计数器</b> 的数值，且不会修改当前计数器的数值。
</p>

<p>
以下举例说明如何使用键盘宏计数器制作带编号的列表，执行如下按键序列即可实现：
</p>

<div class="org-src-container">
<pre class="src src-shell">F3 C-a F3 . SPC F4
</pre>
</div>

<p>
在该键盘宏的定义过程中，字符串 '0. ' 会被插入当前行首。若此时将光标移至缓冲区其他位置，按下 <code>F4</code> 调用该宏，目标行首会插入字符串 '1. '；后续每一次调用宏，会依次插入'2. '、'3. '，依此类推。
</p>

<p>
命令 <code>C-x C-k C-i</code> (<code>kmacro-insert-counter</code>) 的功能与宏定义中的 <code>F3</code> 完全一致，且可在 <b>宏定义之外</b> 的场景使用。当未定义或执行任何键盘宏时，该命令会插入 <b>键盘宏环首位置</b> 对应宏的计数器值，并完成计数器的递增。
</p>

<p>
命令 <code>C-x C-k C-c</code> (<code>kmacro-set-counter</code>) 可将当前宏计数器的数值设为前缀参数指定的数字。若在宏内部执行该命令，其设置会作用于宏的每一次重复执行；若在宏执行过程中仅指定 <code>C-u</code> 作为前缀，该操作会将计数器重置为 <b>本次宏迭代开始</b> 时的数值，撤销本次迭代中对计数器的所有递增操作。
</p>

<p>
命令 <code>C-x C-k C-a</code> (<code>kmacro-add-counter</code>) 会将前缀参数的数值累加至当前宏计数器。若仅指定 <code>C-u</code> 作为参数，该操作会将计数器重置为 <b>任意键盘宏上一次插入的数值</b> （通常情况下，该数值为当前宏上一次插入的计数器值）。
</p>

<p>
命令 <code>C-x C-k C-f</code> (<code>kmacro-set-format</code>) 会通过迷你缓冲区提示你输入计数器的 <b>插入格式字符串</b> ，默认格式为 '<code>%d</code>' ，表示以无补位的十进制形式插入数字。若在迷你缓冲区中直接回车，可将格式重置为该默认值。你可以输入 <code>format</code> 函数支持的任意格式字符串，且该字符串需适配 <b>单个整数</b> 作为额外参数的使用场景（详见《Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Formatting-Strings.html#Formatting-Strings">格式化字符串</a>」章节）。在迷你缓冲区中输入格式字符串时， <b>无需添加双引号</b> 。
</p>

<p>
若在未定义或执行任何键盘宏时执行该命令，新设置的格式会作用于 <b>后续所有新建的宏</b> ，已存在的宏仍会使用其定义时生效的格式；若在定义键盘宏的过程中设置格式，该设置仅对 <b>当前正在定义的宏</b> 从设置节点开始生效，不会影响其他宏。宏执行时，每一步的计数器插入都会使用 <b>其定义时对应步骤生效的格式</b> ；在宏执行过程中修改计数器格式，与在宏定义过程中修改的效果一致，均不会影响其他宏。
</p>

<p>
通过 <code>C-x C-k C-f</code> 设置的格式， <b>不会影响</b> 寄存器中存储数值的插入方式。
</p>

<p>
你也可以将寄存器用作计数器，在宏的每一次重复执行中实现递增，其效果与键盘宏计数器完全一致（详见「<a href="#Number-Registers">在寄存器中保存数字</a>」章节）。但对于绝大多数使用场景，直接使用键盘宏计数器会更简便。
</p>
</div>
</div>
<div id="outline-container-Keyboard-Macro-Query" class="outline-3">
<h3 id="Keyboard-Macro-Query"><span class="section-number-3">19.4.</span> 带变量的宏执行（Executing Macros with Variations）</h3>
<div class="outline-text-3" id="text-Keyboard-Macro-Query">
<p>
在键盘宏中，你可以实现类似 <code>query-replace</code> 查询替换的效果，让宏在每次执行时都向你确认是否执行修改操作。
</p>

<dl class="org-dl">
<dt><code>C-x q</code></dt><dd>宏执行至该位置时，弹出确认提示 (<code>kbd-macro-query</code>) 。</dd>
</dl>

<p>
定义宏时，在需要触发确认的位置按下 <code>C-x q</code> 即可。宏定义过程中，该按键不会产生任何效果；但后续执行该宏时，运行到该位置会弹出交互式确认，询问是否继续执行。
</p>

<p>
当 <code>C-x q</code> 触发确认时，可输入以下有效响应：
</p>
<dl class="org-dl">
<dt><code>SPC</code> (or <code>y</code>)</dt><dd>继续执行该键盘宏。</dd>
<dt><code>DEL</code> (or <code>n</code>)</dt><dd>跳过本次宏迭代的剩余操作，直接开始下一次迭代。</dd>
<dt><code>RET</code> (or <code>q</code>)</dt><dd>跳过本次宏迭代的剩余操作，并取消后续所有宏迭代。</dd>
<dt><code>C-r</code></dt><dd>进入递归编辑模式，可在该模式下执行非宏定义内的编辑操作。使用 <code>C-M-c</code> 退出递归编辑后，会再次弹出宏执行的确认提示；此时按下 <code>SPC</code> 空格，将继续执行该宏的剩余定义操作。你需要自行保证退出递归编辑时，光标和文本的状态能让宏的后续操作达到预期效果。</dd>
</dl>

<p>
带前缀参数的 <code>C-u C-x q</code> ，功能与普通的 <code>C-x q</code> 完全不同。无论是在 <b>宏定义过程中</b> 按下该组合键，还是在 <b>宏执行过程中</b> 触发该操作，都会进入递归编辑模式并从键盘读取输入。
</p>
<ul class="org-ul">
<li>宏定义阶段：在该递归编辑中执行的操作， <b>不会被记录到宏定义</b> 中；</li>
<li>宏执行阶段：该递归编辑为每次宏迭代提供了执行 <b>个性化编辑操作</b> 的机会。详见「<a href="#Recursive-Edit">递归编辑层级</a>」章节。</li>
</ul>
</div>
</div>
<div id="outline-container-Save-Keyboard-Macro" class="outline-3">
<h3 id="Save-Keyboard-Macro"><span class="section-number-3">19.5.</span> 键盘宏的命名与保存</h3>
<div class="outline-text-3" id="text-Save-Keyboard-Macro">
<dl class="org-dl">
<dt><code>C-x C-k n</code></dt><dd>为最近定义的键盘宏指定命令名（有效期为当前 Emacs 会话） (<code>kmacro-name-last-macro</code>) 。</dd>
<dt><code>C-x C-k b</code></dt><dd>将最近定义的键盘宏绑定至某一按键序列（有效期为当前会话）(<code>kmacro-bind-to-key</code>) 。</dd>
<dt><code>M-x insert-kbd-macro</code></dt><dd>将键盘宏的定义以 Lisp 代码形式插入缓冲区。</dd>
</dl>

<p>
若你希望保存键盘宏以供后续使用，可通过 <code>C-x C-k n</code> (<code>kmacro-name-last-macro</code>) 为其命名。该命令会通过迷你缓冲区读取一个名称作为参数，并将该名称定义为执行当前形式的最新键盘宏的指令（若后续你为该宏追加了新的定义内容，此命名对应的宏定义 <b>不会</b> 随之改变）。宏的名称为 Lisp 符号，通过此方式定义后，该名称将成为有效的命令名，可通过 <code>M-x</code> 调用，也可通过 <code>keymap-global-set</code> 为其绑定按键（详见「<a href="#Keymaps">键盘映射</a>」章节）。若你指定的名称已有非键盘宏类型的原有定义，系统会弹出错误提示，且不会对原有设置做任何修改。
</p>

<p>
你也可使用 <code>C-x C-k b</code> (<code>kmacro-bind-to-key</code>) 将最新的键盘宏（当前形式）绑定至指定按键序列，执行该命令后输入想要绑定的按键序列即可。该命令可将宏绑定至全局键盘映射中的任意按键序列，但由于多数按键序列已有其他绑定功能，你需要谨慎选择。若你尝试绑定的按键序列在任意键盘映射中已有绑定，该命令会在替换原有绑定前向你确认。
</p>

<p>
为避免因覆盖原有绑定引发问题， <code>C-x C-k 0</code> 至 <code>C-x C-k 9</code> 以及 <code>C-x C-k A</code> 至 <code>C-x C-k Z</code> 这些按键序列被预留出来，专供你绑定自定义键盘宏使用。实际上，绑定这类预留按键序列时，你只需输入对应的数字或字母，无需输入完整的按键序列。例如：
</p>

<div class="org-src-container">
<pre class="src src-shell">C-x C-k b 4
</pre>
</div>

<p>
该操作会将最新的键盘宏绑定至按键序列 <code>C-x C-k 4</code> 。
</p>

<p>
当键盘宏拥有命令名后，你可将其定义保存至文件中，以便在其他编辑会话中使用。操作步骤如下：
</p>

<ul class="org-ul">
<li>打开你想要保存宏定义的文件；</li>
<li>执行命令：</li>
</ul>

<div class="org-src-container">
<pre class="src src-shell">M-x insert-kbd-macro RET macroname RET
</pre>
</div>

<p>
该命令会在缓冲区中插入一段 Lisp 代码，这段代码在后续执行时，会定义出与当前宏完全一致的键盘宏（你无需理解 Lisp 代码，因为 <code>insert-kbd-macro</code> 会自动为你生成对应的代码）。之后保存该文件即可，后续可通过 <code>load-file</code> 命令加载此文件（详见「<a href="#Lisp-Libraries">Emacs 的 Lisp 代码库</a>」章节）。若你将宏定义保存至初始化文件 <code>~/.emacs</code> 中（详见「<a href="#Init-File">Emacs 初始化文件</a>」章节），则每次启动 Emacs 时，该宏都会被自动定义。
</p>

<p>
若为 <code>insert-kbd-macro</code> 指定前缀参数，该命令会额外生成一段 Lisp 代码，记录你为该宏名绑定的所有按键（若有），这样在你加载文件时，该宏会被重新分配至原有绑定的按键
</p>
</div>
</div>
<div id="outline-container-Edit-Keyboard-Macro" class="outline-3">
<h3 id="Edit-Keyboard-Macro"><span class="section-number-3">19.6.</span> 编辑键盘宏</h3>
<div class="outline-text-3" id="text-Edit-Keyboard-Macro">
<dl class="org-dl">
<dt><code>C-x C-k C-e</code></dt><dd>编辑最近定义的键盘宏 (<code>kmacro-edit-macro</code>) 。</dd>
<dt><code>C-x C-k e 宏名 RET</code></dt><dd>编辑已定义的指定名称的键盘宏 (<code>edit-kbd-macro</code>) 。</dd>
<dt><code>C-x C-k l</code></dt><dd>将最近的 300 次按键操作作为键盘宏进行编辑 (<code>kmacro-edit-lossage</code>) 。</dd>
</dl>

<p>
按下 <code>C-x C-k C-e</code> 或 <code>C-x C-k RET</code> (<code>kmacro-edit-macro</code>) ，即可编辑最近定义的键盘宏。该命令会将宏的定义格式化后展示在专属缓冲区中，并进入编辑宏的专用主模式。在该缓冲区中按下 <code>C-h m</code> ，可查看编辑宏的详细操作说明；编辑完成后，按下 <code>C-c C-c</code> 即可保存修改并退出编辑。
</p>

<p>
<code>kmacro-edit-macro</code> 所使用的 <code>edmacro-mode</code> （宏编辑主模式）提供了一系列便捷命令，用于编辑格式化后的宏定义：按下 <code>C-c C-q</code> (<code>edmacro-insert-key</code>) ，可将后续输入的按键序列按正确格式插入缓冲区，功能与 <code>C-q</code> (<code>quoted-insert</code>) 类似；按下 <code>C-c C-r</code> (<code>edmacro-set-macro-to-region-lines</code>) ，可将选中区域的文本替换为宏的定义内容。若选中的区域并非从行首开始或至行尾结束，该命令会自动扩展区域以包含完整行；若区域结束于某行的行首，则该最后一行不会被纳入替换范围。
</p>

<p>
若要编辑已命名的键盘宏，或绑定至按键的键盘宏，可按下 <code>C-x C-k e</code> (<code>edit-kbd-macro</code>) ，随后输入调用该宏的方式即可 —— 无论是 <code>C-x e</code> 、 <code>M-x name</code> ，还是其他绑定的按键序列均可。
</p>

<p>
按下 <code>C-x C-k l</code> (<code>kmacro-edit-lossage</code>) ，可将最近的 300 次按键操作提取出来，作为键盘宏进行编辑。默认情况下，最新的按键操作会显示在缓冲区的末尾；若将变量 <code>edmacro-reverse-macro-lines</code> 设为 <code>t</code> ，宏的按键序列会以倒序形式展示。
</p>
</div>
</div>
<div id="outline-container-Keyboard-Macro-Step_002dEdit" class="outline-3">
<h3 id="Keyboard-Macro-Step_002dEdit"><span class="section-number-3">19.7.</span> 逐步编辑键盘宏（Stepwise Editing a Keyboard Macro）</h3>
<div class="outline-text-3" id="text-Keyboard-Macro-Step_002dEdit">
<p>
按下 <code>C-x C-k SPC</code> (<code>kmacro-step-edit-macro</code>) ，来交互式地逐步重放并编辑上一个键盘宏，每次处理一条命令。除非你按下 <code>q</code> 或 <code>C-g</code> 退出宏编辑，否则编辑后的宏将替换宏环中最新的那个宏。
</p>

<p>
该宏编辑功能会在迷你缓冲区中显示最新的宏定义，同时标注即将执行的第一条（或下一条）命令，并弹出提示让你选择执行操作。输入 '<code>?</code>' 可查看所有操作选项的说明，可用操作如下：
</p>

<dl class="org-dl">
<dt><code>SPC</code> 、 <code>y</code></dt><dd>执行当前命令，并跳至键盘宏中的下一条命令。</dd>
<dt><code>n</code> 、 <code>d</code> 、 <code>DEL</code></dt><dd>跳过并删除当前命令。</dd>
<dt><code>f</code></dt><dd>在本次宏执行中跳过当前命令，但不将其从宏定义中删除。</dd>
<dt><code>TAB</code></dt><dd>执行当前命令，同时执行紧随其后的所有同类命令；例如，可使用 <code>TAB</code> 执行一串字符的插入操作（对应连续的自插入命令）。</dd>
<dt><code>c</code> </dt><dd>继续执行宏（不再进行后续编辑），直至宏定义结束。若执行正常终止，编辑后的宏将替换原宏。</dd>
<dt><code>C-k</code></dt><dd>跳过并删除键盘宏中剩余的所有命令，终止逐步编辑，并用编辑后的宏替换原宏。</dd>
<dt><code>q</code> 、 <code>C-g</code></dt><dd>取消键盘宏的逐步编辑，丢弃对宏所做的所有修改。</dd>
<dt><code>i key.. C-j</code></dt><dd>读取并执行一串按键序列（不包含最后的 <code>C-j</code> ），将其插入到键盘宏中当前命令的前方，且不跳至下一条命令。</dd>
<dt><code>I key..</code></dt><dd>读取并执行一个按键序列，将其插入到键盘宏中当前命令的前方，且不跳至下一条命令。</dd>
<dt><code>r key.. C-j</code></dt><dd>读取并执行一串按键序列（不包含最后的  <code>C-j</code> ），用其替换键盘宏中的当前命令，并跳至插入的按键序列之后。</dd>
<dt><code>R key..</code></dt><dd>读取并执行一个按键序列，用其替换键盘宏中的当前命令，并跳至插入的按键序列之后。</dd>
<dt><code>a key.. C-j</code></dt><dd>先执行当前命令，再读取并执行一串按键序列（不包含最后的 <code>C-j</code> ），将其插入到键盘宏中当前命令的后方；随后跳至当前命令与插入序列之后的下一条命令。</dd>
<dt><code>A key.. C-j</code></dt><dd>先执行键盘宏中剩余的所有命令，再读取并执行一串按键序列（不包含最后的 <code>C-j</code> ），将其追加至键盘宏的末尾；随后终止逐步编辑，并用编辑后的宏替换原宏。</dd>
</dl>
</div>
</div>
<div id="outline-container-Kmacro-Menu" class="outline-3">
<h3 id="Kmacro-Menu"><span class="section-number-3">19.8.</span> 列出与编辑键盘宏</h3>
<div class="outline-text-3" id="text-Kmacro-Menu">
<p>
执行命令 <code>M-x list-keyboard-macros RET</code> ，即可显示现有所有键盘宏的列表。该命令会在名为 <code>*Keyboard Macro List*</code> 的缓冲区中弹出 <code>Kmacro Menu 宏操作菜单</code> ，列表中每一行对应一个宏，展示其位置编号、计数器值、计数器格式、格式化后的计数值以及宏的按键序列。以下是宏列表的示例：
</p>

<div class="org-src-container">
<pre class="src src-shell">Position  Counter  Format  Formatted  Keys
0               8  %02d    08         N : SPC &lt;F3&gt; RET
1               0  %d      0          l o n g SPC p h r a s e
</pre>
</div>

<p>
宏列表的排序规则为：当前最新的宏排在顶部，位置编号为 0，其余旧宏按 <b>键盘宏环</b> 中的存储顺序依次排列（详见「<a href="#Keyboard-Macro-Ring">键盘宏环</a>」章节）。通过该宏操作菜单，你可调整宏的排序、修改宏的计数器值、计数器格式及按键序列。此菜单所在的缓冲区为只读模式，仅能通过本节介绍的专用命令进行修改。执行任意修改命令后，宏操作菜单会实时刷新，展示宏属性和宏环的最新状态。在该缓冲区中，既可使用 Emacs 常规的光标移动命令，也可使用菜单专属的导航命令；按下 <code>C-h m</code> 或 '<code>?</code>' (<code>describe-mode</code>) ，即可查看所有专用命令的说明。
</p>

<p>
你可使用以下命令修改宏的属性（操作时光标置于对应宏的行上即可）：
</p>
<dl class="org-dl">
<dt><code>#</code></dt><dd>修改当前行对应宏在宏环中的位置编号（详见「<a href="#Keyboard-Macro-Ring">键盘宏环</a>」章节）。</dd>
<dt><code>C-x C-t</code></dt><dd>将当前行的宏上移一行，功能与文本行交换命令 <code>transpose-lines</code> 一致。</dd>
<dt><code>c</code></dt><dd>修改当前行对应宏的计数器值（详见「<a href="#Keyboard-Macro-Counter">键盘宏计数器</a>」章节）。</dd>
<dt><code>f</code></dt><dd>修改当前行对应宏的计数器格式。</dd>
<dt><code>e</code></dt><dd>调用 <code>edit-kbd-macro</code> 命令，编辑当前行对应宏的按键序列（详见「<a href="#Edit-Keyboard-Macro">编辑键盘宏</a>」章节）。</dd>
<dt><code>RET</code></dt><dd>修改当前光标所在列对应的宏属性，自动调用上述对应属性的修改命令。</dd>
</dl>

<p>
以下命令用于在列表中删除或复制宏：
</p>
<dl class="org-dl">
<dt><code>d</code></dt><dd></dd>

<dt>d（宏操作菜单专用）</dt><dd>为当前行的宏标记删除标识，随后光标移至下一行 (<code>kmacro-menu-flag-for-deletion</code>) 。行首出现字符 <code>D</code> 即表示标记成功，标记的宏仅在执行 <code>x</code> 命令后才会被真正删除（见下文）。若当前存在激活的选中区域，该命令会为区域内所有宏标记删除标识。</dd>
<dt><code>x</code></dt><dd></dd>

<dt>x （宏操作菜单专用）</dt><dd>删除列表中所有已标记删除标识的宏 (<code>kmacro-menu-do-flagged-delete</code>) 。</dd>
<dt><code>m</code></dt><dd></dd>

<dt>m（宏操作菜单专用）</dt><dd>为当前行的宏添加标记，随后光标移至下一行 (<code>kmacro-menu-mark</code>) 。行首出现字符 '<code>*</code>' 即表示标记成功，已标记的宏可被 <code>C</code> 和 <code>D</code> 命令批量操作（见下文）。若当前存在激活的选中区域，该命令会为区域内所有宏添加标记。</dd>
<dt><code>C</code></dt><dd></dd>

<dt>C（宏操作菜单专用）</dt><dd>复制宏，在宏当前的列表位置插入副本 (<code>kmacro-menu-do-copy</code>) 。例如，对位置 0 的宏执行该命令，会在位置 1 插入其副本，原位置 1 及之后的宏均顺次下移。若存在激活的选中区域，批量复制区域内所有宏；若无选中区域但有已标记的宏，批量复制所有标记宏；若既无选中区域也无标记宏，仅复制当前行的宏。前两种批量复制的场景下，命令会先弹出确认提示，确认后再执行复制。</dd>
<dt><code>D</code></dt><dd></dd>

<dt>D（宏操作菜单专用）</dt><dd><p>
删除宏并将其从宏环中移除 (<code>kmacro-menu-do-delete</code>) 。例如，对位置 0 的宏执行该命令，会删除该宏，原位置 1 的宏将成为新的当前宏并移至位置 0，同时从宏环中弹出。
</p>

<p>
若存在激活的选中区域，批量删除区域内所有宏；若无选中区域但有已标记的宏，批量删除所有标记宏；若既无选中区域也无标记宏，仅删除当前行的宏。所有场景下，命令都会先弹出确认提示，确认后再执行删除。
</p>

<p>
该命令是 <code>d</code> 和 <code>x</code> 删除方式的替代方案。
</p></dd>
<dt><code>u</code></dt><dd></dd>

<dt>u（宏操作菜单专用）</dt><dd>取消当前行宏的标记和删除标识，随后光标下移至下一行 (<code>kmacro-menu-unmark</code>) 。若存在激活的选中区域，取消区域内所有宏的标记和删除标识。</dd>
<dt><code>DEL</code></dt><dd></dd>

<dt>DEL （宏操作菜单专用）</dt><dd>功能与 <code>u</code> 命令一致（见上文）；若当前无激活的选中区域，操作后光标会上移至上一行 (<code>kmacro-menu-unmark-backward</code>) 。</dd>
<dt><code>U</code></dt><dd></dd>

<dt>U（宏操作菜单专用）</dt><dd>取消列表中所有宏的标记和删除标识 (<code>kmacro-menu-unmark-all</code>) 。</dd>
</dl>
</div>
</div>
</section>
<section id="outline-container-Files" class="outline-2">
<h2 id="Files"><span class="section-number-2">20.</span> 文件处理</h2>
<div class="outline-text-2" id="text-Files">
<p>
操作系统将数据永久存储在命名 <code>files文件</code> 中，因此你使用 Emacs 编辑的大部分文本都来自文件，最终也会保存到文件中。
</p>

<p>
要编辑文件，你需要让 Emacs 读取该文件并创建一个包含文件文本副本的缓冲区，这一操作称为 <code>visiting 访问</code> 文件。编辑命令直接作用于缓冲区中的文本，即 Emacs 内部的这份副本；只有当你将缓冲区内容回存到文件时，所做的修改才会体现在文件本身中。
</p>

<p>
除了访问和保存文件，Emacs 还支持删除、复制、重命名、追加文件内容，保留文件的多个版本，以及对文件目录进行操作。
</p>

<ul class="org-ul">
<li><a href="#File-Names">文件名</a></li>
<li><a href="#Visiting">打开文件（Visiting Files）</a></li>
<li><a href="#Saving">保存文件</a></li>
<li><a href="#Reverting">恢复缓冲区（Reverting a Buffer）</a></li>
<li><a href="#Auto-Revert">自动恢复：保持缓冲区自动更新（Auto Revert）</a></li>
<li><a href="#Auto-Save">自动保存：防止数据丢失（Auto-Saving）</a></li>
<li><a href="#File-Aliases">文件名别名（File Name Aliases）</a></li>
<li><a href="#Directories">文件目录（File Directories）</a></li>
<li><a href="#Comparing-Files">文件比较</a></li>
<li><a href="#Diff-Mode">差异模式</a></li>
<li><a href="#Copying-and-Naming">文件的复制、命名与重命名</a></li>
<li><a href="#Misc-File-Ops">各类文件操作</a></li>
<li><a href="#Compressed-Files">访问压缩文件</a></li>
<li><a href="#File-Archives">文件归档包</a></li>
<li><a href="#Remote-Files">远程文件</a></li>
<li><a href="#Quoted-File-Names">带引用的文件名</a></li>
<li><a href="#File-Name-Cache">文件名缓存</a></li>
<li><a href="#File-Conveniences">查找文件的便捷功能</a></li>
<li><a href="#Image-Mode">查看图像文件</a></li>
<li><a href="#Filesets">文件集（Filesets）</a></li>
</ul>
</div>
<div id="outline-container-File-Names" class="outline-3">
<h3 id="File-Names"><span class="section-number-3">20.1.</span> 文件名</h3>
<div class="outline-text-3" id="text-File-Names">
<p>
Emacs 中许多对文件执行操作的命令，都需要你通过迷你缓冲区指定文件名（参见《<a href="#Minibuffer-File">文件名与迷你缓冲区</a>》章节）。
</p>

<p>
在迷你缓冲区中，你可以使用常规的补全和历史记录命令（参见《<a href="#Minibuffer">迷你缓冲区</a>》章节）。注意，文件名补全会忽略扩展名出现在变量 <code>completion-ignored-extensions</code> 中的文件（参见《<a href="#Completion-Options">补全选项</a>》章节）。此外，大多数读取文件名的命令会采用 <b>带确认的宽松补全</b> 方式：你可以输入不存在的文件名，但如果在补全到一个不存在的文件名后直接按下 <code>RET</code> 回车键，Emacs 会显示 '[Confirm 确认]'，你需要再次按下 <code>RET</code> 回车键完成确认。详细说明参见《<a href="#Completion-Exit">补全的退出方式</a>》章节。
</p>

<p>
迷你缓冲区的历史记录命令在读取文件名时提供了一些特殊功能，参见《<a href="#Minibuffer-History">迷你缓冲区历史记录</a>》章节。
</p>

<p>
每个缓冲区都有一个 <b>default directory默认目录</b> ，存储在缓冲区局部变量 <code>default-directory</code> 中。每当 Emacs 通过迷你缓冲区读取文件名时，通常会将默认目录作为初始内容插入到迷你缓冲区中。你可以将变量 <code>insert-default-directory</code> 设为nil，禁止该插入行为（参见《<a href="#Minibuffer-File">文件名与迷你缓冲区</a>》章节）。无论是否插入默认目录，Emacs 始终将所有相对文件名解析为相对于默认目录的路径，例如，输入不带目录的文件名，即表示默认目录下的该文件。
</p>

<p>
当你访问一个文件时，Emacs 会将该访问缓冲区的 <code>default-directory</code> 设为该文件所在的目录。当你通过 <code>C-x b</code> 这类命令创建一个未访问任何文件的新缓冲区时，其默认目录通常会从创建时的当前缓冲区复制而来（参见《<a href="#Select-Buffer">缓冲区的创建与选择</a>》章节）。你可以使用命令 <code>M-x pwd</code> 查看当前缓冲区的 <code>default-directory</code> 值。命令 <code>M-x cd</code> 会提示你输入目录名，并将当前缓冲区的 <code>default-directory</code> 设为该目录（此操作不会改变缓冲区对应的文件名，若有）。
</p>

<p>
举个例子，当你访问文件 <code>/u/rms/gnu/gnu.tasks</code> 时，默认目录会被设为 <code>/u/rms/gnu/</code> 。此时若调用一个读取文件名的命令，在迷你缓冲区中仅输入 '<code>foo</code>' （省略目录），表示文件 <code>/u/rms/gnu/foo</code> ；输入 '<code>../.login</code>' ，表示文件 <code>/u/rms/.login</code> ；输入 '<code>new/foo</code>' ，表示文件 <code>/u/rms/gnu/new/foo</code> 。
</p>

<p>
在迷你缓冲区中输入文件名时，你可以使用两个快捷方式： <b>//双斜杠</b> 会忽略该双斜杠中第二个斜杠之前的所有内容， '<code>~/</code>' 则代表你的 <b>主目录</b> 。参见《<a href="#Minibuffer-File">文件名与迷你缓冲区</a>》章节。
</p>

<p>
字符 '<code>$</code>' 用于在文件名中 <b>替换环境变量</b> 。环境变量名由 '<code>$</code>' 之后的所有字母数字字符组成；你也可以将环境变量名用大括号包裹后跟在 '<code>$</code>' 之后。例如，若你通过 Shell 命令输入 <code>export FOO=rms/hacks</code> 设置了名为 <code>FOO</code> 的环境变量，那么 <code>/u/$FOO/test.c</code> 和 <code>/u/${FOO}/test.c</code> 均是 <code>/u/rms/hacks/test.c</code> 的简写形式。如果该环境变量未定义，则不会进行替换，字符 '<code>$</code>' 将按原义保留。注意，在 Emacs 外部设置的环境变量，只有在 Emacs 启动前生效，才会对 Emacs 产生影响。
</p>

<p>
若要访问的文件名中包含 '<code>$</code>' 字符，且并且你不希望它被当作环境变量展开，可输入 '<code>$$</code>' 。在对单个 '<code>$</code>' 执行变量替换的同时，这 2 个 '<code>$</code>' 会被转换为 1 个 '<code>$</code>' 。你也可以使用 '<code>/:</code>' 将整个文件名引起来（参见《<a href="#Quoted-File-Names">引用文件名</a>》章节）。以字面量 '~' 开头的文件名，同样需要用 '<code>/:</code>' 引用。
</p>

<p>
你可以在文件名中包含非 ASCII 字符，参见《<a href="#File-Name-Coding">文件名的编码系统</a>》章节。
</p>
</div>
</div>
<div id="outline-container-Visiting" class="outline-3">
<h3 id="Visiting"><span class="section-number-3">20.2.</span> 打开文件（Visiting Files）</h3>
<div class="outline-text-3" id="text-Visiting">
<dl class="org-dl">
<dt><code>C-x C-f</code></dt><dd>访问文件 (<code>find-file</code>)</dd>
<dt>(no term)</dt><dd><code>C-x C-r</code> ::以只读方式访问文件，禁止修改 (<code>find-file-read-only</code>)</dd>
<dt><code>C-x C-v</code></dt><dd>替换访问另一个文件，替代上一次访问的文件 (<code>find-alternate-file</code>)</dd>
<dt><code>C-x 4 f</code></dt><dd>在另一个窗口中访问文件 (<code>find-file-other-window</code>) ，不改变当前选中窗口的显示内容</dd>
<dt><code>C-x 5 f</code></dt><dd>在新框架中访问文件 (<code>find-file-other-frame</code>) ，不改变当前选中框架的显示内容</dd>
<dt><code>M-x find-file-literally</code></dt><dd>以无格式转换的方式访问文件，不处理文件内容的任何转换</dd>
</dl>

<p>
访问文件指将文件内容读取到 Emacs 缓冲区中，以便进行编辑操作。Emacs 会为每个访问的文件创建一个新的缓冲区。
</p>

<p>
要访问文件，输入 <code>C-x C-f</code> (<code>find-file</code>) ，并通过迷你缓冲区输入目标文件名。在迷你缓冲区中，可输入 <code>C-g</code> 终止该命令。关于在迷你缓冲区中输入文件名的详细说明，参见《<a href="#File-Names">文件名</a>》章节。
</p>

<p>
若指定的文件存在但系统禁止你读取，回显区会显示错误信息（在 GNU 和 Unix 系统中，你可通过 <code>su</code> 或 <code>sudo</code> 方式访问此类文件，参见《<a href="#Remote-Files">远程文件</a>》章节）。若访问成功，屏幕会显示文件的新文本，模式行也会显示对应的缓冲区名称（参见《<a href="#Mode-Line">模式行</a>》章节）。Emacs 通常会从文件名中提取缓冲区名，省略目录部分，例如访问文件 <code>/usr/rms/emacs.tex</code> 时，对应的缓冲区名为 <code>emacs.tex</code> 。若该名称的缓冲区已存在，Emacs 会生成一个唯一名称，默认方式是添加基于目录名的后缀（如 '&lt;rms&gt;' 、 '&lt;tmp&gt;' 等），你也可选择其他命名方式，参见《<a href="#Uniquify">让缓冲区名唯一</a>》章节。
</p>

<p>
创建新文件可直接使用相同的命令 <code>C-x C-f</code> ，只需输入新的文件名即可。此时回显区会显示 '(New file)' ，其余操作与访问一个已存在的空文件完全一致。
</p>

<p>
访问文件后，所有编辑命令产生的修改都仅作用于 Emacs 缓冲区，直到你保存缓冲区，修改才会同步到实际的文件中（参见《<a href="#Saving">保存文件</a>》章节）。若缓冲区包含未保存的修改，我们称该缓冲区已修改，此时若未保存就关闭缓冲区，修改将会丢失。模式行左侧的两个星号 '**' 是缓冲区已修改的标识。
</p>

<p>
若你访问的文件已在 Emacs 中打开， <code>C-x C-f</code> 不会创建新的缓冲区副本，而是直接切换到已存在的缓冲区。在此之前，Emacs 会检查该文件自上次访问或保存后是否被外部修改，若已修改，会提示你重新读取文件内容。
</p>

<p>
若你尝试访问的文件大小超过变量 <code>large-file-warning-threshold</code> 的取值（默认值为 10000000，约 10MB），Emacs 会先请求你的确认。输入 <code>y</code> 可继续正常访问文件，输入 <code>l</code> 则以无格式转换方式访问文件（详见下文）。以无格式转换方式访问大文件能提升导航和编辑速度，因为该方式会关闭各类可能占用大量资源的功能。请注意，Emacs 无法访问超过 <b>最大缓冲区</b> 大小的文件，该限制由 Emacs 可分配的内存空间和可表示的整数范围决定（参见《<a href="#Buffers">使用多个缓冲区</a>》章节），若尝试访问，回显区会显示 “超出最大缓冲区大小” 的错误信息。
</p>

<p>
若你尝试访问的文件，其对应的主模式（参见《<a href="#Major-Modes">主模式</a>》章节）会使用树分析解析库（tree-sitter），当文件字节大小超过变量 <code>treesit-max-buffer-size</code> 的取值时，Emacs 会发出警告。该变量默认值：64 位 Emacs 为 40MB，32 位 Emacs 为 15MB。此限制是为了避免 Emacs 内存耗尽，因为大缓冲区中基于 tree-sitter 的主模式会被禁用 —— 典型的 tree-sitter 解析器所需的内存约为其解析文本大小的 10 倍。
</p>

<p>
若你输入的文件名包含 Shell 风格的通配符，Emacs 会访问所有匹配该通配符的文件（在不区分大小写的文件系统中，通配符匹配会忽略字母大小写）。通配符包括 '<code>?</code>' 、 '<code>*</code>' 和 '<code>[…]</code>' 序列。若要在迷你缓冲区中输入作为文件名一部分的通配符 '<code>?</code>' ，需输入 <code>C-q ?</code> 进行转义。若文件名本身包含通配符，关于其访问方法参见《<a href="#Quoted-File-Names">引用文件名</a>》章节。你可通过自定义变量 <code>find-file-wildcards</code> 禁用通配符匹配功能。
</p>

<p>
若你尝试访问的文件已在某个缓冲区中打开，但该文件被外部程序修改，Emacs 通常会询问你是否从磁盘重新读取文件。若你将变量 <code>query-about-changed-file</code> 设为 <code>nil</code> ，Emacs 不会发出询问，而是继续显示缓冲区中修改前的内容，并在回显区提示你如何从文件恢复缓冲区内容。
</p>

<p>
若你因输错文件名意外访问了错误的文件，可输入 <code>C-x C-v</code> (<code>find-alternate-file</code>) 访问实际需要的文件。 <code>C-x C-v</code> 与 <code>C-x C-f</code> 功能类似，但会先关闭当前缓冲区（若缓冲区已修改，会先提示你保存）。当 <code>C-x C-v</code> 读取待访问的文件名时，会将完整的默认文件名插入迷你缓冲区，且光标定位在目录部分之后，若你仅输错了文件名的小部分，该方式会非常便捷。
</p>

<p>
若你尝试访问的文件实际是一个目录，Emacs 会调用目录编辑器 Dired（Emacs 目录浏览器），参见《<a href="#Dired">目录编辑器 Dired</a>》章节。你可将变量 <code>find-file-run-dired</code> 设为 <code>nil</code> 禁用该行为，此时尝试访问目录会被视为错误操作。
</p>

<p>
对于实际为文件集合的归档文件，Emacs 会以特殊模式打开，该模式会调用类 Dired 的操作环境，支持对归档内的成员文件进行操作，关于该功能的详细说明参见《<a href="#File-Archives">文件归档</a>》章节。
</p>

<p>
若你访问的文件被操作系统禁止修改，或被标记为只读，Emacs 会将对应的缓冲区也设为只读，避免你进行修改后无法保存。你可使用 <code>C-x C-q</code> (<code>read-only-mode</code>) 将只读缓冲区改为可写，参见《<a href="#Misc-Buffer">各类缓冲区操作</a>》章节。
</p>

<p>
若你希望以只读方式访问文件，防止意外修改，可使用 <code>C-x C-r</code> (<code>find-file-read-only</code>) 替代=C-x C-f= 。
</p>

<p>
<code>C-x 4 f</code> (<code>find-file-other-window</code>) 与 <code>C-x C-f</code> 功能类似，区别在于该命令会在 <b>另一个窗口</b> 中选中目标文件的缓冲区，执行该命令前的当前窗口会保持原有缓冲区的显示。若执行该命令时仅存在一个窗口，Emacs 会将该窗口拆分为两个，一个窗口保持原有内容，另一个窗口显示新访问的文件，参见《<a href="#Windows">多个窗口</a>》章节。
</p>

<p>
<code>C-x 5 f</code> (<code>find-file-other-frame</code>) 与上述命令类似，区别在于该命令会在 <b>新框架</b> 中打开文件，或选中已显示该文件的现有框架，参见《<a href="#Frames">框架与图形化显示</a>》章节。
</p>

<p>
在图形化显示界面中，还有两种额外的文件访问方式：
</p>
<ol class="org-ol">
<li>若 Emacs 基于合适的 GUI 工具包编译，通过鼠标调用的命令（点击菜单栏或工具栏）会使用工具包的标准文件选择对话框，而非通过迷你缓冲区提示输入文件名。在 GNU/Linux 和 Unix 平台，基于 GTK+、LessTif 和 Motif 工具包编译的 Emacs 支持该功能；在 MS-Windows 和 Mac 系统，GUI 版本的 Emacs 默认支持该功能。关于该功能的自定义方法，参见《<a href="#Dialog-Boxes">使用对话框</a>》章节。</li>
<li>Emacs <b>支持拖放操作</b> ：将文件拖入普通的 Emacs 窗口，该窗口会直接访问该文件。例外情况：将文件拖入显示 Dired 缓冲区的窗口，会将该文件移动或复制到该窗口显示的目录中。详细说明参见《<a href="#Drag-and-Drop">拖放操作</a>》和《<a href="#Misc-Dired-Features">Dired 的其他功能</a>》章节。</li>
</ol>

<p>
在文本模式终端中，或在未基于 GUI 工具包编译的 Emacs 图形化显示界面中，你可通过菜单栏的「文件（File）」菜单访问文件，该菜单包含「访问新文件（Visit New File）」和「打开文件（Open File）」选项。
</p>

<p>
每次访问文件时，Emacs 会自动扫描文件内容，检测其使用的字符编码和行尾格式，并在缓冲区中将其转换为 Emacs 内部的编码和行尾格式。当你保存缓冲区时，Emacs 会执行反向转换，将文件以原始的编码和行尾格式写入磁盘，参见《<a href="#Coding-Systems">编码系统</a>》章节。
</p>

<p>
若你希望将文件作为纯 ASCII 字符序列编辑，不进行任何特殊的编码或格式转换，可使用 <code>M-x find-file-literally</code> 命令。该命令与 <code>C-x C-f</code> 一样用于访问文件，但不会执行格式转换（参见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Format-Conversion.html#Format-Conversion">格式转换</a>》）、字符编码转换（参见《<a href="#Coding-Systems">编码系统</a>》）和自动解压缩（参见《访问压缩文件》），也不会因变量require-final-newline的设置为文件添加末尾换行符（参见《<a href="#Compressed-Files">自定义文件保存方式</a>》）。若你已以常规（非无格式转换）方式访问过同一文件，该命令会询问你是否改为以无格式转换方式访问。
</p>

<p>
某些文件之间会存在松散的关联关系，这类文件被称为 <b>sibling files兄弟文件</b> 。例如编辑 C 语言文件时，若存在文件 "<code>foo.c</code>" ，通常会对应一个头文件 "<code>foo.h</code>" ，该头文件即为其兄弟文件；同一文件的不同版本也可视为兄弟文件，例如 "<code>src/emacs/emacs-27/lisp/allout.el</code>" 和 "<code>src/emacs/emacs-28/lisp/allout.el</code>" 。Emacs 提供了 <code>find-sibling-file</code> 命令用于在兄弟文件之间跳转，但无法默认推测用户希望哪些文件互为兄弟文件，因此你可通过修改用户选项 <code>find-sibling-rules</code> 自由配置，该选项是一个由「匹配 / 扩展」规则组成的列表。
</p>

<p>
例如，要实现从 "<code>.c</code>" 文件到 "<code>.h</code>" 文件的映射，可进行如下配置：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq</span> find-sibling-rules
      '((<span style="color: #8b2252;">"</span><span style="color: #8b2252; font-weight: bold;">\\</span><span style="color: #8b2252; font-weight: bold;">(</span><span style="color: #8b2252;">[</span><span style="color: #8b2252;">^</span><span style="color: #8b2252;">/]+</span><span style="color: #8b2252; font-weight: bold;">\\</span><span style="color: #8b2252; font-weight: bold;">)</span><span style="color: #8b2252;">\\.c\\'"</span> <span style="color: #8b2252;">"\\1.h"</span>)))
</pre>
</div>

<p>
(<code>ff-find-related-file</code> 命令也提供类似功能，该命令专为 C 语言文件设计，参见《<a href="#Other-C-Commands">C 模式的其他命令</a>》章节。)
</p>

<p>
又如，若你希望将 "<code>src/emacs/DIR/file-name</code>" 目录下的所有文件视为其他同层级目录下同名文件的兄弟文件，可配置：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq</span> find-sibling-rules
      '((<span style="color: #8b2252;">"src/emacs/[</span><span style="color: #8b2252;">^</span><span style="color: #8b2252;">/]+/</span><span style="color: #8b2252; font-weight: bold;">\\</span><span style="color: #8b2252; font-weight: bold;">(</span><span style="color: #8b2252;">.*</span><span style="color: #8b2252; font-weight: bold;">\\</span><span style="color: #8b2252; font-weight: bold;">)</span><span style="color: #8b2252;">\\'"</span> <span style="color: #8b2252;">"src/emacs/.*/\\1"</span>)))
</pre>
</div>

<p>
如上所示，该选项的每一条规则均为 <code>(MATCH EXPANSION...)</code> 的形式。其中 <b>match匹配规则</b> 是匹配已访问文件名的正则表达式， <b>expansion扩展规则</b> 可通过 '<code>\\1</code>' 、 '<code>\\2</code>' 等引用匹配规则中的捕获组。Emacs 会将扩展后的字符串作为正则表达式，在文件系统中匹配符合条件的文件。
</p>

<p>
有两个特殊的钩子变量可扩展文件访问的操作逻辑：
</p>

<ol class="org-ol">
<li>访问不存在的文件时，Emacs 会执行 <code>find-file-not-found-functions</code> 中的所有函数。该变量是一个函数列表，函数会被依次调用（无参数），直到某个函数返回非nil值。这并非普通钩子，变量名以 '<code>-functions</code>' 而非 '<code>-hook</code>' 结尾，正是为了区分这一特性。</li>

<li>成功访问任意文件（无论文件是否存在）后，Emacs 会无参数调用 <code>find-file-hook</code> 中的所有函数，该变量是一个 <b>普通钩子</b> 。若访问的是不存在的文件，会先执行 <code>find-file-not-found-functions</code> 中的函数，再执行该钩子。关于钩子的详细说明参见《<a href="#Hooks">钩子</a>》章节。</li>
</ol>

<p>
你可通过多种方式为文件自动指定编辑所用的主模式（参见《<a href="#Choosing-Modes">选择文件模式</a>》），也可为文件指定专属的局部变量（参见《<a href="#File-Variables">文件中的局部变量</a>》）。
</p>
</div>
</div>
<div id="outline-container-Saving" class="outline-3">
<h3 id="Saving"><span class="section-number-3">20.3.</span> 保存文件</h3>
<div class="outline-text-3" id="text-Saving">
<p>
在 Emacs 中保存缓冲区，指将缓冲区的内容回写到其对应的源文件中。
</p>

<ul class="org-ul">
<li><a href="#Save-Commands">保存文件命令</a></li>
<li><a href="#Backup">备份文件（Backup Files）</a></li>
<li><a href="#Customize-Save">文件保存定制</a></li>
<li><a href="#Interlocking">防止同时编辑冲突</a></li>
<li><a href="#File-Shadowing">文件影子（Shadowing Files）</a></li>
<li><a href="#Time-Stamps">自动更新时间戳</a></li>
</ul>
</div>
<div id="outline-container-Save-Commands" class="outline-4">
<h4 id="Save-Commands"><span class="section-number-4">20.3.1.</span> 保存文件命令</h4>
<div class="outline-text-4" id="text-Save-Commands">
<p>
以下是与文件的保存和写入相关的命令。
</p>

<dl class="org-dl">
<dt><code>C-x C-s</code></dt><dd>将当前缓冲区保存至对应文件 (<code>save-buffer</code>)</dd>
<dt><code>C-x s</code></dt><dd>保存任意或全部已修改的缓冲区至各自对应文件 (<code>save-some-buffers</code>)</dd>
<dt><code>M-~</code></dt><dd>清除当前缓冲区的已修改标记 (<code>not-modified</code>)；带前缀参数（ <code>C-u</code> ）时，标记当前缓冲区为已修改状态</dd>
<dt><code>C-x C-w</code></dt><dd>将当前缓冲区以指定文件名保存 (<code>write-file</code>)，即另存为</dd>
<dt><code>M-x set-visited-file-name</code></dt><dd>修改当前缓冲区后续保存时对应的文件名</dd>
<dt><code>M-x rename-visited-file</code></dt><dd>功能与 <code>M-x set-visited-file-name</code> 一致，同时会重命名缓冲区正在访问的原文件（若存在）</dd>
</dl>

<p>
若你希望保存文件并让修改永久生效，输入 <code>C-x C-s</code> (<code>save-buffer</code>) 即可。保存完成后，该命令会在回显区显示如下提示信息：
</p>

<div class="org-src-container">
<pre class="src src-shell">Wrote /u/rms/gnu/gnu.tasks
</pre>
</div>

<p>
若当前缓冲区未被修改（自缓冲区创建或上次保存后无任何更改），则不会实际执行保存操作 —— 因为此操作无任何实际效果，取而代之的是， <code>C-x C-s</code> 会在回显区显示：
</p>

<div class="org-src-container">
<pre class="src src-shell">(No changes need to be saved)
</pre>
</div>

<p>
带前缀参数执行 <code>C-u C-x C-s</code> 时，Emacs 会标记该缓冲区，使其在 <b>下一次保存时生成备份文件</b> ，相关说明参见《<a href="#Backup">备份文件</a>》章节。
</p>

<p>
<code>C-x s</code> (<code>save-some-buffers</code>) 命令会逐个询问是否保存已修改的缓冲区，你可对每个缓冲区选择对应的操作，可选响应与查询替换的操作方式类似：
</p>
<dl class="org-dl">
<dt><code>y</code></dt><dd></dd>

<dt><code>SPC</code></dt><dd>保存当前缓冲区，继续询问其余缓冲区</dd>
<dt><code>n</code></dt><dd></dd>

<dt><code>DEL</code></dt><dd>不保存当前缓冲区，继续询问其余缓冲区</dd>
<dt><code>!</code></dt><dd>保存当前缓冲区及所有剩余缓冲区，后续不再询问</dd>
<dt><code>q</code></dt><dd></dd>

<dt><code>RET</code></dt><dd>终止 <code>save-some-buffers</code> 命令，不再保存任何缓冲区</dd>
<dt><code>.</code></dt><dd>保存当前缓冲区，直接退出 <code>save-some-buffers</code> 命令，不再询问其余缓冲区</dd>
<dt><code>C-r</code></dt><dd>查看当前正在询问的缓冲区内容；退出查看模式后，会回到 <code>save-some-buffers</code> 的询问界面，重新发起该缓冲区的保存询问</dd>
<dt><code>C-f</code></dt><dd>退出 <code>save-some-buffers</code> 命令，直接切换至当前正在询问的缓冲区</dd>
<dt><code>d</code></dt><dd>对比当前缓冲区与对应源文件的差异，可直观查看即将保存的修改内容（该操作会调用 <code>diff-buffer-with-file</code> 命令，参见《<a href="#Comparing-Files">文件对比</a>》章节）</dd>
<dt><code>C-h</code></dt><dd>显示上述操作选项的帮助信息</dd>
</dl>

<p>
你可自定义变量 <code>save-some-buffers-default-predicate</code> 的取值，以此控制 Emacs 会对哪些缓冲区发起保存询问。
</p>

<p>
退出 Emacs 的快捷键 <code>C-x C-c</code> 会调用 <code>save-some-buffers</code> 命令，因此也会弹出相同的保存询问。
</p>

<p>
若你修改了缓冲区但并不希望保存这些更改，需执行相关操作避免误保存；否则每次使用 <code>C-x s</code> 或 <code>C-x C-c</code> 时，都有可能误保存该缓冲区。你可执行的操作之一是输入 <code>M-~</code> (<code>not-modified</code>) ，该命令会清除缓冲区的已修改标识，此后所有保存命令都会判定该缓冲区无需保存（符号 '~' 在数学中常表示 “非”，因此 <code>M-~</code> 可理解为 Meta键版的 “非” 操作）。此外，你也可通过重新从文件读取文本，撤销自访问或上次保存文件后做出的所有修改，该操作称为 <b>恢复缓冲区</b> ，参见《<a href="#Reverting">恢复缓冲区</a>》章节（你也可重复执行撤销命令 <code>C-x u</code> ，直至撤销所有修改，但恢复缓冲区的操作会更简便）。
</p>

<p>
<code>M-x set-visited-file-name</code> 命令用于修改当前缓冲区正在访问的文件名， <b>该命令会通过迷你缓冲区读取新的文件名</b> ，随后将缓冲区标记为访问该新文件，并相应修改缓冲区名称。该命令不会将缓冲区内容保存至新文件，仅会修改 Emacs 内部的记录，为后续的保存操作做准备；同时它会将缓冲区标记为已修改，确保你在该缓冲区执行 <code>C-x C-s</code> 时能触发保存。
</p>

<p>
若你希望将缓冲区标记为访问新文件并 <b>立即保存</b> ，可使用 <code>C-x C-w</code> (<code>write-file</code>) 命令。该命令等效于先执行 <code>set-visited-file-name</code> ，再执行 <code>C-x C-s</code> ，区别在于：若指定的新文件已存在， <code>C-x C-w</code> 会先请求你的确认。若对一个未访问任何文件的缓冲区执行 <code>C-x C-s</code> ，其效果与 <code>C-x C-w</code> 一致 —— 会读取一个文件名，将缓冲区标记为访问该文件，并将内容保存至该文件。未访问任何文件的缓冲区，其默认文件名由 <b>缓冲区名称</b> 与 <b>缓冲区默认目录</b> 组合而成（参见《<a href="#File-Names">文件名</a>》章节）。
</p>

<p>
在大多数情况下，若新文件名的后缀隐含了对应的主模式， <code>C-x C-w</code> 会自动将缓冲区切换至该主模式； <code>set-visited-file-name</code> 命令也具备此功能，相关说明参见《<a href="#Choosing-Modes">选择文件模式</a>》章节。
</p>

<p>
若你希望将当前缓冲区内容保存至其他文件， <b>但不将缓冲区标记为访问该文件</b> ，可先执行 <code>mark-whole-buffer</code> （ <code>C-x h</code> ）全选缓冲区内容，再执行 <code>M-x write-region</code> 命令（参见《<a href="#Misc-File-Ops">各类文件操作</a>》章节）。
</p>

<p>
当 Emacs 即将保存文件时，若检测到磁盘上该文件的最新修改时间，与 Emacs 上次读取或写入该文件的时间不一致，会立即向你发出提示。这一情况通常意味着文件被 <b>同时编辑</b> 并引发了问题，需要你及时处理，相关说明参见《<a href="#Interlocking">同时编辑</a>》章节。
</p>
</div>
</div>
<div id="outline-container-Backup" class="outline-4">
<h4 id="Backup"><span class="section-number-4">20.3.2.</span> 备份文件（Backup Files）</h4>
<div class="outline-text-4" id="text-Backup">
<p>
在大多数操作系统中，重写文件会直接清除该文件的原有内容记录。因此，从 Emacs 中保存文件本会覆盖文件的旧内容 —— 但实际不会，因为 Emacs 会在执行实际保存操作前，将文件旧内容妥善复制到另一个文件中，这个文件即为 <b>backup file备份文件</b> 。
</p>

<p>
Emacs 仅在从访问文件的缓冲区 <b>首次保存该文件</b> 时，为其创建备份文件。后续无论你对该文件执行多少次保存操作，其备份文件的内容都不会改变。但如果关闭该缓冲区后再次访问此文件，Emacs 会为其生成一个新的备份文件。
</p>

<p>
对于绝大多数文件，是否创建备份文件由变量 <code>make-backup-files</code> 决定。在多数操作系统中，该变量的默认值为 <code>t</code> ，即 Emacs 会自动生成备份文件。
</p>

<p>
对于由 <b>版本控制系统</b> 管理的文件（参见《<a href="#Version-Control">版本控制</a>》章节），是否创建备份文件由变量 <code>vc-make-backup-files</code> 决定。该变量默认值为 <code>nil</code> ，因为当所有历史版本都已存储在版本控制系统中时，备份文件属于冗余文件（参见《<a href="#General-VC-Options">通用选项</a>》章节）。
</p>

<p>
你可根据需要设置 Emacs，为每个文件仅保留 <b>单个备份文件</b> ，或为编辑的每个文件生成一系列 <b>带编号的备份文件</b> （参见《<a href="#Backup-Names">单备份与编号备份</a>》小节）。
</p>

<p>
变量 <code>backup-enable-predicate</code> 的默认配置，会禁止为 <b>临时文件目录</b> 中的文件创建备份文件，临时文件目录由变量 <code>temporary-file-directory</code> 或 <code>small-temporary-file-directory</code> 指定。
</p>

<p>
即便缓冲区此前已执行过保存操作，你也可明确让 Emacs 为该缓冲区重新生成一个备份文件：
</p>
<ul class="org-ul">
<li>若通过 <code>C-u C-x C-s</code> 保存缓冲区，当你再次保存该缓冲区时，此次保存的版本会被生成为新的备份文件；</li>
<li><code>C-u C-u C-x C-s</code> 会先将文件原有内容生成为新的备份文件，再执行缓冲区的保存操作；</li>
<li><code>C-u C-u C-u C-x C-s</code> 则会同时完成两项操作：将文件原有内容生成备份文件，且设置为 <b>再次保存时</b> ，将本次新保存的内容也生成新的备份文件。</li>
</ul>

<p>
你可自定义变量 <code>backup-directory-alist</code> ，指定匹配特定模式的文件，在指定目录中创建备份文件。一种常用配置是向该变量添加元素 <code>("." . dir)</code> ，让所有文件的备份都生成在绝对路径为 <code>dir</code> 的目录中。Emacs 会自动修改备份文件的名称，避免不同目录下同名文件的备份发生命名冲突。另一种配置是添加 <code>("." . ".~")</code> ，将备份文件生成在原文件所在目录的隐藏子目录 '<code>.~</code>' 中，若该目录不存在，Emacs 会自动创建以完成备份。
</p>

<ul class="org-ul">
<li><a href="#Backup-Names">单一备份或编号备份</a></li>
<li><a href="#Backup-Deletion">备份文件的自动删除</a></li>
<li><a href="#Backup-Copying">复制备份与重命名备份</a></li>
</ul>
</div>
<div id="outline-container-Backup-Names" class="outline-5">
<h5 id="Backup-Names"><span class="section-number-5">20.3.2.1.</span> 单一备份或编号备份</h5>
<div class="outline-text-5" id="text-Backup-Names">
<p>
Emacs 创建备份文件时，默认的命名方式是在待编辑文件的文件名后追加符号 '~' ；例如，文件 <code>eval.c</code> 对应的备份文件为 <code>eval.c~</code> 。
</p>

<p>
若因访问权限限制，Emacs 无法以常规名称创建备份文件，会将备份文件写入 <code>~/.emacs.d/%backup%~</code> 路径。该路径下仅能存在一个此类备份文件，因此仅可获取最近一次生成的该类备份。
</p>

<p>
Emacs 也支持 <b>创建编号备份文件</b> ，其命名规则为在原文件名后添加 '.~' 、数字序号和另一个 '~' 。例如，文件 <code>eval.c</code> 的编号备份文件依次为 <code>eval.c.~1~</code> 、 <code>eval.c.~2~</code> ，序号可延续至 <code>eval.c.~259~</code> 乃至更大的数字。
</p>

<p>
变量 <code>version-control</code> 用于控制 Emacs 生成单备份文件还是多个编号备份文件，其可选取值及对应规则如下：
</p>
<dl class="org-dl">
<dt><code>nil</code></dt><dd>若文件已有编号备份，则继续生成编号备份；否则生成单备份文件（默认取值）</dd>
<dt><code>t</code></dt><dd>始终生成编号备份文件</dd>
<dt><code>never</code></dt><dd>从不生成编号备份文件，始终生成单备份文件</dd>
</dl>

<p>
该变量的常规配置方式为通过初始化文件或自定义缓冲区进行 <b>全局设置</b> ；同时也可在单个缓冲区中进行局部设置，以控制该缓冲区对应文件的备份生成规则（参见《<a href="#Locals">局部变量</a>》章节）。部分模式（如 Rmail 模式）会自动设置该变量，也可在访问指定文件时，让 Emacs 自动为其设置该变量的局部取值（参见《<a href="#File-Variables">文件中的局部变量</a>》章节）。
</p>

<p>
若你设置了环境变量 <code>VERSION_CONTROL</code> （用于指定各类 GNU 工具的备份文件生成规则），Emacs 在启动时也会遵循该环境变量的配置，自动对应设置 Lisp 变量 <code>version-control</code> ：
</p>
<ul class="org-ul">
<li>当环境变量值为 <code>t</code> 或 <code>numbered</code> 时，Emacs 中 <code>version-control</code> 设为 <code>t</code></li>
<li>当环境变量值为 <code>nil</code> 或 <code>existing</code> 时，Emacs 中 <code>version-control</code> 设为 <code>nil</code></li>
<li>当环境变量值为 <code>never</code> 或 <code>simple</code> 时，Emacs 中 <code>version-control</code> 设为 <code>never</code></li>
<li>若将变量 <code>make-backup-file-name-function</code> 设为合适的 Lisp 函数，可覆盖 Emacs 默认的备份文件命名规则。</li>
</ul>
</div>
</div>
<div id="outline-container-Backup-Deletion" class="outline-5">
<h5 id="Backup-Deletion"><span class="section-number-5">20.3.2.2.</span> 备份文件的自动删除</h5>
<div class="outline-text-5" id="text-Backup-Deletion">
<p>
为避免过度占用磁盘空间，Emacs 可自动删除编号备份文件的旧版本。通常情况下，Emacs 会保留编号最靠前的若干个备份和最新的若干个备份，将中间的所有备份文件删除。该清理操作会在 <b>每次生成新备份文件时</b> 执行。
</p>

<p>
备份文件的自动清理规则由两个变量控制： <code>kept-old-versions</code> 和 <code>kept-new-versions</code> 。二者的取值分别对应 <b>每次生成新备份时</b> ，需要保留的最旧（编号最小）备份文件数量，以及需要保留的最新（编号最大）备份文件数量。处于两者之间的备份文件（即排除上述保留的最旧和最新备份后，剩余的中间备份）均为冗余的中间版本，会被自动删除。这两个变量的取值仅在新备份生成后、清理冗余版本时生效，且刚生成的新备份会被计入 <code>kept-new-versions</code> 的保留数量中。两个变量的默认值均为 <code>2</code> 。
</p>

<p>
若变量 <code>delete-old-versions</code> 的取值为 <code>t</code> ，Emacs 会在后台静默删除冗余的备份文件，不弹出任何提示；若取值为 <code>nil</code> （默认值），Emacs 会先询问你是否确认删除这些冗余备份版本，再执行后续操作；若为其他任意值，Emacs 则不会自动删除任何备份文件。
</p>

<p>
你也可使用 Dired 中的句点（ <code>.</code> ）命令手动删除备份旧版本，相关操作参见《<a href="#Flagging-Many-Files">批量标记文件</a>》章节。
</p>
</div>
</div>
<div id="outline-container-Backup-Copying" class="outline-5">
<h5 id="Backup-Copying"><span class="section-number-5">20.3.2.3.</span> 复制备份与重命名备份</h5>
<div class="outline-text-5" id="text-Backup-Copying">
<p>
创建备份文件的方式分为 <b>复制原文件</b> 和 <b>重命名原文件</b> 两种。当原文件存在多个文件名（硬链接）时，两种方式的效果会截然不同：若将原文件重命名为备份文件，那么原文件的其他关联文件名会成为该备份文件的名称；若选择复制原文件生成备份，原文件的其他关联文件名仍指向你正在编辑的文件，通过这些文件名访问到的内容也会是文件的新内容。
</p>

<p>
备份方式的选择也会影响文件的属主和所属用户组：采用复制方式时，文件的属主和所属组不会发生变化；采用重命名方式时，你会成为文件的新属主，文件的所属组则会变为系统默认组（不同操作系统的默认组规则存在差异）。
</p>

<p>
Emacs 选择复制或重命名方式的判断逻辑如下：
</p>

<ul class="org-ul">
<li>若变量 <code>backup-by-copying</code> 为非nil值（默认值为 <code>nil</code> ），采用复制方式。</li>

<li>若上述变量为 <code>nil</code> ，但变量 <code>backup-by-copying-when-linked</code> 为非nil值（默认值为 <code>nil</code> ）且原文件存在多个硬链接文件名，采用复制方式。</li>

<li><p>
若上述两个变量均为 <code>nil</code> ，但变量 <code>backup-by-copying-when-mismatch</code> 为非nil值（默认值为 <code>t</code> ）且重命名会导致文件属主或所属组发生变化，采用复制方式。
</p>

<p>
若将 <code>backup-by-copying-when-mismatch</code> 设为 <code>nil</code> ，Emacs 会检查文件属主的用户ID和所属组ID：若其中任意一个 ID 的数值不大于变量 <code>backup-by-copying-when-privileged-mismatch</code> 的取值，Emacs 仍会按照 <code>backup-by-copying-when-mismatch</code> 为非nil的规则执行，即采用复制方式。
</p></li>

<li>若以上条件均不满足，默认采用重命名方式。</li>
</ul>

<p>
当文件由版本控制系统管理时（参见《<a href="#Version-Control">版本控制</a>》章节），Emacs 通常不会以常规方式为该文件创建备份。但向版本控制系统提交（也称作 checking in，参见《<a href="#VCS-Concepts">版本控制的基本概念</a>》章节）文件的新版本，在某些方面与创建备份类似，其中一个弊端是：这类操作通常会破坏文件的硬链接，导致你所访问的文件名与该文件的其他关联文件名失去关联。该问题与 Emacs 无关，是由版本控制系统本身的操作导致的。
</p>

<p>
部分文件存储服务支持 <b>文件版本管理功能</b> ：会记录文件的历史版本，并允许恢复至任意历史版本。若你希望在 Emacs 中编辑这类服务托管的文件时，仍能使用该功能，可将变量 <code>backup-by-copying</code> 自定义为非nil值。
</p>

<p>
编辑重要文件时，采用复制原文件的方式创建备份也十分实用：这能确保即便在创建备份后、保存编辑内容前的过程中发生异常，原文件仍会保留其原始名称。此外，你也可将变量 <code>file-precious-flag</code> 设为非nil值，该设置会默认采用复制方式创建备份，同时还能在保存编辑内容时，防止出现 I/O 错误。
</p>
</div>
</div>
</div>
<div id="outline-container-Customize-Save" class="outline-4">
<h4 id="Customize-Save"><span class="section-number-4">20.3.3.</span> 文件保存定制</h4>
<div class="outline-text-4" id="text-Customize-Save">
<p>
若变量 <code>require-final-newline</code> 的取值为 <code>t</code> ，在保存或写入文件时，若文件末尾无换行符，Emacs 会自动为其添加，且不弹出任何提示。若取值为 <code>visit</code> ，Emacs 仅在 <b>访问文件后</b> ，为末尾无换行符的文件添加换行符（此操作会标记缓冲区为已修改状态，你可撤销该操作）。若取值为 <code>visit-save</code> ，则 Emacs 会在 <b>访问文件和保存文件时</b> ，均执行上述末尾换行符的添加操作。若取值为 <code>nil</code> ，Emacs 不会修改文件末尾的内容；若为其他非nil值，Emacs 会先询问你是否添加换行符，再执行后续操作。该变量的默认值为 <code>nil</code> 。
</p>

<p>
部分主模式专为特定类型的文件设计，而这类文件通常要求末尾必须有换行符。此类主模式会将 <code>require-final-newline</code> 的取值设为变量 <code>mode-require-final-newline</code> 的取值，该变量默认值为 <code>t</code> 。你可通过修改 <code>mode-require-final-newline</code> ，控制这些主模式对文件末尾换行符的处理方式。
</p>

<p>
若该选项为非nil值，且你通过 <b>符号链接</b> 访问文件，当变量 <code>file-precious-flag</code> 也为非nil值时，Emacs 在保存缓冲区时会 <b>断开该符号链接</b> ，并将缓冲区内容写入与该符号链接同名的实际文件中（关于 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Saving-Buffers.html#Saving-Buffers">file-precious-flag</a> 的更多说明，参见《Emacs Lisp 参考手册》）。若你希望此类场景下，Emacs 将缓冲区内容保存至符号链接 <b>指向的原文件</b> （从而保留该符号链接），可将变量 <code>file-preserve-symlinks-on-save</code> 自定义为 <code>t</code> 。
</p>

<p>
通常情况下，程序写入文件时，操作系统会先将文件数据临时缓存至主内存，再将数据提交至二级存储设备。该机制虽能大幅提升性能，但存在数据丢失风险：若系统在缓存数据提交前断电，缓存中的数据会丢失；且在部分平台中，其他进程可能无法立即感知到文件的修改。
</p>

<p>
为降低该风险，Emacs 可在保存文件后调用 <code>fsync</code> 系统调用，强制将缓存数据写入二级存储。但使用 <code>fsync</code> 并不能完全消除数据丢失或修改通知延迟的问题，原因有二：一是许多系统并未对 <code>fsync</code> 提供完善支持；二是 Emacs 的文件保存流程通常还依赖于目录更新操作，即便 <code>fsync</code> 执行正常，这类目录更新也可能在系统崩溃时丢失。
</p>

<p>
变量 <code>write-region-inhibit-fsync</code> 用于控制 Emacs 是否在保存文件后调用 <code>fsync</code> ，该变量默认值为 <code>t</code> （即不调用）。
</p>

<p>
Emacs 在写入 <b>自动保存文件</b> 时，绝不会调用 <code>fsync</code> —— 因为这类文件本身就存在数据丢失的可能性。
</p>
</div>
</div>
<div id="outline-container-Interlocking" class="outline-4">
<h4 id="Interlocking"><span class="section-number-4">20.3.4.</span> 防止同时编辑冲突</h4>
<div class="outline-text-4" id="text-Interlocking">
<p>
<b>同时编辑</b> 指两名用户访问同一文件，双方均对文件做出修改并执行保存操作的情况。若未及时向用户告知该情况，先完成保存的一方，后续会发现其修改内容被覆盖丢失。
</p>

<p>
在部分系统中，当第二位用户开始修改文件时，Emacs 会立即检测到并发出警告；而在所有系统中，Emacs 都会在你执行保存操作时进行检查，若检测到你即将覆盖其他用户的修改，会及时弹出警告。此时你可执行相应的修正操作，而非直接保存文件，避免覆盖丢失其他用户的修改成果。
</p>

<p>
当你在访问某文件的 Emacs 缓冲区中做出 <b>首次修改</b> 时，Emacs 会记录该文件被你 <b>锁定</b> （锁定的实现方式为：在该文件所在目录中创建一个命名特殊、内容特殊的符号链接 <sup><a id="fnr.7" class="footref" href="#fn.7" role="doc-backlink">7</a></sup>，更多细节参见《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/File-Locks.html#File-Locks">文件锁定</a>相关章节）。当你保存修改后，Emacs 会自动解除该文件的锁定。该机制的核心逻辑是： <b>当访问某文件的缓冲区存在未保存修改时，该文件会被锁定</b> 。
</p>

<p>
你可将变量 <code>create-lockfiles</code> 设为 <code>nil</code> ，禁止 Emacs 创建锁定文件。注意：此操作会让你失去该功能带来的保护。你也可通过变量 <code>lock-file-name-transforms</code> ，控制锁定文件的存储位置。
</p>

<p>
若你尝试修改的文件，已被其他用户锁定，此时就会发生 <b>collision锁定冲突</b> 。Emacs 检测到冲突后，会调用 Lisp 函数 <code>ask-user-about-lock</code> ，向你询问处理方式；你也可重新定义该函数，实现自定义的冲突处理逻辑。该函数的标准定义会向你提出问题，并接受以下三种响应：
</p>

<dl class="org-dl">
<dt><code>s</code></dt><dd>抢占锁定。原持有该文件锁定的用户会失去锁定权限，锁定权限转移至你。</dd>
<dt><code>p</code></dt><dd>继续编辑。无视其他用户的锁定，继续编辑该文件。</dd>
<dt><code>q</code></dt><dd>退出操作。触发文件被锁定的错误(<code>file-locked</code>)，缓冲区内容保持不变 —— 你本次尝试做出的修改不会实际生效。</dd>
</dl>

<p>
若 Emacs 程序或操作系统发生崩溃，可能会遗留一些 <b>失效的锁定文件</b> ，导致你偶尔收到虚假的锁定冲突警告。当你确认该冲突为虚假冲突时，只需输入 <code>p</code> ，告知 Emacs 继续执行编辑操作即可。
</p>

<p>
请注意，文件锁定机制 <b>基于文件名实现</b> ：若一个文件拥有多个名称（如硬链接、符号链接），Emacs 无法阻止两名用户通过不同名称同时编辑该文件。
</p>

<p>
在某些情况下，Emacs 无法创建锁定文件，例如：Emacs 缺少对应的系统权限，或因其他原因无法生成锁定文件。即便如此，Emacs 仍能在你尝试保存文件时检测到冲突，检测方式为 <b>检查文件的最后修改时间</b> ：若该文件自 Emacs 上次访问或保存后，被其他方式修改过，此时执行保存会覆盖丢失这些修改。Emacs 会立即显示警告信息，并在保存前向你请求确认；输入 '<code>yes</code>' 则执行保存，输入 '<code>no</code>' 或按下 <code>C-g</code> 则取消保存操作。
</p>

<p>
若你收到通知，得知该文件已发生同时编辑，可使用 <code>M-x diff-buffer-with-file</code> 命令对比缓冲区内容与文件的实际内容，查看差异（参见《<a href="#Comparing-Files">文件对比</a>》章节）。
</p>

<p>
你可将变量 <code>remote-file-name-inhibit-locks</code> 设为 <code>t</code> ，禁止 Emacs 创建远程文件的锁定文件。
</p>

<p>
次要模式 <code>lock-file-mode</code> 可通过交互方式调用，用于切换当前缓冲区中 <code>create-lockfiles</code> 变量的局部取值。
</p>
</div>
</div>
<div id="outline-container-File-Shadowing" class="outline-4">
<h4 id="File-Shadowing"><span class="section-number-4">20.3.5.</span> 文件影子（Shadowing Files）</h4>
<div class="outline-text-4" id="text-File-Shadowing">
<p>
你可将指定文件的完全相同的 <b>shadow copies影子副本</b> 保存在多个位置，这些位置甚至可以在不同的计算机上。要实现该功能，首先你需要创建一个 <b>shadow file group影子文件组</b> ，即一组在多个站点间共享、且文件名完全相同的文件构成的集合。该文件组为永久配置，不仅在当前 Emacs 会话中生效，在后续的 Emacs 会话中也同样有效。影子文件组创建完成后，每次退出 Emacs 时，程序都会将你编辑过的该文件，同步复制到其所属影子文件组中的其他文件位置。你也可以不退出 Emacs，直接输入 <code>M-x shadow-copy-files</code> 执行该同步复制操作。
</p>

<p>
<b>shadow cluster影子集群</b> 是一组共享目录的主机，因此向集群中的任一主机执行文件的复制操作，即可完成集群内所有主机上该文件的更新。每个影子集群都有专属名称，同时需要指定集群中 <b>主主机</b> 的网络地址（即文件的同步目标主机），以及一个能匹配集群中所有其他主机名的正则表达式。你可通过 <code>M-x shadow-define-cluster</code> 命令定义影子集群。
</p>

<dl class="org-dl">
<dt><code>M-x shadow-initialize</code></dt><dd>启用文件影子功能</dd>
<dt><code>M-x shadow-define-literal-group</code></dt><dd>声明单个文件在多个站点间共享</dd>
<dt><code>M-x shadow-define-regexp-group</code></dt><dd>将匹配指定正则表达式的所有文件，设为在多主机间共享的文件</dd>
<dt><code>M-x shadow-define-cluster RET 集群名 RET</code></dt><dd>定义一个名为「集群名」的影子文件集群</dd>
<dt><code>M-x shadow-copy-files</code></dt><dd>同步复制所有待处理的影子文件</dd>
<dt><code>M-x shadow-cancel</code></dt><dd>取消部分文件的遮蔽同步指令</dd>
</dl>

<p>
创建影子文件组可使用 <code>M-x shadow-define-literal-group</code> 或 <code>M-x shadow-define-regexp-group</code> 命令，更多使用细节可查阅这两个命令的文档字符串。
</p>

<p>
在将文件同步复制到其各影子副本位置前，Emacs 会向你请求确认。你可选择 "<code>no</code>" ，跳过本次该文件的同步复制操作。若你希望永久取消某个文件的影子同步功能，可使用 <code>M-x shadow-cancel</code> 命令，删除或修改该文件所属的影子文件组配置。
</p>
</div>
</div>
<div id="outline-container-Time-Stamps" class="outline-4">
<h4 id="Time-Stamps"><span class="section-number-4">20.3.6.</span> 自动更新时间戳</h4>
<div class="outline-text-4" id="text-Time-Stamps">
<p>
你可设置让文件中的 <b>时间戳</b> 在每次保存文件时自动更新（时间戳也可被称作日期戳或最后修改时间）。在文件文本中嵌入时间戳，能确保即便文件因被复制或转换而丢失文件系统层面的修改时间，文件的实际写入时间也能被留存。
</p>

<p>
设置自动时间戳功能需分两步操作：首先，需在文件的 <b>前八行内</b> 的任意位置添加一个时间戳模板，模板格式可写为：
</p>

<div class="org-src-container">
<pre class="src src-shell">Time-stamp: &lt;&gt;
</pre>
</div>

<p>
也可按你的需求写成：
</p>

<div class="org-src-container">
<pre class="src src-shell">Time-stamp: <span style="color: #8b2252;">" "</span>
</pre>
</div>

<p>
添加好该模板后，你可立即使用 <code>M-x time-stamp</code> 命令，一次性更新当前缓冲区的时间戳。Emacs 会自动检测文件中的模板，若找到模板，就会将当前的日期、时间、作者及其他信息填充到尖括号或双引号之间（若缓冲区中无此模板， <code>time-stamp</code> 命令将不执行任何操作）。生成首个时间戳后，该模板所在行可能会显示为：
</p>

<div class="org-src-container">
<pre class="src src-shell">Time-stamp: &lt;1993-07-06 11:05:14 terryg&gt;
</pre>
</div>

<p>
其次，将 <code>time-stamp</code> 函数添加至 <code>before-save-hook</code> 钩子中，配置 Emacs 在每次保存文件时自动运行该函数（参见《<a href="#Hooks">钩子</a>》章节）。你既可以使用 <code>M-x customize-option</code> 命令自定义 <code>before-save-hook</code> 选项（参见《<a href="#Specific-Customization">自定义特定项</a>》章节），也可以编辑你的初始化文件，添加如下配置行：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'before-save-hook 'time-stamp)
</pre>
</div>

<ul class="org-ul">
<li><a href="#Time-Stamp-Customization">时间戳定制</a></li>
<li><a href="#Time-Stamps-for-One-File">强制单个文件的时间戳更新</a></li>
</ul>
</div>
<div id="outline-container-Time-Stamp-Customization" class="outline-5">
<h5 id="Time-Stamp-Customization"><span class="section-number-5">20.3.6.1.</span> 时间戳定制</h5>
<div class="outline-text-5" id="text-Time-Stamp-Customization">
<p>
若要为特定文件自定义时间戳格式，可在该文件的 <b>局部变量列表</b> 中设置变量 <code>time-stamp-pattern</code> （参见《<a href="#Specifying-File-Variables">指定文件变量</a>》章节）。通过该变量，你可以修改 <code>time-stamp</code> 命令匹配时间戳模板的规则，同时也能指定命令在文件中的模板查找范围；具体用法可查阅该变量的内置文档（使用 <code>C-h v</code> 命令，参见《<a href="#Name-Help">通过命令或变量名获取帮助</a>》章节）。
</p>

<p>
举一个简单的例子，若某文件的开头位置有如下内容：
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #a0522d;">publishing_year_and_city</span> = <span style="color: #8b2252;">"Published nnnn in Boston, Mass."</span>;
</pre>
</div>

<p>
那么在该文件末尾添加以下注释，即可告知 <code>time-stamp</code> 命令如何识别并更新这个自定义模板：
</p>

<div class="org-src-container">
<pre class="src src-shell">// Local Variables&#58;
// time-stamp-pattern: <span style="color: #8b2252;">"Published %Y in Boston"</span>
// End:
</pre>
</div>

<p>
该匹配规则表示，时间戳的前缀文本为 "Published" ，后缀文本为 "in Boston" 。如果 <code>time-stamp</code> 命令在文件 <b>前八行</b> 中找到同时包含这两段文本的内容，就会按照 <code>%Y</code> 的格式要求，将两段文本之间的内容替换为当前年份。
</p>

<p>
对文件局部变量完成任何修改后，需输入 <code>M-x normal-mode</code> 命令重新读取这些变量配置。
</p>

<p>
再举一个示例，将时间戳插入 HTML 文档的最后一个段落中。由于该模板位于文档末尾，而非文件前八行，因此在 <code>time-stamp-pattern</code> 的开头添加 <code>-10/</code> ，告知 <code>time-stamp</code> 命令在文件 <b>最后 10 行</b> 中查找模板；其中的 <code>%%</code> 表示使用默认的时间戳格式（由变量 <code>time-stamp-format</code> 指定）。
</p>

<p>
文档内容示例：
</p>

<div class="org-src-container">
<pre class="src src-shell">&#8230;
&lt;p&gt;Last modified: &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;!--
Local Variables&#58;
time-stamp-pattern: <span style="color: #8b2252;">"-10/Last modified: %%&lt;/p&gt;$"</span>
End:
--&gt;
</pre>
</div>

<p>
Emacs 会默认根据你的 <b>区域设置</b> （参见《<a href="#Environment">环境变量</a>》章节）和 <b>时区</b> （参见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Time-of-Day.html#Time-of-Day">时间与日期</a>》章节）格式化时间戳。你可以设置变量 <code>time-stamp-time-zone</code> ，覆盖默认使用的时区。关于时间戳的具体格式化规则，以及其他影响格式化的相关变量，可查阅变量 <code>time-stamp-format</code> 的内置文档。
</p>
</div>
</div>
<div id="outline-container-Time-Stamps-for-One-File" class="outline-5">
<h5 id="Time-Stamps-for-One-File"><span class="section-number-5">20.3.6.2.</span> 强制单个文件的时间戳更新</h5>
<div class="outline-text-5" id="text-Time-Stamps-for-One-File">
<p>
若你正在编辑一个由多位作者协作的文件，且无法确定其他作者是否已在其 Emacs 初始化文件中 <b>全局启用</b> 时间戳功能，可在该文件的 <b>局部变量列表</b> 中，将 <code>time-stamp</code> 函数添加至缓冲区的 <code>before-save-hook</code> 钩子，以此为该特定文件强制启用时间戳功能。以下是基于前文示例的扩展配置：
</p>

<div class="org-src-container">
<pre class="src src-shell">// Local Variables&#58;
// eval: (add-hook <span style="color: #8b2252;">'before-save-hook '</span>time-stamp nil t)
// time-stamp-pattern: <span style="color: #8b2252;">"Published %Y in Boston"</span>
// End:
</pre>
</div>

<p>
本示例中同时配置了上述两项内容，若你希望使用默认的时间戳匹配规则，也可仅使用 <code>eval</code> 配置项，而不设置 <code>time-stamp-pattern</code> 。
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-Reverting" class="outline-3">
<h3 id="Reverting"><span class="section-number-3">20.4.</span> 恢复缓冲区（Reverting a Buffer）</h3>
<div class="outline-text-3" id="text-Reverting">
<p>
若你对访问文件的缓冲区做出了大量修改，之后又想放弃这些修改，可通过恢复操作还原至文件的已保存版本。执行该操作只需按下 <code>C-x x g</code> 即可。由于误执行恢复操作可能会丢失大量工作成果，因此若缓冲区存在未保存修改，Emacs 会先向你请求确认，再执行恢复。
</p>

<p>
<code>revert-buffer</code> 命令会尽量智能定位光标位置：若文件仅做了少量修改，光标会停留在与修改前大致相同的文本位置；但如果文件做了大幅修改，光标最终可能会出现在完全不同的位置。
</p>

<p>
执行恢复操作后，缓冲区的 <b>已修改标记会被清除</b> 。但该操作会将本次恢复的所有修改内容，作为单次修改记录添加到缓冲区的撤销历史中（参见《<a href="#Undo">撤销</a>》章节）。因此，即便执行了恢复，若你后续改变主意，仍可按下 <code>C-/</code> 或其等效快捷键，恢复此前被撤销的修改内容。
</p>

<p>
若想以更保守的方式恢复缓冲区，可使用 <code>revert-buffer-with-fine-grain</code> 命令。该命令的基础功能与 <code>revert-buffer</code> 一致，但会尽可能做到 <b>无破坏性恢复</b> ，尽力保留缓冲区中的所有标记、文本属性和覆盖层。当你对文件做出了大量修改时，这种恢复方式的执行速度可能会很慢，你可以修改变量 <code>revert-buffer-with-fine-grain-max-seconds</code> ，指定该方式替换缓冲区内容的最长耗时（以秒为单位）。请注意，该设置并不能保证 <code>revert-buffer-with-fine-grain</code> 命令的整体执行时间不超过该限值。
</p>

<p>
部分与文件无关联的缓冲区也可执行恢复操作，例如 Dired 缓冲区，对这类缓冲区而言，恢复意味着重新计算并刷新其内容。而通过 <code>C-x b</code> 显式创建的空白缓冲区无法执行恢复操作，若尝试对其执行 <code>revert-buffer</code> ，命令会直接抛出错误。
</p>

<p>
当你编辑的文件会 <b>自动且频繁地发生变化</b> （例如，某个持续运行的进程生成的输出日志文件），让 Emacs 无需询问直接恢复该文件会非常实用。若要启用该功能，需将变量 <code>revert-without-query</code> 设为一个正则表达式列表。当文件名匹配列表中的任意一个正则表达式时，若文件在磁盘上发生了变化，且对应的缓冲区本身无未保存修改， <code>find-file</code> 和 <code>revert-buffer</code> 命令会自动恢复该文件（若你已对缓冲区文本做了修改，自动恢复会丢弃这些修改，因此该情况下不会执行）。
</p>

<p>
快捷键 <code>C-x x g</code> 绑定的是 <code>revert-buffer-quick</code> 命令，该命令与 <code>revert-buffer</code> 功能一致，但 <b>弹出的提示更少</b> 。与 <code>revert-buffer</code> 不同，若当前缓冲区关联了文件且无未保存修改，该命令不会弹出任何确认提示。同时，该命令会遵循用户选项 <code>revert-buffer-quick-short-answers</code> 的配置：若该选项为非nil值，会使用简短的 '<code>y/n</code>' 确认提示，而非冗长的 '<code>yes/no</code>' 提示。
</p>

<p>
你也可以设置 Emacs，让缓冲区在其关联的文件在磁盘上发生变化时 <b>自动执行恢复</b> ，相关配置参见《<a href="#Auto-Revert">自动恢复：让缓冲区自动保持最新</a>》章节。
</p>

<p>
请注意，恢复缓冲区时，Emacs 会为该缓冲区关联的文件启用对应的主模式（具体规则参见《<a href="#Choosing-Modes">选择文件模式</a>》章节）。因此，恢复操作最终启用的主模式会受模式重映射配置的影响：若你在恢复前自定义了 <code>major-mode-remap-alist</code> ，恢复后启用的主模式可能与原模式不同。
</p>
</div>
</div>
<div id="outline-container-Auto-Revert" class="outline-3">
<h3 id="Auto-Revert"><span class="section-number-3">20.5.</span> 自动恢复：保持缓冲区自动更新（Auto Revert）</h3>
<div class="outline-text-3" id="text-Auto-Revert">
<p>
当缓冲区关联的磁盘文件被其他程序修改时，缓冲区内容会与文件不同步。若要让缓冲区始终保持最新，可输入 <code>M-x auto-revert-mode</code> 启用 <b>自动恢复模式</b> ，该模式会在磁盘文件发生修改时，自动恢复缓冲区内容。若要为所有文件缓冲区启用该功能，可输入 <code>M-x global-auto-revert-mode</code> 开启 <b>全局自动恢复模式</b> 。
</p>

<p>
当缓冲区存在未保存修改，或其对应的磁盘文件被删除、重命名时，自动恢复功能不会对该缓冲区执行恢复操作。
</p>

<p>
自动恢复模式的一个常用场景是 <b>跟踪</b> 系统日志这类文件，让其他程序对该文件的修改能实时显示在 Emacs 中。只需将光标移至缓冲区末尾，后续文件内容更新时，光标会始终停留在末尾位置。但如果你确定该文件只会在末尾追加内容，建议改用 <b>自动恢复尾部模式</b> （auto-revert-tail-mode），该模式针对此场景的执行效率更高，且对远程文件同样适用。
</p>

<p>
缓冲区被自动恢复时，Emacs 会弹出提示信息，将变量 <code>auto-revert-verbose</code> 设为 nil= 可关闭该提示。
</p>

<p>
自动恢复模式默认不会检查或恢复远程文件，因该操作通常耗时过久，将变量 <code>auto-revert-remote-files</code> 设为非nil值可修改此行为。
</p>

<p>
自动恢复模式默认通过 <b>file notifications文件通知机制</b> 工作，由操作系统将文件系统的修改情况通知给 Emacs。将变量 <code>auto-revert-use-notify</code> 设为 <code>nil</code> 可禁用该机制，此时 Emacs 会通过 <b>轮询</b> 方式检查文件修改，默认轮询间隔为 <code>5</code> 秒，可通过变量 <code>auto-revert-interval</code> 修改轮询时间。
</p>

<p>
并非所有系统都支持文件通知机制，在不支持该机制的系统中， <code>auto-revert-use-notify</code> 会默认设为 <code>nil</code> 。
</p>

<p>
即便启用了文件通知机制，自动恢复模式默认仍会定期轮询文件是否修改。多数场景下轮询并无必要，仅依靠通知机制可减少资源消耗，将变量 <code>auto-revert-avoid-polling</code> 设为非nil值即可关闭轮询。但需注意，部分文件系统的通知机制失效，尤其是类 Unix 系统中的网络文件系统（这类文件可被其他机器修改），此时轮询操作是必要的。若 <code>auto-revert-avoid-polling</code> 为非nil但需对部分文件强制轮询，可设置变量 <code>auto-revert-notify-exclude-dir-regexp</code> ，让匹配该正则表达式的文件排除在通知机制之外，转而使用轮询。
</p>

<p>
在 Dired 缓冲区中（参见《<a href="#Dired">目录编辑器 Dired</a>》章节），当缓冲区对应目录中有文件被创建或删除时，自动恢复模式会刷新该缓冲区的内容。
</p>

<p>
若要恢复版本控制系统管理下文件的早期版本，可参考相关命令说明（参见《<a href="#VC-Undo">撤销版本控制操作</a>》章节）。关于访问版本控制系统管理的文件时，自动恢复模式的特殊行为说明，参见《<a href="#VC-Mode-Line">版本控制与模式行</a>》章节。
</p>

<ul class="org-ul">
<li><a href="#Non_002dFile-Buffers">非文件缓冲区的自动恢复</a></li>
</ul>
</div>
<div id="outline-container-Non_002dFile-Buffers" class="outline-4">
<h4 id="Non_002dFile-Buffers"><span class="section-number-4">20.5.1.</span> 非文件缓冲区的自动恢复</h4>
<div class="outline-text-4" id="text-Non_002dFile-Buffers">
<p>
全局自动恢复模式默认仅对 <b>文件缓冲区</b> 执行自动恢复操作。要为特定非文件缓冲区启用自动恢复，有两种方式：一是在目标缓冲区中启用自动恢复模式（执行 <code>M-x auto-revert-mode</code> 命令）；二是将变量 <code>global-auto-revert-non-file-buffers</code> 设为非nil值，后者会为所有已实现该功能的非文件缓冲区（如下方列表所示）全局启用自动恢复。
</p>

<p>
与文件缓冲区相同，非文件缓冲区在你编辑操作期间，或缓冲区中包含恢复后可能丢失的信息时，默认不会执行自动恢复。因此， <b>已修改的非文件缓冲区不会触发自动恢复</b> 。这一规则的实际应用存在一定复杂性，因为判断非文件缓冲区何时应标记为已修改，通常比文件缓冲区的判断难度更高。
</p>

<p>
另一处需要注意的细节是，出于效率考量，自动恢复功能通常不会尝试检测缓冲区中所有可能的变更，仅会识别 <b>主要变更</b> 或 <b>易于检测的变更</b> 。因此，为非文件缓冲区启用自动恢复，并不总能保证缓冲区中的所有信息都是最新的，手动执行恢复操作依然有其必要性。
</p>

<p>
与之相反的是，部分非文件缓冲区会按照 <code>auto-revert-interval</code> 变量设定的秒数 <b>定时自动恢复</b> （目前该规则仅适用于缓冲区菜单）。此类场景下，即便变量 <code>auto-revert-verbose</code> 设为非nil，自动恢复操作也不会打印任何提示信息。
</p>

<p>
部分非文件缓冲区可通过其 <b>默认目录</b> 的文件通知机制实现可靠的自动更新，Dired 缓冲区就是典型示例。对应的主模式可通过在缓冲区中将变量 <code>buffer-auto-revert-by-notification</code> 设为非nil值来标识这一特性，让自动恢复功能无需再执行定期轮询。需注意，该方式的文件通知仅针对目录本身的变更， <b>不包含目录内文件的变更</b> 。
</p>

<p>
非文件缓冲区自动恢复的具体规则因缓冲区类型而异，相关细节会在对应章节中说明。
</p>

<ul class="org-ul">
<li><a href="#Auto-Reverting-the-Buffer-Menu">缓冲区菜单的自动恢复</a></li>
<li><a href="#Auto-Reverting-Dired">Dired 缓冲区的自动恢复</a></li>
</ul>
</div>
<div id="outline-container-Auto-Reverting-the-Buffer-Menu" class="outline-5">
<h5 id="Auto-Reverting-the-Buffer-Menu"><span class="section-number-5">20.5.1.1.</span> 缓冲区菜单的自动恢复</h5>
<div class="outline-text-5" id="text-Auto-Reverting-the-Buffer-Menu">
<p>
若已启用非文件缓冲区的自动恢复功能， <b>缓冲区菜单</b> （参见《<a href="#Several-Buffers">对多个缓冲区执行操作</a>》章节）会按照 <code>auto-revert-interval</code> 变量设定的秒数定时自动恢复，无论是否存在实际的变更需要同步（因为检查是否需要恢复的耗时，可能反而比直接执行恢复操作更长）。
</p>

<p>
若缓冲区菜单被错误标记为已修改状态，只需按下 <code>g</code> 手动恢复，自动恢复功能便会恢复正常。但需注意，若你已为部分缓冲区标记了删除或显示操作，执行恢复时需格外小心 —— 因为恢复操作会 <b>清除所有标记</b> 。而添加标记的操作会为缓冲区设置已修改标识，这一机制恰好能防止自动恢复功能误删标记
</p>
</div>
</div>
<div id="outline-container-Auto-Reverting-Dired" class="outline-5">
<h5 id="Auto-Reverting-Dired"><span class="section-number-5">20.5.1.2.</span> Dired 缓冲区的自动恢复</h5>
<div class="outline-text-5" id="text-Auto-Reverting-Dired">
<p>
Dired 缓冲区仅在其主目录的文件列表发生变化时（如新增或删除文件）触发自动恢复；若仅为单个文件的信息变更（如文件大小修改），或插入的子目录内容发生变化，不会触发自动恢复。即便已为 Dired 缓冲区启用自动恢复功能，若要确保列表中所有信息均为最新，仍需按下 <code>g</code> 键手动执行恢复操作。
</p>

<p>
有时你会发现，修改或保存主目录列表中的文件后，缓冲区似乎也触发了自动恢复，这是因为对文件的修改或保存操作，往往会间接导致目录本身发生变化（例如生成备份文件或自动保存文件），但这种情况并非必然发生。
</p>

<p>
若 Dired 缓冲区被标记为 “已修改”，且其中无需要保留的修改内容，多数情况下按下 <code>g</code> 键手动恢复后，即可恢复自动恢复功能，仅存在一种例外情况：若你为文件添加了标记或标记符，仍可安全执行缓冲区恢复操作，该操作不会清除已添加的标记或标记符（除非被标记的文件已被删除）；但恢复后，缓冲区仍会保持 “已修改” 状态，自动恢复功能也无法恢复。这一设计的原因是，当你为文件添加标记或标记符时，通常表明正针对该缓冲区进行操作，大概率不希望缓冲区在无提示的情况下发生变更。
</p>

<p>
若希望在保留文件标记 / 标记符的同时恢复自动恢复功能，可按下 <code>M-~</code> 将缓冲区标记为 “未修改”；但后续若再次添加、删除或修改标记 / 标记符，缓冲区会重新被标记为 “已修改”。
</p>

<p>
注意：远程 Dired 缓冲区目前不支持自动恢复；通过 Shell 通配符或文件参数筛选出部分文件生成的 Dired 缓冲区，同样不支持自动恢复。 <code>*Find*</code> 和 <code>*Locate*</code> 缓冲区也无自动恢复功能。
</p>

<p>
此外，在部分系统中，Dired 缓冲区的自动恢复功能可能无法达到预期效果。
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-Auto-Save" class="outline-3">
<h3 id="Auto-Save"><span class="section-number-3">20.6.</span> 自动保存：防止数据丢失（Auto-Saving）</h3>
<div class="outline-text-3" id="text-Auto-Save">
<p>
Emacs 会定期将每个已打开的文件，保存至一个独立的文件中，且不会改动你实际编辑使用的原文件，这一功能称为 <b>自动保存</b> 。若系统发生崩溃，该功能能避免你丢失过多的编辑成果。
</p>

<p>
当 Emacs 判定达到自动保存时机时，会对每个缓冲区进行检查：若该缓冲区启用了自动保存功能，且自上次自动保存后有内容修改，便会对其执行自动保存操作。当变量 <code>auto-save-no-message</code> 设为 <code>nil</code> （默认值）时，若此次有文件实际执行了自动保存，回显区会显示提示信息「正在自动保存&#x2026;」；若要关闭该提示，可将此变量自定义设置为非nil值。自动保存过程中若发生错误，Emacs 会捕获错误信息，避免其干扰你正在输入执行的命令。
</p>

<ul class="org-ul">
<li><a href="#Auto-Save-Files">自动保存文件</a></li>
<li><a href="#Auto-Save-Control">自动保存控制</a></li>
<li><a href="#Recover">从自动保存文件恢复数据</a></li>
</ul>
</div>
<div id="outline-container-Auto-Save-Files" class="outline-4">
<h4 id="Auto-Save-Files"><span class="section-number-4">20.6.1.</span> 自动保存文件</h4>
<div class="outline-text-4" id="text-Auto-Save-Files">
<p>
自动保存操作通常不会将内容保存至你所打开的原文件中，因为贸然保存并非你想要永久保留的修改，会造成不必要的麻烦。反之，自动保存会将内容写入一个独立的文件，即 <b>自动保存文件</b> ；只有当你显式执行保存操作时（如按下快捷键 <code>C-x C-s</code> ），修改内容才会写入原文件。
</p>

<p>
默认情况下，自动保存文件的命名规则为：在原文件名称的首尾各添加一个井号 '<code>#</code>' 。例如，打开文件 'foo.c' 对应的缓冲区，其自动保存文件为 '<code>#foo.c#</code>' 。对于大多数未关联实际文件的缓冲区，仅当你显式发起请求时才会执行自动保存；这类缓冲区的自动保存文件命名，会先在缓冲区名称首尾添加 '<code>#</code>' ，再在末尾拼接数字和字母以保证唯一性。比如，用于撰写待发送邮件的 <code>*mail*</code> 缓冲区，其自动保存文件可能命名为 <code>#*mail*#704juu</code> 。除非你重新编写 Emacs 相关功能代码（涉及 <code>make-auto-save-file-name</code> 和 <code>auto-save-file-name-p</code> 函数），否则自动保存文件都会遵循此命名规则。缓冲区的自动保存文件名，会在该缓冲区开启自动保存功能时完成计算。
</p>

<p>
变量 <code>auto-save-file-name-transforms</code> 允许你对自动保存文件名进行一定程度的自定义，你可通过该变量指定一系列正则表达式及替换规则，实现对自动保存文件名的转换。该变量的默认值会将远程文件（参见「<a href="#Remote-Files">远程文件</a>」相关内容）的自动保存文件，存放至本地机器的临时文件目录中。
</p>

<p>
当你在一个大缓冲区中删除大量文本内容时，该缓冲区的自动保存功能会暂时关闭。此设计的原因是：若你并非有意删除这些文本，保留了被删内容的自动保存文件，会对你恢复数据更有帮助。若要在该情况下重新启用自动保存功能，可按下 <code>C-x C-s</code> 保存缓冲区，或执行命令 <code>C-u 1 M-x auto-save-mode</code> 。
</p>

<p>
若你希望自动保存操作直接写入原文件，而非独立的自动保存文件，可启用全局次要模式 <code>auto-save-visited-mode</code> 。开启该模式后，自动保存的效果将与显式保存完全一致。请注意，该模式与前文所述的自动保存模式相互独立，你可同时启用两种模式。但如果某一缓冲区已激活自动保存模式，且废弃变量 <code>auto-save-visited-file-name</code> 被设为非nil值，那么该缓冲区将不受 <code>auto-save-visited-mode</code> 模式的影响。
</p>

<p>
你可通过变量 <code>auto-save-visited-interval</code> ，自定义 <code>auto-save-visited-mode</code> 模式下自动保存的时间间隔，其默认值为 5 秒。而变量 <code>auto-save-interval</code> 和 <code>auto-save-timeout</code> 对 <code>auto-save-visited-mode</code> 模式不产生作用，关于这些变量的详细说明，参见「<a href="#Auto-Save-Control">控制自动保存</a>」章节。
</p>

<p>
当你将缓冲区的内容保存至原文件时，该缓冲区对应的自动保存文件会被自动删除（若将变量 <code>delete-auto-save-files</code> 设为 <code>nil</code> ，可禁止此删除操作）。若通过 <code>C-x C-w</code>  或 <code>set-visited-file-name</code> 命令修改缓冲区关联的原文件名，对应的自动保存文件也会同步重命名，与新的原文件名匹配。
</p>

<p>
默认情况下，关闭缓冲区不会删除其对应的自动保存文件。若将变量 <code>kill-buffer-delete-auto-save-files</code> 设为非nil值，当你关闭一个存在自动保存文件的缓冲区时，Emacs 会向你发起确认提示，询问是否删除该自动保存文件（若 <code>delete-auto-save-files</code> 设为 <code>nil</code> ，则不会出现此提示）。
</p>
</div>
</div>
<div id="outline-container-Auto-Save-Control" class="outline-4">
<h4 id="Auto-Save-Control"><span class="section-number-4">20.6.2.</span> 自动保存控制</h4>
<div class="outline-text-4" id="text-Auto-Save-Control">
<p>
当你打开任意文件时，若变量 <code>auto-save-default</code> 设为非nil值，该文件对应的缓冲区会开启自动保存功能（批处理模式下除外，参见「<a href="#Initial-Options">初始选项</a>」相关内容）。该变量的默认值为 <code>t</code> ，因此文件关联缓冲区默认都会启用自动保存。若要切换当前缓冲区的自动保存状态，可执行命令 <code>M-x auto-save-mode</code> 。自动保存模式是一个 <b>缓冲区局部次要模式</b> （参见「<a href="#Minor-Modes">次要模式</a>」章节）。
</p>

<p>
Emacs 会根据你自上次自动保存后输入的字符数，定期执行自动保存操作。变量 <code>auto-save-interval</code> 用于指定两次自动保存之间的字符输入阈值，默认值为 <code>300</code> 。该变量不支持设置过小的数值：若你将其自定义为小于 <code>20</code> 的数，Emacs 会自动按 <code>20</code> 的阈值执行。
</p>

<p>
当你停止输入一段时间后，Emacs 也会触发自动保存。默认情况下，闲置 <code>30</code> 秒后会执行该操作（此时 Emacs 可能同时进行垃圾回收，参见《Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Garbage-Collection.html#Garbage-Collection">垃圾回收</a>」章节）。你可通过自定义变量 <code>auto-save-timeout</code> 修改这一闲置阈值。若当前缓冲区内容较长，实际触发自动保存的闲置时间会相应延长；这是一项启发式设计，目的是在你编辑大缓冲区时减少干扰 —— 因为大缓冲区的自动保存会消耗可观的时间。闲置时的自动保存能实现两个目的：一是若你离开终端一段时间，确保所有编辑内容都已保存；二是能在你实际输入的过程中，减少自动保存的触发次数。
</p>

<p>
当 <code>auto-save-visited-mode</code> 模式启用时，文件关联缓冲区会在闲置 5 秒后触发自动保存，你可通过自定义变量 <code>auto-save-visited-interval</code> 修改该闲置阈值。
</p>

<p>
当 Emacs 遭遇致命错误时，也会执行自动保存操作。这类情况包括通过 'kill %emacs' 等 Shell 命令终止 Emacs 进程，或是电话线路、网络连接断开等场景。
</p>

<p>
你也可通过执行命令 <code>M-x do-auto-save</code> ，显式触发一次自动保存。
</p>
</div>
</div>
<div id="outline-container-Recover" class="outline-4">
<h4 id="Recover"><span class="section-number-4">20.6.3.</span> 从自动保存文件恢复数据</h4>
<div class="outline-text-4" id="text-Recover">
<p>
你可以使用命令 <code>M-x recover-file RET 文件名 RET</code> ，借助自动保存文件的内容恢复丢失的数据。该命令会先打开指定文件，经你确认后，从其对应的自动保存文件 <code>#file#</code> 中恢复内容，之后你可按下 <code>C-x C-s</code> ，将恢复的文本保存至原文件中。例如，要从自动保存文件 '<code>#foo.c#</code>' 恢复文件 '<code>foo.c</code>' ，操作步骤如下：
</p>

<div class="org-src-container">
<pre class="src src-shell">M-x recover-file RET foo.c RET
yes RET
C-x C-s
</pre>
</div>

<p>
在请求确认前， <code>M-x recover-file</code> 会显示目录列表，展示指定文件与对应自动保存文件的相关信息，你可借此对比两者的大小和修改时间；若自动保存文件的修改时间更早，该命令将不会提供读取此文件的选项。
</p>

<p>
当 <code>M-x recover-file</code> 请求确认时，若你输入 <code>diff</code> 或 <code>=</code> 作为回应，命令会展示原文件与自动保存文件 '<code>#file#</code>' 之间的内容差异，随后再次向你请求恢复确认。
</p>

<p>
若 Emacs 程序或计算机发生崩溃，你可使用命令 <code>M-x recover-session</code> ，从自动保存文件中恢复所有此前正在编辑的文件。该命令会先为你展示已记录的所有中断会话列表，将光标移至你选择的会话处，按下 <code>C-c C-c</code> 即可进入后续步骤。
</p>

<p>
接着， <code>recover-session</code> 会针对该会话中曾编辑的每一个文件逐一确认，询问是否恢复对应文件；若你回答 '<code>y</code>' ，命令会调用 <code>recover-file</code> 并按其常规逻辑执行，展示原文件与自动保存文件的修改时间，且会再次确认是否恢复该文件。
</p>

<p>
<code>recover-session</code> 执行完成后，你选择恢复的所有文件都会出现在 Emacs 的缓冲区中， <b>此时需手动保存这些缓冲区</b> ，只有执行保存操作，才能将恢复的内容更新至原文件本身。
</p>

<p>
Emacs 会将中断会话的相关信息，记录在 '<code>/.emacs.d/auto-save-list/' 目录下、命名格式为 '.saves-进程号-主机名</code>' 的文件中，该存储目录由变量 <code>auto-save-list-file-prefix</code> 指定；若将此变量设为 <code>nil</code> ，Emacs 将不再记录会话信息，也就无法进行会话恢复操作。
</p>
</div>
</div>
</div>
<div id="outline-container-File-Aliases" class="outline-3">
<h3 id="File-Aliases"><span class="section-number-3">20.7.</span> 文件名别名（File Name Aliases）</h3>
<div class="outline-text-3" id="text-File-Aliases">
<p>
符号链接与硬链接均可实现多个文件名指向同一个文件。 <b>硬链接</b> 是直接指向文件的替代名称，所有名称的有效性完全相同，不存在优先级之分。与之不同的是， <b>符号链接</b> 是一种显式定义的别名：若 'foo' 是指向 'bar' 的符号链接，你可通过任一名称访问该文件，但 'bar' 为实际的原名称，而 'foo' 仅为别名。当符号链接指向目录时，会出现更为复杂的情况。
</p>

<p>
默认情况下，若你打开的文件，Emacs 已通过其他名称打开过，Emacs 会在回显区显示提示信息，并直接使用已打开该文件的现有缓冲区。这种情况会出现在多种场景：支持硬链接或符号链接的系统、会截断长文件名的系统中使用长文件名、或是在不区分大小写的文件系统中操作。你可将变量 <code>find-file-suppress-same-file-warnings</code> 设为非nil值，关闭该提示信息；若将变量 <code>find-file-existing-other-name</code> 设为 <code>nil</code> ，则会完全禁用此功能 —— 此时若通过两个不同名称打开同一个文件，Emacs 会为每个文件名分别创建独立的缓冲区。
</p>

<p>
若变量 <code>find-file-visit-truename</code> 设为非nil值，缓冲区中记录的文件名会是文件的 <b>真实名称</b> （将所有符号链接替换为其指向的目标名称后得到的名称），而非你输入的原始名称。设置该变量的同时，也会等效启用 <code>find-file-existing-other-name</code> 变量的功能。
</p>

<p>
有时，某个目录通常通过符号链接进行访问，而你希望 Emacs 优先显示其链接名称，此时可自定义变量 <code>directory-abbrev-alist</code> 实现该需求。该列表中的每个元素均为 <code>(from源匹配串 . to目标替换串)</code> 的形式，表示当目录名中出现源匹配串时，将其替换为目标替换串。其中 <b>源匹配串为正则表达式</b> （参见《<a href="#Regexps">正则表达式的语法</a>》章节），会从目录名的第一个字符开始匹配，且需以 '<code>\`</code>' 作为起始（以兼容包含换行符的目录名，避免 '<code>^</code>' 匹配符失效）； <b>目标替换串</b> 需为指向同一目录的普通绝对目录名，且不可在其中使用 '<code>~</code>' 代表主目录（Emacs 会单独处理此类路径替换）。以下是一个示例，适用于 '/home/fsf' 目录通常通过符号链接 '/fsf' 访问的系统：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">((<span style="color: #8b2252;">"\\`/home/fsf"</span> . <span style="color: #8b2252;">"/fsf"</span>))
</pre>
</div>
</div>
</div>
<div id="outline-container-Directories" class="outline-3">
<h3 id="Directories"><span class="section-number-3">20.8.</span> 文件目录（File Directories）</h3>
<div class="outline-text-3" id="text-Directories">
<p>
文件系统会将文件归类至不同目录中， <b>directory listing目录列表</b> 即某一目录下的所有文件清单。Emacs 提供了创建、删除目录的命令，也可生成 <b>简洁格式</b> （仅显示文件名）和 <b>详细格式</b> （包含大小、日期及其他属性）的目录列表。Emacs 还内置了名为 Dired 的目录浏览功能，可通过快捷键 <code>C-x d</code> 调用，相关用法参见《<a href="#Dired">目录编辑器 Dired</a>》章节。
</p>

<dl class="org-dl">
<dt><code>C-x C-d 目录/匹配模式 RET</code></dt><dd>显示简洁格式的目录列表 (<code>list-directory</code>) 。</dd>
<dt><code>C-u C-x C-d 目录/匹配模式 RET</code></dt><dd>显示详细格式的目录列表。</dd>
<dt><code>M-x make-directory RET 目录名 RET</code></dt><dd>创建指定名称的新目录。</dd>
<dt><code>M-x delete-directory RET 目录名 RET</code></dt><dd>删除指定名称的目录；若目录非空，会询问是否递归删除该目录。</dd>
</dl>

<p>
用于显示目录列表的核心命令为 <code>C-x C-d</code> (<code>list-directory</code>) ，该命令会通过迷你缓冲区读取一个文件名 —— 此文件名可以是待列出的目录，也可以是包含通配符、用于匹配目标文件的模式。例如：
</p>

<div class="org-src-container">
<pre class="src src-shell">C-x C-d /u2/emacs/etc RET
</pre>
</div>

<p>
会列出 <code>/u2/emacs/etc</code> 目录下的所有文件。以下是指定文件名称匹配模式的示例：
</p>

<div class="org-src-container">
<pre class="src src-shell">C-x C-d /u2/emacs/src/*.c RET
</pre>
</div>

<p>
默认情况下， <code>C-x C-d</code> 显示的简洁目录列表仅包含文件名；若执行命令时带上数字参数（无论参数具体值是多少），则会生成详细目录列表，包含文件大小、修改日期、所有者等信息（效果类似系统命令 <code>ls -l</code> ）。
</p>

<p>
目录列表的内容，主要通过在子进程中执行 <code>ls</code> 命令获取。有两个 Emacs 变量用于控制传递给 <code>ls</code> 命令的参数： <code>list-directory-brief-switches</code> 为简洁列表的参数字符串（默认值为 "-CF"）， <code>list-directory-verbose-switches</code> 为详细列表的参数字符串（默认值为 "-l"）。
</p>

<p>
在详细格式的目录列表中，Emacs 还会额外显示该目录所在磁盘的剩余存储空间信息。
</p>

<p>
<code>M-x delete-directory</code> 命令会通过迷你缓冲区提示输入待删除的目录名，若目录为空则直接删除；若目录非空，会询问是否递归删除。在支持「Trash回收站」（或 "Recycle Bin废纸篓"）功能的系统中，若将变量 <code>delete-by-moving-to-trash</code> 设为 <code>t</code> ，该命令会将指定目录移至回收站，而非直接永久删除。关于回收站的更多使用方法，参见《<a href="#Misc-File-Ops">杂项文件操作</a>》章节。
</p>
</div>
</div>
<div id="outline-container-Comparing-Files" class="outline-3">
<h3 id="Comparing-Files"><span class="section-number-3">20.9.</span> 文件比较</h3>
<div class="outline-text-3" id="text-Comparing-Files">
<p>
命令 <code>M-x diff</code> 会通过迷你缓冲区提示输入两个文件名，随后在名为 <code>*diff*</code> 的缓冲区中显示这两个文件的内容差异。该命令的实现依赖于调用系统的 <code>diff</code> 程序，执行时会使用变量 <code>diff-switches</code> 中配置的参数。此变量的值为字符串类型，默认值是 "-u" ，表示生成 <b>统一上下文格式</b> 的差异对比结果。关于 <code>diff</code> 程序的更多用法，参见《文件的对比与合并》中的「<a href="https://www.gnu.org/software/diffutils/manual/html_node/index.html#Top">差异对比</a>」章节。
</p>

<p>
<code>diff</code> 命令的输出结果会在 <b>差异模式</b> （Diff mode）下展示，该模式为一种主模式，相关用法参见「<a href="#Diff-Mode">差异模式</a>」章节。
</p>

<p>
另一种功能更完善的替代方案是命令 <code>M-x ediff</code> ，相关用法参见《Ediff 手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/ediff/index.html#Top">Ediff</a>」章节。
</p>

<p>
命令 <code>M-x diff-backup</code> 用于对比指定文件与其最新的备份文件；若你输入的是备份文件的名称，该命令则会对比此备份文件与其对应的源文件。除上述逻辑外，该命令的其他行为均与 <code>M-x diff</code> 一致。
</p>

<p>
命令 <code>M-x diff-buffer-with-file</code> 用于对比指定缓冲区与其对应的本地文件，通过该命令可查看：若保存此缓冲区，会对原文件做出哪些修改。
</p>

<p>
命令 <code>M-x diff-buffers</code> 用于对比两个指定缓冲区的内容。
</p>

<p>
命令 <code>M-x compare-windows</code> 用于对比当前窗口与 <b>上一个选中的窗口</b> 中的文本（关于 Emacs 的窗口相关知识，参见「<a href="#Windows">多窗口</a>」章节）。对比操作会从两个窗口的光标位置开始，且执行前会将两个缓冲区的初始光标位置分别压入各自的标记环（参见「<a href="#Mark-Ring">标记环</a>」章节）；随后光标会在两个窗口中同步逐字符向后移动，直至找到不匹配的字符，命令随即退出。
</p>

<p>
若命令执行时，两个窗口的光标位置后紧跟的就是不匹配的文本， <code>M-x compare-windows</code> 会通过启发式算法，尝试在两个窗口中向后定位至匹配的文本位置，之后便退出。因此，若你重复执行该命令（参见「<a href="#Repeating">重复执行命令</a>」章节），每次执行要么会跳过一段匹配的文本区域，要么会找到下一段匹配区域的起始位置。
</p>

<p>
若执行该命令时带上数字参数，对比过程会忽略空白字符的变化；若变量 <code>compare-ignore-case</code> 设为非nil值，对比还会忽略大小写的差异。若变量 <code>compare-ignore-whitespace</code> 设为非nil值， <code>compare-windows</code> 默认会忽略空白字符的变化，而带上前缀参数时，本次命令执行会临时关闭该忽略规则。
</p>

<p>
你可执行 <code>M-x smerge-mode</code> 开启 <b>合并模式</b> （Smerge mode），这是一款用于编辑 <code>diff3</code> 程序输出结果的次要模式。 <code>diff3</code> 的输出通常出现在以下场景：在版本控制系统外执行更新操作时，因文件存在冲突的修改导致合并失败。合并模式提供了专用命令，可通过选择特定的修改内容来解决文件合并冲突。
</p>

<p>
关于文件合并的高级工具 <code>Emerge</code> ，可参见《<a href="#Emerge">使用 Emerge 合并文件</a>》章节，该工具为文件合并提供了功能强大的操作界面。
</p>
</div>
</div>
<div id="outline-container-Diff-Mode" class="outline-3">
<h3 id="Diff-Mode"><span class="section-number-3">20.10.</span> 差异模式</h3>
<div class="outline-text-3" id="text-Diff-Mode">
<p>
差异模式（Diff mode）是一种主模式，专用于展示 <code>M-x diff</code> 及其他同类命令的输出结果。这类输出内容被称为 <b>patch补丁文件</b> ，因为可将其传入系统的 <code>patch</code> 命令，实现指定修改的自动应用。若要手动启用差异模式，执行命令 <code>M-x diff-mode</code> 即可。
</p>

<p>
补丁文件中定义的修改会被划分为多个 <b>修改块</b> （hunk），每个修改块是包含一行或多行变更内容的连续文本段，通常还会附带未修改的文本，为变更提供上下文参考。每个修改块前都会有 <b>hunk header修改块头</b> ，用于指定该块修改在原文件和新文件中对应的行号。差异模式会对所有修改块头进行高亮，使其与修改块的实际内容区分开。
</p>

<p>
补丁文件中的第一个修改块前会有 <b>文件头</b> ，展示文件新旧版本的名称及其时间戳。若一个补丁文件包含对多个文件的修改，每个文件的第一个修改块前都会配有对应的文件头。
</p>

<p>
你可像编辑普通缓冲区一样编辑差异模式的缓冲区（若缓冲区为只读状态，需先将其设为可写，参见《<a href="#Misc-Buffer">缓冲区的杂项操作</a>》）。每当你编辑某个修改块时，差异模式会自动校正该块头中的行号，确保补丁文件始终有效，仍可被 <code>patch</code> 命令正常应用。若要关闭行号自动校正功能，将变量 <code>diff-update-on-the-fly</code> 设为 <code>nil</code> 即可。
</p>

<p>
差异模式会将修改块识别为编译器错误信息，让 <code>M-g M-n</code> 及其他处理错误信息的命令可对其生效（参见《<a href="#Compilation-Mode">编译模式</a>》）。因此，你可使用编译模式的相关命令，跳转到修改对应的源码位置。
</p>

<p>
此外，差异模式还提供了以下命令，用于补丁文件的导航、操作与修改应用：
</p>

<p>
<b>补丁导航命令</b>
</p>

<dl class="org-dl">
<dt><code>M-n</code></dt><dd><p>
跳转到下一个修改块的起始位置 (<code>diff-hunk-next</code>) 。带上数字参数 <code>n</code> 时，向前跳至第 <code>n</code> 个修改块。
</p>

<p>
默认情况下，Emacs 展示补丁时会自动细化所有修改块，以更精细的粒度高亮变更内容。若将变量 <code>diff-refine</code> 设为 <code>navigation</code> ，则差异模式仅会对通过本命令或 <code>diff-hunk-prev</code> 跳转至的修改块进行细化处理。
</p></dd>
<dt><code>M-p</code></dt><dd>跳转到上一个修改块的起始位置 (<code>diff-hunk-prev</code>) 。带上数字参数 <code>n</code> 时，向后跳至第 <code>n</code> 个修改块。与 <code>M-n</code> 相同，若 <code>diff-refine</code> 设为 <code>navigation</code> ，本命令会对跳转至的修改块做细化处理。</dd>
<dt><code>M-}</code></dt><dd>在多文件补丁中，跳转到下一个文件的起始位置 (<code>diff-file-next</code>) 。带上数字参数 <code>n</code> 时，向前跳至第 <code>n</code> 个文件的起始位置。</dd>
<dt><code>M-{</code></dt><dd>在多文件补丁中，跳转到上一个文件的起始位置 (<code>diff-file-prev</code>) 。带上数字参数 <code>n</code> 时，向后跳至第 <code>n</code> 个文件的起始位置。</dd>
</dl>

<p>
<b>补丁内容删除命令</b>
</p>
<dl class="org-dl">
<dt><code>M-k</code></dt><dd>删除光标所在位置的修改块 (<code>diff-hunk-kill</code>) 。</dd>
<dt><code>M-K</code></dt><dd>在多文件补丁中，删除当前文件对应的所有补丁内容 (<code>diff-file-kill</code>) 。</dd>
</dl>

<p>
<b>补丁应用命令</b>
</p>
<dl class="org-dl">
<dt><code>C-c C-a</code></dt><dd>将当前修改块应用至其目标文件 (<code>diff-apply-hunk</code>) 。带上前缀参数 <code>C-u</code> 时，撤销该修改块的变更，即执行反向应用，将文件的 "new" 还原为 "old" 版本 。若变量 <code>diff-jump-to-old-file</code> 设为非nil，则该命令会将修改块应用至文件的「旧版本」而非新版本。</dd>
<dt><code>C-c RET a</code></dt><dd>将缓冲区中所有修改块应用至对应文件 (<code>diff-apply-buffer</code>) 。若所有差异均应用成功，会自动保存被修改的缓冲区。</dd>
</dl>

<p>
<b>补丁细化与查看命令</b>
</p>
<dl class="org-dl">
<dt><code>C-c C-b</code></dt><dd><p>
以更精细的粒度高亮光标所在修改块的变更内容 (<code>diff-refine-hunk</code>) ，可清晰查看变更行中具体哪些字符发生了修改。
</p>

<p>
由于差异模式默认会自动细化所有修改块，该命令主要在你将 <code>diff-refine</code> 设为非默认值时使用。
</p></dd>
<dt><code>C-c C-c</code></dt><dd>跳转到当前修改块对应的源码文件及行号 (<code>diff-goto-source</code>) 。默认跳转到文件的「新版本」（文件头中首个展示的版本），带上前缀参数时则跳转到「旧版本」。若 <code>diff-jump-to-old-file</code> 设为非nil，命令默认跳转到「旧版本」，前缀参数的作用则会反转。若前缀参数为大于 8 的数字（如执行 <code>C-u C-u C-c C-c</code> ），该命令还会为下一次调用设置 <code>diff-jump-to-old-file</code> 的取值。若源码文件受版本控制系统管理（参见《<a href="#Version-Control">版本控制</a>》），命令默认跳转到工作区文件；带上前缀参数时，若光标位于旧版本的行号处，会跳转到文件的「旧版本修订版」（参见《<a href="#Old-Revisions">查看与对比旧修订版</a>》），否则跳转到「新版本修订版」。</dd>
<dt><code>C-c C-n</code></dt><dd>将视图限定为当前修改块 (<code>diff-restrict-view</code> ，参见《<a href="#Narrowing">内容窄化</a>》)。带上前缀参数时，在多文件补丁中将视图限定为当前文件的补丁内容。执行 <code>C-x n w</code> (<code>widen</code>) 可恢复完整视图。</dd>
</dl>

<p>
<b>补丁编辑与转换命令</b>
</p>
<dl class="org-dl">
<dt><code>C-c C-e</code></dt><dd>基于当前补丁启动 Ediff 会话 (<code>diff-ediff-patch</code> ，参见《Ediff 手册》中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/ediff/index.html#Top">Ediff</a> 章节）。</dd>
<dt><code>C-c C-r</code></dt><dd>反转整个缓冲区的对比方向 (<code>diff-reverse-direction</code>) 。带上前缀参数时，仅反转当前区域内的对比方向（参见《<a href="#Mark">标记与区域</a>》）。对比方向反转，指修改块和文件头会被重新调整，生成可将文件「新版本」还原为「旧版本」的补丁。</dd>
<dt><code>C-c C-s</code></dt><dd>将光标所在的修改块拆分为两个独立的修改块 (<code>diff-split-hunk</code>) ，该命令会插入新的修改块头并修改原块头的信息。本命令适用于手动编辑补丁，且仅对 <code>diff</code> 程序通过 <code>-u</code> 或 <code>--unified</code> 选项生成的统一格式差异文件生效。若需拆分 <code>diff</code> 程序通过 <code>-c</code> 或 <code>--context</code> 选项生成的上下文格式差异文件，需先执行 <code>C-c C-u</code> 将缓冲区转换为统一格式。</dd>
<dt><code>C-c C-d</code></dt><dd>将整个缓冲区转换为 <b>上下文格式差异文件</b> (<code>diff-unified-&gt;context</code>) 。带上前缀参数时，仅转换区域内的修改块。</dd>
<dt><code>C-c C-u</code></dt><dd>将整个缓冲区转换为 <b>统一格式差异文件</b> (<code>diff-context-&gt;unified</code>) ；带上前缀参数时，将统一格式转换为上下文格式。若标记处于激活状态，仅转换区域内的修改块。</dd>
<dt><code>C-c C-l</code></dt><dd>重新生成当前修改块 (<code>diff-refresh-hunk</code>) 。</dd>
<dt><code>C-c C-w</code></dt><dd>重新生成当前修改块，忽略空白字符的变更；带上非nil的前缀参数时，重新生成所有修改块 (<code>diff-ignore-whitespace-hunk</code>) 。该命令会通过 <code>diff-ignore-whitespace-switches</code> 调用 <code>diff-command</code> ，该变量默认值为 '<code>-b</code>' ，即仅忽略空白字符的变更。</dd>
</dl>

<p>
<b>其他实用命令</b>
</p>
<dl class="org-dl">
<dt><code>C-x 4 A</code></dt><dd>为每个修改块生成一份 ChangeLog 日志条目 (<code>diff-add-change-log-entries-other-window</code>) ，效果类似 <code>C-x 4 a</code> （参见《<a href="#Change-Log">变更日志</a>》），会创建一份变更日志的骨架，你可后续补充具体的变更描述。在差异模式中， <code>C-x 4 a</code> 本身会针对当前修改块对应的文件生成日志，且从补丁文件中提取函数名，适用于为被补丁删除的函数创建日志条目。</dd>
</dl>

<p>
<b>补丁中的空白字符处理</b>
</p>

<p>
补丁文件有时会在变更行中包含尾随空白字符，这属于无意且不必要的变更，可通过两种方式处理：
</p>
<ol class="org-ol">
<li>在差异缓冲区中启用空白字符模式（Whitespace mode）（参见《<a href="#Useless-Whitespace">无用的空白字符</a>》），模式会自动高亮变更行中的尾随空白字符；</li>
<li>执行命令 <code>M-x diff-delete-trailing-whitespace</code> ，该命令会搜索补丁中所有变更行的尾随空白字符，并同时删除补丁文件和被补丁修改的源码文件中的这些空白字符。该命令不会自动保存所做的修改，你可自行决定是否保存（被修改的文件列表会在回显区显示）；带上前缀参数时，命令会尝试修改原始的「旧版本」源码文件，而非被补丁修改后的「新版本」源码文件。</li>
</ol>

<p>
若变量 <code>diff-font-lock-syntax</code> 设为非nil，修改块中的源码片段会根据对应的主模式进行语法高亮。
</p>
</div>
</div>
<div id="outline-container-Copying-and-Naming" class="outline-3">
<h3 id="Copying-and-Naming"><span class="section-number-3">20.11.</span> 文件的复制、命名与重命名</h3>
<div class="outline-text-3" id="text-Copying-and-Naming">
<p>
Emacs 提供了多条用于文件复制、命名和重命名的命令。这类命令均会通过迷你缓冲区读取两个文件名 —— <code>old</code> 原文件名（或目标文件名）与 <code>new</code> 新文件名，再据此执行文件复制或文件名调整操作； <b>此类命令均不支持带通配符的文件名</b> 。
</p>

<p>
在所有这类命令中，若传入的 <code>new</code> 参数仅为一个目录名（参见《Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Directory-Names.html#Directory-Names">目录名</a>」章节），则实际的 new新文件名会是该目录下、与 old原文件拥有相同非目录部分的名称。例如，执行命令 <code>M-x rename-file RET ~/foo RET /tmp/ RET</code> 会将 '~/foo' 重命名为 '/tmp/foo' 。在 GNU 及其他类 POSIX 系统中，目录名均以 '<code>/</code>' 结尾。
</p>

<p>
当新文件名已存在时，所有这类命令都会先请求用户确认，再执行后续操作。
</p>

<p>
<code>M-x copy-file</code> ：将原文件的内容复制到新文件中。
</p>

<p>
<code>M-x copy-directory</code> ：复制目录，功能与 Shell 命令 <code>cp -r</code> 类似。若 <code>new</code> 为目录名，该命令会创建 <code>old</code> 原目录的副本，并将其放入该目录中；若 <code>new</code> 非目录名，则会把 <code>old</code> 原目录的所有内容复制到一个以 <code>new</code> 新参数命名的新目录中。若变量 <code>copy-directory-create-symlink</code> 设为非 nil 且原目录为符号链接，该命令会直接复制此符号链接；若设为 <code>nil</code> （默认值），则会跟随符号链接，复制链接指向的实际内容。
</p>

<p>
<code>M-x rename-file</code> ：将 <code>old</code> 原文件重命名为 <code>new</code> 新文件名。若 <code>new</code> 新文件名已存在，你必须输入 <code>yes</code> 确认，否则重命名操作不会执行；这是因为重命名会导致 <code>new</code> 新文件名原本对应的文件关联被覆盖。若原文件和新文件所在的文件系统不同，该命令会先将原文件复制到新位置，再删除原文件。
</p>

<p>
若文件受版本控制系统管理（参见《<a href="#Version-Control">版本控制</a>》章节），应使用 <code>M-x vc-rename-file</code> 而非 <code>M-x rename-file</code> 执行重命名操作，具体参见《<a href="#VC-Delete_002fRename">删除和重命名受版本控制的文件</a>》章节。
</p>

<p>
<code>M-x add-name-to-file</code> ：为已有文件添加一个额外的文件名，且保留原文件名不变。该命令会通过为现有文件创建 <b>硬链接</b> 的方式生成新名称，新文件名必须与原文件位于 <b>同一文件系统</b> 中。在微软视窗系统中，该命令仅在文件存储于 NTFS 文件系统时生效；在 MS-DOS 系统及部分远程系统中，该命令会通过 <b>复制文件</b> 的方式实现多文件名关联。
</p>

<p>
<code>M-x make-symbolic-link</code> ：创建一个名为新文件名的 <b>符号链接</b> ，该链接指向指定的目标文件 / 目录。创建后，后续尝试打开该符号链接时，会访问其指向的目标文件 / 目录；若此时目标不存在，则会触发错误。该命令 <b>不会展开</b> 目标参数的路径，因此你可以指定相对路径作为链接的目标；但该命令会展开目标参数中开头的 '<code>' （方便你指定主目录），并剔除开头的 '=/:=' （方便你指定以字面量 '</code>' 或 '<code>/:</code>' 开头的相对路径），具体参见《<a href="#Quoted-File-Names">带引用的文件名</a>》章节。在微软视窗系统中，该命令仅在 Vista 及更高版本中生效；若符号链接的新文件名指向远程位置，命令是否生效取决于对应的远程系统类型。
</p>
</div>
</div>
<div id="outline-container-Misc-File-Ops" class="outline-3">
<h3 id="Misc-File-Ops"><span class="section-number-3">20.12.</span> 各类文件操作</h3>
<div class="outline-text-3" id="text-Misc-File-Ops">
<p>
Emacs 提供了执行各类其他文件操作的命令，这类命令均仅对单个文件生效， <b>不支持带通配符的文件名</b> 。
</p>

<p>
<code>M-x delete-file</code> ：会提示输入文件名并将其删除。若需删除同一目录下的多个文件，使用 Dired 目录编辑器会比该命令更便捷，参见《<a href="#Dired-Deletion">使用 Dired 删除文件</a>》章节。
</p>

<p>
<code>M-x move-file-to-trash</code> ：将文件移至系统 Trash回收站（或 Recycle Bin废纸篓）。该功能在多数操作系统中均支持，移至回收站的文件若后续反悔，可进行恢复（回收站文件的恢复方式因系统而异）。
</p>

<p>
默认情况下，Emacs 的删除类命令不会使用回收站功能。若希望常用删除命令在回收站可用时优先使用该功能，可将变量 <code>delete-by-moving-to-trash</code> 设为 <code>t</code> 。该设置会对 <code>M-x delete-file</code> 、 <code>M-x delete-directory</code> （参见《<a href="#Directories">文件目录</a>》章节），以及 Dired 中的所有删除命令（参见《<a href="#Dired-Deletion">使用 Dired 删除文件</a>》章节）生效。为 <code>M-x delete-file</code> 或 <code>M-x delete-directory</code> 添加前缀参数时，无论 <code>delete-by-moving-to-trash</code> 如何设置，都会直接永久删除文件，而非移至回收站。
</p>

<p>
若你已开启 <code>delete-by-moving-to-trash</code> ，且希望在 Emacs 中手动删除回收站目录中的文件，使用 <code>D</code> (<code>dired-do-delete</code>) 这类命令的效果会很差（该操作仅会为文件重命名，无法实现实际删除）。若需要实现该需求，可在回收站目录中创建一个 <code>.dir-locals.el</code> 文件，并在其中写入以下内容：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">((dired-mode . ((delete-by-moving-to-trash . nil))))
</pre>
</div>

<p>
但需注意，若使用系统的「清空回收站」命令，该 <code>.dir-locals.el</code> 文件也可能被一并删除，因此该方法仅适用于手动删除回收站文件的场景。
</p>

<p>
若变量 <code>remote-file-name-inhibit-delete-by-moving-to-trash</code> 设为非nil值，远程文件将永远不会被移至回收站，而是直接被删除。
</p>

<p>
若文件受版本控制系统管理（参见《<a href="#Version-Control">版本控制</a>》章节），应使用 <code>M-x vc-delete-file</code> 而非 <code>M-x delete-file</code> 执行删除操作，参见《<a href="#VC-Delete_002fRename">删除和重命名受版本控制的文件</a>》章节。
</p>

<p>
<code>M-x insert-file</code> （快捷键亦为 <code>C-x i</code> ）：将指定文件的内容副本插入到当前缓冲区的光标位置，光标会保留在插入内容的前方不变。插入内容的末尾位置会被添加到标记环中，且不会激活标记（参见《<a href="#Mark-Ring">标记环</a>》章节）。
</p>

<p>
<code>M-x insert-file-literally</code> ：功能与 <code>M-x insert-file</code> 类似，区别在于该命令会 <b>以字面形式插入文件内容</b> —— 将文件视为纯 ASCII 字符序列，不进行任何特殊的编码转换，与 <code>M-x find-file-literally</code> 命令的处理方式一致（参见《<a href="#Visiting">访问文件</a>》章节）。
</p>

<p>
<code>M-x write-region</code> ：是 <code>M-x insert-file</code> 的反向操作，会将缓冲区中选定区域的内容复制到指定文件中。 <code>M-x append-to-file</code> ：将选定区域的文本追加到指定文件的末尾，参见《<a href="#Accumulating-Text">文本累积</a>》章节。变量 <code>write-region-inhibit-fsync</code> 对这两个命令及文件保存操作均生效，参见《<a href="#Customize-Save">自定义文件保存方式</a>》章节。
</p>

<p>
<code>M-x set-file-modes</code> ：会先提示输入文件名，再提示输入文件权限模式，并将该模式应用到指定文件上。文件模式也被称为文件权限，用于决定文件的读、写、执行权限归属。该命令读取的文件模式，支持 <code>chmod</code> 系统命令的符号型或八进制型格式，例如 '<code>u+x</code>' 表示为文件的所有者添加执行权限。该命令在不支持文件模式的操作系统中不产生任何效果。 <code>chmod</code> 是该函数的便捷别名，可直接使用
</p>
</div>
</div>
<div id="outline-container-Compressed-Files" class="outline-3">
<h3 id="Compressed-Files"><span class="section-number-3">20.13.</span> 访问压缩文件</h3>
<div class="outline-text-3" id="text-Compressed-Files">
<p>
你在打开压缩文件时，Emacs 会自动对其进行解压缩；若你修改并保存该类文件，Emacs 会自动将其重新压缩。Emacs 通过 <b>文件名</b> 识别压缩文件，以 '<code>.gz</code>' 结尾的文件表示由 <code>gzip</code> 工具压缩的文件，其他后缀则对应其他压缩程序。
</p>

<p>
自动解压缩与重新压缩功能，适用于 Emacs 中所有涉及读取文件内容的操作，包括打开文件、保存文件、将文件内容插入缓冲区、加载文件以及字节编译文件。
</p>

<p>
若要关闭该功能，可执行命令 <code>M-x auto-compression-mode</code> ；若需永久禁用，可对变量 <code>auto-compression-mode</code> 进行自定义设置。
</p>
</div>
</div>
<div id="outline-container-File-Archives" class="outline-3">
<h3 id="File-Archives"><span class="section-number-3">20.14.</span> 文件归档包</h3>
<div class="outline-text-3" id="text-File-Archives">
<p>
文件名以 '<code>.tar</code>' 结尾的文件，通常是由 <code>tar</code> 程序创建的归档文件。Emacs 会以一种特殊的 <b>Tar 模式</b> 打开这类文件，该模式会以类 Dired 的形式展示归档内的内容（参见《<a href="#Dired">目录编辑器 Dired</a>》章节）。你可以像在 Dired 中一样浏览该列表，也能打开归档中包含的子文件，但并非所有 Dired 命令都能在 Tar 模式中使用。
</p>

<p>
若自动压缩模式处于启用状态（参见《<a href="#Compressed-Files">访问压缩文件</a>》章节），Tar 模式也会适用于压缩归档文件 —— 即扩展名是=.tgz= 、 <code>.tar.Z</code> 和 <code>.tar.gz</code> 的文件。
</p>

<p>
按下 <code>e</code> 、 <code>f</code> 键或 <code>RET</code> 回车键，均可将归档中的单个子文件提取并在独立缓冲区中打开。你可在该缓冲区中编辑文件，若保存此缓冲区，修改后的版本会替换 Tar 模式缓冲区中对应的原文件。用鼠标点击 Tar 模式缓冲区中的文件名，也能实现相同的提取编辑操作。按下 <code>v</code> 键会将文件提取到 <b>视图模式</b> 的缓冲区中打开（参见《<a href="#View-Mode">视图模式</a>》章节）；按下 <code>o</code> 键会提取文件并在另一个窗口中展示，方便你同时编辑子文件和操作归档文件。
</p>

<p>
按下 <code>I</code> 键可向归档中添加一个新的普通文件，该文件初始状态为空，你可通过上述命令对其进行编辑。该命令会将新文件插入到当前光标所在文件的前方：在 Tar 模式缓冲区的首行执行此命令，新文件会成为归档中的第一个文件；在缓冲区末尾执行此命令，新文件则会成为归档的最后一个文件。
</p>

<p>
与 Dired 中相同，按下 <code>d</code> 键可为文件标记删除标识，后续按下 <code>x</code> 键即可执行删除；按下 <code>u</code> 键可取消文件的标记。按下 <code>C</code> 键可将归档中的文件复制到本地磁盘；按下 <code>R</code> 键可重命名归档内的文件。按下 <code>g</code> 键可根据磁盘上的原归档文件，恢复 Tar 模式缓冲区的内容。按下 <code>M</code> 、 <code>G</code> 、 <code>O</code> 键，可分别修改归档内文件的权限位、所属用户组和文件所有者。
</p>

<p>
保存 Tar 模式缓冲区时，Emacs 会根据你对归档内子文件所做的修改，在磁盘上生成一份新的归档文件。
</p>

<p>
使用 Tar 模式无需依赖 tar 程序 ——Emacs 会直接读取归档文件，但访问压缩归档文件时，仍需要对应的解压缩程序支持。
</p>

<p>
Emacs 还提供了一个独立但功能相近的 <b>归档模式</b> （Archive mode），适用于 <code>arc</code> 、 <code>jar</code> 、 <code>lzh</code> 、 <code>zip</code> 、 <code>rar</code> 、 <code>7z</code> 、 <code>zoo</code> 格式的归档文件，同时也支持自解压可执行文件（exe 格式）。
</p>

<p>
归档模式的按键绑定与 Tar 模式基本一致，额外增加了 <code>m</code> 键（为文件标记标识，以便执行后续批量操作）和 <code>M-DEL</code> 键（取消所有已标记文件的标识）。此外，对于部分无法在单行内完整展示详情的归档格式，按下 <code>a</code> 键可切换是否显示文件的详细信息。需要注意的是，重命名子文件、修改文件权限或所有者这类操作，仅对部分归档格式提供支持。
</p>

<p>
与 Tar 模式不同，归档模式会调用对应的归档程序来完成归档的解包和重新打包操作。不过仅查看归档的目录内容时，无需依赖这些程序，只有提取或操作归档内的子文件时才会用到。相关程序的名称及其执行参数，可在 '<code>Archive</code>' 自定义组中进行设置（参见《<a href="#Customization-Groups">自定义组</a>》章节）。
</p>
</div>
</div>
<div id="outline-container-Remote-Files" class="outline-3">
<h3 id="Remote-Files"><span class="section-number-3">20.15.</span> 远程文件</h3>
<div class="outline-text-3" id="text-Remote-Files">
<p>
你可通过一种特殊的文件名语法，引用其他机器上的文件，语法格式如下：
</p>

<div class="org-src-container">
<pre class="src src-shell">/method:host:filename
/method:user@host:filename
/method:user@host#port:filename
</pre>
</div>

<p>
为执行远程文件访问请求，Emacs 会调用 <code>ssh</code> 等远程登录程序。在文件名中，你必须明确指定使用的访问方式 —— 例如 <code>/ssh:user@host:filename</code> 表示使用 <code>ssh</code> 方式访问。若在文件名中指定伪访问方式用 '-'，Emacs 会按以下规则自动选择访问方式：
</p>
<ol class="org-ol">
<li>若主机名以 'ftp.' （带句点）开头，使用 <code>FTP</code> 方式；</li>
<li>若用户名设为 'ftp' 或 'anonymous' ，使用 <code>FTP</code> 方式；</li>
<li>若变量 <code>tramp-default-method</code> 设为 <code>ftp</code> ，使用 <code>FTP</code> 方式；</li>
<li>若 <code>ssh-agent</code> 进程正在运行，使用 <code>scp</code> 方式；</li>
<li>其他情况，默认使用 <code>ssh</code> 方式。</li>
</ol>

<p>
执行命令 <code>M-x inhibit-remote-files</code> 可彻底关闭远程文件名功能；也可在文件名前添加 '<code>/:</code>' 进行引用（参见《<a href="#Quoted-File-Names">带引用的文件名</a>》），单独禁用某一次的远程文件访问。
</p>

<p>
通过 <code>FTP</code> 方式的远程文件访问，由 <code>Ange-FTP</code> 包处理，相关用法见下文说明；其他访问方式的远程文件操作，均由 Tramp 包处理，该包有独立的使用手册，参见《<a href="https://www.gnu.org/software/emacs/manual/html_node/tramp/index.html#Top">Tramp 手册</a>》。
</p>

<p>
使用 Ange-FTP 包访问远程文件时，若远程文件名中指定了用户名 <code>user</code> ，Emacs 会使用该用户名通过 FTP 登录；若未指定用户名，默认使用本地系统的用户名登录。若将变量 <code>ange-ftp-default-user</code> 设为某个字符串，Emacs 会使用该字符串作为默认登录用户名。登录过程中，Emacs 可能会提示你输入密码。
</p>

<p>
出于性能考虑，Emacs 默认不会为通过 FTP 访问的远程文件创建备份文件。若需要开启该功能，将变量 <code>ange-ftp-make-backup-files</code> 设为非nil值即可。
</p>

<p>
远程文件的自动保存文件，默认会创建在本地机器的临时文件目录中，具体由变量 <code>auto-save-file-name-transforms</code> 指定，参见《<a href="#Auto-Save-Files">自动保存文件</a>》章节。
</p>

<p>
访问支持匿名 FTP 的远程文件时，需使用专用用户名 <code>anonymous</code> 或 <code>ftp</code> ，这类用户名的密码会做特殊处理，具体由变量 <code>ange-ftp-generate-anonymous-password</code> 控制：
</p>
<ul class="org-ul">
<li>若该变量值为一个字符串，直接使用该字符串作为密码；</li>
<li>若该变量值为非nil（默认值），使用 <code>user-mail-address</code> 变量的值作为密码；</li>
<li>若该变量值为 <code>nil</code> ，Emacs 会像常规操作一样，提示你手动输入密码（参见《<a href="#Passwords">输入密码</a>》）。</li>
</ul>

<p>
有时因中间的防火墙出于安全考虑拦截了连接，你无法直接访问远程机器上的文件。若你能 <b>登录某台网关机器</b> ，且该机器可访问目标文件、其 FTP 服务器支持网关功能，仍可正常使用远程文件名访问 —— 只需将变量 <code>ange-ftp-gateway-host</code> 设为该网关机器的名称，并将 <code>ange-ftp-smart-gateway</code> 设为 <code>t</code> 即可。若上述条件不满足，也可通过其他复杂步骤实现远程文件访问，执行命令 <code>M-x finder-commentary RET ange-ftp RET</code> 可查看详细操作说明。
</p>
</div>
</div>
<div id="outline-container-Quoted-File-Names" class="outline-3">
<h3 id="Quoted-File-Names"><span class="section-number-3">20.16.</span> 带引用的文件名</h3>
<div class="outline-text-3" id="text-Quoted-File-Names">
<p>
你可以对绝对文件名进行 <b>quote引用处理</b> ，避免其中的特殊字符和语法触发相应的特殊效果，具体方法是在文件名开头添加 '<code>/:</code>' 。
</p>

<p>
例如，若某个本地文件名的格式看似远程文件路径，可通过引用将其标记为本地文件，防止 Emacs 将其当作远程文件名处理。比如你有一个名为 <code>/foo:</code> 的目录，其中包含文件 'bar' ，在 Emacs 中可通过 '<code>/:/foo:/bar</code>' 引用该文件。
</p>

<p>
若仅需对远程文件名的本地路径部分中的特殊字符进行引用，可仅为该部分添加引用标识。例如 <code>/ssh:baz:/:/foo:/bar</code> ，表示访问主机 <code>baz</code> 上 <code>/foo:</code> 目录中的 <code>bar</code> 文件。
</p>

<p>
'<code>/:</code>' 也能阻止 '~' 被解析为用户主目录的特殊标识。例如 <code>/:/tmp/~hack</code> ，指向的是 <code>/tmp</code> 目录下一个名为 <code>~hack</code> 的文件。
</p>

<p>
在迷你缓冲区中输入包含 '<code>$</code>' 的文件名时，也可通过 '<code>/:</code>' 进行引用，但需 <b>注意</b>  '<code>/:</code>' 必须置于迷你缓冲区输入内容的开头（也可将每个 '<code>$</code>' 重复输入一次来实现相同效果，参见《<a href="#File-Names">含 $ 的文件名</a>》章节）。
</p>

<p>
访问文件时，还能通过 '<code>/:</code>' 对通配符进行引用。例如输入 <code>/:/tmp/foo*bar</code> ，会直接访问 <code>/tmp</code> 目录下的 <code>foo*bar</code> 文件（而非将 '<code>*</code>' 当作通配符匹配）。
</p>

<p>
实现上述效果还有另一种方法：输入 <code>/tmp/foo[*]bar</code> ，这种通配符写法仅会匹配 <code>/tmp/foo*bar</code> 这一个文件。不过在很多情况下，无需对通配符进行引用，因为即便不引用，也能得到预期结果。例如，若 <code>/tmp</code> 目录中唯一以 <code>foo</code> 开头、以 <code>bar</code> 结尾的文件就是 <code>foo*bar</code> ，那么直接输入 <code>/tmp/foo*bar</code> ，Emacs 也会仅访问该文件。
</p>
</div>
</div>
<div id="outline-container-File-Name-Cache" class="outline-3">
<h3 id="File-Name-Cache"><span class="section-number-3">20.17.</span> 文件名缓存</h3>
<div class="outline-text-3" id="text-File-Name-Cache">
<p>
你可以使用 <code>file name cache文件名缓存</code> 功能，轻松通过文件名定位文件，而无需准确记住文件的存放位置。在迷你缓冲区中输入文件名时，按下 <code>C-TAB</code> (<code>file-cache-minibuffer-complete</code>) 可通过文件名缓存完成补全。重复按下 <code>C-TAB</code> ，会循环展示你初始输入内容的所有可能补全结果。（请注意，在大多数文本终端中无法输入 <code>C-TAB</code> 组合键。）
</p>

<p>
文件名缓存不会自动填充内容，需通过以下命令将文件名手动加载至缓存中：
</p>
<dl class="org-dl">
<dt><code>M-x file-cache-add-directory RET 目录名 RET</code></dt><dd>将指定目录下的所有文件名添加至文件名缓存。</dd>
<dt><code>M-x file-cache-add-directory-using-find RET 目录名 RET</code></dt><dd>将指定目录及其所有嵌套子目录下的所有文件名添加至文件名缓存。</dd>
<dt><code>M-x file-cache-add-directory-using-locate RET 目录名 RET</code></dt><dd>通过 <code>locate</code> 命令查找指定目录及其所有嵌套子目录下的所有文件，并将这些文件名添加至文件名缓存。</dd>
<dt><code>M-x file-cache-add-directory-list RET 变量名 RET</code></dt><dd>将指定变量中列出的所有目录下的文件名，全部添加至文件名缓存。该变量需为 Lisp 变量，且其值为目录列表，类似 <code>load-path</code> 变量的格式。</dd>
<dt><code>M-x file-cache-clear-cache RET</code></dt><dd>清空缓存，即移除缓存中的所有文件名。</dd>
</dl>

<p>
文件名缓存不具备持久性：其内容仅在当前 Emacs 会话期间保留和维护。你可通过 <code>file-cache-display</code> 命令查看缓存中的内容。
</p>
</div>
</div>
<div id="outline-container-File-Conveniences" class="outline-3">
<h3 id="File-Conveniences"><span class="section-number-3">20.18.</span> 查找文件的便捷功能</h3>
<div class="outline-text-3" id="text-File-Conveniences">
<p>
本节将介绍一些实用工具，可用于查找近期打开的文件、从缓冲区中读取文件名。
</p>

<p>
执行 <code>M-x recentf-mode</code> 启用 <b>最近文件模式</b> 后，Emacs 会自动维护一份近期打开的文件列表。要从该列表中打开文件，可使用 <code>M-x recentf-open</code> 命令。开启此模式后，'File' 菜单中会新增一个子菜单，你可通过该子菜单快速访问列表中的文件。 <code>M-x recentf-save-list</code> 命令可将当前的最近文件列表(<code>recentf-list</code>) 保存至文件中， <code>M-x recentf-edit-list</code> 命令则可对该列表进行编辑。
</p>

<p>
若你使用远程文件，可自定义变量 <code>remote-file-name-access-timeout</code> ，该变量用于设置超时秒数 —— 超过此时间后，Emacs 会停止检查是否将该远程文件加入最近文件列表，以此避免程序出现阻塞。
</p>

<p>
<code>M-x ffap</code> 命令是 <code>find-file</code> 命令的增强版，配备了更智能的启发式默认规则（参见《<a href="#FFAP">访问光标位置处的文件和网址</a>》），其匹配逻辑通常基于光标所在位置的文本内容。 <b>部分补全模式</b> 提供了其他扩展 <code>find-file</code> 的功能，可与 <code>ffap</code> 命令配合使用，相关说明参见《<a href="#Completion-Options">补全选项</a>》。
</p>
</div>
</div>
<div id="outline-container-Image-Mode" class="outline-3">
<h3 id="Image-Mode"><span class="section-number-3">20.19.</span> 查看图像文件</h3>
<div class="outline-text-3" id="text-Image-Mode">
<p>
打开图像文件时，Emacs 会自动启用 <b>Image mode图像模式</b> 。在该主模式下，按下 <code>C-c C-c</code> (<code>image-toggle-display</code>) 可在两种显示状态间切换：一是在 Emacs 缓冲区中以图像形式展示文件，二是展示文件的底层文本（或原始字节）格式。此外，按下 <code>C-c C-x</code> (<code>image-toggle-hex-display</code>) ，可在图像显示与十六进制格式显示间切换。 <b>仅当 Emacs 编译时启用了对应图像的显示支持</b> ，才能以图像形式展示文件。
</p>

<p>
若显示的图像宽或高超过所在窗口尺寸，使用常规的光标移动按键（ <code>C-f</code> 、 <code>C-p</code> 等）可切换显示图像的不同区域。不过 Emacs 默认会自动调整图像大小以适配窗口，因此仅当你通过 <code>image-auto-resize</code> 和 <code>image-auto-resize-on-window-resize</code> 选项自定义了默认行为后，才需要手动移动查看。
</p>

<p>
你可通过以下命令手动调整图像尺寸：
</p>
<ul class="org-ul">
<li>按下 <code>s w</code> 执行 <code>image-transform-fit-to-window</code> ，将图像同时适配窗口的高度和宽度；</li>
<li>按下 <code>s p</code> 执行 <code>image-transform-set-percent</code> ，按原始尺寸的百分比缩放图像；</li>
<li>按下 <code>s s</code> 执行 <code>image-transform-set-scale</code> ，指定缩放系数调整图像大小；</li>
<li>按下 <code>s 0</code> 执行 <code>image-transform-reset-to-initial</code> ，或按下 <code>s o</code> 执行 <code>image-transform-reset-to-original</code> ，将所有图像变换恢复至初始状态。</li>
</ul>

<p>
按下 <code>n</code> (<code>image-next-file</code>) 和 <code>p</code> (<code>image-previous-file</code>) ，可分别打开同一目录中的下一个和上一个图像文件。这两个命令会通过 <b>父级 Dired 缓冲区</b> 确定对应的图像文件，在从归档文件（如 <code>zip</code> 、 <code>tar</code> 文件）中打开图像时也能生效，此时会读取归档模式缓冲区的信息；若未找到归档或 Dired 父级缓冲区，Emacs 会自动打开一个 Dired 缓冲区。
</p>

<p>
浏览图像时，有时需要标记文件以便后续处理（例如选择一组图像复制到其他位置）：按下 <code>m</code> (<code>image-mode-mark-file</code>) ，会在所有显示该文件所在目录的 Dired 缓冲区中标记当前文件；若未打开相关 Dired 缓冲区，会在新缓冲区中打开该目录并完成标记。按下 <code>u</code> (<code>image-mode-unmark-file</code>) 可取消文件标记。按下 <code>w</code> (<code>image-mode-copy-file-name-as-kill</code>) ，可将当前缓冲区对应的文件名复制到杀环中。
</p>

<p>
若图像支持动画效果，按下 <code>RET</code> (<code>image-toggle-animation</code>) 可启动或停止动画；默认情况下动画仅播放一次，若将 <code>image-animate-loop</code> 设为非nil值则会循环播放。按下 <code>f</code> (<code>image-next-frame</code>) 和 <code>b</code> (<code>image-previous-frame</code>) 可逐帧浏览动画，为命令添加数字前缀可一次跳过多帧；按下 <code>F</code> (<code>image-goto-frame</code>) 可跳转到指定帧（帧的索引从 1 开始）。按下 <code>+</code> (<code>image-increase-speed</code>) 加快动画播放速度，按下 <code>-</code> (<code>image-decrease-speed</code>) 减慢速度，按下 <code>r</code> (<code>image-reverse-speed</code>) 反转播放方向，按下 <code>a 0</code> (<code>image-reset-speed</code>) 将速度恢复为默认值。
</p>

<p>
除上述图像模式专属的按键绑定外，当光标位于 Emacs 任意缓冲区中的图像上或图像内部时，还可使用以下专用按键：
</p>
<dl class="org-dl">
<dt><code>i +</code></dt><dd>将图像放大 20% (<code>image-increase-size</code>) ，数字前缀可自定义放大比例 —— 前缀为 <code>n</code> 时，图像尺寸会乘以 <code>1 + n/10</code> ，例如 <code>C-u 5 i +</code> 表示将图像放大 50%。</dd>
<dt><code>i -</code></dt><dd>将图像缩小 20% (<code>image-decrease-size</code>) ，数字前缀可自定义缩小比例 —— 前缀为 <code>n</code> 时，图像尺寸会乘以 <code>1 - n/10</code> ，例如 <code>C-u 3 i -</code> 表示将图像缩小 30%。</dd>
<dt><code>i r</code></dt><dd>将图像顺时针旋转 90 度 (<code>image-rotate</code>) ，添加前缀参数则为逆时针旋转 90 度（该命令对分片图像无效）。</dd>
<dt><code>i h</code></dt><dd>将图像水平翻转 (<code>image-flip-horizontally</code>) ，效果等同于通过垂直镜面反射图像（该命令对分片图像无效）。</dd>
<dt><code>i v</code></dt><dd>将图像垂直翻转 (<code>image-flip-vertically</code>) ，效果等同于通过水平镜面反射图像（该命令对分片图像无效）。</dd>
<dt><code>i o</code></dt><dd>将图像保存至文件 (<code>image-save</code>) ，命令会提示输入保存的文件名。</dd>
<dt><code>i c</code></dt><dd>裁剪图像 (<code>image-crop</code>) ， <b>仅当系统安装了可用于图像裁剪的外部程序</b> 时该命令才可用， <code>image-crop-crop-command</code> 变量用于指定裁剪程序，默认使用 <code>ImageMagick</code> 的 <code>convert</code> 程序。执行该命令后，图像上会叠加一个矩形裁剪框，可通过鼠标移动和调整裁剪框大小；按下 <code>m</code> 可将鼠标操作从调整尺寸切换为移动裁剪框，按下 <code>s</code> 可将裁剪框锁定为正方形；调整满意后按下 <code>RET</code> 回车键完成裁剪，按下 <code>q</code> 则退出不执行裁剪，裁剪后的图像可通过 <code>i o</code> 或 <code>M-x image-save</code> 保存。</dd>
<dt><code>i x</code></dt><dd>从图像中裁剪出矩形区域并删除 (<code>image-cut</code>) ，该命令的使用条件与 <code>image-crop</code> 一致（需通过 <code>image-crop-cut-command</code> 指定外部程序），与裁剪不同的是，该命令会删除裁剪框内的图像区域，并将该区域填充为 <code>image-cut-color</code> 指定的颜色；添加前缀参数时，命令会提示自定义填充颜色。</dd>
</dl>

<p>
上述图像尺寸调整和旋转命令支持 <b>连续操作</b> ，即首次按下 <code>i</code> 前缀后，后续可直接按 <code>+</code> 、 <code>-</code> 、 <code>r</code> 等键继续调整，无需重复输入 <code>i</code> 。
</p>

<p>
若 Emacs 编译时启用了 <b>ImageMagick 库</b> 支持，可通过该库渲染多种格式的图像。 <code>imagemagick-enabled-types</code> 变量列出了 Emacs 可使用 ImageMagick 渲染的图像类型，列表中的每个元素为 ImageMagick 内部的图像类型名（可为符号或对应字符串，例如 BMP 对应 <code>.bmp</code> 格式）；将该变量设为 <code>t</code> ，可让 Emacs 对所有支持的图像类型均使用 ImageMagick 渲染。 <code>imagemagick-types-inhibit</code> 变量列出了 <b>禁止</b> 使用 ImageMagick 渲染的图像类型（不受 <code>imagemagick-enabled-types</code> 取值影响），默认列表包含 C、HTML 等类型 —— 这类类型虽能被 ImageMagick 渲染为图像，但 Emacs 不应做此处理；将该变量设为 <code>t</code> ，可彻底禁用 ImageMagick 的图像渲染功能。
</p>

<p>
若 Emacs 本身不支持某类图像格式，且 <code>image-use-external-converter</code> 设为非nil值，Emacs 会尝试查找外部工具，将该格式图像转换为 PNG 格式后再进行显示，目前支持的转换工具包括 GraphicsMagick、ImageMagick 和 ffmpeg。
</p>

<p>
此外，你可为特定图像格式添加自定义处理程序，通过 <code>image-converter-add-handler</code> 函数即可实现。例如，要将 <code>Krita</code> 文件以普通图像形式查看，可执行以下代码：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(image-converter-add-handler
 <span style="color: #8b2252;">"kra"</span>
 (<span style="color: #a020f0;">lambda</span> (file data-p)
   (<span style="color: #a020f0;">if</span> data-p
       (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #8b2252;">"Can't decode non-files"</span>)
     (call-process <span style="color: #8b2252;">"unzip"</span> nil t nil
                   <span style="color: #8b2252;">"-qq"</span> <span style="color: #8b2252;">"-c"</span> <span style="color: #8b2252;">"-x"</span> file <span style="color: #8b2252;">"mergedimage.png"</span>))))
</pre>
</div>

<p>
该函数接收两个参数：第一个为文件后缀名，第二个为执行转换的处理函数。处理函数同样接收两个参数：第一个为文件名或图像数据字符串，第二个为布尔值（标识第一个参数是数据还是文件名），处理函数需在当前缓冲区中输出 <code>image-convert-to-format</code> 格式的图像数据。
</p>

<p>
你还可使用Image-Dired 包以缩略图形式查看图像，详见《<a href="#Image_002dDired">在 Dired 中查看图像缩略图</a>》章节。
</p>
</div>
</div>
<div id="outline-container-Filesets" class="outline-3">
<h3 id="Filesets"><span class="section-number-3">20.20.</span> 文件集（Filesets）</h3>
<div class="outline-text-3" id="text-Filesets">
<p>
若你需要定期编辑某一组特定文件，可将其定义为一个 <b>fileset文件集</b> ，通过文件集可一次性对所有文件执行打开、查询替换、执行 Shell 命令等操作。要使用文件集功能，需先在初始化文件中添加表达式 <code>(filesets-init)</code> （参见《<a href="#Init-File">Emacs 初始化文件</a>》章节），该操作会在菜单栏的 'File' 菜单下添加一个 'Filesets' 子菜单。
</p>

<p>
定义文件集最简便的方式是逐个向其中添加文件：打开目标文件后，执行 <code>M-x filesets-add-buffer RET 文件名 RET</code> ，即可将当前文件添加至指定名称的文件集；若该名称的文件集尚未存在，会自动创建一个新文件集，且初始仅包含当前文件。执行 <code>M-x filesets-remove-buffer</code> 命令，可将当前文件从对应文件集中移除。
</p>

<p>
你也可通过 <code>M-x filesets-edit</code> 命令（或从「Filesets」菜单中选择「Edit Filesets」选项）直接编辑文件集列表，编辑操作会在自定义缓冲区中完成（参见《<a href="#Easy-Customization">简易自定义界面</a>》章节）。默认情况下，文件集是一个简单的文件列表，你也可将文件集定义为 <b>匹配文件名的正则表达式</b> ，自定义缓冲区中会展示这类复杂文件集的示例。若希望在后续的 Emacs 会话中继续使用这些文件集，记得选择「Save for future sessions保存供后续会话使用」。
</p>

<p>
执行 <code>M-x filesets-open</code> 命令可打开某个文件集中的所有文件， <code>M-x filesets-close</code> 命令可关闭文件集中的所有文件；执行 <code>M-x filesets-run-cmd</code> 命令，可对某个文件集中的所有文件执行指定的 Shell 命令。这些命令也可通过「Filesets」菜单调用，菜单中会为每个已存在的文件集单独创建一个子菜单。
</p>

<p>
另有一种不同概念的文件集可参见《<a href="#Version-Control">版本控制</a>》章节，这类文件集是为执行版本控制操作而组合的文件组， <b>无命名且不会在 Emacs 会话间持久保存</b> 。
</p>
</div>
</div>
</section>
<section id="outline-container-Buffers" class="outline-2">
<h2 id="Buffers"><span class="section-number-2">21.</span> 多缓冲区的使用</h2>
<div class="outline-text-2" id="text-Buffers">
<p>
你在 Emacs 中编辑的文本，会存储在一个名为 <b>buffer缓冲区</b> 的对象中。每次打开文件时，Emacs 都会创建一个缓冲区来存放该文件的文本；每次调用 Dired 目录编辑器时，会生成一个缓冲区来展示目录列表；使用 <code>C-x m</code> 发送消息时，消息文本也会由一个缓冲区承载；查询命令的帮助文档时，文档内容会显示在名为 <code>*Help*</code> 的缓冲区中。
</p>

<p>
缓冲区会在使用期间一直存在，当不再需要时，会由用户（参见《<a href="#Kill-Buffer">删除缓冲区</a>》）或 Emacs 自身删除（即「销毁」，例如退出 Emacs 时，参见《<a href="#Exiting">退出 Emacs</a>》）。
</p>

<p>
每个缓冲区都有一个 <b>唯一的名称</b> ，名称可包含任意字符且无长度限制。当缓冲区在窗口中显示时，其名称会出现在模式行中（参见《<a href="#Mode-Line">模式行</a>》）。缓冲区名称区分大小写，大部分缓冲区由打开文件创建，名称也派生自对应文件名；你也可以创建一个自定义名称的空缓冲区。刚启动的 Emacs 会自带多个缓冲区，其中包含一个名为 <code>*scratch*</code> 的临时缓冲区，可用于执行 Lisp 表达式，该缓冲区不关联任何文件（参见《<a href="#Lisp-Interaction">Lisp 交互缓冲区</a>》）。
</p>

<p>
在任意时刻，Emacs 中 <b>有且仅有一个缓冲区处于选中状态</b> ，该缓冲区被称为 <b>current buffer当前缓冲区</b> 。我们常说某条命令「作用于缓冲区」，实际指该命令作用于当前缓冲区。当 Emacs 中只有一个窗口时，该窗口显示的缓冲区即为当前缓冲区；当存在多个窗口时， <b>select window选中窗口</b> 中显示的缓冲区为当前缓冲区（参见《<a href="#Windows">多窗口</a>》）。
</p>

<p>
缓冲区的内容由一串字符组成，每个字符可选择性地附带一组 <b>文本属性</b> （参见《<a href="#International-Chars">文本属性</a>》），用于记录该字符的额外信息。
</p>

<p>
除文本内容外，每个缓冲区还会记录多项相关信息，包括其关联的文件（若有）、是否被修改、当前启用的 <code>major mode主模式</code> 和 <code>minor mode次要模式</code> （参见《<a href="#Modes">主模式与次要模式</a>》）等。这些信息都存储在 <b>缓冲区局部变量</b> 中 —— 这类变量可在不同缓冲区中拥有不同的值（参见《<a href="#Locals">局部变量</a>》）。
</p>

<p>
缓冲区的大小存在上限，该上限由 Emacs 整数类型所能表示的最大缓冲区位置决定，因为 Emacs 会通过该数据类型跟踪缓冲区位置。对于常见的 64 位系统，缓冲区的最大容量为 2^{61} - 2 字节，约 2 艾字节（EiB）；对于常见的 32 位系统，最大容量通常为 2^{29} - 2 字节，约 512 兆字节（MiB）。此外，缓冲区的实际大小还会受系统内存容量的限制。
</p>

<ul class="org-ul">
<li><a href="#Select-Buffer">创建与选择缓冲区</a></li>
<li><a href="#List-Buffers">列出已有缓冲区</a></li>
<li><a href="#Misc-Buffer">缓冲区的各类杂项操作</a></li>
<li><a href="#Kill-Buffer">关闭缓冲区</a></li>
<li><a href="#Several-Buffers">对多个缓冲区执行批量操作</a></li>
<li><a href="#Indirect-Buffers">间接缓冲区</a></li>
<li><a href="#Buffer-Convenience">缓冲区操作的便捷功能与相关定制</a></li>
</ul>
</div>
<div id="outline-container-Select-Buffer" class="outline-3">
<h3 id="Select-Buffer"><span class="section-number-3">21.1.</span> 创建与选择缓冲区</h3>
<div class="outline-text-3" id="text-Select-Buffer">
<dl class="org-dl">
<dt><code>C-x b buffer RET</code></dt><dd>选中或创建指定名称的缓冲区 (<code>switch-to-buffer</code>) 。</dd>
<dt><code>C-x 4 b buffer RET</code></dt><dd>功能同上，在另一个窗口中选中该缓冲区 (<code>switch-to-buffer-other-window</code>) 。</dd>
<dt><code>C-x 5 b buffer RET</code></dt><dd>功能同上，在独立的框架中选中该缓冲区 (<code>switch-to-buffer-other-frame</code>) 。</dd>
<dt><code>C-x LEFT</code></dt><dd>选中缓冲区列表中的上一个缓冲区 (<code>previous-buffer</code>) 。</dd>
<dt><code>C-x RIGHT</code></dt><dd>选中缓冲区列表中的下一个缓冲区 (<code>next-buffer</code>) 。</dd>
<dt><code>C-u M-g M-g</code></dt><dd></dd>

<dt><code>C-u M-g g</code></dt><dd>读取数字 <code>n</code> ，在另一个窗口中，将光标移至 <b>除当前缓冲区外最近选中的缓冲区</b> 的第 <code>n</code> 行。</dd>
</dl>

<p>
<code>C-x b</code> (<code>switch-to-buffer</code>) 命令会通过迷你缓冲区读取缓冲区名称，随后将该缓冲区设为当前缓冲区，并在当前选中的窗口中展示。若输入为空，则会选中 <b>当前未在任何窗口中显示、且最近一次被设为当前缓冲区</b> 的那个缓冲区。
</p>

<p>
输入缓冲区名称时，可使用常规的补全和历史记录命令（参见《<a href="#Minibuffer">迷你缓冲区</a>》）。注意， <code>C-x b</code> 及相关命令在迷你缓冲区补全时，采用 <b>permissive completion with confirmation 带确认的宽松补全</b> 规则：若按下 <code>RET</code> 回车时，迷你缓冲区中的文本对应的是不存在的缓冲区，Emacs 会打印 '<code>[Confirm]</code>'，你需要再次按下 <code>RET</code> 回车，确认创建该名称的缓冲区。详细规则参见《<a href="#Completion-Exit">补全的退出方式</a>》，其他补全选项与功能参见《<a href="#Completion-Options">补全选项</a>》。
</p>

<p>
若指定的缓冲区不存在， <code>C-x b</code> 会创建一个 <b>未关联任何文件的新空缓冲区</b> ，并将其选中供编辑使用。新缓冲区的主模式由变量 <code>major-mode</code> 的默认值决定，默认为主基础模式（Fundamental mode）（参见《<a href="#Major-Modes">主模式</a>》）。创建新缓冲区的常见用途之一，是记录临时笔记。若你尝试保存该缓冲区，Emacs 会提示输入文件名，且会根据该文件名重新确定缓冲区的主模式（参见《<a href="#Choosing-Modes">文件模式的选择</a>》）。
</p>

<p>
若需要在少数几个缓冲区之间快速切换，可使用 <code>C-x LEFT</code> 和 <code>C-x RIGHT</code> 命令。 <code>C-x 左方向键</code> (<code>previous-buffer</code>) 会选中 <b>上一个缓冲区</b> （按当前框架中最近的选中顺序）， <code>C-x 右方向键</code> (<code>next-buffer</code>) 则按相反顺序切换缓冲区。两个命令均支持数字前缀参数，用于指定切换的次数。
</p>

<p>
若要在 <b>非当前窗口</b> 中选中缓冲区（参见《<a href="#Windows">多窗口</a>》），可输入 <code>C-x 4 b</code> (<code>switch-to-buffer-other-window</code>) 。该命令会通过迷你缓冲区提示输入缓冲区名称，在另一个窗口中展示该缓冲区，并将该窗口设为选中状态。
</p>

<p>
类似地， <code>C-x 5 b</code> (<code>switch-to-buffer-other-frame</code>) 会提示输入缓冲区名称，在另一个框架中展示该缓冲区（参见《<a href="#Frames">框架与图形化显示</a>》），并选中该框架。若该缓冲区已在其他框架的某个窗口中显示，Emacs 会直接选中该窗口和框架，而非创建新框架。
</p>

<p>
关于 <code>C-x 4 b</code> 和 <code>C-x 5 b</code> 命令如何选择展示缓冲区的窗口和 / 或框架，参见《<a href="#Displaying-Buffers">在窗口中展示缓冲区</a>》。
</p>

<p>
此外， <code>C-x C-f</code> 及其他所有打开文件的命令，也可用于切换至已存在的、关联该文件的缓冲区（参见《<a href="#Visiting">访问文件</a>》）。
</p>

<p>
<code>C-u M-g M-g</code> （即带普通前缀参数的 <code>goto-line</code> 命令），会通过迷你缓冲区读取数字 <code>n</code> ，在另一个窗口中选中 <b>除当前缓冲区外最近选中的缓冲区</b> ，并将光标移至该缓冲区的第 <code>n</code> 行开头。该命令主要适用于 <b>某一缓冲区中引用了另一缓冲区行号</b> 的场景：若光标位于某个数字上，或紧邻数字后方， <code>goto-line</code> 会将该数字作为 <code>n</code> 的默认值。注意，非单纯 <code>C-u</code> 的前缀参数，执行效果会不同：例如 <code>C-u 4 M-g M-g</code> ，会直接将光标移至 <b>当前缓冲区</b> 的第 4 行，而不会从迷你缓冲区读取数字。（注意，无前缀参数的 <code>M-g M-g</code> ，会读取数字 <code>n</code> 并将光标移至当前缓冲区的第 <code>n</code> 行，参见《<a href="#Moving-Point">移动光标位置</a>》。）
</p>

<p>
Emacs 会将 <b>以空格开头</b> 的缓冲区名用于内部操作，这类缓冲区会被做一些细微的特殊处理 —— 例如，默认不会记录撤销信息。建议你避免使用此类名称命名自己的缓冲区。
</p>
</div>
</div>
<div id="outline-container-List-Buffers" class="outline-3">
<h3 id="List-Buffers"><span class="section-number-3">21.2.</span> 列出已有缓冲区</h3>
<div class="outline-text-3" id="text-List-Buffers">
<dl class="org-dl">
<dt><code>C-x C-b</code></dt><dd>列出所有已存在的缓冲区 (<code>list-buffers</code>) 。</dd>
</dl>

<p>
键入 <code>C-x C-b</code> 可展示所有已存在的缓冲区列表，该操作会在名为 <code>*Buffer List*</code> 的缓冲区中弹出一个缓冲区菜单。列表中的每一行对应一个缓冲区，展示其缓冲区名、大小、主模式以及关联的文件。缓冲区按 <b>最近成为当前缓冲区的顺序</b> 排列，最近使用的缓冲区会显示在最前方。本节介绍缓冲区列表的展示形式及列表中各类标识的含义； <code>*Buffer List*</code> 缓冲区的专用模式及可使用的相关命令，详见《<a href="#Several-Buffers">对多个缓冲区执行操作</a>》章节。
</p>

<p>
列表每行第一个字段中的 '<code>.</code>' 表示该缓冲区为 <b>当前缓冲区</b> ， '<code>%</code>' 表示该缓冲区为 <b>只读缓冲区</b> ， '<code>*</code>' 表示该缓冲区 <b>已被修改</b> 。若有多个缓冲区标记为已修改，便是时候使用 <code>C-x s</code> 命令保存部分缓冲区了（参见《<a href="#Save-Commands">文件保存相关命令</a>》）。以下是缓冲区列表的示例：
</p>

<div class="org-src-container">
<pre class="src src-shell">CRM Buffer                Size  Mode              File
. * .emacs                3294  ELisp/l           ~/.emacs
 %  *Help*                 101  Help
    search.c             86055  C                 ~/cvs/emacs/src/search.c
 %  src                  20959  Dired by name     ~/cvs/emacs/src/
  * *mail*                  42  Mail
 %  HELLO                 1607  Fundamental       ~/cvs/emacs/etc/HELLO
 %  NEWS                481184  Outline           ~/cvs/emacs/etc/NEWS
    *scratch*              191  Lisp Interaction
  * *Messages*            1554  Messages
</pre>
</div>

<p>
<code>*Help*</code> 缓冲区由帮助查询操作创建（参见《<a href="#Help">帮助功能</a>》），该缓冲区未关联任何文件； <code>src</code> 缓冲区是对目录 <code>~/cvs/emacs/src/</code>  执行 Dired 目录浏览操作后生成的。为该命令添加前缀参数（如执行 <code>C-u C-x C-b</code> ），可仅列出 <b>关联了文件</b> 的缓冲区。
</p>

<p>
默认情况下， <code>list-buffers</code> 命令会 <b>忽略名称以空格开头</b> 的缓冲区（关联了文件的除外），这类缓冲区为 Emacs 的内部使用缓冲区（可通过 <code>I</code> 命令取消该限制，详见《<a href="#Several-Buffers">对多个缓冲区执行操作</a>》章节）。
</p>
</div>
</div>
<div id="outline-container-Misc-Buffer" class="outline-3">
<h3 id="Misc-Buffer"><span class="section-number-3">21.3.</span> 缓冲区的各类杂项操作</h3>
<div class="outline-text-3" id="text-Misc-Buffer">
<dl class="org-dl">
<dt><code>C-x C-q</code></dt><dd>切换缓冲区的只读状态 (<code>read-only-mode</code>) 。</dd>
<dt><code>C-x x r RET 新缓冲区名 RET</code></dt><dd>修改当前缓冲区的名称 (<code>rename-buffer</code>) 。</dd>
<dt><code>C-x x u</code></dt><dd>为当前缓冲区重命名，在原名称后添加数字后缀以保证唯一性 (<code>rename-uniquely</code>) 。</dd>
<dt><code>M-x view-buffer RET buffer RET</code></dt><dd>滚动浏览指定缓冲区的内容（参见「<a href="#View-Mode">视图模式</a>」章节）。</dd>
</dl>


<p>
缓冲区可设置为 <b>read-only只读状态</b> ，处于该状态时，无法执行插入或删除文本的相关命令。（但部分其他命令如 <code>C-x RET f</code> ，仍可将其标记为已修改，参见「<a href="#Text-Coding">为文件文本指定编码系统</a>」章节。）模式行的左侧边缘会显示 '<code>%%</code>' 或 '<code>%*</code>' 标识，以此表示该缓冲区为只读缓冲区（参见「<a href="#Mode-Line">模式行</a>」章节）。只读缓冲区通常由 Dired、Rmail 这类子系统创建，这类子系统会提供专门的命令对缓冲区文本进行操作；若打开的文件在系统权限中被设置为不可写，对应的缓冲区也会被设为只读。
</p>

<p>
执行 <code>C-x C-q</code> (<code>read-only-mode</code>) ，可将只读缓冲区切换为可写状态，也可将可写缓冲区设为只读状态。该命令的实现原理是修改 <code>buffer-read-only</code> 变量 —— 该变量为缓冲区局部变量，若其值为非nil，则对应缓冲区为只读。若将 <code>view-read-only</code> 选项设为非nil，通过 <code>C-x C-q</code> 将缓冲区设为只读时，会同时为该缓冲区启用视图模式（参见「<a href="#View-Mode">视图模式</a>」章节）。
</p>

<p>
执行 <code>C-x x r</code> (<code>rename-buffer</code>) 命令可修改当前缓冲区的名称，需在迷你缓冲区中输入新名称，该命令无默认名称可选；若指定的新名称已被其他缓冲区使用，会触发错误且重命名操作失败。
</p>

<p>
执行 <code>C-x x u</code> (<code>rename-uniquely</code>) 命令会为当前缓冲区生成一个相似的唯一名称，具体方式是在原名称后添加数字后缀，该命令无需传入参数。此命令适用于创建多个 Shell 缓冲区的场景：若先为 <code>*shell*</code> 缓冲区重命名，再执行 <code>M-x shell</code> 命令，Emacs 会创建一个新的 <code>*shell*</code> 缓冲区，而原 Shell 缓冲区会以新名称继续存在。该方法也适用于邮件缓冲区、编译缓冲区，以及 Emacs 中大多数会创建特定名称专用缓冲区的功能。（对于部分此类功能，如 <code>M-x compile</code> 、 <code>M-x grep</code> ，再次执行命令前需先切换至其他缓冲区，否则即便原缓冲区已重命名，该功能仍会复用当前缓冲区。）
</p>

<p>
执行 <code>M-x append-to-buffer</code> 和 <code>C-x x i</code> (<code>insert-buffer</code>) 命令，也可实现将文本从一个缓冲区复制至另一个缓冲区的操作（参见「<a href="#Accumulating-Text">文本累积</a>」章节）。
</p>
</div>
</div>
<div id="outline-container-Kill-Buffer" class="outline-3">
<h3 id="Kill-Buffer"><span class="section-number-3">21.4.</span> 关闭缓冲区</h3>
<div class="outline-text-3" id="text-Kill-Buffer">
<p>
若 Emacs 会话持续运行一段时间，可能会累积大量缓冲区，此时删除不再需要的缓冲区会让操作更便捷（部分其他编辑器将此操作称为 “close”，会提及 “closing the buffer” 或 “closing the file”）。在大多数操作系统中，删除缓冲区会将 Emacs 为该缓冲区占用的内存释放给系统，供其他程序使用。以下是用于删除缓冲区的相关命令：
</p>

<dl class="org-dl">
<dt><code>C-x k buffer RET</code></dt><dd>删除指定缓冲区 (<code>kill-buffer</code>) 。</dd>
<dt><code>M-x kill-some-buffers</code></dt><dd>逐个确认并删除缓冲区。</dd>
<dt><code>M-x kill-matching-buffers</code></dt><dd>确认并删除所有名称匹配指定正则表达式的缓冲区。</dd>
<dt><code>M-x kill-matching-buffers-no-ask</code></dt><dd>功能与 <code>kill-matching-buffers</code> 类似，无需确认直接删除。</dd>
</dl>

<p>
<code>C-x k</code> (<code>kill-buffer</code>) 命令用于删除单个缓冲区，需在迷你缓冲区中指定缓冲区名称；若直接在迷你缓冲区中按 <code>RET</code> 回车，默认删除 <b>当前缓冲区</b> 。若删除的是当前缓冲区，Emacs 会将另一个缓冲区设为当前缓冲区 —— 该缓冲区为近期曾作为当前缓冲区、且当前未在任何窗口中显示的缓冲区。若要删除的是关联了文件且已被修改的缓冲区，必须输入 <code>yes</code> 确认后，删除操作才会执行。
</p>

<p>
<code>M-x kill-some-buffers</code> 命令会逐个对所有缓冲区进行删除确认，输入 <code>yes</code> 即表示删除该缓冲区，效果与 <code>kill-buffer</code> 命令一致。该命令会忽略 Emacs 内部使用的、名称以空格开头的缓冲区。
</p>

<p>
<code>M-x kill-matching-buffers</code> 命令会先提示输入一个正则表达式，随后删除所有名称匹配该表达式的缓冲区（参见《<a href="#Regexps">正则表达式的语法</a>》）。与 <code>kill-some-buffers</code> 命令相同，该命令在删除每个缓冲区前都会要求确认，且默认忽略 Emacs 内部使用的、名称以空格开头的缓冲区；若为该命令添加前缀参数，则会一并删除内部缓冲区。 <code>M-x kill-matching-buffers-no-ask</code> 命令的功能与 <code>kill-matching-buffers</code> 一致，区别是删除匹配的缓冲区时 <b>无需逐次确认</b> 。
</p>

<p>
使用缓冲区菜单功能也能便捷地删除多个缓冲区，详见《<a href="#Several-Buffers">对多个缓冲区执行操作</a>》章节。
</p>

<p>
若希望在每次删除缓冲区时执行自定义操作，可向 <code>kill-buffer-hook</code> 钩子中添加钩子函数（参见《<a href="#Hooks">钩子</a>》章节）。
</p>

<p>
许多用户会让 Emacs 会话连续运行数日，此时会话中会堆积数天前使用过的缓冲区， <code>M-x clean-buffer-list</code> 命令是清理这类缓冲区的便捷方式 —— 该命令会删除所有长期未使用且未被修改的缓冲区。默认情况下，若某个普通缓冲区已 3 天未被显示，就会被该命令删除；你也可以指定某些缓冲区为 <b>禁止自动删除</b> ，同时将另一些缓冲区的自动删除阈值设为仅一小时未使用。该命令的这些默认规则及其他行为，均可通过自定义 <code>clean-buffer-list</code> 文档字符串中描述的相关选项来调整。
</p>

<p>
你也可以启用 <code>Midnight mode 午夜模式</code> ，让系统每日自动执行缓冲区清理操作。午夜模式会在每日午夜触发，执行 <code>clean-buffer-list</code> 命令，或你添加到 <code>midnight-hook</code> 普通钩子中的其他自定义函数（参见《<a href="#Hooks">钩子</a>》章节）。启用该模式的方法是，在自定义缓冲区中将变量 <code>midnight-mode</code> 设为 <code>t</code> （参见《<a href="#Easy-Customization">简易自定义界面</a>》章节）。
</p>
</div>
</div>
<div id="outline-container-Several-Buffers" class="outline-3">
<h3 id="Several-Buffers"><span class="section-number-3">21.5.</span> 对多个缓冲区执行批量操作</h3>
<div class="outline-text-3" id="text-Several-Buffers">
<dl class="org-dl">
<dt><code>M-x buffer-menu</code></dt><dd>打开缓冲区菜单，可编辑 Emacs 所有缓冲区的列表。</dd>
<dt><code>M-x buffer-menu-other-window</code></dt><dd>功能同上，在另一个窗口中打开缓冲区菜单。</dd>
</dl>

<p>
通过 <code>C-x C-b</code> 打开的缓冲区菜单（参见《<a href="#List-Buffers">列出已有缓冲区</a>》）并非仅用于罗列缓冲区，还可通过类 Dired 的操作界面（参见《<a href="#Dired">目录编辑器 Dired</a>》），对缓冲区执行保存、删除、显示等各类操作。
</p>

<p>
使用缓冲区菜单的操作方法：按下 <code>C-x C-b</code> 后，切换至显示 <code>*Buffer List*</code> 缓冲区的窗口即可；也可直接输入 <code>M-x buffer-menu</code> ，在当前选中的窗口中打开缓冲区菜单；此外， <code>M-x buffer-menu-other-window</code> 命令会在另一个窗口中打开缓冲区菜单并自动选中该窗口。
</p>

<p>
缓冲区菜单为只读缓冲区，仅可通过本节介绍的专用命令进行操作，常规的光标移动命令在该缓冲区中均适用。以下命令均作用于光标所在行对应的缓冲区：
</p>
<dl class="org-dl">
<dt><code>d</code></dt><dd>为缓冲区标记删除（killing）标识，随后将光标移至下一行 (<code>Buffer-menu-delete</code>) 。标记后，该行缓冲区名称前会显示字符 '<code>D</code>' 作为删除标识，实际删除操作仅在按下 <code>x</code> 命令后执行（见下文）。</dd>
<dt><code>C-d</code></dt><dd>功能与 <code>d</code> 命令一致，区别是标记后将光标向上移动 (<code>Buffer-menu-delete-backwards</code>) 。</dd>
<dt><code>s</code></dt><dd>为缓冲区标记保存标识 (<code>Buffer-menu-save</code>) 。标记后，该行缓冲区名称前会显示字符 <code>S</code> 作为保存标识，实际保存操作仅在按下 <code>x</code> 命令后执行。可对同一个缓冲区同时标记保存和删除标识。</dd>
<dt><code>x</code></dt><dd>执行所有已标记的删除和保存操作 (<code>Buffer-menu-execute</code>) 。</dd>
<dt><code>u</code></dt><dd>清除光标所在行的所有标识，随后将光标向下移动 (<code>Buffer-menu-unmark</code>) 。若添加数字前缀参数，清除标识后光标会向上移动。</dd>
<dt><code>DEL</code></dt><dd>将光标移至上一行，并清除该行的所有标识 (<code>Buffer-menu-backup-unmark</code>) 。</dd>
<dt><code>M-DEL</code></dt><dd>清除所有行中指定类型的标识 (<code>Buffer-menu-unmark-all-buffers</code>) 。按下该命令后会提示输入一个字符，随后清除所有以该字符为标识的标记；直接按 <code>RET</code> 回车键则清除所有标识。</dd>
<dt><code>U</code></dt><dd>清除所有行的所有标识 (<code>Buffer-menu-unmark-all</code>) 。</dd>
</dl>

<p>
上述的标识清除命令、 <code>d</code> 命令和 <code>C-d</code> 命令，均支持数字前缀参数作为重复执行的次数。
</p>

<p>
以下命令会立即对光标所在行对应的缓冲区执行操作，且均支持数字前缀参数作为重复执行的次数：
</p>
<dl class="org-dl">
<dt><code>~</code></dt><dd>将缓冲区标记为未修改状态 (<code>Buffer-menu-not-modified</code>) ，参见《<a href="#Save-Commands">文件保存相关命令</a>》。</dd>
<dt><code>%</code></dt><dd>切换缓冲区的只读状态 (<code>Buffer-menu-toggle-read-only</code>) ，参见《<a href="#Misc-Buffer">缓冲区的杂项操作</a>》。</dd>
<dt><code>t</code></dt><dd>将该缓冲区作为标签表打开 (<code>Buffer-menu-visit-tags-table</code>) ，参见《<a href="#Select-Tags-Table">选择标签表</a>》。</dd>
</dl>

<p>
以下命令用于选中单个或多个其他缓冲区：
</p>
<dl class="org-dl">
<dt><code>q</code></dt><dd>退出缓冲区菜单 (<code>quit-window</code>) ，原窗口会显示最近一次可见的缓冲区。</dd>

<dt><code>RET</code></dt><dd></dd>

<dt><code>f</code></dt><dd>选中光标所在行的缓冲区，替换当前窗口中的 <code>*Buffer List*</code> 缓冲区 (<code>Buffer-menu-this-window</code>) 。</dd>
<dt><code>o</code></dt><dd>在另一个窗口中选中光标所在行的缓冲区，效果等同于执行 <code>C-x 4 b</code> 命令，保留 <code>*Buffer List*</code> 缓冲区可见 (<code>Buffer-menu-other-window</code>) 。</dd>
<dt><code>C-o</code></dt><dd>在另一个窗口中显示光标所在行的缓冲区，不选中该窗口 (<code>Buffer-menu-switch-other-window</code>) 。</dd>
<dt><code>1</code></dt><dd>在占满整个框架的窗口中选中光标所在行的缓冲区 (<code>Buffer-menu-1-window</code>) 。</dd>
<dt><code>2</code></dt><dd>在当前框架中拆分出两个窗口，一个窗口选中光标所在行的缓冲区，另一个窗口显示此前的当前缓冲区（ <code>*Buffer List*</code> 除外） (<code>Buffer-menu-2-window</code>) 。</dd>
<dt><code>b</code></dt><dd>将光标所在行的缓冲区置为未激活状态 (<code>Buffer-menu-bury</code>) ，即移至缓冲区列表的末尾。</dd>
<dt><code>m</code></dt><dd>为缓冲区标记显示标识，若按下 <code>v</code> 命令退出菜单，该缓冲区会在另一个窗口中显示 (<code>Buffer-menu-mark</code>) 。标记后，该行开头会显示字符 '<code>&gt;</code>' 作为显示标识（一个缓冲区不可同时标记删除和显示标识）。</dd>
<dt><code>v</code></dt><dd>选中光标所在行的缓冲区，同时在其他窗口中显示所有带 <code>m</code> 标记的缓冲区 (<code>Buffer-menu-select</code>) 。若未标记任何带显示标识的缓冲区，该命令的效果与 <code>1</code> 命令一致。</dd>
</dl>

<p>
以下命令作用于整个缓冲区列表：
</p>
<dl class="org-dl">
<dt><code>S</code></dt><dd>根据光标所在列的属性对缓冲区菜单的条目进行排序 (<code>tabulated-list-sort</code>) 。若添加数字前缀参数 <code>n</code> ，则根据第 <code>n</code> 列的属性进行排序。</dd>
<dt><code>}</code></dt><dd>将当前列的宽度增加 <code>n</code> 个字符（ <code>n</code> 为数字前缀参数）。</dd>
<dt><code>{</code></dt><dd>将当前列的宽度减少 <code>n</code> 个字符（ <code>n</code> 为数字前缀参数）。</dd>
<dt><code>T</code></dt><dd>隐藏或重新显示非文件类缓冲区对应的行 (<code>Buffer-menu-toggle-files-only</code>) ，该命令可切换缓冲区列表中是否包含此类缓冲区。</dd>
<dt><code>I</code></dt><dd>切换是否显示内部缓冲区（名称以空格开头的缓冲区）。</dd>
</dl>

<p>
默认情况下，当创建或删除缓冲区时， <code>*Buffer List*</code> 缓冲区不会自动更新，其内容仅为静态文本。若执行了缓冲区的创建、删除或重命名操作，按下 <code>g</code> 键 (<code>revert-buffer</code>) 即可更新 <code>*Buffer List*</code> 的内容，展示最新的缓冲区状态。若该缓冲区未被标记为已修改，在其中启用自动恢复模式后，缓冲区会按照 <code>auto-revert-interval</code> 变量设定的秒数定期自动更新。全局自动恢复模式仅在 <code>global-auto-revert-non-file-buffers</code> 变量值为非 nil 时，才对 <code>*Buffer List*</code> 缓冲区生效，具体细节参见 <a href="#Auto-Reverting-the-Buffer-Menu">global-auto-revert-non-file-buffers</a> 变量的说明。
</p>
</div>
</div>
<div id="outline-container-Indirect-Buffers" class="outline-3">
<h3 id="Indirect-Buffers"><span class="section-number-3">21.6.</span> 间接缓冲区</h3>
<div class="outline-text-3" id="text-Indirect-Buffers">
<p>
<code>indirect buffer间接缓冲区</code> 共享另一缓冲区的文本内容，该缓冲区被称为此间接缓冲区的 <code>base buffer基缓冲区</code> 。在某种程度上，它相当于文件系统中符号链接在缓冲区上的对应实现。
</p>

<p>
<b>相关命令</b>
</p>

<dl class="org-dl">
<dt><code>M-x make-indirect-buffer RET base-buffer RET indirect-name RET</code></dt><dd>创建以指定基缓冲区为文本源、并命名为指定名称的间接缓冲区。</dd>
<dt><code>M-x clone-indirect-buffer 回车</code></dt><dd>创建当前缓冲区的副本间接缓冲区（与原缓冲区完全联动）。</dd>
<dt><code>C-x 4 c</code></dt><dd>创建当前缓冲区的副本间接缓冲区，并在新窗口中选中该间接缓冲区 (<code>clone-indirect-buffer-other-window</code>) 。</dd>
</dl>

<p>
<b>核心特性</b>
</p>

<p>
间接缓冲区的文本始终与基缓冲区  <b>完全一致</b> ：对任意一方的编辑修改，都会立即在另一方中显示。此处的 "Text" 包含字符本身及其所有 <b>文本属性</b> 。
</p>

<p>
但在其他所有方面，间接缓冲区与基缓冲区是 <b>完全独立</b> 的，二者可拥有：不同的缓冲区名称、不同的光标位置、不同的内容窄化范围、不同的标记、不同的叠加层、不同的主模式，以及不同的局部变量。
</p>

<p>
<b>文件操作与缓冲区生命周期</b>
</p>
<ol class="org-ol">
<li>间接缓冲区 <b>无法直接访问文件</b> ，但其基缓冲区可以；若尝试保存间接缓冲区，实际会执行基缓冲区的保存操作。</li>
<li>删除基缓冲区会 <b>连带失效</b> 其所有间接缓冲区；而删除间接缓冲区，对其基缓冲区无任何影响。</li>
</ol>

<p>
<b>典型用法</b>
</p>

<p>
间接缓冲区的常用场景之一是为大纲文档创建 <b>多视图展示</b> ，具体可参考《<a href="#Outline-Views">在多视图中查看单个大纲</a>》章节。
</p>

<p>
<b>快速创建方式</b>
</p>

<p>
使用快捷键 <code>C-x 4 c</code> 是创建间接缓冲区最快捷的方式，该命令会以当前缓冲区为基缓冲区，直接生成副本间接缓冲区并在新窗口打开。若带数字参数执行该命令，会提示用户输入间接缓冲区的自定义名称；无参数时，默认以原缓冲区名称加后缀 '&lt;n&gt;' （n 为数字）命名。
</p>

<p>
<b>通用创建方式</b>
</p>

<p>
使用命令 <code>M-x make-indirect-buffer</code> 可创建自定义的间接缓冲区，该命令会通过迷你缓冲区依次提示用户输入 <b>基缓冲区名</b> 和 <b>间接缓冲区名</b> ，灵活性更高。
</p>

<p>
<b>相关钩子函数</b>
</p>

<p>
创建间接缓冲区的所有函数，都会在缓冲区创建完成后执行钩子函数 <code>clone-indirect-buffer-hook</code> 。该钩子执行时，新创建的间接缓冲区会成为当前缓冲区。
</p>

<p>
<b>注意事项</b>
</p>

<p>
对缓冲区文本进行修改时， <b>修改钩子仅会在基缓冲区中执行</b> —— 原因是这些钩子上的大部分函数并未适配间接缓冲区的运行环境，无法在其中正常工作。因此，若需要在间接缓冲区中使用修改钩子函数，需手动将该函数添加到 <b>基缓冲区</b> 的对应钩子中，并让函数在目标间接缓冲区中执行相关操作。
</p>
</div>
</div>
<div id="outline-container-Buffer-Convenience" class="outline-3">
<h3 id="Buffer-Convenience"><span class="section-number-3">21.7.</span> 缓冲区操作的便捷功能与相关定制</h3>
<div class="outline-text-3" id="text-Buffer-Convenience">
<p>
本节介绍多款可提升缓冲区切换效率的模式与功能。
</p>
<ul class="org-ul">
<li><a href="#Uniquify">让缓冲区名称唯一化</a></li>
<li><a href="#Icomplete">迷你缓冲区快速选择（方式）</a></li>
<li><a href="#Buffer-Menus">定制缓冲区菜单</a></li>
</ul>
</div>
<div id="outline-container-Uniquify" class="outline-4">
<h4 id="Uniquify"><span class="section-number-4">21.7.1.</span> 让缓冲区名称唯一化</h4>
<div class="outline-text-4" id="text-Uniquify">
<p>
当多个缓冲区访问文件名相同的文件时，Emacs 必须为这些缓冲区分配互不重复的名称。默认命名方式会 <b>根据文件所在的目录名称添加后缀</b> ，以此区分。例如，若同时访问文件 <code>/foo/bar/mumble/name</code> 和 <code>/baz/quux/mumble/name</code> ，对应的缓冲区会分别命名为 'name&lt;bar/mumble&gt;' 和 'name&lt;quux/mumble&gt;' 。Emacs 会自动添加足够多的目录层级，确保缓冲区名称唯一。
</p>

<p>
你可以通过自定义选项 <code>uniquify-buffer-name-style</code> ，选择多种不同的 <b>缓冲区唯一名称构建规则</b> 。
</p>

<p>
'<code>forward</code>' <b>正向命名法</b> 会将文件目录的部分名称加在缓冲区名称 <b>开头</b> ：例如访问 <code>/u/rms/tmp/Makefile</code> 和 <code>/usr/projects/zaphod/Makefile</code> 时，缓冲区会被命名为 'tmp/Makefile' 和 'zaphod/Makefile' 。
</p>

<p>
与之相对， '<code>post-forward</code>' <b>后置正向命名法</b> 会将目录名加在缓冲区名称后方，格式为 '文件名|目录名' ，上述两个文件对应的缓冲区会被命名为 'Makefile|tmp' 和 'Makefile|zaphod' 。默认使用的 <code>post-forward-angle-brackets</code> <b>后置正向尖括号命名法</b> 与后置正向命名法逻辑一致，仅将唯一路径部分用尖括号包裹，也是前文示例中使用的命名方式。
</p>

<p>
<code>reverse</code> <b>反向命名法</b> 会将目录名加在缓冲区名称后方，格式为 '文件名\目录名' ，上述示例会被命名为 'Makefile\tmp' 和 'Makefile\zaphod' 。后置正向命名法与反向命名法的核心区别体现在 <b>单个目录名不足以区分文件</b> 的场景：此时反向命名法会将目录层级 <b>逆序拼接</b> ，例如文件 <code>/top/middle/file</code> 会被命名为 'file\middle\top' ；而后置正向命名法会将目录层级 <b>正序拼接</b> 在文件名后，格式为 'file|top/middle' 。
</p>

<p>
若将 <code>uniquify-buffer-name-style</code> 设为 <code>nil</code> ，Emacs 会采用最简命名规则，仅在缓冲区名称后依次追加 '&lt;2&gt;' 、 '&lt;3&gt;' 等数字后缀以保证唯一。
</p>

<p>
<code>uniquify-buffer-name-style</code> 的取值也可以是 <b>自定义函数</b> ，该函数需接收两个参数： <code>base</code> （字符串类型，为缓冲区基础名称）和 <code>extra-strings</code> （字符串列表类型，为用于区分的目录片段）。例如，后置正向尖括号命名法的默认实现可自定义为如下函数：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">my-post-forward-angle-brackets</span> (base extra-string)
  (concat base \"&lt;\" (mapconcat #'identity extra-string \"/\") \"&gt;\"))
</pre>
</div>

<p>
如果在输入缓冲区名称前，你会先查看所有缓冲区的命名再选择，那么采用哪种目录名拼接规则其实影响不大。但对于熟练的 Emacs 用户而言，若熟知所使用的命名规则，无需查看即可直接输入缓冲区名称，此时你会发现某一种规则会更便于记忆和快速使用。
</p>
</div>
</div>
<div id="outline-container-Icomplete" class="outline-4">
<h4 id="Icomplete"><span class="section-number-4">21.7.2.</span> 迷你缓冲区快速选择（方式）</h4>
<div class="outline-text-4" id="text-Icomplete">
<p>
补全预览模式（Icomplete mode）为在迷你缓冲区中从候选补全项里快速选择内容提供了便捷方式。启用该模式后，在迷你缓冲区中输入内容时，会 <b>实时显示</b> 所有与已输入字符串匹配的候选补全项列表。
</p>

<p>
在输入过程中的任意时刻，可按下 <code>C-j</code> 选中列表中的 <b>首个补全项</b> 。因此，选中特定补全项的核心思路，是将其调整为列表中的首个选项，具体有两种实现方式：
</p>
<ol class="org-ol">
<li>继续输入补全项的更多字符， <b>缩小候选范围</b> ，将目标项上方的无关补全项过滤掉；</li>
<li>使用快捷键 <code>C-.</code> 和 <code>C-,</code>  <b>轮换候选列表</b> ，直至目标缓冲区 / 补全项出现在列表首位。</li>
</ol>

<p>
按下 <code>M-TAB</code> 同样会选中列表中的首个补全项，与 <code>C-j</code> 的区别是 <b>不会退出迷你缓冲区</b> ，可对选中的补全项继续编辑。该快捷键在输入文件名时尤为常用，多次按下可逐级匹配目录层级，快速定位目标路径。
</p>

<p>
若要为迷你缓冲区启用补全预览模式，可执行命令 <code>M-x icomplete-mode</code> ，或将配置变量 <code>icomplete-mode</code> 自定义设为 <code>t</code> （参见<a href="#Easy-Customization">简易自定义界面</a>）。
</p>

<p>
此外，还可通过将配置变量 <code>icomplete-in-buffer</code> 设为 <code>t</code> ，为快捷键 <code>C-M-i</code> (<code>completion-at-point</code> ，即点处补全）额外启用补全预览模式。针对缓冲区内的补全操作，配置变量 <code>completion-auto-help</code> 用于控制补全预览模式的 <b>候选补全项显示时机</b> ，其默认值 <code>t</code> 表示首次按下 <code>C-M-i</code> 时，即显示候选补全项列表。
</p>

<p>
默认情况下，按下 <code>C-M-i</code> 时，补全预览模式的缓冲区内置候选补全项显示，与 <code>*Completions*</code> 补全缓冲区会 <b>同时出现</b> 。若启用了缓冲区内置的补全预览功能（ <code>icomplete-in-buffer</code> ），可隐藏自动弹出的 <code>*Completions*</code> 缓冲区，只需在 Emacs 初始化文件中添加以下配置（参见 <a href="#Init-File">Emacs 初始化文件</a>相关说明）：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(advice-add 'completion-at-point <span style="color: #483d8b;">:after</span> #'minibuffer-hide-completions)
</pre>
</div>

<p>
补全预览模式的替代方案是 Fido 补全模式（Fido mode），该模式与补全预览模式功能高度相似，同时保留了热门扩展 Ido 模式的部分核心功能（其名称正是由 “Fake Ido” 衍生而来）。除基础补全功能外， Fido 补全模式还有以下特性：
</p>
<ol class="org-ol">
<li>可使用 <code>C-s</code> 和 <code>C-r</code> 快捷键轮换候选补全项列表；</li>
<li>可通过 <code>C-k</code> 在候选列表中直接删除文件、关闭缓冲区；</li>
<li>默认采用 <b>flex柔性匹配</b> 作为补全样式（参见<a href="#Completion-Styles">补全候选项的选择规则</a>）。</li>
</ol>

<p>
若要修改该模式的默认补全样式，可在初始化文件中添加以下配置：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">my-icomplete-styles</span> ()
  (<span style="color: #a020f0;">setq-local</span> completion-styles '(initials flex)))
(add-hook 'icomplete-minibuffer-setup-hook 'my-icomplete-styles)
</pre>
</div>

<p>
启用 Fido 补全模式的方式为：执行命令 <code>M-x fido-mode</code> ，或将配置变量 <code>fido-mode</code> 自定义设为 <code>t</code> （参见<a href="#Easy-Customization">简易自定义界面</a>）。
</p>

<p>
补全预览模式与 Fido 补全模式，默认会在与提示语同一行显示候选补全项。若要在提示语下方 <b>垂直展示</b> 所有补全候选项，可执行命令 <code>M-x icomplete-vertical-mode</code> ，或将配置变量 <code>icomplete-vertical-mode</code> 自定义设为 <code>t</code> （参见<a href="#Easy-Customization">简易自定义界面</a>）。
</p>
</div>
</div>
<div id="outline-container-Buffer-Menus" class="outline-4">
<h4 id="Buffer-Menus"><span class="section-number-4">21.7.3.</span> 定制缓冲区菜单</h4>
<div class="outline-text-4" id="text-Buffer-Menus">
<dl class="org-dl">
<dt><code>M-x bs-show</code></dt><dd>生成缓冲区列表，功能与 <code>M-x list-buffers</code> 类似，且支持自定义配置。</dd>
<dt><code>M-x ibuffer</code></dt><dd>生成缓冲区列表，并可通过类 Dired 的操作方式对缓冲区进行管理。</dd>
</dl>

<p>
<code>M-x bs-show</code> 会弹出一个缓冲区列表，与 <code>C-x C-b</code> 默认显示的列表功能一致，但 <b>支持更灵活的自定义显示规则</b> 。例如，你可以指定要展示的缓冲区属性项、缓冲区名称列的最小和最大宽度、用于匹配 <b>永不显示</b> 的缓冲区名称正则表达式，以及 <b>始终显示</b> 的缓冲区名称正则表达式等。若你更偏好该缓冲区列表，可将此命令绑定到 <code>C-x C-b</code> 快捷键上。如需自定义该缓冲区列表，可使用 <code>bs</code> 自定义组（参见<a href="#Easy-Customization">简易自定义界面</a>），或直接调用 <code>bs-customize</code> 命令进行配置。
</p>

<p>
MSB 全局次要模式（MSB 为 "mouse select buffer" 鼠标选择缓冲区的英文缩写）提供了一套风格不同且支持自定义的鼠标缓冲区菜单，你可根据喜好启用。该模式会用自身的命令，替换原本绑定在 <code>C-Down-mouse-1</code> 和 <code>C-F10</code> 上的 <code>mouse-buffer-menu</code> 相关命令，同时也会修改菜单栏中的缓冲区菜单。你可在msb自定义组中对该菜单进行个性化配置。
</p>

<p>
IBuffer 是一款专门用于查看缓冲区列表的 <b>主模式</b> ，它支持以类 Dired 的方式（参见《<a href="#Dired">目录编辑器 Dired</a>》章节）对缓冲区进行操作，包括缓冲区过滤、标记、多种方式排序，以及对标记的缓冲区执行批量操作等。
</p>
</div>
</div>
</div>
</section>
<section id="outline-container-Windows" class="outline-2">
<h2 id="Windows"><span class="section-number-2">22.</span> 多窗口</h2>
<div class="outline-text-2" id="text-Windows">
<p>
Emacs 可将一个框架拆分为两个或多个窗口。多个窗口既可以显示不同缓冲区的内容，也可显示同一缓冲区的不同部分。多框架必然对应多窗口，因为每个框架都有其独立的窗口集，且每个窗口仅归属于一个框架。
</p>

<ul class="org-ul">
<li><a href="#Basic-Window">Emacs 窗口的概念</a></li>
<li><a href="#Split-Window">拆分窗口</a></li>
<li><a href="#Other-Window">使用其他窗口</a></li>
<li><a href="#Pop-Up-Window">在另一窗口中显示内容</a></li>
<li><a href="#Change-Window">删除与调整窗口大小</a></li>
<li><a href="#Displaying-Buffers">在窗口中显示缓冲区</a></li>
<li><a href="#Window-Convenience">窗口操作的便捷功能</a></li>
<li><a href="#Tab-Line">窗口标签栏</a></li>
<li><a href="#Window-Tool-Bar">窗口工具栏</a></li>
</ul>
</div>
<div id="outline-container-Basic-Window" class="outline-3">
<h3 id="Basic-Window"><span class="section-number-3">22.1.</span> Emacs 窗口的概念</h3>
<div class="outline-text-3" id="text-Basic-Window">
<p>
每个 Emacs 窗口在任一时刻仅显示一个 Emacs 缓冲区。单个缓冲区可同时显示在 <b>多个窗口</b> 中：若缓冲区内容发生修改，所有显示该缓冲区的窗口都会实时同步更新修改内容。但这些窗口可展示缓冲区的不同部分，因为 <b>每个窗口都有独立的光标位置</b> 。
</p>

<p>
任一时刻，仅有一个 Emacs 窗口为 <b>选中窗口</b> ，该窗口当前显示的缓冲区即为 <b>当前缓冲区</b> 。在图形化显示界面中，选中窗口的光标为 <b>实心闪烁光标</b> ，未选中窗口的光标为空心方框；在文本终端中，光标仅会显示在选中窗口内。相关细节参见《<a href="#Cursor-Display">光标显示</a>》章节。
</p>

<p>
光标移动类命令 <b>仅会改变选中窗口</b> 的光标位置，不会影响其他 Emacs 窗口的光标位置 —— 即便这些窗口显示的是同一个缓冲区。缓冲区切换类命令（如 <code>C-x b</code> ）的行为同理，完全不会对其他窗口产生影响。不过存在部分特殊命令（如 <code>C-x 4 b</code> ），可选中其他窗口并在其中切换缓冲区。此外，所有在窗口中展示信息的命令（例如 <code>C-h f</code> (<code>descibe-function</code>) 、 <code>C-x C-b</code> (<code>list-buffers</code>) ），通常都会在 <b>未选中窗口</b> 中展示对应缓冲区内容，且不会改变当前的选中窗口。
</p>

<p>
当多个窗口显示同一个缓冲区时，各窗口可拥有 <b>不同的选区</b> ，原因是各窗口的光标位置相互独立；但所有窗口共享同一个 <b>标记位置</b> ，因为每个缓冲区仅存在一个标记位。
</p>

<p>
每个窗口都配有独立的 <b>模式行</b> ，用于显示该窗口当前所展示缓冲区的名称、修改状态，以及该缓冲区的主模式和次要模式。选中窗口的模式行会以 <b>不同颜色</b> 显示，相关细节参见《<a href="#Mode-Line">模式行</a>》章节。
</p>
</div>
</div>
<div id="outline-container-Split-Window" class="outline-3">
<h3 id="Split-Window"><span class="section-number-3">22.2.</span> 拆分窗口</h3>
<div class="outline-text-3" id="text-Split-Window">
<dl class="org-dl">
<dt><code>C-x 2</code></dt><dd>将选中的窗口拆分为两个上下排列的窗口 (<code>split-window-below</code>) 。</dd>
<dt><code>C-x 3</code></dt><dd>将选中的窗口拆分为两个左右并排的窗口 (<code>split-window-right</code>) 。</dd>
<dt><code>C-mouse-2</code></dt><dd>在某一窗口的模式行上点击，拆分该窗口。</dd>
</dl>

<p>
<code>C-x 2</code> (<code>split-window-below</code>) 会将选中窗口拆分为两个上下排布的窗口，拆分后原窗口为上方的选中窗口，新拆分出的窗口位于下方。两个窗口会保留拆分前的光标位置，且显示缓冲区的同一部分内容（或尽可能接近的区域）；若有需要，窗口会自动滚动以保证光标处于可视区域。默认情况下，拆分后的两个窗口各占原窗口高度的一半。带正数字参数执行该命令，可指定上方窗口的行数；带负数字参数，则指定下方窗口的行数。
</p>

<p>
若将变量 <code>split-window-keep-point</code> 设为 <code>nil</code> ，执行 <code>C-x 2</code> 时，Emacs 会调整两个窗口显示的缓冲区内容范围，同时修改各窗口的光标位置，尽可能保持屏幕上的文本与拆分前一致；此外，若拆分前光标位于原窗口的下半区域，拆分后会选中下方的窗口，而非上方窗口。
</p>

<p>
<code>C-x 3</code> (<code>split-window-right</code>) 会将选中窗口拆分为两个左右并排的窗口，左侧为选中窗口，右侧窗口显示同一缓冲区的同一部分内容，且光标位置与原窗口一致。带正数字参数执行该命令，可指定左侧窗口的列数；带负数字参数，则指定右侧窗口的列数。
</p>

<p>
使用 <code>C-x 3</code> 拆分窗口后，每个窗口的宽度都会小于框架的完整宽度。若窗口过窄，且文本启用了折行显示，缓冲区内容会难以阅读（参见<a href="#Continuation-Lines">折行显示</a>章节）。因此，当窗口宽度小于 50 列时，Emacs 会自动切换为行截断模式。该自动截断行为不受变量 <code>truncate-lines</code> 控制（参见行截断章节），而是由变量 <code>truncate-partial-width-windows</code> 管理：若该变量值为正整数（默认值为 50），则表示非全宽窗口的最小宽度阈值，低于此值即触发自动行截断；若值为 <code>nil</code> ，则禁用自动行截断；若为其他非nil值，则所有非全宽窗口无论宽度多少，均会启用行截断。窗口的总宽度以 <code>window-total-width</code> 函数返回的列数为单位（参见《Emacs Lisp 参考手册》的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Window-Sizes.html#Window-Sizes">窗口大小</a>章节），包含边缘区域、折行与截断符号、边距和滚动条的宽度。
</p>

<p>
在文本终端中，左右并排的窗口之间会显示一个垂直分隔线，该分隔线使用 <code>vertical-border</code> 面属性绘制。
</p>

<p>
在某一窗口的模式行上点击 <code>C-mouse-2</code> ，会拆分该窗口，且在点击位置生成垂直分隔线。根据 Emacs 的编译版本，也可在滚动条上点击 <code>C-mouse-2</code> 2拆分窗口，此时会在点击位置生成水平分隔线（该功能在 Emacs 使用 GTK + 滚动条时无效）。
</p>

<p>
默认情况下，拆分窗口时，Emacs 会为拆分后的每个窗口分配 <b>框架默认字体大小整数倍</b> 的尺寸，这可能导致屏幕空间在各窗口间分配不均。若将变量 <code>window-resize-pixelwise</code> 设为非nil值，Emacs 会为每个窗口分配相同的像素数（若初始尺寸为奇数像素，可能会相差 1 个像素）。注意，若框架的像素尺寸并非字符尺寸的整数倍，即便该选项设为 <code>nil</code> ，至少有一个窗口也会按像素单位调整大小
</p>
</div>
</div>
<div id="outline-container-Other-Window" class="outline-3">
<h3 id="Other-Window"><span class="section-number-3">22.3.</span> 使用其他窗口</h3>
<div class="outline-text-3" id="text-Other-Window">
<dl class="org-dl">
<dt><code>C-x o</code></dt><dd>选中另一窗口 (<code>other-window</code>) 。</dd>
<dt><code>C-M-v</code></dt><dd>向上滚动下一个窗口的内容 (<code>scroll-other-window</code>) 。</dd>
<dt><code>C-M-S-v</code></dt><dd>向下滚动下一个窗口的内容 (<code>scroll-other-window-down</code>) 。</dd>
<dt><code>C-M-S-l</code></dt><dd>重定下个窗口的内容居中显示 (<code>recenter-other-window</code>) 。</dd>
<dt><code>mouse-1</code></dt><dd>在窗口的文本区域点击鼠标左键，会选中该窗口并将光标移动至点击位置；在模式行上点击则仅选中窗口，不会改变其中的光标位置。</dd>
</dl>

<p>
使用键盘可通过输入 <code>C-x o</code> (<code>other-window</code>) 来切换窗口，此处为字母 <code>o</code> （代表 “other”，即其他），并非数字 0。当窗口数量多于两个时，该命令会按 <b>循环顺序</b> 遍历所有窗口，一般遵循从上到下、从左到右的次序；在选中最右侧、最下方的窗口后，会重新回到左上角的第一个窗口。带 <b>数字参数</b> 执行该命令，可按循环顺序连续切换指定次数的窗口；带 <b>负参数</b> 则按相反的循环方向切换。当迷你缓冲区处于激活状态时，迷你缓冲区窗口会作为循环中的最后一个窗口；你可从迷你缓冲区窗口切换至其他任意窗口，后续可再次切回并继续输入迷你缓冲区所需的参数。详见《<a href="#Minibuffer-Edit">在迷你缓冲区中编辑</a>》章节。
</p>

<p>
<code>other-window</code> 命令默认仅在 <b>当前框架</b> 内切换至下一个窗口（除非另行配置）。若你在多框架环境下工作，希望将所有框架中的窗口都纳入循环切换范围，可将 <code>C-x o</code> 重新绑定至 <code>next-window-any-frame</code> 命令（关于如何重新绑定命令，详见《<a href="#Rebinding">交互式修改按键绑定</a>》章节）。
</p>

<p>
常规的滚动命令（详见《<a href="#Display">控制显示效果</a>》章节）仅对 <b>选中窗口</b> 生效，Emacs 也提供了专门用于滚动下一个窗口的命令。 <code>C-M-v</code> (<code>scroll-other-window</code>) 会滚动 <code>C-x o</code> 即将选中的那个窗口，该命令的其他行为与 <code>C-v</code> 一致：二者均会让缓冲区文本相对窗口向上滚动，且均可接收正、负数字参数。（在迷你缓冲区中， <code>C-M-v</code> 不会滚动标准循环顺序中的下一个窗口，而是滚动与迷你缓冲区关联的帮助窗口（若存在），详见《<a href="#Minibuffer-Edit">在迷你缓冲区中编辑</a>》章节。） <code>C-M-S-v</code> (<code>scroll-other-window-down</code>) 以类似方式实现下一个窗口的向下滚动；同理， <code>C-M-S-l</code> (<code>recenter-other-window</code>) 的作用，等同于在次窗口中执行 <code>C-l</code> (<code>recenter-top-bottom</code>) 命令。
</p>

<p>
若将变量 <code>mouse-autoselect-window</code> 设为非nil值，将鼠标移至其他窗口上方时，会自动选中该窗口，该功能默认处于关闭状态。
</p>
</div>
</div>
<div id="outline-container-Pop-Up-Window" class="outline-3">
<h3 id="Pop-Up-Window"><span class="section-number-3">22.4.</span> 在另一窗口中显示内容</h3>
<div class="outline-text-3" id="text-Pop-Up-Window">
<p>
<code>C-x 4</code> 是一组命令的前缀键，这类命令会在 <b>另一窗口</b> 中切换至指定缓冲区 —— 该窗口可以是已存在的其他窗口，也可以是通过拆分当前选中窗口新建的窗口。Emacs 如何选择或创建目标窗口的规则，详见《<a href="#Window-Choice">display-buffer 函数的工作机制</a>》章节。
</p>

<dl class="org-dl">
<dt><code>C-x 4 b bufname RET</code></dt><dd>在另一窗口中选中指定缓冲区 (<code>switch-to-buffer-other-window</code>) ，详见《<a href="#Select-Buffer">创建与选择缓冲区</a>》章节。</dd>
<dt><code>C-x 4 C-o bufname RET</code></dt><dd>在某一窗口中显示指定缓冲区， <b>不尝试选中</b> 该窗口 (<code>display-buffer</code>) 。窗口的选择规则细节，详见《<a href="#Displaying-Buffers">在窗口中显示缓冲区</a>》章节。</dd>
<dt><code>C-x 4 f finename RET</code></dt><dd>访问指定文件，并在另一窗口中选中其对应的缓冲区 (<code>find-file-other-window</code>) ，详见《<a href="#Visiting">访问文件</a>》章节。</dd>
<dt><code>C-x 4 d directory RET</code></dt><dd>在另一窗口中为指定目录选中 Dired 缓冲区 (<code>dired-other-window</code>) ，详见《<a href="#Dired">目录编辑器 Dired</a>》章节。</dd>
<dt><code>C-x 4 m</code></dt><dd>开始撰写邮件，功能与 <code>C-x m</code> 一致（详见《<a href="#Sending-Mail">发送邮件</a>》章节），区别是在另一窗口中执行 (<code>compose-mail-other-window</code>) 。</dd>
<dt><code>C-x 4 .</code></dt><dd>查找标识符的定义，功能与 <code>M-.</code> 一致（详见《<a href="#Xref">查找标识符引用</a>》章节），区别是在另一窗口中执行 (<code>xref-find-definitions-other-window</code>) 。</dd>
<dt><code>C-x 4 r filename RET</code></dt><dd>以只读方式访问指定文件，并在另一窗口中选中其对应的缓冲区 (<code>find-file-read-only-other-window</code>) ，详见《<a href="#Visiting">访问文件</a>》章节。</dd>
<dt><code>C-x 4 4</code></dt><dd>一个更通用的前缀命令，会影响紧随其后执行的命令所显示的缓冲区 (<code>other-window-prefix</code>) ，该前缀会要求后续命令将其要显示的缓冲区展示在另一窗口中。</dd>
<dt><code>C-x 4 1</code></dt><dd>该通用前缀命令则要求后续执行的命令，将其对应的缓冲区 <b>显示在当前同一窗口中</b> 。</dd>
</dl>
</div>
</div>
<div id="outline-container-Change-Window" class="outline-3">
<h3 id="Change-Window"><span class="section-number-3">22.5.</span> 删除与调整窗口大小</h3>
<div class="outline-text-3" id="text-Change-Window">
<dl class="org-dl">
<dt><code>C-x 0</code></dt><dd>删除选中的窗口 (<code>delete-window</code>) 。</dd>
<dt><code>C-x 1</code></dt><dd>删除选中框架中除选中窗口外的所有窗口 (<code>delete-other-windows</code>) 。</dd>
<dt><code>C-x 4 0</code></dt><dd>删除选中的窗口并 <code>kill关闭</code> 其在缓冲区显示 (<code>kill-buffer-and-window</code> ，该快捷键最后一个字符为数字 0) 。</dd>
<dt><code>C-x w 0 RET buffer RET</code></dt><dd>删除所有显示指定缓冲区的窗口。</dd>
<dt><code>C-x ^</code></dt><dd>增大选中窗口的高度 (<code>enlarge-window</code>) 。</dd>
<dt><code>C-x }</code></dt><dd>增大选中窗口的宽度 (<code>enlarge-window-horizontally</code>) 。</dd>
<dt><code>C-x {</code></dt><dd>缩小选中窗口的宽度 (<code>shrink-window-horizontally</code>) 。</dd>
<dt><code>C-x -</code></dt><dd>若缓冲区无需当前行数，缩小该窗口尺寸 (<code>shrink-window-if-larger-than-buffer</code>) 。</dd>
<dt><code>C-x +</code></dt><dd>平衡选中框架中所有窗口的尺寸 (<code>balance-windows</code>) 。</dd>
</dl>

<p>
删除选中窗口可按下 <code>C-x 0</code> （注意是数字 0）。窗口被删除后，其占用的空间会分配给相邻的窗口（迷你缓冲区窗口除外，即便其处于激活状态也不会分配）。删除窗口不会对其原本显示的缓冲区产生任何影响，该缓冲区会继续存在，你仍可通过 <code>C-x b</code> 切换至该缓冲区。配置项 <code>delete-window-choose-selected</code> 用于控制选择哪个窗口作为新的选中窗口（详见《Emacs Lisp 参考手册》的 “<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Deleting-Windows.html#Deleting-Windows">删除窗口</a>” 章节）。
</p>

<p>
<code>C-x 4 0</code> 是比 <code>C-x 0</code> 功能更强的命令，它会先 <code>kill关闭</code> 当前缓冲区，再删除选中的窗口。
</p>

<p>
<code>C-x 1</code> 会删除选中框架中除选中窗口外的所有窗口，选中窗口会自动扩展至占据整个框架的空间（该命令无法在迷你缓冲区窗口激活时使用，强行使用会触发错误）。
</p>

<p>
执行 <code>M-x delete-windows-on</code> 可删除所有显示指定缓冲区的窗口，该命令会提示输入目标缓冲区，默认值为当前缓冲区。若带上数字 0 前缀参数（ <code>C-u 0</code> ），该命令仅会删除当前显示器所属框架中显示该缓冲区的窗口。
</p>

<p>
<code>C-x ^</code> 命令会将选中窗口的高度增加一行，空间从垂直方向的相邻窗口中获取，且不会改变框架的整体高度。带上正数字参数时，窗口高度会按该数值增加；带上负数字参数时，窗口高度会按该数值减少。若当前窗口无垂直方向的相邻窗口（即窗口已占满框架全部高度），执行该命令会触发错误；若尝试将任意窗口的高度缩小至低于配置项 <code>window-min-height</code> 指定的最小行数（默认值为 <code>4</code> 行），同样会触发错误。
</p>

<p>
同理， <code>C-x }</code> 会增大选中窗口的宽度， <code>C-x {</code> 会缩小选中窗口的宽度。若尝试将任意窗口的宽度缩小至低于配置项 <code>window-min-width</code> 指定的最小列数（默认值为 10 列），执行这两个命令会触发错误。
</p>

<p>
在模式行（参见《<a href="#Mode-Line-Mouse">模式行的鼠标命令</a>》）或窗口分隔线（参见《<a href="#Window-Dividers">窗口分隔线</a>》）上点击鼠标，也可实现窗口高度调整、窗口拆分或删除操作。
</p>

<p>
<code>C-x -</code> 命令会检测选中窗口的高度，若其超出显示对应缓冲区全部文本所需的行数，会自动缩小窗口高度，并将多余的行空间分配给框架中的其他窗口。
</p>

<p>
你也可使用 <code>C-x +</code> 平衡选中框架中所有窗口的尺寸（迷你缓冲区窗口除外，参见《<a href="#Minibuffer">迷你缓冲区</a>》章节）。该命令会让所有水平相邻的窗口高度一致，所有垂直相邻的窗口宽度一致。
</p>
</div>
</div>
<div id="outline-container-Displaying-Buffers" class="outline-3">
<h3 id="Displaying-Buffers"><span class="section-number-3">22.6.</span> 在窗口中显示缓冲区</h3>
<div class="outline-text-3" id="text-Displaying-Buffers">
<p>
响应用户命令来显示或调出某个缓冲区，是 Emacs 的常规操作。命令实现该功能的方式有多种。
</p>

<p>
许多命令（如 <code>C-x C-f</code> (<code>find-file</code>) ）默认会 <b>占用当前选中的窗口</b> 来显示缓冲区，这是因为这类命令预期用户的注意力会转移至该缓冲区。
</p>

<p>
部分命令会采用更智能的显示方式，尽量不占用选中的窗口 —— 例如，拆分出一个新窗口并在其中显示目标缓冲区。这类命令包括各类帮助命令（参见<a href="#Help">帮助</a>相关章节），其内部均通过调用 <code>display-buffer</code> 函数实现该功能，具体细节参见《<a href="#Window-Choice">display-buffer 的工作机制</a>》小节。
</p>

<p>
另有一些命令的行为与 <code>display-buffer</code> 一致，且会额外选中用于显示的窗口，方便用户直接开始编辑该缓冲区。命令 <code>M-g M-n</code> (<code>next-error</code>) 就是典型示例（参见<a href="#Compilation-Mode">编译模式</a>章节），这类命令内部通过调用 <code>pop-to-buffer</code> 函数实现功能，具体可参见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Switching-Buffers.html#Switching-Buffers">在窗口中切换至缓冲区</a>》章节。
</p>

<p>
名称以 <code>-other-window</code> 结尾的命令，行为与 <code>display-buffer</code> 类似， <b>唯一区别</b> 是绝不会在选中的窗口中显示缓冲区。这类命令中有多个被绑定在 <code>C-x 4</code> 前缀键下（参见《<a href="#Pop-Up-Window">在另一窗口中显示内容</a>》章节）。
</p>

<p>
名称以 <code>-other-frame</code> 结尾的命令，同样以 <code>display-buffer</code> 的行为为基础，同时满足两个规则：① 绝不会在选中的窗口中显示缓冲区；② 优先创建新框架，或使用其他框架中的窗口来显示目标缓冲区。这类命令中有多个被绑定在 <code>C-x 5</code> 前缀键下。
</p>

<p>
有时，某个窗口会被 <b>dedicated专用于</b> 其当前显示的缓冲区（详见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Dedicated-Windows.html#Dedicated-Windows">专用窗口</a>》章节）。 <code>display-buffer</code> 函数在绝大多数情况下，都会避免复用专用窗口。窗口的专用属性会在模式行中以字符 '<code>d</code>' 标识（参见<a href="#Mode-Line">模式行</a>相关章节）；此外，窗口还可设置为 <b>强专用模式</b> ，该模式下窗口显示的缓冲区无法被任何方式替换，其模式行中会以字符 '<code>D</code>' 标识。
</p>

<p>
专用窗口通常用于显示特定用途的缓冲区，不过该属性在交互式操作中也能发挥作用。例如，使用 <code>M-g M-n</code> (<code>next-error</code>) 查看错误信息时，新显示的源代码缓冲区可能会覆盖你需要参考的某个缓冲区。若将该窗口设置为对应缓冲区的专用窗口，上述命令（通过 <code>display-buffer</code> 函数）会自动选择其他窗口来显示新内容。
</p>

<p>
你可使用命令 <code>C-x w d</code> (<code>toggle-window-dedicated</code>) ，来切换选中窗口是否专用于当前缓冲区。若带上前缀参数执行该命令，会将窗口设置为强专用模式。
</p>

<ul class="org-ul">
<li><a href="#Window-Choice">display-buffer 函数的工作原理</a></li>
<li><a href="#Temporary-Displays">显示不可编辑缓冲区</a></li>
</ul>
</div>
<div id="outline-container-Window-Choice" class="outline-4">
<h4 id="Window-Choice"><span class="section-number-4">22.6.1.</span> display-buffer 函数的工作原理</h4>
<div class="outline-text-4" id="text-Window-Choice">
<p>
<code>display-buffer</code> 命令（以及所有内部调用该函数的命令）会按照下述步骤选择用于显示缓冲区的窗口。若需修改该步骤执行顺序，详见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Choosing-Window.html#Choosing-Window">为显示缓冲区选择窗口</a>》章节。
</p>

<ul class="org-ul">
<li><p>
若无论其他条件如何，该缓冲区都需在选中窗口中显示，则复用当前选中的窗口。此步骤默认会被跳过，若要取消跳过，需将 <b>匹配该缓冲区名称的正则表达式</b> ，与 <code>display-buffer-same-window</code> 动作函数的引用一起，添加至配置项 <code>display-buffer-alist</code> 中（动作函数相关说明详见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Buffer-Display-Action-Functions.html#Buffer-Display-Action-Functions">缓冲区显示的动作函数</a>》章节，配置项相关说明详见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Choosing-Window.html#Choosing-Window">为显示缓冲区选择窗口</a>》章节）。例如，要让 <code>*scratch*</code> 缓冲区优先在选中窗口中显示，可写入以下配置：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setopt</span>
 display-buffer-alist
 '((<span style="color: #8b2252;">"\\*scratch\\*"</span> (display-buffer-same-window))))
</pre>
</div>

<p>
<code>display-buffer-alist</code> 的默认值为 <code>nil</code> 。
</p></li>

<li>若该缓冲区已在某个现有窗口中显示，则复用该窗口。默认情况下，仅会检索当前选中框架中的窗口；若在动作关联列表中配置了对应的 <code>reusable-frames</code> 项（详见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Buffer-Display-Action-Alists.html#Buffer-Display-Action-Alists">缓冲区显示的动作关联列表</a>》章节），其他框架中的窗口也可被复用。具体配置方式可参考下一步的示例。</li>

<li><p>
可选创建一个新框架，并在其中显示该缓冲区。此步骤默认被跳过。若要启用该功能，需按如下方式修改配置项 <code>display-buffer-base-action</code> 的值（详见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Choosing-Window.html#Choosing-Window">为显示缓冲区选择窗口</a>》章节）：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setopt</span>
 display-buffer-base-action
 '((display-buffer-reuse-window display-buffer-pop-up-frame)
   (reusable-frames . 0)))
</pre>
</div>

<p>
该自定义配置同时会让上一步的检索范围，扩展至所有可见或最小化的框架中的可复用窗口。
</p></li>

<li><p>
尝试在当前选中的框架中拆分某个窗口，创建新窗口并在其中显示该缓冲区。
</p>

<p>
拆分方式可为垂直或水平，具体由变量 <code>split-height-threshold</code> 和 <code>split-width-threshold</code> 控制，这两个变量均需设置为整数值。若 <code>split-height-threshold</code> 小于目标窗口的高度，新窗口会被拆分为下方窗口；若该条件不满足，但 <code>split-width-threshold</code> 小于目标窗口的宽度，新窗口会被拆分为右侧窗口；若两个条件均不满足，Emacs 会尝试将新窗口拆分为下方窗口 —— 但该行为仅在目标窗口未被拆分过的情况下生效（避免过度拆分）。
</p></li>

<li>在之前显示过该缓冲区的窗口中重新显示。默认情况下，仅会检索当前选中框架中的窗口；若配置了合适的 <code>reusable-frames</code> 动作关联列表项（见上文），也可使用其他框架中的对应窗口。</li>

<li>在当前选中框架的某个现有窗口中显示该缓冲区。</li>

<li>若因任何原因，上述所有方式均失败，则创建一个新框架，并在其中显示该缓冲区。</li>
</ul>
</div>
</div>
<div id="outline-container-Temporary-Displays" class="outline-4">
<h4 id="Temporary-Displays"><span class="section-number-4">22.6.2.</span> 显示不可编辑缓冲区</h4>
<div class="outline-text-4" id="text-Temporary-Displays">
<p>
部分缓冲区在窗口中展示仅作查阅之用，而非用于编辑。帮助类命令（参见<a href="#Help">帮助</a>章节）通常会借助名为 <code>*Help*</code> 的缓冲区实现此功能，迷你缓冲区补全（参见<a href="#Completion">补全</a>章节）会用到名为 <code>*Completions*</code> 的缓冲区，诸如此类的缓冲区通常仅临时显示一小段时间。
</p>

<p>
默认情况下，Emacs 会通过 <code>display-buffer</code> 函数为这类临时展示的缓冲区选择显示窗口，具体规则见上一小节。但 <code>*Completions*</code> 缓冲区是例外，它通常会固定显示在 <b>选中框架底部</b> 的窗口中，不受该框架当前已打开的窗口数量影响。
</p>

<p>
若你希望 Emacs 以其他方式显示临时缓冲区，可对配置项 <code>display-buffer-alist</code> 进行相应的自定义配置（详见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Choosing-Window.html#Choosing-Window">为显示缓冲区选择窗口</a>》章节）。例如，要让 <code>*Completions*</code> 缓冲区始终显示在选中窗口的下方，可在初始化文件中添加以下配置（参见《<a href="#Init-File">Emacs 初始化文件</a>》章节）：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setopt</span>
 display-buffer-alist
 '((<span style="color: #8b2252;">"\\*Completions\\*"</span> display-buffer-below-selected)))
</pre>
</div>

<p>
<code>*Completions*</code> 缓冲区还有一个特殊之处：Emacs 通常会自动调整其窗口大小，使其 <b>恰好能完整显示所有内容</b> 。若要让其他临时展示的缓冲区（如 <code>*Help*</code> 缓冲区）的窗口也实现自动调整大小，可启用次要模式 <code>temp-buffer-resize-mode</code> （参见次要模式章节，该模式详情见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Temporary-Displays.html#Temporary-Displays">临时展示</a>》章节）。
</p>

<p>
由 <code>temp-buffer-resize-mode</code> 模式调整大小的窗口，其最大尺寸可通过配置项 <code>temp-buffer-max-height</code> 和 <code>temp-buffer-max-width</code> 自定义控制（详见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Temporary-Displays.html#Temporary-Displays">临时展示</a>》章节），且窗口最大尺寸不会超过所属框架的大小。
</p>

<p>
用于展示警告信息的缓冲区（如字节编译警告，详见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Compilation-Functions.html#Compilation-Functions">字节编译函数</a>》章节），默认也会显示在选中框架底部的窗口中。你可通过变量 <code>warning-display-at-bottom</code> 控制该行为：若将其设为 <code>nil</code> ，Emacs 会改用 <code>display-buffer</code> 函数的默认逻辑为其选择窗口（参见 <a href="#Window-Choice">display-buffer 函数的工作机制</a>），你也可通过 <code>display-buffer-alist</code> 对该逻辑进行自定义。
</p>
</div>
</div>
</div>
<div id="outline-container-Window-Convenience" class="outline-3">
<h3 id="Window-Convenience"><span class="section-number-3">22.7.</span> 窗口操作的便捷功能</h3>
<div class="outline-text-3" id="text-Window-Convenience">
<p>
窗口配置恢复模式（Winner mode）是一款全局次要模式，它会记录 <b>窗口配置的变更记录</b> （即框架拆分为多个窗口的布局方式），让你可以撤销这些变更。可通过 <code>M-x winner-mode</code> 切换该模式的开启与关闭，也可通过自定义变量 <code>winner-mode</code> 完成设置。启用该模式后，按下 <code>C-c LEFT</code> (<code>winner-undo</code>) 可撤销上一次的窗口配置变更；若在撤销操作后改变想法，可使用 <code>C-c right</code> (<code>M-x winner-redo</code>) 重做已撤销的配置变更。若不想让窗口配置恢复模式绑定 <code>C-c left</code> 和 <code>C-c right</code> ，可将变量 <code>winner-dont-bind-my-keys</code> 设为非nil值。默认情况下，该模式为每个框架最多存储 200 条窗口配置记录，你可通过修改变量 <code>winner-ring-size</code> 调整这一上限。若存在部分缓冲区，你不希望该模式恢复其对应的窗口布局，可将这些缓冲区的名称添加至列表变量 <code>winner-boring-buffers</code> ，或匹配至正则表达式变量 <code>winner-boring-buffers-regexp</code> 中。
</p>

<p>
跟随模式（ <code>M-x follow-mode</code> ）可让显示同一缓冲区的多个窗口实现同步，使它们始终展示该缓冲区中 <b>相邻的内容区域</b> 。详见「<a href="#Follow-Mode">跟随模式</a>」章节。
</p>

<p>
Windmove 包定义了在一个框架中 <b>按方向切换相邻窗口</b> 的命令。 <code>M-x windmove-right</code> 会选中当前选中窗口右侧紧邻的窗口， <code>windmove-left</code> 、 <code>windmove-up</code> 、 <code>windmove-down</code> 命令则分别对应左、上、下方向的窗口切换。执行 <code>windmove-default-keybindings</code> 可将这些命令绑定至 <code>S-right</code> Shift+右方向键等组合键；该绑定操作会禁用这些按键原本的移位选择功能（详见「<a href="#Shift-Selection">移位选择</a>」章节）。与为按方向选窗的命令绑定快捷键的方式相同，你可使用 <code>windmove-display-default-keybindings</code> ，为「指定下一条命令的缓冲区在哪个方向的窗口中显示」的相关命令绑定快捷键。此外， <code>windmove-delete-default-keybindings</code> 可用于为按方向删除窗口的命令绑定快捷键， <code>windmove-swap-states-default-keybindings</code> 则能为「将选中窗口与指定方向窗口的内容互换」的命令绑定快捷键。
</p>

<p>
执行 <code>M-x compare-windows</code> 命令，可对比不同窗口中显示的文本内容。详见「<a href="#Comparing-Files">文件对比</a>」章节。
</p>

<p>
全部滚动模式（ <code>M-x scroll-all-mode</code> ）是一款全局次要模式，启用后，滚动类命令和光标移动类命令会作用于所有窗口。
</p>
</div>
</div>
<div id="outline-container-Tab-Line" class="outline-3">
<h3 id="Tab-Line"><span class="section-number-3">22.8.</span> 窗口标签栏</h3>
<div class="outline-text-3" id="text-Tab-Line">
<p>
<code>global-tab-line-mode</code> 命令用于切换是否在每个窗口的顶部显示 <code>tab line标签行</code> 。标签行会为该窗口中曾显示过的每个缓冲区显示专属按钮（"tabs"），点击对应按钮即可切换至相应缓冲区。点击 <code>+</code> 图标可在该窗口的本地缓冲区标签行中新增一个缓冲区，点击某一标签的 <code>x</code> 图标则可将该标签移除。在标签行上滚动鼠标滚轮，可实现标签的水平滚动。
</p>

<p>
触摸屏输入（参见<a href="#Other-Input">触摸屏输入与虚拟键盘</a>）也可用于与 "tab line" 交互。长按（参见<a href="#Touchscreens">在触摸屏上使用 Emacs</a>）某一标签，会弹出一个上下文菜单，其中包含对该被按标签的操作选项；轻点标签本身，即可切换至该标签对应的缓冲区；轻点标签行上的按钮，效果等同于使用 <code>mouse-1</code> 鼠标左键点击该按钮。
</p>

<p>
选中窗口本地的上一个标签，等同于按下 <code>C-x LEFT</code> (<code>previous-buffer</code>) ；选中下一个标签，等同于按下 <code>C-x RIGHT</code> (<code>next-buffer</code>) 。这两个命令均支持将数字前缀参数作为重复执行的次数。
</p>

<p>
你可自定义变量 <code>tab-line-tabs-function</code> ，来定义标签行的首选显示内容。默认情况下，该标签行会显示前文所述的、该窗口中曾访问过的所有缓冲区。但你也可将其设置为显示与当前缓冲区主模式相同的所有缓冲区列表，或按主模式对缓冲区进行分组显示 —— 此时点击首个标签中的模式名称，会弹出所有主模式的列表，你可从中选择另一组缓冲区进行查看。
</p>

<p>
请注意， <b>Tab Line标签行与 Tab Bar标签栏并非同一功能</b> （参见<a href="#Tab-Bars">标签栏</a>）。标签栏位于每个框架的顶部，其标签用于在包含多个缓冲区窗口的窗口配置之间进行切换；而标签行位于每个窗口的顶部，其标签仅用于在当前窗口内的不同缓冲区之间切换。
</p>

<p>
另请注意，标签行与窗口工具栏会占用 <b>同一显示区域</b> ，因此任一时刻只能显示二者中的一个；除非你在 Lisp 代码中自定义 <code>tab-line-format</code> 的值，向其中添加 <code>(:eval (tab-line-format))</code> 来调整布局（详见《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Mode-Line-Format.html#Mode-Line-Format">模式行格式</a>章节）。
</p>
</div>
</div>
<div id="outline-container-Window-Tool-Bar" class="outline-3">
<h3 id="Window-Tool-Bar"><span class="section-number-3">22.9.</span> 窗口工具栏</h3>
<div class="outline-text-3" id="text-Window-Tool-Bar">
<p>
<code>global-window-tool-bar-mode</code> 命令用于切换是否在每个窗口的顶部显示工具栏。启用该功能后，多个窗口可同时显示各自的专属工具栏。为节省显示空间，若某一窗口的工具栏无任何按钮可展示（即 <code>tool-bar-map</code> 变量值为 <code>nil</code> ），该窗口的工具栏会自动隐藏。
</p>

<p>
若你希望仅为部分缓冲区切换窗口工具栏的显示状态，可在这些缓冲区中执行 <code>window-tool-bar-mode</code> 命令。该用法在模式钩子中尤为实用。例如，若你希望仅为 <b>非文件类缓冲区</b> 且配有自定义工具栏的缓冲区显示窗口工具栏，可在初始化文件中添加以下代码（参见《<a href="#Init-File">Emacs 初始化文件</a>》章节）：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'special-mode-hook 'window-tool-bar-mode)
</pre>
</div>

<p>
Emacs 也支持在框架顶部显示一个 <b>全局统一的工具栏</b> （参见《<a href="#Tool-Bars">工具栏</a>》章节）。
</p>

<p>
请注意，窗口工具栏与标签行会占用 <b>同一显示区域</b> ，因此任一时刻只能显示二者中的一个；除非你自定义 <code>tab-line-format</code> 变量的值，向其中添加 <code>(:eval (window-tool-bar-string))</code>  来调整布局（详见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Mode-Line-Format.html#Mode-Line-Format">模式行格式</a>》章节）。
</p>
</div>
</div>
</section>
<section id="outline-container-Frames" class="outline-2">
<h2 id="Frames"><span class="section-number-2">23.</span> 框架与图形界面</h2>
<div class="outline-text-2" id="text-Frames">
<p>
当 Emacs 在图形化显示环境中启动时（如 X 窗口系统），它会占用一块系统级的图形化显示区域。在本手册中，该区域被称为 <b>frame框架</b> ，而 "window窗口" 一词专指框架中用于显示缓冲区的区域。一个框架初始时仅包含一个窗口，也可将其拆分为多个窗口（参见<a href="#Windows">多窗口</a>章节）。框架通常还包含菜单栏、工具栏和回显区。
</p>

<p>
你也可以创建额外的框架（参见<a href="#Creating-Frames">创建框架</a>章节）。在同一个 Emacs 会话中创建的所有框架，均可访问相同的底层缓冲区及其他数据。例如，若某个缓冲区同时在多个框架中显示，在其中一个框架中对该缓冲区做出的任何修改，都会立即同步显示在其他所有框架中。
</p>

<p>
按下 <code>C-x C-c</code> 会关闭当前显示器上的所有框架；若 Emacs 在其他所有显示器上均无打开的框架，该操作会直接结束 Emacs 会话（参见<a href="#Exiting">退出 Emacs</a>章节）。若仅需关闭当前选中的框架，按下 <code>C-x 5 0</code> 即可（此处为数字 0，非字母 o）。
</p>

<p>
本章介绍 Emacs 专用于图形化显示的功能（尤其是鼠标命令），以及管理多框架的相关功能。在文本终端中，这些功能有许多无法使用。不过，仍可在文本终端中创建多个框架，这类框架会逐个显示，并占满整个终端屏幕（参见<a href="#Text-Terminals">文本终端</a>章节）。部分文本终端也支持鼠标操作（在 GNU 和 Unix 系统上的使用方法参见<a href="#Text_002dOnly-Mouse">文本终端中的鼠标操作</a>章节；在 MS-DOS 系统上的使用方法参见 <a href="#MS_002dDOS-Mouse">MS-DOS 中的鼠标使用</a>章节）。所有文本终端均支持菜单功能。
</p>

<ul class="org-ul">
<li><a href="#Mouse-Commands">编辑相关的鼠标命令</a></li>
<li><a href="#Word-and-Line-Mouse">针对单词与行的鼠标命令</a></li>
<li><a href="#Mouse-References">用鼠标跟随引用链接</a></li>
<li><a href="#Menu-Mouse-Clicks">菜单相关的鼠标点击操作</a></li>
<li><a href="#Mode-Line-Mouse">模式行鼠标命令</a></li>
<li><a href="#Creating-Frames">创建框架</a></li>
<li><a href="#Frame-Commands">框架命令</a></li>
<li><a href="#Fonts">字体设置</a></li>
<li><a href="#Speedbar">速览栏框架</a></li>
<li><a href="#Multiple-Displays">多显示器支持</a></li>
<li><a href="#Frame-Parameters">框架参数</a></li>
<li><a href="#Scroll-Bars">滚动条</a></li>
<li><a href="#Window-Dividers">窗口分隔线</a></li>
<li><a href="#Drag-and-Drop">拖放功能</a></li>
<li><a href="#Menu-Bars">菜单栏</a></li>
<li><a href="#Tool-Bars">工具栏</a></li>
<li><a href="#Tab-Bars">标签栏</a></li>
<li><a href="#Dialog-Boxes">使用对话框</a></li>
<li><a href="#Tooltips">工具提示</a></li>
<li><a href="#Mouse-Avoidance">鼠标避让功能</a></li>
<li><a href="#Text-Terminals">文本终端</a></li>
<li><a href="#Text_002dOnly-Mouse">文本终端中的鼠标使用</a></li>
</ul>
</div>
<div id="outline-container-Mouse-Commands" class="outline-3">
<h3 id="Mouse-Commands"><span class="section-number-3">23.1.</span> 编辑相关的鼠标命令</h3>
<div class="outline-text-3" id="text-Mouse-Commands">
<dl class="org-dl">
<dt><code>mouse-1</code></dt><dd>将光标移动至点击位置 (<code>mouse-set-point</code>) 。</dd>
<dt><code>Drag-mouse-1</code></dt><dd>拖动鼠标左键。拖动选中的文本激活选区，并将该文本放入主选择区 (<code>mouse-set-region</code>) 。</dd>
<dt><code>mouse-2</code></dt><dd>鼠标中键。将光标移动至点击位置，并在该位置插入主选择区的内容 (<code>mouse-yank-primary</code>) 。</dd>
<dt><code>mouse-3</code></dt><dd>鼠标右键。若选区已激活，将选区较近的一端移动至点击位置；若选区未激活，将标记位设为当前光标位置，再将光标移至点击位置。将最终的选区内容存入删除环；再次点击则删除该选区内容 (<code>mouse-save-then-kill</code>) 。</dd>
<dt><code>C-M-mouse-1</code></dt><dd>为拖动选中的文本激活矩形选区，详见「<a href="#Rectangles">矩形操作</a>」章节。</dd>
</dl>

<p>
最基础的鼠标命令是 <code>mouse-set-point</code> ，在窗口的文本区域点击鼠标左键，即可调用该命令，它会将光标移动到点击的位置。若点击的窗口并非选中窗口，该窗口会成为新的选中窗口。你也可通过双击 <code>mouse-1</code> 鼠标左键激活选区，详见「<a href="#Word-and-Line-Mouse">单词与行的鼠标命令</a>」章节。
</p>

<p>
默认情况下，若点击的框架并非选中框架，除了选中对应窗口并设置光标位置外，该框架会被设为选中框架。在 X 窗口系统中，可将变量 <code>x-mouse-click-focus-ignore-position</code> 设为 <code>t</code> 来更改此行为，此时点击未选中的框架，首次点击仅会选中该框架，不执行其他操作；再次点击才会选中窗口并设置光标位置。
</p>

<p>
按住 <code>mouse-1</code> 鼠标左键并在一段文本上拖动，会为该文本激活选区 (<code>mouse-set-region</code>) ，标记位会落在按住鼠标键的起始位置，光标则在松开鼠标键的结束位置，详见「<a href="#Mark">标记与选区</a>」章节。同时，选区内的文本会成为 <b>主选择区</b> 的内容，详见「<a href="#Primary-Selection">与其他窗口程序的剪切粘贴</a>」章节。
</p>

<p>
若将变量 <code>mouse-drag-copy-region</code> 设为非nil值，拖动鼠标选中文本时，该文本也会被添加至 <b>删除环</b> ，该变量默认值为 <code>nil</code> 。
</p>

<p>
若该变量设为 <code>non-empty</code> ，则仅当选区非空时，才会将内容复制到删除环。例如，若鼠标拖动的区域不足半个字符，原本会向删除环中存入空字符串，而设为该值后，这种短距离拖动不会对删除环产生任何影响。
</p>

<p>
拖动鼠标时，若将鼠标移出窗口的顶部或底部，窗口会以稳定的速率自动滚动，直至将鼠标移回窗口内。通过这种方式，你可以选中无法完整显示在屏幕上的文本区域。每一步的滚动行数，取决于鼠标离窗口边缘的距离；变量 <code>mouse-scroll-min-lines</code> 规定了滚动的最小步长。
</p>

<p>
若启用选项 <code>mouse-drag-mode-line-buffer</code> ，且窗口系统支持文件拖动，那么在模式行的缓冲区名称区域拖动鼠标，可将该缓冲区对应的文件拖至其他程序或 Emacs 框架中。
</p>

<p>
点击 <code>mouse-2</code> 鼠标中键，会将光标移至点击位置，并在该位置插入主选择区的内容 (<code>mouse-yank-primary</code>) ，详见「<a href="#Primary-Selection">与其他窗口程序的剪切粘贴</a>」章节，该行为与其他 X 应用程序保持一致。你也可将 <code>mouse-2</code> 鼠标中键重新绑定至 <code>mouse-yank-at-click</code> 命令，该命令会在点击位置直接粘贴内容。
</p>

<p>
若将变量 <code>mouse-yank-at-point</code> 设为非nil值，点击 <code>mouse-2</code> 鼠标中键时不会移动光标，无论点击框架中的哪个位置、哪个窗口，都会在 <b>当前光标位置</b> 插入内容。该变量会同时作用于 <code>mouse-yank-primary</code> 和 <code>mouse-yank-at-click</code> 两个命令。
</p>

<p>
点击 <code>mouse-3</code> 鼠标右键会执行 <code>mouse-save-then-kill</code> 命令，该命令的行为会根据点击位置和选区的状态发生变化，具体规则如下：
</p>

<ul class="org-ul">
<li>若选区未激活，点击鼠标右键会激活选区，标记位为原光标位置，光标移至点击位置；</li>
<li>若选区已激活，点击鼠标右键会调整选区较近的一端，将其移至点击位置，调整后的选区内容会被复制到删除环；若原选区的内容已在删除环中，则会替换原有内容；</li>
<li>若最初通过双击或三击鼠标左键选中选区（即选区为整词或整行，详见「<a href="#Word-and-Line-Mouse">单词与行的鼠标命令</a>」章节），那么通过鼠标右键调整选区时，也会按整词或整行的规则进行；</li>
<li>在同一位置连续第二次点击鼠标右键，会删除已选中的选区内容。</li>
</ul>

<p>
因此，使用鼠标删除文本的最简方式为：在文本一端点击鼠标左键，在另一端连续双击鼠标右键。若只想将文本复制到删除环、而不从缓冲区中删除，只需单击一次鼠标右键—— 或直接用鼠标左键拖动选中文本即可，后续可通过粘贴操作将其复制到其他位置。
</p>

<p>
<code>mouse-save-then-kill</code> 命令同样遵循变量 <code>mouse-drag-copy-region</code> 的设置（前文已述）。若该变量值为非nil，则每当该命令创建或调整激活的选区时，选区内的文本都会被添加至删除环；若删除环的最新条目是通过相同方式添加的，则会替换该条目，而非新建条目。
</p>

<p>
无论通过上述哪种鼠标命令设置选区，除了常规的选区取消方式外，后续执行 <b>无移位修饰的光标移动命令</b> ，都会自动取消标记的激活状态，详见「<a href="#Shift-Selection">移位选择</a>」章节。
</p>

<p>
部分鼠标配有滚轮，可用于滚动页面。Emacs 在大多数图形化显示环境中，默认支持通过鼠标滚轮滚动窗口，可使用 <code>M-x mouse-wheel-mode</code> 切换该功能的开启与关闭。变量 <code>mouse-wheel-follow-mouse</code> 和 <code>mouse-wheel-scroll-amount</code> 决定了滚动的目标窗口和滚动步长；变量 <code>mouse-wheel-progressive-speed</code> 决定了滚动速度是否与滚轮的转动速度相关。
</p>

<p>
该模式还支持调整字体大小，默认将 <code>Ctrl</code>  键配合滚轮绑定为字体缩放的快捷键。启用该模式后，鼠标滚轮会触发 <code>wheel-up</code> （滚轮上滚）和 <code>wheel-down</code> （滚轮下滚）等特殊事件（部分旧系统会将其识别为 <code>mouse-4</code> 和 <code>mouse-5</code> ）。若鼠标配有水平滚轮，还会触发 <code>wheel-left</code> （滚轮左滚）和 <code>wheel-right</code> （滚轮右滚）事件。
</p>

<p>
Emacs 还支持 <code>Shift</code> 键配合滚轮实现水平滚动。在开始水平滚动前输入数字前缀参数（如 <code>M-5</code> ），可修改由用户选项 <code>mouse-wheel-scroll-amount-horizontal</code> 定义的水平滚动步长。
</p>

<p>
若你的鼠标滚轮支持侧倾，或触控板支持该操作，可将变量 <code>mouse-wheel-tilt-scrolxl</code> 设为非nil值，启用滚轮侧倾的水平滚动功能。默认情况下，侧倾鼠标滚轮会让窗口视图向侧倾方向水平滚动：例如，向右倾滚轮会让窗口向右滚动，窗口中显示的文本则会向左水平移动。若想反转水平滚动的方向，可将变量 <code>mouse-wheel-flip-direction</code> 设为非nil值。
</p>

<p>
在图像模式下，当鼠标指针置于图片上方时（详见「<a href="#Image-Mode">查看图像文件</a>」章节），Ctrl 键配合滚轮会缩放鼠标指针下方的图片，Shift 键配合滚轮则会让图片水平滚动。
</p>
</div>
</div>
<div id="outline-container-Word-and-Line-Mouse" class="outline-3">
<h3 id="Word-and-Line-Mouse"><span class="section-number-3">23.2.</span> 针对单词与行的鼠标命令</h3>
<div class="outline-text-3" id="text-Word-and-Line-Mouse">
<p>
<code>mouse-1</code> 鼠标左键的这些操作变体可一次选中整词或整行文本。Emacs 会为选中的文本激活选区，同时将文本复制至删除环。
</p>

<dl class="org-dl">
<dt><code>Double-mouse-1</code></dt><dd><p>
双击鼠标左键。选中点击位置所在的整词或字符周边的文本。
</p>

<p>
若在符号语法的字符（如 C 模式中的下划线）上双击，会选中该字符所在的整个符号；若在左 / 右括号语法的字符上双击，会选中该字符所起始或终止的括号匹配内容；若在字符串分隔符语法的字符（如 C 模式中的单引号、双引号）上双击，会选中整个字符串常量（Emacs 会通过启发式规则判断该字符为字符串的起始还是终止符）。
</p>

<p>
若在括号匹配内容的起始处或字符串分隔符的起始符上双击，光标会移至选区末尾，必要时会向前滚动缓冲区内容以显示光标的新位置；若在括号匹配内容的终止处或字符串分隔符的终止符上双击，默认光标会停留在选区末尾，若选区起始位置超出窗口上边界则会无法显示；将用户选项 <code>mouse-select-region-move-to-beginning</code> 设为非nil值，可改为将光标移至选区起始位置，必要时向后滚动显示内容。
</p></dd>

<dt><code>Double-Drag-mouse-1</code></dt><dd>双击并拖动鼠标左键。以整词为单位，选中拖动范围内的所有文本。</dd>
<dt><code>Triple-mouse-1</code></dt><dd>三击鼠标左键。选中点击位置所在的整行文本。</dd>
<dt><code>Triple-Drag-mouse-1</code></dt><dd>三击并拖动鼠标左键。以整行为单位，选中拖动范围内的所有文本。</dd>
</dl>
</div>
</div>
<div id="outline-container-Mouse-References" class="outline-3">
<h3 id="Mouse-References"><span class="section-number-3">23.3.</span> 用鼠标跟随引用链接</h3>
<div class="outline-text-3" id="text-Mouse-References">
<p>
部分 Emacs 缓冲区中会包含 <code>buttons按钮</code> 或 <code>hyperlins超链接</code> ：这类文本片段在被激活（如点击）时会执行特定操作（例如跳转到对应引用位置）。通常，按钮文本会有视觉高亮效果：或以下划线标注，或在文本外围绘制边框。将鼠标移至按钮上方时，鼠标光标的形状会发生变化，且按钮会亮起。若将变量 <code>mouse-highlight</code> 设为 <code>nil</code> ，Emacs 会关闭该高亮功能。
</p>

<p>
激活按钮的方式有两种：将光标移至按钮处并按下回车键（ <code>RET</code> ），或在按钮上点击鼠标左键（ <code>mouse-1</code> ）/ 鼠标中键（ <code>mouse-2</code> ）。例如，在 Dired 缓冲区中，每个文件名都是一个按钮，激活该按钮会让 Emacs 打开对应文件（参见《<a href="#Dired">Dired：目录编辑器</a>》章节）；在 <code>*Compilation*</code> 编译缓冲区中，每条错误提示信息都是一个按钮，激活后会跳转到该错误对应的源代码位置（参见《<a href="#Compilation">在 Emacs 中运行编译操作</a>》章节）。
</p>

<p>
尽管在按钮上单击鼠标左键通常会激活按钮，但如果按住鼠标左键一段时间后再松开（具体为超过 450 毫秒），Emacs 只会将光标移至点击位置，而不会激活按钮。通过这种方式，可在不激活按钮的前提下，用鼠标将光标移至按钮上方。在按钮上或向按钮区域拖动鼠标时，会执行常规的选区设置操作，不会激活按钮。
</p>

<p>
可通过自定义变量 <code>mouse-1-click-follows-link</code> ，修改鼠标左键对按钮的作用方式：
</p>
<ul class="org-ul">
<li>若该值为正整数，该数值即为取消按钮激活所需按住鼠标左键的时长（单位：毫秒），默认值为前文所述的 450；</li>
<li>若该值设为 <code>nil</code> ，鼠标左键仅会将光标移至点击位置，不会激活按钮；</li>
<li>若该值设为 <code>double</code> ，双击鼠标左键会激活按钮，单击仅会移动光标。</li>
</ul>

<p>
默认情况下，即便按钮处于未选中的窗口中，在其上点击 <code>mouse-1</code> 鼠标左键仍会激活该按钮。若将变量 <code>mouse-1-click-in-non-selected-windows</code> 设为 <code>nil</code> ，在未选中窗口的按钮上点击 <code>mouse-1</code> 鼠标左键，只会将光标移至点击位置并选中该窗口，而不会激活按钮
</p>
</div>
</div>
<div id="outline-container-Menu-Mouse-Clicks" class="outline-3">
<h3 id="Menu-Mouse-Clicks"><span class="section-number-3">23.4.</span> 菜单相关的鼠标点击操作</h3>
<div class="outline-text-3" id="text-Menu-Mouse-Clicks">
<p>
结合 <code>Ctrl</code> 和 <code>Shift</code> 修饰键的多款鼠标点击操作可调出对应菜单。
</p>

<dl class="org-dl">
<dt><code>C-mouse-1</code></dt><dd><p>
该菜单用于选择缓冲区。
</p>

<p>
MSB（即 “mouse select buffer鼠标选择缓冲区”）全局次要模式可让此菜单的功能更智能、且支持更多自定义设置，详见《<a href="#Buffer-Menus">自定义缓冲区菜单</a>》章节。
</p></dd>
<dt><code>C-mouse-2</code></dt><dd>该菜单包含用于查看和设置外观属性及其他文本属性的菜单项，其中文本属性设置功能主要在编辑富文本时使用（详见《<a href="#Enriched-Text">富文本</a>》章节）。</dd>
<dt><code>C-mouse-3</code></dt><dd>该菜单为模式专属菜单：
<ul class="org-ul">
<li>若开启菜单栏模式，对于大多数主模式，此菜单会整合该模式下菜单栏中的所有专属菜单项；部分主模式可为该操作自定义不同的菜单内容。</li>
<li>若关闭菜单栏模式，此菜单会包含菜单栏中的 <b>所有菜单项</b> （并非仅模式专属项），无需显示菜单栏即可调用全部菜单功能。</li>
</ul></dd>

<dt><code>S-mouse-1</code></dt><dd>该菜单用于修改当前窗口缓冲区的默认面属性，详见《<a href="#Text-Scale">文本缩放</a>》章节。</dd>
</dl>

<p>
多数图形界面应用会将鼠标右键（ <code>mouse-3</code> ）设为调出上下文菜单的快捷键，此类菜单会根据鼠标点击的位置和上下文，提供相关的设置项与操作选项。Emacs 中鼠标右键的默认功能为绑定 <code>mouse-save-then-kill</code> 命令（详见《<a href="#Mouse-Commands">编辑相关的鼠标命令</a>》章节），若你更习惯将其用作上下文菜单，可启用 <code>context-menu-mode</code> （上下文菜单模式）：启用后，点击 <code>mouse-3</code> 鼠标右键即可调出上下文菜单，菜单的具体内容会根据当前主模式、以及鼠标点击位置附近的缓冲区内容动态变化。
</p>

<p>
你可通过变量 <code>context-menu-functions</code> 自定义上下文菜单的内容（详见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Major-Mode-Conventions.html#Major-Mode-Conventions">主模式约定</a>》章节），也可通过按下 <code>S-F10</code> 快捷键调出上下文菜单。
</p>
</div>
</div>
<div id="outline-container-Mode-Line-Mouse" class="outline-3">
<h3 id="Mode-Line-Mouse"><span class="section-number-3">23.5.</span> 模式行鼠标命令</h3>
<div class="outline-text-3" id="text-Mode-Line-Mouse">
<p>
可通过点击窗口的模式行，实现窗口的选择与各类操作。
</p>

<p>
模式行的部分区域（如缓冲区名称、主模式与次要模式名称处）配有专属的鼠标绑定命令。将鼠标悬停在这些区域时，区域会高亮显示，同时相关绑定命令的说明信息也会弹出（参见工具提示相关内容）。本节介绍的命令不适用于这些特殊区域。
</p>

<dl class="org-dl">
<dt><code>mouse-1</code></dt><dd>在模式行上点击 <code>mouse-1</code> 鼠标左键，会选中该模式行所属的窗口。在模式行上按住 <code>mouse-1</code> 鼠标左键并拖动，可移动模式行的位置，进而调整其上下方窗口的高度。通过这种方式用鼠标调整窗口高度时，绝不会删除任何窗口，仅会限制窗口高度，使其不小于最小高度值。</dd>
<dt><code>mouse-2</code></dt><dd>在模式行上点击 <code>mouse-2</code> 鼠标中键，会将该模式行所属的窗口最大化，占满其所在的整个框架。</dd>
<dt><code>mouse-3</code></dt><dd>在模式行上点击 <code>mouse-3</code> 鼠标右键，会关闭该模式行所属的窗口。若该框架中仅有一个窗口，此操作将无任何效果。</dd>
<dt><code>C-mouse-2</code></dt><dd>在模式行上按住 Ctrl 并点击鼠标中键，会拆分该模式行所属的窗口，生成两个左右并排的窗口，窗口的分隔线会落在鼠标点击的位置（参见<a href="#Split-Window">窗口拆分</a>相关内容）。</dd>
</dl>

<p>
此外，在两个左右并排窗口的模式行分隔处，按住 <code>mouse-1</code> 鼠标左键并拖动，可左右移动窗口的垂直分隔线，调整两侧窗口的宽度。
</p>

<p>
请注意，窗口的调整操作会受 <code>window-resize-pixelwise</code> 变量的取值影响，相关说明参见<a href="#Split-Window">窗口拆分</a>章节。
</p>
</div>
</div>
<div id="outline-container-Creating-Frames" class="outline-3">
<h3 id="Creating-Frames"><span class="section-number-3">23.6.</span> 创建框架</h3>
<div class="outline-text-3" id="text-Creating-Frames">
<p>
前缀键 <code>C-x 5</code> 与 <code>C-x 4</code> 的功能逻辑相似： <code>C-x 4</code> 系列命令会在选中框架的新窗口中弹出指定缓冲区（参见《<a href="#Pop-Up-Window">在另一窗口中显示内容</a>》章节），而 <code>C-x 5</code> 系列命令则会在新的框架中完成该操作。若目标缓冲区已显示在某个可见或最小化的框架中（“最小化” 亦作图标化，参见《Emacs Lisp 参考手册》中《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Visibility-of-Frames.html#Visibility-of-Frames">框架的可见性</a>》章节），该框架会被前置并还原为正常显示状态（取消最小化）；若未找到对应框架，则会在当前显示终端中新建一个框架。
</p>

<p>
<code>C-x 5</code> 下的各类命令，核心区别在于 <b>查找或创建待选中缓冲区的方式</b> ，具体命令如下：
</p>
<dl class="org-dl">
<dt><code>C-x 5 2</code></dt><dd>使用默认框架参数创建一个新框架 (<code>make-frame-command</code>) 。</dd>
<dt><code>C-x 5 c</code></dt><dd>沿用当前框架的窗口配置与框架参数，克隆一个新框架 (<code>clone-frame</code>) 。</dd>
<dt><code>C-x 5 b bufname RET</code></dt><dd>在另一个框架中选中指定名称的缓冲区，对应命令 <code>switch-to-buffer-other-frame</code> 。</dd>
<dt><code>C-x 5 f filename RET</code></dt><dd>打开指定文件，并在另一个框架中选中该文件对应的缓冲区，对应命令 <code>find-file-other-frame</code> （参见《<a href="#Visiting">打开文件</a>》章节）。</dd>
<dt><code>C-x 5 d directory RET</code></dt><dd>在另一个框架中为指定目录打开 Dired 缓冲区，对应命令 <code>dired-other-frame</code> （参见《<a href="#Dired">Dired：目录编辑器</a>》章节）。</dd>
<dt><code>C-x 5 m</code></dt><dd>在另一个框架中开始撰写邮件，对应命令 <code>compose-mail-other-frame</code> ，是 <code>C-x m</code> 命令的跨框架版本（参见《<a href="#Sending-Mail">发送邮件</a>》章节）。</dd>
<dt><code>C-x 5 .</code></dt><dd>在另一个框架中查找标识符的定义，对应命令 <code>xref-find-definitions-other-frame</code> ，是 <code>M-.</code> 命令的多框架版本（参见《<a href="#Xref">查找标识符引用</a>》章节）。</dd>
<dt><code>C-x 5 r filename RET</code></dt><dd>以只读方式打开指定文件，并在另一个框架中选中该缓冲区，对应命令find-file-read-only-other-frame（参见《打开文件》章节）。</dd>
<dt><code>C-x 5 5</code></dt><dd>一个更通用的前缀命令 (<code>other-frame-prefix</code>) ，作用于紧随其后执行的命令：该前缀会让后续命令所显示的缓冲区，在另一个框架中展示。</dd>
</dl>

<p>
你可以通过 <b>指定框架参数</b> ，控制新建框架的外观与行为，相关说明参见《<a href="#Frame-Parameters">框架参数</a>》章节。
</p>
</div>
</div>
<div id="outline-container-Frame-Commands" class="outline-3">
<h3 id="Frame-Commands"><span class="section-number-3">23.7.</span> 框架命令</h3>
<div class="outline-text-3" id="text-Frame-Commands">
<p>
下述命令用于框架的删除与各类操作：
</p>

<dl class="org-dl">
<dt><code>C-x 5 0</code></dt><dd>删除当前选中的框架 (<code>delete-frame</code>) 。若当前仅存在一个框架，执行此命令会触发错误提示。</dd>
<dt><code>C-x 5 u</code></dt><dd>当启用 <code>undelete-frame-mode</code> （框架恢复模式）时，可恢复最近删除的 16 个框架中的一个。无前缀参数时，恢复 <b>最近刚删除</b> 的框架；若传入 1 到 16 之间的数字前缀参数（数字 1 对应最近删除的框架），则恢复对应序号的已删除框架。</dd>
<dt><code>C-z</code></dt><dd>将当前选中的 Emacs 框架最小化（图标化） (<code>suspend-frame</code>) ，详见《<a href="#Exiting">退出 Emacs</a>》章节。</dd>
<dt><code>C-x 5 o</code></dt><dd>选中并前置另一个框架。重复执行此命令，会在当前终端的所有框架间循环切换。</dd>
<dt><code>C-x 5 1</code></dt><dd>删除当前终端上除选中框架外的所有其他框架。</dd>
<dt><code>M-F10</code></dt><dd>切换当前框架的最大化状态，框架最大化时会占满整个屏幕。</dd>
<dt><code>F11</code></dt><dd>切换当前框架的全屏模式。（全屏与最大化的区别通常在于：全屏模式会隐藏窗口管理器的装饰栏，为 Emacs 本身让出更多的屏幕空间。）</dd>
</dl>

<p>
请注意，在部分窗口管理器环境下，若要让框架实现真正的最大化或全屏，需将变量 <code>frame-resize-pixelwise</code> 自定义设为非nil值。当该变量为非nil时，框架整体支持 <b>像素级精度</b> 调整大小，而非仅以行和列为单位的整数倍调整。
</p>

<p>
<code>C-x 5 0</code> (<code>delete-frame</code>) 命令用于删除选中的框架，但为防止用户失去与 Emacs 会话的交互能力，该命令会拒绝删除 Emacs 会话中的最后一个框架。需注意，当 Emacs 以守护进程模式运行时（详见《<a href="#Emacs-Server">将 Emacs 用作服务器</a>》章节），即便所有常规的交互式框架都被删除，仍会保留一个虚拟框架；此种情况下， <code>C-x 5 0</code> 可删除最后一个交互式框架，用户可通过 <code>emacsclient</code> 重新连接至该 Emacs 会话。
</p>

<p>
<code>C-x 5 1</code> (<code>delete-other-frames</code>) 命令仅删除 <b>当前终端</b> 上的其他所有框架（此处的终端指图形化显示器或文本终端，详见《<a href="#Text-Terminals">文本终端</a>》章节）；若 Emacs 会话在其他图形化显示器或文本终端上还打开了框架，这些框架不会被删除。
</p>

<p>
<code>C-x 5 o</code> (<code>other-frame</code>) 命令用于选中当前终端的下一个框架。若在 X 窗口系统中使用 Emacs，且所用的窗口管理器会自动选中（或赋予焦点）鼠标光标悬停的任意框架，需将变量 <code>focus-follows-mouse</code> 设为 <code>t</code> ，此命令才能正常工作。设置后，执行 <code>C-x 5 o</code> 还会将鼠标光标 <b>移动至</b> 选中的框架处。
</p>
</div>
</div>
<div id="outline-container-Fonts" class="outline-3">
<h3 id="Fonts"><span class="section-number-3">23.8.</span> 字体设置</h3>
<div class="outline-text-3" id="text-Fonts">
<p>
默认情况下，Emacs 在图形化显示界面中使用 <b>10 号等宽字体</b> 显示文本，且可通过交互方式调整字体大小（参见《<a href="#Text-Scale">文本缩放</a>》章节）。
</p>

<p>
指定自定义字体的方式有以下几种：
</p>
<ol class="org-ol">
<li>在 'Options选项' 菜单中点击 'Set Default Font设置默认字体' ，所选字体会成为所有现有图形化框架的默认字体；若要将该设置保存至后续会话，可在 'Options选项' 菜单中点击 'Save Options保存选项' 。</li>
<li><p>
在初始化文件中添加一行代码，修改 <code>default-frame-alist</code> 变量以指定字体参数（参见《<a href="#Frame-Parameters">框架参数</a>》章节），示例如下：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-to-list 'default-frame-alist
             '(font . <span style="color: #8b2252;">"DejaVu Sans Mono-10"</span>))
</pre>
</div>

<p>
重启 Emacs 后，所有新建的图形化框架都会使用该字体作为默认字体。
</p></li>

<li><p>
在 X 资源文件中添加 'emacs.font' 的 X 资源配置，示例如下：
</p>

<div class="org-src-container">
<pre class="src src-shell">emacs.font: DejaVu Sans Mono-12
</pre>
</div>

<p>
需重启 X 窗口系统或执行 <code>xrdb</code> 命令，才能让 X 资源文件的配置生效（参见《<a href="#Resources">X 资源</a>》章节）。注意：在 X 资源文件中指定字体名时无需加引号。
</p></li>

<li>若在 GNOME 桌面或 Haiku 系统中运行 Emacs，可将变量 <code>font-use-system-font</code> 设为 <code>t</code> （默认值为 <code>nil</code> ），让 Emacs 跟随系统默认字体的变更，自动调整框架的默认字体。该功能生效的前提是，Emacs 编译时启用了 Gsettings（或旧版 Gconf）支持。（具体使用的 Gsettings 配置项为 'org.gnome.desktop.interface monospace-font-name' 和 'org.gnome.desktop.interface font-name' 。）</li>
<li>使用命令行选项 '<code>-fn</code>' （或 '<code>--font</code>' ）指定字体（参见《<a href="#Font-X">字体指定选项</a>》章节）。</li>
</ol>

<p>
若要查看当前使用的字体，可使用 <code>C-u C-x =</code> 命令，该命令会显示光标处字符的详细信息，同时标注其渲染所用的字体。
</p>

<p>
<b>字体名的四种表示方式</b>
</p>

<p>
<b>方式一：Fontconfig 模式</b>
</p>

<p>
Fontconfig 模式的字体名格式如下：
</p>

<div class="org-src-container">
<pre class="src src-shell">fontname[-fontsize][:<span style="color: #a0522d;">name1</span>=values1][:<span style="color: #a0522d;">name2</span>=values2]...
</pre>
</div>

<p>
格式中所有方括号内的元素均可省略。其中：
</p>
<ul class="org-ul">
<li><code>fontname</code> 为字体家族名，如Monospace（等宽体）、DejaVu Sans Mono；</li>
<li><code>fontsize</code> 为字体的号数（1 印刷点约等于 1/72 英寸）；</li>
<li>'name=values' 项用于指定字体的倾斜、字重等属性，values可为单个值，也可为逗号分隔的多个值；</li>
<li>部分属性值仅对应一种属性名，此种情况下可省略 'name=' 部分。</li>
</ul>

<p>
<b>常用字体属性：</b>
</p>
<dl class="org-dl">
<dt>'slant'</dt><dd>（倾斜）。italic（斜体）、oblique（伪斜体）、roman（正体）三者之一；</dd>
<dt>'weight'</dt><dd>（字重）。light（细体）、medium（常规）、demibold（半粗）、bold（粗体）、black（特粗）五者之一；</dd>
<dt>'style'</dt><dd>（样式）。部分字体会定义融合了倾斜和字重的特殊样式，例如Dejavu Sans的book样式，该样式会覆盖倾斜和字重的单独设置；</dd>
<dt>'width'</dt><dd>（字宽）。condensed（紧缩）、normal（常规）、expanded（加宽）三者之一；</dd>
<dt>'spacing'</dt><dd>（字符间距）。monospace（等宽）、proportional（比例间距）、dual-width（双宽）、charcell（字符格）四者之一。</dd>
</dl>

<p>
Fontconfig 模式示例：
</p>

<div class="org-src-container">
<pre class="src src-shell">Monospace
Monospace-12
Monospace-12:bold
DejaVu Sans Mono:bold:italic
Monospace-12:<span style="color: #a0522d;">weight</span>=bold:<span style="color: #a0522d;">slant</span>=italic
</pre>
</div>

<p>
关于 Fontconfig 模式的详细说明，可参考 Fontconfig 手册（随 Fontconfig 分发，在线地址：<a href="https://fontconfig.org/fontconfig-user.html">https://fontconfig.org/fontconfig-user.html</a>）。
</p>

<p>
注意：在 Windows 系统中，所有字体仅支持 <code>fontname[-fontsize]</code> 的简化格式，完整的 Fontconfig 模式并非对所有字体生效。
</p>

<p>
<b>方式二：GTK 字体模式</b>
</p>

<p>
GTK 字体模式的语法如下：
</p>

<div class="org-src-container">
<pre class="src src-shell">fontname [properties] [fontsize]
</pre>
</div>

<p>
其中fontname为字体家族名，properties为空格分隔的属性值列表，fontsize为字体号数。
</p>

<p>
<b>GTK 支持的字体属性：</b>
</p>
<ul class="org-ul">
<li>倾斜属性：Italic（斜体）、Oblique（伪斜体），省略时默认为正体；</li>
<li>字重属性：Bold（粗体）、Book（书体）、Light（细体）、Medium（常规）、Semi-bold（半粗）、Ultra-light（超轻），省略时默认为Medium；</li>
<li>字宽属性：Semi-Condensed（半紧缩）、Condensed（紧缩），省略时使用默认字宽。</li>
</ul>

<p>
<b>GTK 字体模式示例：</b>
</p>

<div class="org-src-container">
<pre class="src src-shell">Monospace 12
Monospace Bold Italic 12
</pre>
</div>

<p>
注意：在 Windows 系统中，仅支持fontname的最简格式。
</p>

<p>
<b>方式三：XLFD（X 逻辑字体描述）</b>
</p>

<p>
这是 X 窗口系统下指定字体的传统方式，Windows 系统也支持该格式。每个 XLFD 由 14 个以连字符分隔的单词或数字组成，示例如下：
</p>

<div class="org-src-container">
<pre class="src src-shell">-misc-fixed-medium-r-semicondensed--13-*-*-*-c-60-iso8859-1
</pre>
</div>

<p>
XLFD 中的通配符 '<code>*</code>' 可匹配任意字符序列（包括空序列）， '<code>?</code>' 可匹配单个字符；但匹配规则由具体实现决定，当通配符匹配长名称中的连字符时，结果可能不准确。为保证匹配可靠，需保留全部 14 个连字符，且仅在单个字段内使用通配符。XLFD 的大小写不敏感，完整语法如下：
</p>

<div class="org-src-container">
<pre class="src src-shell">-maker-family-weight-slant-widthtype-style&#8230;
&#8230;-pixels-height-horiz-vert-spacing-width-registry-encoding
</pre>
</div>

<p>
各字段含义：
</p>
<dl class="org-dl">
<dt>maker</dt><dd>字体制造商名称；</dd>
<dt>family</dt><dd>字体家族名（如courier）；</dd>
<dt>weight</dt><dd>字重，通常为bold（粗）、medium（常规）、light（细），部分字体支持其他值；</dd>
<dt>slant</dt><dd>倾斜样式，通常为r（正体）、i（斜体）、o（伪斜体）、ri（反向斜体）、ot（其他），部分字体支持其他值；</dd>
<dt>widthtype</dt><dd>字宽，通常为normal（常规）、condensed（紧缩）、semicondensed（半紧缩）、extended（加宽），部分字体支持其他值；</dd>
<dt>style</dt><dd>可选的附加样式名，通常为空（此时该位置会出现两个连续的连字符）；也可指定 ISO-639 双字母语言代码（如ja日语、ko韩语），部分支持中日韩文字的字体会在此字段标注相关信息；</dd>
<dt>pixels</dt><dd>字体高度（单位：像素）；</dd>
<dt>height</dt><dd>屏幕上的字体高度（单位：0.1 印刷点），即字体号数乘以 10；在固定垂直分辨率下，该值与pixels成正比，因此通常只需指定其中一个，另一个用*替代；</dd>
<dt>horiz</dt><dd>字体适配的屏幕水平分辨率（单位：像素 / 英寸）；</dd>
<dt>vert</dt><dd>字体适配的屏幕垂直分辨率（单位：像素 / 英寸）；系统字体的分辨率通常与当前屏幕匹配，因此这两个字段一般均设为*；</dd>
<dt>spacing</dt><dd>字符间距类型，m（等宽）、p（比例间距）、c（字符格）三者之一；</dd>
<dt>width</dt><dd>平均字符宽度（单位：0.1 像素）；</dd>
<dt>registry</dt><dd></dd>

<dt>encoding</dt><dd>字体对应的 X 字体字符集（与 Emacs 字符集不同，但相似），可通过xfontsel程序查看可选值，通常注册表设为 'iso8859' 、编码设为 '1' 。</dd>
</dl>

<p>
<b>方式四：字体别名</b>
</p>

<p>
部分字体会有简短的别名，可替代完整的字体规范表示，例如6x13等价于：
</p>

<div class="org-src-container">
<pre class="src src-shell">-misc-fixed-medium-r-semicondensed--13-*-*-*-c-60-iso8859-1
</pre>
</div>

<p>
注意：该方式在 Windows 系统中不被支持。
</p>

<p>
<b>X 窗口系统下的 Emacs 字体类型</b>
</p>

<p>
在 X 系统中，Emacs 支持两种字体：
</p>

<ol class="org-ol">
<li>客户端字体：由 Xft 和 Fontconfig 库提供，支持抗锯齿、亚像素微调等高级字体特性；</li>
<li>服务端字体：由 X 服务器自身提供，不支持上述高级特性。</li>
</ol>

<p>
注意：Fontconfig 模式和 GTK 模式仅能匹配客户端字体。
</p>

<p>
<b>等宽字体的查询与预览</b>
</p>

<p>
Emacs 的默认字体建议使用等宽字体（所有字符宽度相同），不同类型字体的查询方式如下：
</p>

<ol class="org-ol">
<li><p>
Xft/Fontconfig 客户端等宽字体：使用fc-list命令查询
</p>

<div class="org-src-container">
<pre class="src src-shell">fc-list :<span style="color: #a0522d;">spacing</span>=mono
fc-list :<span style="color: #a0522d;">spacing</span>=charcell
</pre>
</div></li>

<li><p>
X 服务端等宽字体：使用xlsfonts程序查询
</p>

<div class="org-src-container">
<pre class="src src-shell">xlsfonts -fn <span style="color: #8b2252;">'*x*'</span> | grep -E <span style="color: #8b2252;">'^[0-9]+x[0-9]+'</span>
xlsfonts -fn <span style="color: #8b2252;">'*-*-*-*-*-*-*-*-*-*-*-m*'</span>
xlsfonts -fn <span style="color: #8b2252;">'*-*-*-*-*-*-*-*-*-*-*-c*'</span>
</pre>
</div></li>
</ol>

<p>
XLFD 格式中， 间距字段为 'm' 或 'c' 的字体均为等宽字体。可使用xfd命令预览指定字体的样式，示例如下：
</p>

<div class="org-src-container">
<pre class="src src-shell">xfd -fn 6x13
</pre>
</div>

<p>
该命令会显示 '<code>6x13</code>' 字体的所有字符。
</p>

<p>
<b>补充说明</b>
</p>

<p>
在 Emacs 运行过程中，还可为 <b>特定类型的文本</b> 单独设置字体（参见《<a href="#Faces">文本面属性</a>》章节），或为 <b>单个框架</b> 自定义字体（参见《<a href="#Frame-Parameters">框架参数</a>》章节）。
</p>
</div>
</div>
<div id="outline-container-Speedbar" class="outline-3">
<h3 id="Speedbar"><span class="section-number-3">23.9.</span> 速览栏框架</h3>
<div class="outline-text-3" id="text-Speedbar">
<p>
<code>speedbar速览栏</code> 是一个特殊框架，用于便捷地在另一框架中进行导航或执行操作。速览栏一旦创建，始终与某个特定框架相关联，该框架被称为其 <b>attached frame关联框架</b> ；所有速览栏操作均作用于这个关联框架。
</p>

<p>
键入 <code>M-x speedbar</code> 可创建速览栏，并将其与当前框架相关联。要关闭速览栏，可再次键入 <code>M-x speedbar</code> ，或选中速览栏后键入 <code>q</code> （也可像删除其他 Emacs 框架一样直接删除速览栏框架）。若要将速览栏关联至其他框架，需先关闭现有速览栏，再在目标框架中执行 <code>M-x speedbar</code> 命令。
</p>

<p>
速览栏支持多种工作模式， <b>various modes文件显示模式</b> 为其默认模式：该模式下，速览栏会按行显示关联框架选中窗口当前目录下的所有文件。点击非目录文件，会在关联框架的选中窗口中打开该文件（参见《<a href="#Mouse-References">用鼠标跟随引用链接</a>》章节）；点击目录，则会在速览栏中展示该目录的内容。每一行内容旁都有一个 '<code>[+]</code>' 或 '<code>&lt;+&gt;</code>' 的方框，点击该方框可 <b>展开</b> 对应项目的内容：展开目录会将该目录下的内容添加至速览栏中对应目录行的下方；展开普通文件则会在速览栏中列出该文件内的所有标签，点击标签名可跳转到关联框架选中窗口中该标签的对应位置。当文件或目录被展开后，旁侧的 '<code>[+]</code>' 会变为 '<code>[-]</code>' ，点击该方框可 <b>折叠</b> 项目，隐藏其展开的内容。
</p>

<p>
也可通过 <b>键盘</b> 操作速览栏进行导航：光标停在速览栏某一行时键入回车键（ <code>RET</code> ），效果等同于点击该行的项目；按下空格键（ <code>SPC</code> ）可展开或折叠对应项目；按下 <code>U</code> 会显示当前目录的上级目录。要复制、删除或重命名光标所在行的文件，可分别键入 <code>C</code> 、 <code>D</code> 、 <code>R</code> ；按下 <code>M</code> 可创建新目录。
</p>

<p>
速览栏的另一通用模式为 <b>Buffer Display mode缓冲区显示模式</b> ，该模式下速览栏会列出所有 Emacs 缓冲区。在速览栏中键入 <code>b</code> 可切换至该模式，键入 <code>f</code> 则可恢复为文件显示模式。也可在速览栏窗口的任意位置点击鼠标右键（ <code>mouse-3</code> ）（或在模式行点击鼠标左键 <code>mouse-1</code> ），在弹出的菜单中选择 <b>显示方式</b> 来切换显示模式。
</p>

<p>
部分主模式（包括 Rmail 邮件模式、Info 信息模式和 GUD 调试模式）为速览栏提供了 <b>专属适配功能</b> ，会将该模式下的常用项目载入速览栏供用户选择。例如，在 Rmail 模式下，速览栏会列出所有 Rmail 邮件文件，点击文件旁的 '&lt;M&gt;' 方框，可将当前邮件移动至该 Rmail 文件中。
</p>

<p>
关于速览栏的使用与编程开发细节，详见《<a href="https://www.gnu.org/software/emacs/manual/html_node/speedbar/index.html#Top">速览栏手册</a>》中的速览栏相关章节。
</p>
</div>
</div>
<div id="outline-container-Multiple-Displays" class="outline-3">
<h3 id="Multiple-Displays"><span class="section-number-3">23.10.</span> 多显示器支持</h3>
<div class="outline-text-3" id="text-Multiple-Displays">
<p>
单个 Emacs 程序可连接至多个 X 显示器。Emacs 启动时默认仅使用一个显示器 —— 即通过 <code>DISPLAY</code> 环境变量或 '&#x2013;display' 选项指定的显示器（参见《<a href="#Initial-Options">启动选项</a>》章节）。若要连接至其他显示器，可使用 <code>make-frame-on-display</code> 命令：
</p>

<dl class="org-dl">
<dt><code>M-x make-frame-on-display RET 显示器名 RET</code></dt><dd>在指定显示器上创建一个新框架。</dd>
</dl>

<p>
单个 X 服务器可管理多个屏幕。当在同一服务器的两个屏幕上打开 Emacs 框架时，Emacs 会识别出这些屏幕共享一个键盘，并将来自这些屏幕的所有命令视作单一的输入流进行处理。
</p>

<p>
若在 <b>不同 X 服务器</b> 的显示器上打开 Emacs 框架，Emacs 会为每个服务器创建独立的输入流，且每个服务器各自拥有一个选中框架。通过某一特定 X 服务器输入的命令，仅会作用于该服务器对应的选中框架。
</p>

<p>
在多显示器显示环境中，还可使用 <code>make-frame-on-monitor</code> 命令：
</p>

<dl class="org-dl">
<dt><code>M-x make-frame-on-monitor RET 显示器名 RET</code></dt><dd>在指定的显示器上创建新框架，该显示器的屏幕区域为当前显示设备的一部分。</dd>
</dl>
</div>
</div>
<div id="outline-container-Frame-Parameters" class="outline-3">
<h3 id="Frame-Parameters"><span class="section-number-3">23.11.</span> 框架参数</h3>
<div class="outline-text-3" id="text-Frame-Parameters">
<p>
可通过在变量 <code>default-frame-alist</code> 中指定 <b>框架参数默认列表</b> ，控制所有框架的默认外观与行为。该变量的值为一个参数条目列表，每个条目均指定一个参数名及其对应取值，这些条目会在 Emacs 创建新框架（包括初始框架）时生效。
</p>

<p>
例如，可在初始化文件中添加以下代码（参见《<a href="#Init-File">Emacs 初始化文件</a>》章节），将默认框架宽度设为 90 字符列、默认框架高度设为 40 字符行，并将默认字体设为等宽字体 10 号（ '<code>Monospace-10</code>' ）：
</p>

<div class="org-src-container">
<pre class="src src-shell">(add-to-list <span style="color: #8b2252;">'default-frame-alist '</span>(width  . 90))
(add-to-list <span style="color: #8b2252;">'default-frame-alist '</span>(height . 40))
(add-to-list <span style="color: #8b2252;">'default-frame-alist '</span>(font . <span style="color: #8b2252;">"Monospace-10"</span>))
</pre>
</div>

<p>
关于框架参数的完整列表及其作用，详见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Frame-Parameters.html#Frame-Parameters">框架参数</a>》章节。
</p>

<p>
也可通过自定义变量 <code>initial-frame-alist</code> ，指定仅对 <b>初始框架</b> 生效的框架参数列表。
</p>

<p>
若 Emacs 编译时启用了 X 工具包支持，用于指定颜色和字体的框架参数将 <b>不会作用于菜单和菜单栏</b> ，因为这类界面元素由 X 工具包绘制，而非 Emacs 直接渲染。
</p>

<p>
框架的外观与行为也可通过X 资源进行自定义（参见《<a href="#X-Resources">X 选项与资源</a>》章节），且 X 资源的配置会覆盖初始化文件中为初始框架指定的参数。
</p>

<p>
请注意，若使用桌面库保存和恢复 Emacs 会话，待恢复的框架及其参数会一同记录在桌面文件中。恢复这些框架时，文件中记录的参数会 <b>优先于</b> 初始化文件里 <code>default-frame-alist</code> 和 <code>initial-frame-alist</code> 所指定的框架参数。如何避免该情况，详见《<a href="#Saving-Emacs-Sessions">保存 Emacs 会话</a>》章节。
</p>
</div>
</div>
<div id="outline-container-Scroll-Bars" class="outline-3">
<h3 id="Scroll-Bars"><span class="section-number-3">23.12.</span> 滚动条</h3>
<div class="outline-text-3" id="text-Scroll-Bars">
<p>
在图形化显示界面中，Emacs 的每个窗口侧边都会显示一个 <b>垂直滚动条</b> 。点击滚动条的上下箭头按钮，窗口会每次滚动一行（部分工具包支持自定义滚动条，可隐藏此类箭头按钮）；在滚动条滑块的上方或下方点击 <code>mouse-1</code> 鼠标左键，窗口会分别向上、向下滚动近乎一整屏的内容，效果等同于快捷键 <code>M-v</code> 和 <code>C-v</code> （参见《<a href="#Moving-Point">移动光标位置</a>》章节）（该行为在部分工具包中也可自定义）；拖动滑块则可实现窗口的连续滚动。
</p>

<p>
若 Emacs 在 X 窗口系统中编译时未启用 X 工具包支持，滚动条的操作行为会有所不同：在滚动条的任意位置点击 <code>mouse-1</code> 鼠标左键，窗口会像按下 <code>C-v</code> 一样向下滚动；点击 <code>mouse-3</code> 鼠标右键，窗口会像按下 <code>M-v</code> 一样向上滚动；点击 <code>mouse-2</code> 鼠标中键并拖动，可上下移动滚动条滑块。
</p>

<p>
键入 <code>M-x scroll-bar-mode</code> 可 <b>切换垂直滚动条的启用状态</b> ，该命令对所有框架生效，包括尚未创建的框架；若仅需切换当前选中框架的垂直滚动条状态，可使用命令 <code>M-x toggle-scroll-bar</code> 。
</p>

<p>
若要在 Emacs 启动时就控制垂直滚动条的启用状态，可自定义变量 <code>scroll-bar-mode</code> （参见《<a href="#Customization">自定义配置</a>》章节）。该变量的取值有三种： <code>right</code> （将滚动条置于窗口右侧）、 <code>left</code> （将滚动条置于窗口左侧）、 <code>nil</code> （禁用垂直滚动条）。默认情况下，若 Emacs 在 X 窗口系统中编译时启用了 GTK+ 支持，或运行在 Windows、macOS 系统中，滚动条会默认显示在窗口右侧；若 Emacs 在 X 窗口系统中编译时未启用 GTK+ 支持，滚动条会默认显示在窗口左侧（遵循 X 应用程序的旧有惯例）。
</p>

<p>
也可通过 X 资源项 '<code>verticalScrollBars</code>' 启用或禁用滚动条（参见《<a href="#Resources">X 资源</a>》章节）；若要调整滚动条的宽度，可修改框架参数 <code>scroll-bar-width</code> （参见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Frame-Parameters.html#Frame-Parameters">框架参数</a>》章节）。
</p>

<p>
若在 X 窗口系统中使用 Emacs（启用 GTK+ 或 Motif 支持），可自定义变量 <code>scroll-bar-adjust-thumb-portion</code> ，控制滚动条的 <b>超滚动</b> 行为（即即便缓冲区末尾已显示在窗口中，仍可向下拖动滑块）。当该变量取值为非nil时，即便缓冲区末尾可见，仍可向下拖动滚动条滑块；取值为 <code>nil</code> 时，若缓冲区末尾已显示，滑块会固定在滚动条最下方。当整个缓冲区内容均可在窗口中显示时，无法触发超滚动行为。
</p>

<p>
滚动条的 <b>视觉样式</b> 由 <code>scroll-bar</code> 滚动条外观属性控制（部分工具包如 GTK+、Windows 会忽略该面属性，其滚动条样式仅能通过系统全局设置自定义，GTK + 的相关配置可参见《<a href="#GTK-resources">GTK + 资源</a>》章节）。
</p>

<p>
在图形化框架中，垂直滚动条还会在 <b>视觉上分隔左右并排的窗口</b> 。当垂直滚动条被禁用时，Emacs 会默认使用 1 像素宽的垂直边框分隔这类窗口。该边框会占据右侧窗口的第一列像素，可能会遮挡窗口中显示的字符最左侧的像素。若这些像素包含重要信息，可启用 <b>窗口分隔线</b> 使其显示（参见《<a href="#Window-Dividers">窗口分隔线</a>》章节）；若要还原垂直边框的视觉效果，可将框架的 <code>right-divider-width</code> 参数设为 1，并让窗口分隔线的面属性继承垂直边框的面属性（详见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Window-Dividers.html#Window-Dividers">窗口分隔线</a>》章节）。
</p>

<p>
在启用了工具包支持的图形化显示界面中，Emacs 还可为每个窗口的底部添加 <b>horizontal scroll bar水平滚动条</b> 。点击水平滚动条的左右箭头按钮，窗口会每次水平滚动一列；（注意：部分工具包支持自定义滚动条，可隐藏此类箭头按钮）；在水平滚动条滑块的左侧或右侧点击鼠标左键，窗口会分别向左、向右滚动四列；拖动滑块则可实现窗口的连续水平滚动。
</p>

<p>
需注意，水平滚动可能会导致 <b>光标位置移出窗口的左右可视区域</b> 。此时键入字符插入文本，或使用键盘命令移动光标，光标通常会重新回到可视区域内。
</p>

<p>
键入 <code>M-x horizontal-scroll-bar-mode</code> 可 <b>切换水平滚动条的启用状态</b> ，该命令对所有框架生效，包括尚未创建的框架；若仅需切换当前选中框架的水平滚动条状态，可使用命令 <code>M-x toggle-horizontal-scroll-bar</code> 。
</p>

<p>
若要在 Emacs 启动时控制水平滚动条的启用状态，可自定义变量 <code>horizontal-scroll-bar-mode</code> 。
</p>

<p>
也可通过 X 资源项 '<code>horizontalScrollBars</code>' 启用或禁用水平滚动条（参见《<a href="#Resources">X 资源</a>》章节）；若要调整水平滚动条的高度，可修改框架参数 <code>scroll-bar-height</code> （参见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Frame-Parameters.html#Frame-Parameters">框架参数</a>》章节）。
</p>
</div>
</div>
<div id="outline-container-Window-Dividers" class="outline-3">
<h3 id="Window-Dividers"><span class="section-number-3">23.13.</span> 窗口分隔线</h3>
<div class="outline-text-3" id="text-Window-Dividers">
<p>
在图形化显示界面中，可启用 <code>window dividers</code> 窗口分隔线实现窗口的视觉分隔。窗口分隔线为可通过鼠标拖动的条状区域，借助它能轻松调整相邻窗口的尺寸。
</p>

<p>
键入命令 <code>M-x window-divider-mode</code> ，可切换窗口分隔线的显示状态。
</p>

<p>
如需自定义窗口分隔线的显示位置，可配置选项 <code>window-divider-default-places</code> ，其取值有三种： <code>bottom-only</code> （仅在窗口底部显示分隔线）、 <code>right-only</code> （仅在窗口右侧显示分隔线）、 <code>t</code> （在窗口底部和右侧均显示分隔线）。
</p>

<p>
如需调整该模式下窗口分隔线的宽度，可分别配置选项 <code>window-divider-default-bottom-width</code> （底部分隔线宽度）和 <code>window-divider-default-right-width</code> （右侧分隔线宽度）。
</p>

<p>
当垂直滚动条被禁用时，窗口分隔线还能发挥实用作用 —— 让窗口的第一列像素保持可见。若不启用分隔线，这一列像素会被用于分隔左右并排窗口的垂直边框遮挡（参见《<a href="#Scroll-Bars">滚动条</a>》章节）。
</p>

<p>
关于窗口分隔线的更多细节，详见《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Window-Dividers.html#Window-Dividers">窗口分隔线</a>相关章节
</p>
</div>
</div>
<div id="outline-container-Drag-and-Drop" class="outline-3">
<h3 id="Drag-and-Drop"><span class="section-number-3">23.14.</span> 拖放功能</h3>
<div class="outline-text-3" id="text-Drag-and-Drop">
<p>
在大多数图形化桌面环境中，Emacs 支持基础的拖放操作。例如，将文本拖放至 Emacs 框架中，文本会被插入到拖放的位置；将文件拖放至 Emacs 框架中，Emacs 会打开该文件。一个特殊场景为：若将文件拖放至 Dired 缓冲区，该文件会根据源应用的操作规则，被移动或复制到该缓冲区所显示的目录中。
</p>

<p>
将文件拖放至 Emacs 时，默认会在拖放目标窗口中打开该文件。若希望此类场景下在新窗口中打开文件，可自定义变量 <code>dnd-open-file-other-window</code> 。
</p>

<p>
Emacs 目前支持 XDND、Motif 拖放协议，以及旧版的 KDE 1.x 拖放协议。
</p>

<p>
在将文本拖向 Emacs 窗口的过程中，若要滚动窗口或确定拖放文本的插入位置，操作起来会较为不便。将选项 <code>dnd-indicate-insertion-point</code> 设为非nil值后，拖放过程中鼠标在窗口内移动时，光标会自动跳至文本即将被插入的位置；将 <code>dnd-scroll-margin</code> 设为整数值后，拖放时若鼠标移动至窗口顶部或底部的该数值行范围内，窗口会自动滚动。
</p>

<p>
Emacs 也可通过鼠标将选区拖放至当前缓冲区或其他缓冲区的任意位置，该功能需将变量 <code>mouse-drag-and-drop-region</code> 设为非nil值方可启用。默认规则为：若拖放的目标缓冲区与源缓冲区为同一个，文本会被移动（即剪切并粘贴）；若拖放至其他缓冲区，则仅复制文本。若将该变量设为某一修饰键名称（如'shift'、'control'或'alt'），则拖放时按住该修饰键，即便拖放至源缓冲区，文本也会被复制而非剪切。
</p>

<p>
若希望即便源缓冲区与目标缓冲区不同，拖放时仍执行剪切操作，可将选项 <code>mouse-drag-and-drop-region-cut-when-buffers-differ</code> 设为非nil值。默认情况下，在图形化显示界面中，拖放过程中选中的文本会在工具提示中显示，且光标会随鼠标指针一同移动。若要关闭该行为，可将选项 <code>mouse-drag-and-drop-region-show-tooltip</code> 或 <code>mouse-drag-and-drop-region-show-cursor</code> 设为nil。
</p>

<p>
若要将文本从 Emacs 拖放至其他程序，需将选项 <code>mouse-drag-and-drop-region-cross-program</code> 设为非nil值。
</p>

<p>
在 X 窗口系统中，部分程序可将文件拖放至 Emacs，期望 Emacs 对其进行保存。默认情况下，Emacs 会先提示用户输入保存的文件名，完成保存后再打开该文件；可通过修改变量 <code>x-dnd-direct-save-function</code> 更改此行为。更多细节详见《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Drag-and-Drop.html#Drag-and-Drop">拖放操作</a>相关章节。
</p>
</div>
</div>
<div id="outline-container-Menu-Bars" class="outline-3">
<h3 id="Menu-Bars"><span class="section-number-3">23.15.</span> 菜单栏</h3>
<div class="outline-text-3" id="text-Menu-Bars">
<p>
可使用 <code>M-x menu-bar-mode</code> 命令切换菜单栏的启用状态。不带参数执行该命令时，会对 <b>菜单栏模式</b> （一款全局次要模式）进行开关切换；带参数执行时，若参数为正数则开启菜单栏模式，非正数则关闭。若要在 Emacs 启动时控制菜单栏的启用状态，可自定义变量 <code>menu-bar-mode</code> 。
</p>

<p>
资深用户通常会关闭菜单栏，在文本终端中尤为如此 —— 关闭后能多腾出一行空间用于显示文本。若菜单栏已关闭，在支持弹出菜单的显示界面中，可通过 <code>C-mouse-3</code> 调出包含菜单栏全部内容的弹出菜单；也可启用上下文菜单模式，并自定义变量 <code>context-menu-functions</code> ，通过点击鼠标右键（mouse-3）调出上下文菜单，相关操作详见《<a href="#Menu-Mouse-Clicks">菜单的鼠标点击操作</a>》章节。
</p>

<p>
关于如何通过菜单栏调用命令的相关说明，参见《<a href="#Menu-Bar">菜单栏</a>》章节；关于如何自定义菜单栏及菜单项视觉样式的方法，参见《<a href="#X-Resources">X 选项与资源</a>》章节。
</p>
</div>
</div>
<div id="outline-container-Tool-Bars" class="outline-3">
<h3 id="Tool-Bars"><span class="section-number-3">23.16.</span> 工具栏</h3>
<div class="outline-text-3" id="text-Tool-Bars">
<p>
在图形化显示界面中，Emacs 会在每个框架的顶部、菜单栏正下方显示一个工具栏。工具栏是一排带有图标的按钮，点击这些按钮可调用各类对应命令。Emacs 也可根据需要，在每个窗口的顶部单独显示工具栏（参见《<a href="#Window-Tool-Bar">窗口工具栏</a>》章节）。
</p>

<p>
全局（默认）工具栏包含各类通用命令，部分主模式也会定义专属工具栏：当当前缓冲区使用这类带专属工具栏的主模式时，该主模式的工具栏会替换全局工具栏。若要阻止这种替换行为，可自定义变量 <code>tool-bar-always-show-default</code> 。
</p>

<p>
键入 <code>M-x tool-bar-mode</code> 可切换工具栏的启用状态，该命令对所有框架生效，包括尚未创建的框架。若要在 Emacs 启动时控制工具栏的启用状态，可自定义变量 <code>tool-bar-mode</code> 。
</p>

<p>
当 Emacs 编译时启用了 GTK+ 支持，每个工具栏项可仅显示图片、仅显示文本标签，或同时显示两者。默认情况下，Emacs 会遵循 GNOME 桌面的工具栏样式设置；若未定义相关设置，则仅以图片形式显示工具栏项。若要强制使用特定的工具栏样式，可自定义变量 <code>tool-bar-style</code> 。
</p>

<p>
对于 GTK+ 工具栏，还可通过框架参数 <code>tool-bar-position</code> 控制其显示位置，详见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Frame-Parameters.html#Frame-Parameters">框架参数</a>》章节。
</p>

<p>
NS 版本的 Emacs 将工具栏视作 <b>窗口装饰元素</b> ，因此当窗口取消装饰时，工具栏也会随之隐藏，相关说明详见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Frame-Parameters.html#Frame-Parameters">框架参数</a>》章节。在 macOS 系统中，当框架进入全屏模式时工具栏会被隐藏，将鼠标指针移至屏幕顶部即可重新显示工具栏。
</p>

<p>
部分键盘会缺少 Emacs 用户可能需要用到的修饰键（参见《<a href="#Modifier-Keys">修饰键</a>》章节），导致用户无法或难以输入带这些修饰键的按键序列。例如，许多键盘无 Hyper 和 Super 修饰键，智能手机的虚拟键盘通常也没有 <code>Ctrl</code> 和 <code>Alt</code> 修饰键。针对此情况，Emacs 可选择性显示一个由修饰键按钮组成的额外工具栏，即 <b>modifier bar修饰键栏</b> 。点击修饰键栏中的按钮后，Emacs 会将该按钮对应的修饰键应用到接下来读取的一次键盘操作中。启用全局次要模式 <code>modifier-bar-mode</code> 即可显示修饰键栏，键入 <code>M-x modifier-bar-mode</code> 可完成该模式的开关切换。
</p>
</div>
</div>
<div id="outline-container-Tab-Bars" class="outline-3">
<h3 id="Tab-Bars"><span class="section-number-3">23.17.</span> 标签栏</h3>
<div class="outline-text-3" id="text-Tab-Bars">
<p>
在图形化显示界面和文本终端中，Emacs 可根据需要在每个框架的顶部显示 <code>Tab Bar标签栏</code> ，其位置位于菜单栏下方（参见《<a href="#Menu-Bars">菜单栏</a>》）、工具栏上方或下方（参见《<a href="#Tool-Bars">工具栏</a>》），具体由变量 <code>tab-bar-position</code> 控制。标签栏是一排标签按钮，点击即可在不同的窗口配置间切换。
</p>

<p>
标签栏中的每个标签，代表其所属框架的一个 <b>命名持久化窗口配置</b> ，即该框架被划分为多个窗口的布局方式，以及每个窗口中显示的对应缓冲区。标签名称由该窗口配置下各窗口所显示的缓冲区名称组合而成。点击标签会切换至该标签记录的窗口配置，该配置是此框架中该标签作为当前标签时曾使用过的窗口与缓冲区布局。
</p>

<p>
若你使用桌面库保存和恢复 Emacs 会话（参见《<a href="#Saving-Emacs-Sessions">保存 Emacs 会话</a>》），标签栏中的所有标签会与其关联的窗口配置一同记录在桌面文件中，恢复会话后这些标签仍可使用。
</p>

<p>
请注意， <b>标签栏</b> 与 <b>标签行</b> （参见《<a href="#Tab-Line">窗口标签行</a>》）并非同一功能：窗口顶部标签行的标签，用于在当前窗口的不同缓冲区间切换；而框架顶部标签栏的标签，用于在包含多个窗口、显示一个或多个缓冲区的不同窗口配置间切换。
</p>

<p>
键入 <code>M-x tab-bar-mode</code> 可切换标签栏的启用状态，该命令对所有框架生效，包括尚未创建的框架。若要在 Emacs 启动时控制标签栏的启用状态，可自定义变量 <code>tab-bar-mode</code> 并保存该配置。
</p>

<p>
变量 <code>tab-bar-show</code> 用于控制标签栏模式是否自动开启：
</p>
<ul class="org-ul">
<li>若取值为 <code>t</code> ，执行创建新标签的命令时会自动启用标签栏模式；</li>
<li>若取值为 <code>1</code> ，当标签栏仅有一个标签时会自动隐藏，创建更多标签后则重新显示；</li>
<li>更通用的规则为，若取值为非负整数，仅当标签数量大于该数值时，标签栏才会显示；</li>
<li>若取值为 <code>nil</code> ，标签栏会始终隐藏，此时仍可通过 <code>M-x tab-next</code> 、 <code>M-x tab-switcher</code> 等支持标签名补全的命令，在不显示标签栏的情况下切换命名窗口配置，也可通过 <code>M-x tab-new</code> 、 <code>M-x tab-close</code> 等命令完成标签的创建与关闭。</li>
</ul>

<p>
需注意，若 <code>tab-bar-show</code> 设为数值，标签栏可能会在部分框架中显示、另一部分框架中隐藏，具体取决于各框架中创建的标签数量。
</p>

<p>
若仅需切换当前选中框架的标签栏启用状态，可键入 <code>M-x toggle-frame-tab-bar</code> 。该命令可实现对不同框架的标签栏进行选择性启用，不受 <code>tab-bar-mode</code> 和 <code>tab-bar-show</code> 取值的影响。
</p>

<p>
前缀键 <code>C-x t</code> 的功能逻辑与 <code>C-x 5</code> 相似： <code>C-x 5</code> 系列命令会在不同框架中打开缓冲区（参见《<a href="#Creating-Frames">创建框架</a>》），而 <code>C-x t</code> 系列命令会在选中框架的不同标签中，以不同的窗口配置打开缓冲区。
</p>

<p>
<code>C-x t</code> 下的各类命令，核心区别在于查找或创建待选中缓冲区的方式，以下命令可在新标签中选中指定缓冲区：
</p>
<dl class="org-dl">
<dt><code>C-x t 2</code></dt><dd>新建一个标签 (<code>tab-new</code>) 。可通过自定义变量 <code>tab-bar-new-tab-choice</code> ，控制新标签中默认显示的缓冲区；也可通过自定义变量 <code>tab-bar-tab-name-function</code> ，设置新标签的默认命名规则。</dd>
<dt><code>C-x t b</code> bufname RET=</dt><dd>在另一个标签中选中指定名称的缓冲区，对应命令 <code>switch-to-buffer-other-tab</code> 。</dd>
<dt><code>C-x t f</code> filename RET=</dt><dd>打开指定文件（参见《<a href="#Visiting">打开文件</a>》），并在另一个标签中选中该文件对应的缓冲区，对应命令 <code>find-file-other-tab</code> 。</dd>
<dt><code>C-x t d</code> directory RET=</dt><dd>在另一个标签中编辑指定目录（参见《<a href="#Dired">Dired：目录编辑器</a>》），对应命令 <code>dired-other-tab</code> 。</dd>
<dt><code>C-x t t</code></dt><dd>一个前缀命令 (<code>other-tab-prefix</code>) ，作用于紧随其后执行的命令：该前缀会让后续命令所显示的缓冲区，在新的标签中展示。</dd>
</dl>

<p>
默认情况下，新建标签会显示执行新建命令前的当前缓冲区。若要让新标签默认显示其他缓冲区，可自定义变量 <code>tab-bar-new-tab-choice</code> 。
</p>

<p>
变量 <code>tab-bar-new-tab-to</code> 用于控制新标签的位置，默认情况下，新标签会添加在当前标签的右侧。
</p>

<p>
<b>标签的删除命令</b>
</p>

<dl class="org-dl">
<dt><code>C-x t 0</code></dt><dd>关闭当前选中的标签 (<code>tab-close</code>) 。若标签栏中仅有一个标签，该操作默认无效果，除非将变量 <code>tab-bar-close-last-tab-choice</code> 自定义为非默认值。</dd>
<dt><code>C-x t 1</code></dt><dd>关闭当前选中框架中，除当前标签外的所有其他标签。</dd>
</dl>

<p>
变量 <code>tab-bar-close-tab-select</code> 用于控制关闭当前标签后选中的目标标签，默认会选中最近使用过的标签。
</p>

<p>
命令 <code>tab-undo</code> 可恢复最后一个被关闭的标签。
</p>

<p>
<b>标签的切换命令</b>
</p>

<dl class="org-dl">
<dt><code>C-x t o</code></dt><dd></dd>

<dt><code>C-TAB</code></dt><dd>切换至下一个标签  (<code>tab-next</code>) 。重复执行该命令，会在当前选中框架的所有标签间循环切换。带正数值前缀参数 <code>n</code> 时，切换至第 <code>n</code> 个下一个标签；带负数值前缀参数 - n 时，切换至第 n 个上一个标签。</dd>
<dt><code>S-C-TAB</code></dt><dd>切换至上一个标签 (<code>tab-previous</code>) 。带正数值前缀参数 <code>n</code> 时，切换至第 <code>n</code> 个上一个标签；带负数值前缀参数 <code>-n</code> 时，切换至第 <code>n</code> 个下一个标签。</dd>
<dt><code>C-x t RET tabname RET</code></dt><dd>根据标签名切换标签 (<code>tab-switch</code>) ，支持所有标签名的补全功能。标签名的默认候选列表和 “future history历史未来项” 会按最近使用顺序排序，因此可使用 <code>M-n</code> (<code>next-history-element</code>) 快速选择最后一个、倒数第二个曾访问的标签名。</dd>
<dt><i><code>modifier</code></i>-<i><code>tab-number</code></i></dt><dd><code>修饰键 + 标签数字</code> 根据标签的序号切换标签 (<code>tab-select</code>) 。先自定义变量 <code>tab-bar-select-tab-modifiers</code> ，指定一个或多个修饰键后，即可通过 <b>指定修饰键 + 标签数字</b> 的组合键，按序号选中对应标签；数字 9 可用于选中最后一个标签。Emacs 支持的所有修饰键均可配置（参见《<a href="#Modifier-Keys">修饰键</a>》）。若要在标签名称旁显示标签序号，可自定义变量 <code>tab-bar-tab-hints</code> ，便于你快速确定选中对应标签所需按下的数字键。</dd>
<dt><i><code>modifier</code></i>-9</dt><dd><code>修饰键 + 9</code> 切换至最后一个标签 (<code>tab-last</code>) ，组合键为 <code>tab-bar-select-tab-modifiers</code> 定义的修饰键 + 数字 9。带数值前缀参数 <code>n</code> 时，切换至倒数第 <code>n</code> 个标签。</dd>
<dt><i><code>modifier</code></i>-0</dt><dd><code>修饰键 + 0</code> 切换至最近使用的标签 (<code>tab-recent</code>) ，组合键为 <code>tab-bar-select-tab-modifiers</code> 定义的修饰键 + 数字 0。带数值前缀参数 <code>n</code> 时，切换至第 <code>n</code> 个最近使用的标签。</dd>
</dl>

<p>
<b>标签的操作命令</b> 
</p>
<dl class="org-dl">
<dt><code>C-x t r tabname RET</code></dt><dd>将当前标签重命名为指定名称 (<code>tab-rename</code>) 。</dd>
<dt><code>C-x t m</code></dt><dd>将当前标签向右移动一个位置 (<code>tab-move</code>) 。带正数值前缀参数 <code>n</code> 时，向右移动 <code>n</code> 个位置；带负数值前缀参数 <code>-n</code> 时，向左移动 <code>n</code> 个位置。</dd>
</dl>

<p>
<b>标签的鼠标操作</b>
</p>

<p>
点击鼠标中键（ <code>mouse-2</code> ）可关闭对应标签；点击鼠标右键（ <code>mouse-3</code> ）会弹出上下文菜单，包含对该标签的各类操作选项；按住鼠标左键（ <code>mouse-1</code> ）拖动标签，可将其移至标签栏的其他位置；滚动鼠标滚轮，可在标签间切换至上一个或下一个；滚动滚轮时按住 <code>Shift</code> 键，可将当前标签向左或向右移动。
</p>

<p>
<b>标签的触摸屏操作</b>
</p>

<p>
也可通过触摸屏输入操作标签（参见《<a href="#Other-Input">触摸屏输入与虚拟键盘</a>》）： <b>长按</b> （参见《<a href="#Touchscreens">在触摸屏上使用 Emacs</a>》）某个标签，会弹出对该标签的操作上下文菜单；长按标签栏本身，会弹出可创建和删除标签的上下文菜单；轻点某个标签，即可选中该标签对应的窗口配置；轻点标签栏上的按钮，效果等同于用 <code>mouse-1</code> 鼠标左键点击该按钮。
</p>

<p>
可启用 <code>tab-bar-history-mode</code> 模式，让 Emacs 记录每个标签使用过的所有窗口配置，后续可恢复这些配置：
</p>
<dl class="org-dl">
<dt><code>M-x tab-bar-history-back</code></dt><dd>恢复当前标签曾使用过的上一个窗口配置，可在窗口配置的历史记录中向后回溯；</dd>
<dt><code>M-x tab-bar-history-forward</code></dt><dd>撤销上一次的窗口配置恢复操作，可在窗口配置的历史记录中向前前进。</dd>
</dl>

<p>
可通过用户选项 <code>tab-bar-format</code> ，自定义标签栏上显示的各类元素。
</p>
</div>
</div>
<div id="outline-container-Dialog-Boxes" class="outline-3">
<h3 id="Dialog-Boxes"><span class="section-number-3">23.18.</span> 使用对话框</h3>
<div class="outline-text-3" id="text-Dialog-Boxes">
<p>
<code>dialog box对话框</code> 是一种特殊的交互窗口，用于向用户询问  <code>yes-or-no 是否</code> 类问题或其他特定问题。若你通过鼠标调用触发该问题的 Emacs 命令，许多 Emacs 命令都会通过对话框提出是否类的询问。
</p>

<p>
若要禁用对话框，可将变量 <code>use-dialog-box</code> 设为 <code>nil</code> 。此时 Emacs 将始终通过回显区和键盘输入的方式，发起 <code>yes-or-no 是否</code> 类的提示询问。该变量同时也控制是否启用文件选择窗口（但并非所有平台都支持此功能）。
</p>

<p>
文件选择窗口是用于询问文件名的专用对话框。即便你希望保留其他类型的对话框，也可自定义变量 <code>use-file-dialog</code> 来禁用文件选择窗口。若你已通过变量 <code>use-dialog-box</code> 禁用了所有对话框，此变量将不再生效。
</p>

<p>
当 Emacs 编译时启用了 GTK+ 支持，其会调用 GTK+ 文件选择对话框。Emacs 为该对话框新增了一个切换按钮，可通过此按钮在对话框中显示或隐藏隐藏文件（以 <code>.</code> 句点开头的文件）。若希望该切换按钮默认处于启用状态，可将变量 <code>x-gtk-show-hidden-files</code> 设为 <code>t</code> 。此外，Emacs 还为 GTK+ 文件选择对话框添加了帮助文本；若要禁用该帮助文本，可将变量 <code>x-gtk-file-dialog-help-text</code> 设为 <code>nil</code> 。
</p>
</div>
</div>
<div id="outline-container-Tooltips" class="outline-3">
<h3 id="Tooltips"><span class="section-number-3">23.19.</span> 工具提示</h3>
<div class="outline-text-3" id="text-Tooltips">
<p>
<code>Tooltips工具提示</code> 是一类小型专用框架，会在当前鼠标位置显示文本信息。当鼠标在窗口中的重要文本区域、模式行，或是 Emacs 框架的其他区域（如工具栏按钮、菜单项）上停留不动时，工具提示便会激活。
</p>

<p>
可通过命令 <code>M-x tooltip-mode</code> 切换工具提示的启用状态。禁用工具提示模式后，帮助文本将转而在回显区显示。若要控制启动时工具提示的启用状态，可自定义变量 <code>tooltip-mode</code> 。
</p>

<p>
以下变量为工具提示的显示提供了自定义选项：
</p>
<dl class="org-dl">
<dt><code>tooltip-delay</code></dt><dd>该变量指定 Emacs 在显示第一个工具提示前的等待时长，取值单位为秒。</dd>
<dt><code>tooltip-short-delay</code></dt><dd>该变量指定 Emacs 在已显示第一个工具提示后，为不同项目显示后续工具提示前的等待时长，取值单位为秒。</dd>
<dt><code>tooltip-hide-delay</code></dt><dd>若鼠标保持不动，工具提示从显示到自动隐藏的间隔时长，取值单位为秒。</dd>
<dt><code>tooltip-x-offset</code></dt><dd></dd>

<dt><code>tooltip-y-offset</code></dt><dd>工具提示的左上角相对于鼠标指针位置的水平、垂直偏移量，取值单位为像素。注意，若 <code>tooltip-frame-parameters</code> 被自定义为分别包含 <code>left</code> 和 <code>top</code> 参数，这两个偏移量变量将被忽略。选择偏移量数值时，应确保工具提示不会遮挡鼠标指针的热点区域，否则可能干扰鼠标的点击操作。</dd>
<dt><code>tooltip-frame-parameters</code></dt><dd>用于显示工具提示的框架参数。详见《Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Frame-Parameters.html#Frame-Parameters">框架参数</a>」章节，以及该手册中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Tooltips.html#Tooltips">工具提示</a>」章节。</dd>
</dl>

<p>
若需更多工具提示的显示自定义选项，可执行 <code>M-x customize-group RET tooltip RET</code> 进行配置。
</p>

<p>
当 Emacs 基于 GTK+ 工具包、Nextstep 窗口系统或 Haiku 窗口系统编译构建时，会通过对应工具包显示工具提示，并沿用工具包自身工具提示的默认外观 <sup><a id="fnr.8" class="footref" href="#fn.8" role="doc-backlink">8</a></sup>。若要禁用此功能，可将变量 <code>use-system-tooltips</code> 设为 <code>nil</code> 。禁用后，或当 Emacs 编译时未加入相应的窗口系统支持时，工具提示文本的大部分显示属性将由 <code>tooltip</code> 面版，以及 X 资源进行指定（参见<a href="#X-Resources">X 选项与资源</a>）。
</p>

<p>
GUD 工具提示是一类特殊的工具提示，在使用 GUD 调试程序时，会显示变量的取值。详见<a href="#Debugger-Operation">调试器操作</a>。
</p>
</div>
</div>
<div id="outline-container-Mouse-Avoidance" class="outline-3">
<h3 id="Mouse-Avoidance"><span class="section-number-3">23.20.</span> 鼠标避让功能</h3>
<div class="outline-text-3" id="text-Mouse-Avoidance">
<p>
在图形化终端中，鼠标指针可能会遮挡 Emacs 框架内的文本内容。Emacs 提供了两种方法来解决这一问题。
</p>

<p>
第一种，当鼠标指针位于 Emacs 框架内时，你每输入一个自插入字符，Emacs 就会自动隐藏鼠标指针；移动鼠标指针则会使其重新显示。若要禁用该功能，将变量 <code>make-pointer-invisible</code> 设为 <code>nil</code> 即可，详见「<a href="#Display-Custom">显示的自定义</a>」章节。
</p>

<p>
第二种，你可以启用鼠标避让模式（一款辅助模式），让鼠标指针远离光标位置。启用该模式需自定义变量 <code>mouse-avoidance-mode</code> ，可为其设置不同取值，以多种方式移动鼠标指针：
</p>
<dl class="org-dl">
<dt><code>banish</code></dt><dd>（归位）按下任意按键时，将鼠标指针移至框架的角落。可通过自定义变量 <code>mouse-avoidance-banish-position</code> ，指定指针归位的目标位置。</dd>
<dt><code>exil</code></dt><dd>（暂移）仅当光标过于靠近指针时才将其归位，待光标移开后，允许指针回到原位置。</dd>
<dt><code>jum</code></dt><dd>（跃移）若光标过分靠近指针，将指针向随机方向移动一段随机距离。</dd>
<dt><code>animat</code></dt><dd>（动移）功能与跃移一致，只是会通过分步移动的效果营造出指针的动态移动观感。</dd>
<dt><code>cat-and-mous</code></dt><dd>（猫鼠式）与动移模式功能完全相同。</dd>
<dt><code>proteu</code></dt><dd>（变形移）在动移模式的基础上，还会同时改变鼠标指针的形状。</dd>
</dl>

<p>
你也可通过执行命令 <code>M-x mouse-avoidance-mode</code> 启用该模式。每当鼠标避让模式移动鼠标指针时，对应的 Emacs 框架也会被置于顶层显示。
</p>
</div>
</div>
<div id="outline-container-Text-Terminals" class="outline-3">
<h3 id="Text-Terminals"><span class="section-number-3">23.21.</span> 文本终端</h3>
<div class="outline-text-3" id="text-Text-Terminals">
<p>
在文本终端中，Emacs 同一时间仅能显示一个 Emacs 框架，但你仍可创建多个 Emacs 框架并在其中切换。此类终端上的框架切换，与不同窗口配置间的切换方式十分相似。
</p>

<p>
使用快捷键 <code>C-x 5 2</code> 创建新框架并切换至该框架；使用 <code>C-x 5 o</code> 循环切换所有已存在的框架；使用 <code>C-x 5 0</code> 删除当前框架。
</p>

<p>
每个框架都有专属编号用于区分。若你的终端同一时间仅能显示一个框架，当前选中框架的编号 <code>n</code> 会以 '<code>Fn</code>' 的形式显示在模式行的开头位置。
</p>

<p>
'<code>Fn</code>' 实际上是框架的初始名称。你可根据需要为框架设置更具意义的名称，也可通过名称选中对应框架。使用命令 <code>M-x set-frame-name RET name RET</code> ，可为当前选中的框架指定新名称；使用命令 <code>M-x select-frame-by-name RET name RET</code> ，可根据名称选中对应框架。当某一框架被选中时，你为其设置的名称会显示在模式行中。
</p>
</div>
</div>
<div id="outline-container-Text_002dOnly-Mouse" class="outline-3">
<h3 id="Text_002dOnly-Mouse"><span class="section-number-3">23.22.</span> 文本终端中的鼠标使用</h3>
<div class="outline-text-3" id="text-Text_002dOnly-Mouse">
<p>
部分文本终端支持在终端窗口内进行鼠标点击操作。
</p>

<p>
在兼容 <code>xterm</code> 的终端模拟器中，可使用 <code>M-x xterm-mouse-mode</code> 命令让 Emacs 接管鼠标的基础使用功能 —— 该模式下基本仅支持无修饰键的单次点击操作。新版本的 <code>xterm</code> 还支持鼠标追踪功能。若需使用 <code>xterm</code> 针对此类点击的原生鼠标功能，可在按下鼠标按键的同时按住 <code>SHIFT</code> 键。Xterm 鼠标模式为全局次要模式（参见「<a href="#Minor-Modes">次要模式</a>」相关内容），重复执行该命令即可关闭此模式。
</p>

<p>
在 GNU/Linux 的控制台中，可使用 <code>M-x gpm-mouse-mode</code> 命令启用鼠标支持功能。使用该功能前，你的系统中必须已安装并运行 <code>gpm</code> 服务端程序。请注意，启用此模式后，无法通过鼠标在 Emacs 与其他使用 GPM 的程序之间传输文本，这是由 GPM 和 Linux 内核的功能限制导致的。
</p>

<p>
有关 MS-DOS 系统下的鼠标支持相关信息，参见「<a href="#MS_002dDOS-Mouse">MS-DOS 下的鼠标使用</a>」章节。
</p>
</div>
</div>
</section>
<section id="outline-container-International" class="outline-2">
<h2 id="International"><span class="section-number-2">24.</span> 国际字符集支持</h2>
<div class="outline-text-2" id="text-International">
<p>
Emacs 支持多种国际字符集，包括拉丁语系的欧洲变体、越南变体，同时支持阿拉伯文字、婆罗米系文字（适用于孟加拉语、印地语、泰语等语言）、西里尔文字、埃塞俄比亚文字、格鲁吉亚文字、希腊文字、汉字（适用于中、日两国语言）、韩文、希伯来文字以及国际音标字符。Emacs 还支持这些字符的各类编码方式，这类编码也被文字处理软件、邮件客户端等其他国际化软件所采用。
</p>

<p>
Emacs 通过对所有相关操作提供支持，实现带国际字符文本的编辑功能，具体包括：
</p>

<ol class="org-ol">
<li>可打开含非 ASCII 字符的文件、保存非 ASCII 文本，也可在 Emacs 与其调用的程序（如编译器、拼写检查器、邮件客户端）之间传递非 ASCII 文本。设置语言环境（参见「<a href="#Language-Environments">语言环境</a>」）可自动为特定语言或文化配置编码体系及其他相关选项；你也可单独为每个命令指定 Emacs 对文本的编码与解码方式（参见「<a href="#Text-Coding">为文件文本指定编码体系</a>」）。</li>

<li>可显示各类文字编码的非 ASCII 字符。在图形化显示界面中，该功能通过调用适配字体实现（参见「<a href="#Defining-Fontsets">定义字体集</a>」）；在文本显示界面中，通过向终端发送特殊编码实现（参见「<a href="#Terminal-Coding">终端输入输出的编码体系</a>」）。若部分字符显示异常，可参考「<a href="#Undisplayable-Characters">无法显示的字符</a>」章节，其中介绍了可能出现的问题及对应的解决方法。</li>

<li>对于文字自然排版方向为从右至左的文字体系，Emacs 会对其字符重新排序后再显示（参见「<a href="#Bidirectional-Editing">双向编辑</a>」），这类文字包括阿拉伯文、希伯来文、叙利亚文、塔安那文等少数文字。</li>

<li><p>
可插入或搜索非 ASCII 字符。你可选择适配自身使用语言的 Emacs 输入方法（参见「<a href="#Select-Input-Method">选择输入方法</a>」），或使用选择语言环境时默认配置的输入方法；若你的键盘可输入非 ASCII 字符，可选择对应的键盘编码体系（参见「<a href="#Terminal-Coding">终端输入输出的编码体系</a>」），Emacs 将直接识别这些字符。在图形化显示界面中，现代系统通常会提供原生输入方法，同时也可通过 <code>C-x 8</code> 前缀输入 Latin-1 字符（参见「<a href="#Unibyte-Mode">单字节编辑模式</a>」）。
</p>

<p>
在 X 窗口系统中，需将系统区域设置为对应值，以确保 Emacs 正确解析键盘输入（参见「<a href="#Language-Environments">区域设置</a>」与「<a href="#X-Coding">X 键盘输入的编码体系</a>」）。
</p></li>
</ol>

<p>
本章后续内容将对上述问题展开详细说明。
</p>
<ul class="org-ul">
<li><a href="#International-Chars">国际字符集简介</a></li>
<li><a href="#Language-Environments">语言环境</a></li>
<li><a href="#Input-Methods">输入方法</a></li>
<li><a href="#Select-Input-Method">选择输入方法</a></li>
<li><a href="#Coding-Systems">编码系统</a></li>
<li><a href="#Recognize-Coding">编码系统识别</a></li>
<li><a href="#Specify-Coding">指定文件的编码系统</a></li>
<li><a href="#Output-Coding">为输出选择编码系统</a></li>
<li><a href="#Text-Coding">为文件文本指定编码系统</a></li>
<li><a href="#Communication-Coding">进程间通信的编码系统</a></li>
<li><a href="#File-Name-Coding">文件名的编码系统</a></li>
<li><a href="#X-Coding">X 键盘输入的编码系统</a></li>
<li><a href="#Terminal-Coding">终端 I/O 的编码系统</a></li>
<li><a href="#Fontsets">字体集</a></li>
<li><a href="#Defining-Fontsets">定义字体集</a></li>
<li><a href="#Modifying-Fontsets">修改字体集</a></li>
<li><a href="#Undisplayable-Characters">无法显示的字符</a></li>
<li><a href="#Unibyte-Mode">单字节编辑模式</a></li>
<li><a href="#Charsets">字符集</a></li>
<li><a href="#Bidirectional-Editing">双向编辑</a></li>
</ul>
</div>
<div id="outline-container-International-Chars" class="outline-3">
<h3 id="International-Chars"><span class="section-number-3">24.1.</span> 国际字符集简介</h3>
<div class="outline-text-3" id="text-International-Chars">
<p>
国际字符集与文字体系的使用者已制定了诸多标准化程度不一的编码系统，用于文件存储。这类编码系统通常为 <b>multibyte多字节编码</b> ，即使用两个或更多字节的序列来表示单个非 ASCII 字符。
</p>

<p>
Emacs 内部采用自研的多字节字符编码，该编码是 <b>Unicode 标准的超集</b> 。这种内部编码支持将几乎所有已知文字体系的字符混合在单个缓冲区或字符串中。Emacs 在读写文件、与子进程交换数据时，会在自身多字节字符编码与其他各类编码系统之间进行转换。
</p>

<p>
执行命令 <code>C-h h</code> (<code>view-hello-file</code>) 可打开 <code>etc/HELLO</code> 文件，该文件通过展示多种语言的 “hello” 表达，直观呈现了不同的文字体系。若你的终端无法显示部分字符，这些字符会以 '<code>?</code>' 或空心方块形式呈现（参见《<a href="#Undisplayable-Characters">无法显示的字符</a>》）。
</p>

<p>
即便在使用这些字符集的国家，键盘通常也不会为所有字符配备独立按键。你可使用 <code>C-x 8 RET</code> (<code>insert-char</code>) 插入键盘不支持的字符（参见《<a href="#Inserting-Text">插入文本</a>》）。部分常用字符配有快捷输入方式：例如，输入 <code>C-x 8 [</code> 可插入左单引号 <code>‘</code> ；若启用智能引号模式，通常直接按 <code>`</code> 键即可输入。（参见《<a href="#Quotation-Marks">引号</a>》）。Emacs 还支持多种输入法，通常一种文字体系 / 语言对应一种输入法，可简化对应字符的输入操作（参见《<a href="#Input-Methods">输入法</a>》）。
</p>

<p>
前缀键 <code>C-x RET</code> 用于调用与多字节字符、编码系统和输入法相关的命令。
</p>

<p>
命令 <code>C-x =</code> (<code>what-cursor-position</code>) 可显示光标所在位置字符的相关信息。除了《<a href="#Position-Info">光标位置信息</a>》中介绍的字符位置外，该命令还会展示字符的编码方式。例如，对于字符 '<code>c</code>' ，该命令会在回显区显示以下内容：
</p>

<div class="org-src-container">
<pre class="src src-shell">Char: c (99, <span style="color: #b22222;">#</span><span style="color: #b22222;">o143, #x63) point=28062 of 36168 (78%) column=53</span>
</pre>
</div>

<p>
'Char:' 后的四个值用于描述光标后方的字符，先显示字符本身，再依次给出其十进制、八进制和十六进制的字符编码。对于非 ASCII 多字节字符，若当前缓冲区的编码系统能对该字符进行 <b>单字节安全编码</b> ，则会在后续显示 '<code>file</code>' 及该字符在该编码系统中的十六进制表示（参见《<a href="#Coding-Systems">编码系统</a>》）；若字符的编码长度超过一个字节，Emacs 会显示 'file &#x2026;' 。
</p>

<p>
在极少数情况下，Emacs 会遇到 <b>raw bytes原始字节</b> ：即值在 128（八进制 0200）至 255（八进制 0377）范围内的单字节，Emacs 无法将其解析为某类已知非 ASCII 字符编码的一部分。这类原始字节会被归为特殊的 <b>八位字符集</b> ，Emacs 会将其以转义八进制码形式显示（该方式可自定义，参见《<a href="#Display-Custom">显示的自定义</a>》）。这种情况下， <code>C-x =</code> 会显示原始字节而非文件。此外，Emacs 会将原始字节的字符编码映射至 <code>#x3FFF80~#x3FFFFF</code> 区间并展示，以此与 <code>#x0080~#x00FF</code> 区间的 Unicode 字符区分开。
</p>

<p>
若为该命令添加前缀参数（ <code>C-u C-x =</code> ），会额外调用 <code>describe-char</code> 命令，展示该字符的详细描述信息，包括：
</p>

<ul class="org-ul">
<li>字符集名称，以及该字符在对应字符集中的编码；ASCII 字符归属于 ascii 字符集。</li>
<li>字符所属的文字体系、语法类型和分类。</li>
<li>在当前输入法中输入该字符的按键组合（若当前输入法支持该字符）。</li>
<li>字符的编码方式，包括在缓冲区中的内部编码，以及将缓冲区保存为文件时的外部编码。</li>
<li>若在图形界面运行 Emacs，会显示该字符对应的字体名称和字形编码；若在文本终端运行 Emacs，会显示发送至终端的编码。</li>
<li>若该字符在显示时与后续字符组合形成一个或多个 <b>grapheme cluster字素簇</b> ，会展示组合信息：图形界面下为对应字体字形，以及参与组合的所有字符。</li>
<li>字符的文本属性（参见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Text-Properties.html#Text-Properties">文本属性</a>》），包括用于显示该字符的所有非默认面，以及包含该字符的所有覆盖层（参见同一手册中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Overlays.html#Overlays">覆盖层</a>》）。</li>
</ul>

<p>
以下是详细描述的示例（部分行做折行处理以适配手册排版）：
</p>

<div class="org-src-container">
<pre class="src src-shell">             position: 1 of 1 (0%), column: 0                           <span style="color: #b22222;"># </span><span style="color: #b22222;">&#20301;&#32622;
</span>            character: &#234; (displayed as &#234;) (codepoint 234, <span style="color: #b22222;">#</span><span style="color: #b22222;">o352, #xea)  # &#23383;&#31526;&#12290;&#26174;&#31034;&#12289;&#32534;&#30721;&#28857;&#12289;&#20843;&#36827;&#21046;&#12289;&#21313;&#20845;&#36827;&#21046;
</span>    preferred charset: unicode (Unicode (ISO10646))                     <span style="color: #b22222;"># </span><span style="color: #b22222;">&#39318;&#36873;&#23383;&#31526;&#38598;
</span>code point<span style="color: #a020f0;"> in</span> charset: 0xEA                                             <span style="color: #b22222;"># </span><span style="color: #b22222;">&#23383;&#31526;&#38598;&#20869;&#32534;&#30721;&#28857;
</span>               script: latin                                            <span style="color: #b22222;"># </span><span style="color: #b22222;">&#25991;&#23383;&#20307;&#31995;
</span>               syntax: w        which means: word                       <span style="color: #b22222;"># </span><span style="color: #b22222;">&#35821;&#27861;&#31867;&#22411;&#12290;w &#34920;&#31034;&#65306;&#21333;&#35789;&#23383;&#31526;
</span>             category: .:Base, L:Left-to-right (strong), c:Chinese,
                       j:Japanese, l:Latin, v:Viet                      <span style="color: #b22222;"># </span><span style="color: #b22222;">&#23383;&#31526;&#20998;&#31867;&#12290;&#22522;&#30784;&#23383;&#31526;&#65292;L:&#20174;&#24038;&#21040;&#21491;&#65288;&#24378;&#65289;&#65292;c:&#20013;&#25991;
</span>             to input: type <span style="color: #8b2252;">"C-x 8 RET ea"</span> or
                       <span style="color: #8b2252;">"C-x 8 RET LATIN SMALL LETTER E WITH CIRCUMFLEX"</span> <span style="color: #b22222;"># </span><span style="color: #b22222;">&#36755;&#20837;&#26041;&#24335;&#12290;C-x 8 RET ea
</span>          buffer code: <span style="color: #b22222;">#</span><span style="color: #b22222;">xC3 #xAA                                        # &#32531;&#20914;&#21306;&#32534;&#30721;
</span>            file code: <span style="color: #b22222;">#</span><span style="color: #b22222;">xC3 #xAA (encoded by coding system utf-8-unix)  # &#25991;&#20214;&#32534;&#30721;
</span>              display: by this font (glyph code)                        <span style="color: #b22222;"># </span><span style="color: #b22222;">&#26174;&#31034;&#26041;&#24335;&#12290;&#20351;&#29992;&#20197;&#19979;&#23383;&#20307;&#65288;&#23383;&#24418;&#32534;&#30721;&#65289;
</span>    xft:-PfEd-DejaVu Sans Mono-normal-normal-
        normal-*-15-*-*-*-m-0-iso10646-1 (<span style="color: #b22222;">#</span><span style="color: #b22222;">xAC)
</span>
Character code properties: customize what to show                       <span style="color: #b22222;"># </span><span style="color: #b22222;">&#23383;&#31526;&#32534;&#30721;&#23646;&#24615;&#65306;&#21487;&#33258;&#23450;&#20041;&#23637;&#31034;&#20869;&#23481;
</span>  name: LATIN SMALL LETTER E WITH CIRCUMFLEX                              <span style="color: #b22222;"># </span><span style="color: #b22222;">&#21517;&#31216;
</span>  old-name: LATIN SMALL LETTER E CIRCUMFLEX                               <span style="color: #b22222;"># </span><span style="color: #b22222;">&#26087;&#21517;&#31216;
</span>  general-category: Ll (Letter, Lowercase)                                <span style="color: #b22222;"># </span><span style="color: #b22222;">&#36890;&#29992;&#20998;&#31867;
</span>  decomposition: (101 770) (<span style="color: #8b2252;">'e'</span> <span style="color: #8b2252;">'^'</span>)                                      <span style="color: #b22222;"># </span><span style="color: #b22222;">&#23383;&#31526;&#20998;&#35299;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-Language-Environments" class="outline-3">
<h3 id="Language-Environments"><span class="section-number-3">24.2.</span> 语言环境</h3>
<div class="outline-text-3" id="text-Language-Environments">
<p>
只要启用了多字节字符功能，Emacs 缓冲区就支持所有受兼容的字符集，无需为显示某类字符专门选择对应的语言。但选择 <code>language environment语言环境</code> 对配置各类默认项至关重要，简单来说，语言环境选择的是 <b>首选文字体系</b> ，而非具体的语言。
</p>

<p>
语言环境会控制 Emacs 读取文本时识别的编码体系（参见「<a href="#Recognize-Coding">识别编码体系</a>」），该规则适用于文件、接收的邮件及所有读入 Emacs 的文本，也可指定新建文件时使用的默认编码体系。每种语言环境还会对应一个默认的输入方法。
</p>

<p>
<b>选择语言环境</b>
</p>

<p>
可通过自定义变量 <code>current-language-environment</code> ，或使用命令 <code>M-x set-language-environment</code> 选择语言环境。执行该命令时当前处于哪个缓冲区不产生影响，因为其效果会全局作用于整个 Emacs 会话。受支持的语言环境列表可查看变量 <code>language-info-alist</code> ；若需了解某一语言环境 <i><code>lang-env</code></i> 的详细信息，可使用命令 <code>C-h L</code> <i><code>lang-env</code></i> <code>RET</code> (<code>describe-language-environment</code>) 。
</p>

<p>
Emacs 支持的语言环境包括：
</p>

<blockquote>
<p>
ASCII, Arabic, Belarusian, Bengali, Brazilian Portuguese, Bulgarian, Burmese, Cham, Chinese-BIG5, Chinese-CNS, Chinese-EUC-TW, Chinese-GB, Chinese-GB18030, Chinese-GBK, Croatian, Cyrillic-ALT, Cyrillic-ISO, Cyrillic-KOI8, Czech, Devanagari, Dutch, English, Esperanto, Ethiopic, French, Georgian, German, Greek, Gujarati, Hebrew, IPA, Italian, Japanese, Kannada, Khmer, Korean, Lao, Latin-1, Latin-2, Latin-3, Latin-4, Latin-5, Latin-6, Latin-7, Latin-8, Latin-9, Latvian, Lithuanian, Malayalam, Oriya, Persian, Polish, Punjabi, Romanian, Russian, Sinhala, Slovak, Slovenian, Spanish, Swedish, TaiViet, Tajik, Tamil, Telugu, Thai, Tibetan, Turkish, UTF-8, Ukrainian, Vietnamese, Welsh, and Windows-1255.
</p>
</blockquote>
<blockquote>
<p>
ASCII、阿拉伯语、白俄罗斯语、孟加拉语、巴西葡萄牙语、保加利亚语、缅甸语、占语、中文 - 大五码、中文 - 万国码、中文 - 欧盟扩展码繁体、中文 - 国标码、中文 - 国标 18030、中文 - 国标扩展码、克罗地亚语、西里尔文 - 替代码、西里尔文 - 国际标准码、西里尔文 - KOI8 码、捷克语、天城文、荷兰语、英语、世界语、埃塞俄比亚语、法语、格鲁吉亚语、德语、希腊语、古吉拉特语、希伯来语、国际音标、意大利语、日语、卡纳达语、高棉语、韩语、老挝语、拉丁语 - 1、拉丁语 - 2、拉丁语 - 3、拉丁语 - 4、拉丁语 - 5、拉丁语 - 6、拉丁语 - 7、拉丁语 - 8、拉丁语 - 9、拉脱维亚语、立陶宛语、马拉雅拉姆语、奥里亚语、波斯语、波兰语、旁遮普语、罗马尼亚语、俄语、僧伽罗语、斯洛伐克语、斯洛文尼亚语、西班牙语、瑞典语、泰越语、塔吉克语、泰米尔语、泰卢固语、泰语、藏语、土耳其语、通用多八位编码字符集、乌克兰语、越南语、威尔士语、视窗 1255 编码。
</p>
</blockquote>

<p>
在图形化显示界面中，要显示所选语言环境对应的文字体系，需配备适配的字体，字体的配置细节参见「<a href="#Fontsets">字体集</a>」章节。
</p>

<p>
<b>与系统区域设置的关联</b>
</p>

<p>
部分操作系统可通过设置环境变量 <code>LC_ALL</code> 、 <code>LC_CTYPE</code> 或 <code>LANG</code> 指定使用的字符集区域设置（若多个变量均被设置，以首个非空变量的配置为准）。Emacs 启动时，会在系统区域设置别名表中查找当前字符集区域设置的名称，将其标准名称与变量 <code>locale-charset-language-names</code> 和 <code>locale-language-names</code> 的配置项匹配（前者优先级高于后者）；若匹配成功，会自动选择对应的语言环境，同时还会根据该区域设置，按需调整显示表、终端编码体系、区域设置编码体系、首选编码体系， <b>以及键盘发送的非 ASCII 字符的解析方式</b> （这一点尤为重要）。
</p>

<p>
若在 Emacs 运行过程中修改了 <code>LC_ALL</code> 、 <code>LC_CTYPE</code> 或 <code>LANG</code> 环境变量（可通过 <code>M-x setenv</code> 操作），可执行 <code>set-locale-environment</code> 命令，根据新的区域设置重新调整语言环境。
</p>

<p>
<code>set-locale-environment</code> 函数通常会使用语言环境指定的首选编码体系解析系统消息；但如果当前区域设置与变量 <code>locale-preferred-coding-systems</code> 中的配置项匹配，Emacs 会改用对应的编码体系。例如，若区域设置 <code>ja_JP.PCK</code> 与 <code>locale-preferred-coding-systems</code> 中的 <code>japanese-shift-jis</code> 匹配，即便默认编码为 UTF-8，Emacs 也会使用该编码。
</p>

<p>
你可通过显式执行 <code>set-language-environment</code> 命令，或在初始化文件中自定义 <code>current-language-environment</code> ，覆盖 Emacs 启动时自动选择的语言环境。
</p>

<p>
<b>查看语言环境信息</b>
</p>

<p>
要查看某一语言环境 <i><code>lang-env</code></i> 的生效配置，使用命令 <code>C-h L</code> <i>= lang-env=</i>  <code>RET</code> (<code>describe-language-environment</code>) 即可。该命令会说明该语言环境适用的语言，列出对应的字符集、编码体系和输入方法，还会展示示例文本以演示其支持的文字体系；若输入空值作为 <i><code>lang-env</code></i> ，则会描述当前已选中的语言环境。
</p>

<p>
<b>自定义语言环境</b>
</p>

<p>
可通过常规钩子 <code>set-language-environment-hook</code> 自定义任意语言环境， <code>set-language-environment</code> 命令在完成新语言环境的配置后，会执行该钩子。钩子函数可通过检查变量 <code>current-language-environment</code> 判断当前的具体语言环境，针对特定语言环境的非默认配置（如键盘输入和终端输出的编码体系、默认输入方法等），都应在该钩子中设置。
</p>

<p>
<code>set-language-environment</code> 命令在开始配置新语言环境前，会先执行钩子 <code>exit-language-environment-hook</code> ，该钩子可用于撤销通过 <code>set-language-environment-hook</code> 完成的自定义配置。例如，若你通过 <code>set-language-environment-hook</code> 为某一特定语言环境设置了特殊的按键绑定，就需要在 <code>exit-language-environment-hook</code> 中恢复该按键的默认绑定。
</p>
</div>
</div>
<div id="outline-container-Input-Methods" class="outline-3">
<h3 id="Input-Methods"><span class="section-number-3">24.3.</span> 输入方法</h3>
<div class="outline-text-3" id="text-Input-Methods">
<p>
<i>input method 输入方法</i> 是专为交互式输入设计的一类字符转换方式。本节介绍 Emacs 自带的输入方法；若需了解底层操作系统提供的原生输入方法，参见「<a href="#Unibyte-Mode">单字节编辑模式</a>」章节。
</p>

<p>
在 Emacs 中，通常一种语言对应一种专属输入方法；部分使用相同字符的语言可共用一个输入方法，也有少数语言支持多种输入方法。
</p>

<p>
输入方法的核心实现方式
</p>
<ul class="org-ul">
<li>简单映射：将 ASCII 字母映射为另一套字母体系，替代 ASCII 字符的输入，希腊语、俄语输入方法均采用此方式。</li>
<li>字符合成：将多个字符的序列转换为单个字符，是更常用的高级方式。许多欧洲语言的输入方法通过该方式，将「字母 + 重音符号」（或反之）的序列转换为单个带重音的非 ASCII 字母（例如部分方法可将 <code>o ^</code> 合成为单个带抑扬符的 o）。这类输入方法无专属命令，仅完成可打印字符序列的合成。</li>
<li>映射 + 合成：音节文字体系的输入方法通常采用此组合方式，泰语、韩语输入方法均是如此。先将按键映射为特定发音或声调符号，再将构成完整音节的符号序列映射为单个音节字符。</li>
</ul>

<p>
<b>中日文专属输入方法</b>
</p>

<p>
<b>中文输入方法</b>
</p>

<p>
中文输入方法需先输入汉字的拼音（如 <code>chinese-py</code> 拼音输入法），或字符的拆分部件（如 <code>chinese-4corner</code> 四角码、 <code>chinese-sw</code> 等）。一条输入序列通常对应多个候选汉字，需通过 <code>C-f</code> 、 <code>C-b</code> 、 <code>C-n</code> 、 <code>C-p</code> （或方向键）及数字键选择目标字符，这类按键在候选选择阶段会被赋予特殊含义。
</p>

<p>
候选汉字在逻辑上分为多行展示，每行最多显示 10 个候选。Emacs 通常在回显区一次仅显示一行，行首会标注 (i/j)，代表当前为第 <code>i</code> 行，共 <code>j</code> 行：
</p>

<ul class="org-ul">
<li>按 <code>C-n/C-p</code> 可上下切换候选行；</li>
<li>按 <code>C-f/C-b</code> 可在当前行中前后切换候选字符，选中的候选会以特殊颜色高亮，按 <code>C-SPC</code> 可选定该候选并插入到缓冲区；</li>
<li>候选字符旁会标注数字序号，直接按对应数字键可快速选定当前行的该候选。</li>
</ul>

<p>
在中文输入方法中按 <code>TAB</code> 键，会弹出一个独立缓冲区展示所有候选字符，点击 <code>mouse-2</code> 鼠标中键 可选定对应候选；此时 C-f、C-b、C-n、C-p 及数字键仍可正常使用，只是高亮效果会在候选缓冲区中显示，而非回显区。
</p>

<p>
若需按拼音声调输入，可使用 <code>chinese-sisheng</code> 四声输入法，该方法基于字符合成实现，例如输入 <code>pi1</code> 可得到带一声调的「pī」。
</p>

<p>
<b>日文输入方法</b>
</p>

<p>
日文输入方法需先通过拼音输入完整的单词，待单词字符进入缓冲区后，Emacs 会调用大型词典将其转换为一个或多个日文汉字 / 假名。一个拼音拼写通常对应多个日文单词，按 <code>C-n</code> / <code>C-p</code> 可循环切换候选词完成选择。
</p>

<p>
<b>终止字符合成的方法</b>
</p>

<p>
有时需要终止输入方法的字符合成处理，避免已输入的字符与后续字符组合（例如在 <code>latin-1-postfix</code> 输入方法中， <code>o ^</code> 会自动合成带重音的 'o' ，若需单独输入 'o' 和 '<code>^</code>' ，可通过以下方式实现）：
</p>
<ul class="org-ul">
<li>重复输入符号：将重音符号输入两次，是输入独立字母和符号的专属技巧，例如输入 <code>o ^ ^</code> 可得到两个独立字符 <code>o^</code> ；</li>
<li>插入无关字符再删除：在字母后输入一个无法与其合成的字符，再立即删除，例如输入 <code>o o DEL ^</code> 可得到独立的 <code>o</code> 和 <code>^</code> ；</li>
<li>通用快捷键：在两个字符之间按  <code>C-\ C-\</code> ，可强制终止合成，该方式通用性最强，只是操作稍繁琐；该操作是连续两次执行 <code>C-\</code> (<code>toggle-input-method</code>)。详见《<a href="#Select-Input-Method">选择输入方法</a>》章节。</li>
<li>增量搜索中使用： <code>C-\ C-\</code> 在增量搜索中尤为实用，可终止输入方法的等待合成状态，直接基于已输入的字符开始搜索。</li>
</ul>

<p>
<b>输入方法的辅助功能</b>
</p>

<ul class="org-ul">
<li>查询字符输入方式：按 <code>C-u C-x =</code> ，可查看当前输入方法下，光标所在位置字符的具体输入方式（参见「<a href="#Position-Info">光标位置信息</a>」章节）。</li>
<li>输入过程可视化配置：两个变量可控制输入方法的提示方式：
<ul class="org-ul">
<li><code>input-method-highlight-flag</code> ：非空时，缓冲区中会高亮显示未完成的合成字符序列（多数输入方法支持，少数会禁用此功能）；</li>
<li><code>input-method-verbose-flag</code> ：非空时，回显区会显示下一个可输入的候选字符列表（迷你缓冲区中除外）。</li>
</ul></li>
<li>自定义输入方法：可将自定义函数添加到钩子变量 <code>quail-activate-hook</code> ，修改输入方法的工作方式（参见「<a href="#Hooks">钩子</a>」章节）。例如通过 <code>quail-translation-keymap</code> 函数获取输入方法的键映射表，再使用 <code>define-key</code> 重新定义部分按键的绑定（参见「<a href="#Init-Rebinding">在初始化文件中重新绑定按键</a>」章节）。</li>
<li>只读缓冲区的输入方法抑制：当缓冲区文本因某种原因设为只读时，输入方法会自动禁用。此举可确保在 <code>read-only-mode只读模式</code> 、 <code>image-mode 图片模式</code> 等将缓冲区（或部分区域）设为只读的模式中，单字符按键绑定能正常生效，即便输入方法处于激活状态。</li>
</ul>

<p>
<b>其他字符输入方式</b>
</p>

<ul class="org-ul">
<li>按 Unicode 输入任意字符：若需输入键盘上无对应按键的字符，可使用 <code>C-x 8 RET</code> (<code>insert-char</code>) ，通过字符的 Unicode 名称或编码点插入单个字符（参见「<a href="#Inserting-Text">插入文本</a>」章节）。</li>
<li>Emoji 专属输入命令：Emacs 为 Emoji 字符提供了专属输入快捷键，所有相关命令均在 <code>C-x 8 e</code> 键映射表中：
<ul class="org-ul">
<li><code>C-x 8 e e</code> (<code>emoji-insert</code>) ：可浏览不同分类的 Emoji，选择后插入；</li>
<li><code>C-x 8 e l</code> (<code>emoji-list</code>) ：弹出新缓冲区列出所有 Emoji，点击或按回车可将选中的 Emoji 插入当前缓冲区；</li>
<li><code>C-x 8 e s</code> (<code>emoji-search</code>) ：根据名称搜索 Emoji 并插入。😘</li>
</ul></li>
<li>Emoji 信息查询： <code>describe-char</code> 命令可显示光标所在位置字符 / 字形的详细信息（包括 Emoji）；若仅需快速查询字符名称，可使用 <code>C-x 8 e d</code> (<code>emoji-describe</code>) 命令，该命令主要用于区分外观相似的 Emoji 变体，也可查询非 Emoji 字符的名称。</li>
</ul>
</div>
</div>
<div id="outline-container-Select-Input-Method" class="outline-3">
<h3 id="Select-Input-Method"><span class="section-number-3">24.4.</span> 选择输入方法</h3>
<div class="outline-text-3" id="text-Select-Input-Method">
<dl class="org-dl">
<dt><code>C-\</code></dt><dd>启用或关闭已选中的输入方法 (<code>toggle-input-method</code>) 。</dd>
<dt><code>C-x RET C-\ 输入法名 RET</code></dt><dd>为当前缓冲区选择新的输入方法  (<code>set-input-method</code>)  。</dd>
<dt><code>C-x \ 输入法名 RET</code></dt><dd>临时启用选定的瞬时输入方法；插入单个字符后，该输入法会自动关闭 (<code>activate-transient-input-method</code>) 。</dd>
<dt><code>C-h I 输入法名 RET</code></dt><dd></dd>

<dt><code>C-h C-\ 输入法名 RET</code></dt><dd>描述指定的输入方法 (<code>describe-input-method</code>) 。默认情况下，该命令会描述当前启用的输入方法（若存在），描述内容会详细说明该输入法的完整使用方法。</dd>
<dt><code>M-x list-input-methods</code></dt><dd>列出所有受支持的输入方法。</dd>
</dl>

<p>
为当前缓冲区选择输入方法可使用 <code>C-x RET C-\</code> (<code>set-input-method</code>) ，该命令会从迷你缓冲区读取输入法名称，名称通常以其适用的语言环境开头。变量 <code>current-input-method</code> 会记录当前选中的输入方法。
</p>

<p>
输入方法会通过各类 ASCII 字符序列来表示非 ASCII 字符，有时需要临时关闭输入方法，按下 <code>C-\</code> (<code>toggle-input-method</code>) 即可；再次按下该快捷键，可重新启用输入方法。
</p>

<p>
若 <b>首次</b> 按下 <code>C-\</code> 时尚未选择任何输入方法，Emacs 会提示你指定一个，该操作与使用 <code>C-x RET C-\</code> 指定输入法的效果一致。
</p>

<p>
带数字参数执行该命令时（如 <code>C-u C-\</code> ）， <code>toggle-input-method</code> 总会提示你选择输入方法，并将最近一次选中的输入法作为默认选项推荐。
</p>

<p>
选择语言环境时，会为各缓冲区指定一个默认输入方法。若存在默认输入方法，按下 <code>C-\</code> 即可在当前缓冲区启用它。变量 <code>default-input-method</code> 用于指定默认输入方法（值为 <code>nil</code> 表示无默认输入法）。
</p>

<p>
部分语言环境支持多种输入方法，若你想使用与 <code>set-language-environment</code> 命令默认选择不同的输入法，可通过 <code>set-language-environment-hook</code> 钩子让 Emacs 为特定语言环境选择自定义的默认输入方法（参见<a href="#Language-Environments">set-language-environment-hook</a>相关说明）。示例如下：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">my-chinese-setup</span> ()
  <span style="color: #8b2252;">"Set up my private Chinese environment."</span>
  (<span style="color: #a020f0;">if</span> (equal current-language-environment <span style="color: #8b2252;">"Chinese-GB"</span>)
      (<span style="color: #a020f0;">setq</span> default-input-method <span style="color: #8b2252;">"chinese-tonepy"</span>)))
(add-hook 'set-language-environment-hook 'my-chinese-setup)
</pre>
</div>

<p>
上述代码的作用是：当你选择「Chinese-GB（中文 - 国标码）」语言环境时，将默认输入方法设为带声调的拼音输入法 <code>chinese-tonepy</code> 。
</p>

<p>
你也可让 Emacs 自动激活指定的输入方法，示例如下：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'text-mode-hook
  (<span style="color: #a020f0;">lambda</span> () (set-input-method <span style="color: #8b2252;">"german-prefix"</span>)))
</pre>
</div>

<p>
该代码会在文本模式（Text mode）下，自动激活德语前缀输入法german-prefix。
</p>

<p>
部分字母文字的输入方法，本质是通过重新映射键盘，模拟该文字体系常用的各类键盘布局。键盘的正确映射方式取决于你的实际键盘布局，可使用命令 <code>M-x quail-set-keyboard-layout</code> 指定当前的键盘布局。
</p>

<p>
使用 <code>M-x quail-show-key</code> 命令，可查看在选定的键盘布局下，输入光标后该字符所需按下的按键（或按键序列）。 <code>C-u C-x =</code> 命令除了显示该字符的其他相关信息外，也会展示这一输入方式。
</p>

<p>
<code>M-x list-input-methods</code> 会列出所有受支持的输入方法，该列表会展示每种输入法的相关信息，包括其在 <code>mode line模式行</code> 中对应的显示标识。
</p>

<p>
有时需要临时启用输入方法仅插入单个字符，这种场景下使用瞬时输入方法会更为便捷。按下 <code>C-x \</code> (<code>activate-transient-input-method</code>) 可临时启用输入方法，按该输入法规则插入单个字符后，输入法会自动关闭。若尚未选定瞬时输入方法， <code>C-x \</code> 会提示你指定一个；后续再次执行该命令，会直接启用已选定的瞬时输入方法。若要更换瞬时输入方法，可按下 <code>C-u C-x \</code> ，你选定的瞬时输入方法可与通过 <code>C-u C-\</code> 选择的常规输入方法不同。
</p>
</div>
</div>
<div id="outline-container-Coding-Systems" class="outline-3">
<h3 id="Coding-Systems"><span class="section-number-3">24.5.</span> 编码系统</h3>
<div class="outline-text-3" id="text-Coding-Systems">
<p>
不同语言的使用者已制定出多种标准化程度各异的编码系统，用于表示各自的语言字符。Emacs 内部并不直接使用这些编码系统，而是在 <b>读取数据</b> 时将各类编码系统转换为自身的内部编码，在 <b>写入数据</b> 时再将内部编码转换为其他编码系统。该转换功能可应用于文件的读写、终端的数据收发，以及与子进程间的数据交换场景。
</p>

<p>
Emacs 为每种编码系统分配了专属名称。多数编码系统仅适用于单一语言，其名称以对应语言名开头；部分编码系统可支持多种语言，这类编码系统的名称通常以 '<code>iso</code>' 开头。此外还有一些特殊编码系统，例如 <code>no-conversion</code> （无转换）、 <code>raw-text</code> （原始文本）和 <code>emacs-internal</code> （Emacs 内部编码）。
</p>

<p>
有一类特殊的编码系统被统称为 <b>代码页</b> （codepages），专为兼容微软视窗（MS-Windows）和微软磁盘操作系统（MS-DOS）软件的文本编码而设计。这类编码系统的名称格式为 <code>cpnnnn</code> ，其中 <code>nnnn</code> 为 3 位或 4 位的代码页编号。你可像使用其他编码系统一样使用这类编码，例如，要打开以代码页 850 编码的文件，可键入快捷键： <code>C-x RET c cp850 RET C-x C-f 文件名 RET</code> 。
</p>

<p>
编码系统除了能对非 ASCII 字符的各类表示形式进行转换外，还可执行 <b>行尾转换</b> 。Emacs 支持处理文件中行分隔符的三种主流规范：换行符（Newline，类 Unix 系统）、回车符后接换行符（Carriage Return + Linefeed，DOS 系统），以及仅使用回车符（Carriage Return，传统 Mac 系统）。
</p>

<p>
<b>相关操作命令</b>
</p>

<dl class="org-dl">
<dt><code>C-h C 编码系统名 RET</code></dt><dd>描述指定编码系统的详细信息 (<code>describe-coding-system</code>) 。</dd>
<dt><code>C-h C RET</code></dt><dd>描述当前正在使用的所有编码系统 (<code>describe-coding-system</code>) 。</dd>
<dt><code>M-x list-coding-systems</code></dt><dd>显示 Emacs 支持的所有编码系统列表。</dd>
</dl>

<p>
命令 <code>C-h C</code> (<code>describe-coding-system</code>) 可展示特定编码系统的相关信息，包括该编码系统指定的行尾转换规则。执行该命令时，你可传入编码系统名作为参数；若留空参数，该命令会描述当前缓冲区及系统默认中，为各类用途选定的编码系统，同时还会展示编码系统的识别优先级列表（参见《<a href="#Recognize-Coding">编码系统的识别</a>》章节）。
</p>

<p>
键入 <code>M-x list-coding-systems</code> 可查看 Emacs 支持的全部编码系统列表，该列表会展示每种编码系统的相关信息，包括其在模式行中对应的标识字符（参见《<a href="#Mode-Line">模式行</a>》章节）。
</p>

<p>
此列表中的所有编码系统（ <b>无转换编码no-conversion除外</b> ，该编码表示不执行任何形式的转换），均会明确可打印字符的转换方式与是否转换，但行尾转换的具体规则会根据每个文件的内容自动判定。例如，若检测到文件使用回车符 + 换行符作为行分隔符，Emacs 会自动采用 DOS 系统的行尾转换规则。
</p>

<p>
列表中的每种编码系统都包含三种 <b>变体</b> ，用于明确指定行尾转换的具体方式：
</p>
<dl class="org-dl">
<dt><code>…-unix</code></dt><dd>不执行任何行尾转换，假定文件使用换行符作为行分隔符（该规范为类 Unix 系统、GNU 系统及 macOS 系统的默认规范）。</dd>
<dt><code>…-dos</code></dt><dd>假定文件使用回车符 + 换行符作为行分隔符，并执行对应的行尾转换（该规范为微软系统的默认规范 <sup><a id="fnr.9" class="footref" href="#fn.9" role="doc-backlink">9</a></sup>）。</dd>
<dt><code>…-mac</code></dt><dd>假定文件仅使用回车符作为行分隔符，并执行对应的行尾转换（该规范为经典 Mac OS 系统的默认规范，目前仅在部分遗留软件中使用）。</dd>
</dl>

<p>
为简化显示， <code>list-coding-systems</code> 命令的输出结果中会省略上述变体编码系统，因其命名规则完全可推导。例如，编码系统 <code>iso-latin-1</code> 包含 <code>iso-latin-1-unix</code> 、 <code>iso-latin-1-dos</code> 和 <code>iso-latin-1-mac</code> 三种变体。
</p>

<p>
编码系统unix、dos和mac分别是 <code>undecided-unix</code> 、 <code>undecided-dos</code> 和 <code>undecided-mac</code> 的别名。这类编码系统 <b>仅指定行尾转换规则</b> ，字符编码的转换方式则由文本内容自行推导。
</p>

<p>
<b>原始文本编码raw-text</b> 适用于以 ASCII 文本为主、但可能包含值大于 127 的字节（且这些字节并非用于编码非 ASCII 字符）的文件。使用该编码时，Emacs 会原样复制这些字节值，并将当前缓冲区的变量 <code>enable-multibyte-characters</code> 设为 <code>nil</code> ，以保证这些字节被正确解析。 <code>raw-text</code> 会根据检测到的数据，以常规方式处理行尾转换，同时也包含上述三种标准变体，用于指定行尾转换的具体类型。
</p>

<p>
与之相对，无转换编码 <code>no-conversion</code> 表示不执行任何字符编码转换 —— 既不转换非 ASCII 字节值，也不执行行尾转换。该编码适用于读写二进制文件、tar 归档文件及其他需要逐字原样解析的文件，同时它也会将变量 <code>enable-multibyte-characters</code> 设为 <code>nil</code> 。
</p>

<p>
以 <b>无任何转换</b> 的方式编辑文件的最简方法，是使用 <code>M-x find-file-literally</code> 命令。该命令会采用no-conversion编码，同时还会禁用 Emacs 中其他可能在你查看文件前修改其内容的功能（参见《<a href="#Visiting">打开文件</a>》章节）。
</p>

<p>
Emacs 内部编码 <code>emacs-internal</code> （与其等效的 <code>utf-8-emacs</code> 同理），表示文件中的非 ASCII 字符以 Emacs 的内部编码格式存储。该编码系统会根据检测到的数据处理行尾转换，同时也包含上述三种标准变体，用于指定行尾转换的具体类型。
</p>
</div>
</div>
<div id="outline-container-Recognize-Coding" class="outline-3">
<h3 id="Recognize-Coding"><span class="section-number-3">24.6.</span> 编码系统识别</h3>
<div class="outline-text-3" id="text-Recognize-Coding">
<p>
Emacs 在读取任意文本内容时，都会尝试识别其应使用的编码系统，该过程适用于读取文件、子进程输出、X 窗口系统选择的文本等各类场景。 <b>只要你设定好偏好配置</b> ，Emacs 大多时候能自动选中正确的编码系统。
</p>

<p>
部分编码系统可通过数据中出现的字节序列来识别或区分，但也有一些编码系统，即便在理论上也无法相互区分。例如，拉丁1（Latin-1）和拉丁2（Latin-2）编码就无法区分 —— 二者使用相同的字节值，仅代表的字符含义不同。
</p>

<p>
Emacs 通过 <b>编码系统优先级列表</b> 来处理上述情况。当你未指定文件的使用编码时，Emacs 读取文件会依次将数据与优先级列表中的编码系统进行匹配，从列表首位开始逐一向下检测，直至找到与数据匹配的编码系统，随后便会假定文件内容以该编码系统存储并完成转换。
</p>

<p>
编码系统的优先级列表由 <b>选定的语言环境</b> 决定（参见《<a href="#Language-Environments">语言环境</a>》章节）。例如，若你使用法语，大概率希望 Emacs 优先使用拉丁 1 而非拉丁 2；若使用捷克语，则大概率希望优先使用拉丁 2。这也是指定语言环境的原因之一。
</p>

<p>
你也可通过 <code>M-x prefer-coding-system</code> 命令，对编码系统优先级列表进行精细调整。该命令会从迷你缓冲区读取编码系统名称，并将其添加至优先级列表的头部，使其优先级高于所有其他编码。多次执行该命令时，每次都会在列表头部新增一个编码系统。
</p>

<p>
若你使用的编码系统指定了行尾转换类型（如 <code>iso-8859-1-dos</code> ），其含义为：Emacs 会优先尝试识别 <code>iso-8859-1</code> 编码，且在识别出该编码时，使用 DOS 格式的行尾转换规则。
</p>

<p>
有时 <b>文件名</b> 也可指示文件应使用的编码系统，变量 <code>file-coding-system-alist</code> 便定义了这种对应关系。Emacs 提供了专用函数 <code>modify-coding-system-alist</code> ，用于向该列表中添加配置项。例如，要将所有 '<code>.txt</code>' 文件的读写编码设为 <code>chinese-iso-8bit</code> ，可执行以下 Lisp 表达式：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(modify-coding-system-alist 'file <span style="color: #8b2252;">"\\.txt\\'"</span> 'chinese-iso-8bit)
</pre>
</div>

<p>
该函数的第一个参数固定为 <code>file</code> ，第二个参数为正则表达式，用于匹配该配置适用的文件，第三个参数则为这些文件要使用的编码系统。
</p>

<p>
Emacs 会根据 <b>文件内容</b> 识别应使用的行尾转换类型：若检测到文件仅使用回车符，或仅使用回车符加换行符的组合作为行分隔符，便会相应选择对应的行尾转换规则。你可将变量 <code>inhibit-eol-conversion</code> 设为非nil值，禁用行尾转换的自动识别功能。禁用后，DOS 格式的文件在缓冲区中会显示可见的 '<code>^M</code>' 字符；相较于模式行左侧边缘较为隐晦的 '(DOS)' 行尾类型标识（参见《<a href="#Mode-Line">行尾助记符</a>》章节），部分用户更偏好这种显示方式。
</p>

<p>
默认情况下，编码系统的自动检测会 <b>对转义序列敏感</b> 。若 Emacs 检测到以转义字符开头的字符序列，且该序列符合 ISO-2022 编码的规范，便会使用某一种 ISO-2022 编码对文件进行解码。
</p>

<p>
但在某些场景下，你可能希望 <b>原样读取</b> 文件中的转义序列，此时可将变量 <code>inhibit-iso-escape-detection</code> 设为非nil值。开启该设置后，编码检测会忽略所有转义序列，且绝不会使用 ISO-2022 编码，最终所有转义序列都会在缓冲区中以可见形式显示。
</p>

<p>
<code>inhibit-iso-escape-detection</code> 的默认值为nil。建议你 <b>不要永久修改</b> 该变量，仅在执行特定操作时临时调整即可。原因在于，Emacs 发行版中的部分 Emacs Lisp 源文件，其非 ASCII 字符采用 <code>iso-2022-7bit</code> 编码存储；若禁用转义序列检测，打开这些文件时将无法正确解码。
</p>

<p>
变量 <code>auto-coding-alist</code> 和 <code>auto-coding-regexp-alist</code> 是指定编码系统的最高优先级方式：前者针对特定文件名模式，后者针对包含特定内容模式的文件。这两个变量的配置 <b>甚至会覆盖文件自身</b> 的
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">-*-coding:-*-
</pre>
</div>
<p>
标签（参见《<a href="#Specify-Coding">指定文件的编码系统</a>》章节）。例如，Emacs 会将 <code>auto-coding-alist</code> 应用于 tar 归档文件，避免因归档内某个文件包含的 '<code>-*-coding:-*-</code>' 标签，导致 Emacs 误判并将该编码应用到整个归档文件上。
</p>

<p>
另一种指定编码系统的方式是使用变量 <code>auto-coding-functions</code> 。例如，Emacs 内置的其中一个自动编码函数可检测 XML 文件的编码。与上述两个变量不同，该变量 <b>不会覆盖</b> 任何 <code>-*-coding:-*-</code> 标签。
</p>
</div>
</div>
<div id="outline-container-Specify-Coding" class="outline-3">
<h3 id="Specify-Coding"><span class="section-number-3">24.7.</span> 指定文件的编码系统</h3>
<div class="outline-text-3" id="text-Specify-Coding">
<p>
若 Emacs 对文件编码识别有误，你可使用快捷键 <code>C-x RET r</code> (<code>revert-buffer-with-coding-system</code>) ，选用正确的编码系统重新读取该文件。该命令会提示你输入要使用的编码系统。若要查看 Emacs 实际用于解码该文件的编码系统，可查看 <code>mode line模式行</code> 左侧的编码系统助记字符（参见《<a href="#Mode-Line">模式行</a>》章节），或键入 <code>C-h C</code> (<code>describe-coding-system</code>) 查询。
</p>

<p>
你可直接在文件内部为特定文件指定编码系统，方式有两种：
</p>
<ul class="org-ul">
<li>一是在文件开头使用 '<code>-*-…-*-</code>' 格式的标识，</li>
<li>二是在文件末尾添加本地变量列表（参见《<a href="#File-Variables">文件中的本地变量</a>》章节）。</li>
</ul>

<p>
具体操作是为名为 <code>coding</code> 的「variable」定义取值，实际上 Emacs 并不存在真正的 <code>coding</code> 变量，该方式并非设置变量，而是为当前文件指定对应的编码系统。例如，标识 <code>-*-mode: C; coding: latin-1; -*-</code> 既指定了使用 Latin-1 编码系统，也将文件的主模式设为 C 模式。当你在文件中显式指定编码后，该设置会覆盖 <code>file-coding-system-alist</code> 变量中的对应配置。
</p>
</div>
</div>
<div id="outline-container-Output-Coding" class="outline-3">
<h3 id="Output-Coding"><span class="section-number-3">24.8.</span> 为输出选择编码系统</h3>
<div class="outline-text-3" id="text-Output-Coding">
<p>
Emacs 为某个缓冲区选定编码系统后，会将该编码系统存储在变量 <code>buffer-file-coding-system</code> 中。该编码系统会成为从当前缓冲区向文件写入内容相关操作的默认编码，如 <code>save-buffer</code> （保存缓冲区）和 <code>write-region</code> （写入区域）命令。你可通过 <code>set-buffer-file-coding-system</code> 命令，为该缓冲区后续的文件输出操作指定另一编码系统（参见《<a href="#Text-Coding">为文件文本指定编码系统</a>》章节）。
</p>

<p>
你可在任意 Emacs 缓冲区中插入 Emacs 支持的所有字符，但多数编码系统仅能处理其中的一部分字符。因此，你插入的字符有可能无法用保存该缓冲区时使用的编码系统进行编码。例如，你打开了一个以 <code>iso-8859-2</code> 编码的波兰语文本文件，并在其中添加了一些俄语词汇，保存该缓冲区时，Emacs 将无法使用 <code>buffer-file-coding-system</code> 的当前值进行编码，因为你添加的字符无法被该编码系统解析。
</p>

<p>
出现上述情况时，Emacs 会尝试使用 <b>优先级最高的编码系统</b> （由 <code>M-x prefer-coding-system</code> 或 <code>M-x set-language-environment</code> 命令设置）。若该编码系统能对缓冲区中的所有字符完成安全编码，Emacs 会采用此编码，并将其值存入 <code>buffer-file-coding-system</code> ；若不能，Emacs 会展示所有适用于编码该缓冲区内容的编码系统列表，让你从中选择其一。
</p>

<p>
若你在邮件中插入了无法被当前编码适配的字符，Emacs 的处理方式会略有不同。它会额外检查该优先级最高的编码系统是否推荐用于 MIME 邮件；若不推荐，Emacs 会将这一情况告知你，并提示你选择另一编码系统。这样做是为了避免你无意间发送了采用收件人邮件软件难以解码的编码方式的邮件。（若你在提示时输入对应编码系统名称，仍可使用该不适配的编码。）
</p>

<p>
当你发送邮件时（参见《<a href="#Sending-Mail">发送邮件</a>》章节），Emacs 会通过四种不同方式确定用于编码邮件文本的编码系统，优先级依次为：首先，若 <code>buffer-file-coding-system</code> 的缓冲区自有值非nil，则使用该值；其次，若 <code>sendmail-coding-system</code> 的值非nil，则使用该值；第三，使用 <code>default-sendmail-coding-system</code> 的值。若上述三个值均为 <code>nil</code> ，Emacs 会使用新文件的默认编码系统（即 <code>buffer-file-coding-system</code> 的默认值）对发出的邮件进行编码，而该默认编码系统由你选择的语言环境决定。
</p>
</div>
</div>
<div id="outline-container-Text-Coding" class="outline-3">
<h3 id="Text-Coding"><span class="section-number-3">24.9.</span> 为文件文本指定编码系统</h3>
<div class="outline-text-3" id="text-Text-Coding">
<p>
当 Emacs 未能为文件内容自动选择正确的编码系统时，你可以使用以下命令手动指定：
</p>
<dl class="org-dl">
<dt><code>C-x RET f 编码系统 RET</code></dt><dd>使用指定的编码系统保存或重新读取当前缓冲区中的文件 (<code>set-buffer-file-coding-system</code>) 。</dd>
<dt><code>C-x RET c coding RET</code></dt><dd>为紧随其后执行的命令指定编码系统 (<code>universal-coding-system-argument</code>) 。</dd>
<dt><code>C-x RET r coding RET</code></dt><dd>使用指定的编码系统重新读取当前文件 (<code>revert-buffer-with-coding-system</code>) 。</dd>
<dt><code>M-x recode-region RET 正确编码 RET 错误编码 RET</code></dt><dd>转换缓冲区中指定区域的编码 —— 该区域此前以错误编码完成了解码，重新用正确编码对其解码。</dd>
</dl>

<p>
命令 <code>C-x RET f</code> (<code>set-buffer-file-coding-system</code>) 用于为当前缓冲区设置 <b>文件编码系统</b> （即保存或重新读取文件时使用的编码系统），你需要在迷你缓冲区中输入指定的编码系统名称。你也可以通过在模式行的编码系统标识处点击鼠标右键（ <code>mouse-3</code> ）来调用该命令（参见《<a href="#Mode-Line">模式行</a>》章节）。
</p>

<p>
若你指定的编码系统无法处理缓冲区中的所有字符，当你尝试保存缓冲区时，Emacs 会就这些无法处理的字符发出警告，并让你重新选择其他编码系统（参见《<a href="#Output-Coding">为输出选择编码系统</a>》章节）。
</p>

<p>
你也可通过该命令为当前缓冲区的编码指定 <b>行尾转换规则</b> （参见<a href="#Coding-Systems">行尾转换</a>）。例如，执行 <code>C-x RET f dos RET</code> ，Emacs 会将当前缓冲区的文本以 DOS 格式保存，行尾使用回车符加换行符的组合。
</p>

<p>
为文件指定编码系统的另一种方式，是在 <b>打开文件时</b> 进行设置。先执行命令 <code>C-x RET c</code> (<code>universal-coding-system-argument</code>) ，该命令会在迷你缓冲区中读取你输入的编码系统名称；退出迷你缓冲区后，这个指定的编码系统就会应用于紧随其后执行的那条命令。
</p>

<p>
例如，若紧随其后的命令是 <code>C-x C-f</code> （打开文件），Emacs 会使用该编码系统读取文件（并记录该编码系统，供后续保存文件时使用）；若紧随其后的命令是 <code>C-x C-w</code> （另存为），则会使用该编码系统写入文件。以这种方式指定保存用的编码系统，而非通过 <code>C-x RET f</code> 命令设置时，即便缓冲区包含该编码系统无法处理的字符，Emacs 也不会发出警告。
</p>

<p>
受指定编码系统影响的其他文件操作命令包括 <code>C-x i=（插入文件）、 =C-x C-v</code> （重新访问文件），以及 <code>C-x C-f</code> 的跨窗口变体命令。 <code>C-x RET c</code> 命令也会作用于启动子进程的各类命令，包括 <code>M-x shell</code> （参见《<a href="#Shell">从 Emacs 中运行 Shell 命令</a>》章节）。若紧随其后的命令并不使用编码系统，那么 <code>C-x RET c</code> 命令最终将不会产生任何效果。
</p>

<p>
以 <b>无任何转换</b> 的方式打开文件的简便方法，是使用 <code>M-x find-file-literally</code> 命令（参见《<a href="#Visiting">打开文件</a>》章节）。
</p>

<p>
变量 <code>buffer-file-coding-system</code> 的默认值，指定了创建新文件时使用的编码系统。该值适用于新建文件的场景，也适用于先创建缓冲区再将其保存为文件的场景。选择语言环境时，Emacs 通常会将该变量设为适合该语言环境的默认编码系统。
</p>

<p>
若你使用错误的编码系统打开了文件，可通过 <code>C-x RET r</code> (<code>revert-buffer-with-coding-system</code>) 命令修正。该命令会让你指定一个编码系统，并用其重新读取当前文件。
</p>

<p>
若某段文本已通过错误的编码系统插入到缓冲区中，你可使用 <code>M-x recode-region</code> 命令重新解码。该命令会先提示你输入正确的编码系统，再提示你输入此前实际使用的错误编码系统，随后完成编码转换 —— 它会先使用错误编码将该区域的内容编码，再使用正确编码对其重新解码。
</p>
</div>
</div>
<div id="outline-container-Communication-Coding" class="outline-3">
<h3 id="Communication-Coding"><span class="section-number-3">24.10.</span> 进程间通信的编码系统</h3>
<div class="outline-text-3" id="text-Communication-Coding">
<p>
本节介绍如何为与其他进程的通信操作指定编码系统。
</p>
<dl class="org-dl">
<dt><code>C-x RET x coding RET</code></dt><dd>使用指定编码系统在 Emacs 与其他图形化应用之间传输选中的文本 (<code>set-selection-coding-system</code>) 。</dd>
<dt><code>C-x  RET X coding RET</code></dt><dd>使用指定编码系统传输下一次选中的文本，实现与其他图形化应用间的单向或双向传输 (<code>set-next-selection-coding-system</code>) 。</dd>
<dt><code>C-x RET p input-coding RET out-coding RET</code></dt><dd>为当前缓冲区中与子进程的输入、输出操作分别指定输入编码和输出编码 (<code>set-buffer-process-coding-system</code>) 。</dd>
</dl>

<p>
命令 <code>C-x RET x</code> (<code>set-selection-coding-system</code>) 用于指定编码系统，该编码将应用于 <b>Emacs 向其他窗口应用发送选中文本</b> ，以及 <b>从其他应用接收选中的文本</b> 这两种场景。该命令的设置会作用于后续所有的文本选中传输操作，直至再次执行该命令覆盖原有设置。命令 <code>C-x RET X</code> (<code>set-next-selection-coding-system</code>) 则仅为 <b>Emacs 中接下来的一次选中文本操作</b> ，或 <b>Emacs 读取的下一次外部选中文本操作</b> 指定编码系统。
</p>

<p>
变量 <code>x-select-request-type</code> 用于指定从 X 窗口系统中接收其他应用选中文本时，请求获取的数据类型。若该变量值为 <code>nil</code> （默认值），Emacs 会按顺序尝试 <code>UTF8_STRING</code> 和 <code>COMPOUND_TEXT</code> 两种类型，并通过多种启发式规则从两个返回结果中选择更合适的一种；若这两种类型均尝试失败，Emacs 会回退使用 <code>STRING</code> 类型。若 <code>x-select-request-type</code> 的值为 <code>COMPOUND_TEXT</code> 、 <code>UTF8_STRING</code> 、 <code>STRING</code> 或 <code>TEXT</code> 中的任一符号，Emacs 将仅使用该指定的请求类型。若该变量值为上述部分符号组成的列表，Emacs 会按列表顺序依次尝试其中的请求类型，直至某一类型尝试成功，或遍历完整个列表为止。
</p>

<p>
命令 <code>C-x RET p</code> (<code>set-buffer-process-coding-system</code>) 为与子进程的输入、输出操作指定编码系统，该命令的设置仅作用于当 <b>前缓冲区</b> 。通常每个子进程都有其对应的专属缓冲区，因此可在对应子进程的缓冲区中执行该命令，为与该特定子进程的双向数据转换指定编码系统。
</p>

<p>
你也可在执行启动子进程的命令前，先执行 <code>C-x RET c</code> (<code>universal-coding-system-argument</code>) 命令，为与该子进程的通信操作指定编码系统，具体用法参见《<a href="#Text-Coding">为文件文本指定编码系统</a>》章节。
</p>

<p>
与子进程间输入、输出数据转换使用的默认编码系统，由 <b>当前的语言环境</b> 决定。
</p>

<p>
变量 <code>locale-coding-system</code> 用于指定编码系统，该编码将应用于系统字符串的编码和解码操作，例如系统错误信息、 <code>format-time-string</code> 函数的格式串及时间戳的编解码。在 X 窗口系统中，该编码系统也可能被用于解码非 ASCII 的键盘输入；在批处理模式下，该编码还会用于对发送至标准输出流和标准错误流的文本进行编码。你应选择与 <b>底层系统的文本表示方式</b> 相兼容的编码系统，而系统的文本表示方式通常由环境变量 <code>LC_ALL</code> 、 <code>LC_CTYPE</code> 和 <code>LANG</code> 中的一个决定（按上述排列顺序，第一个值非空的环境变量将作为文本表示方式的判定依据）。
</p>
</div>
</div>
<div id="outline-container-File-Name-Coding" class="outline-3">
<h3 id="File-Name-Coding"><span class="section-number-3">24.11.</span> 文件名的编码系统</h3>
<div class="outline-text-3" id="text-File-Name-Coding">
<dl class="org-dl">
<dt><code>C-x RET F coding RET</code></dt><dd>使用指定的编码系统对文件名进行编码和解码 (<code>set-file-name-coding-system</code>) 。</dd>
</dl>

<p>
命令 <code>C-x RET F</code> (<code>set-file-name-coding-system</code>) 用于指定专门对文件名进行编码的编码系统，该设置对文件内容的读写操作无任何影响。
</p>

<p>
实际上，该命令的作用仅为修改变量 <code>file-name-coding-system</code> 的值。若将该变量设为某一编码系统名称（可为 Lisp 符号或字符串格式），Emacs 会在所有文件操作中，使用该编码系统对文件名进行编码。这一设置让文件名中可以包含非 ASCII 字符 —— 至少支持该指定编码系统能编码的所有非 ASCII 字符。
</p>

<p>
若 <code>file-name-coding-system</code> 的值为 <code>nil</code> ，Emacs 会使用由选定语言环境决定的默认编码系统，该默认编码存储在变量 <code>default-file-name-coding-system</code> 中（默认值通常为 <code>UTF-8</code> ）。
</p>

<p>
当 Emacs 运行在基于 NT 内核的微软视窗系统版本中（包括 Windows 2000、XP 及所有后续版本）， <code>file-name-coding-system</code> 的值基本会被忽略，因为 Emacs 默认会调用相关应用程序接口（API），直接传递 Unicode 格式的文件名。与之相反，在 Windows 9X 系统中，文件名会通过 <code>file-name-coding-system</code> 进行编码，该变量应被设为与当前系统区域设置对应的代码页（参见<a href="#Coding-Systems">代码页</a>相关内容）。变量 <code>w32-unicode-filenames</code> 用于控制 Emacs 调用接收文件名的系统函数时，是否使用 Unicode 应用程序接口：Emacs 的启动代码会在 Windows 9X 系统中将该变量设为 <code>nil</code> ，在更高版本的微软视窗系统中则设为 <code>t</code> 。
</p>

<p>
<b>警告</b> ：若在 Emacs 会话过程中修改 <code>file-name-coding-system</code> 的值（或更改语言环境），而你此前已打开过部分文件，这些文件的名称是通过旧编码系统编码的，且在新编码系统下无法编码（或编码方式不同），就可能引发问题。若你尝试以原文件名保存这类缓冲区的内容，可能会使用错误的文件名，或直接触发保存错误。若出现此类问题，可使用 <code>C-x C-w</code> 命令为该缓冲区指定新的文件名。
</p>

<p>
若对文件名进行编码时发生错误，可使用 <code>M-x recode-file-name</code>  命令修改文件名的编码系统。执行该命令时，Emacs 会依次提示你输入目标现有文件名、该文件名原有的编码系统，以及你希望转换到的目标编码系统。
</p>
</div>
</div>
<div id="outline-container-X-Coding" class="outline-3">
<h3 id="X-Coding"><span class="section-number-3">24.12.</span> X 键盘输入的编码系统</h3>
<div class="outline-text-3" id="text-X-Coding">
<p>
X 窗口系统下的输入法会指定专属的编码系统，这类编码系统是解码键盘输入所必需的。默认情况下，Emacs 在与输入法服务器建立连接后，会自动为每种输入法确定对应的解码编码系统，并使用该专属编码系统对键盘输入进行解码。但这种自动判定操作有时可能失败，出现该情况时，Emacs 会改用区域设置编码系统进行解码（参见《<a href="#Communication-Coding">进程间通信的编码系统</a>》章节）。
</p>

<p>
若输入法未正确声明其用于编码文本的编码系统，就需要手动指定 Emacs 对该输入法的输入文本进行解码时所用的编码系统。将变量 <code>x-input-coding-system</code> 的值设为某一编码系统符号后，Emacs 会无条件使用该编码系统，对所有来自输入法的键盘输入进行解码。
</p>
</div>
</div>
<div id="outline-container-Terminal-Coding" class="outline-3">
<h3 id="Terminal-Coding"><span class="section-number-3">24.13.</span> 终端 I/O 的编码系统</h3>
<div class="outline-text-3" id="text-Terminal-Coding">
<dl class="org-dl">
<dt><code>C-x RET t coding RET</code></dt><dd>使用指定编码系统处理终端输出 (<code>set-terminal-coding-system</code>) 。</dd>
<dt><code>C-x RET k coding RET</code></dt><dd>使用指定编码系统处理键盘输入 (<code>set-keyboard-coding-system</code>) 。</dd>
</dl>

<p>
命令 <code>C-x RET t</code> (<code>set-terminal-coding-system</code>) 用于指定 <b>终端输出</b> 的编码系统。若为终端输出指定了字符编码，所有输出到终端的字符都会转换为该编码系统格式。
</p>

<p>
该功能适用于专为支持特定语言或字符集设计的纯字符终端 —— 例如，支持某一种 ISO 拉丁字符集的欧洲终端。在使用多字节文本时，你需要指定终端编码系统，让 Emacs 知晓该终端实际能处理哪些字符。
</p>

<p>
默认情况下，终端输出不会进行任何编码转换，除非 Emacs 能从你的终端类型或区域设置中推导出合适的编码系统（参见《<a href="#Language-Environments">语言环境</a>》章节）。
</p>

<p>
命令 <code>C-x RET k</code> (<code>set-keyboard-coding-system</code>) 或变量 <code>keyboard-coding-system</code> ，用于指定 <b>键盘输入</b> 的编码系统。对于部分会发送非 ASCII 图形字符的终端，键盘输入的字符编码转换功能十分实用 —— 例如，部分为 ISO Latin-1 字符集或其子集设计的终端。
</p>

<p>
默认情况下，键盘输入会根据系统的区域设置进行编码转换。若你的终端实际并不支持区域设置所对应的编码（例如，按下 <code>M-i</code> 时终端插入了非 ASCII 字符），你需要将 <code>keyboard-coding-system</code> 设为 <code>nil</code> 来关闭编码转换。你可在初始化文件中添加以下代码实现该设置：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(set-keyboard-coding-system nil)
</pre>
</div>

<p>
在微软视窗系统中，设置 <code>keyboard-coding-system</code> 无任何效果；仅在老旧的 Windows 9X 系统中例外，此时该编码必须与微软视窗控制台的当前代码页匹配，而控制台代码页可通过调用 <code>w32-set-console-codepage</code> 函数修改。
</p>

<p>
为键盘输入设置编码系统转换，与使用输入法之间存在一定相似性：二者都会将一系列键盘输入转换为单个字符。但二者设计初衷不同， <b>输入法</b> 是为了方便用户交互式操作，待转换的输入序列通常为 ASCII 可打印字符；而 <b>编码系统</b> 的转换对象，通常为非图形字符序列。
</p>
</div>
</div>
<div id="outline-container-Fontsets" class="outline-3">
<h3 id="Fontsets"><span class="section-number-3">24.14.</span> 字体集</h3>
<div class="outline-text-3" id="text-Fontsets">
<p>
一种字体通常仅为某一种字母体系或文字脚本定义字形。因此，要显示 Emacs 所支持的全范围文字脚本，就需要组合使用多种字体。在 Emacs 中，这样的字体组合被称为 <b>字体集</b> 。字体集由一系列字体规格定义而成，其中每一种字体规格被分配处理一个字符编码范围；对于其指定字体未覆盖的字符，该字体集会回退调用另一个字体集来处理。
</p>

<p>
每个字体集都和单种字体一样拥有专属名称。但不同的是，字体由系统存储，可用的字体名称也由系统定义，而 <b>字体集是在 Emacs 内部自行定义</b> 的。一旦完成某一字体集的定义，你便可在 Emacs 中通过指定其名称来使用它，所有可使用单种字体的场景均适用。当然，Emacs 字体集仅能使用你的系统所支持的字体。若部分字符在屏幕上显示为空白方框或十六进制编码，说明用于显示这些字符的字体集中，没有对应适配的字体。出现这种情况，或是字符虽能显示但显示效果不符合预期时，你可能需要安装额外的字体，或是修改该字体集，使其调用你系统中已安装的特定字体（详见下文）。你的操作系统可能会提供可选安装的字体，你也可以安装 GNU 国际字体包（GNU Intlfonts），该字体包包含了 Emacs 所支持的绝大多数文字脚本对应的字体 <sup><a id="fnr.10" class="footref" href="#fn.10" role="doc-backlink">10</a></sup>。
</p>

<p>
Emacs 会自动创建三种字体集：standard fontset标准字体集、 startup启动字体集和 default默认字体集。 <b>默认字体集</b> 最有可能包含适配各类非 ASCII 字符的字体，它是另外两种字体集的默认回退字体集；当你设置的是默认字体而非字体集时，该字体集也会作为默认回退选项。但默认字体集并未指定字体族名称，因此若直接使用，显示效果可能会存在一定的随机性。你可在启动 Emacs 时使用 '<code>-fn</code>' 选项指定特定的字体集，例如：
</p>


<div class="org-src-container">
<pre class="src src-shell">emacs -fn fontset-standard
</pre>
</div>

<p>
你也可通过 X 资源中的 '<code>Font</code>' 项指定字体集（参见《<a href="#X-Resources">X 选项与资源</a>》章节）。
</p>

<p>
若未指定要使用的字体集，Emacs 会使用一款 ASCII 字体，对于该字体未覆盖的字符，则会以 '<code>fontset-default</code>' （默认字体集）作为回退。 <b>标准字体集</b> 尽管名称如此，却仅在被显式调用时才会生效。
</p>

<p>
要查看特定字体集的相关信息，可使用 <code>M-x describe-fontset</code> 命令。该命令会提示你输入字体集名称，默认值为当前框架正在使用的字体集；执行后会展示该字体集中的所有字符子范围，以及分配给各范围的对应字体。若要查看在未指定字体集的情况下（常规启动的默认情况），Emacs 在当前会话中使用的字体信息，可在命令提示时输入 <code>fontset-default</code> 并回车，或直接回车，即可查看当前框架所用字体集的详情。
</p>

<p>
一个字体集并非必须为每一个字符编码都指定对应字体。若某字体集未为某个字符指定字体，或是其指定的字体在你的系统中不存在，该字符就无法被正确显示，取而代之的会是该字符的十六进制编码、细空格或空白方框（详见《<a href="#Text-Display">无字形字符的显示处理</a>》章节）。此外，即便字体集为某一字符范围指定了字体，你也可能对其视觉显示效果不满意。出现上述这些情况时，你可以对字体集进行修改，具体方法参见《<a href="#Modifying-Fontsets">修改字体集</a>》章节。
</p>
</div>
</div>
<div id="outline-container-Defining-Fontsets" class="outline-3">
<h3 id="Defining-Fontsets"><span class="section-number-3">24.15.</span> 定义字体集</h3>
<div class="outline-text-3" id="text-Defining-Fontsets">
<p>
在 X 窗口系统中运行时，Emacs 会根据 <code>standard-fontset-spec</code> 的取值自动创建一个标准字体集，该字体集的名称为：
</p>

<div class="org-src-container">
<pre class="src src-shell">-*-fixed-medium-r-normal-*-16-*-*-*-*-*-fontset-standard
</pre>
</div>
<p>
可简称为 'fontset-standard' 。
</p>

<p>
在 GNUstep 和 macOS 系统中，标准字体集由 <code>ns-standard-fontset-spec</code> 的取值生成；在微软视窗系统（MS Windows）中，标准字体集则由 <code>w32-standard-fontset-spec</code> 的取值生成。
</p>

<p>
标准字体集的粗体、斜体、粗斜体变体也会被自动创建，其名称会将原名称中的 'medium' 替换为 'bold' ，或将 'r' 替换为 'i' ，也可同时替换两者。
</p>

<p>
若你通过 'Font' 资源、 '-fn' 命令行参数指定了默认的 ASCII 字体，或 Emacs 启动时自动识别到了默认字体，程序会基于该字体自动生成一个字体集，即 <b>启动字体集</b> ，名称为 <code>fontset-startup</code> 。Emacs 生成该字体集的规则为：将字体名称中的 <i>charset_registry</i> （字符集注册名）字段替换为 'fontset' ， <i>charset_encoding</i> （字符集编码名）字段替换为 'startup' ，再将生成的字符串作为字体集的指定标识。
</p>

<p>
例如，若你通过以下形式指定字体启动 Emacs：
</p>

<div class="org-src-container">
<pre class="src src-shell">emacs -fn <span style="color: #8b2252;">"*courier-medium-r-normal--14-140-*-iso8859-1"</span>
</pre>
</div>

<p>
Emacs 会生成下述字体集，并将其应用于 X 窗口系统的初始框架：
</p>

<div class="org-src-container">
<pre class="src src-shell">-*-courier-medium-r-normal-*-14-140-*-*-*-*-fontset-startup
</pre>
</div>

<p>
对于该字体所支持的所有字符，启动字体集会直接使用该指定字体（或注册表、编码不同的变体）；对于其他字符，则会回退至 'fontset-default' （默认字体集）进行匹配。
</p>

<p>
通过 X 资源 'Emacs.Font' ，你可像指定实际字体名一样指定字体集名称。但注意 <b>不要</b> 在 '<code>Emacs*Font</code>' 这类通配符资源中指定字体集名称 —— 该通配符会匹配菜单等其他各类资源，而菜单组件无法识别并处理字体集。相关细节可参考《<a href="#X-Resources">X 窗口系统的选项与资源</a>》章节。
</p>

<p>
你可通过命名为 '<code>Fontset-n</code>' 的 X 资源指定额外的字体集（其中n为从 0 开始的整数），该资源的取值需遵循以下格式：
</p>

<div class="org-src-container">
<pre class="src src-shell">fontpattern, [charset:font]&#8230;
&#23383;&#20307;&#27169;&#24335;, [&#23383;&#31526;&#38598;:&#23383;&#20307;]&#8230;
</pre>
</div>

<p>
其中， <b>fontpattern字体模式</b> 需符合标准 X 窗口系统的字体名格式（可参考前文启动字体集的示例），但最后两个字段除外，这两个字段需设为 '<code>fontset-alias</code>' 的形式。
</p>

<p>
每个字体集均有两个名称：长名称和短名称。长名称即上述的 <b>字体模式</b> ，短名称为长名称的最后两个字段，即 '<code>fontset-alias</code>'（例如启动时自动创建的字体集，其短名称为 '<code>fontset-startup</code>' ）。你可通过任意一个名称引用该字体集。
</p>

<p>
'<code>charset:font</code>' 格式用于指定（当前字体集中）某一特定字符集所使用的字体。其中， <i>charset</i> 为字符集名称， <i>font</i> 为该字符集对应的字体。在定义单个字体集时，可根据需要多次使用该格式。
</p>

<p>
对于其余未单独指定的字符集，Emacs 会依据字体模式（ <i>fontpattern</i> ）自动匹配字体：将模式中的 '<code>fontset-alias</code>' 替换为对应字符集的描述值。例如针对 ASCII 字符的字体， '<code>fontset-alias</code>' 会被替换为 '<code>ISO8859-1</code>' 。
</p>

<p>
此外，当字体模式中出现多个连续的通配符时，Emacs 会将其合并为单个通配符，这一设计是为了避免使用 auto-scaled fonts自动缩放的字体。通过放大原有字体得到的缩放字体并不适用于文本编辑，而缩小字体也无实际意义 —— 直接使用小字体的原始尺寸效果会更好，Emacs 也会按此方式处理。
</p>

<p>
因此，若 <i>fontpatter</i> 字体模式为下述形式：
</p>

<div class="org-src-container">
<pre class="src src-shell">-*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24
</pre>
</div>

<p>
则 ASCII 字符对应的字体指定规则为：
</p>
<div class="org-src-container">
<pre class="src src-shell">-*-fixed-medium-r-normal-*-24-*-ISO8859-1
</pre>
</div>

<p>
而中文 GB2312 字符对应的字体指定规则为：
</p>
<div class="org-src-container">
<pre class="src src-shell">-*-fixed-medium-r-normal-*-24-*-gb2312*-*
</pre>
</div>

<p>
你的系统中可能没有匹配上述字体指定规则的中文字体。大多数 X 窗口系统发行版所包含的中文字体，其字体族字段均为「宋体（song ti）」或「仿宋（fangsong ti）」。这种情况下，可按如下方式指定「Fontset-n」：
</p>
<div class="org-src-container">
<pre class="src src-shell">Emacs.Fontset-0: -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24,<span style="color: #8b2252;">\</span>
        chinese-gb2312:-*-*-medium-r-normal-*-24-*-gb2312*-*
</pre>
</div>

<p>
配置后，除中文 GB2312 字符外，所有字符对应的字体指定规则中，字体族字段均为「fixed」；而中文 GB2312 字符的字体指定规则中，字体族字段为通配符 '<code>*</code>' ，可自动匹配系统中的中文字体。
</p>

<p>
Emacs 中负责解析字体集资源配置值并创建字体集的函数为 <code>create-fontset-from-fontset-spec</code> ，你也可以显式调用该函数手动创建字体集。
</p>

<p>
关于字体命名的更多相关信息，可参阅《<a href="#Fonts">字体</a>》章节。
</p>
</div>
</div>
<div id="outline-container-Modifying-Fontsets" class="outline-3">
<h3 id="Modifying-Fontsets"><span class="section-number-3">24.16.</span> 修改字体集</h3>
<div class="outline-text-3" id="text-Modifying-Fontsets">
<p>
字体集并非总需要从头创建。若仅需小幅修改，直接编辑现有字体集通常更简便，最常用的是 '<code>fontset-default</code>' （默认字体集）。修改 '<code>fontset-default</code>' 还会影响所有将其作为回退字体集的其他字体集，因此这是解决 Emacs 为特定文字体系选择字体时各类问题的有效方法。
</p>

<p>
可通过 <code>set-fontset-font</code> 函数修改字体集，该函数需指定 <b>要修改字体的字符、字符集、文字体系或字符范围</b> ，以及 <b>待使用的字体规格</b> 。以下为具体示例：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#20026;&#27721;&#23383;&#20248;&#20808;&#20351;&#29992;&#22823;&#20116;&#30721;&#65288;Big5&#65289;&#23383;&#20307;
</span>(set-fontset-font <span style="color: #8b2252;">"fontset-default"</span>
                  'han (font-spec <span style="color: #483d8b;">:registry</span> <span style="color: #8b2252;">"big5"</span>)
                  nil 'prepend)

<span style="color: #b22222;">;; </span><span style="color: #b22222;">&#20026;&#34920;&#24773;&#31526;&#21495;&#25991;&#23383;&#20307;&#31995;&#20351;&#29992;&#8220;Noto Color Emoji&#8221;&#23383;&#20307;&#65288;&#40664;&#35748;&#37197;&#32622;&#65289;
</span>(set-fontset-font <span style="color: #8b2252;">"fontset-default"</span> 'emoji
                  '(<span style="color: #8b2252;">"Noto Color Emoji"</span> . <span style="color: #8b2252;">"iso10646-1"</span>)
                  nil 'prepend)

<span style="color: #b22222;">;; </span><span style="color: #b22222;">&#20351;&#29992;&#24425;&#33394;&#23383;&#20307;&#26174;&#31034;&#24515;&#24418;&#23383;&#31526;
</span>(set-fontset-font <span style="color: #8b2252;">"fontset-default"</span>
                  #x2764 <span style="color: #8b2252;">"Noto Color Emoji"</span>)

<span style="color: #b22222;">;; </span><span style="color: #b22222;">&#20026;Unicode&#31169;&#26377;&#20351;&#29992;&#21306;&#20351;&#29992;&#33258;&#23450;&#20041;&#31169;&#26377;&#23383;&#20307;MyPrivateFont
</span>(set-fontset-font <span style="color: #8b2252;">"fontset-default"</span>  '(#xe000 . #xf8ff)
                  <span style="color: #8b2252;">"MyPrivateFont"</span>)

<span style="color: #b22222;">;; </span><span style="color: #b22222;">&#20026;&#25289;&#19969;-3&#23383;&#31526;&#38598;&#20351;&#29992;Liberation Mono&#23383;&#20307;
</span>(set-fontset-font <span style="color: #8b2252;">"fontset-default"</span> 'iso-8859-3
                  <span style="color: #8b2252;">"Liberation Mono"</span>)

<span style="color: #b22222;">;; </span><span style="color: #b22222;">&#22312;&#21551;&#21160;&#23383;&#20307;&#38598;&#65288;fontset-startup&#65289;&#20013;&#65292;&#23558;DejaVu Sans Mono&#35774;&#20026;&#22238;&#36864;&#23383;&#20307;&#65292;
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#20248;&#20808;&#20110;&#40664;&#35748;&#23383;&#20307;&#38598;&#65288;fontset-default&#65289;&#35843;&#29992;
</span>(set-fontset-font <span style="color: #8b2252;">"fontset-startup"</span> nil <span style="color: #8b2252;">"DejaVu Sans Mono"</span>
                  nil 'append)
</pre>
</div>

<p>
修改 <code>symbol script符号文字体系</code> 的字体集时，变量 <code>use-default-font-for-symbols</code> 的取值会决定该 <b>字体集</b> 是否实际生效。
</p>

<p>
关于 <code>set-fontset-font</code> 函数的更多详细用法，可参考《GNU Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Fontsets.html#Fontsets">字体集</a>章节。
</p>

<p>
若你不清楚某个字符的编码点或其所属的文字体系，可让 Emacs 直接查询：将光标移至该字符处，按下 <code>C-u C-x =</code> (<code>what-cursor-position</code>) ，相关信息及更多细节会在 Emacs 弹出的 <code>*Help*</code> 帮助缓冲区中显示，具体可参考<a href="#Position-Info">光标位置信息</a>章节。
</p>

<p>
例如，日文字符归属于kana（假名）文字体系，但日文文本中常会混合汉字，因此可通过为han（汉字）文字体系配置字体，让 Emacs 使用Kochi Gothic（高知哥特体）显示日文：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(set-fontset-font <span style="color: #8b2252;">"fontset-default"</span> 'han <span style="color: #8b2252;">"Kochi Gothic"</span>)
</pre>
</div>

<p>
（为方便使用，Emacs 中的 '<code>han</code>' 文字体系并非仅支持中文字符，而是覆盖了中日韩（ <code>CJK</code> ）所有统一字符。）
</p>

<p>
Emacs 支持的所有 <code>script 文字体系</code> 列表，可查看变量 <code>script-representative-chars</code> 的取值。
</p>

<p>
上述这类字体集配置 <b>仅对默认字体不支持的字符生效</b> ：例如若 '<code>Kochi Gothic</code>' 字体包含拉丁字符，Emacs 也不会用它显示拉丁文字体系 —— 因为 Emacs 默认字体通常已支持基础拉丁字符集。
</p>

<p>
你系统中安装的部分字体可能存在损坏，或显示对应字符时效果不佳，此时可让 Emacs 在搜索合适的显示字体时，完全忽略这些问题字体。具体方法为：将问题字体名称添加至列表型变量 <code>face-ignored-fonts</code> 的取值中，可在 '<code>~/.emacs</code>' 配置文件中添加如下示例代码：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-to-list 'face-ignored-fonts <span style="color: #8b2252;">"Some Bad Font"</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-Undisplayable-Characters" class="outline-3">
<h3 id="Undisplayable-Characters"><span class="section-number-3">24.17.</span> 无法显示的字符</h3>
<div class="outline-text-3" id="text-Undisplayable-Characters">
<p>
你的终端可能无法显示部分非 ASCII 字符。大多数文本终端仅支持一种字符集（可通过变量 <code>default-terminal-coding-system</code> 告知 Emacs 当前终端使用的字符集，详见《<a href="#Terminal-Coding">终端输入输出的编码体系</a>》章节）； 无法用该编码体系编码的字符，默认会显示为问号 '<code>?</code>' 。
</p>

<p>
图形化显示界面能支持更广泛的字符显示，但如果你的系统未安装对应字符的字体，这些字符会以 <b>空心方块</b> 的形式呈现。
</p>

<p>
若你需要使用 Latin-1 字符，而终端不支持 Latin-1 字符的显示，可将其替换为助记 ASCII 序列来展示，例如用 "<code>"o</code>" 表示带分音符的字母  <code>ö</code> 。加载 <code>iso-ascii</code> 库即可实现该功能。
</p>

<p>
若你的终端支持 Latin-1 字符显示，还可通过 Latin-1 等效字符与ASCII 助记序列结合的方式，显示其他欧洲字符集的字符。自定义变量 <code>latin1-display</code> 并启用该功能即可，其中所用的 ASCII 助记序列，大多与前缀输入法的助记序列一致。
</p>
</div>
</div>
<div id="outline-container-Unibyte-Mode" class="outline-3">
<h3 id="Unibyte-Mode"><span class="section-number-3">24.18.</span> 单字节编辑模式</h3>
<div class="outline-text-3" id="text-Unibyte-Mode">
<p>
ISO 8859 系列拉丁字符集将八进制 0240 至 0377（十进制 160 至 255）的字符编码范围，用于表示欧洲各类语言（及部分非欧洲语言）所需的带重音字母和标点符号。需要注意的是，即便在单字节缓冲区中（即禁用多字节字符的情况下），Emacs 仍会将此编码范围内的字节视为 <b>原始字节</b> ，而非字符；但 Emacs 仍可将这些字符编码临时视作某一单字节字符集的内容来处理。若要指定使用的字符集，可调用 <code>M-x set-language-environment</code> 命令，并选择合适的语言环境（如 '<code>Latin-n</code>' ）。相关细节可参考《GNU Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Disabling-Multibyte.html#Disabling-Multibyte">禁用多字节字符</a>」章节。
</p>

<p>
只要当前使用的终端或字体支持，Emacs 也能将十进制 160 至 255 范围内的字节显示为可识别的字符，该功能会自动生效。在图形化显示界面中，Emacs 还可通过 <b>字体集</b> 显示单字节字符，其实际原理是根据当前语言环境，将单字节字符转换为等效的多字节字符后再展示。若要启用该功能，只需将变量 <code>unibyte-display-via-language-environment</code> 设置为非nil值即可。请注意，该设置 <b>仅影响此类字节的显示方式</b> ，并不会改变 Emacs 将其视作原始字节而非字符的核心处理逻辑。
</p>

<p>
若你的终端不支持 Latin-1 字符集的显示，Emacs 可将这些字符转换为 ASCII 序列展示，至少能让你清晰识别字符本身。加载 <code>iso-ascii</code> 库即可实现该功能。理论上可为其他 ISO 8859 拉丁字符集实现类似的库，但目前暂未开发。
</p>

<p>
默认情况下，非 ISO 8859 字符（十进制 128 至 159 范围内的编码）会以 <b>八进制转义序列</b> 的形式显示。若需为非标准的 ISO 8859 字符集扩展版本修改此显示方式，可使用 <code>disp-table</code> 库中的 <code>standard-display-8bit</code> 函数。
</p>

<p>
输入单字节非 ASCII 字符有两种方法：
</p>

<ol class="org-ol">
<li>使用当前选定语言环境对应的输入法（详见「<a href="#Input-Methods">输入法</a>」章节）。在单字节缓冲区中使用输入法时，通过输入法输入的非 ASCII 字符会被自动转换为单字节格式。</li>
<li><p>
若你的键盘可生成表示非 ASCII 字符的、十进制 128 及以上的字符编码，可直接敲击对应按键输入该编码。
</p>

<p>
在图形化显示界面中，使用上述按键无需进行特殊设置，可直接生效；而在文本终端中，需调用 <code>M-x set-keyboard-coding-system</code> 命令，或自定义变量 <code>keyboard-coding-system</code> ，以此指定键盘所使用的编码体系（详见「<a href="#Terminal-Coding">终端输入输出的编码体系</a>」章节）。启用该功能后，你可能需要通过 <code>ESC</code> 键来输入元字符（Meta）；但在控制台终端或 <code>xterm</code> 等终端模拟器中，你可将元字符映射为 <code>ESC</code> 键，同时仍能直接通过键盘、组合键（Compose）或右 <code>Alt</code> 键（AltGr）输入 8 位字符，相关细节可参考「<a href="#User-Input">用户输入的类型</a>」章节。
</p>

<p>
许多现代系统为各类无对应键盘按键的语言，提供了 <b>原生输入法</b> 支持。若 Emacs 在编译时启用了原生输入法支持，你即可激活此类输入法并输入其支持的字符。原生输入法的激活与使用方式因系统和输入法类型而异，本文不再赘述，可参考对应的系统文档。本节仅介绍 Emacs 中用于控制原生输入法使用的相关功能。
</p>

<p>
在基于 GTK 工具包编译的 Emacs 中，变量 <code>x-gtk-use-native-input</code> 用于控制 Emacs 是否接收 GTK 输入法生成的字符。该变量默认值为 <code>nil</code> ，此时 Emacs 使用 X 输入法（XIM）；若设为非nil值，则使用 GTK 输入法。X 资源中的 <code>useXIM</code> 用于控制是否启用 XIM， <code>inputStyle</code> 则用于控制原生输入法在 X 界面中生成的预览文本的显示方式，相关细节可参考<a href="#Windows-Keyboard">「Emacs 的 X 资源列表</a>」。
</p>

<p>
在微软视窗（MS-Windows）系统中，Emacs 支持由输入法管理器（IMM）提供的原生输入法，若有需要也可将其关闭，相关细节可参考「<a href="#Windows-Keyboard">微软视窗系统中的键盘使用方法</a>」。
</p></li>
<li><p>
你可将组合键 <code>C-x 8</code> 用作 <b>合成字符前缀</b> ，来输入非 ASCII 的 Latin-1字符及其他可打印字符。 <code>C-x 8</code> 可在迷你缓冲区、普通缓冲区中用于字符插入，也可在搜索过程中及所有允许输入按键序列的场景中使用。
</p>

<p>
<code>C-x 8</code> 的功能通过加载 <code>iso-transl</code> 库实现。该库加载后，若键盘配有 <code>Alt</code> 修饰键，该键将与 <code>C-x 8</code> 实现相同的功能：按住 <code>Alt</code> 键并敲击重音字符，即可为后续输入的字母添加对应重音。此外， <code>iso-transl</code> 库加载后，若键盘带有 Latin-1 虚重音字符键，这些按键也会被定义为合成键，可与后续输入的字符组合生成带重音的字符。
</p>

<p>
按下 <code>C-x 8 C-h</code> 可列出所有可用的 <code>C-x 8</code> 字符合成映射关系。
</p>

<p>
你可通过 <code>M-x iso-transl-set-language</code> 命令，为特定语言扩展 <code>C-x 8</code> 支持的字符合成映射集，目前该功能支持的语言包括：法语（French）、德语（German）、葡萄牙语（Portuguese）、西班牙语（Spanish）和世界语（Esperanto）。相关细节可参考变量 <code>iso-transl-language-alist</code> 。
</p></li>
</ol>
</div>
</div>
<div id="outline-container-Charsets" class="outline-3">
<h3 id="Charsets"><span class="section-number-3">24.19.</span> 字符集</h3>
<div class="outline-text-3" id="text-Charsets">
<p>
在 Emacs 中， <i>charset</i> 是 字符集（character set）的缩写。Emacs 除了支持自身定义的若干字符集（如 emacs、unicode-bmp、eight-bit）外，还兼容绝大多数主流字符集（如 ascii、iso-8859-1、cp1250、big5、unicode）。所有受支持的字符，均归属于一个或多个字符集。
</p>

<p>
Emacs 通常会自动对字符集做最优处理，无需用户手动干预；但了解字符集的一些底层细节，有时能为使用带来帮助。
</p>

<p>
一个典型应用场景是字体选择（详见「<a href="#Fonts">字体</a>」章节）：每种语言环境（详见「<a href="#Language-Environments">语言环境</a>」章节）都会为各类字符集定义一个 <b>优先级列表</b> 。Emacs 搜索字体时，会优先尝试找到能显示最高优先级字符集的字体。例如在日语语言环境中， '<code>japanese-jisx0208</code>' 字符集拥有最高优先级，因此 Emacs 会尝试使用 <b>注册表属性</b> 为 '<code>JISX0208.1983-0</code>' 的字体。
</p>

<p>
有两个命令可用于查询字符集相关信息：
</p>
<ul class="org-ul">
<li>执行 <code>M-x list-charset-chars</code> ，按提示输入字符集名称，即可显示该字符集中的所有字符；</li>
<li>执行 <code>M-x describe-character-set</code> ，按提示输入字符集名称，即可展示该字符集的详细信息，包括其在 Emacs 内部的表示方式。</li>
</ul>

<p>
执行 <code>M-x list-character-sets</code> 可显示 Emacs 支持的所有字符集列表，该列表会标注各字符集的名称及身份识别补充信息。如需了解更多背景，可参考由<a href="https://www.itscj.ipsj.or.jp/itscj_english/">日本信息处理学会 / 日本信息技术标准委员会（IPSJ/ITSCJ）</a>维护的《<a href="https://www.itscj.ipsj.or.jp/itscj_english/iso-ir/ISO-IR.pdf">用于转义序列的 ISO 编码字符集国际注册表</a>》（ISO-IR）。该列表中的字符集分为两类：常规字符集排在前列，后续为补充字符集。补充字符集指用于定义其他字符集（作为父集或子集），或为旧版 Emacs 提供向下兼容性的字符集。
</p>

<p>
若要查询缓冲区中某个字符所属的字符集，只需将光标移至该字符前，按下 <code>C-u C-x =</code> 即可（详见「<a href="#International-Chars">国际字符集简介</a>」章节）。
</p>
</div>
</div>
<div id="outline-container-Bidirectional-Editing" class="outline-3">
<h3 id="Bidirectional-Editing"><span class="section-number-3">24.20.</span> 双向编辑</h3>
<div class="outline-text-3" id="text-Bidirectional-Editing">
<p>
Emacs 支持编辑阿拉伯语、波斯语、希伯来语等文字体系的文本，这类文字的横向自然显示顺序为 <b>从右到左</b> ，但嵌入其中的数字和拉丁语文本仍按从左到右的方式显示。拉丁语文档中也常嵌入小段阿拉伯语或希伯来语文本（例如程序源文件中的注释和字符串），因此这类文字的文本实际为 <b>双向文本</b> ：同时包含从左到右和从右到左的字符段。
</p>

<p>
本节介绍 Emacs 为编辑双向文本提供的功能与配置项。
</p>

<p>
Emacs 以逻辑顺序（也叫阅读顺序）存储从右到左的文本和双向文本：即阅读时第一个字符在缓冲区或字符串中的位置，排在下一个字符之前。双向文本会在显示阶段重新排序为视觉顺序，这就导致字符在缓冲区中的位置，与其在屏幕上的显示位置不再保持单调递增的关系。Emacs 实现了<a href="https://unicode.org/reports/tr9/">《Unicode 标准附录 #9</a>》中规定的Unicode 双向算法（UBA），用于双向文本的显示重排；仅在文本方向与段落基础方向相反时的折行显示上存在差异（例如从右到左的段落中出现长段英语文本）。
</p>

<p>
缓冲区局部变量 <code>bidi-display-reordering</code> 用于控制缓冲区中的文本是否在显示时重排。若其值为非nil，Emacs 会对显示的含从右到左方向属性的字符进行重排，该变量默认值为 <code>t</code> 。
</p>

<p>
双向文本的每个段落均可设置独立的 <b>基础方向</b> ，可设为从右到左或从左到右。从左到右的段落，文本从窗口左边界开始显示，到达右边界时自动截断或折行；与之相反，从右到左的段落，文本从窗口右边界开始显示，到达左边界时截断或折行。默认情况下， <b>空行（即全部由空白字符组成的行）</b> 为段落分隔符；若需修改，可自定义两个缓冲区局部变量 <code>bidi-paragraph-start-re</code> 和 <code>bidi-paragraph-separate-re</code> （详见「<a href="#Locals">局部变量</a>」章节），其值为正则表达式（字符串）—— 例如将两个变量均设为 "<code>^</code>" ，即可将单个换行符作为新段落的起始标识。
</p>

<p>
Emacs 会根据 <b>段落开头的文本内容</b> ，动态判断每个段落的基础方向。但有时需要为缓冲区中的所有段落强制指定固定的基础方向：若变量 <code>bidi-paragraph-direction</code> 设为非nil，则会关闭基础方向的动态判断，转而强制缓冲区中所有段落使用该变量的缓冲区局部值指定的方向，其有效值为 <code>right-to-left</code> （从右到左）和 <code>left-to-right</code> （从左到右），其他值均视为 <code>nil</code> 。
</p>

<p>
此外，也可通过在段落开头 <b>插入特殊格式字符</b> 来控制段落的基础方向： <b>从右到左标记（RLM）</b> 会强制后续段落为从右到左方向， <b>从左到右标记（LRM）</b> 则强制为从左到右方向（可通过 <code>C-x 8 RET</code> 插入这类字符）。在图形界面会话中，LRM 和 RLM 字符会显示为极窄的空白字符；在文本终端中则显示为普通空白字符。
</p>

<p>
由于字符在显示时会被重排，那些按 <b>逻辑顺序</b> 或 <b>缓冲区位置段</b> 执行的 Emacs 命令，可能会产生特殊效果。例如 <code>C-f</code> （前进字符）和 <code>C-b</code> （后退字符）按逻辑顺序移动光标，因此当光标遍历经过重排的双向文本时，有时会出现跳跃；同理，若高亮区域覆盖的连续缓冲区字符段跨过重排文本，视觉上该区域可能显得不连续。这属于正常现象，与其他支持双向文本的程序表现一致。
</p>

<p>
绑定在方向键上的光标移动命令（如 <code>LEFT</code> 、 <code>C-RIGHT</code> ），会 <b>适配当前段落的基础方向</b> 。在从左到右的段落中，带或不带修饰键的右箭头命令，会沿缓冲区文本向前移动；而在从右到左的段落中，该操作会变为向后移动。这一设计契合从右到左段落的特点：屏幕上向左移动时，字符在缓冲区中的位置通常呈递增趋势。
</p>

<p>
当光标移出某一段落时，若前一段落或后一段落的基础方向与原段落不同，方向键的功能可能会发生变化，此时需要根据新的基础方向调整按下的方向键。
</p>

<p>
默认情况下， <code>LEFT</code> 、 <code>RIGHT</code> 方向键按 <b>逻辑顺序</b> 移动光标；若将变量 <code>visual-order-cursor-movement</code> 设为非nil，则这些命令会移动到当前屏幕位置 <b>视觉上</b> 左侧或右侧的字符，并在需要时跳转到下一行或上一行屏幕文本。请注意，受周边双向文本上下文影响，该操作可能会使光标在缓冲区中移动较长的距离。
</p>

<p>
双向文本有时会使用 <b>特殊格式字符</b> 来影响文本的显示重排，前文提到的 LRM 和 RLM 就是其中两种，这类字符还有其他类型。默认情况下，它们在图形界面帧中显示为窄空白符号，在文本模式帧中显示为普通空格。若希望能直观看到这些特殊控制字符，避免其对显示的影响超出预期，可开启 <code>glyphless-display-mode</code> （无字形显示模式，详见「<a href="#Text-Display">文本的显示方式</a>」章节）。开启该次要模式后，这些格式字符会显示为 <b>小方框内的缩写形式</b> ，在屏幕上突出显示，便于理解其作用。
</p>
</div>
</div>
</section>
<section id="outline-container-Modes" class="outline-2">
<h2 id="Modes"><span class="section-number-2">25.</span> 主模式与次模式</h2>
<div class="outline-text-2" id="text-Modes">
<p>
Emacs 内置多种编辑模式，可通过实用的方式改变其基础操作行为，这些模式分为 <i>major modes</i> 主模式和 <i>minor modes</i> 次模式两类。
</p>

<p>
主模式为处理特定类型文件（如 C 语言源文件，参见「<a href="#Programs">编辑程序</a>」章节）或特定类型的非文件缓冲区（如 Shell 缓冲区，参见「<a href="#Shell">在 Emacs 中执行 Shell 命令</a>」章节）提供专属功能支持。主模式之间互斥，任意时刻每个缓冲区都有且仅有一个主模式。
</p>

<p>
次模式是可自由开启或关闭的可选功能，并非必须绑定于特定类型的文件或缓冲区。例如 <code>Auto Fill mode</code> 自动换行模式便是一种副模式，开启后输入空格时，会在单词之间自动换行（参见「<a href="#Auto-Fill">自动换行模式</a>」章节）。各副模式之间相互独立，且与当前选中的主模式也彼此独立。
</p>
<ul class="org-ul">
<li><a href="#Major-Modes">主模式</a></li>
<li><a href="#Minor-Modes">次模式</a></li>
<li><a href="#Choosing-Modes">选择文件模式</a></li>
</ul>
</div>
<div id="outline-container-Major-Modes" class="outline-3">
<h3 id="Major-Modes"><span class="section-number-3">25.1.</span> 主模式</h3>
<div class="outline-text-3" id="text-Major-Modes">
<p>
每个缓冲区都拥有一个主模式，该模式决定了此缓冲区为当前缓冲区时 Emacs 的编辑行为。 <code>mode line模式行</code> 通常会在 <b>圆括号内显示当前主模式</b> 的名称（参见「<a href="#Mode-Line">模式行</a>」章节）。
</p>

<p>
功能最基础的主模式为 <b><i>Fundamental mode</i> 基本模式</b> 。该模式无专属的模式重定义或变量设置，因此 Emacs 的每个命令都会以最通用的方式执行，所有用户选项变量也均处于默认状态。
</p>

<p>
编辑 Emacs 可识别的特定类型文本（如 Lisp 代码、英文文本）时，通常会使用更专用的主模式，例如 Lisp mode、Text mode。绝大多数主模式可分为三大类：
</p>
<ul class="org-ul">
<li>第一类是适用于普通文本的模式，包含纯文本和带标记的文本，涵盖 Text mode、HTML mode、SGML mode、TeX mode和 Outline mode；</li>
<li>第二类是针对特定编程语言的模式，包括 Lisp mode（含多个变体）、C mode、Fortran mode等；</li>
<li>第三类是与文件无直接关联的主模式，这类模式用于 Emacs 为特定用途创建的缓冲区，例如 Dired 功能创建的缓冲区所使用的 Dired mode （参见「<a href="#Dired">目录编辑器 Dired</a>」章节）、快捷键 <code>C-x m</code> 在缓冲区所使用的Message mode （参见「<a href="#Sending-Mail">发送邮件</a>」章节）、用于与子 Shell 进程交互的缓冲区所使用的 Shell mode （参见「<a href="#Interactive-Shell">交互式子 Shell</a>」章节）。</li>
</ul>

<p>
通常，当你首次打开文件或创建缓冲区时，Emacs 会自动设置主模式（参见「<a href="#Choosing-Modes">选择文件模式</a>」章节）。你也可以通过 <code>M-x</code> 命令手动选择新的主模式：将模式名后加上 <code>-mode</code> ，即可得到对应模式的选择命令（例如，执行 <code>M-x lisp-mode</code> 即可进入 Lisp 模式）。由于每个缓冲区有且仅有一个主模式，因此不存在「关闭」主模式的操作，若需切换，只需更换为其他主模式即可。
</p>

<p>
缓冲区局部变量 <code>major-mode</code> 的取值为一个符号，该符号与对应主模式的命令名完全一致（例如 <code>lisp-mode</code> ）。此变量由 Emacs 自动设置， <b>请勿手动修改</b> 。
</p>

<p>
<code>major-mode</code> 的默认值决定了两类场景下使用的主模式：一是未指定主模式的文件，二是通过 <code>C-x b</code> 创建的新缓冲区。该变量的默认值通常为符号 <code>fundamental-mode</code> ，即对应基本模式。你可通过自定义界面修改此默认值（参见「<a href="#Easy-Customization">简易自定义界面</a>」章节），也可在初始化文件中添加如下语句实现修改（参见「<a href="#Init-File">Emacs 初始化文件</a>」章节）：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq-default</span> major-mode 'text-mode)
</pre>
</div>

<p>
若 <code>major-mode</code> 的默认值为 <code>nil</code> ，则新缓冲区会沿用前一个当前缓冲区的主模式。
</p>

<p>
专用主模式通常会重新定义部分按键的功能，使其更适配该模式的使用场景。例如，编程语言相关模式会将 <code>TAB</code> 键绑定为 <b>按对应语言的语法规则缩进当前行的功能</b> （参见「<a href="#Indentation">缩进</a>」章节）。常被重新定义的按键包括 <code>TAB</code> 、 <code>DEL</code> 和 <code>C-j</code> 。许多主模式还会自定义专属命令，这类命令通常绑定到以 <code>C-c</code> 为前缀的按键序列（参见「<a href="#Keys">按键</a>」章节）。主模式也可修改用户选项和变量，例如，编程语言模式通常会为变量 <code>comment-start</code> 设置缓冲区局部值，该变量用于定义源代码注释的分隔符规则（参见「<a href="#Comments">处理注释</a>」章节）。
</p>

<p>
若要查看当前主模式的说明文档（含其按键绑定列表），可按下 <code>C-h m</code> (<code>describe-mode</code>) ，相关内容亦可参见「<a href="#Misc-Help">其他帮助命令</a>」章节。
</p>

<p>
除 Fundamental mode基本模式外，所有主模式都定义了 <b><i>mode hook</i> 模式钩子</b> —— 这是一个可自定义的 Lisp 函数列表，每当该主模式在某个缓冲区中启用时，列表内的函数都会依次执行。关于钩子的更多信息，参见「<a href="#Hooks">钩子</a>」章节。各模式钩子均以对应主模式命名，例如 Fortran mode的钩子为 <code>fortran-mode-hook</code> 。此外，所有基于文本的主模式在执行自身模式钩子前，都会先执行 <code>text-mode-hook</code> ；多数编程语言模式<sup><a id="fnr.11" class="footref" href="#fn.11" role="doc-backlink">11</a></sup>（包括 Emacs 自带的所有编程语言模式），则会先执行 <code>prog-mode-hook</code> ，再执行自身模式钩子。钩子函数可通过读取变量 <code>major-mode</code> 的值，判断当前实际进入的是哪一个主模式。
</p>

<p>
模式钩子常被用于启用次模式（参见「<a href="#Minor-Modes">次模式</a>」章节）。例如，你可在初始化文件中添加以下语句，实现「在所有基于文本的主模式中启用 Flyspell mode拼写检查次模式」（参见「<a href="#Spelling">检查并修正拼写</a>」章节），以及「在 Emacs Lisp 模式中启用 EIDoc 文档实时提示次模式」（参见「<a href="#Programming-Language-Doc">编程语言文档查阅</a>」章节）：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'text-mode-hook 'flyspell-mode)
(add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
</pre>
</div>
</div>
</div>
<div id="outline-container-Minor-Modes" class="outline-3">
<h3 id="Minor-Modes"><span class="section-number-3">25.2.</span> 次模式</h3>
<div class="outline-text-3" id="text-Minor-Modes">
<p>
minor mode 次模式是一类可选的编辑模式，可按照明确定义的方式改变 Emacs 的操作行为。与主模式不同，任意时刻均可启用 <b>任意数量</b> 的次模式。部分次模式为 <b><i>buffer-local 缓冲区局部</i></b> 模式，可在特定缓冲区中开启（启用）、在其他缓冲区中关闭（禁用）；另一部分则为 <b><i>global 全局</i></b> 模式，一旦启用，会作用于 Emacs 会话中所有操作及全部缓冲区。多数次模式默认处于禁用状态，仅有少数次模式默认启用。
</p>

<p>
多数缓冲区局部次模式启用后，会在 mode line模式行的主模式标识后方显示自身状态。例如，模式行中的 '<code>Fill</code>' 表示 Auto Fill mode自动换行模式已启用，相关说明参见「<a href="#Mode-Line">模式行</a>」章节。
</p>

<p>
与主模式相同，每个次模式都对应一个 <b><i>mode command 模式命令</i></b> ，命令名为「模式名-mode」。例如，自动换行模式对应的命令为 <code>auto-fill-mode</code> 。但主模式命令仅用于启用对应模式，次模式命令则可实现启用与禁用的双向操作，规则如下：
</p>
<ul class="org-ul">
<li>无前缀参数直接调用次模式命令时（可通过 <code>M-x</code> 执行，或为命令绑定按键后敲击对应按键，参见「<a href="#Key-Bindings">自定义按键绑定</a>」章节），会 <b>切换</b> 该次模式状态：若原本禁用则启用，若原本启用则禁用。</li>

<li>带前缀参数调用次模式命令时，若参数为 0 或负数，会 <b>无条件禁用</b> 该次模式；若参数为正数，则 <b>无条件启用</b> 。</li>

<li>在 Lisp 代码中调用次模式命令时，若省略参数或参数为nil，会 <b>无条件启用</b> 该次模式（此设计便于在主模式的模式钩子中启用次模式，参见「<a href="#Major-Modes">主模式</a>」章节）；若参数为非nil值，则按上述交互式前缀参数的规则处理。</li>
</ul>

<p>
多数次模式还配有与模式命令同名的 <b><i>mode variable 模式变量</i></b> ：变量值为非nil表示次模式已启用，为 <code>nil</code> 则表示禁用。 <b>注意</b> ：请勿在 Lisp 代码中通过直接修改模式变量的值来启用 / 禁用次模式，应调用对应的模式命令；而通过自定义界面（参见「<a href="#Easy-Customization">简易自定义界面</a>」章节）设置模式变量时，会自动触发对应模式命令，确保次模式被正确启用 / 禁用。
</p>

<p>
以下为常用的 buffer-local 缓冲区局部次模式列表：
</p>
<ul class="org-ul">
<li>缩写模式（Abbrev mode）：根据预定义的缩写规则自动展开文本，参见「<a href="#Abbrevs">缩写</a>」章节。</li>
<li>自动换行模式（Auto Fill mode）：输入时自动插入换行符，防止行内容过长，参见「<a href="#Filling">文本换行</a>」章节。</li>
<li>自动保存模式（Auto Save mode）：定期保存缓冲区内容，减少程序崩溃时的工作丢失，参见「<a href="#Auto-Save">自动保存：应对意外故障</a>」章节。</li>
<li>智能引号模式（Electric Quote mode）：自动转换引号样式，例如将输入的 <code>`like this'</code> 自动转换为 <code>‘like this’</code> ；可自定义其生效的文本类型，也可在单个缓冲区中完全禁用，参见「<a href="#Quotation-Marks">引号</a>」章节。</li>
<li>富文本模式（Enriched mode）：支持编辑和保存带格式的文本，参见「<a href="#Enriched-Text">富文本</a>」章节。</li>
<li>拼写检查模式（Flyspell mode）：自动高亮拼写错误的单词，参见「<a href="#Spelling">检查并修正拼写</a>」章节。</li>
<li>语法高亮模式（Font-Lock mode）：自动高亮程序中的各类文本单元，该模式默认全局启用，也可在单个缓冲区中禁用，参见「<a href="#Faces">文本外观</a>」章节。</li>
<li>行号显示模式（Display Line Numbers mode）：是 <code>display-line-numbers</code> 功能的便捷封装，根据 <code>display-line-numbers-type</code> 的值设置行号显示规则，参见「<a href="#Display-Custom">显示自定义</a>」章节。</li>
<li>大纲次模式（Outline minor mode）：提供与大纲主模式（Outline mode）相似的功能，参见「<a href="#Outline-Mode">大纲模式</a>」章节。</li>
<li>覆盖模式（Overwrite mode）：输入普通打印字符时会替换原有文本，而非将原有文本后移。例如，光标位于 'FOOBAR' 中字母 'B' 前方时，开启该模式后输入 'G' 会得到 'FOOGAR'，而非默认的 'FOOGBAR' 。该模式下，命令 <code>C-q</code> 会插入后续任意字符（包括数字），可实现「插入字符而非替换原有字符」的操作。该模式的命令 <code>overwrite-mode</code> 绑定于 <code>Insert</code> 键。</li>
<li>二进制覆盖模式（Binary Overwrite mode）：覆盖模式的变体，适用于编辑二进制文件；将换行符、制表符视作普通字符，可被其他字符替换，也可替换其他字符。该模式下， <code>C-q</code> 后的数字仍按常规表示八进制字符编码。</li>
<li>视觉行模式（Visual Line mode）：按单词边界进行自动换行，使长行在单词之间折行显示，参见「<a href="#Visual-Line-Mode">视觉行模式</a>」章节。</li>
</ul>

<p>
以下为实用的全局次模式列表：
</p>
<ul class="org-ul">
<li>列号显示模式（Column Number mode）：在模式行中显示当前光标所在列号，参见「<a href="#Mode-Line">模式行</a>」章节。</li>
<li>选中删除模式（Delete Selection mode）：若选区处于激活状态，输入文本时会先删除选区内容，参见「<a href="#Using-Region">选区操作</a>」章节。</li>
<li>补全提示模式（Icomplete mode）：在迷你缓冲区中进行补全操作时，实时显示可用的补全选项，参见「<a href="#Icomplete">迷你缓冲区快速选择</a>」章节。</li>
<li>行号模式（Line Number mode）：在模式行中显示当前光标所在行号，默认启用，参见「<a href="#Mode-Line">模式行</a>」章节。</li>
<li>菜单栏模式（Menu Bar mode）：为每个框架添加菜单栏，默认启用，参见「<a href="#Menu-Bars">菜单栏</a>」章节。</li>
<li>滚动条模式（Scroll Bar mode）：为每个窗口添加滚动条，默认启用，仅在图形化终端中显示滚动条，参见「<a href="#Scroll-Bars">滚动条</a>」章节。</li>
<li>工具栏模式（Tool Bar mode）：为每个框架添加工具栏，默认启用，仅在图形化终端中显示工具栏，参见「<a href="#Tool-Bars">工具栏</a>」章节。</li>
<li>窗口工具栏模式（Window Tool Bar mode）：为每个窗口添加工具栏，参见「<a href="#Window-Tool-Bar">窗口工具栏</a>」章节。</li>
<li>标签栏模式（Tab Bar mode）：为每个框架添加标签栏，参见「<a href="#Tab-Bars">标签栏</a>」章节。</li>
<li>标签行模式（Tab Line mode）：为每个窗口添加标签行，参见「<a href="#Tab-Line">窗口标签行</a>」章节。</li>
<li>临时标记模式（Transient Mark mode）：高亮显示选区，且当标记处于激活状态时，让 Emacs 的多数命令作用于选区，默认启用，参见「<a href="#Mark">标记与选区</a>」章节</li>
</ul>
</div>
</div>
<div id="outline-container-Choosing-Modes" class="outline-3">
<h3 id="Choosing-Modes"><span class="section-number-3">25.3.</span> 选择文件模式</h3>
<div class="outline-text-3" id="text-Choosing-Modes">
<p>
访问文件时，Emacs 会自动为其选择一种 <b>主要模式</b> 。默认情况下，该选择基于文件名 —— 例如，后缀为 '<code>.c</code>' 的文件会默认使用 C mode 编辑；部分场景下，也会根据文件内的特殊文本选择主要模式，这类特殊文本也可用于启用 <b>buffer-local 缓冲区本地的次要模式</b> 。
</p>

<p>
Emacs 选择文件模式的具体流程如下：
</p>

<p>
<b>第一步：检查文件本地模式变量</b>
</p>

<p>
Emacs 会先检查文件中是否包含 <b>file-local mode文件本地模式变量</b> （参见《<a href="#File-Variables">文件中的本地变量</a>》章节）。若存在指定了主要模式的文件本地变量，Emacs 会直接使用该模式，忽略其他所有判断条件。通过文件本地变量指定主要模式的方法有多种， <b>最简方式</b> 是在文件的 <b>第一个非空行</b> 中，将模式名包裹在 '<code>-*-</code>' 之间，该行也可包含其他文本。例如：
</p>

<div class="org-src-container">
<pre class="src src-shell">; -*-Lisp-*-
</pre>
</div>

<p>
上述代码会告知 Emacs 使用 Lisp 模式。注意此处的分号是为了让 Lisp 将该行识别为注释，也可等价写为：
</p>

<div class="org-src-container">
<pre class="src src-shell">; -*- mode: Lisp;-*-
</pre>
</div>

<p>
也可通过 <code>eval</code> 规范 ，利用文件本地变量指定缓冲区本地的次要模式。例如，以下第一个非空行会将缓冲区设为 Lisp mode，并启用自动换行模式：
</p>

<div class="org-src-container">
<pre class="src src-shell">; -*- mode: Lisp; <span style="color: #483d8b;">eval</span>: (auto-fill-mode 1); -*-
</pre>
</div>

<p>
注意：通常不建议以这种方式启用次要模式，因为多数次要模式代表用户的个性化偏好。若你希望为特定文件类型启用某一次要模式，更推荐通过 <b>主要模式钩子</b> 实现（参见《<a href="#Major-Modes">主要模式</a>》章节）。
</p>

<p>
<b>第二步：检查目录本地的自动模式关联表</b>
</p>

<p>
Emacs 会检查文件后缀是否匹配任意目录本地的 <code>auto-mode-alist</code> 中的条目，该表通过 <code>.dir-locals.el</code> 工具实现（参见《<a href="#Directory-Variables">按目录划分的本地变量</a>》章节）。
</p>

<p>
<b>第三步：检查文件首行的 <code>#!</code> 标记</b>
</p>

<p>
若仍未确定主要模式，Emacs 会检查文件内容是否以 <code>#!</code> 开头。该标记表示此文件是可执行的 Shell 命令，系统会通过文件首行指定的解释器运行该文件（文件其余内容作为解释器的输入）。因此，Emacs 会尝试通过解释器名称选择模式。例如，首行为 '<code>#!/usr/bin/perl</code>' 的文件会以 Perl mode 打开。解释器程序名与主要模式的对应关系，由变量 <code>interpreter-mode-alist</code> 定义。
</p>

<p>
若文件首行以 <code>#!</code> 开头，通常无法在首行使用 '-*-' 标记（否则系统运行解释器时会出现解析错误）。
</p>
<ul class="org-ul">
<li>因此，这类文件中，Emacs 会同时在第一行和第二行查找 '-*-' 标记。</li>
<li>手册页（man page）也存在类似情况：其首行通常以魔术字符串 <code>'\"</code> 开头，用于指定 troff 预处理器列表，这类文件同样会在第二行查找 '-*-' 标记。</li>
</ul>

<p>
<b>第四步：通过 <code>magic-mode-alist</code> 匹配缓冲区首文本</b>
</p>

<p>
Emacs 会基于 <code>magic-mode-alist</code> 变量，通过检查 <b>缓冲区开头的文本内容</b> 来判定主要模式。该变量的默认值为 <code>nil</code> （空列表），因此 Emacs 会跳过此步骤；你可在初始化文件中对其进行自定义配置（参见《<a href="#Init-File">Emacs 初始化文件</a>》章节）。该变量的值需为若干指定格式的元素组成的列表。元素格式有两种：
</p>

<ul class="org-ul">
<li><p>
正则表达式格式： <code>(regexp . mode-function)</code>
</p>

<p>
其中 <i>regexp</i> 为正则表达式（参见《<a href="#Regexps">正则表达式的语法</a>》）， <i>mode-function</i> 为主要模式命令。若文件开头的文本匹配该正则表达式，Emacs 会使用 <i>mode-function</i> 指定的主要模式。
</p></li>

<li><p>
函数匹配格式： <code>(match-function . mode-function)</code>
</p>

<p>
其中 <i>match-function</i> 为 Lisp 函数，Emacs 会在缓冲区开头调用该函数；若函数返回非 nil 的值，则使用 <i>mode-function</i> 设置主要模式。
</p></li>
</ul>

<p>
<b>第五步：根据文件名匹配自动模式关联表</b>
</p>

<p>
若仍未找到合适的主要模式，Emacs 会最终通过 <b>文件名</b> 判断，文件名与主要模式的对应关系由变量 <code>auto-mode-alist</code> 控制。该变量的值为列表，每个元素有两种格式：
</p>
<ul class="org-ul">
<li>基础格式： <code>(regexp . mode-function)</code></li>
<li>扩展格式： <code>(regexp mode-function flag)</code></li>
</ul>

<p>
例如，该列表中默认包含条目 <code>("\\.c\\'" . c-mode)</code> ，用于为后缀为 <code>.c</code> 的文件选择 C mode 。（注意：Lisp 语法中，需用 '<code>\\</code>' 表示字符串中的 '<code>\</code>'，而正则表达式中需用 '<code>\</code>' 取消 '<code>.</code>' 的特殊含义。）
</p>

<p>
若元素为扩展格式 <code>(regexp mode-function flag)</code> 且 <i>flag</i> 为非 nil，则 Emacs 调用 <i>mode-function</i> （若其非 nil）后，会 <b>舍弃匹配正则表达式的文件后缀</b> ，并重新遍历列表查找新的匹配项。这种「递归剥离后缀」的机制，适用于多后缀文件—— 此类文件的「外层后缀」会掩盖实际指定模式的「内层后缀」，例如备份文件、后缀为 .gpg 的 GPG 加密文件均使用该特性。
</p>

<p>
在 GNU/Linux 等区分文件名大小写的系统中，Emacs 会先对 <code>auto-mode-alist</code> 进行区分大小写的查找；若查找失败，会再次进行不区分大小写的查找。若要关闭第二次查找，可将变量 <code>auto-mode-case-fold</code> 设为 nil。
</p>

<p>
在微软 Windows 等不区分文件名大小写的系统中，Emacs 仅对 <code>auto-mode-alist</code> 进行一次不区分大小写的查找。
</p>

<p>
<b>第六步：通过 <code>magic-fallback-mode-alist</code> 表匹配</b>
</p>

<p>
若以上所有步骤均未找到主要模式，Emacs 会将缓冲区开头的文本与变量 <code>magic-fallback-mode-alist</code> 进行匹配。
</p>

<p>
该变量的工作方式与  <code>magic-mode-alist</code> 一致，唯一区别是仅在 <code>auto-mode-alist</code> 匹配失败后才会被调用。其默认值包含用于识别图片文件、HTML/XML/SGML 文件、PostScript 文件和Unix 风格配置文件的规则。
</p>

<p>
<b>主要模式的重映射</b>
</p>

<p>
当 Emacs 找到某一主要模式后，会做最后一次检查：该模式是否被 <code>major-mode-remap-alist</code> 重映射。若存在重映射，则使用重映射后的模式。该机制适用于 <b>同一种文件类型可对应多种主要模式</b> 的场景，方便用户指定偏好的模式。注意：该重映射会影响上述所有方法找到的主要模式 —— 例如，文件首行指定的模式，未必是最终在访问该文件的缓冲区中启用的模式（该重映射也会影响 <code>revert-buffer</code> 命令，参见《<a href="#Reverting">恢复缓冲区</a>》章节）。
</p>

<p>
若某一文件类型有多种可选模式，可通过自定义 <code>major-mode-remap-alist</code> 告知 Emacs 你的偏好。例如，在 <code>~/.emacs</code> 初始化文件中添加以下代码（参见《<a href="#Init-File">Emacs 初始化文件</a>》章节）：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-to-list 'major-mode-remap-alist '(c-mode . c-ts-mode))
</pre>
</div>

<p>
可强制 Emacs 在 <code>auto-mode-alist</code> 或文件本地变量指定 <code>c-mode</code> 时，调用 <code>c-ts-mode</code> 。反之，添加：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-to-list 'major-mode-remap-alist '(c-mode))
</pre>
</div>

<p>
可强制 Emacs 永远不将 <code>c-mode</code> 重映射为其他模式。
</p>

<p>
<code>major-mode-remap-alist</code> 的默认值为 <code>nil</code> ，即无重映射。但加载部分 Lisp 包或功能时，可能会自动引入模式重映射（Emacs 会默认认为，加载这些包代表用户偏好使用替代模式）。因此，为了让 Emacs 行为可预测，建议始终自定义 <code>major-mode-remap-alist</code> 明确你的偏好—— 该变量会覆盖 Emacs 内部的所有重映射规则。
</p>

<p>
<b>恢复默认主要模式： <code>normal-mode</code> 命令</b>
</p>

<p>
若你手动修改了缓冲区的主要模式，可键入 <code>M-x normal-mode</code> ，让 Emacs 恢复为其自动选择的主要模式。 <code>find-file</code> 命令选择主要模式时，调用的正是该函数。
</p>
<ul class="org-ul">
<li>若缓冲区正在访问某一文件，该命令还会处理文件的 '-*-' 行和文件本地变量列表（若有）；参考 <a href="#File-Variables">文件本地变量</a></li>
<li>若缓冲区未访问任何文件，该命令仅处理 '-*-' 行和文件本地变量列表中的主要模式规范（若有）。</li>
</ul>

<p>
<code>normal-mode</code> 会考虑模式重映射 —— 若在 Emacs 选择缓冲区的主要模式后，你自定义了 <code>Major-mode-remap-alist</code> ，该命令可能会启用与 Emacs 初始选择不同的模式。
</p>

<p>
<b>文件名变更时的模式自动切换</b>
</p>

<p>
<code>C-x C-w</code> 和 <code>set-visited-file-name</code> 命令若修改了文件名，且新文件名对应某一主要模式，Emacs 会自动切换至该模式（参见《<a href="#Saving">保存文件</a>》章节）；若缓冲区原本未访问任何文件， <code>C-x C-s</code> 命令也会触发此行为。例外情况：若缓冲区内容已通过特殊文本指定了主要模式，或当前为部分特殊主要模式（不允许模式变更），则不会触发自动切换。若要关闭该特性，可将变量 <code>change-major-mode-with-file-name</code> 设为 <code>nil</code> 。
</p>
</div>
</div>
</section>
<section id="outline-container-Indentation" class="outline-2">
<h2 id="Indentation"><span class="section-number-2">26.</span> 缩进</h2>
<div class="outline-text-2" id="text-Indentation">
<p>
<i>Indentation 缩进</i> 指在文本行开头插入或调整 <i>whitespace characters 空白字符</i> （空格和 / 或制表符）。本章介绍 Text mode及相关模式与编程语言模式通用的缩进命令和配置项。关于编程模式下的缩进相关额外说明，参见《<a href="#Program-Indent">程序缩进</a>》章节。
</p>

<p>
实现缩进最简便的方式是按下 <code>TAB</code> 键。在大多数主要模式中，按下该键会执行 <code>indent-for-tab-command</code> 命令（在 C 语言及相关模式中， <code>TAB</code> 键执行 <code>c-indent-line-or-region</code> 命令，其行为与之类似，参见《<a href="#C-Indent">C 语言缩进命令</a>》章节）。
</p>

<dl class="org-dl">
<dt><code>TAB</code></dt><dd>以适配当前模式的方式插入空白字符，或为当前行执行缩进 (<code>indent-for-tab-command</code>) 。若区域处于激活状态，则为区域内所有行执行缩进。</dd>
</dl>

<p>
<code>TAB</code> 键的具体行为由当前主要模式决定：在文本模式及相关主要模式中， <code>TAB</code> 键通常会插入若干空格和制表符的组合，将光标移动至下一个制表位（参见《<a href="#Tab-Stops">制表位</a>》章节）。在此模式下，上一行首个非空白字符的位置会被视作一个额外的制表位，因此你可通过 <code>TAB</code> 键让光标与上一行对齐。若区域处于激活状态（参见《<a href="#Using-Region">区域操作</a>》章节）， <code>TAB</code> 键会执行特殊行为：为区域内每一行缩进，使各行首个非空白字符与上一行对齐。
</p>

<p>
在编程模式中， <code>TAB</code> 键会根据前序代码的结构，为当前代码行执行符合语法逻辑的缩进。若区域处于激活状态，则为区域内所有行执行该缩进操作。若光标初始位置处于当前行的缩进空白段内，执行该命令后光标会被重新定位至该行首个非空白字符处。
</p>

<p>
若你仅需在缓冲区中插入一个制表符，可键入 <code>C-q TAB</code> （参见《<a href="#Inserting-Text">插入文本</a>》章节）。
</p>

<ul class="org-ul">
<li><a href="#Indentation-Commands">缩进命令</a></li>
<li><a href="#Tab-Stops">制表位</a></li>
<li><a href="#Just-Spaces">制表符与空格的选择</a></li>
<li><a href="#Indent-Convenience">缩进的便捷功能</a></li>
<li><a href="#Code-Alignment">代码对齐</a></li>
</ul>
</div>
<div id="outline-container-Indentation-Commands" class="outline-3">
<h3 id="Indentation-Commands"><span class="section-number-3">26.1.</span> 缩进命令</h3>
<div class="outline-text-3" id="text-Indentation-Commands">
<p>
除 <code>TAB</code> 制表键 (<code>indent-for-tab-command</code>) 外，Emacs 还提供多种命令，以其他方式实现缩进操作。
</p>

<dl class="org-dl">
<dt><code>C-M-o</code></dt><dd>在光标位置拆分当前行 (<code>split-line</code>) 。光标后的行内文本将成为新行，且缩进至光标所在的列位置。该命令会先将光标向前移动，跳过所有空格和制表符；拆分完成后，光标将停在插入的换行符之前。</dd>
<dt><code>M-m</code></dt><dd>将光标移至当前行第一个非空白字符处 (<code>back-to-indentation</code>) 。若当前行无任何非空白字符，则将光标移至行尾。</dd>
<dt><code>M-i</code></dt><dd>在光标位置插入空白字符，直至下一个制表位 (<code>tab-to-tab-stop</code>) ，详见<a href="#Tab-Stops">制表位</a>章节。</dd>
<dt><code>M-x indent-relative</code></dt><dd>在光标位置插入空白字符，直至光标与上一行（实际为最后一个非空行）的第一个非空白字符对齐。若光标原本已在该位置右侧，则执行 <code>tab-to-tab-stop</code> 命令；若带数字参数调用此命令，则不执行任何操作。</dd>
<dt><code>M-^</code></dt><dd><p>
合并上一行与当前行 (<code>delete-indentation</code>) 。该命令会将当前行开头的所有缩进字符及行分隔符替换为单个空格，实现两行的整洁合并。
</p>

<p>
特殊情况（适用于 Lisp 代码）：若待合并的字符为连续的左右括号，或合并位置紧跟另一个换行符，则省略上述的单个空格。
</p>

<p>
若当前设置了填充前缀，当被删除的换行符后紧跟填充前缀时， <code>M-^</code> 会同时删除该填充前缀，详见<a href="#Fill-Prefix">填充前缀</a>章节。
</p>

<p>
带前缀参数调用此命令时，将合并当前行与下一行；若区域处于激活状态且未带前缀参数，则合并该区域内的所有行。
</p></dd>
<dt><code>C-M-\</code></dt><dd><p>
缩进区域内的所有行，效果等同于在每行行首按下 <code>TAB</code> 制表键 (<code>indent-region</code>) 。
</p>

<p>
若带数字参数调用，将把区域内所有行统一缩进至该数字指定的列数。
</p></dd>
<dt><code>C-x TAB</code></dt><dd><p>
缩进所有起始于该区域的行，受影响的行将作为一个整体进行刚性移动 (<code>indent-rigidly</code>) 。
</p>

<p>
无参数调用此命令时，将激活一个临时模式，可交互式调整受影响行的缩进：临时模式激活期间，按左方向键/右方向键可分别向左 / 向右缩进 1 个空格；也可按 <code>S-LEFT</code> / <code>S-RIGTH</code> ，向左 / 向右缩进至下一个制表位（详见<a href="#Tab-Stops">制表位</a>章节）。按下其他任意按键，将退出该临时模式，且该按键会按常规功能执行。
</p>

<p>
带前缀参数 <code>n</code> 调用此命令时，将把目标行向前缩进 <code>n</code> 个空格（不激活临时模式）； <code>n</code> 为负值时则向后缩进，因此可使用一个绝对值较大的负值，移除区域内所有行的缩进，示例操作： <code>C-u -999 C-x TAB</code>
</p></dd>
</dl>
</div>
</div>
<div id="outline-container-Tab-Stops" class="outline-3">
<h3 id="Tab-Stops"><span class="section-number-3">26.2.</span> 制表位</h3>
<div class="outline-text-3" id="text-Tab-Stops">
<p>
Emacs 会定义特定的列号作为 <i>tab stop 制表位</i> 。在文本模式及相关模式下插入空白符时，制表键（ <code>TAB</code> ）会将光标停在这些位置（参见<a href="#Indentation">缩进</a>相关说明）， <code>M-i</code> 这类缩进命令也会遵循该规则（参见<a href="#Indentation-Commands">缩进命令</a>相关说明）。制表位的位置由变量 <code>tab-stop-list</code> 控制，其默认值为 <code>nil</code> ，代表每 8 列设置一个制表位。该变量也可设为一个 <b>从零开始计数</b> 的列号列表（按升序排列），列表中的列号即为制表位的位置。Emacs 会取列表中最后一个元素与倒数第二个元素的差值，以此为间隔无限延伸该制表位列表。
</p>

<p>
无需直接自定义 <code>tab-stop-list</code> 变量，Emacs 提供了更便捷的制表位查看与设置方式：执行命令 <code>M-x edit-tab-stops</code> 。该命令会打开一个专用缓冲区，用于展示当前制表位的设置情况，缓冲区内容格式如下：
</p>

<div class="org-src-container">
<pre class="src src-shell">        :       :       :       :       :       :
0         1         2         3         4
0123456789012345678901234567890123456789012345678
To install changes, type C-c C-c
</pre>
</div>

<p>
第一行的冒号（:）对应每个制表位的位置，下方两行的数字仅用于标示冒号所在的列数。若 <code>tab-stop-list</code> 为默认值 nil，该缓冲区初始状态下将不显示任何冒号。
</p>

<p>
你可在该缓冲区中编辑制表位：在需要设置制表位的列位置输入冒号即可，此缓冲区默认启用 Overwrite mode改写模式（参见<a href="#Minor-Modes">次要</a>模式）。需注意，Emacs 会以你手动设置的最后两个显式制表位的差值为步长，无限延伸后续的制表位。编辑完成后，按下 <code>C-c C-c</code> 即可使新的制表位设置生效。默认情况下，新的制表位设置会应用于所有缓冲区；但如果你已将 <code>tab-stop-list</code> 设为调用 <code>M-x edit-tab-stops</code> 时所在缓冲区的局部变量（参见<a href="#Locals">局部变量</a>），则新设置仅对该缓冲区生效。若要将制表位设置保存至后续的 Emacs 会话，可通过自定义界面（Customize）保存 <code>tab-stop-list</code> 的值（参见<a href="#Easy-Customization">简易自定义界面</a>）。
</p>

<p>
注意：本节所讲的制表位，与缓冲区中制表符（tab 字符）的显示方式无任何关联。制表符在显示时，始终会以空白字符的形式填充至 <b>下一个显示制表位</b> ，具体规则参见<a href="#Text-Display">文本的显示方式</a>相关内容。
</p>
</div>
</div>
<div id="outline-container-Just-Spaces" class="outline-3">
<h3 id="Just-Spaces"><span class="section-number-3">26.3.</span> 制表符与空格的选择</h3>
<div class="outline-text-3" id="text-Just-Spaces">
<p>
默认情况下，缩进命令会插入（或删除） <b>最短的制表符与空格组合</b> ，使光标对齐至目标列。制表符在显示时会以一段空白的形式呈现，直至下一个显示制表位。默认配置下，每 <code>tab-width</code> 列会设置一个显示制表位（该变量默认值为 8），详见《<a href="#Text-Display">文本的显示方式</a>》。
</p>

<p>
若需要，可将所有缩进统一设置为仅使用空格实现：将 <i>buffer-local 缓冲区局部</i> 变量 <code>indent-tabs-mode</code> 设为 <code>nil</code> 即可。关于缓冲区局部变量的设置方法，详见《<a href="#Locals">局部变量</a>》章节。需注意，无论 <code>indent-tabs-mode</code> 的取值如何，按下 <code>C-q TAB</code> 始终会插入一个制表符。
</p>

<p>
将 <code>indent-tabs-mode</code> 设为 <code>nil</code> 的一个重要原因是：不同编辑器对制表符的显示规则不一致，即便是 Emacs 用户，也可能为 <code>tab-width</code> 配置不同的自定义值。仅使用空格进行缩进，可确保文件在任意编辑器中显示的缩进格式完全一致。如果仅关注文件在 Emacs 中的显示效果，也可通过 <b><i>file-local variable文件局部变量</i></b> 设置 <code>tab-width</code> 来解决该问题（详见《<a href="#File-Variables">文件中的局部变量</a>》）。
</p>

<p>
Emacs 也提供了制表符与空格的互转命令，且转换过程中 <b>始终保留所有非空白文本的列位置不变</b> ：
</p>
<ul class="org-ul">
<li><code>M-x tabify</code> ：扫描指定区域内的空格序列，若转换后不会改变缩进效果，会将连续至少两个空格的序列转换为制表符；</li>
<li><code>M-x untabify</code> ：将指定区域内的所有制表符，转换为对应数量的空格。</li>
</ul>
</div>
</div>
<div id="outline-container-Indent-Convenience" class="outline-3">
<h3 id="Indent-Convenience"><span class="section-number-3">26.4.</span> 缩进的便捷功能</h3>
<div class="outline-text-3" id="text-Indent-Convenience">
<p>
变量 <code>tab-always-indent</code> 可调整制表键 (<code>indent-for-tab-command</code>) 的行为。其默认值为 <code>t</code> ，此时制表键将遵循「<a href="#Indentation">缩进</a>」章节中描述的默认缩进行为。若将该值改为符号 <code>complete</code> ，制表键会先尝试缩进当前行；若当前行已完成缩进，则会尝试补全光标处的文本（参见《<a href="#Symbol-Completion">符号名的补全</a>》）。若该值设为 <code>nil</code> ，则仅当光标位于左边界或当前行的缩进区域内时，制表键才会缩进当前行；其余情况下，制表键将直接插入一个制表符。
</p>

<p>
当 <code>tab-always-indent</code> 设为 <code>complete</code> 时，制表键优先执行补全还是缩进，可通过变量 <code>tab-first-completion</code> 进一步自定义。例如，若将该变量设为 <code>eol</code> ，则仅当光标位于行尾时，制表键才会执行文本补全。更多细节可参见《Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Mode_002dSpecific-Indent.html#Mode_002dSpecific-Indent">模式专属缩进</a>」章节。
</p>

<p>
Electric Indent mode 是一个全局次要模式，开启后按下回车键（ <code>RET</code> ）会自动缩进新行，该模式默认启用。按下 <code>M-x electric-indent-mode</code> 可切换该全局模式的开关；若仅需在单个缓冲区中切换，可使用命令 <code>M-x electric-indent-local-mode</code> 。
</p>
</div>
</div>
<div id="outline-container-Code-Alignment" class="outline-3">
<h3 id="Code-Alignment"><span class="section-number-3">26.5.</span> 代码对齐</h3>
<div class="outline-text-3" id="text-Code-Alignment">
<p>
<i>Alignment 对齐</i> 是指调整区域内多行文本的空白符，使所有行中特定内容均从同一列开始的操作。该操作通常用于提升文本或代码的可读性，典型示例为对类 C 编程语言中的一系列赋值语句进行对齐：
原始代码：
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #228b22;">int</span> <span style="color: #a0522d;">a</span> = 1;
<span style="color: #228b22;">short</span> <span style="color: #a0522d;">foo</span> = 2;
<span style="color: #228b22;">double</span> <span style="color: #a0522d;">blah</span> = 4;
</pre>
</div>

<p>
对齐后通常为：
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #228b22;">int</span>    <span style="color: #a0522d;">a</span>    = 1;
<span style="color: #228b22;">short</span>  <span style="color: #a0522d;">foo</span>  = 2;
<span style="color: #228b22;">double</span> <span style="color: #a0522d;">blah</span> = 4;
</pre>
</div>

<p>
可使用命令 <code>M-x align</code> 对当前区域内的行进行对齐，该命令适配多种标记语言和编程语言的通用对齐模式，并将这些模式编码为一套 <b><i>alignment rules 对齐规则</i></b> ，定义了不同上下文下各类文本的对齐方式。
</p>

<p>
用户选项 <code>align-rules-list</code> 指定了 <code>M-x align</code> 需参考的对齐规则，其值为一个描述对齐规则的元素列表。每个元素均为一个点对 <code>(title . attributes)</code> ：其中 <b><i>title</i></b> 为符号类型的对齐规则名称， <b><i>attributes</i></b> 为规则属性列表，用于定义规则的生效条件，以及对行的拆分和对齐方式。每个规则属性也是一个点对 <code>(attribute . value)</code> ，唯一的必选 <b><i>attribute</i></b> 为 <code>regexp</code> ， <b><i>value</i></b> 为一个正则表达式，通过子表达式匹配每行中需要 <code>M-x align</code> 增减空白符的位置（参见《<a href="#Regexp-Backslash">正则表达式中的反斜杠</a>》）。关于对齐规则属性的完整说明，可查看 <code>align-rules-list</code> 的文档字符串  (<code>C-h v align-rules-list RET</code>) 。该选项默认配置了一长串适配 Emacs 所支持的多种语言的对齐规则，且默认规则通过 <code>modes</code> 规则属性指定了 <code>M-x align</code> 的生效主模式。主模式也可通过将缓冲区局部变量 <code>align-mode-rules-list</code> 设为非空的对齐规则列表，来覆盖 <code>align-rules-list</code> 的配置；当 <code>align-mode-rules-list</code> 为非空值时， <code>M-x align</code> 将优先参考该变量，而非 <code>align-rules-list</code> 。
</p>

<p>
除对齐规则外， <code>M-x align</code> 还会使用另一类 <b><i>exclusion rules 排除规则</i></b> ，用于指定区域内无需对齐、需保持原样的内容。用户选项 <code>align-exclude-rules-list</code> 定义了这些排除规则，其值同样为描述排除规则的点对列表，与 <code>align-rules-list</code> 格式一致。该选项默认包含了对 Lisp、C 等语言中 <b>字符串常量</b> 和 <b>注释</b> 的对齐排除规则。除 <code>align-exclude-rules-list</code> 中的默认排除规则外，主模式还可通过将 <code>align-mode-exclude-rules-list</code> 设为非空的规则列表，定义自定义排除规则；该变量对 <code>align-exclude-rules-list</code> 的覆盖方式，与 <code>align-mode-rules-list</code> 对 <code>align-rules-list</code> 的覆盖方式一致。
</p>

<p>
<code>M-x align</code> 会将目标区域拆分为多个 <b><i>sections 分段</i></b> （通常为连续的非空行），并通过增减空白符，按照所有匹配的对齐规则对每个分段分别对齐。该命令会保证单个分段内的所有行对齐方式一致，但同一区域内的不同分段可能采用不同的对齐方式。用户选项 <code>align-region-separate</code> 指定了 <code>M-x align</code> 拆分区域为分段的方式，其值可为符号 <code>entire</code> 、 <code>group</code> ，或一个正则表达式：
</p>

<ul class="org-ul">
<li>若值为 <code>entire</code> ，Emacs 会将整个区域作为一个分段进行对齐；</li>
<li>若值为 <code>group</code> ，Emacs 会将区域内每组连续的非空行分别作为独立分段；</li>
<li>若值为正则表达式， <code>M-x align</code> 会扫描区域中匹配该表达式的内容，将其作为分段分隔符。</li>
</ul>

<p>
该选项默认设为一个正则表达式，可匹配 <b>空行</b> ，以及仅包含空白符和单个大括号（'<code>{</code>' 或 '<code>}</code>'）的行。若正则表达式无法满足精准拆分的特殊场景，也可将 <code>align-region-separate</code> 设为一个函数，由该函数定义区域到对齐分段的拆分规则，更多细节可查看其文档字符串。特定的对齐规则还可通过指定 <code>separate</code> 规则属性，覆盖 <code>align-region-separate</code> 的取值，定义专属的分段分隔符。
</p>

<p>
若带前缀参数调用 <code>M-x align</code> （快捷键 <code>C-u M-x align</code> ），该命令会启用更多对齐规则 —— 这些规则通常实用，但有时可能会产生过度对齐的效果。例如，在 Lisp 缓冲区中有如下代码：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(set-face-attribute 'mode-line-inactive nil
                    <span style="color: #483d8b;">:box</span> nil
                    <span style="color: #483d8b;">:background</span> nil
                    <span style="color: #483d8b;">:underline</span> <span style="color: #8b2252;">"black"</span>)
</pre>
</div>

<p>
执行 <code>C-u M-x align</code> 后将得到：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(set-face-attribute 'mode-line-inactive nil
                    <span style="color: #483d8b;">:box</span>                nil
                    <span style="color: #483d8b;">:background</span>         nil
                    <span style="color: #483d8b;">:underline</span>          <span style="color: #8b2252;">"black"</span>)
</pre>
</div>

<p>
多数情况下，应先直接调用 <code>M-x align</code> （不带前缀参数）；若结果不符合预期，可通过 <code>C-/</code> 撤销操作，再尝试带前缀参数的 <code>C-u M-x align</code> 。
</p>

<p>
可使用命令 <code>M-x align-highlight-rule</code> ，在当前区域中可视化特定对齐规则或排除规则的作用效果。该命令会提示你输入规则标题，并高亮显示区域内受该规则影响的内容：对对齐规则，会高亮 <code>M-x align</code> 将增减的空白符；对排除规则，会高亮 <code>M-x align</code> 将跳过对齐的内容。若要清除该命令的高亮效果，执行 <code>M-x align-unhighlight-rule</code> 即可。
</p>

<p>
命令 <code>M-x align-current</code> 与 <code>M-x align</code> 功能类似，区别在于：无论当前是否选中区域，该命令仅对 <b>包含光标</b> 的对齐分段生效，其会根据 <code>align-region-separate</code> 定义的分段分隔符，确定当前分段的边界。 <code>M-x align-entire</code> 是 <code>M-x align</code> 的另一个变体，该命令会忽略 <code>align-region-separate</code> 的配置，将整个区域作为单个对齐分段进行统一对齐。若将 <code>align-region-separate</code> 设为 <code>entire</code> ， <code>M-x align</code> 的默认行为将与 <code>M-x align-entire</code> 一致。
</p>

<p>
以下示例可说明将整个区域作为单个分段对齐的效果，原始代码：
</p>

<div class="org-src-container">
<pre class="src src-C">one = 1;
foobarbaz = 2;

spam = 3;
emacs = 4;
</pre>
</div>

<p>
若选中所有行并执行 <code>M-x align</code> ，结果为：
</p>

<div class="org-src-container">
<pre class="src src-C">one       = 1;
foobarbaz = 2;

spam  = 3;
emacs = 4;
</pre>
</div>

<p>
而执行 <code>M-x align-entire</code> 时，所有行被作为单个分段对齐，所有等号 '<code>=</code>' 将出现在同一列：
</p>

<div class="org-src-container">
<pre class="src src-C">one       = 1;
foobarbaz = 2;

spam      = 3;
emacs     = 4;
</pre>
</div>

<p>
命令 <code>M-x align-regexp</code> 允许你通过 <b>自定义临时对齐规则</b> 对当前区域进行对齐，而非使用 <code>align-rules-list</code> 中的预定义规则。该命令会提示你输入一个正则表达式，并将该表达式作为临时对齐规则的 <code>regexp</code> 属性，用于区域对齐。默认情况下，该命令会调整匹配你所指定正则表达式 <b>第一个子表达式</b> 的空白符；若带前缀参数调用 <code>M-x align-regexp</code> ，其还会提示你指定待使用的子表达式、设置对齐的空白符填充量，以及是否对每行中所有匹配该正则表达式的内容重复应用该规则。关于正则表达式及其子表达式的更多信息，参见《<a href="#Regexp-Backslash">正则表达式中的反斜杠</a>》。
</p>

<p>
若用户选项 <code>align-indent-before-aligning</code> 为非空值，Emacs 会在执行 <code>M-x align</code> 对齐区域前，先对该区域进行缩进处理（参见《<a href="#Indentation">缩进</a>》章节），该选项默认值为 <code>nil</code> 。
</p>

<p>
用户选项 <code>align-to-tab-stop</code> 用于指定对齐后的内容是否从制表位开始（参见《<a href="#Tab-Stops">制表位</a>》章节）：
</p>
<ul class="org-ul">
<li>若值为 <code>nil</code> ， <code>M-x align</code> 仅使用满足对齐需求的最少空白符，忽略制表位；</li>
<li>若值为非空符号， <code>M-x align</code> 会检查该符号的取值，若其值为非空，则按制表位进行对齐。</li>
</ul>

<p>
该选项默认设为 <code>indent-tabs-mode</code> ，因此在使用制表符进行缩进的缓冲区中，对齐操作会遵循制表位的配置（参见《<a href="#Just-Spaces">制表符与空格</a>》章节）。
</p>

<p>
用户选项 <code>align-default-spacing</code> 指定了 <code>M-x align</code> 及其相关命令在对齐时，为每行不同内容之间填充的默认空白符数量：
</p>
<ul class="org-ul">
<li>当 <code>align-to-tab-stop</code> 为 <code>nil</code> 时，该值为填充的空格数；</li>
<li>当 <code>align-to-tab-stop</code> 为非空值时，该值为填充的制表位数量。</li>
</ul>

<p>
各对齐规则可通过 <code>spacing</code> 规则属性，覆盖 <code>align-default-spacing</code> 设置的默认值。
</p>
</div>
</div>
</section>
<section id="outline-container-Text" class="outline-2">
<h2 id="Text"><span class="section-number-2">27.</span> 自然语言相关命令</h2>
<div class="outline-text-2" id="text-Text">
<p>
本章介绍 Emacs 中用于处理 <i>text 文本</i> 的命令，此处的文本指自然语言的字符序列（而非计算机编程语言的字符序列）。这类命令的执行逻辑会兼顾自然语言的句法与格式规范，包括与单词、句子、段落及大写字母相关的各类规则。Emacs 也提供 <i>filling填充</i> 相关命令，即重新调整段落的行排版，使各行长度大致均等。这些命令虽主要为文本编辑设计，在程序代码编辑中也同样常用。
</p>

<p>
Emacs 提供了多种适用于自然语言文本编辑的主模式：若编辑普通纯文本文件，可使用 <b>Text mode文本模式</b> ，该模式会针对自然语言的句法规范，对 Emacs 做轻量定制； * Outline mode大纲模式* 则为编辑大纲结构的文本提供了专属操作命令，详见《<a href="#Outline-Mode">大纲模式</a>》章节。
</p>

<p>
<b>Org mode</b> 是大纲模式的拓展，可将 Emacs 变为功能完善的事务管理工具：你可通过该模式管理待办清单、记录笔记，并将笔记导出为多种格式。相关用法详见 Emacs 自带的《Org 信息手册》。
</p>

<p>
针对包含嵌入式命令的特殊文本，Emacs 也提供了对应的专用主模式，包括 TeX 与 LaTeX 模式（详见《<a href="#TeX-Mode">TeX 模式</a>》）、HTML 与 SGML 模式（详见《<a href="#HTML-Mode">SGML 和 HTML 模式</a>》）、XML 模式（详见 Emacs 自带的《nXML 模式信息手册》），以及 Groff 与 Nroff 模式（详见《<a href="#Nroff-Mode">Nroff 模式</a>》）。
</p>

<p>
若需编辑由文本字符构成的 ASCII 绘图，可使用 <b>Picture mode图片模式</b> —— 这是为编辑此类绘图专门设计的主模式，详见《<a href="#Picture-Mode">编辑字符绘图</a>》章节。
</p>

<ul class="org-ul">
<li><a href="#Words">单词操作</a></li>
<li><a href="#Sentences">句子操作</a></li>
<li><a href="#Paragraphs">段落操作</a></li>
<li><a href="#Pages">页面操作</a></li>
<li><a href="#Quotation-Marks">引号处理</a></li>
<li><a href="#Filling">文本填充</a></li>
<li><a href="#Case">大小写转换命令</a></li>
<li><a href="#Text-Mode">文本模式</a></li>
<li><a href="#Outline-Mode">大纲模式</a></li>
<li><a href="#Org-Mode">组织模式（Org Mode）</a></li>
<li><a href="#TeX-Mode">TeX 模式</a></li>
<li><a href="#HTML-Mode">SGML 与 HTML 模式</a></li>
<li><a href="#Nroff-Mode">Nroff 模式</a></li>
<li><a href="#Enriched-Text">富文本</a></li>
<li><a href="#Text-Based-Tables">文本表格编辑</a></li>
<li><a href="#Two_002dColumn">双列编辑</a></li>
</ul>
</div>
<div id="outline-container-Words" class="outline-3">
<h3 id="Words"><span class="section-number-3">27.1.</span> 单词操作</h3>
<div class="outline-text-3" id="text-Words">
<p>
Emacs 定义了多个用于单词移动和单词操作的命令：
</p>

<dl class="org-dl">
<dt><code>M-f</code></dt><dd>向前移动一个单词 (<code>forward-word</code>) 。(PS: 向前指光标右边)</dd>
<dt><code>M-b</code></dt><dd>向后移动一个单词 (<code>backward-word</code>) 。</dd>
<dt><code>M-d</code></dt><dd>删除至单词末尾 (<code>kill-word</code>) 。</dd>
<dt><code>M-DEL</code></dt><dd>删除至单词开头 (<code>backward-kill-word</code>) 。</dd>
<dt><code>M-@</code></dt><dd>将标记置于下一个单词的末尾 (<code>mark-word</code>) 。</dd>
<dt><code>M-t</code></dt><dd>交换两个单词的位置，或拖动一个单词至其他单词后方 (<code>transpose-words</code>) 。</dd>
</dl>

<p>
可以看到，上述快捷键与基于字符操作的 <code>C-f</code> 、 <code>C-b</code> 、 <code>C-d=、=DEL</code> 、 <code>C-t</code> 形成对应系列。 <code>M-@</code> 与 <code>C-@</code> 同源，而 <code>C-@</code> 是 <code>C-SPC</code> 的别名。
</p>

<p>
<code>M-f</code> (<code>forward-word</code>) 和 <code>M-b</code> (<code>backward-word</code>) 命令分别实现单词级的向前、向后移动，这类基于 <code>Meta</code> 键的快捷键，与基于单个字符移动的 <code>C-f</code> 、 <code>C-b</code> 快捷键用法相仿，数字参数同样可作为重复执行的次数。带负参数的 <code>M-f</code> 会向后移动，带负参数的 <code>M-b</code> 则会向前移动。向前移动时，光标会停在单词最后一个字符 <b>后方</b> ；向后移动时，光标会停在单词第一个字符 <b>前方</b> 。
</p>

<p>
<code>M-d</code> (<code>kill-word</code>) 命令会删除光标位置之后的单词内容。准确来说，该命令会删除从光标处到 M-f 命令目标位置之间的所有内容。因此，若光标处于单词中间， <code>M-d</code> 仅删除光标后的部分单词内容；若光标与下一个单词之间存在标点符号，标点会随单词一同被删除。（若你只想删除下一个单词、保留其前的标点，只需先按 <code>M-f</code> 移至单词末尾，再按 <code>M-DEL</code> 从后向前删除单词即可。） <code>M-d</code> 命令的参数用法与 <code>M-f</code> 完全一致。
</p>

<p>
<code>M-DEL</code> (<code>backward-kill-word</code>) 命令会删除光标位置之前的单词内容，删除范围为从光标处到 <code>M-b</code> 命令目标位置之间的所有内容。例如，若光标位于 “FOO, BAR” 中空格的后方，执行该命令会删除 “FOO, ” 这部分内容。若你只想删除 “FOO”、保留逗号和空格，可使用 <code>M-b</code> 搭配 <code>M-d</code> 完成，而非直接按 <code>M-DEL</code> 。
</p>

<p>
<code>M-t</code> (<code>transpose-words</code>) 命令会将光标前方（或包含光标）的单词，与后方的单词互换位置，单词之间的分隔符不会随单词移动。例如，“FOO, BAR” 执行该命令后会变为 “BAR, FOO”，而非 “BAR FOO,”。关于文本交换的更多用法，参见「<a href="#Transpose">文本交换</a>」章节。
</p>

<p>
若要通过作用于选区的操作处理单词，可使用 <code>M-@</code> (<code>mark-word</code>) 命令，该命令会将标记置于 <code>M-f</code> 命令的目标位置。关于此命令的更多信息，参见「<a href="#Marking-Objects">标记文本对象的命令</a>」章节。
</p>

<p>
单词命令对单词边界的识别规则，由 <b>语法表</b> 控制。例如，可将任意字符定义为单词分隔符。相关内容参见《Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Tables.html#Syntax-Tables">语法表</a>」章节。
</p>

<p>
此外， <code>M-=</code> (<code>count-words-region</code>) 和 <code>M-x count-words</code> 命令可统计并显示选区或缓冲区中的单词数量，相关用法参见「<a href="#Position-Info">光标位置信息</a>」章节。
</p>
</div>
</div>
<div id="outline-container-Sentences" class="outline-3">
<h3 id="Sentences"><span class="section-number-3">27.2.</span> 句子操作</h3>
<div class="outline-text-3" id="text-Sentences">
<p>
Emacs 中用于操作句子和段落的命令，与单词操作命令类似，大多绑定在 <code>Meta</code> 键上。
</p>

<dl class="org-dl">
<dt><code>M-a</code></dt><dd>回退至句子开头 (<code>backward-sentence</code>) 。</dd>
<dt><code>M-e</code></dt><dd>前移至句子结尾 (<code>forward-sentence</code>) 。(PS: 前移指向光标右边)</dd>
<dt><code>M-k</code></dt><dd>向前删除至句子结尾 (<code>kill-sentence</code>) 。(PS: 向前指向光标右边)</dd>
<dt><code>C-x DEL</code></dt><dd>向后删除至句子开头 (<code>backward-kill-sentence</code>) 。</dd>
</dl>

<p>
<code>M-a</code> (<code>backward-sentence</code>) 和 <code>M-e</code> (<code>forward-sentence</code>) 命令，分别跳转至当前句子的开头和结尾。其快捷键的设计参考了跳转行首、行尾的 <code>C-a</code> 和 <code>C-e</code> ，与后者不同的是，重复按下 <code>M-a</code> 或 <code>M-e</code> ，可连续在多个句子间向前 / 向后跳转。
</p>

<p>
向句子后方回退时，光标会停在句子第一个字符 <b>前方</b> ；向句子前方移动时，光标会停在结束句子的标点 <b>后方</b> 。两种操作均不会跨过句子边界的空白字符。
</p>

<p>
如同行操作的 <code>C-a</code> 、 <code>C-e</code> 配有对应的删除命令 <code>C-k</code> ， <code>M-a</code> 和 <code>M-e</code> 也有专属的删除命令： <code>M-k</code> (<code>kill-sentence</code>) 会删除从光标处到句子结尾的所有内容。带正数字参数 <code>n</code> 时，该命令会删除后续 <code>n</code> 个句子；带负数字参数 <code>-n</code> 时，则会向后删除至前 <code>n</code> 个句子的开头。
</p>

<p>
<code>C-x DEL</code> (<code>backward-kill-sentence</code>) 命令的作用为，向后删除从光标处到句子开头的所有内容。
</p>

<p>
句子相关命令的识别逻辑，遵循 <b>美式打字的排版惯例</b> —— <b>句子结尾</b> 需标注 <b>两个空格</b> 。即当句末出现英文句点 '<code>.</code>' 、'<code>?</code>' 或 '<code>!</code>' ，且其后紧跟行尾或两个空格时，判定为句子结束；符号与行尾 / 两个空格之间，允许出现任意数量的右括号 '<code>)</code>' 、右方括号 '<code>]</code>' 、单引号 ‘'’ 或双引号 ‘"’ 。此外，段落的开头和结尾，也同时视为句子的起止位置。遵循这一惯例十分实用，能让 Emacs 的句子命令准确区分 <b>句末结束符</b> 和 <b>缩写词后的句点</b> 。
</p>

<p>
若你习惯在句子之间只使用一个空格，可将变量 <code>sentence-end-double-space</code> 设为 <code>nil</code> ，让句子命令适配单个空格的判定规则。但该设置存在弊端：Emacs 将无法区分句末结束符和缩写词后的句点。为了实现便捷、准确的文本编辑，我们建议你遵循 <b>句末双空格</b> 的排版惯例。变量 <code>sentence-end-double-space</code> 的设置同样会影响文本填充功能（详见「<a href="#Fill-Commands">显式填充命令</a>」章节）。
</p>

<p>
变量 <code>sentence-end</code> 用于控制 Emacs 对 <b>句尾</b> 的识别规则。若该变量非nil，其值需为一个正则表达式，用于匹配句子的最后几个字符，以及句子后方的空白字符（详见「<a href="#Regexps">正则表达式语法</a>」章节）；若设为默认值 <code>nil</code> ，Emacs 会根据多种规则判定句尾，例如变量 <code>sentence-end-double-space</code> 的取值。
</p>

<p>
部分语言（如泰语）并不使用句点标识句子结束，此类场景下，可将变量 <code>sentence-end-without-period</code> 设为 <code>t</code> 。
</p>

<p>
尽管上述句子移动命令为适配自然语言设计，但 Emacs 的其他模式也可重新绑定这些命令，实现类似的功能（详见「<a href="#Moving-by-Sentences">按句子跳转</a>」章节）。
</p>
</div>
</div>
<div id="outline-container-Paragraphs" class="outline-3">
<h3 id="Paragraphs"><span class="section-number-3">27.3.</span> 段落操作</h3>
<div class="outline-text-3" id="text-Paragraphs">
<p>
Emacs 中用于段落操作的命令同样绑定在 <code>Meta</code> 键上。
</p>

<dl class="org-dl">
<dt><code>M-{</code></dt><dd>回退至前一个段落开头 (<code>backward-paragraph</code>) 。</dd>
<dt><code>M-}</code></dt><dd>前移至下一个段落结尾 (<code>forward-paragraph</code>) 。</dd>
<dt><code>M-h</code></dt><dd>将光标和标记定位至当前或下一个段落的首尾 (<code>mark-paragraph</code>) 。</dd>
</dl>

<p>
<code>M-{</code> (<code>backward-paragraph</code>) 会跳转至当前段落或前一个段落的开头，具体取决于执行命令时光标的位置（段落的定义见下文）。 <code>M-}</code> (<code>forward-paragraph</code>) 则同理，跳转至当前段落或下一个段落的结尾。若某段落前方存在空行， <code>M-{</code> 会直接跳转至该空行处。
</p>

<p>
若要对某一段落执行操作，可按下 <code>M-h</code> (<code>mark-paragraph</code>) ，将该段落设为选区。例如，按下 <code>M-h</code> 后再按 <code>C-w</code> ，即可删除光标所在或光标后方的整个段落。 <code>M-h</code> 会将光标置于原光标所在段落的开头，标记置于该段落的结尾；若光标处于段落之间（连续空行中或段落边界处）， <code>M-h</code> 则会将下一个段落设为选区；若目标段落的首行前方存在空行，选区会包含其中一行空行。若选区已处于激活状态，执行该命令时仅会移动标记而保持光标位置不变，且后续每按一次 <code>M-h</code> ，标记会向后再推进一个段落。
</p>

<p>
段落的定义由 <b>主模式</b> 决定。在 Fundamental mode、Text 模式及相关衍生模式中，段落与相邻段落之间由一行或多行空行分隔 —— 空行指无任何字符的行，或仅包含空格、制表符和 / 或换页符的行。在编程语言模式中，段落的定义方式与之大致相同，因此即便程序代码中并无实际意义上的段落，你仍可使用各类段落操作命令。
</p>

<p>
请注意，在文本模式中，缩进行本身并不构成段落分隔。若你希望将缩进行作为段落的分隔标识，可改用 <b>Paragraph-Indent Text mode 段落缩进文本模式</b> ，详见「<a href="#Text-Mode">文本模式</a>」章节。
</p>

<p>
若你设置了 <b>填充前缀</b> ，则所有未以该填充前缀开头的行，均会作为段落的分隔符，详见「<a href="#Filling">文本填充</a>」章节。
</p>

<p>
段落边界的精确判定规则，由变量 <code>paragraph-separate</code> 和 <code>paragraph-start</code> 控制。 <code>paragraph-start</code> 的取值为一个正则表达式，用于匹配作为段落开头或分隔段落的行（详见「<a href="#Regexps">正则表达式语法</a>」章节）； <code>paragraph-separate</code> 的取值同样为正则表达式，用于匹配仅作为段落分隔、不属于任何段落的行（例如空行）。作为新段落开头且隶属于该段落的行，仅需匹配 <code>paragraph-start</code> ，无需匹配 <code>paragraph-separate</code> 。例如在基本模式中， <code>paragraph-start</code> 的取值为"<code>\f\\|[ \t]*$</code>" ， <code>paragraph-separate</code> 的取值为 "<code>[ \t\f]*$</code>"。
</p>

<p>
需注意， <code>paragraph-start</code> 和 <code>paragraph-separate</code> 的匹配对象为 <b>左页边距处的文本</b> ，而非必定是行首的文本，因此这两个正则表达式不应使用 '<code>^</code>' 作为锚定符，以确保段落相关操作命令在由页边距设置形成的缩进文本区域内也能正常生效
</p>
</div>
</div>
<div id="outline-container-Pages" class="outline-3">
<h3 id="Pages"><span class="section-number-3">27.4.</span> 页面操作</h3>
<div class="outline-text-3" id="text-Pages">
<p>
部分文本文件中，内容会以 <i>formfeed character 换页符</i> （ASCII code 12，也记作 'control-L' ）分隔为不同页面，该字符在 Emacs 中会以转义序列 '<code>^L</code>' 显示（详见「<a href="#Text-Display">文本的显示方式</a>」章节）。按照惯例，此类文本文件打印到硬拷贝时，每个换页符都会强制触发分页。Emacs 中大部分命令会将换页符视作普通字符处理，因此可通过 <code>C-q C-l</code> 插入、按退格键 <code>DEL</code> 删除该字符。除此之外，Emacs 还提供了专门用于页面间跳转和页面操作的命令。
</p>

<dl class="org-dl">
<dt><code>M-x what-page</code></dt><dd>显示光标所在的页面编号，以及光标在该页面内的行号。</dd>
<dt><code>C-x [</code></dt><dd>将光标移至上一个页面边界 (<code>backward-page</code>) 。</dd>
<dt><code>C-x ]</code></dt><dd>将光标移至下一个页面边界 (<code>forward-page</code>) 。</dd>
<dt><code>C-x C-p</code></dt><dd>将光标和标记定位至当前（或指定）页面的首尾 (<code>mark-page</code>) 。</dd>
<dt><code>C-x l</code></dt><dd>统计当前页面的行数 (<code>count-lines-page</code>) 。</dd>
</dl>

<p>
<code>M-x what-page</code> 命令会从文件开头开始统计页面编号，同时统计光标在当前页面内的行号，并将两个数值一同显示在回显区。
</p>

<p>
<code>C-x [</code> (<code>backward-page</code>) 会将光标移至上一个页面分隔符的 <b>后方</b> ；若光标原本就处于某一页面分隔符后方，该命令会跳过此分隔符，继续定位至前一个分隔符处。数字参数可作为该命令的重复执行次数。 <code>C-x ]</code> (<code>forward-page</code>) 则会将光标向前移至下一个页面分隔符的 <b>后方</b> 。
</p>

<p>
<code>C-x C-p</code> (<code>mark-page</code>) 会将光标置于当前页面的起始位置（即页面首部分隔符的后方），并将标记置于当前页面的结束位置（即页面尾部分隔符的后方）。
</p>

<p>
<code>C-x C-p</code> 搭配 <code>C-w</code> 是快速删除某一页面并将其移动至其他位置的便捷方式：先通过 <code>C-x [</code> 和 <code>C-x ]</code> 跳转到其他页面分隔符处，再粘贴被删除的页面，所有页面会重新恢复正确的分隔格式。 <code>C-x C-p</code> 命令的选区仅包含页面尾部的分隔符，正是为了保证该操作能按预期生效。
</p>

<p>
为 <code>C-x C-p</code> 添加数字参数，可指定跳转至相对于当前页面的某一页面：0 代表当前页面，1 代表下一页，-1 代表上一页。
</p>

<p>
<code>C-x l</code> (<code>count-lines-page</code>) 可辅助拆分页面，该命令会在回显区显示当前页面的总行数，并按当前行将其拆分为「当前行之前的行数」和「当前行之后的行数」，显示格式如下：
</p>

<div class="org-src-container">
<pre class="src src-shell">Page has 96 (72+25) lines
&#39029;&#38754;&#20849;&#26377; 96 &#34892;&#65288;72+25&#65289;
</pre>
</div>

<p>
需注意，显示的两个数字之和与总行数相差 1—— 若光标并非位于行首，此为正常现象。
</p>

<p>
变量 <code>page-delimiter</code> 用于控制页面的起始位置，其值为一个正则表达式，用于匹配作为页面分隔符的行首内容（详见「<a href="#Regexps">正则表达式语法</a>」章节）。该变量的默认值为 "^\f" ，即匹配行首的换页符。
</p>
</div>
</div>
<div id="outline-container-Quotation-Marks" class="outline-3">
<h3 id="Quotation-Marks"><span class="section-number-3">27.5.</span> 引号处理</h3>
<div class="outline-text-3" id="text-Quotation-Marks">
<p>
引号的常用输入方式有两种，一是打字机惯例，使用直单引号 ‘'like this'’ 或直双引号 ‘"like this"’ 标注；二是弯引号惯例，使用左右单弯引号 ‘like this’ 或左右双弯引号 “like this” 标注<sup><a id="fnr.12" class="footref" href="#fn.12" role="doc-backlink">12</a></sup>。在文本文件中，打字机引号的优势是输入简单、兼容性强；弯引号则能避免歧义，视觉呈现也更美观。
</p>

<p>
Electric Quote mode 可简化弯引号的输入操作。开启该模式后，输入指定字符会自动转换为对应弯引号：输入 `  转为左单弯引号 ‘ ，输入 ' 转为右单弯引号 ’ ，输入 `` 转为左双弯引号 “ ，输入 '' 转为右双弯引号 ” 。你可通过自定义变量 <code>electric-quote-chars</code> 修改上述默认转换规则，该变量为包含四个字符的列表，依次对应左单弯引号、右单弯引号、左双弯引号、右双弯引号，其默认值为 <code>'(?‘ ?’ ?“ ?”)</code> 。
</p>

<p>
Electric Quote mode 的生效范围可通过相关变量自定义：若变量 <code>electric-quote-paragraph</code> 设为非nil，模式在文本段落中生效；若 <code>electric-quote-comment</code> 设为非nil，模式在编程语言的注释中生效；若 <code>electric-quote-string</code> 设为非nil，模式在编程语言的字符串中生效。该模式的默认配置为： <code>electric-quote-string</code> 值为 <code>nil</code> ，其余两个变量值为 <code>t</code> 。
</p>

<p>
你也可将选项 <code>electric-quote-replace-double</code> 设为非nil，开启后输入直双引号 "，程序会根据上下文自动转换为对应双弯引号：在缓冲区开头、换行符后、空白字符后、左括号后或引号字符后输入 "，会转为左双弯引号 “；其他场景下输入则转为右双弯引号”。
</p>

<p>
Electric Quote mode 默认处于关闭状态。若需在单个缓冲区中切换该模式，可执行 <code>M-x electric-quote-local-mode</code> ；若需全局切换，执行 <code>M-x electric-quote-mode</code> 即可。若想临时禁用该模式输入单个字符，可按下 <code>C-q `</code> 或 <code>C-q '</code> 替代直接输入 ` 或 ' 。即便 Electric Quote  mode 处于关闭或未生效状态，仍可通过快捷键插入弯引号：按 <code>C-x 8 [</code> 插入左单弯引号 ‘，按 <code>C-x 8 ]</code> 插入右单弯引号 ’，按 <code>C-x 8 {</code> 插入左双弯引号 “，按 <code>C-x 8 }</code> 插入右双弯引号 ” （详见「<a href="#Inserting-Text">文本插入</a>」章节）。需注意，变量 <code>electric-quote-chars</code> 的设置不会影响上述快捷键，这些快捷键并非绑定在 electric-quote-mode 中，而是全局映射表（ <code>global-map</code> ）中的全局绑定。
</p>
</div>
</div>
<div id="outline-container-Filling" class="outline-3">
<h3 id="Filling"><span class="section-number-3">27.6.</span> 文本填充</h3>
<div class="outline-text-3" id="text-Filling">
<p>
<i>Filling text 文本填充</i> 指将文本拆分为符合指定行宽的若干行。Emacs 提供两种文本填充方式：开启自动填充模式后，通过自插入字符输入文本时，会自动完成填充；同时也提供了可手动调用的显式填充命令，供编辑文本时使用。
</p>

<ul class="org-ul">
<li><a href="#Auto-Fill">自动填充模式</a></li>
<li><a href="#Fill-Commands">显式填充命令</a></li>
<li><a href="#Fill-Prefix">填充前缀</a></li>
<li><a href="#Adaptive-Fill">自适应填充</a></li>
</ul>
</div>
<div id="outline-container-Auto-Fill" class="outline-4">
<h4 id="Auto-Fill"><span class="section-number-4">27.6.1.</span> 自动填充模式</h4>
<div class="outline-text-4" id="text-Auto-Fill">
<p>
<i>Auto Fill mode自动填充模式</i> 是一种缓冲区局部次要模式（参见「<a href="#Minor-Modes">次要模式</a>」章节），开启后当行宽超出限值，且你输入空格（SPC）或回车键（RET）时，行会被自动折行。
</p>
<dl class="org-dl">
<dt><code>M-x auto-fill-mode</code></dt><dd>启用或关闭自动填充模式。</dd>
<dt><code>SPC</code></dt><dd></dd>

<dt><code>RET</code></dt><dd>在自动填充模式下，于合适位置折行。</dd>
</dl>

<p>
执行命令 <code>M-x auto-fill-mode</code> 可切换当前缓冲区的自动填充模式。与其他所有次要模式一致，带正数字参数执行时会启用该模式，带负数字参数则关闭。若需在特定主模式中自动启用自动填充模式，可将 <code>auto-fill-mode</code> 添加至 <b>模式钩子</b> 中（参见「<a href="#Major-Modes">主模式</a>」章节）。当自动填充模式启用时，模式行中会显示模式标识 'Fill' （参见「<a href="#Mode-Line">模式行</a>」章节）。
</p>

<p>
当行宽超过设定的理想宽度时，自动填充模式会在合适位置自动折行，且该操作 <b>仅在你输入空格或回车键时触发</b> 。若你希望插入空格或换行但禁止折行，可分别输入 <code>C-q SPC</code> 或 <code>C-q C-j</code> ；此外，按下 <code>C-o</code> 插入换行时也不会触发折行。
</p>

<p>
自动填充模式的折行位置由行内字符类型决定：对于 ASCII、拉丁语系及其他大多数文字体系的字符，Emacs 会在空格处折行，以保证单词的完整性；而对于中日韩（CJK）文字体系，可在任意两个字符之间折行（若加载 kinsoku 库，Emacs 会遵循特殊规则，避免在特定的 CJK 字符组合之间折行）。
</p>

<p>
自动填充模式折行时，会尝试遵循 <b><i>adaptive fill prefix自适应填充前缀</i></b> 规则：若能从当前段落的第一行或第二行推导出填充前缀，该前缀会被插入新行（参见「<a href="#Adaptive-Fill">自适应填充</a>」章节）；否则新行会被自动缩进，效果等同于在该行按下制表符（ <code>TAB</code> ）（参见「<a href="#Indentation">缩进</a>」章节）。在编程语言模式中，若在注释中间折行，Emacs 会按需插入新的注释分隔符，完成注释的拆分。
</p>

<p>
自动填充模式 <b>不会重新填充整个段落</b> ，它仅执行折行操作，不合并行。因此，在段落中间进行编辑后，可能会导致段落排版格式混乱，此时可调用 <b>显式填充命令</b> 重新整理（参见「<a href="#Fill-Commands">显式填充命令</a>」章节）。
</p>

<p>
另有一个相似功能为 <b>Visual Line mode视觉行模式</b> ，可在显示时自动折行长行（参见「<a href="#Visual-Line-Mode">视觉行模式</a>」章节）。
</p>
</div>
</div>
<div id="outline-container-Fill-Commands" class="outline-4">
<h4 id="Fill-Commands"><span class="section-number-4">27.6.2.</span> 显式填充命令</h4>
<div class="outline-text-4" id="text-Fill-Commands">
<dl class="org-dl">
<dt><code>M-q</code></dt><dd>填充当前段落 (<code>fill-paragraph</code>)</dd>
<dt><code>C-x f</code></dt><dd>设置填充列 (<code>set-fill-column</code>)</dd>
<dt><code>M-x fill-region</code></dt><dd>填充区域内的每个段落 (<code>fill-region</code>)</dd>
<dt><code>M-x fill-region-as-paragraph</code></dt><dd>将整个区域视为单个段落进行填充</dd>
<dt><code>M-x center-line</code></dt><dd>居中对齐行</dd>
</dl>

<p>
<code>M-q</code> (<code>fill-paragraph</code>) 命令用于填充当前段落，会重新调整段落内的换行位置，删除段落中多余的空格和制表符，使所有行的宽度均不超过设定的最大限值。与自动填充模式一致，该命令及其他填充命令通常以空格为换行依据；而对于中日韩（CJK）字符，这类命令几乎可在任意两个字符间换行，且会遵循禁则排版规则（详见「<a href="#Auto-Fill">自动填充模式</a>」）。
</p>

<p>
默认情况下， <code>M-q</code> 作用于光标所在的段落；若光标处于段落之间，则作用于光标后方的段落；若区域处于激活状态，则会转而作用于区域内的文本。也可直接调用 <code>M-x fill-region</code> 命令，专门对区域内的文本进行填充。
</p>

<p>
<code>M-q</code> 和 <code>fill-region</code> 命令遵循 Emacs 通用的段落边界判定规则（详见「<a href="#Paragraphs">段落</a>」）。若需要更精细的控制，可使用 <code>M-x fill-region-as-paragraph</code> 命令，该命令会将光标与标记之间的所有内容作为单个段落重新填充，同时删除区域内的所有空行，使原本分离的文本块合并为一个整体。
</p>

<p>
为 <code>M-q</code> 命令添加数字参数时，会在填充文本的同时进行对齐处理，即插入额外的空格，使右边缘与填充列精准对齐；若无需额外空格，直接执行无参数的 <code>M-q</code> 即可（ <code>fill-region</code> 命令同理）。
</p>

<p>
文本填充的最大行宽由缓冲区局部变量 <code>fill-column</code> 定义，其默认值为 70（详见「<a href="#Locals">局部变量</a>」）。在当前缓冲区中设置 <code>fill-column</code> 最便捷的方式是使用 <code>C-x f</code> (<code>set-fill-column</code>) 命令：带数字参数执行时，将该数字设为新的填充列值；仅以 <code>C-u</code> 为参数执行时，将填充列设为光标当前的水平位置。需注意， <code>fill-column</code> 本质以列单位计量，其在图形界面中的实际显示位置取决于所使用的字体；尤其是使用变宽字体时，不同行的 <code>fill-column</code> 对应的水平位置会有所不同。
</p>

<p>
<code>M-x center-line</code> 命令可将当前行在填充列范围内居中对齐；带数字参数 <code>n</code> 执行时，会将连续 <code>n</code> 行分别居中，并将光标移至这些行之后。该快捷键由文本模式绑定，仅在文本模式及相关衍生模式中可用（详见「<a href="#Text-Mode">文本模式</a>」）。
</p>

<p>
Emacs 默认将「句点后接两个空格」或「句点后接换行」视为句子结束；若句点后仅接一个空格，则判定为缩写，而非句子结束。因此，填充命令不会在「单空格接句点」的位置换行。若将变量 <code>sentence-end-double-space</code> 设为 <code>nil</code> ，填充命令会在「句点后接一个空格」的位置换行，且所有句点后均仅保留一个空格（该设置的其他影响及潜在问题详见「<a href="#Sentences">句子</a>」）。
</p>

<p>
若变量 <code>colon-double-space</code> 设为非 nil 值，填充命令会在冒号后保留两个空格。
</p>

<p>
若需自定义禁止换行的额外场景，可对异常钩子变量 <code>fill-nobreak-predicate</code> 进行定制（详见「<a href="#Hooks">钩子</a>」）。该钩子中的每个函数均为无参执行，执行时光标位于 Emacs 拟换行的位置；若某一函数返回非 nil 值，Emacs 则不会在该位置换行。可用于该钩子的函数包括： <code>fill-single-word-nobreak-p</code> （句子首个单词后、最后一个单词前禁止换行）、 <code>fill-single-char-nobreak-p</code> （空白字符后的单字母单词后禁止换行）、 <code>fill-french-nobreak-p</code> （左括号后、右括号 / 冒号 / 问号前禁止换行）、 <code>fill-polish-nobreak-p</code> （单字母单词后禁止换行，无论其前是否为空白字符）。
</p>

<p>
可通过「显示填充列指示符模式」，让 Emacs 在填充列位置显示标识线（详见 <a href="#Displaying-Boundaries">display-fill-column-indicator</a> 相关说明）。
</p>
</div>
</div>
<div id="outline-container-Fill-Prefix" class="outline-4">
<h4 id="Fill-Prefix"><span class="section-number-4">27.6.3.</span> 填充前缀</h4>
<div class="outline-text-4" id="text-Fill-Prefix">
<p>
<i>fill prefix 填充前缀</i> 功能可在对段落进行填充时，让每一行都以特定的字符串开头（例如一段空格，实现段落缩进效果）。你可以显式指定填充前缀；若未指定，Emacs 会尝试自动推导填充前缀（详见「<a href="#Adaptive-Fill">自适应填充</a>」）。
</p>

<dl class="org-dl">
<dt><code>C-x .</code></dt><dd>设置填充前缀 (<code>set-fill-prefix</code>)</dd>
<dt><code>M-q</code></dt><dd>使用当前填充前缀填充段落 (<code>fill-paragraph</code>)</dd>
<dt><code>M-x fill-individual-paragraphs</code></dt><dd>填充指定区域，将缩进量的每次变化均视为新段落的开始</dd>
<dt><code>M-x fill-nonuniform-paragraphs</code></dt><dd>填充指定区域，仅将段落分隔行视为新段落的开始</dd>
</dl>

<p>
为当前缓冲区设置填充前缀的操作方法：将光标移至以目标前缀开头的行，把点定位到该前缀的末尾，按下 <code>C-x .</code> （即 <code>C-x</code> 后接句点）即可。若要关闭填充前缀，只需将点定位到行首，执行 <code>C-x .</code> 来指定空前缀即可。
</p>

<p>
当填充前缀生效时，填充命令会在填充前先移除段落中每一行的填充前缀，填充完成后再为每一行重新插入该前缀。（段落首行的开头部分会保持原样，因为该位置的格式通常是有意设置的特殊样式。）自动填充模式在换行时，也会自动插入填充前缀（详见「<a href="#Auto-Fill">自动填充模式</a>」）。当你在行首使用 <code>C-o</code> 命令换行时，该命令也会在新建的行上插入填充前缀（详见「<a href="#Blank-Lines">空行</a>」）。反之， <code>M-^</code> 命令在删除换行符后，若该位置存在填充前缀，会一并将其删除（详见「<a href="#Indentation">缩进</a>」）。
</p>

<p>
举例来说，若填充列设为 40，且将填充前缀设为‘;; ’，那么对以下文本执行 <code>M-q</code> 命令：
</p>

<div class="org-src-container">
<pre class="src src-shell">;; This is an
;; example of a paragraph
;; inside a Lisp-style comment.
</pre>
</div>

<p>
执行后会得到如下结果：
</p>

<div class="org-src-container">
<pre class="src src-shell">;; This is an example of a paragraph
;; inside a Lisp-style comment.
</pre>
</div>

<p>
在 <code>M-q</code> 命令和各类段落相关命令中， <b>不以填充前缀开头的行都会被视为新段落的起始行</b> ，这一规则对悬挂式缩进的段落（除首行外，其余所有行均缩进）处理效果极佳。 <b>空行</b> ，或是 <b>移除填充前缀后出现缩进的行</b> ，也会被视作段落分隔行或新段落的起始行；如果你需要编写每行都带注释分隔符的多段注释，这一规则会恰好满足你的排版需求。
</p>

<p>
你可以使用 <code>M-x fill-individual-paragraphs</code> 命令，为每个段落自动设置填充前缀。该命令会将指定区域划分为多个段落，把 <b>缩进量的每一次变化</b> 都当作新段落的开始，再对每个分段分别进行填充。如此一来，同一个段落内的所有行都会拥有相同的缩进量，而该缩进量会成为这个段落的填充前缀。
</p>

<p>
<code>M-x fill-nonuniform-paragraphs</code> 是一个类似的填充命令，其段落划分方式有所不同：该命令 <b>仅将段落分隔行</b> （由 <code>paragraph-separate</code> 变量定义）视作新段落的开始。这意味着同一个段落内的各行可能拥有不同的缩进量，此时命令会将 <b>该段落所有行中最小的缩进量</b> 作为填充前缀。对于「段落首行缩进量与其余行不同」的排版样式，该命令能实现理想的填充效果。
</p>

<p>
填充前缀的相关设置存储在变量 <code>fill-prefix</code> 中，其值为一个字符串；若未设置填充前缀，该变量值为 <code>nil</code> 。这是一个缓冲区局部变量，修改该变量仅会对当前缓冲区生效，同时你也可以修改其默认值（详见「<a href="#Locals">局部变量</a>」）。
</p>

<p>
除填充前缀外，还可通过 <b>缩进文本属性</b> 控制段落的缩进量，相关说明详见「<a href="#Enriched-Indentation">富文本中的缩进</a>」。
</p>
</div>
</div>
<div id="outline-container-Adaptive-Fill" class="outline-4">
<h4 id="Adaptive-Fill"><span class="section-number-4">27.6.4.</span> 自适应填充</h4>
<div class="outline-text-4" id="text-Adaptive-Fill">
<p>
在某些情况下，填充命令可自动为段落推导合适的填充前缀：行首的空白字符，或是特定的标点符号序列，会被应用到该段落的所有行中。
</p>

<p>
若某段落包含两行及以上内容，填充前缀将取自该段落的第二行；但 <b>仅当该前缀同时出现在首行时</b> ，此规则才生效。
</p>

<p>
若段落仅有一行，填充命令也可能从这一行提取前缀，但其判定逻辑更为复杂 —— 针对这种情况，有三种符合常规的排版处理方式，命令需从中选择：
</p>
<ul class="org-ul">
<li>将首行的前缀应用到该段落的所有行；</li>
<li>后续行仅用空白字符缩进，使其对齐首行前缀后的文本内容， <b>不直接复制</b> 首行的前缀本身；</li>
<li>第二行及后续行不做任何特殊的前缀 / 缩进处理。</li>
</ul>

<p>
上述三种排版样式均为常用形式，因此填充命令会根据提取到的前缀特征，结合当前的主模式，来判断用户的排版需求，具体判定规则如下。
</p>

<p>
若从首行提取的前缀匹配正则表达式 <code>adaptive-fill-first-line-regexp</code> ，或该前缀看起来是 <b>注释起始符序列</b> （具体判定规则依赖当前主模式），且该前缀不会被识别为后续行的段落起始标识，则此前缀将被用于该段落的填充。
</p>

<p>
若不满足上述条件，提取到的前缀会被转换为同等缩进宽度的空白字符；若这些空白字符不会被识别为后续行的段落起始标识，则将其作为该段落后续所有行的填充前缀。
</p>

<p>
在文本模式，以及其他 <b>仅将空行和分页符视作段落分隔符</b> 的模式中，自适应填充所选的前缀永远不会被识别为段落起始标识，因此可直接用于段落填充。
</p>

<p>
变量 <code>adaptive-fill-regexp</code> 用于定义 <b>可作为填充前缀的行首字符规则</b> ：行首所有匹配该正则表达式的字符序列，都会被当作填充前缀提取。若将变量 <code>adaptive-fill-mode</code> 设为 <code>nil</code> ，则填充命令将 <b>永远不会自动推导</b> 填充前缀。
</p>

<p>
若需自定义更复杂的自动填充前缀推导规则，可将变量 <code>adaptive-fill-function</code> 设为一个自定义函数。该函数执行时，光标会定位在目标行的左边界之后，函数需根据该行内容返回对应的填充前缀；若函数返回 <code>nil</code> ，则会转而通过 <code>adaptive-fill-regexp</code> 来提取前缀。
</p>
</div>
</div>
</div>
<div id="outline-container-Case" class="outline-3">
<h3 id="Case"><span class="section-number-3">27.7.</span> 大小写转换命令</h3>
<div class="outline-text-3" id="text-Case">
<p>
Emacs 提供了专门命令，可将单个单词或任意范围的文本转换为大写或小写形式。
</p>

<dl class="org-dl">
<dt><code>M-l</code></dt><dd>将后续单词转换为小写 (<code>downcase-word</code>) 。</dd>
<dt><code>M-- M-l</code></dt><dd>将前一个单词转换为小写。注： <code>M--</code> 即 Meta-减号。</dd>
<dt><code>M-u</code></dt><dd>将后续单词转换为大写 (<code>upcase-word</code>) 。</dd>
<dt><code>M-- M-u</code></dt><dd>将前一个单词转换为全大写形式。</dd>
<dt><code>M-c</code></dt><dd>将后续单词首字母大写 (<code>capitalize-word</code>) 。</dd>
<dt><code>M-- M-c</code></dt><dd>将前一个单词转换为首字母大写、其余字母小写的形式。</dd>
<dt><code>C-x C-l</code></dt><dd>将选中区域的文本转换为小写 (<code>downcase-region</code>) 。</dd>
<dt><code>C-x C-u</code></dt><dd>将选中区域的文本转换为大写 (<code>upcase-region</code>) 。</dd>
</dl>

<p>
<code>M-l</code> (<code>downcase-word</code>) 会将光标后方的单词转换为小写，并将光标移至该单词末尾。因此，重复按下 <code>M-l</code> 可依次转换后续的多个单词。 <code>M-u</code> (<code>upcase-word</code>) 则将单词转换为全大写，而 <code>M-c</code> (<code>capitalize-word</code>) 仅将单词首字母转为大写，其余字母均转为小写。若为这些命令指定参数，可一次性转换多个单词。这些命令在将大量全大写文本转换为大小写混合格式时尤为实用：你可在文本中移动光标，根据需要对每个单词分别使用 <code>M-l</code> 、 <code>M-u</code> 或 <code>M-c</code> ，也可偶尔使用 <code>M-f</code> 跳过无需转换的单词。
</p>

<p>
若为单词大小写转换命令指定负参数（如 <code>C-u - 5 M-c</code> ），该命令会对光标 <b>前方</b> 指定数量的单词进行转换，且 <b>不会移动光标</b> 。当你刚输入完一个大小写错误的单词时，此用法会非常便捷：直接使用 <code>M-- M-u</code> 这类转换命令即可修正，无需中断输入。
</p>

<p>
若在单词 <b>中间位置</b> 执行单词大小写转换命令，该命令仅对光标 <b>后方</b> 的单词部分生效（这一行为与 <code>M-d</code> ( <code>kill-word</code> ，删除单词) 类似）；若指定负参数，则仅对光标 <b>前方</b> 的单词部分进行大小写转换。
</p>

<p>
另外两个大小写转换命令为 <code>C-x C-u</code> (<code>upcase-region</code>) 和 <code>C-x C-l</code> (<code>downcase-region</code>) ，二者会将光标与标记之间的 <b>整个区域</b> 内的所有文本转换为指定大小写，执行后光标与标记的位置均保持不变。
</p>

<p>
区域大小写转换命令 <code>upcase-region</code> 和 <code>downcase-region</code> 默认处于 <b>禁用状态</b> ，这意味着你尝试使用这类命令时，Emacs 会要求你确认操作。当你确认后，可选择启用该命令，后续使用时将不再弹出确认提示。详见「<a href="#Disabling">命令的禁用</a>」相关内容。
</p>
</div>
</div>
<div id="outline-container-Text-Mode" class="outline-3">
<h3 id="Text-Mode"><span class="section-number-3">27.8.</span> 文本模式</h3>
<div class="outline-text-3" id="text-Text-Mode">
<p>
文本模式是用于编辑自然语言文本文件的主模式，扩展名以 <code>.txt</code> 结尾的文件通常会以文本模式打开（参见「<a href="#Choosing-Modes">文件模式的选择</a>」）。若要显式切换至文本模式，可执行命令 <code>M-x text-mode</code> 。
</p>

<p>
在文本模式下， <b>仅空行和分页符可作为段落的分隔符</b> 。因此段落可设置缩进，且自适应填充功能会在填充段落时，自动判定应使用的缩进格式（参见「<a href="#Adaptive-Fill">自适应填充</a>」）。
</p>

<p>
文本模式下，按下 <code>TAB</code> 键 (<code>indent-for-tab-command</code>) 通常会插入空白字符，直至下一个制表位，而非为当前行进行缩进处理，具体细节参见「<a href="#Indentation">缩进</a>」相关说明。
</p>

<p>
文本模式会关闭所有与注释相关的功能，除非你显式调用这些功能；同时该模式会修改语法表，将撇号认定为单词的组成部分（例如don't会被视作一个完整单词）。但在首字母大写的处理逻辑中，若单词以撇号开头，该撇号会被当作前缀处理（例如执行 <code>M-c</code> 时，'hello'会按预期转换为'Hello'）。
</p>

<p>
若你习惯为段落首行设置缩进，应使用 <b>段落缩进文本模式</b> （执行 <code>M-x paragraph-indent-text-mode</code> ）而非普通文本模式。在该模式下，段落之间无需添加空行，因为首行的缩进已足够作为新段落的标识；但此模式 <b>不支持</b> 所有行均带缩进的段落排版形式。若因场景限制无法修改主模式（例如撰写邮件时），可执行 <code>M-x paragraph-indent-minor-mode</code> ，启用功能等效的副模式。
</p>

<p>
按下 <code>M-TAB</code> 键 (<code>completion-at-point</code>) 可对光标前方的部分单词进行补全，该功能默认以拼写词典作为候选词库（参见「<a href="#Spelling">拼写检查与修正</a>」）。若你的窗口管理器已将 <code>M-TAB</code> 绑定为窗口切换快捷键，可改用 <code>ESC TAB</code> 或 <code>C-M-i</code> 执行单词补全；若要禁用该补全功能，可将变量 <code>text-mode-ispell-word-completion</code> 自定义为 <code>nil</code> 。
</p>

<p>
进入文本模式时，会自动运行模式钩子 <code>text-mode-hook</code> （参见「<a href="#Major-Modes">主模式</a>」）。
</p>

<p>
后续章节将介绍若干由文本模式派生的主模式，这些派生模式继承了上文所述的文本模式绝大部分功能；值得注意的是，文本模式的派生模式在运行自身的模式钩子前，会先执行 <code>text-mode-hook</code> 。
</p>
</div>
</div>
<div id="outline-container-Outline-Mode" class="outline-3">
<h3 id="Outline-Mode"><span class="section-number-3">27.9.</span> 大纲模式</h3>
<div class="outline-text-3" id="text-Outline-Mode">
<p>
<i>outline mode 大纲模式</i> 是从文本模式派生出的主模式，专为编辑大纲内容设计。该模式提供了大纲结构中条目间的导航命令，还可将缓冲区中的部分内容临时隐藏，让大纲的层级结构更易查看。输入 <code>M-x outline-mode</code> 即可切换至大纲模式。进入大纲模式时，会先运行钩子函数 <code>text-mode-hook</code> ，再运行钩子函数 <code>outline-mode-hook</code> （参见「<a href="#Hooks">钩子</a>」）。
</p>

<p>
当你使用大纲模式的命令隐藏某一行时（参见「<a href="#Outline-Visibility">大纲可见性命令</a>」），该行会从屏幕中消失，且在其上一行可见内容的末尾会显示一个省略号（连续三个句点），用以标识存在隐藏文本。连续多行隐藏内容仅会显示一个省略号。
</p>

<p>
各类对行进行操作的编辑命令（如 <code>C-n</code> 和 <code>C-p</code> ），会将隐藏行的文本视作其前一行可见内容的一部分。删除某行可见内容末尾的省略号，实际会删除该省略号对应的所有后续隐藏文本。
</p>
<ul class="org-ul">
<li><a href="#Outline-Minor-Mode">大纲次模式</a></li>
<li><a href="#Outline-Format">大纲格式</a></li>
<li><a href="#Outline-Motion">大纲移动命令</a></li>
<li><a href="#Outline-Visibility">大纲可见性命令</a></li>
<li><a href="#Outline-Views">多视图查看单个大纲</a></li>
<li><a href="#Foldout">折叠编辑</a></li>
</ul>
</div>
<div id="outline-container-Outline-Minor-Mode" class="outline-4">
<h4 id="Outline-Minor-Mode"><span class="section-number-4">27.9.1.</span> 大纲次模式</h4>
<div class="outline-text-4" id="text-Outline-Minor-Mode">
<p>
大纲次要模式是一种 <b>buffer-local minor mode 缓冲区局部的次要模式</b> ，其提供的命令与主模式「大纲模式」完全一致，且可与其他主模式配合使用。你可以键入 <code>M-x outline-minor-mode</code> 来切换当前缓冲区的大纲次要模式，也可通过 <b>file-local variable 文件局部变量</b> 设置，在指定文件中启用该模式（参见《<a href="#File-Variables">文件中的局部变量</a>》）。
</p>

<p>
主模式「大纲模式」在 <code>C-c</code> 前缀下提供专属按键绑定；而大纲次要模式则将 <code>C-c @</code> 作为前缀实现类似的按键绑定，这一设计是为了减少与主模式专属命令的冲突（前缀可通过变量 <code>outline-minor-mode-prefix</code> 进行自定义）。
</p>

<p>
若变量 <code>outline-minor-mode-use-buttons</code> 设为非空值，大纲次要模式除了显示省略号外，还会在标题行开头添加 <b>按钮</b> ，用以标识该章节处于隐藏状态。点击该按钮可切换章节的显示 / 隐藏状态。若该变量值设为 <code>insert</code> ，按钮会直接插入到缓冲区文本中，此时按下回车键（ <code>RET</code> ）也可实现与鼠标点击相同的章节显示切换效果；但 <b>不建议</b> 在可编辑缓冲区中将该值设为 <code>insert</code> ，因为该操作会修改缓冲区内容。若变量值设为 <code>in-margins</code> ，大纲次要模式会在 <b>窗口边距</b> 中标识隐藏的章节，且这些按钮可自定义为图标样式（参见《<a href="#Icons">图标</a>》）。
</p>

<p>
若用户选项 <code>outline-minor-mode-cycle</code> 设为非空值，大纲标题行将启用 <code>TAB</code> 和 <code>S-TAB</code> 键的 <b>循环切换可见性</b> 功能（参见<a href="#Outline-Visibility">outline-cycle</a> 命令）：按下 <code>TAB</code> 可对当前章节循环执行「隐藏」「显示子标题」「显示全部内容」操作；按下 <code>S-TAB</code> 则会对整个缓冲区执行相同的循环操作。
</p>
</div>
</div>
<div id="outline-container-Outline-Format" class="outline-4">
<h4 id="Outline-Format"><span class="section-number-4">27.9.2.</span> 大纲格式</h4>
<div class="outline-text-4" id="text-Outline-Format">
<p>
大纲模式假定缓冲区中的行分为两类： <b>/ heading lines 标题行/</b> 与 <b><i>body lines 正文行</i></b> 。标题行代表大纲中的一个主题，以一个或多个星号（'<code>*</code>'）开头；星号的数量决定了该标题在大纲结构中的层级。因此，以单个 '<code>*</code>' 开头的标题行为一级主题，在该标题行与下一个一级标题行之间、所有以两个 '<code>*</code>' 开头的标题行均为其子主题，依此类推。非标题行的所有行均为正文行，且正文行归属于其前方最近的标题行。示例如下：
</p>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">* &#39278;&#39135;</span>
&#36825;&#26159;&#39278;&#39135;&#20027;&#39064;&#30340;&#27491;&#25991;&#20869;&#23481;&#65292;
&#29992;&#20110;&#38416;&#36848;&#19982;&#39278;&#39135;&#30456;&#20851;&#30340;&#20449;&#24687;&#12290;

<span style="color: #a0522d;">** &#32654;&#21619;&#30340;&#39278;&#39135;</span>
&#36825;&#26159;&#20108;&#32423;&#26631;&#39064;&#30340;&#27491;&#25991;&#20869;&#23481;&#12290;

<span style="color: #a0522d;">** &#38590;&#21507;&#30340;&#39278;&#39135;</span>
&#35813;&#26631;&#39064;
&#20063;&#21487;&#21253;&#21547;
&#27491;&#25991;&#20869;&#23481;&#65292;
&#19988;&#21487;&#36328;&#22810;&#34892;&#12290;

<span style="color: #a020f0;">*** &#23487;&#33293;&#39278;&#39135;</span>

<span style="color: #0000ff;">* &#23621;&#25152;</span>
&#36825;&#26159;&#21478;&#19968;&#20010;&#19968;&#32423;&#20027;&#39064;&#21450;&#20854;&#26631;&#39064;&#34892;&#12290;
</pre>
</div>

<p>
一个标题行与其后所有的正文行，合称为一个 <b><i>entry 大纲项</i></b> ；一个标题行与其后所有层级更深的标题行、以及这些标题行对应的正文行，合称为一个 <b><i>subtree 大纲子树</i></b> 。
</p>

<p>
你可通过设置变量 <code>outline-regexp</code> ，自定义区分标题行的判定规则（推荐在主模式函数中或通过文件局部变量完成设置）。凡是行首匹配该正则表达式的行，都会被判定为标题行；行内（非左边界处）的匹配结果无效。
</p>

<p>
<b>匹配文本的长度决定了标题的层级</b> ，匹配文本越长，标题的嵌套层级越深。例如，若某文本格式化工具使用 '@chapter（章节）' 、 '@section（小节）' 、 '@subsection（子小节）' 命令划分文档结构，你可将 <code>outline-regexp</code> 设为‘ <code>"@chap\\|@\\(sub\\)*section"</code> ’，使这些命令所在行成为大纲的标题行。此处有一个技巧： 'chapter' 与 'section' 两个单词长度相同，但通过将正则表达式设为仅匹配 'chap' ，可让 '@chapter' 对应的匹配文本更短，从而让大纲模式识别出「小节归属于章节」的层级关系 —— 该设置的前提是，无其他命令以 '@chap' 开头。
</p>

<p>
除设置 <code>outline-regexp</code> 外，你也可将变量 <code>outline-search-function</code> 设为一个自定义函数，用于匹配当前标题并查找下一个标题（详见《Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Outline-Minor-Mode.html#Outline-Minor-Mode">大纲次要模式</a>」章节）。
</p>

<p>
你还可通过设置变量 <code>outline-level</code> ，显式指定标题行的层级计算规则。该变量的值应为一个 <b>无参函数</b> ，调用后会返回当前标题的层级。推荐在主模式命令中或通过文件局部变量完成该变量的设置。
</p>
</div>
</div>
<div id="outline-container-Outline-Motion" class="outline-4">
<h4 id="Outline-Motion"><span class="section-number-4">27.9.3.</span> 大纲移动命令</h4>
<div class="outline-text-4" id="text-Outline-Motion">
<p>
大纲模式提供了专用于在标题行间向前、向后跳转的移动命令。
</p>

<dl class="org-dl">
<dt><code>C-c C-n</code></dt><dd>将光标移至下一个可见的标题行 (<code>outline-next-visible-heading</code>) 。</dd>
<dt><code>C-c C-p</code></dt><dd>将光标移至上一个可见的标题行 (<code>outline-previous-visible-heading</code>) 。</dd>
<dt><code>C-c C-f</code></dt><dd>将光标移至与当前行同级的下一个可见标题行 (<code>outline-forward-same-level</code>) 。</dd>
<dt><code>C-c C-b</code></dt><dd>将光标移至与当前行同级的上一个可见标题行 (<code>outline-backward-same-level</code>) 。</dd>
<dt><code>C-c C-u</code></dt><dd>将光标上移至更高层级（包含性更强）的可见标题行 (<code>outline-up-heading</code>) 。</dd>
</dl>

<p>
上述所有命令均可接收数字参数作为重复执行的次数。例如，为  <code>C-c C-f</code> 指定数字参数时，光标会向前跳转指定次数的同级可见标题行；为 <code>C-c C-u</code> 指定数字参数时，光标会向上跳出指定层数的嵌套标题层级。
</p>
</div>
</div>
<div id="outline-container-Outline-Visibility" class="outline-4">
<h4 id="Outline-Visibility"><span class="section-number-4">27.9.4.</span> 大纲可见性命令</h4>
<div class="outline-text-4" id="text-Outline-Visibility">
<p>
大纲模式提供了若干命令，可基于大纲结构临时隐藏或显示缓冲区中的部分内容。这些命令不支持撤销—— 撤销机制不会记录其执行效果，因此你可直接撤销至执行这些命令之前的状态（参见「<a href="#Undo">撤销</a>」相关说明）。
</p>

<p>
此类命令大多作用于当前标题行：若光标位于某标题行，该行即为当前标题行；若光标位于正文行，当前标题行则为其前方最近的那个标题行。
</p>

<dl class="org-dl">
<dt><code>C-c C-c</code></dt><dd>隐藏当前标题行对应的正文内容 (<code>outline-hide-entry</code>) 。</dd>
<dt><code>C-c C-e</code></dt><dd>显示当前标题行对应的正文内容 (<code>outline-show-entry</code>) 。</dd>
<dt><code>C-c C-d</code></dt><dd>隐藏当前标题行下的所有内容（标题行本身除外） (<code>outline-hide-subtree</code>) 。</dd>
<dt><code>C-c C-s</code></dt><dd>显示当前标题行下的所有内容，包括正文、子标题及其对应的正文 (<code>outline-show-subtree</code>) 。</dd>
<dt><code>C-c C-l</code></dt><dd>隐藏当前标题行及其所有子标题的正文内容 (<code>outline-hide-leaves</code>) 。</dd>
<dt><code>C-c C-k</code></dt><dd>显示当前标题行所有层级的子标题 (<code>outline-show-branches</code>) 。</dd>
<dt><code>C-c C-i</code></dt><dd>显示当前标题行的直接子标题（下一级标题） (<code>outline-show-children</code>) 。</dd>
<dt><code>C-c C-t</code></dt><dd>隐藏缓冲区中的所有正文行 (<code>outline-hide-body</code>) 。</dd>
<dt><code>C-c C-a</code></dt><dd>显示缓冲区中的所有行 (<code>outline-show-all</code>) 。</dd>
<dt><code>C-c C-q</code></dt><dd>仅显示大纲前 <i>n</i> 级标题行，隐藏其余所有内容 (<code>outline-hide-sublevels</code>) 。</dd>
<dt><code>C-c C-o</code></dt><dd>仅显示光标所在的大纲项（标题 / 正文），以及从该位置向上至大纲顶层的所有标题，隐藏其余内容 (<code>outline-hide-other</code>) 。</dd>
<dt><code>C-c /h</code></dt><dd>正则表达式 回车隐藏标题内容匹配指定正则表达式的所有标题对应的正文 (<code>outline-hide-by-heading-regexp</code>)  。</dd>
<dt><code>C-c /s</code></dt><dd>正则表达式 回车显示标题内容匹配指定正则表达式的所有标题对应的正文 (<code>outline-show-by-heading-regexp</code>) 。</dd>
</dl>

<p>
上述命令中最基础的是 <code>C-c C-c</code> (<code>outline-hide-entry</code>) 和 <code>C-c C-e</code> (<code>outline-show-entry</code>) ：前者隐藏紧跟当前标题行的正文内容，后者则将其显示，这两个命令均 <b>不影响子标题及其正文</b> 。
</p>

<p>
<code>C-c C-d</code> (<code>outline-hide-subtree</code>) 和 <code>C-c C-s</code> (<code>outline-show-subtree</code>) 是功能更强大的命令，二者作用于当前标题行的 <b><i>subtree 大纲子树</i></b> ，包括该标题的正文、所有直接和间接子标题，以及这些子标题对应的全部正文。
</p>

<p>
<code>C-c C-l</code> (<code>outline-hide-leaves</code>) 会隐藏当前标题行的正文，以及其大纲子树中所有内容的正文， <b>子标题本身仍保持可见</b> ； <code>C-c C-k</code> (<code>outline-show-branches</code>) 可将此前被隐藏的子标题（如通过 <code>C-c C-d</code> 隐藏）重新显示； <code>C-c C-i</code> (<code>outline-show-children</code>) 是该命令的轻量版本，仅显示当前标题行的直接子标题（即下一级标题）。
</p>

<p>
<code>C-c C-o</code> (<code>outline-hide-other</code>) 会隐藏除以下内容外的所有部分：光标所在的大纲项、该大纲项的所有上级标题（从当前位置至大纲顶层的标题），以及大纲的所有顶层标题；同时，该命令还会显示缓冲区中第一个标题行之前的所有正文行。
</p>

<p>
<code>C-c /h</code> (<code>outline-hide-by-heading-regexp</code>) 会先提示你输入正则表达式，随后隐藏所有标题内容匹配该正则表达式的标题对应的正文； <code>C-c /s</code> (<code>outline-show-by-heading-regexp</code>) 的作用与之相反，会提示输入正则表达式并显示匹配标题的正文。
</p>

<p>
其余命令则作用于 <b>整个缓冲区</b> ：
</p>

<p>
<code>C-c C-t</code> (<code>outline-hide-body</code>) 隐藏所有正文行，仅显示大纲的结构（一个特殊例外：该命令不会隐藏文件开头、第一个标题行之前的内容，尽管从技术上来说这些内容也属于正文行）； <code>C-c C-a</code> (<code>outline-show-all</code>) 显示缓冲区中的所有行； <code>C-c C-q</code> (<code>outline-hide-sublevels</code>) 默认隐藏除当前标题行层级及以上的顶层标题外的所有内容（若光标未在标题行，默认仅显示 1 级标题）；若为该命令指定数字参数  <code>n</code> ，则仅显示大纲的前 <code>n</code> 级标题行，其余内容全部隐藏。注意：该命令会将前 <code>n</code> 级标题行完全显示，同时也会显示第一个标题行之前的所有正文行。
</p>

<p>
大纲模式还提供了两个便捷的循环切换命令，可分别对单个章节和整个缓冲区的内容可见性进行循环切换：在标题行按下 <code>TAB</code> 键 (<code>outline-cycle</code>) ，会将当前章节在「隐藏全部内容」「仅显示子标题」「显示全部内容」三种状态间循环切换；按下 <code>S-TAB</code> 键 (<code>outline-cycle-buffer</code>) ，会将整个缓冲区在「仅显示顶层标题」「显示所有标题（含子标题）」「显示全部内容」三种状态间循环切换。
</p>

<p>
当增量搜索找到被大纲模式隐藏的文本时，会自动将缓冲区中的该部分内容显示；若你在该位置退出搜索，文本仍会保持可见。若要切换 <b>激活的增量搜索</b> 是否可匹配隐藏文本，可按下 <code>M-s i</code> ；若要修改后续搜索的默认行为，可自定义选项 <code>search-invisible</code> （该选项也会影响查询替换及相关函数对隐藏文本的处理方式，参见「<a href="#Query-Replace">查询替换</a>」相关说明）。你也可启用 <b>显示模式</b> （M-x reveal-mode，一种缓冲区局部的次要模式），在导航文本时自动显示对应的隐藏内容。
</p>

<p>
变量 <code>outline-default-state</code> 用于控制启用大纲模式后，哪些标题行默认保持可见，其取值对应不同的初始可见性规则：
</p>
<ul class="org-ul">
<li>设为非空值：部分标题行默认处于大纲折叠状态；</li>
<li>设为数字 <code>n</code> ：仅显示第 <code>n</code> 级及以上层级的标题行；</li>
<li>设为 <code>outline-show-all</code> ：显示缓冲区中的所有文本内容；</li>
<li>设为 <code>outline-show-only-headings</code> ：仅显示所有标题行（无论层级），隐藏所有正文；</li>
<li>设为 lambda 匿名函数 / 函数名：启用大纲模式后，会无参调用该函数，由函数控制标题行的可见性切换。</li>
</ul>
</div>
</div>
<div id="outline-container-Outline-Views" class="outline-4">
<h4 id="Outline-Views"><span class="section-number-4">27.9.5.</span> 多视图查看单个大纲</h4>
<div class="outline-text-4" id="text-Outline-Views">
<p>
你可在不同窗口中同时显示同一个大纲的两个视图，操作时需通过 <code>M-x make-indirect-buffer</code> 命令创建 <b>indirect buffer 间接缓冲区</b> 。该命令的第一个参数为已存在的大纲缓冲区名称，第二个参数为新建间接缓冲区的自定义名称（详见「<a href="#Indirect-Buffers">间接缓冲区</a>」相关说明）。
</p>

<p>
间接缓冲区创建完成后，即可通过 <code>C-x 4 b</code> 或其他 Emacs 常规命令，在窗口中展示该缓冲区。大纲模式中用于隐藏、显示文本内容的各类命令，会 <b>对每个缓冲区独立生效</b> ；因此每个缓冲区均可拥有专属的大纲视图。若需为同一个大纲创建两个以上的视图，新建更多间接缓冲区即可。
</p>
</div>
</div>
<div id="outline-container-Foldout" class="outline-4">
<h4 id="Foldout"><span class="section-number-4">27.9.6.</span> 折叠编辑</h4>
<div class="outline-text-4" id="text-Foldout">
<p>
Foldout 折叠扩展包为大纲模式和大纲次要模式新增了折叠相关命令。折叠的核心思路是 <b>聚焦大纲的嵌套部分</b> ，同时隐藏其更高层级的同级内容。
</p>

<p>
假设某大纲模式缓冲区中，所有一级标题下的文本和子标题均处于隐藏状态。若要查看其中某个一级标题下的隐藏内容，你可使用 <code>C-c C-e</code> (<code>M-x outline-show-entry</code>) 显示其正文，或使用 <code>C-c C-i</code> 显示其子级（二级）标题。
</p>

<p>
而使用 Foldout 扩展包时，你只需按下 <code>C-c C-z</code> (<code>M-x foldout-zoom-subtree</code>) ，该操作会同时显示目标一级标题的正文和二级子标题，并对缓冲区进行 <b>缩窄处理</b> ，最终仅保留该一级标题、其正文及下属二级标题的可见性。若需继续查看某二级标题下的内容，将光标移至该二级标题处，再次按下 <code>C-c C-z</code> 即可 —— 此操作会显示该二级标题的正文和三级子标题，并再次缩窄缓冲区。你可根据需要，对后续各级子标题持续执行该聚焦操作，模式行中会显示当前的折叠聚焦层级。
</p>

<p>
对标题执行聚焦操作时，若仅需显示其子级标题，可为命令指定 <b>数字参数</b> ： <code>C-u C-c C-z</code> ；你也可指定显示的子标题层级数（可对比 <code>M-x outline-show-children</code> 命令），例如 <code>M-2 C-c C-z</code> 会显示目标标题下 <b>两层</b> 子标题。反之，若仅需显示目标标题的正文，可指定 <b>负参数</b> ： <code>M-- C-c C-z</code> ；若要展开目标标题的整个子树（效果等同于 <code>C-c C-s</code>  / <code>M-x outline-show-subtree</code> ），则指定 <b>零参数</b> ： <code>M-0 C-c C-z</code> 。
</p>

<p>
处于折叠聚焦状态时，你仍可正常使用大纲模式的各类显示 / 隐藏命令，且不会影响 Foldout 的折叠状态。同时，由于缓冲区已被缩窄，所有全局编辑操作 <b>仅会作用于当前聚焦标题下的内容</b> ，这一特性可帮助你将修改范围限定在文档的特定章节或小节中。
</p>

<p>
若要 <b>退出折叠聚焦</b> ，按下 <code>C-c C-x</code> (<code>M-x foldout-exit-fold</code>) 即可，该操作会隐藏当前顶层聚焦标题下的所有文本和子标题，并恢复缓冲区此前的视图。为该命令指定数字参数，可退出对应层数的折叠；指定零参数，则会直接退出所有折叠层级。
</p>

<p>
若希望 <b>取消缓冲区的缩窄处理</b> ，但保留当前已显示的文本和子标题（不隐藏），可为退出命令指定负参数。例如 <code>M--2 C-c C-x</code> ，会退出两层折叠，且保持当前所有文本和子标题的可见状态。
</p>

<p>
Foldout 模式还提供了鼠标操作命令，用于执行折叠的进入、退出及文本的显示 / 隐藏，具体如下：
</p>
<ul class="org-ul">
<li><code>C-M-mouse-1</code> 聚焦点击的目标标题
<ul class="org-ul">
<li>单击：显示标题正文</li>
<li>双击：显示标题的子级标题</li>
<li>三击：显示标题的正文和子级标题</li>
<li>四击：展开标题的整个子树</li>
</ul></li>

<li><code>C-M-mouse-2</code> 显示点击的目标标题下的内容
<ul class="org-ul">
<li>单击：显示标题正文</li>
<li>双击：显示标题的子级标题</li>
<li>三击：显示标题的正文和子级标题</li>
<li>四击：展开标题的整个子树</li>
</ul></li>

<li><code>C-M-mouse-3</code> 隐藏点击的目标标题下的内容，或退出折叠
<ul class="org-ul">
<li>单击：隐藏标题的整个子树</li>
<li>双击：退出折叠并隐藏对应内容</li>
<li>三击：退出折叠，保留内容可见</li>
<li>四击：退出所有折叠并隐藏对应内容</li>
</ul></li>
</ul>

<p>
你可通过设置变量 <code>foldout-mouse-modifiers</code> ，自定义鼠标操作的修饰键（替代默认的 Ctrl+Meta 组合键）；但需注意，若你已加载 <code>foldout.el</code> 库文件，需 <b>重新加载</b> 该库，修改才能生效。
</p>

<p>
使用 Foldout 扩展包的方法有两种：一是手动键入 <code>M-x load-library RET foldout RET</code> 加载；二是将以下代码添加至 Emacs 初始化文件中，实现 <b>自动加载</b> ：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">with-eval-after-load</span> <span style="color: #8b2252;">"outline"</span>
  (<span style="color: #a020f0;">require</span> '<span style="color: #008b8b;">foldout</span>))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-Org-Mode" class="outline-3">
<h3 id="Org-Mode"><span class="section-number-3">27.10.</span> 组织模式（Org Mode）</h3>
<div class="outline-text-3" id="text-Org-Mode">
<p>
Org 模式是大纲模式的一个变体，专为将 Emacs 用作事务管理工具和 / 或文档编辑系统设计。扩展名以 <code>.org</code> 结尾的文件会默认以 Org 模式打开（参见《<a href="#Choosing-Modes">选择文件模式</a>》）；若要显式切换至 Org 模式，可键入 <code>M-x org-mode</code> 命令。
</p>

<p>
与大纲模式一致，Org 模式中每个大纲项都有以一个或多个星号（ '<code>*</code>' ）开头的标题行（详见《<a href="#Outline-Format">大纲的格式</a>》）。此外，所有以井号（ '<code>#</code>' ）开头的行都会被视作 <b>注释行</b> 。
</p>

<p>
Org 模式提供了便捷的命令，用于查看和操作大纲结构，其中最基础的是 <code>TAB</code> 键 (<code>org-cycle</code>) 。若在标题行触发该命令，会对当前大纲子树的可见状态进行循环切换，依次为：(1) 仅显示该标题行；(2) 仅显示该标题行及其直接子标题行（若存在）；(3) 显示整个大纲子树。若在正文行触发该命令，则会执行 <code>TAB</code> 键的全局绑定功能。
</p>

<p>
在 Org 模式缓冲区的任意位置按下 <code>S-TAB</code> 键 (<code>org-shifttab</code>) ，会对整个大纲结构的可见状态进行循环切换，依次为：(1) 仅显示顶层标题行；(2) 显示所有标题行、隐藏所有正文行；(3) 显示所有内容。
</p>

<p>
在标题行按下 <code>M-UP</code> (<code>org-metaup</code>) 或 <code>M-DOWN</code> (<code>org-metadown</code>) ，可将 <b>整个大纲项</b> （包括其正文行和下属子树，若有）在缓冲区中向上或向下移动；同理，按下 <code>M-LEFT</code> (<code>org-metaleft</code>) 和 <code>M-RIGHT</code> (<code>org-metaright</code>) ，可对标题行进行 <b>升级</b> 或 <b>降级</b> 操作。若在正文行触发这些快捷键，则会执行其全局绑定功能。
</p>

<p>
下述小节将介绍将 Org 模式用作事务管理工具和文档编辑系统的基础用法，更多细节可参见《Org 模式手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/org/index.html#Top">简介</a>》章节。
</p>

<ul class="org-ul">
<li><a href="#Org-Organizer">作为事务管理器的 Org 模式</a></li>
<li><a href="#Org-Authoring">作为创作系统的 Org 模式</a></li>
</ul>
</div>
<div id="outline-container-Org-Organizer" class="outline-4">
<h4 id="Org-Organizer"><span class="section-number-4">27.10.1.</span> 作为事务管理器的 Org 模式</h4>
<div class="outline-text-4" id="text-Org-Organizer">
<p>
在大纲项内的任意位置按下 <code>C-c C-t</code> (<code>org-todo</code>) ，即可将该 Org 大纲项标记为 <b><i>TODO item 待办项</i></b> ，此操作会在标题行添加 'TODO' 关键字。再次按下 <code>C-c C-t</code> ，关键字会切换为 'DONE' ；第三次按下则会彻底移除该关键字，后续按动会按自定义的关键字序列循环切换。你可通过变量 <code>org-todo-keywords</code> ，自定义 <code>C-c C-t</code> 命令所使用的关键字。
</p>

<p>
除了将大纲项标记为待办，还可在项内按下 <code>C-c C-s</code> (<code>org-schedule</code>) 为其添加 <b>日程日期</b> 。该命令会弹出 Emacs 日历供你选择日期（参见《<a href="#Calendar_002fDiary">日历与日记</a>》），并在标题行下方添加 'SCHEDULED' 标签及选定的日期。 <code>C-c C-d</code> (<code>org-deadline</code>) 命令的操作方式与之相同，区别仅在于该命令使用 'DEADLINE' （截止日期）标签。
</p>

<p>
当你在 Org 文件中规划了若干待办项后，按下 <code>C-c [</code> (<code>org-agenda-file-to-front</code>) ，即可将该文件添加至 <b>日程文件列表</b> 中。Org 模式支持便捷管理多个日程文件，可用于规划生活中的不同事务板块，日程文件列表的信息会存储在变量 <code>org-agenda-files</code> 中。
</p>

<p>
要查看所有日程文件中的事项，键入 <code>M-x org-agenda</code> 即可。该命令会提示你选择查看的内容类型，例如本周待办事项列表、含特定关键字的待办项列表等。更多细节可参见《Org 模式手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/org/Agenda-Views.html#Agenda-Views">日程视图</a>》章节。
</p>
</div>
</div>
<div id="outline-container-Org-Authoring" class="outline-4">
<h4 id="Org-Authoring"><span class="section-number-4">27.10.2.</span> 作为创作系统的 Org 模式</h4>
<div class="outline-text-4" id="text-Org-Authoring">
<p>
你可对 Org 笔记进行美观的格式排版，并将其整理为适用于导出和发布的形式。在 Org 缓冲区的任意位置按下 <code>C-c C-e</code> (<code>org-export-dispatch</code>) ，即可导出当前缓冲区的内容。该命令会提示你选择导出格式，目前支持的格式包括 HTML、LaTeX、Texinfo、开放文档（.odt）、iCalendar、Markdown、手册页以及 PDF。部分格式（如 PDF）需要安装相应的系统工具方可使用。
</p>

<p>
若要将多个文件一次性导出至本地或网络中的指定目录，你需要通过变量 <code>org-publish-project-alist</code> 定义项目列表，具体细节可参考该变量的说明文档。
</p>

<p>
Org 模式支持一套简洁的标记语法，可对导出文档的文本进行格式设置，示例如下：
</p>

<div class="org-src-container">
<pre class="src src-org">- This text is <span style="font-style: italic;">/emphasized/</span>
- This text is <span style="font-weight: bold;">*in bold*</span>
- This text is <span style="text-decoration: underline;">_underlined_</span>
- This text uses <span style="color: #7f7f7f;">=a teletype font=</span>

<span style="color: #b22222;">#+begin_quote
</span>``This is a quote.''
<span style="color: #b22222;">#+end_quote
</span>
<span style="color: #b22222;">#+begin_example
</span><span style="color: #7f7f7f;">This is an example.
</span><span style="color: #b22222;">#+end_example</span>
</pre>
</div>

<p>
更多详细内容，可参见《Org 模式手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/org/Exporting.html#Exporting">导出</a>」章节与「<a href="https://www.gnu.org/software/emacs/manual/html_node/org/Publishing.html#Publishing">发布</a>」章节。
</p>
</div>
</div>
</div>
<div id="outline-container-TeX-Mode" class="outline-3">
<h3 id="TeX-Mode"><span class="section-number-3">27.11.</span> TeX 模式</h3>
<div class="outline-text-3" id="text-TeX-Mode">
<p>
TeX 是由  Donald Knuth (唐纳德・克努特) 编写的一款功能强大的文本格式化程序，与 GNU Emacs 一样，它属于自由软件。TeX 格式拥有多个衍生版本，包括：LaTeX（TeX 的简化输入格式）、DocTeX（编写 LaTeX 源码所使用的专用文件格式，将源码与文档说明融为一体）以及 SliTeX（LaTeX 的一款已废弃专用格式<sup><a id="fnr.13" class="footref" href="#fn.13" role="doc-backlink">13</a></sup>）。
</p>

<p>
Emacs 为上述每一种 TeX 衍生版本都提供了对应的 TeX 主模式：纯 TeX  mode、LaTeX mode、DocTeX  mode 和 SliTeX mode 。Emacs 会通过分析缓冲区的内容，自动选择对应的模式（该操作由 <code>tex-mode</code> 命令完成，打开类 TeX 文件时该命令通常会自动调用，参见《<a href="#Choosing-Modes">选择文件模式</a>》）。若缓冲区内容不足以判定格式类型，Emacs 会选用变量 <code>tex-default-mode</code> 指定的模式，该变量的默认值为 <code>latex-mode</code> （LaTeX 模式）。若 Emacs 的自动识别结果有误，你可通过 <code>plain-tex-mode</code> 、 <code>latex-mode</code> 、 <code>slitex-mode</code> 或 <code>doctex-mode</code> 命令，手动选择正确的 TeX 衍生模式。
</p>

<p>
以下小节将介绍 TeX 模式及其各衍生版本的功能特性。另有多款与 TeX 相关的 Emacs 扩展包未在本手册中说明，相关信息如下：
</p>
<ul class="org-ul">
<li>BibTeX mode：适用于 BibTeX 文件的主模式，该类文件常用于管理 LaTeX 文档的参考文献。更多信息可查阅 <code>bibtex-mode</code> 命令的文档字符串。</li>
<li>RefTeX 扩展包：提供一款可与 LaTeX 模式配合使用的次要模式，用于管理参考文献。更多信息可参见随 Emacs 发布的 <a href="https://www.gnu.org/software/emacs/manual/reftex.html">RefTeX 信息手册</a>。</li>
<li>AUCTeX 扩展包：为编辑 TeX 及其相关格式提供更高级的功能，包括在 Emacs 缓冲区中预览 TeX 公式的能力。与 BibTeX 模式和 RefTeX 扩展包不同，AUCTeX 并非 Emacs 的默认内置扩展包，可通过软件包菜单下载（参见《<a href="#Packages">Emacs Lisp 软件包</a>》）；安装完成后，可参阅该扩展包自带的 AUCTeX 手册。</li>

<li><a href="#TeX-Editing">TeX 编辑命令</a></li>
<li><a href="#LaTeX-Editing">LaTeX 编辑命令</a></li>
<li><a href="#TeX-Print">TeX 打印命令</a></li>
<li><a href="#TeX-Misc">TeX 模式杂项功能</a></li>
</ul>
</div>
<div id="outline-container-TeX-Editing" class="outline-4">
<h4 id="TeX-Editing"><span class="section-number-4">27.11.1.</span> TeX 编辑命令</h4>
<div class="outline-text-4" id="text-TeX-Editing">
<dl class="org-dl">
<dt><code>"</code></dt><dd>根据上下文插入 ‘``’ 、‘"’或‘''’ (<code>tex-insert-quote</code>) 。</dd>
<dt><code>C-j</code></dt><dd>插入段落分隔符（两个换行符），并检查前一段落是否存在大括号或美元符配对不匹配的情况 (<code>tex-terminate-paragraph</code>) 。</dd>
<dt><code>M-x tex-validate-region</code></dt><dd>检查选中区域内的每一个段落，排查大括号或美元符的配对不匹配问题。</dd>
<dt><code>C-c {</code></dt><dd>插入 ‘{}’，并将光标定位在两个符号之间 (<code>tex-insert-braces</code>) 。</dd>
<dt><code>C-c }</code></dt><dd>向前移动光标，跳过下一个未配对的右大括号 (<code>up-list</code>) 。</dd>
</dl>

<p>
在 TeX 中，通常不使用双引号字符‘"’；引用内容需以两个反引号‘``’ 开头，以两个单引号 ‘''’结尾。因此 TeX 模式会将双绰号 <code>"</code> 键绑定到 <code>tex-insert-quote</code> 命令。该命令的行为为：在空白字符或左大括号后，在反斜杠后按下 <code>"</code> 双绰号，会直接插入 <code>``</code> 反引号 ；在其他任意字符后会插入 <code>''</code> 双单引号 。
</p>

<p>
有一个特殊例外规则：若光标前的文本是 <code>``</code> 反引号或 <code>''</code> 双单引号，此时按下 <code>"</code> 双引号，Emacs 会将光标前的这两个字符替换为单个 <code>"</code> 双引号字符。因此当你需要插入单个 <code>"</code> 双引号时，直接连续按两次 <code>"</code> 双引号即可实现（也可使用快捷键 <code>C-q "</code> 插入该字符）。
</p>

<p>
在 TeX 模式下，美元符 '<code>$</code>' 被赋予特殊的语法编码，用以识别 TeX 数学模式分隔符的配对规则。当你插入一个用于退出数学模式的 '<code>$</code>' 时，系统会短暂显示对应的、用于进入数学模式的配对 '<code>$</code>' 的位置。这一功能与插入右大括号时，系统显示配对左大括号位置的功能一致。但由于系统无法判断一个 '<code>$</code>' 是用于进入还是退出数学模式，因此当你插入一个用于进入数学模式的 '<code>$</code>' 时，系统仍会显示上一个 '<code>$</code>' 的位置，仿佛二者是配对关系，即便它们实际上并无关联。
</p>

<p>
TeX 将大括号作为必须严格配对的分隔符。部分用户倾向于始终保持大括号成对存在，而非单独插入单侧。可使用快捷键 <code>C-c {</code> (<code>tex-insert-braces</code>) 插入一对大括号，光标会停在两个大括号之间，方便你输入括号内的内容。输入完成后，可使用快捷键 <code>C-c }</code> (<code>up-list</code>) 将光标移至右大括号后方。若你已选中一段文本，再按下 <code>C-c {</code> ，该命令会直接将选中的文本用一对大括号包裹起来。
</p>

<p>
Emacs 提供了两个检查大括号配对的命令： <code>C-j</code> (<code>tex-terminate-paragraph</code>) 会检查光标所在位置之前的整段文本，同时插入两个换行符以开始新段落；若检测到配对错误，会在回显区输出提示信息。执行 <code>M-x tex-validate-region</code> 命令可逐段检查选中的区域，所有配对错误会列在 <code>*Occur*</code> 缓冲区中，你可在该缓冲区使用 Occur 模式的常规命令（如 <code>C-c C-c</code> ）定位到具体的配对错误位置（详见「<a href="#Other-Repeating-Search">其他搜索与循环命令</a>」）。
</p>

<p>
需注意，在 TeX 模式下，Emacs 的各类命令会对中括号、小括号和大括号一并进行配对计数，而非仅检查大括号。从 TeX 语法检查的严格角度来说，这一处理方式并不完全合规；但由于小括号和中括号在文本中也常作为需要配对的分隔符使用，让各类光标移动命令和自动配对显示功能支持这两类符号，实际使用中会更为便捷。
</p>
</div>
</div>
<div id="outline-container-LaTeX-Editing" class="outline-4">
<h4 id="LaTeX-Editing"><span class="section-number-4">27.11.2.</span> LaTeX 编辑命令</h4>
<div class="outline-text-4" id="text-LaTeX-Editing">
<p>
LaTeX 模式提供了若干不适用于纯 TeX 的额外功能：
</p>
<dl class="org-dl">
<dt><code>C-c C-o</code></dt><dd>插入 LaTeX 块的 '<code>\begin</code>' 和 '<code>\end</code>' 命令，并将光标定位到二者之间的空行 (<code>latex-insert-block</code>) 。</dd>
<dt><code>C-c C-e</code></dt><dd>闭合最内层尚未闭合的 LaTeX 块 (<code>latex-close-block</code>) 。</dd>
</dl>

<p>
在 LaTeX 输入中， '<code>\begin</code>' 和 '<code>\end</code>' 标记用于对文本块进行分组。插入文本块时，按下 <code>C-c C-o</code> (<code>latex-insert-block</code>) ，该命令会提示输入块类型，随后插入配对的对应 '<code>\begin</code>' 和 '<code>\end</code>' 标记，在二者之间保留一行空行并将光标移至该行。
</p>

<p>
在为 <code>C-c C-o</code> 命令输入块类型参数时，可使用常规的补全命令（详见「<a href="#Completion">补全</a>」章节）。默认补全列表包含标准的 LaTeX 块类型；若需在补全中添加更多块类型，可自定义列表型变量 <code>latex-block-names</code> 。
</p>

<p>
在 LaTeX 输入中， '<code>\begin</code>' 和 '<code>\end</code>' 标记必须成对出现。按下 <code>C-c C-e</code> (<code>latex-close-block</code>) 可插入与最后一个未配对 '<code>\begin</code>' 相匹配的 '<code>\end</code>' 标记，同时会为该 '<code>\end</code>' 标记设置与对应 '<code>\begin</code>' 一致的缩进；若光标位于行首，还会在 '<code>\end</code>' 标记后插入一个换行符。次要模式 <code>latex-electric-env-pair-mode</code> 开启后，当你输入 '<code>\begin</code>' 或 '<code>\end</code>' 标记时，会自动为你插入配对的另一标记。
</p>
</div>
</div>
<div id="outline-container-TeX-Print" class="outline-4">
<h4 id="TeX-Print"><span class="section-number-4">27.11.3.</span> TeX 打印命令</h4>
<div class="outline-text-4" id="text-TeX-Print">
<p>
你可以将 TeX 作为 Emacs 的子进程调用，编译缓冲区中的全部内容，也可仅编译部分内容（例如大型文档中的某一章节）。
</p>

<dl class="org-dl">
<dt><code>C-c C-b</code></dt><dd>对当前缓冲区的全部内容调用 TeX 编译 (<code>tex-buffer</code>) 。</dd>
<dt><code>C-c C-r</code></dt><dd>结合缓冲区的头部内容，对当前区域调用 TeX 编译 (<code>tex-region</code>) 。</dd>
<dt><code>C-c C-f</code></dt><dd>对当前文件调用 TeX 编译 (<code>tex-file</code>) 。</dd>
<dt><code>C-c C-v</code></dt><dd>预览上一次执行 <code>C-c C-b</code> 、 <code>C-c C-r</code> 或 <code>C-c C-f</code> 命令后的编译输出结果 (<code>tex-view</code>) 。</dd>
<dt><code>C-c C-p</code></dt><dd>打印上一次执行 <code>C-c C-b</code> 、=C-c C-r= 或 <code>C-c C-f</code> 命令后的编译输出文件 (<code>tex-print</code>) 。</dd>
<dt><code>C-c TAB</code></dt><dd>对当前文件调用 BibTeX 进行参考文献处理 (<code>tex-bibtex-file</code>) 。</dd>
<dt><code>C-c C-l</code></dt><dd>将显示 TeX 编译输出的窗口重定中心，使最后一行内容可见 (<code>tex-recenter-output-buffer</code>) 。</dd>
<dt><code>C-c C-k</code></dt><dd>终止 TeX 子进程 (<code>tex-kill-job</code>) 。</dd>
<dt><code>C-c C-c</code></dt><dd>对当前缓冲区的全部内容调用其他编译命令 (<code>tex-compile</code>) 。</dd>
</dl>

<p>
要对当前缓冲区内容进行 TeX 编译，按下 <code>C-c C-b</code> (<code>tex-buffer</code>) 即可，格式化后的输出内容会写入一个临时文件，默认是 <code>.dvi</code> 格式文件。编译完成后，可按下 <code>C-c C-v</code> (<code>tex-view</code>) 启动 <code>xdvi</code> 等外部程序查看该输出文件，也可按下 <code>C-c C-p</code> (<code>tex-print</code>) 打印输出文件的硬拷贝。
</p>

<p>
默认情况下， <code>C-c C-b</code> 会在 <b>当前目录</b> 中运行 TeX，编译输出文件也会生成在该目录。若要在其他目录运行 TeX，可将变量 <code>tex-directory</code> 修改为目标目录。如果你的环境变量 <code>TEXINPUTS</code> 包含相对路径，或 TeX 文件中使用了带相对文件名的 '<code>\input</code>' 命令，那么 <code>tex-directory</code> 必须设为 <code>.</code> （当前目录），否则会出现编译错误；其他情况下，可安全地指定 '/tmp' 等其他目录。
</p>

<p>
缓冲区使用的 TeX 变体，决定了 <code>C-c C-b</code> 实际执行的 Shell 命令：纯 TeX 模式下，由变量 <code>tex-run-command</code> 指定，默认值为 <code>tex</code> ；LaTeX 模式下，由变量 <code>latex-run-command</code> 指定，默认值为 <code>latex</code> 。无论使用哪种 TeX 变体， <code>C-c C-v</code> 用于查看 <code>.dvi</code> 输出文件的 Shell 命令，均由变量 <code>tex-dvi-view-command</code> 决定； <code>C-c C-p</code> 用于打印输出文件的 Shell 命令，均由变量 <code>tex-dvi-print-command</code> 决定。可通过变量 <code>tex-print-file-extension</code> 设置 TeX 编译文件的查看和打印所需扩展名，例如将其设为 <code>.pdf</code> ，并相应更新 <code>tex-dvi-view-command</code> 、 <code>tex-dvi-print-command</code> ，以及 <code>latex-run-command</code> 或 <code>tex-run-command</code> 。
</p>

<p>
通常，Emacs 会自动将输出文件名追加到上述 Shell 命令后。例如若 <code>tex-dvi-view-command</code> 设为 <code>xdvi</code> ，执行 <code>C-c C-v</code> 时会运行 <code>xdvi</code> 输出文件名。但在某些场景下，需要将文件名嵌入命令中（例如需将文件名作为某一命令的参数，且该命令的输出通过管道传递给另一命令），此时可在命令字符串中用 '<code>*</code>' 指定文件名的插入位置，示例如下：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq</span> tex-dvi-print-command <span style="color: #8b2252;">"dvips -f * | lpr"</span>)
</pre>
</div>

<p>
TeX 的终端输出（包括所有错误信息）会显示在名为 <code>*tex-shell*</code> 的缓冲区中。若 TeX 编译出现错误，你可切换至该缓冲区并输入交互指令（操作方式与 Shell 模式一致，详见「<a href="#Interactive-Shell">交互式子 Shell</a>」章节）；无需切换缓冲区时，按下 <code>C-c C-l</code> 即可滚动该缓冲区，使最后一行内容可见。
</p>

<p>
若发现 TeX 进程的输出不再有参考价值，按下 <code>C-c C-k</code> (<code>tex-kill-job</code>) 即可终止该进程；执行 <code>C-c C-b</code> 或 <code>C-c C-r</code> 时，也会自动终止仍在运行的 TeX 进程。
</p>

<p>
你也可按下 <code>C-c C-r</code> (<code>tex-region</code>) ，对任意指定区域进行 TeX 编译，但该操作存在一定限制：大多数 TeX 输入文件的开头会包含参数设置和宏定义命令，缺少这些命令，文件后续内容将无法正确格式化。为解决该问题， <code>C-c C-r</code> 允许你将文件中的某一部分标记为 <b>核心命令区（头部）</b> ，编译时会将该区域内容作为 TeX 输入的一部分，添加到指定编译区域之前。文件中这一被标记的部分称为 <b>头部（header）</b> 。
</p>

<p>
在 <b>纯 TeX 模式</b> 下，需在文件中插入两个特殊字符串来标记头部的范围：在头部内容前插入 '<code>%**start of header</code>' ，在头部内容后插入 '<code>%**end of header</code>' 。每个字符串必须完整出现在单独一行中，该行前后可包含其他文本，且包含这两个字符串的行也会被纳入头部。若在缓冲区的前 100 行中未找到 '<code>%**start of header</code>' ， <code>C-c C-r</code> 会判定该文件无头部。
</p>

<p>
在 <b>LaTeX 模式</b> 下，头部内容以 '<code>\documentclass</code>' 或 '<code>\documentstyle</code>' 开头，以 '<code>\begin{document}</code>' 结尾。这些是 LaTeX 对所有文档的强制要求命令，因此无需额外操作即可自动识别头部。
</p>

<p>
<code>tex-buffer</code> 和 <code>tex-region</code> 命令的所有操作均在 <b>临时目录</b> 中执行，无法访问 TeX 交叉引用所需的任何辅助文件；因此这些命令通常不适合编译需要保证所有交叉引用均正确的最终版本文档。
</p>

<p>
若需要生成交叉引用所需的辅助文件，请使用 <code>C-c C-f</code> (<code>tex-file</code>) 命令，该命令会在当前缓冲区对应文件的 <b>所在目录</b> 中，对该文件执行 TeX 编译。运行 TeX 前，Emacs 会提示保存所有已修改的缓冲区。通常需要执行两次 <code>tex-file</code> 命令，才能保证交叉引用的内容全部正确。
</p>

<p>
变量 <code>tex-start-options</code> 的取值，用于指定 TeX 编译时的运行选项。变量 <code>tex-start-commands</code> 的取值，用于指定启动 TeX 的 TeX 命令，默认值会让 TeX 以 <b>非停止模式</b> 运行；若要以交互模式运行 TeX，将该变量设为空字符串 <code>""</code> 即可。
</p>

<p>
大型 TeX 文档通常会拆分为多个文件，包含一个主文件和若干子文件。直接对於文件执行 TeX 编译通常无法成功，必须对主文件进行编译。为了在编辑子文件时， <code>tex-file</code> 命令仍能正常使用，可将变量 <code>tex-main-file</code> 设为主文件的名称，此后执行 <code>tex-file</code> 时，会自动对该主文件进行编译。
</p>

<p>
使用 <code>tex-main-file</code> 最便捷的方式，是在每个子文件的 <b>局部变量列表</b> 中指定其值（详见「<a href="#File-Variables">文件中的局部变量</a>」章节）。
</p>

<p>
对于 LaTeX 文件，可使用 BibTeX 处理当前缓冲区对应文件的辅助文件：BibTeX 会在参考文献数据库中检索引用条目，并为文档的参考文献部分生成格式化的引用内容。按下  <code>C-c TAB</code> (<code>tex-bibtex-file</code>) 会执行 Shell 命令 <code>tex-bibtex-command</code> ，为当前文件生成.bbl 格式的参考文献文件。通常的操作流程为：先执行一次 <code>C-c C-f</code> (<code>tex-file</code>)  生成 <code>.aux</code> 辅助文件，再执行 <code>C-c TAB</code> (<code>tex-bibtex-file</code>) 处理参考文献，最后再执行两次 <code>C-c C-f</code> (<code>tex-file</code>) ，即可保证交叉引用和参考文献均正确显示。
</p>

<p>
若要对当前 TeX 缓冲区调用其他编译程序，按下 <code>C-c C-c</code> (<code>tex-compile</code>) 即可。该命令支持为 <code>pdflatex</code> 、 <code>yap</code> 、 <code>xdvi</code> 、 <code>dvips</code> 等常用编译程序传递参数，你可使用标准的补全按键选择所需的编译程序（详见「<a href="#Completion">补全</a>」章节）。
</p>
</div>
</div>
<div id="outline-container-TeX-Misc" class="outline-4">
<h4 id="TeX-Misc"><span class="section-number-4">27.11.4.</span> TeX 模式杂项功能</h4>
<div class="outline-text-4" id="text-TeX-Misc">
<p>
进入任意一种 TeX 模式变体时，会先执行钩子函数 <code>text-mode-hook</code> 和 <code>tex-mode-hook</code> ，随后根据实际模式，执行对应的 <code>plain-tex-mode-hook</code> 、 <code>doctex-mode-hook</code> 、 <code>latex-mode-hook</code> 或 <code>slitex-mode-hook</code> 。启动 TeX Shell 时，会执行钩子函数 <code>tex-shell-hook</code> 。相关说明详见「<a href="#Hooks">钩子函数</a>」章节。
</p>

<p>
可使用命令 <code>M-x iso-iso2tex</code> 、 <code>M-x iso-tex2iso</code> 、 <code>M-x iso-iso2gtex</code> 和 <code>M-x iso-gtex2iso</code> ，实现 Latin-1 编码文件与 TeX 编码等效文件之间的格式转换。
</p>
</div>
</div>
</div>
<div id="outline-container-HTML-Mode" class="outline-3">
<h3 id="HTML-Mode"><span class="section-number-3">27.12.</span> SGML 与 HTML 模式</h3>
<div class="outline-text-3" id="text-HTML-Mode">
<p>
SGML 和 HTML 对应的主模式提供缩进支持，并内置了针对标签的操作命令。
</p>

<p>
HTML 相关的编辑包含两种模式：一种是基础的 <code>html-mode</code> （HTML 模式），它是 SGML 模式的轻量定制版本；另一种是 <code>mhtml-mode</code> （多模式 HTML），也是 Emacs 对 HTML 文件的默认模式，该模式可正确处理 <code>&lt;script&gt;</code> 标签中嵌入的 JavaScript 代码，以及 <code>&lt;style&gt;</code> 标签中嵌入的 CSS 样式代码。
</p>

<p>
<b>核心快捷键与对应功能</b>
</p>
<dl class="org-dl">
<dt><code>C-c C-n</code></dt><dd>交互式指定特殊字符，并插入该字符对应的 SGML 转义命令（以 '<code>&amp;</code>' 开头） (<code>sgml-name-char</code>) 。</dd>
<dt><code>C-c C-t</code></dt><dd><p>
交互式指定标签及其属性 (<code>sgml-tag</code>) 。该命令会先提示输入标签名和各属性值，随后插入配对的开始标签与结束标签，并将光标定位在两个标签之间。
</p>

<p>
若带数字前缀参数 <code>n</code> ，该命令会将标签包裹在光标后方的 <code>n</code> 个单词外；当区域处于激活状态时，标签会直接包裹该区域（若暂存标记模式关闭，传入数字参数-1也可实现区域包裹功能）。
</p></dd>
<dt><code>C-c C-a</code></dt><dd>为当前标签交互式插入属性值 (<code>sgml-attributes</code>) 。</dd>
<dt><code>C-c C-f</code></dt><dd>跳过一组配对的标签（即从开始标签到对应结束标签的完整内容） (<code>sgml-skip-tag-forward</code>) 。数字参数可指定跳过的次数。</dd>
<dt><code>C-c C-b</code></dt><dd>反向跳过一组配对的标签 (<code>sgml-skip-tag-backward</code>) 。数字参数可指定反向跳过的次数。</dd>
<dt><code>C-c C-d</code></dt><dd>删除光标位置或光标后方的标签，并同时删除其配对的标签 (<code>sgml-delete-tag</code>) 。若目标标签是开始标签，会连带删除结束标签；若为结束标签，则连带删除开始标签。</dd>
<dt><code>C-c ? 标签名 RET</code></dt><dd>显示指定标签的含义说明 (<code>sgml-tag-help</code>) 。若未输入标签名（直接回车），则说明光标所在位置的标签。</dd>
<dt><code>C-c /</code></dt><dd>为最内层未闭合的标签插入结束标签 (<code>sgml-close-tag</code>) 。若光标处于某一标签内部或注释内容中，该命令会直接闭合当前标签 或 注释，而非插入新的结束标签。</dd>
<dt><code>C-c 8</code></dt><dd>切换一个次要模式，开启后输入 Latin-1 字符时，会自动插入其对应的 SGML 转义命令，而非字符本身 (<code>sgml-name-8bit-mode</code>) 。</dd>
<dt><code>C-c C-v</code></dt><dd>执行自定义的 Shell 命令，对当前缓冲区的内容进行 SGML 有效性验证 (<code>sgml-validate</code>) （在 HTML 模式下，该快捷键对应其他命令）。</dd>
<dt><code>C-c TAB</code></dt><dd>切换缓冲区中现有标签的可见性，可作为简易的预览功能使用 (<code>sgml-tags-invisible</code>) 。</dd>
</dl>

<p>
<b>XML 文档编辑：nXML 模式</b>
</p>

<p>
编辑 XML 文档的主模式为 nXML mode（nXML 模式），这是一款功能强大的主模式：可识别多种现有 XML 模式（Schema），支持通过 <code>M-TAB</code> 实现 XML 元素的补全，还能实时验证 XML 语法并高亮显示错误。在已有缓冲区中启用该模式，可执行 <code>M-x nxml-mode</code> （或等效的 <code>M-x xml-mode</code> ）。Emacs 会为 <code>.xml</code> 后缀的文件自动启用 nXML 模式；而对于 <code>.xhtml</code> 后缀的 XHTML 文件，Emacs 默认启用 HTML 模式，若需改为 nXML 模式，可自定义变量 <code>auto-mode-alist</code> （详见「<a href="#Choosing-Modes">文件模式的选择</a>」章节）。nXML 模式的详细说明，可参考 Emacs 自带的 Info 手册。
</p>

<p>
你也可选择使用功能更简洁的 SGML 模式编辑 XML（因 XML 是 SGML 的严格子集）。在缓冲区中执行 <code>M-x sgml-mode</code> 即可启用 SGML 模式，启用时 Emacs 会自动检测缓冲区内容是否为 XML 格式；若检测为 XML，会将变量 <code>sgml-xml-mode</code> 设为非nil值，此时上述 SGML 模式的标签插入命令，会始终为标签生成显式的结束标签。
</p>
</div>
</div>
<div id="outline-container-Nroff-Mode" class="outline-3">
<h3 id="Nroff-Mode"><span class="section-number-3">27.13.</span> Nroff 模式</h3>
<div class="outline-text-3" id="text-Nroff-Mode">
<p>
Nroff 模式是衍生自文本模式的主模式，专门用于编辑 nroff 文件（如 Unix 手册页）。输入 <code>M-x nroff-mode</code> 即可进入该模式。进入 Nroff 模式时，会先执行钩子函数 <code>text-mode-hook</code> ，再执行 <code>nroff-mode-hook</code> （详见<a href="#Hooks">钩子函数</a>章节）。
</p>

<p>
在 Nroff 模式下，nroff 命令行被视作段落分隔符，分页由 '<code>.bp</code>' 命令实现，注释以反斜杠加双引号（ <code>\"</code> ）开头。该模式还定义了以下命令：
</p>
<dl class="org-dl">
<dt><code>M-n</code></dt><dd>移动到下一行非 nroff 命令的文本行开头 (<code>nroff-forward-text-line</code>) ，数字参数可指定重复执行的次数。</dd>
<dt><code>M-p</code></dt><dd>功能与 M-n 类似，方向为向上移动 (<code>nroff-backward-text-line</code>) 。</dd>
<dt><code>M-?</code></dt><dd>在回显区显示当前区域内的文本行行数 (即非 nroff 命令的行数， <code>nroff-count-text-lines</code>) 。</dd>
</dl>

<p>
Electric Nroff mode 是可与 Nroff 模式配合使用的缓冲区局部次要模式，输入 <code>M-x nroff-electric-mode</code> 可切换该模式的开启与关闭（详见<a href="#Minor-Modes">次要模式</a>章节）。开启后，当你在包含 <b>分组开启类 nroff 命令</b> 的行尾按下 <code>RET</code> 回车键时，系统会在后续行自动插入对应的分组关闭类 nroff 命令。
</p>

<p>
若你在 Nroff 模式中启用大纲次要模式（详见<a href="#Outline-Mode">大纲模式</a>章节），则标题行定义为以 '<code>.H</code>' 开头、后接数字（表示标题层级）的行。
</p>
</div>
</div>
<div id="outline-container-Enriched-Text" class="outline-3">
<h3 id="Enriched-Text"><span class="section-number-3">27.14.</span> 富文本</h3>
<div class="outline-text-3" id="text-Enriched-Text">
<p>
Enriched mode 富文本模式是一种 <b>WYSIWYG (What You See Is What You Get) 所见即所得</b> 的次要模式，用于编辑带格式的文本文件。启用该模式后，你可为缓冲区中的文本设置各类格式属性（如字体、颜色等）；保存缓冲区时，这些格式属性会随文本一同保存，采用 MIME 标准的 'text/enriched' 文件格式。
</p>

<p>
富文本模式通常与文本模式配合使用（详见<a href="#Text-Mode">文本模式</a>章节），它与语法高亮模式（Font Lock mode）互不兼容 —— 后者被多数主模式（包括大部分编程语言模式）用于实现语法高亮（详见<a href="#Font-Lock">语法高亮模式</a>章节）。与富文本模式不同，语法高亮模式会根据缓冲区当前内容自动分配文本属性，且这些属性不会保存到磁盘中。
</p>

<p>
Emacs 的 <code>data-directory</code> 变量对应目录下的 'enriched.txt' 文件，可作为富文本模式功能的示例参考。
</p>

<ul class="org-ul">
<li><a href="#Enriched-Mode">富文本模式</a></li>
<li><a href="#Hard-and-Soft-Newlines">硬换行与软换行</a></li>
<li><a href="#Editing-Format-Info">格式信息编辑</a></li>
<li><a href="#Enriched-Faces">富文本中的外观样式</a></li>
<li><a href="#Enriched-Indentation">富文本中的缩进</a></li>
<li><a href="#Enriched-Justification">富文本中的对齐方式</a></li>
<li><a href="#Enriched-Properties">设置其他文本属性</a></li>
</ul>
</div>
<div id="outline-container-Enriched-Mode" class="outline-4">
<h4 id="Enriched-Mode"><span class="section-number-4">27.14.1.</span> 富文本模式</h4>
<div class="outline-text-4" id="text-Enriched-Mode">
<p>
富文本模式是一种缓冲区局部次要模式（详见<a href="#Minor-Modes">次要模式</a>章节）。当你打开以 'text/enriched' 格式保存的文件时，Emacs 会自动启用富文本模式，并将文件中的格式信息应用到缓冲区文本上。若启用富文本模式后保存缓冲区，文件会以 'text/enriched' 格式存储，其中包含所有的格式信息。
</p>

<p>
若要创建新的格式化文本文件，可先打开该不存在的文件，再执行 <code>M-x enriched-mode</code> 命令。该命令实际为富文本模式的切换开关：带正数值前缀参数时启用富文本模式，非正数值则禁用。禁用富文本模式后，Emacs 不再以 'text/enriched' 格式保存缓冲区；已添加到缓冲区的各类格式属性会保留在缓冲区中，但不会写入磁盘。
</p>

<p>
富文本模式 <b>并非保存 Emacs 所有的文本属性</b> ，仅会保存变量 <code>enriched-translations</code> 中指定的属性，包括字体、颜色、缩进和对齐方式相关的属性。
</p>

<p>
若打开文件时，Emacs 未能识别出其为 'text/enriched' 格式，可执行 <code>M-x format-decode-buffer</code> 命令。该命令会提示你指定文件格式，并按该格式重新读取文件；当指定为 'text/enriched' 格式时，会自动启用富文本模式。
</p>

<p>
若要以原始形式查看 'text/enriched' 格式文件（即显示带有标记的纯文本，而非格式化后的文本），可使用 <code>M-x find-file-literally</code> 命令（详见<a href="#Visiting">打开文件</a>章节）。
</p>

<p>
关于 Emacs 如何识别并转换 'text/enriched' 这类文件格式的详细说明，可参考《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Format-Conversion.html#Format-Conversion">格式转换</a>章节；有关文本属性的更多信息，可参考该手册中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Text-Properties.html#Text-Properties">文本属性</a>章节。
</p>
</div>
</div>
<div id="outline-container-Hard-and-Soft-Newlines" class="outline-4">
<h4 id="Hard-and-Soft-Newlines"><span class="section-number-4">27.14.2.</span> 硬换行与软换行</h4>
<div class="outline-text-4" id="text-Hard-and-Soft-Newlines">
<p>
在富文本模式下，Emacs 会区分两种不同的换行符： / hard newlines硬换行/ 和 <i>soft newlines 软换行</i> 。你也可以在其他缓冲区中，通过执行 <code>M-x use-hard-newlines</code> 命令启用或关闭该功能。
</p>

<p>
硬换行用于分隔段落，或在所有需要强制换行的位置使用 —— 无论文本如何自动折行，硬换行会始终保留；软换行则专门用于文本的自动折行排版。按下 <code>RET</code> (<code>newline</code>)和  <code>C-o</code> (<code>open-line</code>) 插入的是硬换行。各类折行排版命令（包括自动折行模式，详见《<a href="#Auto-Fill">自动折行模式</a>》章节）仅会插入软换行，且仅删除软换行，不会改动硬换行。
</p>

<p>
因此，在富文本模式下编辑时， <b>不要</b> 在已折行排版的段落中间使用 <code>RET</code> 回车键或  <code>C-o</code> 进行换行。此类场景应使用自动折行模式，或手动执行折行排版命令（详见《<a href="#Fill-Commands">手动折行排版命令</a>》章节）。仅在需要始终保留换行的位置使用 <code>RET</code> 回车键或 <code>C-o</code> ，例如编辑表格和列表时。对于这类包含强制换行的文本行，你还可以将其对齐方式设置为不折行（详见《<a href="#Enriched-Justification">富文本中的对齐方式</a>》章节）。
</p>
</div>
</div>
<div id="outline-container-Editing-Format-Info" class="outline-4">
<h4 id="Editing-Format-Info"><span class="section-number-4">27.14.3.</span> 格式信息编辑</h4>
<div class="outline-text-4" id="text-Editing-Format-Info">
<p>
修改文本属性最简便的方式是使用 'Text Properties 文本属性' 菜单。你可以通过菜单栏中的 'Edit' 菜单打开该菜单（详见<a href="#Menu-Bar">菜单栏</a>章节），也可通过鼠标快捷键 <code>C-mouse-2</code> （详见<a href="#Menu-Mouse-Clicks">菜单的鼠标点击操作</a>章节）。以下列出文本属性菜单中的部分命令（这些命令也可通过 <code>M-x</code> 调用执行）：
</p>

<dl class="org-dl">
<dt>Remove Face Properties</dt><dd>清除选区中的显示样式属性 (<code>facemenu-remove-face-props</code>) 。</dd>
<dt>Remove Text Properties</dt><dd>清除选区中的全部文本属性，包括显示样式属性 (<code>facemenu-remove-all</code>) 。</dd>
<dt>Describe Properties</dt><dd>列出光标后方字符的所有文本属性及其他相关信息 (<code>describe-text-properties</code>) 。</dd>
<dt>Display Faces</dt><dd>展示已定义的所有显示样式列表 (<code>list-faces-display</code>) ，详见<a href="#Faces">文本显示样式</a>章节。</dd>
<dt>Display Colors</dt><dd>展示已定义的所有颜色列表 (<code>list-colors-display</code>) ，详见<a href="#Colors">显示样式的颜色设置</a>章节。</dd>
</dl>

<p>
该菜单中的其他功能项将在后续小节中介绍。
</p>
</div>
</div>
<div id="outline-container-Enriched-Faces" class="outline-4">
<h4 id="Enriched-Faces"><span class="section-number-4">27.14.4.</span> 富文本中的外观样式</h4>
<div class="outline-text-4" id="text-Enriched-Faces">
<p>
下述命令可用于添加或移除显示样式（参见「<a href="#Faces">文本显示样式</a>」章节）。若标记处于激活状态，所有命令均作用于区域内的文本；若标记未激活，则作用于下一个自插入字符。若带前缀参数，即便区域处于激活状态，所有命令也仅作用于下一个自插入字符。
</p>

<dl class="org-dl">
<dt><code>M-o d</code></dt><dd>清除所有显示样式属性 (<code>facemenu-set-default</code>) 。</dd>
<dt><code>M-o b</code></dt><dd>应用粗体显示样式 (<code>facemenu-set-bold</code>) 。</dd>
<dt><code>M-o i</code></dt><dd>应用斜体显示样式 (<code>facemenu-set-italic</code>) 。</dd>
<dt><code>M-o l</code></dt><dd>应用粗斜体显示样式 (<code>facemenu-set-bold-italic</code>) 。</dd>
<dt><code>M-o u</code></dt><dd>应用下划线显示样式 (<code>facemenu-set-underline</code>) 。</dd>
<dt><code>M-o o 样式名 RET</code></dt><dd>应用指定名称的显示样式 (<code>facemenu-set-face</code>) 。</dd>
<dt><code>M-x facemenu-set-foreground</code></dt><dd>提示输入颜色（参见「<a href="#Colors">显示样式的颜色设置</a>」章节），并将其设为前景色。</dd>
<dt><code>M-x facemenu-set-background</code></dt><dd>提示输入颜色，并将其设为背景色。</dd>
</dl>

<p>
上述命令也可通过「Text Properties」菜单调用。
</p>

<p>
自插入字符通常会从缓冲区中前一个字符继承显示样式属性（及绝大多数其他文本属性）。若通过上述任一命令为下一个自插入字符指定了显示样式，该字符将不再继承前一个字符的显示样式属性，但仍会继承其他文本属性。
</p>

<p>
富文本模式额外定义了两种显示样式：摘录样式（excerpt）和等宽样式（fixed），二者对应 'text/enriched' 文件格式中使用的编码。摘录样式适用于引用文本，默认显示效果与斜体一致；等宽样式用于指定等宽文本，默认显示效果与 <i>bold粗体</i> 一致。
</p>
</div>
</div>
<div id="outline-container-Enriched-Indentation" class="outline-4">
<h4 id="Enriched-Indentation"><span class="section-number-4">27.14.5.</span> 富文本中的缩进</h4>
<div class="outline-text-4" id="text-Enriched-Indentation">
<p>
在富文本模式下，你可为一个段落或段落的某一部分，设置不同数值的左、右页边距缩进。这些页边距设置也会作用于 <code>M-q</code> 等自动换行命令（参见「<a href="#Filling">文本自动换行</a>」章节）。
</p>

<p>
「Text Properties」菜单的「indentation缩进」子菜单中，提供了用于设置缩进的相关命令：
</p>

<dl class="org-dl">
<dt><code>增加左缩进</code></dt><dd>将选中区域的左缩进增加 4 列 (<code>increase-left-margin</code>) 。在富文本模式下，该命令也可通过快捷键 <code>C-x TAB</code> 调用；若为其指定数字参数，参数值即为左缩进需增加的列数（负参数表示减少对应列数的左缩进）。</dd>
<dt><code>Indent Less</code></dt><dd>将选中区域的左缩进减少 4 列。</dd>
<dt><code>Indent Right More</code></dt><dd>将右页边距缩进增加 4 列，使文本显示区域变窄。</dd>
<dt><code>Indent Right Less</code></dt><dd>将右页边距的缩进减少 4 列。</dd>
</dl>

<p>
变量 <code>standard-indent</code> 用于定义上述缩进命令每次增加或减少的列数，默认值为 4。和常规模式一致，富文本模式的默认右页边距由变量 <code>fill-column</code> 控制。
</p>

<p>
你也可通过快捷键 <code>C-c [</code> (<code>set-left-margin</code>) 和 <code>C-c ]</code> (<code>set-right-margin</code>) 分别设置左、右页边距。可为这两个快捷键指定数字参数以直接定义页边距宽度；若未指定参数，命令会通过迷你缓冲区提示你输入数值。
</p>

<p>
若设置了自动换行前缀，其会在段落指定缩进的基础上生效：快捷键 <code>C-x .</code> 设置自动换行前缀的新值时，不会将指定缩进的空白字符包含在内；且自动换行命令会在每行的缩进之后，匹配对应的自动换行前缀（参见「<a href="#Fill-Prefix">自动换行前缀</a>」章节）。
</p>
</div>
</div>
<div id="outline-container-Enriched-Justification" class="outline-4">
<h4 id="Enriched-Justification"><span class="section-number-4">27.14.6.</span> 富文本中的对齐方式</h4>
<div class="outline-text-4" id="text-Enriched-Justification">
<p>
在富文本模式下，可使用以下命令为文本填充指定各类对齐样式。这些命令将作用于光标所在的段落；若选区处于激活状态，则作用于所有与选区重叠的段落。
</p>

<dl class="org-dl">
<dt><code>M-j l</code></dt><dd>向左边距对齐 (<code>set-justification-left</code>) 。</dd>
<dt><code>M-j r</code></dt><dd>向右边距对齐 (<code>set-justification-right</code>) 。</dd>
<dt><code>M-j b</code></dt><dd>左右边距两端对齐，通过在行中间插入空格实现该效果 (<code>set-justification-full</code>) 。</dd>
<dt><code>M-j c</code></dt><dd></dd>

<dt><code>M-S</code></dt><dd>在左右边距之间居中对齐 (<code>set-justification-center</code>) 。</dd>
<dt><code>M-j u</code></dt><dd>完全关闭文本填充功能 (<code>set-justification-none</code>) 。开启此设置后，填充类命令对文本将不再生效，但仍可对左边距进行缩进操作。</dd>
</dl>

<p>
你也可通过「Text Properties 」菜单中的「justification对齐方式」子菜单来指定对齐样式。默认对齐样式由缓冲区级变量 <code>default-justification</code> 定义，其取值需为以下符号之一： <code>left</code> （左对齐）、 <code>right</code> （右对齐）、 <code>full</code> （两端对齐）、 <code>center</code> （居中对齐）或  <code>none</code> （关闭填充），各符号含义与上述对应命令一致。
</p>
</div>
</div>
<div id="outline-container-Enriched-Properties" class="outline-4">
<h4 id="Enriched-Properties"><span class="section-number-4">27.14.7.</span> 设置其他文本属性</h4>
<div class="outline-text-4" id="text-Enriched-Properties">
<p>
'Text Properties' 菜单的 'Special Properties特殊属性' 子菜单中，包含用于添加或移除四种其他文本属性的选项，分别为：read-only只读（禁止修改文本）、invisible不可见（隐藏文本）、intangible不可触（禁止将光标移至文本内）以及 charset字符集（对选择合适的字体显示字符至关重要）。 'Remove Special移除特殊属性' 菜单项可将选区文本中的所有这类特殊属性全部清除。
</p>

<p>
invisible不可见和 intangible不可触属性不会被保存。
</p>

<p>
富文本模式还支持保存和恢复 display显示属性（参见《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Display-Property.html#Display-Property">显示属性</a>章节），这类属性会影响文本在屏幕上的显示方式，也支持显示来自缓冲区文本以外来源的图片和字符串。显示属性还支持在处理该属性以完成文本显示的过程中，执行任意的 Lisp 表达式，从而提供了一种根据仅在显示时才能确定的条件，动态调整文本显示效果的方法。由于执行任意 Lisp 表达式会使 Emacs 面临潜在的攻击风险 —— 尤其是当富文本的来源并非 Emacs 内部、甚至并非你的系统内部时（例如，通过电子邮件接收的富文本），因此富文本模式中默认禁用该功能。你可通过将变量 <code>enriched-allow-eval-in-display-props</code> 自定义设置为非空值，来启用此功能。
</p>
</div>
</div>
</div>
<div id="outline-container-Text-Based-Tables" class="outline-3">
<h3 id="Text-Based-Tables"><span class="section-number-3">27.15.</span> 文本表格编辑</h3>
<div class="outline-text-3" id="text-Text-Based-Tables">
<p>
表格包提供了一系列命令，可便捷编辑基于文本的表格。此类表格的示例如下：
</p>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">+-----------------+--------------------------------+-----------------+</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|     Command     |          Description           |   Key Binding   |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">+-----------------+--------------------------------+-----------------+</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|  forward-char   |Move point right N characters   |       C-f       |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|                 |(left if N is negative).        |                 |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|                 |                                |                 |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">+-----------------+--------------------------------+-----------------+</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|  backward-char  |Move point left N characters    |       C-b       |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|                 |(right if N is negative).       |                 |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|                 |                                |                 |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">+-----------------+--------------------------------+-----------------+</span>
</pre>
</div>

<p>
当 Emacs 将一段文本识别为表格时（参见<a href="#Table-Recognition">表格识别</a>章节），若表格单元格中的内容超出单元格可容纳范围，编辑各单元格内容的操作将自动调整表格尺寸。你可使用后续章节中定义的命令，进行表格布局的导航与编辑操作。
</p>

<p>
键入 <code>M-x table-fixed-width-mode</code> 可切换表格自动调整尺寸的功能开关。
</p>

<ul class="org-ul">
<li><a href="#Table-Definition">什么是文本表格？</a></li>
<li><a href="#Table-Creation">创建表格</a></li>
<li><a href="#Table-Recognition">表格识别</a></li>
<li><a href="#Cell-Commands">表格单元格操作命令</a></li>
<li><a href="#Cell-Justification">单元格对齐方式</a></li>
<li><a href="#Table-Rows-and-Columns">表格行与列操作</a></li>
<li><a href="#Table-Conversion">纯文本与表格的相互转换</a></li>
<li><a href="#Table-Misc">表格杂项功能</a></li>
</ul>
</div>
<div id="outline-container-Table-Definition" class="outline-4">
<h4 id="Table-Definition"><span class="section-number-4">27.15.1.</span> 什么是文本表格？</h4>
<div class="outline-text-4" id="text-Table-Definition">
<p>
基于文本的 <i>talbe 表格</i> 由一个被划分为若干 <i>cells 单元格</i> 的矩形文本区域构成。不计边框线的情况下，每个单元格的宽度和高度至少为一个字符。单元格可进一步拆分为多个子单元格，但所有单元格之间不得重叠。
</p>

<p>
单元格的边框线由三种特殊字符绘制，相关字符由以下变量指定：
</p>
<dl class="org-dl">
<dt><code>table-cell-vertical-char</code></dt><dd>用于绘制竖线的字符，默认值为 ‘|’ 。</dd>
<dt><code>table-cell-horizontal-chars</code></dt><dd>用于绘制横线的字符，默认值为 “"-="” 。</dd>
<dt><code>table-cell-intersection-char</code></dt><dd>用于绘制横竖线交叉处的字符，默认值为 ‘+’ 。</dd>
</dl>

<p>
以下为无效表格的示例：
</p>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">+-----+       +--+    </span><span style="color: #0000ff; text-decoration: line-through;">+-</span><span style="color: #0000ff; text-decoration: line-through;">++</span><span style="color: #0000ff; text-decoration: line-through;">--+</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|     |       |  |    | ||  |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|     |       |  |    | ||  |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">+--+  |    +--+--+    </span><span style="color: #0000ff; text-decoration: line-through;">+-</span><span style="color: #0000ff; text-decoration: line-through;">++</span><span style="color: #0000ff; text-decoration: line-through;">--+</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|  |  |    |  |  |    </span><span style="color: #0000ff; text-decoration: line-through;">+-</span><span style="color: #0000ff; text-decoration: line-through;">++</span><span style="color: #0000ff; text-decoration: line-through;">--+</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|  |  |    |  |  |    | ||  |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">+--+--+    +--+--+    </span><span style="color: #0000ff; text-decoration: line-through;">+-</span><span style="color: #0000ff; text-decoration: line-through;">++</span><span style="color: #0000ff; text-decoration: line-through;">--+</span><span style="color: #0000ff;">
</span>   a          b          c
</pre>
</div>

<p>
上述示例从左至右分别违反了以下规则：
</p>
<ol class="org-ol">
<li>不允许出现单元格重叠或非矩形的单元格；</li>
<li>表格边框必须为矩形；</li>
<li>单元格的宽度和高度必须至少为一个字符。</li>
</ol>
</div>
</div>
<div id="outline-container-Table-Creation" class="outline-4">
<h4 id="Table-Creation"><span class="section-number-4">27.15.2.</span> 创建表格</h4>
<div class="outline-text-4" id="text-Table-Creation">
<p>
若要从头创建一个基于文本的表格，键入 <code>M-x table-insert</code> 即可。该命令会依次提示你输入表格的columns列数、rows行数、width单元格宽度和 height单元格高度。 <b>单元格的宽度和高度均不含边框</b> ；其取值既可以是单个整数（表示所有单元格使用相同的宽度 / 高度），也可以是一组由空格或逗号分隔的整数（用于指定每一列 或 每一行单元格的单独宽度 或 高度，列按从左到右的顺序、行按从上到下的顺序对应）。完成设置后，表格将插入到光标所在位置。
</p>

<p>
通过 <code>M-x table-insert</code> 插入的表格带有特殊的文本属性，正是这些属性让 Emacs 将其识别为特殊的基于文本的表格进行处理。若将缓冲区保存至文件并在后续重新打开，这些属性将会丢失，Emacs 会将该表格视作普通文本。如需将其恢复为表格形式，可参见下一节内容。
</p>
</div>
</div>
<div id="outline-container-Table-Recognition" class="outline-4">
<h4 id="Table-Recognition"><span class="section-number-4">27.15.3.</span> 表格识别</h4>
<div class="outline-text-4" id="text-Table-Recognition">
<p>
缓冲区中已存在的基于文本的表格，若未带有 <code>M-x table-insert</code> 命令添加的特殊文本属性，将不会被 Emacs 当作表格特殊处理。如需为其添加该类属性，可键入 <code>M-x table-recognize</code> 。该命令会扫描当前缓冲区，识别有效的表格单元格并为其应用相关文本属性。反之，键入 <code>M-x table-unrecognize</code> 可取消当前缓冲区中所有表格的识别状态，移除其特殊文本属性并将表格还原为纯文本。
</p>

<p>
你也可使用以下命令，对表格进行选择性的识别或取消识别：
</p>
<dl class="org-dl">
<dt><code>M-x table-recognize-region</code></dt><dd>识别当前选区范围内的表格</dd>
<dt><code>M-x table-unrecognize-region</code></dt><dd>取消当前选区范围内的表格识别</dd>
<dt><code>M-x table-recognize-table</code></dt><dd>识别光标所在位置的表格并激活该表格</dd>
<dt><code>M-x table-unrecognize-table</code></dt><dd>取消光标所在位置表格的激活状态</dd>
<dt><code>M-x table-recognize-cell</code></dt><dd>识别光标所在位置的单元格并激活该单元格</dd>
<dt><code>M-x table-unrecognize-cell</code></dt><dd>取消光标所在位置单元格的激活状态</dd>
</dl>

<p>
关于表格识别的另一种方法，可参见<a href="#Table-Conversion">纯文本与表格的格式转换</a>章节。
</p>

<p>
如果是org-mode模式文件，键入 <code>C-c '</code> ，在内部可使用快捷键操作表格。
</p>
</div>
</div>
<div id="outline-container-Cell-Commands" class="outline-4">
<h4 id="Cell-Commands"><span class="section-number-4">27.15.4.</span> 表格单元格操作命令</h4>
<div class="outline-text-4" id="text-Cell-Commands">
<p>
<code>M-x table-forward-cell</code> 和 <code>M-x table-backward-cell</code> 命令可将光标从当前单元格移动至相邻单元格，移动顺序为循环式：当光标处于表格最后一个单元格时，执行 <code>M-x table-forward-cell</code> 会跳至第一个单元格；同理，光标处于第一个单元格时，执行 <code>M-x table-backward-cell</code> 会跳至最后一个单元格。
</p>

<p>
<code>M-x table-span-cell</code> (<code>C-*</code>) 命令会先提示选择合并方向 —— right向右、left向左、above向上或 below向下，随后将当前单元格与对应方向的相邻单元格合并。若该合并操作会导致单元格布局无效，此命令将抛出错误提示。
</p>

<p>
<code>M-x table-split-cell</code> 命令可对当前单元格进行 vertically垂直或 horizontally水平拆分，拆分方向需在迷你缓冲区中指定。若需直接按指定方向拆分，可使用 <code>M-x table-split-cell-vertically</code> (<code>C–-</code>) （垂直拆分）和 <code>M-x table-split-cell-horizontally</code> (<code>C-|</code>) （水平拆分）命令。执行垂直拆分时，原单元格的内容会自动分配至上下两个新单元格h；执行水平拆分时，若原单元格非空，命令会提示选择内容拆分方式，可选方式包括：'split' （从光标位置拆分内容）、'left' （将所有内容放入左侧新单元格）、 'right' （将所有内容放入右侧新单元格）。
</p>

<p>
以下命令用于 enlarge放大或 shrink缩小单元格，默认情况下每次调整 1 行或列的尺寸；若为命令指定数字参数，可自定义调整的行/列数。
</p>

<dl class="org-dl">
<dt><code>M-x table-heighten-cell</code></dt><dd>垂直放大当前单元格 (<code>C-}</code>)</dd>
<dt><code>M-x table-shorten-cell</code></dt><dd>垂直缩小当前单元格 (<code>C-{</code>)</dd>
<dt><code>M-x table-widen-cell</code></dt><dd>水平放大当前单元格 (<code>C-&lt;</code>)</dd>
<dt><code>M-x table-narrow-cell</code></dt><dd>水平缩小当前单元格 (<code>C-&gt;</code>)</dd>
</dl>
</div>
</div>
<div id="outline-container-Cell-Justification" class="outline-4">
<h4 id="Cell-Justification"><span class="section-number-4">27.15.5.</span> 单元格对齐方式</h4>
<div class="outline-text-4" id="text-Cell-Justification">
<p>
<code>M-x table-justify</code> (<code>C-:</code>) 命令可对基于文本的表格中一个或多个单元格设置 <i>justification对齐方式</i> 。对齐方式用于定义单元格内的文本相对单元格边缘的排布规则，表格中的每个单元格可单独设置对齐方式。
</p>

<p>
执行 <code>M-x table-justify</code> 命令后，会先提示选择对齐作用范围，可选值为 'cell' （仅当前单元格）、 'column' （当前表格列的所有单元格）和 'row' （当前表格行的所有单元格）；随后会提示选择对齐样式，可选值为left左对齐、center居中对齐、right右对齐、top顶端对齐、middle中部对齐、bootom底端对齐，或none（表示不设置垂直对齐）。
</p>

<p>
水平对齐样式与垂直对齐样式为独立设置，且两种样式可同时生效。例如，可连续执行两次 <code>M-x table-justify</code> 命令，一次设置右对齐、一次设置底端对齐，即可将单元格内容调整为右下角对齐。
</p>

<p>
对齐样式会以文本属性的形式存储在缓冲区中，关闭缓冲区或退出 Emacs 后，该属性将会丢失。不过表格识别类命令（如 <code>M-x table-recognize</code> ，参见<a href="#Table-Recognition">表格识别</a>章节）会通过分析单元格内容，尝试识别并重新为每个单元格应用原有对齐样式。若要禁用此功能，可将变量 <code>table-detect-cell-alignment</code> 的值设为 <code>nil</code> 。
</p>
</div>
</div>
<div id="outline-container-Table-Rows-and-Columns" class="outline-4">
<h4 id="Table-Rows-and-Columns"><span class="section-number-4">27.15.6.</span> 表格行与列操作</h4>
<div class="outline-text-4" id="text-Table-Rows-and-Columns">
<p>
<code>M-x table-insert-row</code> 命令会在当前 <b>表格行上方</b> 插入一行单元格，原当前行及光标位置会下移至新行之后。若要在表格最底部的最后一行下方插入新行，需将光标置于表格外、表格下边缘的正下方，再执行此命令。为该命令添加数字前缀参数，可一次性插入多行。
</p>

<p>
同理， <code>M-x table-insert-column</code> 命令会在当前 <b>表格列左侧</b> 插入一列单元格。若要在表格最右侧的最后一列右侧插入新列，需将光标置于表格外、表格最右侧列的右边，再执行此命令。数字前缀参数可指定一次性插入的列数。
</p>

<p>
<code>M-x table-delete-column</code> 命令用于删除光标所在位置的整列单元格， <code>M-x table-delete-row</code> 命令则用于删除光标所在位置的整行单元格。为这两个命令添加数字前缀参数，可指定一次性删除的列数或行数。
</p>
</div>
</div>
<div id="outline-container-Table-Conversion" class="outline-4">
<h4 id="Table-Conversion"><span class="section-number-4">27.15.7.</span> 纯文本与表格的相互转换</h4>
<div class="outline-text-4" id="text-Table-Conversion">
<p>
<code>M-x table-capture</code> 命令可提取选区内的纯文本并将其转换为表格。与 <code>M-x table-recognize</code> 命令不同（参见<a href="#Table-Recognition">表格识别</a>章节），待转换的原始文本无需具备表格的外观形式，仅需拥有符合逻辑的类表格结构即可。
</p>

<p>
例如，现有以下一组数字，分为三行排列，列之间以逗号分隔：
</p>

<div class="org-src-container">
<pre class="src src-org">1, 2, 3, 4
5, 6, 7, 8
, 9, 10
</pre>
</div>

<p>
对这段文本执行 <code>M-x table-capture</code> 命令，将生成如下表格：
</p>
<ul class="org-ul">
<li>Column delimiter regexp: ,</li>
<li>Row delimiter regexp: 换行 <code>C-q C-j</code></li>
</ul>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">+-----+-----+-----+-----+</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|1    |2    |3    |4    |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">+-----+-----+-----+-----+</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|5    |6    |7    |8    |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">+-----+-----+-----+-----+</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|     |9    |10   |     |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">+-----+-----+-----+-----+</span>
</pre>
</div>

<p>
<code>M-x table-release</code> 命令的作用则与之相反：它会将表格还原为纯文本，并移除所有单元格边框。
</p>

<p>
这一组命令的一个实际应用场景是按版式编辑文本。例如有以下三段文本：
</p>

<div class="org-src-container">
<pre class="src src-shell">table-capture is a powerful command.
Here are some things it can<span style="color: #a020f0;"> do</span>:

Parse Cell Items   Using row and column delimiter regexps,
                   it parses the specified text area and
                   extracts cell items into a table.
</pre>
</div>

<p>
将包含上述文本的选区执行 <code>M-x table-capture</code> 命令，并将行列分隔符正则表达式均设为空字符串，会生成一个仅含单个单元格的表格，如下所示：
</p>

<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">+----------------------------------------------------------+</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|table-capture is a powerful command.                      |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|Here are some things it can do:                           |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|                                                          |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|Parse Cell Items   Using row and column delimiter regexps,|</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|                   it parses the specified text area and  |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|                   extracts cell items into a table.      |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">+----------------------------------------------------------+</span>
</pre>
</div>

<p>
随后我们可使用单元格拆分相关命令（参见<a href="#Cell-Commands">表格单元格操作命令</a>章节）对该表格进行拆分，让每一段文本各占一个单元格：
</p>
<ul class="org-ul">
<li>若为org mode文件，需要进入编辑模式操作： <code>C-c '</code></li>
<li>光标在第3行，空白单元格内。按 <code>M-x table-split-cell-vertically</code> (<code>C–</code>) 垂直分割单元格</li>
<li>光标在 Items 后空白处， <code>M-x table-split-cell-horizontally</code> (<code>C-|</code>) 水平分割单元格
<ul class="org-ul">
<li>按split分割，按光标位置自动将当前单元格分割。</li>
<li>注意光标这里与下文本宽度一样，有利切分</li>
</ul></li>
<li>光标在最后一行内，按 <code>M-x table-shorten-cell</code> (<code>C-{</code>) 垂直收缩当前单元格</li>
</ul>
<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">+----------------------------------------------------------+</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|table-capture is a powerful command.                      |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|Here are some things it can do:                           |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">+-----------------+----------------------------------------+</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|Parse Cell Items | Using row and column delimiter regexps,|</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|                 | it parses the specified text area and  |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|                 | extracts cell items into a table.      |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">+-----------------+----------------------------------------+</span>
</pre>
</div>

<p>
此时每个单元格均可独立编辑，且不会影响其他单元格的版式布局。编辑完成后，执行 <code>M-x table-release</code> 命令即可将表格重新转换为纯文本。
</p>
</div>
</div>
<div id="outline-container-Table-Misc" class="outline-4">
<h4 id="Table-Misc"><span class="section-number-4">27.15.8.</span> 表格杂项功能</h4>
<div class="outline-text-4" id="text-Table-Misc">
<p>
<code>table-query-dimension</code> 命令会反馈光标所在位置的表格及单元格布局信息，以下是该命令的输出示例：
</p>

<div class="org-src-container">
<pre class="src src-shell">Cell: (21w, 6h), Table: (67w, 16h), Dim: (2c, 3r), Total Cells: 5
</pre>
</div>

<p>
该输出表示：当前单元格宽度为 21 个字符、高度为 6 行；表格整体宽度为 67 个字符、高度为 16 行，包含 2 列 3 行，表格的单元格总数为 5 个。
</p>

<p>
<code>M-x table-insert-sequence</code> 命令会遍历表格的所有单元格，并在遍历过程中为每个单元格插入一组序列化的文本字符串。执行该命令时，需先指定序列的基础字符串，命令会通过对基础字符串进行 <b>自增运算</b> 生成后续序列 —— 若基础字符串以数字结尾，则按数字规则自增；否则按 ASCII 字符顺序自增。除基础字符串外，该命令还会依次提示输入序列元素数量、自增步长、单元格间隔，以及文本在单元格内的对齐方式。
</p>

<p>
<code>M-x table-generate-source</code> 命令可生成适配指定标记语言的表格格式。执行该命令时，需先指定目标标记语言（仅支持 html、latex、cals、wiki、mediawiki），再指定用于存放生成结果的目标缓冲区，以及表格标题，完成设置后命令会将生成的表格插入指定缓冲区。默认的目标缓冲区名称为 <code>table.lang</code> ，其中 <i>lang</i> 为你所指定的标记语言名称。
</p>
</div>
</div>
</div>
<div id="outline-container-Two_002dColumn" class="outline-3">
<h3 id="Two_002dColumn"><span class="section-number-3">27.16.</span> 双列编辑</h3>
<div class="outline-text-3" id="text-Two_002dColumn">
<p>
two-column mode双列模式可让你便捷地编辑两列并排的文本，该模式会启用两个并排的窗口，每个窗口显示独立的缓冲区。进入双列模式共有三种方式：
</p>
<dl class="org-dl">
<dt><code>F2 2</code> 或 <code>C-x 6 2</code></dt><dd>以当前缓冲区作为左侧栏，右侧栏启用一个基于当前缓冲区名称命名的缓冲区 (<code>2C-two-columns</code>) ，进入双列模式。若右侧缓冲区尚未创建，则初始为空白状态，当前缓冲区的内容不会发生任何改变。此命令适用于当前缓冲区为空白、或仅包含单列文本，且你需要新增另一列的场景。</dd>
<dt><code>F2 s</code> 或 <code>C-x 6 s</code></dt><dd><p>
将包含双列文本的当前缓冲区拆分为两个缓冲区，并将其并排显示 (<code>2C-split</code>) 。原当前缓冲区成为左侧缓冲区，右侧栏的文本会被移至右侧缓冲区，拆分位置由当前光标所在列决定。拆分操作从光标所在行开始，直至缓冲区末尾。
</p>

<p>
此命令适用于当前缓冲区已包含双列文本，且你需要临时将两列分离编辑的场景。
</p></dd>

<dt><code>F2 b buffer RET</code> 或 <code>C-x 6 b buffer RET</code></dt><dd>以当前缓冲区为左侧缓冲区、指定缓冲区为右侧缓冲区，进入双列模式 (<code>2C-associate-buffer</code>) 。</dd>
</dl>

<p>
执行 <code>F2 s</code> 或 <code>C-x 6 s</code> 时，命令会自动识别 <b>列分隔符</b> —— 即每行中位于两列文本之间的字符串。你可通过为 <code>F2 s</code> 指定 <b>数字参数</b> 来定义分隔符的宽度：光标左侧对应数量的字符将被视作列分隔符。默认分隔符宽度为 1，即光标左侧的单个字符为列分隔符。
</p>

<p>
若某行的分隔符处于正确位置， <code>F2 s</code> 会将分隔符后的文本移至右侧缓冲区，并删除原分隔符；若某行未在正确位置包含列分隔符，则该行不会被拆分，仍保留在左侧缓冲区，且右侧缓冲区会在对应位置插入一空行。（双列模式下，若要编写跨两列的文本，可按此方法操作：在左侧缓冲区编写文本，在右侧缓冲区对应位置保留空行即可。）
</p>

<p>
命令 <code>F2 RET</code> 或 <code>C-x 6 RET</code> (<code>2C-newline</code>) ，会在两个缓冲区的对应位置各插入一个换行符。在拆分后的双缓冲区中编辑双列文本时，这是为文本新增一行最便捷的方式。
</p>

<p>
当你完成对两个缓冲区的编辑后，可执行 <code>F2 1</code> 或 <code>C-x 6 1</code> (<code>2C-merge</code>) 合并两个缓冲区，该命令会将右侧缓冲区的文本作为第二列，合并至左侧缓冲区中。若需再次进入双列编辑模式，重新执行 <code>F2 s</code> 即可。
</p>

<p>
执行 <code>F2 d</code> 或 <code>C-x 6 d</code> 可解除两个缓冲区的关联关系，各自保留当前内容 (<code>2C-dissociate</code>) 。若执行该命令时，非当前的另一个缓冲区为空白状态，则该缓冲区会被直接删除。
</p>
</div>
</div>
</section>
<section id="outline-container-Programs" class="outline-2">
<h2 id="Programs"><span class="section-number-2">28.</span> 程序编辑</h2>
<div class="outline-text-2" id="text-Programs">
<p>
本章介绍 Emacs 中用于便捷编辑程序代码的各类功能，这些功能可实现的操作包括：
</p>
<ul class="org-ul">
<li>查找或跳转至顶层定义（参见「<a href="#Defuns">顶层定义（Defuns）</a>」章节）</li>
<li>遵循编程语言的通用缩进规范进行缩进（参见「<a href="#Program-Indent">程序代码的缩进</a>」章节）</li>
<li>匹配括号（参见「<a href="#Parentheses">括号编辑相关命令</a>」章节）</li>
<li>插入、删除或对齐注释（参见「<a href="#Comments">注释的操作</a>」章节）</li>
<li>高亮程序语法（参见「<a href="#Font-Lock">字体锁定模式</a>」章节）</li>
</ul>


<ul class="org-ul">
<li><a href="#Program-Modes">编程语言相关主模式</a></li>
<li><a href="#Defuns">顶层定义（或函数定义）</a></li>
<li><a href="#Program-Indent">程序缩进</a></li>
<li><a href="#Parentheses">括号编辑相关命令</a></li>
<li><a href="#Comments">注释处理</a></li>
<li><a href="#Documentation">文档查阅</a></li>
<li><a href="#Hideshow">代码折叠次模式</a></li>
<li><a href="#Symbol-Completion">符号名称补全</a></li>
<li><a href="#MixedCase-Words">混合大小写单词处理</a></li>
<li><a href="#Semantic">语义分析（Semantic）</a></li>
<li><a href="#Misc-for-Programs">其他程序编辑实用功能</a></li>
<li><a href="#C-Modes">C 语言及相关模式</a></li>
<li><a href="#Asm-Mode">汇编语言模式</a></li>
<li><a href="#Fortran">Fortran 模式</a></li>
</ul>
</div>
<div id="outline-container-Program-Modes" class="outline-3">
<h3 id="Program-Modes"><span class="section-number-3">28.1.</span> 编程语言相关主模式</h3>
<div class="outline-text-3" id="text-Program-Modes">
<p>
Emacs 为多种编程语言提供了专用的主模式（参见「<a href="#Major-Modes">主模式</a>」章节）。一款编程语言主模式通常会定义该语言的表达式语法、通用缩进规则、语法高亮的实现方式，以及函数定义的起止位置查找方法，通常还会集成程序编译和调试相关功能。各语言的主模式均以对应语言命名，例如 C 语言的主模式为 <code>c-mode</code> 。
</p>

<p>
Emacs 支持的编程语言主模式涵盖：Lisp、Scheme、基于 Scheme 的 DSSSL 表达式语言、Ada、汇编语言（ASM）、AWK、C、C++、C#、Elixir、Fortran、Icon、IDL（CORBA）、HEEx、IDLWAVE、Java、JavaScript、Lua、M4、Makefile、Metafont（TeX 的字体制作配套语言）、Modula2、Object Pascal、Objective-C、Octave、Pascal、Perl、PHP、Pike、PostScript、Prolog、Python、Ruby、Simula、SQL、Tcl、TypeScript、Verilog、VHDL。Perl 语言推荐使用的主模式为 CPerl mode。此外，Emacs 还为 GNU 和 Unix 通用 Shell 的脚本语言、MS-DOS/MS-Windows 的 BAT 批处理文件、JSON、DNS 主配置文件、层叠样式表（CSS）、Dockerfile、CMake 配置文件，以及各类系统配置文件提供了对应的主模式。
</p>

<p>
理想情况下，Emacs 应为所有可能需要编辑的编程语言都提供对应的主模式。若你常用的语言暂无内置主模式，该模式可能存在于 Emacs 官方分发包之外的扩展包中（参见「<a href="#Packages">Emacs Lisp 扩展包</a>」章节），你也可以自行开发并贡献对应的主模式。
</p>

<p>
若 Emacs 编译时集成了 '<code>tree-sitter</code>' 库，还会提供一系列基于该库的可选编辑模式。这类模式借助 'tree-sitter' 的增量解析能力实现，模式名中均包含 '<code>-ts-</code>'，例如 C 语言的 <code>c-ts-mode</code> 、Python 语言的 <code>python-ts-mode</code> 等。
</p>

<p>
编程语言主模式可通过 Eglot 扩展包提供的功能，调用语言服务器的各类服务。Eglot 扩展包实现了语言服务器协议（LSP），让 Emacs 能够接收特定语言的专属信息与服务，从而丰富并扩展源代码的编辑能力。相关详情参见《Eglot：Emacs LSP 客户端》手册中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/eglot_html/Eglot-Features.html#Eglot-Features">Eglot 功能</a>」章节。
</p>

<p>
在绝大多数编程语言中，代码的缩进需随行调整，以体现程序的结构层次。因此，在多数编程语言主模式下，按下 <code>TAB</code> 键会自动更新当前行的缩进格式（参见「<a href="#Program-Indent">程序代码的缩进</a>」章节）。此外，删除键（ <code>DEL</code> ）通常绑定为 <code>backward-delete-char-untabify</code> 函数，该函数会向后删除字符，并将制表符（ <code>Tab</code> ）视作等效数量的空格处理；如此一来，你在删除一列缩进时，无需顾虑该空白区域是由空格还是制表符构成。
</p>

<p>
进入某一编程语言主模式时，Emacs 会先执行钩子变量 <code>prog-mode-hook</code> 中指定的自定义 Lisp 函数，再执行该模式自身的模式钩子中定义的函数（参见「<a href="#Major-Modes">主模式</a>」章节）。例如，进入 C 模式时，会依次执行prog-mode-hook和c-mode-hook两个钩子中的函数。有关钩子的详细说明，参见「钩子」章节。
</p>

<p>
Ada、C/C++/Objective-C/Java/CORBA IDL/Pike/AWK、Octave、VHDL、IDLWAVE 等语言的主模式均配有独立的使用手册，分别参见《Ada 模式手册》中的「<a href="https://elpa.gnu.org/packages/ada-mode.html#Top">Ada 模式</a>」、《CC 模式手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/ccmode/index.html#Top">CC 模式</a>」，以及《IDLWAVE 用户手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/idlwave/index.html#Top">IDLWAVE</a>」章节。
</p>
</div>
</div>
<div id="outline-container-Defuns" class="outline-3">
<h3 id="Defuns"><span class="section-number-3">28.2.</span> 顶层定义（或函数定义）</h3>
<div class="outline-text-3" id="text-Defuns">
<p>
在 Emacs 中，缓冲区里顶层的主要定义（如函数）被称为函数定义块（ <i>defun</i> ）。该名称源自 Lisp 语言，但在 Emacs 中，这一术语适用于所有编程语言。
</p>
<ul class="org-ul">
<li><a href="#Left-Margin-Paren">左边距约定</a></li>
<li><a href="#Moving-by-Defuns">按函数定义移动</a></li>
<li><a href="#Moving-by-Sentences">按句子移动</a></li>
<li><a href="#Imenu">索引菜单（Imenu）</a></li>
<li><a href="#Which-Function">函数定位模式</a></li>
</ul>
</div>
<div id="outline-container-Left-Margin-Paren" class="outline-4">
<h4 id="Left-Margin-Paren"><span class="section-number-4">28.2.1.</span> 左边距约定</h4>
<div class="outline-text-4" id="text-Left-Margin-Paren">
<p>
许多编程语言模式历来遵循一项约定：凡出现在左侧边距的左括号或左大括号，均视为顶层定义（函数定义块）的起始位置。因此默认情况下，用于定位函数定义块起始位置的各类命令，会将此类分隔符视作该位置的标识。
</p>

<p>
若需取消该约定，可将用户选项 <code>open-paren-in-column-0-is-defun-start</code> 设为 <code>nil</code> 。当该选项设为 <code>t</code> （默认值）时，定位函数定义块起始位置的命令，会在第 0 列的左括号 / 左大括号处停止（注释或字符串内的括号除外）；设为 <code>nil</code> 时，程序会通过检索最外层的括号来定位函数定义块。由于 Emacs 底层子程序已不再依赖该约定，通常无需修改此选项的默认值。
</p>
</div>
</div>
<div id="outline-container-Moving-by-Defuns" class="outline-4">
<h4 id="Moving-by-Defuns"><span class="section-number-4">28.2.2.</span> 按函数定义移动</h4>
<div class="outline-text-4" id="text-Moving-by-Defuns">
<p>
下述命令可基于顶层主要定义（亦称作函数定义块 <i>defuns</i> ）移动光标位置，或设定选区范围。
</p>
<dl class="org-dl">
<dt><code>C-M-a</code></dt><dd>移至当前或上一个函数定义块的起始位置 (<code>beginning-of-defun</code>) 。</dd>
<dt><code>C-M-e</code></dt><dd>移至当前或下一个函数定义块的结束位置 (<code>end-of-defun</code>) 。</dd>
<dt><code>C-M-h</code></dt><dd>将当前或下一个函数定义块整体选中为选区 (<code>mark-defun</code>) 。</dd>
</dl>

<p>
移至当前函数定义块起始和结束位置的命令分别为 <code>C-M-a</code> (<code>beginning-of-defun</code>) 和 <code>C-M-e</code> (<code>end-of-defun</code>) 。若重复执行其中任一命令，或传入正数值参数，每一次重复都会沿当前移动方向跳至下一个函数定义块。
</p>

<p>
为 <code>C-M-a</code> 传入负数值参数 <code>−n</code> 时，会向前跳 <code>n</code> 次，定位至第 <code>n</code> 个函数定义块的起始位置。该位置与为 <code>C-M-e</code> 传入参数 <code>n</code> 后定位的位置并非完全一致 —— 当前函数定义块的结束位置，通常与下一个函数定义块的起始位置之间存在间隔（可能包含空白字符、注释语句，甚至声明代码）。同理，为 <code>C-M-e</code> 传入负数值参数时，会向后跳至某一函数定义块的结束位置，该位置也与为 <code>C-M-a</code> 传入正数值参数后定位的位置略有差异。
</p>

<p>
若要对当前函数定义块执行操作，可使用 <code>C-M-h</code> (<code>mark-defun</code>) ：该命令会将标记点设至当前函数定义块的结束位置，同时将光标移至其起始位置（详见《<a href="#Marking-Objects">标记文本对象的相关命令</a>》）。这是快速选中并删除函数定义块，以便将其移至文件其他位置的最简便方法。若该函数定义块前方紧邻注释语句（二者之间无空行分隔），注释也会被一并选中。若光标处于两个函数定义块之间时执行该命令，会选中下一个函数定义块；若选区标记已处于激活状态时执行该命令，会将选区的结束位置向后扩展，纳入再下一个函数定义块。传入前缀参数时，该命令会选中对应数量的函数定义块，或按参数值扩展选区范围；传入负前缀参数时，会向相反方向选中函数定义块，且后续执行 <code>mark-defun</code> 命令时，选区的选择方向也会随之改变。
</p>

<p>
在 C 语言模式下， <code>C-M-h</code> 会调用函数 <code>c-mark-function</code> ，其功能与 <code>mark-defun</code> 基本一致，唯一区别在于：该函数会将选中范围向前覆盖至参数声明、函数名和返回数据类型的起始位置，确保整个 C 语言函数都被包含在选区内。这是主模式对标准按键绑定进行适配的典型示例，让按键能以更贴合特定编程语言的方式，实现其标准功能。其他主模式也可能为此，替换上述全部或部分按键的绑定功能。
</p>

<p>
部分编程语言支持嵌套式函数定义块，即一个函数定义块（如函数、方法或类）可定义在另一个函数定义块的内部（即作为其函数体的一部分）。上述命令在默认情况下，会定位至光标所在位置周边最内层的函数定义块的起始和结束位置。基于 <code>tree-sitter</code> 库的主模式可对该行为进行控制：若将变量 <code>treesit-defun-tactic</code> 的值设为 <code>top-level</code> ，这些函数定义块相关命令会转而定位至最外层的函数定义块。
</p>
</div>
</div>
<div id="outline-container-Moving-by-Sentences" class="outline-4">
<h4 id="Moving-by-Sentences"><span class="section-number-4">28.2.3.</span> 按句子移动</h4>
<div class="outline-text-4" id="text-Moving-by-Sentences">
<p>
此类命令会基于代码单元（也称作 <i>sentences语句块</i> ）移动光标位置或设置选区。尽管语句块的概念通常在编写自然语言时提及，但 Emacs 也可使用相同命令在编程语言的特定语法结构间移动（参见「<a href="#Sentences">语句块</a>」、「<a href="#Moving-by-Defuns">按定义块移动</a>」）。在编程语言中，一个语句块通常是完整的语法结构，规模小于定义块、大于 s表达式 （参见《Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/List-Motion.html#List-Motion">列表移动</a>」）。具体何种结构属于语句块依编程语言而定，一般为完整的语句，例如变量定义与初始化语句、条件判断语句等。
</p>

<p>
C 语言中的语句块示例：
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #228b22;">int</span> <span style="color: #a0522d;">x</span> = 5;
</pre>
</div>

<p>
JavaScript 语言中的语句块示例：
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #a020f0;">const</span> <span style="color: #a0522d;">thing</span> = () =&gt; console.log(<span style="color: #8b2252;">"Hi"</span>);
<span style="color: #a020f0;">const</span> <span style="color: #a0522d;">foo</span> = [1] == <span style="color: #8b2252;">'1'</span>
  ? <span style="color: #8b2252;">"No way"</span>
  : <span style="color: #8b2252;">"..."</span>;
</pre>
</div>

<dl class="org-dl">
<dt><code>M-a</code></dt><dd>移动到当前或前一个语句块的开头 (<code>backward-sentence</code>) 。</dd>
<dt><code>M-e</code></dt><dd>移动到当前或后一个语句块的结尾 (<code>forward-sentence</code>) 。</dd>
</dl>

<p>
移动到当前语句块开头和结尾的命令分别为 <code>M-a</code> (<code>backward-sentence</code>) 和 <code>M-e</code> (<code>forward-sentence</code>) 。重复执行其中任一命令，或传入正数值参数，每一次执行都会沿当前移动方向跳至下一个语句块。
</p>

<p>
给 <code>M-a</code> 传入负数值参数 <code>−n</code> 时，会向前跳 <code>n</code> 次至对应语句块的结尾；同理，给 <code>M-e</code> 传入负数值参数时，会向后跳至对应语句块的开头。
</p>
</div>
</div>
<div id="outline-container-Imenu" class="outline-4">
<h4 id="Imenu"><span class="section-number-4">28.2.4.</span> 索引菜单（Imenu）</h4>
<div class="outline-text-4" id="text-Imenu">
<p>
索引菜单功能支持通过 <b>名称</b> 查找文件中的主要定义内容，该功能在编程语言主模式和文本格式化主模式中均适用：在编程语言主模式下，可查找变量、函数等定义；在文本格式化主模式下，会将每一章、每一节等内容视作一个定义项。（如需跨多文件查找的更强大功能，可参见「<a href="#Xref">标识符引用查找</a>」相关内容。）
</p>

<p>
键入 <code>M-g i</code> (<code>imenu</code>) 后，该功能会通过迷你缓冲区读取目标定义的名称，随后将光标移动至该定义的位置。你可使用 <b>补全功能</b> 指定定义名称，该命令会在补全缓冲区中显示所有匹配的有效名称。若索引为 <b>层级结构</b> ，补全候选内容默认也会以嵌套列表的形式层级展示：需先选择一级分类，再选择二级子分类，依此类推，最后选定具体的定义名称。若将变量 <code>imenu-flatten</code> 设为非空值，则可直接从 <b>扁平化的定义列表</b> 中选择补全候选项，而非通过嵌套菜单选择。扁平化列表中各级分类的展示形式由 <code>imenu-flatten</code> 的取值决定，可选值包括以下三种：
</p>

<dl class="org-dl">
<dt><code>prefix</code></dt><dd>（前缀式）：每个候选项前会添加其所属的一级分类、二级子分类、三级子分类等名称，各级名称之间通过变量 <code>imenu-level-separator</code> 的取值字符串分隔，默认分隔符为冒号（ <code>:</code> ）。</dd>

<dt><code>annotation</code></dt><dd>（注解式）：将分类名称作为注解，显示在每个定义名称后方。</dd>

<dt><code>group</code></dt><dd>（分组式）：按所属分类对所有补全候选项进行分组展示。</dd>
</dl>

<p>
你也可将  <code>imenu</code> 命令绑定至鼠标点击操作，绑定后点击鼠标会弹出鼠标菜单，供你选择定义名称。还可调用命令 <code>imenu-add-menubar-index</code> ，将当前缓冲区的索引添加至菜单栏；若希望某一主模式下的所有缓冲区都显示该菜单项，可将该命令添加至该主模式的 <b>模式钩子</b> 中。需注意，完成此设置后，每次在该主模式下打开文件时，Emacs 会扫描缓冲区中的所有定义内容，此过程会产生短暂的等待。
</p>

<p>
当你修改缓冲区内容（如新增或删除定义项）后，可在索引菜单中选择 「重新扫描」项，根据新的内容更新缓冲区索引。若将变量 <code>imenu-auto-rescan</code> 设为非空值，系统会自动执行重新扫描；仅对文本做微小修改时，无需执行重新扫描操作。
</p>

<p>
当缓冲区的字节大小超过变量 <code>imenu-auto-rescan-maxout</code> 的取值时，自动重新扫描功能会被禁用；若扫描过程耗时超过变量 <code>imenu-max-index-time</code> 设定的秒数，扫描操作会直接终止。
</p>

<p>
可通过设置变量 <code>imenu-sort-function</code> ，自定义索引菜单的 <b>排序方式</b> ：默认按定义在缓冲区中的出现顺序排序；若需按字母顺序排序，将该变量值设为符号 <code>imenu--sort-by-name</code> 即可；你也可通过编写 Lisp 代码，自定义专属的比较排序函数。
</p>

<p>
此外，还可修改变量 <code>completion-category-overrides</code> ，并为其中的 <code>imenu</code> 分类设置 <code>display-sort-function</code> ，实现对索引菜单补全候选内容的排序自定义。
</p>

<p>
若当前缓冲区所属项目及主模式已激活 Eglot 插件（参见「<a href="#Projects">项目操作</a>」相关内容），Eglot 会通过管理当前缓冲区的语言服务器对程序源码进行分析，自行生成缓冲区的索引内容，相关细节可参见《Eglot：Emacs 语言服务器协议客户端》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/eglot_html/Eglot-Features.html#Eglot-Features">「Eglot 功能特性</a>」章节。
</p>

<p>
索引菜单会为函数定位模式提供定位指引（参见「<a href="#Which-Function">函数定位模式</a>」相关内容），Emacs 的速览栏也可调用该功能（参见「<a href="#Speedbar">速览栏框架</a>」相关内容）。
</p>
</div>
</div>
<div id="outline-container-Which-Function" class="outline-4">
<h4 id="Which-Function"><span class="section-number-4">28.2.5.</span> 函数定位模式</h4>
<div class="outline-text-4" id="text-Which-Function">
<p>
Which Function mode函数定位模式是一种全局次要模式（参见「<a href="#Minor-Modes">次要模式</a>」相关内容），可在模式行或标题行中显示当前所在的函数名称，且会随你在缓冲区中移动光标实时更新显示内容。
</p>

<p>
启用或关闭函数定位模式，可使用命令 <code>M-x which-function-mode</code> 。该模式为全局次要模式，默认情况下，会在所有支持该功能的主模式中生效（即所有兼容索引菜单的主模式）。若需限定其生效的主模式范围，可将变量 <code>which-func-modes</code>  的取值从 <code>t</code> （表示支持所有可用主模式）修改为指定的主模式名称列表。
</p>

<p>
函数定位模式默认在模式行中显示当前函数名称。自定义变量 <code>which-func-display</code> 的取值，设为 <code>header</code> 则仅在标题行显示，设为 <code>mode</code> 则仅在模式行显示，设为 <code>mode-and-header</code> 则在模式行和标题行同时显示。
</p>
</div>
</div>
</div>
<div id="outline-container-Program-Indent" class="outline-3">
<h3 id="Program-Indent"><span class="section-number-3">28.3.</span> 程序缩进</h3>
<div class="outline-text-3" id="text-Program-Indent">
<p>
保持程序代码缩进规范的最佳方式，是在修改代码时通过 Emacs 对其重新缩进。Emacs 提供了对应的缩进命令，可对单行代码、指定行数的代码，或是单个括号嵌套结构内的所有代码进行缩进处理。
</p>

<p>
关于缩进的通用说明，可参见「<a href="#Indentation">缩进</a>」相关章节。本节将介绍编程语言模式下特有的缩进功能。
</p>

<p>
Emacs 还在 <code>pp</code> 包中提供了 Lisp 代码美化打印工具，该工具可对 Lisp 对象重新格式化并生成规范美观的缩进。相关详情可参见《Emacs Lisp 参考手册》中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Output-Functions.html#Output-Functions">pp</a> 工具章节。
</p>

<ul class="org-ul">
<li><a href="#Basic-Indent">基本程序缩进命令</a></li>
<li><a href="#Multi_002dline-Indent">多行缩进</a></li>
<li><a href="#Lisp-Indent">定制 Lisp 缩进</a></li>
<li><a href="#C-Indent">C 语言缩进命令</a></li>
<li><a href="#Custom-C-Indent">定制 C 语言缩进</a></li>
</ul>
</div>
<div id="outline-container-Basic-Indent" class="outline-4">
<h4 id="Basic-Indent"><span class="section-number-4">28.3.1.</span> 基本程序缩进命令</h4>
<div class="outline-text-4" id="text-Basic-Indent">
<dl class="org-dl">
<dt><code>TAB</code></dt><dd>调整当前行的缩进格式 (<code>indent-for-tab-command</code>) 。</dd>
<dt><code>RET</code></dt><dd>插入换行符，随后调整新行的缩进格式 (<code>newline</code>) 。</dd>
</dl>

<p>
缩进操作的基础命令为 <code>TAB</code> 键 (<code>indent-for-tab-command</code>) ，该命令的通用说明见「<a href="#Indentation">缩进</a>」章节。在编程语言模式下， <code>TAB</code> 键会根据前序代码行的缩进格式和语法内容，为当前行自动缩进；若 <b>选区处于激活状态</b> ， <code>TAB</code> 键会为选区内的所有行统一缩进，而非仅处理当前行。
</p>

<p>
回车键 <code>RET</code> (<code>newline</code>) 的功能等同于先按 <code>C-j</code> 再按 <code>TAB</code> 键：先插入一个换行符，再为新生成的行自动调整缩进。
</p>

<p>
当为 <b>括号嵌套结构内</b> 的起始行做缩进时，Emacs 通常会将该行的起始位置对齐至结构内的前一行，或对齐至左括号后的文本位置。若你为这类行手动设置了非标准的缩进格式（例如出于排版美观的需求），其下方的代码行会自动沿用该缩进格式。
</p>

<p>
多数编程语言模式的缩进命令均遵循一个规则： <b>左边界处</b> 的左括号、左大括号或其他左分隔符，会被认定为函数的起始位置。若你编辑的代码违背了这一规则 —— 即便这些分隔符出现在字符串或注释中 —— 你需要将变量 <code>open-paren-in-column-0-is-defun-start</code> 设为 <code>nil</code> ，才能让缩进功能正常工作。相关说明见「<a href="#Left-Margin-Paren">左边界约定</a>」章节。
</p>
</div>
</div>
<div id="outline-container-Multi_002dline-Indent" class="outline-4">
<h4 id="Multi_002dline-Indent"><span class="section-number-4">28.3.2.</span> 多行缩进</h4>
<div class="outline-text-4" id="text-Multi_002dline-Indent">
<p>
有时你可能需要一次性为多行代码重新缩进，一种方法是使用标记：当标记激活且选区非空时，按下 <code>TAB</code> 键会为选区内的所有行统一缩进。此外，命令 <code>C-M-\</code> (<code>indent-region</code>) 同样能为选区内所有行缩进，无论标记是否处于激活状态（参见「<a href="#Indentation-Commands">缩进命令</a>」相关内容）。
</p>

<p>
Emacs 还提供了以下命令，用于对大段代码进行缩进处理：
</p>
<dl class="org-dl">
<dt><code>C-M-q</code></dt><dd>重新缩进单个括号嵌套结构内的所有代码行</dd>
<dt><code>M-q</code></dt><dd>填充某个定义块内的单个段落，或重新缩进该定义块内的所有代码行</dd>
<dt><code>C-u TAB</code></dt><dd>整体平移单个括号嵌套结构的缩进位置，使结构的首行缩进格式合规</dd>
<dt><code>M-x indent-code-rigidly</code></dt><dd>整体平移选区内所有代码行的缩进位置，不改动注释和字符串内的起始行</dd>
</dl>

<p>
若要为单个括号嵌套结构的内容重新缩进，将光标移至该结构起始位置前，按下 <code>C-M-q</code> 即可。该操作仅调整结构内代码的相对缩进，不会改变结构的整体缩进（即结构起始行的缩进格式）。 <code>C-M-q</code> 调用的具体函数由主模式决定：Lisp 模式下为 <code>indent-pp-sexp</code> ，C 模式下为 <code>c-indent-exp</code> 等。若需同时修正结构的整体缩进，可先按下 <code>TAB</code> 键。
</p>

<p>
若要为光标所在的整个定义块重新缩进，按下 <code>M-q</code> (<code>prog-fill-reindent-defun</code>) 即可。若光标处于注释或字符串内，该命令会改为对注释或字符串进行填充和缩进。注释、字符串或定义块的具体判定规则由主模式决定：定义块的边界由变量 <code>beginning-of-defun-function</code> 和 <code>end-of-defun-function</code> 定义（参见《Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/List-Motion.html#List-Motion">列表移动</a>」章节），填充机制则由变量 <code>fill-paragraph-function</code> 定义（参见《Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Filling.html#Filling">文本填充</a>」章节）。
</p>

<p>
若你希望保留括号嵌套结构内的相对缩进，仅修正其首行的缩进格式，将光标移至该首行并按下 <code>C-u TAB</code> 即可。在 Lisp、C 及其他部分主模式下，带数字参数的 <code>TAB</code> 键会先按常规方式为当前行重新缩进，再将以当前行为起始的括号嵌套结构内所有行，按相同缩进量同步调整。该命令设计较为智能，不会改动字符串内的起始行；在 C 模式下，也不会改动 C 预处理器行，但会为其关联的所有续行重新缩进。
</p>

<p>
命令 <code>M-x indent-code-rigidly</code> 的功能与 <code>indent-rigidly</code> 类似，可整体平移选区内所有代码行的缩进位置（参见「<a href="#Indentation-Commands">缩进命令</a>」相关内容）。该命令不会改动字符串内起始行的缩进，除非选区的起始位置也在该字符串内。前缀参数用于指定缩进的列数。
</p>
</div>
</div>
<div id="outline-container-Lisp-Indent" class="outline-4">
<h4 id="Lisp-Indent"><span class="section-number-4">28.3.3.</span> 定制 Lisp 缩进</h4>
<div class="outline-text-4" id="text-Lisp-Indent">
<p>
Lisp 表达式的缩进格式可由表达式所调用的函数决定。对于每个 Lisp 函数，你既可以从多种预定义缩进格式中选择，也可以通过编写 Lisp 程序自定义任意缩进规则。
</p>

<p>
标准缩进格式定义如下：若表达式的第一个参数与表达式起始位置在同一行，表达式的第二行将缩进至该参数下方；若不在同一行，第二行则缩进至函数名下方。后续每一行，均缩进至前一个同级嵌套深度的行下方。
</p>

<p>
若将变量 <code>lisp-indent-offset</code> 设为非空值，该变量会覆盖表达式第二行的常规缩进格式，使该行始终比其所属列表多缩进 <code>lisp-indent-offset</code> 列。
</p>

<p>
部分函数会覆盖上述标准缩进格式。名称以 <code>def</code> 开头的函数，会将表达式的第二行视作代码体的起始行，该行的缩进位置会在表达式起始左括号的基础上，再额外缩进 <code>lisp-body-indent</code> 列。
</p>

<p>
你可通过为函数名设置 <code>lisp-indent-function</code> 属性，以多种方式为单个函数单独覆盖标准缩进格式。该操作通常结合 <code>declare</code> 结构为宏定义完成，相关详情参见《Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Defining-Macros.html#Defining-Macros">宏定义</a>」章节。
</p>

<p>
在 Emacs Lisp 中，列表通常会被当作函数式形式进行缩进，示例如下：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq</span> foo '(bar zot
                gazonk))
</pre>
</div>

<p>
但如果在左括号后添加一个空格，会告知 Emacs 该列表为数据列表而非代码片段，此时 Emacs 会按如下格式缩进：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq</span> foo '( bar zot
             gazonk))
</pre>
</div>
</div>
</div>
<div id="outline-container-C-Indent" class="outline-4">
<h4 id="C-Indent"><span class="section-number-4">28.3.4.</span> C 语言缩进命令</h4>
<div class="outline-text-4" id="text-C-Indent">
<p>
以下是 C 模式及相关模式中用于缩进的专属功能：
</p>

<dl class="org-dl">
<dt><code>C-c C-q</code></dt><dd>重新缩进当前顶层函数定义或聚合类型声明（CC 模式下调用 <code>c-indent-defun</code> 函数，基于tree-sitter 的 <code>c-ts-mode</code> 模式下调用 <code>c-ts-mode-indent-defun</code> 函数）。</dd>

<dt><code>C-M-q</code></dt><dd>重新缩进光标后方的平衡表达式（参见「<a href="#Expressions">带配对分隔符的表达式</a>」相关内容，也称作 "sexp"）中所有行。CC 模式下该命令调用 <code>c-indent-exp</code> 函数；基于树解析的 <code>c-ts-mode</code> 模式下，会调用更通用的 <code>prog-indent-sexp</code> 函数。带前缀参数时，将抑制关于语法无效的警告信息。</dd>

<dt><code>TAB</code></dt><dd><p>
重新缩进当前行、已激活的选区，或以当前行为起始的代码块 (<code>c-indent-line-or-region</code>) 。带前缀参数时，若当前行需要重新缩进，将对以当前行为起始的平衡表达式进行刚性重新缩进。
</p>

<p>
若变量 <code>c-tab-always-indent</code> 设为t，该命令始终仅对当前行重新缩进，无其他操作，此为默认设置。
</p>

<p>
若该变量设为 <code>nil</code> ，仅当光标位于左边界或当前行的缩进区域内时，命令才会对当前行重新缩进；否则将插入一个制表符（若变量 <code>indent-tabs-mode</code> 设为 <code>nil</code> ，则插入同等数量的空格）。
</p>

<p>
若该变量设为 <code>t</code> 和 <code>nil</code> 之外的任意值，命令会始终对当前行重新缩进；若光标位于注释或字符串内，还会额外插入一个制表符。
</p></dd>
</dl>

<p>
若要为当前整个缓冲区重新缩进，按下 <code>C-x h C-M-\.</code> 即可。该操作会先将整个缓冲区选为选区，再对选区执行重新缩进。
</p>

<p>
若要为当前代码块重新缩进，使用 <code>C-M-u C-M-q</code> 组合操作。该操作会先将光标移至代码块起始位置，再对整个代码块执行重新缩进。
</p>
</div>
</div>
<div id="outline-container-Custom-C-Indent" class="outline-4">
<h4 id="Custom-C-Indent"><span class="section-number-4">28.3.5.</span> 定制 C 语言缩进</h4>
<div class="outline-text-4" id="text-Custom-C-Indent">
<p>
C 模式及相关模式提供了灵活的缩进自定义机制。C 模式对源码行的缩进分为两步执行：第一步，根据行的内容和上下文，对该行进行语法分类；第二步，根据你选定的缩进风格，匹配该语法结构对应的缩进偏移量，并将该偏移量叠加至锚定语句的缩进值上。
</p>

<dl class="org-dl">
<dt><code>C-c . 风格名 RET</code></dt><dd>选定预定义的缩进风格（CC 模式下调用函数 <code>c-set-style</code> ，基于 tree-sitter 的 <code>c-ts-mode 模式下调用 ~c-ts-mode-set-style</code> ）。</dd>
</dl>

<p>
缩进风格是一组命名的自定义配置集合，可在 C 模式及相关模式中使用，关于风格的完整说明参见《CC 模式手册》的「<a href="https://www.gnu.org/software/emacs/manual/html_node/ccmode/Styles.html#Styles">缩进风格</a>」章节。Emacs 内置了多种预定义缩进风格，包括 <code>gnu</code> 、 <code>k&amp;r</code> 、 <code>zbsd</code> 、 <code>stroustrup</code> 、 <code>linux</code> 、 <code>python</code> 、 <code>java</code> 、 <code>whitesmith</code> 、 <code>ellemtel</code>  和 <code>awk</code> 。其中部分风格最初为特定语言设计，但所有风格均可用于这些模式支持的任意编程语言。若想查看某一风格的实际效果，可先选定该风格，再对部分代码重新缩进，例如在函数定义起始位置按下  <code>C-M-q</code> 。
</p>

<p>
为当前缓冲区选择缩进风格，可使用命令 <code>C-c .</code> ，并传入风格名作为参数（大小写不敏感）。该命令仅对当前缓冲区生效，且仅影响后续执行的缩进操作，不会对缓冲区中已有的代码重新缩进。若要按照新风格对整个缓冲区重新缩进，可按下 <code>C-x h C-M-\</code> 。
</p>

<p>
使用 CC 模式时，可通过修改变量 <code>c-default-style</code> 为不同主模式指定默认缩进风格。该变量的值可以是风格名字符串，也可以是关联列表 —— 列表中的每个元素为一个主模式指定对应的缩进风格。示例如下：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq</span> c-default-style
      '((java-mode . <span style="color: #8b2252;">"java"</span>)
        (awk-mode . <span style="color: #8b2252;">"awk"</span>)
        (other . <span style="color: #8b2252;">"gnu"</span>)))
</pre>
</div>

<p>
上述配置为 Java 模式和 AWK 模式显式指定了对应缩进风格，为其他类 C 模式设置了默认的 gnu 风格（该配置也是 Emacs 的默认设置）。该变量在你选定某一类 C 主模式时生效；因此，若为 Java 模式指定了新的默认风格，可在已打开的 Java 模式缓冲区中按下 <code>M-x java-mode</code> ，使新配置生效。
</p>

<p>
使用基于 tree-sitter 的 <code>c-ts-mode</code> 模式时，可通过自定义变量 <code>c-ts-mode-indent-style</code> 设置默认缩进风格。
</p>

<p>
gnu 风格是 GNU 项目推荐的 C 语言代码格式化风格，也是 Emacs 的默认缩进风格，旨在推广使用该推荐风格。
</p>

<p>
关于 C 模式及相关模式的缩进自定义更多细节，包括如何覆盖现有风格的部分配置、如何自定义全新缩进风格，可参见《CC 模式手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/ccmode/Indentation-Engine-Basics.html#Indentation-Engine-Basics">缩进引擎基础</a>」和「<a href="https://www.gnu.org/software/emacs/manual/html_node/ccmode/Customizing-Indentation.html#Customizing-Indentation">自定义缩进</a>」章节。
</p>

<p>
除了直接指定缩进风格，你也可在包含示例代码的缓冲区中按下 <code>M-x c-guess</code> ，让 Emacs <b>自动识别并匹配</b> 代码的缩进风格；随后可使用 <code>M-x c-guess-install</code> ，将识别出的风格应用到其他缓冲区，具体细节参见《CC 模式手册》的「<a href="https://www.gnu.org/software/emacs/manual/html_node/ccmode/Guessing-the-Style.html#Guessing-the-Style">风格自动识别</a>」章节。
</p>
</div>
</div>
</div>
<div id="outline-container-Parentheses" class="outline-3">
<h3 id="Parentheses"><span class="section-number-3">28.4.</span> 括号编辑相关命令</h3>
<div class="outline-text-3" id="text-Parentheses">
<p>
本节介绍利用程序中的括号结构实现的编辑命令与功能，也包含帮助你保持括号配对平衡的相关内容。
</p>

<p>
在介绍这类功能时，术语 “parenthesis括号” 也包含大括号、方括号，以及所有被定义为成对匹配的分隔符。主模式会通过语法表控制哪些分隔符为有效匹配分隔符（参见《Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Tables.html#Syntax-Tables">语法表</a>」章节）。在 Lisp 模式下，仅圆括号参与匹配；在 C 模式下，这些命令同时适用于大括号和方括号。
</p>

<p>
你可以使用 <code>M-x check-parens</code> 命令，检查缓冲区中所有未配对的括号与未闭合的字符串引号。
</p>

<p>
配套内容：配对括号的表达式括号结构内的光标移动括号匹配
</p>
<ul class="org-ul">
<li><a href="#Expressions">配对括号的表达式</a></li>
<li><a href="#Moving-by-Parens">括号结构内的光标移动</a></li>
<li><a href="#Matching">括号匹配</a></li>
</ul>
</div>
<div id="outline-container-Expressions" class="outline-4">
<h4 id="Expressions"><span class="section-number-4">28.4.1.</span> 配对括号的表达式</h4>
<div class="outline-text-4" id="text-Expressions">
<p>
每种编程语言模式都有其自身对 <b>配对括号表达式</b> 的定义。这类表达式通常包含单个符号、数字、字符串常量，以及由成对匹配分隔符包裹的代码段。下述命令均针对配对括号表达式操作（在 Emacs 内部，这类表达式被称作 <i>sexps</i><sup><a id="fnr.14" class="footref" href="#fn.14" role="doc-backlink">14</a></sup>）。
</p>

<p>
<b>核心快捷键与对应功能</b>
</p>
<dl class="org-dl">
<dt><code>C-M-f</code></dt><dd>向前移动一个配对括号表达式 (<code>forward-sexp</code>) 。</dd>
<dt><code>C-M-b</code></dt><dd>向后移动一个配对括号表达式 (<code>backward-sexp</code>) 。</dd>
<dt><code>C-M-k</code></dt><dd>向前删除一个配对括号表达式 (<code>kill-sexp</code>) 。</dd>
<dt><code>C-M-t</code></dt><dd>交换表达式位置 (<code>transpose-sexps</code>) 。</dd>
<dt><code>C-M-@</code></dt><dd></dd>

<dt><code>C-M-SPC</code></dt><dd>将标记点置于后续表达式末尾 (<code>mark-sexp</code>) 。</dd>
</dl>

<p>
<b>命令详细说明</b>
</p>

<p>
使用 <code>C-M-f</code> (<code>forward-sexp</code>) 可向前移动至下一个配对括号表达式的末尾。若光标后的第一个有效字符是左分隔符（例如 C 语言中的 ‘(’、‘[’、‘{’），该命令会直接跳至对应的右分隔符之后；若该字符为符号、字符串或数字的起始，命令则会移动至该内容的末尾。
</p>

<p>
<code>C-M-b</code> (<code>backward-sexp</code>) 与 <code>C-M-f</code> 功能相反，用于 <b>向后</b> 移动一个配对括号表达式。若目标表达式前带有前缀字符（如 Lisp 中的单引号、反引号和逗号），命令会同时跳过这些前缀字符。
</p>

<p>
给 <code>C-M-f</code> 或 <code>C-M-b</code> 加上数字参数，可按指定次数重复对应操作；若参数为负数，则向相反方向移动。在大多数模式下，这两个命令会将注释视作空白字符，直接跳过。需注意，这两个快捷键与按字符移动的 <code>C-f=/ =C-b</code> （参见「<a href="#Moving-Point">光标位置调整</a>」）、按单词移动的 <code>M-f</code> / <code>M-b</code> （参见「<a href="#Words">单词操作</a>」）用法类比，逻辑一致。
</p>

<p>
键入 <code>C-M-k</code> (<code>kill-sexp</code>) 可删除整个配对括号表达式，删除范围与 <code>C-M-f</code> 的移动范围完全一致。
</p>

<p>
<code>C-M-t</code> (<code>transpose-sexps</code>) 用于 <b>交换光标前后相邻的两个配对括号表达式</b> ，与交换单个字符的 <code>C-t</code> 命令（参见「<a href="#Transpose">文本交换</a>」）用法类比。给 <code>C-M-t</code> 加数字参数可作为重复次数：正数参数会将光标前的表达式向后交换过指定数量的后续表达式；负数参数则将光标前的表达式向前交换过指定数量的前方表达式；若参数为 0，并非无操作，而是交换 <b>光标 / 标记点处及之后</b> 的配对括号表达式。
</p>

<p>
若要结合 <b>区域操作命令</b> 处理配对括号表达式，可键入 <code>C-M-SPC</code> (<code>mark-sexp</code>) ，该命令会将标记点设为 <code>C-M-f</code> 移动的目标位置。当标记点处于激活状态时，重复调用此命令会将标记点再向后移动一个表达式，从而扩展选中区域；正 / 负数字参数可让标记点向前 / 向后移动指定数量的表达式。 <code>C-M-@</code> 是 <code>C-M-SPC</code> 的别名，功能完全相同。更多相关命令说明可参见「<a href="#Marking-Objects">文本对象标记命令</a>」章节。
</p>

<p>
在 C 语言这类使用 <b>infix operators中缀运算符</b> 的语言中，Emacs 无法识别所有的配对括号表达式，因为同一位置可能存在多种表达式解析可能。例如，C 模式不会将 ‘foo + bar’ 视作单个表达式（尽管它在 C 语法中是一个完整表达式），而是将 ‘foo’ 和 ‘bar’ 分别识别为两个独立表达式，将+视作二者之间的标点符号；但对于 ‘(foo + bar)’ ，由于括号的包裹，C 模式会将其识别为单个完整的配对括号表达式。
</p>
</div>
</div>
<div id="outline-container-Moving-by-Parens" class="outline-4">
<h4 id="Moving-by-Parens"><span class="section-number-4">28.4.2.</span> 括号结构内的光标移动</h4>
<div class="outline-text-4" id="text-Moving-by-Parens">
<p>
下述命令可在括号分隔的代码块间移动（也适用于当前编辑语言中其他类型的配对分隔符）。这些命令会忽略字符串与注释内容（包括其中的所有括号），同时也会忽略经转义字符转义的括号。此类命令主要用于程序编辑，也可在编辑任何包含括号的文本时发挥作用；在 Emacs 内部它们被称 “list commands作列表命令”，原因是 Lisp 语言中这类括号分隔的代码块即为列表。
</p>

<p>
这些命令默认光标起始位置不在字符串或注释内部，若在字符串 / 注释内调用，执行结果可能不符合预期。
</p>

<dl class="org-dl">
<dt><code>C-M-n</code></dt><dd>向前跳过一个括号代码块 (<code>forward-list</code>) 。</dd>
<dt><code>C-M-p</code></dt><dd>向后跳过一个括号代码块 (<code>backward-list</code>) 。</dd>
<dt><code>C-M-u</code></dt><dd>向上跳转一级括号结构 (<code>backward-up-list</code>) 。</dd>
<dt><code>C-M-d</code></dt><dd>向下跳转一级括号结构 (<code>down-list</code>) 。</dd>
</dl>

<p>
列表命令 <code>C-M-n</code> (<code>forward-list</code>) 与 <code>C-M-p</code> (<code>backward-list</code>) ，可向前或向后跳过 1 个（或指定 n 个）括号代码块，且始终保持在当前的括号层级。
</p>

<p>
若要向上跳转 1 级（或指定 n 级）括号结构，可使用 <code>C-M-u</code> (<code>backward-up-list</code>) ，该命令会向后移动一个未配对的左分隔符，实现层级上移。带正数字参数表示重复跳转对应次数；带负数字参数则反转移动方向，向前并向上跳转对应层级。
</p>

<p>
若要向下跳转括号结构，可使用 <code>C-M-d</code> (<code>down-list</code>) 。在仅将左圆括号(作为起始分隔符的 Lisp 模式下，该命令的效果几乎等同于搜索左圆括号 ‘(’ ；给命令添加数字参数，可指定向下跳转的层级数。
</p>
</div>
</div>
<div id="outline-container-Matching" class="outline-4">
<h4 id="Matching"><span class="section-number-4">28.4.3.</span> 括号匹配</h4>
<div class="outline-text-4" id="text-Matching">
<p>
Emacs 提供了多项括号匹配功能，能让你轻松查看括号（或其他成对分隔符）的匹配方式与匹配状态。
</p>

<p>
当你键入可自动插入的闭合分隔符时，若对应的左分隔符处于当前屏幕范围内，Emacs 会短暂标记其位置；若左分隔符不在屏幕范围内，Emacs 则会在回显区显示其附近的部分文本。无论哪种情况，你都能明确当前闭合的是哪一个代码分组。若左、右分隔符出现不匹配的情况（如 ‘[x)’ ），回显区会弹出警告信息。
</p>

<p>
有三个变量用于控制括号匹配的显示效果：
</p>
<ul class="org-ul">
<li><code>blink-matching-paren</code> ：开启或关闭该功能，设为nil则禁用，默认值为 <code>t</code> （开启）。设为 <code>jump</code> 时，会通过将光标短暂移至匹配的左分隔符处实现标记；设为 <code>jump-offscreen</code> 时，即便左分隔符不在屏幕范围内，光标也会跳转至对应位置。</li>
<li><code>blink-matching-delay</code> ：设置匹配左分隔符的标记持续时间（单位：秒），可设为整数或浮点数，默认值为 1。</li>
<li><code>blink-matching-paren-distance</code> ：指定向前搜索匹配左分隔符的字符范围，若超出该范围仍未找到匹配项，Emacs 会停止扫描且不显示任何标记，默认值为 102400。</li>
</ul>

<p>
括号显示模式（Show Paren mode） 是一种功能更强大的自动匹配次要模式。当光标位于左分隔符之前或右分隔符之后时，该分隔符、其匹配的分隔符，以及（可选的）二者之间的文本会被高亮显示。键入 <code>M-x show-paren-mode</code> 可在全局范围内切换该模式，键入 <code>M-x show-paren-local-mode</code> 则仅在当前缓冲区切换。
</p>

<p>
默认情况下，该模式会在所有用于编辑的缓冲区中开启，而在仅用于展示数据的缓冲区中禁用，此行为由用户选项 <code>show-paren-predicate</code> 控制。
</p>

<p>
若要自定义该模式，可键入 -M-x customize-group RET paren-showing= 。控制该模式运行的可自定义选项包括：
</p>
<ul class="org-ul">
<li><code>show-paren-highlight-openparen</code> ：控制当光标紧邻左分隔符前时，是否高亮该左分隔符（光标本身已标记其位置），默认值为非nil（开启）。</li>
<li><code>show-paren-style</code> ：控制仅高亮一对分隔符，还是同时高亮二者之间的文本。可选值为 <code>parenthesis</code> （仅显示匹配的分隔符）、 <code>expression</code> （高亮括号包裹的整个表达式）、 <code>mixed</code> （若匹配的分隔符在窗口内可见则高亮分隔符，否则高亮整个表达式）。</li>
<li><code>show-paren-when-point-inside-paren</code> ：设为非nil时，即便光标位于括号内部，也会触发高亮，默认值为 <code>nil</code> （关闭）。</li>
<li><code>show-paren-when-point-in-periphery</code> ：设为非nil时，以下两种情况也会触发高亮：光标位于行首空白处，且该行首个或最后一个非空白字符为括号；光标位于行尾，且该行最后一个非空白字符为括号。</li>
<li><code>show-paren-context-when-offscreen</code> ：设为非nil时，若光标位于右分隔符处且对应的左分隔符不在屏幕范围内，会在回显区显示相关上下文 —— 通常为包含左分隔符的整行，若左分隔符单独占一行，则上下文会包含其前一个非空行。</li>
</ul>

<p>
快速配对模式（Electric Pair mode） 是一款可快速插入成对匹配分隔符的次要模式，支持括号、大括号、方括号、引号等（具体的匹配分隔符由主模式决定）。键入 <code>M-x electric-pair-mode</code> 可在全局切换该模式，键入 <code>M-x electric-pair-local-mode</code> 仅在当前缓冲区切换。
</p>

<p>
开启该模式后，键入左分隔符时，Emacs 会同时插入对应的右分隔符，并将光标置于两个分隔符之间。多数情况下，你无需再手动键入闭合分隔符。若你仍手动键入了闭合分隔符，Emacs 会直接插入该字符；但如果光标紧邻同类型的右分隔符前，光标会直接跳至该右分隔符之后，且不会额外插入新的闭合分隔符。因此，键入「左分隔符→对应右分隔符」的操作，比「左分隔符→C-f」的操作更便捷。
</p>

<p>
当存在激活的选区时（参见「<a href="#Mark">标记与选区</a>」），Electric Pair mode 的行为会发生变化：键入左分隔符或右分隔符，都会将选区内的文本包裹在一对匹配的分隔符中，且光标会停在你键入的分隔符之后 —— 这一设计方便你在左分隔符后的文本前，或右分隔符后继续输入内容。
</p>

<p>
有多个用户选项可修改 Electric Pair mode 的行为：
</p>
<ul class="org-ul">
<li><p>
<code>electric-pair-preserve-balance</code> ：设为非nil（默认值）时，键入分隔符会保持左、右分隔符的配对平衡。例如，若你键入左分隔符，且缓冲区后方存在未配对的对应右分隔符，则仅插入左分隔符（不会立即跟随插入右分隔符）；同理，若缓冲区前方存在未配对的左分隔符，那么在后方键入对应右分隔符时，即便其后紧邻另一个同类型右分隔符，也会正常插入该字符。
</p>

<p>
设为 <code>nil</code> 时，仅当光标紧邻同类型左分隔符前后，或紧邻字母 / 数字前时，键入左分隔符才会仅插入该字符；在其他所有位置键入左分隔符，都会自动在其后插入匹配的右分隔符，即便缓冲区后方存在未配对的对应右分隔符。且当光标紧邻同类型右分隔符前时，键入该右分隔符不会插入字符，而是按上述规则移动光标，即便缓冲区前方存在未配对的左分隔符。
</p>

<p>
若存在激活的选区，该变量将失效。
</p></li>
<li><code>electric-pair-delete-adjacent-pairs</code> ：设为非nil（默认值）时，按下删除键（ <code>DEL</code> ，通常为退格键 <code>BACKSPACE</code> ）删除左分隔符时，若其后紧邻匹配的右分隔符（且成对分隔符之间无任何字符，包括空白符），会自动同时删除该右分隔符；设为 <code>nil</code> 时，按下退格键仅删除左分隔符（按下退格键删除右分隔符时，始终仅删除该字符）。</li>
<li><code>electric-pair-open-newline-between-pairs</code> ：设为非nil（默认值）时，若光标位于左分隔符和其后紧邻的匹配右分隔符之间，按下换行键会在光标后自动插入一个额外的换行符（光标所在的空行可能会根据主模式进行缩进）；设为 <code>nil</code> 时，按下换行键会像常规操作一样，仅在光标前插入一个换行符。</li>
<li><code>electric-pair-skip-whitespace</code> ：保持默认的非nil值时，若光标与右分隔符之间仅存在空白符，键入同类型右分隔符不会插入字符，而是将光标直接移至已存在的右分隔符之后；你也可将该选项设为同时删除光标移动过程中经过的所有空白符。设为 <code>nil</code> 时，键入右分隔符会直接插入该字符，即便这会导致其后的同类型右分隔符出现配对失衡。</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-Comments" class="outline-3">
<h3 id="Comments"><span class="section-number-3">28.5.</span> 注释处理</h3>
<div class="outline-text-3" id="text-Comments">
<p>
注释是编程中至关重要的组成部分，因此 Emacs 提供了专门用于编辑和插入注释的命令。它还可通过 拼写检查模式 Flyspell Prog mode 对注释进行拼写检查（详见 “<a href="#Spelling">拼写检查与修正</a>” 章节）。
</p>

<p>
部分主模式针对不同类型注释的缩进制定了特殊规则。例如，在 Lisp 代码中，以两个分号（ <code>;;</code> ）开头的注释会按代码行的方式缩进，而以三个分号（ <code>;;;</code> ）开头的注释则应左对齐到页边距，且常用于代码分段说明。Emacs 能够识别这些约定：例如，在注释行按 <code>Tab</code> 键时，会将注释缩进至合适位置。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#27492;&#20989;&#25968;&#20165;&#20026;&#31034;&#20363;
</span><span style="color: #b22222;">;;; </span><span style="color: #b22222;">&#27492;&#22788;&#20351;&#29992;&#20004;&#20010;&#25110;&#19977;&#20010;&#20998;&#21495;&#22343;&#21487;
</span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">foo</span> (x)
<span style="color: #b22222;">;;;  </span><span style="color: #b22222;">&#25509;&#19979;&#26469;&#26159;&#20989;&#25968;&#30340;&#31532;&#19968;&#37096;&#20998;&#65306;
</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">&#19979;&#19968;&#34892;&#23454;&#29616;&#21152;&#19968;&#25805;&#20316;
</span>  (1+ x))           <span style="color: #b22222;">; </span><span style="color: #b22222;">&#27492;&#34892;&#23454;&#29616;&#21152;&#19968;&#25805;&#20316;</span>
</pre>
</div>


<ul class="org-ul">
<li><a href="#Comment-Commands">注释命令</a></li>
<li><a href="#Multi_002dLine-Comments">多行注释</a></li>
<li><a href="#Options-for-Comments">控制注释的相关选项</a></li>
</ul>
</div>
<div id="outline-container-Comment-Commands" class="outline-4">
<h4 id="Comment-Commands"><span class="section-number-4">28.5.1.</span> 注释命令</h4>
<div class="outline-text-4" id="text-Comment-Commands">
<p>
下述命令专用于注释的编辑操作：
</p>
<dl class="org-dl">
<dt><code>M-;</code></dt><dd>为当前行插入注释或重新对齐已有注释；若选区处于激活状态，则改为为选区添加注释或取消注释 (<code>comment-dwim</code>) 。</dd>
<dt><code>C-x C-;</code></dt><dd>为当前行添加注释或取消注释 (<code>comment-line</code>) 。若选区处于激活状态，则改为为选区中的所有行添加 / 取消注释。</dd>
<dt><code>C-u M-;</code></dt><dd>删除当前行的注释内容 (<code>comment-kill</code>) 。</dd>
<dt><code>C-x ;</code></dt><dd>设置注释的对齐列数 (<code>comment-set-column</code>) 。</dd>
<dt><code>C-M-j</code></dt><dd></dd>

<dt><code>M-j</code></dt><dd>等效于按下 <code>RET</code> 回车键后，自动插入并对齐注释 (<code>default-indent-new-line</code>)) ，相关说明见「<a href="#Multi_002dLine-Comments">多行注释</a>」章节。</dd>
<dt><code>M-x comment-region</code></dt><dd></dd>

<dt><code>C-c C-c（类 C 语言模式下的绑定快捷键）</code></dt><dd>为选区中的所有行添加注释定界符。</dd>
</dl>

<p>
用于创建注释或对齐注释的核心命令为 <code>M-;</code> (<code>comment-dwim</code>) 。其中 “dwim” 是英文 “Do What I Mean”（按我所想执行）的缩写，这意味着该命令会根据使用场景，自动适配完成与注释相关的多种操作。
</p>

<p>
当选区处于激活状态时， <code>M-;</code> 会自动判断为选区添加注释定界符，或移除已有注释的定界符：若选区中的所有行均已为注释行，则移除这些行的注释定界符以取消注释；反之，则添加注释定界符，将选区内的文本包裹为注释。
</p>

<p>
若在选区激活时为 <code>M-;</code> 添加前缀参数，该参数将指定要添加或删除的注释定界符数量：正整数参数 n 表示添加 n 个注释定界符，负整数参数 −n 表示删除 n 个注释定界符。
</p>

<p>
若选区未激活，且当前行无任何注释， <code>M-;</code> 会为当前行插入新注释：若当前行为空行（即无任何字符，或仅包含空白字符），则注释会缩进至按下 <code>TAB</code> 键后的对齐位置（参见「<a href="#Basic-Indent">基础程序缩进命令</a>」）；若当前行为非空行，注释会被放置在该行最后一个非空白字符之后。若条件允许，Emacs 会尝试将注释置于 <code>comment-column</code> 和 <code>comment-fill-column</code> 两个变量指定的列数范围内；若无法满足，则会选择其他合适的位置，且注释与非注释文本之间通常至少保留一个空格的间距。无论哪种情况，Emacs 都会将光标置于注释起始定界符之后，方便你直接输入注释内容。
</p>

<p>
你也可使用 <code>M-;</code> 对已有注释进行重新对齐：若当前行已包含注释起始定界符， <code>M-;</code> 会将注释重新对齐至规范位置，并将光标移至注释起始定界符之后。例外情况：从第 0 列开始的注释不会被移动。即便已有注释的对齐位置规范， <code>M-;</code> 仍可用于快速将光标跳至注释文本的起始位置。
</p>

<p>
<code>C-x C-;</code> (<code>comment-line</code>) 用于对整行进行添加 / 取消注释操作：选区激活时，对选区内所有行执行该操作；选区未激活时，仅对光标所在行执行。为该命令添加正整数前缀参数 <code>n</code> ，会对从当前行开始的连续 <code>n</code> 行执行操作；添加负整数参数 <code>−n</code> ，则对当前行之前的 <code>n</code> 行执行操作。若首次使用负参数调用该命令，后续使用正参数再次调用时，仍会对当前行之前的行执行操作，效果等同于参数被取反。
</p>

<p>
当选区未激活时， <code>C-u M-;</code> （带前缀参数的 <code>comment-dwim</code> 命令）会删除当前行的所有注释内容，同时删除注释前的空白字符。由于被删除的注释内容会被保存至删除环，你可在其他行通过以下操作恢复该注释：将光标移至目标行末尾，按下 <code>C-y</code> 粘贴注释内容，再按下 <code>M-;</code> 重新对齐注释即可。直接执行 <code>M-x comment-kill</code> 命令，可实现与 <code>C-u M-;</code> 完全相同的效果（当 <code>comment-dwim</code> 命令接收到前缀参数时，实际会调用 <code>comment-kill</code> 作为子例程执行）。若选区未激活，且为 <code>M-;</code> 添加数字前缀参数（如 <code>C-u n M-;</code> ），则会让 <code>comment-kill</code> 命令一次性删除从当前行开始的 <code>n</code> 行注释。
</p>

<p>
<code>M-x comment-region</code> 命令的效果，等同于在激活选区的情况下按下 <code>M-;</code> ，区别在于该命令始终作用于选区，即便标记点处于非激活状态。在 C 语言模式及相关派生模式中，该命令被绑定至快捷键 <code>C-c C-c</code> 。与之对应的 <code>M-x uncomment-region</code> 命令，用于为选区中的所有行取消注释；为其添加数字前缀参数，可指定要移除的注释定界符数量（负参数则表示要添加的注释定界符数量）。
</p>

<p>
对于类 C 语言模式，你可通过设置 <code>c-indent-comment-alist</code> 和 <code>c-indent-comments-syntactically-p</code> 变量，自定义 <code>M-;</code> 命令的具体执行效果。例如，在以右大括号结尾的行中， <code>M-;</code> 会将注释置于大括号后一个空格的位置，而非 <code>comment-column</code> 变量指定的列数。详细配置说明参见《CC 模式手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/ccmode/Comment-Commands.html#Comment-Commands">注释相关命令</a>」章节。
</p>
</div>
</div>
<div id="outline-container-Multi_002dLine-Comments" class="outline-4">
<h4 id="Multi_002dLine-Comments"><span class="section-number-4">28.5.2.</span> 多行注释</h4>
<div class="outline-text-4" id="text-Multi_002dLine-Comments">
<p>
若你正在输入注释并希望换行继续编写，可按下 <code>M-j</code> 或 <code>C-M-j</code> (<code>default-indent-new-line</code>) 。该操作会换行，并自动插入续写注释所需的注释定界符，同时完成相应的缩进。
</p>

<p>
对于使用闭合注释定界符的编程语言（例如 C 语言中的 '<code>*/</code>'）， <code>M-j</code> 命令的具体执行行为由 <code>comment-multi-line</code> 变量的值决定：若该变量设为 <code>nil</code> ，命令会先闭合上一行的注释，再在新行开启一个新注释；若为非nil值，则会在当前注释的定界符范围内直接换行续写。
</p>

<p>
当自动换行模式（Auto Fill mode）开启时，在输入注释的过程中，若内容超出换行列数，Emacs 也会自动续写注释，效果与手动按下 <code>M-j</code> 完全一致。
</p>

<p>
若要将已有的文本行转换为注释行，可激活选区后按下 <code>M-;</code> ，或使用上一节中介绍的 <code>M-x comment-region</code> 命令。
</p>

<p>
你可对 C 模式进行如下配置：在多行块注释中，若在行首键入 '<code>/</code>'，即可闭合该注释。只需为该功能启用 <code>comment-close-slash</code> 清理规则即可，详细说明参见《CC 模式手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/ccmode/Clean_002dups.html#Clean_002dups">清理规则</a>」章节。
</p>
</div>
</div>
<div id="outline-container-Options-for-Comments" class="outline-4">
<h4 id="Options-for-Comments"><span class="section-number-4">28.5.3.</span> 控制注释的相关选项</h4>
<div class="outline-text-4" id="text-Options-for-Comments">
<p>
正如<a href="#Comment-Commands">注释</a>相关命令章节所述，当 <code>M-j</code> 命令为某行添加注释时，会尝试将注释置于缓冲区局部变量 <code>comment-column</code> 和 <code>comment-fill-column</code> 所指定的列数区间内（若 <code>comment-fill-column</code> 值为 <code>nil</code> ，则使用 <code>fill-column</code> 的取值，参见<a href="#Fill-Commands">显式换行命令</a>章节）。你可通过常规方式为这些缓冲区局部变量设置局部值或默认值（参见<a href="#Locals">局部变量</a>章节）。此外，也可键入 <code>C-x ;</code> (<code>comment-set-column</code>) ，将当前缓冲区的 <code>comment-column</code> 值设为光标当前所在的列数。执行 <code>C-u C-x ;</code> 会将注释列数匹配为缓冲区中光标位置之前的最后一个注释的列数，随后执行 <code>M-;</code> 命令，将当前行的注释与上一个注释对齐。
</p>

<p>
注释相关命令通过变量 <code>comment-start-skip</code> 的取值（一个正则表达式）识别注释，需确保该正则表达式不会匹配空字符串。从严格意义上讲，它匹配的内容可多于注释起始定界符：例如在 C 模式中，该变量的取值可为 <code>"/\\*+[ \t]*\\|//+[ \t]*"</code> ，此表达式既会匹配 '<code>/*</code>' 后多余的星号和空白符，也支持 C++ 风格的 '<code>//</code>' 注释。（注意：在 Lisp 语法中，需用 '<code>\\</code>' 表示字符串中的单个 '<code>\</code>' ，以此取消正则表达式中第一个星号的特殊含义，参见<a href="#Regexp-Backslash">正则表达式中的反斜杠</a>章节。）
</p>

<p>
当注释命令新建注释时，会插入 <code>comment-start</code> 的取值作为注释起始定界符，同时在光标后插入 <code>comment-end</code> 的取值作为注释结束定界符。例如在 Lisp 模式中， <code>comment-start</code> 的取值为 <code>";"</code> ， <code>comment-end</code> 的取值为空字符串 <code>""</code> ；在 C 模式中， <code>comment-start</code> 为 <code>"/* "</code> ， <code>comment-end</code> 为 <code>" */"</code> 。
</p>

<p>
变量 <code>comment-padding</code> 指定注释命令在注释定界符与注释文本之间插入的字符串，默认值为 <code>" "</code> （单个空格）。该变量也可设为数字，表示插入对应数量的空格；若设为 <code>nil</code> ，则表示不插入任何空格。
</p>

<p>
变量 <code>comment-multi-line</code> 控制 <code>M-j</code> 命令和自动换行模式如何实现注释的多行续写，具体说明参见<a href="#Multi_002dLine-Comments">多行注释</a>章节。
</p>

<p>
变量 <code>comment-indent-function</code> 应指向一个函数，该函数用于计算新插入注释的对齐位置，或为已有注释重新计算对齐位置，不同的主模式会为其设置不同的函数。调用该函数时无需传入参数，调用时光标需位于注释起始位置；若为新建注释，则光标需位于行尾。该函数的返回值为注释应起始的列数，例如默认函数会根据已有注释的起始符数量来确定对齐位置。
</p>

<p>
Emacs 还会尝试将相邻行的注释对齐，若要取消该行为，上述函数可返回一个由两个整数（可相等）组成的点对，以此指定注释缩进的可接受范围。
</p>
</div>
</div>
</div>
<div id="outline-container-Documentation" class="outline-3">
<h3 id="Documentation"><span class="section-number-3">28.6.</span> 文档查阅</h3>
<div class="outline-text-3" id="text-Documentation">
<p>
Emacs 提供了多项功能，可用于查阅你计划在程序中使用的函数、变量和命令对应的文档。
</p>

<ul class="org-ul">
<li><a href="#Info-Lookup">Info 文档查阅</a></li>
<li><a href="#Man-Page">手册页查阅</a></li>
<li><a href="#Programming-Language-Doc">编程语言文档查阅</a></li>
</ul>
</div>
<div id="outline-container-Info-Lookup" class="outline-4">
<h4 id="Info-Lookup"><span class="section-number-4">28.6.1.</span> Info 文档查阅</h4>
<div class="outline-text-4" id="text-Info-Lookup">
<p>
对于对应编程语言的说明文档已收录在 Info 中的主模式，你可使用快捷键 <code>C-h S</code> (<code>info-lookup-symbol</code>) ，查阅程序中所用符号的 Info 说明文档。你需要在迷你缓冲区中指定待查询的符号，默认查询的是光标所在位置缓冲区中显示的符号。例如在 C 模式下，该命令会在《C 库手册》中检索目标符号。注意，该命令仅在对应的手册 Info 文件已完成安装时才能正常使用。
</p>

<p>
Emacs 会根据当前的主模式，确定符号文档的检索范围 —— 包括检索的 Info 文件及具体检索的索引项。你也可使用 <code>M-x info-lookup-file</code> 命令，查阅与文件名相关的说明文档。
</p>

<p>
若在不支持该功能的主模式中使用 <code>C-h S</code> ，Emacs 会提示你指定 <b>符号帮助模式</b> 。此时你需要输入一个支持 <code>C-h S</code> 功能的主模式对应命令，例如 <code>c-mode</code> 即可。
</p>
</div>
</div>
<div id="outline-container-Man-Page" class="outline-4">
<h4 id="Man-Page"><span class="section-number-4">28.6.2.</span> 手册页查阅</h4>
<div class="outline-text-4" id="text-Man-Page">
<p>
在 Unix 系统中，在线文档的主要形式为手册页（ <i>man page</i> ）。在 GNU 操作系统中，我们力求用组织结构更优的手册替代手册页，这类手册可通过 Info 工具浏览（参见<a href="#Misc-Help">其他帮助命令</a>章节）。该替代工作尚未完成，因此查阅手册页仍有实际用处。
</p>

<p>
你可以使用 <code>M-x man</code> 命令，查阅操作系统命令、库函数或系统调用对应的手册页。该命令会在迷你缓冲区中提示你输入查询主题，支持补全功能（参见<a href="#Completion">补全</a>章节），并调用 man 程序对对应的手册页进行格式化。若系统支持，该命令会以异步方式运行 <code>man</code> 程序，让你在手册页格式化的同时继续进行编辑操作。查阅结果会显示在名为 <code>*Man topic*</code> 的缓冲区中，这类缓冲区使用专属的主模式 ——手册模式（Man mode），该模式可便捷地实现翻页和跳转到其他手册页的操作。如需了解该模式的详细用法，可在手册模式缓冲区中键入 <code>C-h m</code> 查看。
</p>

<p>
每个手册页都归属于十个及以上的 <b>章节</b> ，各章节以单个数字或数字加字母命名。有时不同章节中会存在同名的手册页。若要查阅指定章节的手册页，可在 <code>M-x man</code> 命令提示输入主题时，键入‘topic(section)’或‘section topic’。例如，C 库函数 <code>chmod</code> 的手册页位于第 2 章节，而存在一个同名的 Shell 命令，其手册页在第 1 章节；若要查看前者，需键入 <code>M-x man RET chmod(2) RET</code> 。
</p>

<p>
若未指定章节， <code>M-x man</code> 命令默认仅显示找到的首个手册页。部分系统中，man 程序支持 '<code>-a</code>' 命令行选项，该选项可让程序显示指定主题的所有手册页。若要启用该功能，可将变量 <code>Man-switches</code> 的值修改为 <code>"-a"</code> 。设置完成后，在手册模式缓冲区中，你可键入 <code>M-n</code> 和 <code>M-p</code> 在不同章节的手册页间切换，模式行会显示当前可用的手册页总数。
</p>

<p>
默认情况下， <code>M-x man</code> 会以异步方式调用 man 程序。若要强制以同步方式执行，可将自定义变量 <code>Man-prefer-synchronous-call</code> 设为非nil值。
</p>

<p>
若用户选项 <code>Man-support-remote-systems</code> 为非nil值，且 <code>default-directory</code> 指向远程系统（参见<a href="#Remote-Files">远程文件</a>章节），则手册页会从该远程系统中获取。在调用 man 命令时添加前缀参数（如 <code>C-u M-x man</code> ），会临时反转本次调用中 <code>Man-support-remote-systems</code> 的取值。
</p>

<p>
查阅手册页的另一种方式是使用 <code>M-x woman</code> 命令。与 <code>M-x man</code> 不同，该命令不会调用任何外部程序来格式化和显示手册页，所有格式化操作均由 Emacs 自身完成，因此该命令可在 MS-Windows 等未安装 man 程序的系统中使用。该命令会提示你输入手册页名称，并将查阅结果显示在名为 <code>*WoMan section topic*</code> 的缓冲区中。
</p>

<p>
<code>M-x woman</code> 命令会在你首次调用时，计算手册页的补全列表。若添加数字前缀参数调用该命令，会重新计算补全列表 —— 当你新增或删除手册页时，该操作会十分实用。
</p>

<p>
若你输入的手册页名称在不同章节中存在多个同名手册页， <code>M-x woman</code> 会弹出一个窗口，列出所有候选手册页供你选择。
</p>

<p>
请注意， <code>M-x woman</code> 目前暂不支持现代手册页的最新特性，因此若你的系统中可使用 <code>M-x man</code> ，建议优先使用该命令。
</p>

<p>
关于 <code>M-x woman</code> 的配置和使用详情，可参考随 Emacs 一同分发的 WoMan Info 手册。
</p>
</div>
</div>
<div id="outline-container-Programming-Language-Doc" class="outline-4">
<h4 id="Programming-Language-Doc"><span class="section-number-4">28.6.3.</span> 编程语言文档查阅</h4>
<div class="outline-text-4" id="text-Programming-Language-Doc">
<p>
编辑 Emacs Lisp 代码时，可使用命令 <code>C-h f</code> (<code>describe-function</code>) 和 <code>C-h v</code> (<code>describe-variable</code>) ，查阅想要使用的 Lisp 函数与变量的内置文档，相关说明参见「<a href="#Name-Help">按命令或变量名获取帮助</a>」章节。
</p>

<p>
ElDoc<sup><a id="fnr.15" class="footref" href="#fn.15" role="doc-backlink">15</a></sup> 是一款缓冲区局部次要模式，可辅助查阅程序中各类符号（函数、方法、类、变量等）的文档。开启该模式后，只要光标所在位置存在带文档的符号，回显区就会显示相关实用信息。例如在 Emacs Lisp 模式的缓冲区中，光标置于函数处时，会显示该函数的参数列表；光标置于 Lisp 变量处时，会显示该变量文档字符串的首行内容。
</p>

<p>
键入 <code>M-x eldoc-mode</code> 可切换 ElDoc 模式的开关状态。Emacs 还提供全局 ElDoc 模式，该模式默认开启，会为所有主模式配置了下述相关变量的缓冲区，自动启用 ElDoc 模式；键入 <code>M-x global-eldoc-mode</code> 可在全局范围内关闭该模式。
</p>

<p>
各类主模式会对全局 ElDoc 模式进行配置，使其调用各自的文档查询函数，Emacs Lisp 模式、Python 模式、Cfengine 模式均属此类。此外，为多款主模式提供支持的 Emacs 功能，也会配置 ElDoc 调用其自身的文档检索工具，例如：基于语言服务器信息提供文档的 Eglot（参见《Eglot：Emacs LSP 客户端》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/eglot_html/Eglot-Features.html#Eglot-Features">Eglot 功能</a>」章节）、Semantic 插件的空闲摘要模式（参见《Semantic 手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/semantic/Idle-Summary-Mode.html#Idle-Summary-Mode">空闲摘要模式</a>」章节），以及通过 ElDoc 在光标处显示诊断信息的 Flymake（参见《GNU Flymake 手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/flymake/Finding-diagnostics.html#Finding-diagnostics">诊断信息查找</a>」章节）。
</p>

<p>
ElDoc 模式的工作机制为：当 Emacs 处于空闲状态并达到设定的短时间阈值后，会自动调取光标所在符号的可用文档并显示。这一设计可避免快速输入时，回显区或模式行的文档信息频繁闪烁，造成使用干扰。
</p>

<p>
你也可通过命令 <code>M-x eldoc-print-current-symbol-info</code> ，手动触发光标所在符号的文档显示。
</p>

<p>
可通过以下变量对 ElDoc 模式进行自定义配置：
</p>
<dl class="org-dl">
<dt><code>eldoc-idle-delay</code></dt><dd>该用户选项用于控制光标处文档的空闲显示延迟时间，取值为等待的秒数，设为 0 表示无延迟即时显示，默认值为 0.5 秒。</dd>
<dt><code>eldoc-print-after-edit</code></dt><dd>若该用户选项设为非 nil 值，ElDoc 仅会在执行插入、删除文本等编辑命令后显示文档。若你希望 Emacs 仅为手动键入的符号显示文档，而非缓冲区中已存在的符号（即仅阅读源代码时不显示文档），该配置会非常实用；默认值为 <code>nil</code> 。修改该变量的值后，需先关闭再重新开启 <code>eldoc-mode</code> ，配置方可生效。</dd>
<dt><code>eldoc-echo-area-use-multiline-p</code></dt><dd><p>
该用户选项用于控制：当文档文本长度超过回显区单行可显示范围时，是否截断及如何截断文档。
取值为正数时，指定 ElDoc 在回显区中可无截断显示文档的屏幕行数；正整数表示绝对最大行数，浮点数表示占帧高度的比例。
</p>

<p>
取值为 <code>t</code> 时，表示永不截断文档（回显区会自动调整高度，最大不超过 <code>max-mini-window-height</code> 限定的高度，参见「迷你缓冲区中的编辑」章节）。
</p>

<p>
取值为 <code>nil</code> 时，表示若文档超过单行长度则直接截断。
</p>

<p>
特殊取值 <code>truncate-sym-name-if-fit</code> （默认值）：若截断符号名部分即可让文档完整显示在单行中，则仅截断符号名。
</p></dd>

<dt><code>eldoc-echo-area-display-truncation-message</code></dt><dd>若设为非 nil 值（默认），当回显区显示的文档因过长被截断时，会在文档末尾附上完整文档的查看指引；若设为 <code>nil</code> ，则仅用省略号…标识文档已被截断。</dd>
<dt><code>eldoc-echo-area-prefer-doc-buffer</code></dt><dd><p>
该用户选项的取值决定回显区与 ElDoc 专属文档缓冲区的显示优先级：
</p>

<p>
取值为 <code>t</code> 时，若承载该文档的 ElDoc 缓冲区已在任意窗口中显示，则不在回显区重复显示（可随时通过 <code>M-x eldoc-doc-buffer</code> 命令调出 ElDoc 文档缓冲区）。
</p>

<p>
取值为符号 <code>maybe</code> 时，若 ElDoc 缓冲区已显示，且文档在回显区中显示需要截断，则不在回显区显示。
</p>

<p>
取值为 <code>nil</code> （默认）时，始终在回显区显示文档。
</p></dd>
<dt><code>eldoc-documentation-strategy</code></dt><dd>该可自定义变量的取值为一个函数，该函数负责检索并显示光标所在符号的文档，文档内容由钩子 <code>eldoc-documentation-functions</code> 中的函数生成。该变量的默认值指定：ElDoc 仅显示 <code>eldoc-documentation-functions</code> 钩子中第一个函数生成的文档文本；你可自定义该变量，实现其他展示逻辑，例如将所有函数生成的文档文本拼接后完整显示。</dd>
<dt><code>eldoc-documentation-functions</code></dt><dd>这是一个异常钩子，其取值为函数列表，这些函数可根据当前缓冲区的主模式，为光标所在符号生成对应的文档，是 ElDoc 的底层文档检索后端集合。各类主模式会将自身的文档查询函数添加至该变量的缓冲区局部值中，完成与 ElDoc 的注册对接。</dd>
</dl>
</div>
</div>
</div>
<div id="outline-container-Hideshow" class="outline-3">
<h3 id="Hideshow"><span class="section-number-3">28.7.</span> 代码折叠次模式</h3>
<div class="outline-text-3" id="text-Hideshow">
<p>
Hideshow mode代码折叠模式是一款缓冲区局部次要模式，支持你选择性地显示程序中的代码段（这类代码段被称作 <i>blocks 代码块</i> ）。键入 <code>M-x hs-minor-mode</code> 可切换该次要模式的开关状态（参见「<a href="#Minor-Modes">次要模式</a>」章节）。
</p>

<p>
使用代码折叠模式隐藏某一代码块时，该代码块会从屏幕中消失，取而代之的是一个省略号（连续三个句点）。代码块的判定规则由当前主模式决定：在 C 模式及相关派生模式中，代码块以大括号为分隔符；在 Lisp 模式中，代码块以圆括号为分隔符， <b>多行注释也会被视作代码块</b> 。
</p>

<p>
代码折叠模式提供以下操作命令：
</p>
<dl class="org-dl">
<dt><code>C-c @ C-h</code></dt><dd></dd>

<dt><code>C-c @ C-d</code></dt><dd>隐藏当前代码块 (<code>hs-hide-block</code>) 。</dd>
<dt><code>C-c @ C-s</code></dt><dd>显示当前代码块 (<code>hs-show-block</code>) 。</dd>
<dt><code>C-c @ C-c</code></dt><dd></dd>

<dt><code>C-c @ C-e</code></dt><dd></dd>

<dt><code>S-mouse-2</code></dt><dd>切换当前代码块的显示状态（隐藏 / 显示） (<code>hs-toggle-hiding</code>) 。</dd>
<dt><code>C-c @ C-M-h</code></dt><dd></dd>

<dt><code>C-c @ C-t</code></dt><dd>隐藏所有顶层代码块 (<code>hs-hide-all</code>) 。</dd>
<dt><code>C-c @ C-M-s</code></dt><dd></dd>

<dt><code>C-c @ C-a</code></dt><dd>显示缓冲区中的所有代码块 (<code>hs-show-all</code>) 。</dd>
<dt><code>C-u n C-c @ C-l</code></dt><dd>隐藏当前代码块下第 n 层的所有代码块 (<code>hs-hide-level</code>) 。</dd>
</dl>

<p>
可通过以下变量自定义代码折叠模式的行为：
</p>

<dl class="org-dl">
<dt><code>hs-hide-comments-when-hiding-all</code></dt><dd>若设为非nil值，执行 <code>C-c @ C-M-h</code> (<code>hs-hide-all</code>) 时会同时隐藏注释内容。</dd>

<dt><code>hs-isearch-open</code></dt><dd>该变量用于指定增量搜索的匹配文本出现在隐藏代码块内时，解隐藏该代码块的触发条件。其取值可选：code（仅解隐藏代码块）、comment（仅解隐藏注释块）、t（同时解隐藏代码块和注释块）、nil（均不解隐藏），默认值为code。</dd>
</dl>
</div>
</div>
<div id="outline-container-Symbol-Completion" class="outline-3">
<h3 id="Symbol-Completion"><span class="section-number-3">28.8.</span> 符号名称补全</h3>
<div class="outline-text-3" id="text-Symbol-Completion">
<p>
补全功能通常在迷你缓冲区中使用（参见「<a href="#Completion">补全</a>」章节），但你也可在 Emacs 普通缓冲区中完成符号名的补全操作。
</p>

<p>
在大多数编程语言模式下，按下 <code>C-M-i</code> （或 <code>M-TAB</code> <sup><a id="fnr.16" class="footref" href="#fn.16" role="doc-backlink">16</a></sup>）会调用 <code>completion-at-point</code> 命令，该命令会为光标所在位置的符号生成所有可能的补全候选列表。此命令会调用各类可用的支持工具来生成补全候选，优先级规则如下：
</p>

<ul class="org-ul">
<li>若当前缓冲区所属项目及主模式已激活 Eglot 功能（参见「<a href="#Projects">项目操作</a>」章节），该命令会尝试调用对应的语言服务器生成补全候选列表（参见《Eglot：Emacs LSP 客户端》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/eglot_html/Eglot-Features.html#Eglot-Features">Eglot 功能</a>」章节）；</li>

<li>若已启用 Semantic 模式（参见「<a href="#Semantic">Semantic 语义分析</a>」章节），该命令会尝试使用 Semantic 解析器的数据分析结果进行补全；</li>

<li>若未启用 Semantic 模式，或该模式补全失败，命令会尝试通过已选中的标签表进行补全（参见「<a href="#Tags-Tables">标签表</a>」章节）—— 需先执行 <code>M-x visit-tags-table</code> 命令加载标签表，此功能方可生效；</li>

<li>在 Emacs Lisp 模式下，该命令会利用当前 Emacs 会话中已定义的函数、变量或属性名完成补全。</li>
</ul>

<p>
除上述规则外，缓冲区中的符号补全行为与迷你缓冲区补全完全一致。例如，若 Emacs 无法补全为唯一的符号，会在另一个窗口中显示所有补全候选选项。此时你可按下 <code>M-DOWN</code> 和 <code>M-UP</code> ，在不离开原缓冲区的前提下，浏览补全缓冲区中的候选内容；按下 <code>M-RET</code> ，即可将当前高亮的补全项插入原缓冲区（详见「<a href="#Completion">补全</a>」章节）。
</p>

<p>
在文本模式及相关派生模式中，按下 <code>M-TAB</code> 会基于拼写检查器的词典完成单词补全（参见「<a href="#Spelling">拼写检查与修正</a>」章节）。
</p>

<p>
补全预览模式是一款次要模式，可在你输入的同时实时显示补全建议。执行 <code>M-x completion-preview-mode</code> 可在当前缓冲区启用该模式，执行 <code>M-x global-completion-preview-mode</code> 则可在全局启用。开启补全预览模式后，Emacs 会在光标后方以 <b>行内预览</b> 的形式，自动显示光标附近文本的推荐补全内容；按下 <code>TAB</code> 键即可确认并插入该补全建议。
</p>
</div>
</div>
<div id="outline-container-MixedCase-Words" class="outline-3">
<h3 id="MixedCase-Words"><span class="section-number-3">28.9.</span> 混合大小写单词处理</h3>
<div class="outline-text-3" id="text-MixedCase-Words">
<p>
部分编程风格会使用混合大小写（即 “驼峰式”）的符号，例如 'unReadableSymbol' 。（在 GNU 项目中，我们建议在标识符中使用下划线分隔单词，而非通过大小写区分。）Emacs 提供了多种功能，方便处理这类符号。
</p>

<p>
Glasses 模式是一款缓冲区局部次要模式，它通过修改混合大小写符号的显示方式，提升其可读性。默认情况下，该模式会在小写字母与后续的大写字母之间，显示额外的下划线作为分隔。此操作仅改变符号的显示效果，不会修改缓冲区中的实际文本内容。
</p>

<p>
键入 <code>M-x glasses-mode</code> 可切换 Glasses 模式的开关状态（参见「<a href="#Minor-Modes">次要模式</a>」章节）。开启该模式后，模式行会出现次要模式标识 '<code>o^o</code>' 。如需了解 Glasses 模式的更多信息，可键入 <code>C-h P glasses RET</code> 查阅。
</p>

<p>
子词模式（Subword mode）是另一款缓冲区局部次要模式。开启该模式后，Emacs 的各类单词操作命令会将驼峰式标识符（如 'StudlyCapsIdentifiers' ）中的大写字母识别为单词边界。启用子词模式后，模式行会显示次要模式标识,。你也可参考功能类似的超词模式（superword-mode）（参见「<a href="#Misc-for-Programs">程序编辑的其他实用功能</a>」章节）。
</p>
</div>
</div>
<div id="outline-container-Semantic" class="outline-3">
<h3 id="Semantic"><span class="section-number-3">28.10.</span> 语义分析（Semantic）</h3>
<div class="outline-text-3" id="text-Semantic">
<p>
Semantic 是一个基于源代码解析器、提供 <b>语言感知型编辑命令</b> 的扩展包。本节仅对其做简要介绍，完整详情请参见《Semantic 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/semantic/index.html#Top">语义分析</a>章节。
</p>

<p>
Emacs 中大部分语言感知功能（如语法高亮模式），均依赖于经验性规则<sup><a id="fnr.17" class="footref" href="#fn.17" role="doc-backlink">17</a></sup> 实现 —— 这类规则通常能达到较好效果，但始终无法做到完全精准。与之不同的是，Semantic 所使用的解析器能 <b>精准解析编程语言的语法规则</b> ，这让它可以提供功能强大且结果精准的搜索、导航与补全命令。
</p>

<p>
要开始使用 Semantic，可键入 <code>M-x semantic-mode</code> ，或在「Tools」菜单中点击「Source Code Parsers (Semantic)」选项，即可启用Semantic 模式（一款全局次要模式）。
</p>

<p>
启用 Semantic 模式后，Emacs 会自动尝试解析你打开的每一个文件。目前 Semantic 支持解析的语言包括：C、C++、HTML、Java、JavaScript、Make、Python、Scheme、SRecode 以及 Texinfo。在所有已完成解析的缓冲区中，可使用以下命令：
</p>

<dl class="org-dl">
<dt><code>C-c , j</code></dt><dd>提示输入当前文件中定义的函数名，并将光标跳转到该函数处 (<code>semantic-complete-jump-local</code>) 。</dd>
<dt><code>C-c , J</code></dt><dd>提示输入 Emacs 已解析的任意文件中定义的函数名，并将光标跳转到该函数处 (<code>semantic-complete-jump</code>) 。</dd>
<dt><code>C-c , SPC</code></dt><dd>为光标所在位置的符号显示所有可能的补全候选列表 (<code>semantic-complete-analyze-inline</code>) 。该命令还会激活一套用于选择补全项的专用快捷键：按下 <code>RET</code> 回车键确认当前补全项， <code>M-n</code> 和 <code>M-p</code> 循环切换补全候选，制表键（ <code>TAB</code> ）先完成最大程度的自动补全再循环候选， <code>C-g</code> 或其他任意按键则终止补全操作。</dd>
<dt><code>C-c , l</code></dt><dd>在新窗口中显示光标所在位置符号的所有补全候选列表 (<code>semantic-analyze-possible-completions</code>) 。</dd>
</dl>

<p>
除上述命令外，Semantic 扩展包还提供了多种利用解析器信息的方式，例如可配置为 Emacs 空闲时自动显示符号补全列表。相关详情请参见《Semantic 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/semantic/index.html#Top">语义分析</a>章节。
</p>
</div>
</div>
<div id="outline-container-Misc-for-Programs" class="outline-3">
<h3 id="Misc-for-Programs"><span class="section-number-3">28.11.</span> 其他程序编辑实用功能</h3>
<div class="outline-text-3" id="text-Misc-for-Programs">
<p>
部分并非专为程序编辑设计的 Emacs 命令，在编写代码时同样能发挥实用价值。
</p>

<p>
Emacs 中用于操作单词、句子和段落的命令，均可用于代码编辑。多数符号名中包含多个语义单词（参见「<a href="#Words">单词操作</a>」章节），而字符串与注释中则会出现完整的句子（参见「<a href="#Sentences">句子操作</a>」章节）。至于段落，大多数编程语言模式中都将空行定义为段落的起止边界（参见「<a href="#Paragraphs">段落操作</a>」章节）。因此，合理使用空行让程序代码的结构更清晰，同时也能为段落操作命令划分出便于处理的文本块。若在编程语言主模式中启用了自动换行模式，该模式会为其自动换行生成的新行完成缩进。
</p>

<p>
超词模式（Superword mode）是一款缓冲区局部次要模式，启用后，编辑与光标移动类命令会将编程符号（例如 <code>this_is_a_symbol</code> ）视作单个单词处理。开启该模式后，模式行会显示次要模式标识 ‘²’。相关可参考功能类似的子词模式（参见「<a href="#MixedCase-Words">混合大小写单词</a>」章节）。
</p>

<p>
快速排版模式（Electric Layout mode）（ <code>M-x electric-layout-mode</code> ）是一款全局次要模式，键入特定字符时会自动插入换行符；例如在 JavaScript 模式中，键入‘{’、‘}’和;时会触发该自动换行行为。
</p>

<p>
除代码折叠模式外（参见「<a href="#Hideshow">代码折叠次要模式</a>」章节），另一类选择性显示程序代码片段的方式是使用选择性显示功能（参见「<a href="#Selective-Display">选择性显示</a>」章节）。编程相关模式通常还支持大纲次要模式（参见「<a href="#Outline-Mode">大纲模式</a>」章节），该模式可与 Foldout 扩展包配合使用（参见「<a href="#Foldout">折叠编辑</a>」章节）。
</p>

<p>
符号美化模式（Prettify Symbols mode）是一款缓冲区局部次要模式，会将特定字符串替换为视觉上更美观的形式显示， <b>不会修改缓冲区实际文本</b> 。例如在 Emacs Lisp 模式中，该模式会将字符串 ‘lambda’ 替换为希腊字母 ‘λ’ 显示；在 TeX 缓冲区中，会将 '<code>\alpha ... \omega</code>' 等数学宏命令替换为对应的 Unicode 字符显示。该模式同样可在非编程模式中启用。你可通过向 <code>prettify-symbols-alist</code> 变量中添加更多配置项，自定义该模式的替换规则；若默认的判定函数 <code>prettify-symbols-default-compose-p</code> 无法满足需求，还可通过自定义 <code>prettify-symbols-compose-predicate</code> 实现更复杂的配置。该模式也提供全局版本 <code>global-prettify-symbols-mode</code> ，可在所有支持该模式的缓冲区中启用。
</p>

<p>
光标所在位置的符号可强制显示其原始形式，该功能由变量 <code>prettify-symbols-unprettify-at-point</code> 控制：若设为非nil值，只要光标停留在某符号处，该符号就会恢复为原始形式显示。
</p>
</div>
</div>
<div id="outline-container-C-Modes" class="outline-3">
<h3 id="C-Modes"><span class="section-number-3">28.12.</span> C 语言及相关模式</h3>
<div class="outline-text-3" id="text-C-Modes">
<p>
本节简要介绍 C、C++、Objective-C、Java、CORBA 接口定义语言（IDL）、Pike 及 AWK 模式中提供的专属功能（这些模式统称C 语言及相关模式）。更多详细内容，可参阅随 Emacs 一同分发的 CC 模式 Info 手册。
</p>

<ul class="org-ul">
<li><a href="#Motion-in-C">C 模式移动命令</a></li>
<li><a href="#Electric-C">C 语言自动缩进字符</a></li>
<li><a href="#Hungry-Delete">C 模式中的贪婪删除功能</a></li>
<li><a href="#Other-C-Commands">C 模式的其他命令</a></li>
</ul>
</div>
<div id="outline-container-Motion-in-C" class="outline-4">
<h4 id="Motion-in-C"><span class="section-number-4">28.12.1.</span> C 模式移动命令</h4>
<div class="outline-text-4" id="text-Motion-in-C">
<p>
本节介绍 C 模式及相关模式中用于移动光标的专属命令。
</p>

<dl class="org-dl">
<dt><code>C-M-a</code></dt><dd></dd>

<dt><code>C-M-e</code></dt><dd>将光标移至当前函数或顶层定义的起始 / 结束位置。在存在嵌套作用域的语言中（如 C++ 的类），「当前函数」指直接包含光标的函数（可位于某一作用域内）；其他情况下，指由最内层闭合大括号定义的函数。（与之不同的是， <code>beginning-of-defun</code> 和 <code>end-of-defun</code> 命令会仅检索位于第 0 列的大括号。）参见「<a href="#Moving-by-Defuns">按函数单元移动</a>」章节。</dd>
<dt><code>C-c C-u</code></dt><dd><p>
将光标回退至包含当前位置的预处理条件编译块处，同时在原位置留下标记。前缀参数表示重复执行次数；若为负参数，则将光标前移至该预处理条件编译块的结束位置。
</p>

<p>
‘#elif’ 等效于 ‘#else’ 后紧跟 ‘#if’，因此该命令回退时会在 ‘#elif’ 处停止，前移时则不会。
</p></dd>
<dt><code>C-c C-p</code></dt><dd>将光标回退过一个预处理条件编译块，同时在原位置留下标记。前缀参数表示重复执行次数；若为负参数，则执行前移操作。</dd>
<dt><code>C-c C-n</code></dt><dd>将光标前移过一个预处理条件编译块，同时在原位置留下标记。前缀参数表示重复执行次数；若为负参数，则执行回退操作。</dd>
<dt><code>M-a</code></dt><dd><p>
将光标移至最内层 C 语句的起始位置 (<code>c-beginning-of-statement</code>) 。若光标已位于某语句起始处，则移至上一条语句的起始位置。带前缀参数 <code>n</code> 时，回退过 <code>n-1</code> 条语句。
</p>

<p>
若光标处于跨多行的注释或字符串内，该命令会按句子而非语句进行移动。
</p></dd>
<dt><code>M-e</code></dt><dd>将光标移至最内层 C 语句或句子的结束位置；功能与 <code>M-a</code> 一致，仅移动方向相反 (<code>c-end-of-statement</code>) 。</dd>
</dl>
</div>
</div>
<div id="outline-container-Electric-C" class="outline-4">
<h4 id="Electric-C"><span class="section-number-4">28.12.2.</span> C 语言自动缩进字符</h4>
<div class="outline-text-4" id="text-Electric-C">
<p>
在 C 模式及相关模式中，部分可打印字符为 <i>电动electric</i> 字符—— 这类字符被键入时，除自身插入到文本中外，还会对当前行重新进行缩进，亦可根据设置自动插入换行符。电动字符包含： { 、}、:、#、;、,、&lt;、&gt;、/、*、(、)。
</p>

<p>
若你编辑的代码缩进格式混乱，电动缩进功能可能会带来不便；对于初次使用 CC 模式的用户，该功能也可能让人感到不适。你可通过命令 <code>C-c C-l</code> 切换电动功能的开关状态：功能启用时，模式行的模式名称后方会显示标识 ‘/cl’ （其中字符 c 若存在，会根据注释风格显示为 ‘*’ 或 ‘/’，分别对应块注释和行注释）。关于 CC 模式下模式行的各类标识说明，详见《CC 模式手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/ccmode/Minor-Modes.html#Minor-Modes">次要模式</a>」章节。
</p>

<dl class="org-dl">
<dt><code>C-c C-l</code></dt><dd>切换电动功能的启用状态 (<code>c-toggle-electric-state</code>) 。带正前缀参数时启用该功能，带负前缀参数时禁用。</dd>
</dl>

<p>
电动字符仅在电动功能开启，且自动换行功能同时启用的情况下，才会触发自动插入换行符的行为（该状态下模式行的模式名称后方会显示标识 ‘/cla’）。你可通过命令 <code>C-c C-a</code> 开关该功能：
</p>

<dl class="org-dl">
<dt><code>C-c C-a</code></dt><dd>切换自动换行功能的启用状态 (<code>c-toggle-auto-newline</code>) 。带前缀参数时，正参数启用该功能，负参数禁用。</dd>
</dl>

<p>
CC 模式的风格配置通常会定义 Emacs 触发自动换行的具体场景，你也可直接对该行为进行自定义配置，详见《CC 模式手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/ccmode/Custom-Auto_002dnewlines.html#Custom-Auto_002dnewlines">自定义自动换行</a>」章节。
</p>
</div>
</div>
<div id="outline-container-Hungry-Delete" class="outline-4">
<h4 id="Hungry-Delete"><span class="section-number-4">28.12.3.</span> C 模式中的贪婪删除功能</h4>
<div class="outline-text-4" id="text-Hungry-Delete">
<p>
若需删除光标位置处的整段空白字符，可使用 <b>hungry deletion贪婪删除</b> 功能。该功能能通过单次操作，删除光标前或光标后的所有连续空白字符。此处的空白字符包含制表符和换行符，但不包含注释或预处理命令。
</p>

<dl class="org-dl">
<dt><code>C-c C-DEL</code></dt><dd></dd>

<dt><code>C-c DEL</code></dt><dd>删除光标前方的整段空白字符 (<code>c-hungry-delete-backwards</code>) 。</dd>
<dt><code>C-c C-d</code></dt><dd></dd>

<dt><code>C-c C-Delete</code></dt><dd></dd>

<dt><code>C-c Delete</code></dt><dd>删除光标后方的整段空白字符 (<code>c-hungry-delete-forward</code>) 。</dd>
</dl>

<p>
除上述命令外，你也可以启用 <i>hungry delete</i> 模式。该功能启用后，模式行的模式名称后方会在/后显示标识 ‘h’ ；此时按下单次删除键（ <code>DEL</code> ）会删除前方所有空白字符，而非仅单个空格；按下单次 <code>C-d</code> 键（普通 <code>Delete</code> 键无此效果）会删除后方所有空白字符。
</p>

<dl class="org-dl">
<dt><code>M-x c-toggle-hungry-state</code></dt><dd>切换贪婪删除功能的启用状态 (<code>c-toggle-hungry-state</code>) 。带前缀参数时，正参数启用该功能，负参数禁用该功能。</dd>
</dl>

<p>
变量 <code>c-hungry-delete-key</code> 用于控制贪婪删除功能的启用状态。
</p>
</div>
</div>
<div id="outline-container-Other-C-Commands" class="outline-4">
<h4 id="Other-C-Commands"><span class="section-number-4">28.12.4.</span> C 模式的其他命令</h4>
<div class="outline-text-4" id="text-Other-C-Commands">
<dl class="org-dl">
<dt><code>M-x c-context-line-break</code></dt><dd><p>
插入换行符，并根据上下文对新行进行适配性缩进。在普通代码中，该命令的作用等同于回车键（ <code>RET</code> ）；在 C 预处理行中，会在换行处额外插入一个反斜杠 '<code>\</code>' ；在注释内时，效果与 <code>M-j</code> (<code>c-indent-new-comment-line</code>) 一致。
</p>

<p>
该命令默认未绑定快捷键，需手动绑定才能便捷使用。以下代码可将其绑定至回车键，代码中使用 <code>c-initialization-hook</code> 钩子，确保在修改键映射前该映射已完成加载：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">
</pre>
</div></dd>
</dl>
<p>
(defun my-bind-clb ()
  (keymap-set c-mode-base-map "RET"
              'c-context-line-break))
(add-hook 'c-initialization-hook 'my-bind-clb)
</p>

<dl class="org-dl">
<dt><code>C-M-h</code></dt><dd>将标记点置于函数定义的末尾，光标置于函数定义的开头 (<code>c-mark-function 命令，选中整个函数</code>) 。</dd>
<dt><code>M-q</code></dt><dd>对段落进行自动换行，专门适配 C 和 C++ 注释格式 (<code>c-fill-paragraph</code>) 。若当前行的任意部分属于注释或处于注释内，该命令会对光标所在的注释段 / 注释内段落进行换行处理，同时保留注释的缩进格式与注释定界符。</dd>
<dt><code>C-c C-e</code></dt><dd><p>
对选区内的文本执行 C 预处理器处理，并展示处理结果，其中包含所有宏调用的展开内容 (<code>c-macro-expand</code>) 。为兼容宏的定义位置，选区之前的缓冲区文本也会参与预处理，但这部分内容的处理结果不会展示。
</p>

<p>
调试使用了宏的 C 代码时，有时难以准确分析宏的展开逻辑，使用该命令可直接查看宏的展开结果，无需手动推导。
</p></dd>
<dt><code>C-c C-\</code></dt><dd><p>
在选区的各行末尾插入或对齐反斜杠 '<code>\</code>' (<code>c-backslash-region</code>) ，编写或编辑 C 宏定义后，该命令会非常实用。
</p>

<p>
若某行末尾已存在反斜杠 '<code>\</code>' ，该命令会调整其前方的空白字符数量以实现对齐；若不存在，则插入一个新的反斜杠 '<code>\</code>' 。特殊规则：选区的最后一行会被特殊处理，该行不会插入反斜杠 '<code>\</code>' ，若已有则会被删除。
</p></dd>

<dt><code>M-x cpp-highlight-buffer</code></dt><dd>根据预处理条件编译指令，对文本不同部分进行高亮标记。该命令会打开一个名为 <code>*CPP Edit*</code> 的缓冲区，作为图形化菜单，可在其中选择特定类型的条件编译指令及其内容的展示方式。完成各项设置后，点击 ‘[A]pply these settings’（或切换至该缓冲区并按下 <code>a</code> 键），C 模式缓冲区会根据设置重新高亮。</dd>

<dt><code>C-c C-s</code></dt><dd>展示当前源代码行的语法结构信息 (<code>c-show-syntactic-information</code>)，这些信息是该行缩进规则的判定依据。</dd>
<dt><code>M-x cwarn-mode</code></dt><dd></dd>

<dt><code>M-x global-cwarn-mode</code></dt><dd><p>
CWarn 次要模式会对 C 和 C++ 中部分可疑的代码写法进行高亮提醒，包括：
</p>
<ul class="org-ul">
<li>表达式内部的赋值操作；</li>
<li>if、for、while语句后紧跟分号（‘do … while’语句除外）；</li>
<li>包含引用参数的 C++ 函数。</li>
</ul>

<p>
可通过 <code>M-x cwarn-mode</code> 命令为单个缓冲区启用该模式，或通过 <code>M-x global-cwarn-mode</code> 命令、自定义 <code>global-cwarn-mode</code> 变量，为所有适配的缓冲区全局启用。注意：该模式生效的前提是已启用语法高亮模式（Font Lock mode）。
</p></dd>

<dt><code>M-x hide-ifdef-mode</code></dt><dd>Hide-ifdef 次要模式会隐藏 ‘#if’ 和 ‘#ifdef’ 预处理块中选定的代码。若将变量 <code>hide-ifdef-shadow</code> 设为 <code>t</code> ，该模式不会完全隐藏预处理块，而是将其以低醒目度的字体样式显示（虚显）。更多信息可查阅该模式的文档字符串。</dd>
<dt><code>M-x ff-find-related-file</code></dt><dd>查找与当前缓冲区所打开文件存在特定关联的文件，通常为 C/C++ 源文件对应的头文件，或头文件对应的源文件。变量 <code>ff-related-file-alist</code> 定义了关联文件名的匹配规则。</dd>
</dl>
</div>
</div>
</div>
<div id="outline-container-Asm-Mode" class="outline-3">
<h3 id="Asm-Mode"><span class="section-number-3">28.13.</span> 汇编语言模式</h3>
<div class="outline-text-3" id="text-Asm-Mode">
<p>
Asm mode汇编模式是用于编辑汇编代码文件的主模式，该模式定义了以下命令：
</p>
<dl class="org-dl">
<dt><code>TAB</code></dt><dd>按制表位缩进。</dd>
<dt><code>C-j</code></dt><dd>插入换行符，随后 <code>tab-to-tab-stop</code> 缩进。</dd>
<dt><code>:</code></dt><dd>插入冒号，接着移除冒号前方标签的前置缩进，然后 <code>tab-to-tab-stop</code> 。</dd>
<dt><code>;</code></dt><dd>插入注释或对齐已有注释。</dd>
</dl>

<p>
变量 <code>asm-comment-char</code> 用于指定汇编语法中作为注释起始符的字符。
</p>
</div>
</div>
<div id="outline-container-Fortran" class="outline-3">
<h3 id="Fortran"><span class="section-number-3">28.14.</span> Fortran 模式</h3>
<div class="outline-text-3" id="text-Fortran">
<p>
Fortran 模式适用于编辑 <b>固定格式（及制表符格式）</b> 的源代码（通常为 Fortran 77）。若要编辑更现代的自由格式源代码（Fortran 90、95、2003、2008），请使用 F90 模式（ <code>f90-mode</code> ）。Emacs 默认对扩展名为‘.f’、‘.F’ 或‘.for’ 的文件启用 Fortran 模式，对扩展名为‘.f90’、‘.f95’、‘.f03’ 和‘.f08’ 的文件启用 F90 模式。可自定义 <code>auto-mode-alist</code> 变量添加更多关联扩展名。GNU Fortran 同时支持自由格式与固定格式。本手册主要介绍 Fortran 模式，相关的 F90 模式功能会在对应场景下提及。
</p>

<p>
Fortran 模式为 Fortran 语句和子程序提供了专属的光标移动命令，其缩进命令可识别 Fortran 的嵌套规则、行号及续行约定。该模式对自动换行模式提供适配支持，可将过长的代码行拆分为符合 Fortran 规范的续行；同时也支持代码折叠次要模式（参见<a href="#Hideshow">代码折叠次要模式</a>章节）和索引菜单功能（参见<a href="#Imenu">索引菜单</a>章节）。
</p>

<p>
由于 Fortran 的注释规则与其他编程语言不同，该模式提供了注释专属操作命令；内置的缩写功能可按需减少你输入 Fortran 关键字的工作量。
</p>

<p>
键入 <code>M-x fortran-mode</code> 可切换至该主模式，该命令会执行 <code>fortran-mode-hook</code> 钩子函数（参见<a href="#Hooks">钩子</a>章节）。
</p>

<ul class="org-ul">
<li><a href="#Fortran-Motion">移动命令</a></li>
<li><a href="#Fortran-Indent">Fortran 缩进</a></li>
<li><a href="#Fortran-Comments">Fortran 注释</a></li>
<li><a href="#Fortran-Autofill">Fortran 模式下的自动填充</a></li>
<li><a href="#Fortran-Columns">Fortran 列检查</a></li>
<li><a href="#Fortran-Abbrev">Fortran 关键字缩写</a></li>
</ul>
</div>
<div id="outline-container-Fortran-Motion" class="outline-4">
<h4 id="Fortran-Motion"><span class="section-number-4">28.14.1.</span> 移动命令</h4>
<div class="outline-text-4" id="text-Fortran-Motion">
<p>
除了按函数单元移动和操作的常规命令（Fortran 子程序 —— 包含函数、子例程，F90 模式还包含模块，对应命令为 <code>fortran-end-of-subprogram</code> 和 <code>fortran-beginning-of-subprogram</code> ）外，Fortran 模式还提供了按语句及其他程序单元移动的专属命令。
</p>

<dl class="org-dl">
<dt><code>C-c C-n</code></dt><dd>移至下一条语句的起始位置 (<code>fortran-next-statement</code> / <code>f90-next-statement</code> 命令）。</dd>
<dt><code>C-c C-p</code></dt><dd>移至上一条语句的起始位置 (<code>fortran-previous-statement</code> / <code>f90-previous-statement</code> 命令）。若不存在上一条语句（即从缓冲区的第一条语句处调用该命令），则移至缓冲区起始位置。</dd>
<dt><code>C-c C-e</code></dt><dd>将光标向前移至下一个代码块的起始位置，或当前代码块的结束位置（以先到达者为准）（执行 <code>f90-next-block</code> 命令）。代码块包括子例程、 <code>if–endif</code> 语句等。该命令仅适用于 F90 模式，不适用于 Fortran 模式。带数字前缀参数时，向前移动指定数量的代码块。</dd>
<dt><code>C-c C-a</code></dt><dd>将光标向后移至上一个代码块的位置 (<code>f90-previous-block</code>)。功能与 <code>f90-next-block</code> 一致，仅移动方向相反。</dd>
<dt><code>C-M-n</code></dt><dd>移至当前代码块的结束位置 (<code>fortran-end-of-block</code> / <code>f90-end-of-block</code>) 。带数字前缀参数时，向前移动指定数量的代码块。移动光标前会先设置标记。该命令的 F90 模式版本会检查代码块类型和标签（若存在）的一致性，但不会检查最外层代码块，因其可能未编写完成。</dd>
<dt><code>C-M-p</code></dt><dd>移至当前代码块的起始位置 (<code>fortran-beginning-of-block</code> / <code>f90-beginning-of-block</code>) 。功能与 <code>fortran-end-of-block</code> 一致，仅移动方向相反。</dd>
</dl>

<p>
<code>fortran-beginning-of-subprogram</code> 和 <code>fortran-end-of-subprogram</code> 命令分别移至当前子程序的起始和结束位置。 <code>fortran-mark-do</code> 和 <code>fortran-mark-if</code> 命令会标记当前 do 或 if 代码块的结束位置，并将光标移至其起始位置。
</p>
</div>
</div>
<div id="outline-container-Fortran-Indent" class="outline-4">
<h4 id="Fortran-Indent"><span class="section-number-4">28.14.2.</span> Fortran 缩进</h4>
<div class="outline-text-4" id="text-Fortran-Indent">
<p>
对固定格式（或制表符格式）的 Fortran 代码进行缩进时，需要专用的命令和功能，以确保各类语法元素（行号、注释行标识、续行标记）出现在规定的列位置。
</p>

<ul class="org-ul">
<li><a href="#ForIndent-Commands">Fortran 缩进与填充命令</a></li>
<li><a href="#ForIndent-Cont">续行</a></li>
<li><a href="#ForIndent-Num">行号显示</a></li>
<li><a href="#ForIndent-Conv">语法约定</a></li>
<li><a href="#ForIndent-Vars">Fortran 缩进相关变量</a></li>
</ul>
</div>
<div id="outline-container-ForIndent-Commands" class="outline-5">
<h5 id="ForIndent-Commands"><span class="section-number-5">28.14.2.1.</span> Fortran 缩进与填充命令</h5>
<div class="outline-text-5" id="text-ForIndent-Commands">
<dl class="org-dl">
<dt><code>C-M-j</code></dt><dd>在光标位置拆分当前行并设置续行格式 (<code>fortran-split-line</code>) 。</dd>
<dt><code>M-^</code></dt><dd>将当前行与上一行合并 (<code>fortran-join-line</code>) 。</dd>
<dt><code>C-M-q</code></dt><dd>为光标所在子程序的所有行进行缩进排版 (<code>fortran-indent-subprogram</code>) 。</dd>
<dt><code>M-q</code></dt><dd>对光标所在的注释块或语句进行自动换行处理（调用 <code>fortran-fill-paragraph</code> 或 <code>fortran-fill-statement</code> 函数）。</dd>
</dl>

<p>
快捷键 <code>C-M-q</code> 执行 <code>fortran-indent-subprogram</code> 命令，可对包含光标位置的 Fortran 子程序（函数或子例程）的所有代码行重新进行缩进。
</p>

<p>
快捷键 <code>C-M-j</code> 执行 <code>fortran-split-line</code> 命令，会按照 Fortran 的语法规范拆分代码行：若为非注释行，拆分后的后半部分会作为续行并按规则缩进；若为注释行，拆分后的两部分会成为独立的注释行。
</p>

<p>
<code>M-^</code> 或 <code>C-c C-d</code> 执行 <code>fortran-join-line</code> 命令，可将续行合并回上一行，其功能大致为 <code>fortran-split-line</code> 命令的逆操作注意：调用该命令时，光标必须处于续行上。
</p>

<p>
在 Fortran 模式中， <code>M-q</code> 会对光标所在的注释块或语句执行自动换行，同时会清理语句中多余的续行标记。
</p>
</div>
</div>
<div id="outline-container-ForIndent-Cont" class="outline-5">
<h5 id="ForIndent-Cont"><span class="section-number-5">28.14.2.2.</span> 续行</h5>
<div class="outline-text-5" id="text-ForIndent-Cont">
<p>
大多数 Fortran 77 编译器支持两种编写续行的方式。若某行第一个非空格字符出现在第 5 列，该行即为上一行的续行，这种方式被称为 <b>fixed form固定格式</b> 。（GNU Emacs 中列数始终从 0 开始计数；但需注意，Fortran 标准中列数从 1 开始计数。你可自定义 <code>column-number-indicator-zero-based</code> 变量，让列数显示与 Fortran 规范一致，参见「<a href="#Optional-Mode-Line">可选的模式行功能</a>」章节。）变量 <code>fortran-continuation-string</code> 用于指定在第 5 列填充的续行标识字符。此外，若某行以制表符开头，且后续紧跟非 0 的数字，该行也会被视为续行，这种续行方式被称为 <b>tab format制表符格式</b> 。（Fortran 90 中新增了自由格式的续行方式。）
</p>

<p>
Fortran 模式支持上述两种续行格式。进入该模式时，编辑器会自动从缓冲区内容中推导合适的续行格式：从缓冲区起始位置开始，扫描最多 <code>fortran-analyze-depth</code> 行（默认值为 100），首个以制表符开头或以 6 个空格开头的行，会决定当前使用的续行格式。若扫描失败（例如缓冲区为新建的空缓冲区），则会使用 <code>fortran-tab-mode-default</code> 的取值（ <code>nil</code> 表示固定格式，非nil表示制表符格式）。当模式行中显示标识 ‘/t’ （由 <code>fortran-tab-mode-string</code> 定义）时，说明当前选中的是制表符格式，Fortran 模式会据此相应设置 <code>indent-tabs-mode</code> 的取值。
</p>

<p>
若某行文本以 Fortran 续行标记 '<code>$</code>' 开头，或第 5 列出现任意非空白字符，Fortran 模式会将其识别为续行。使用 <code>TAB</code> 键为续行缩进时，该行会被转换为当前的续行格式；使用 <code>C-M-j</code> 拆分 Fortran 语句时，新行的续行标记也会按照当前续行格式生成。
</p>

<p>
续行格式的设置会影响 Fortran 模式下的多项编辑行为：在固定格式下，语句主体的起始列数最小为 6，Fortran 代码块内缩进至更大列数的行，其空白部分只能使用空格字符；在制表符格式下，语句主体的起始列数最小为 8，且第 8 列之前的空白部分必须由一个制表符构成。
</p>
</div>
</div>
<div id="outline-container-ForIndent-Num" class="outline-5">
<h5 id="ForIndent-Num"><span class="section-number-5">28.14.2.3.</span> 行号显示</h5>
<div class="outline-text-5" id="text-ForIndent-Num">
<p>
若某行中第一个非空白字符为数字，Fortran 缩进功能会将其认定为行号，并将该行号调整至 0 至 4 列的位置。（Emacs 中列数始终从 0 开始计数，若将 <code>column-number-indicator-zero-based</code> 设为 <code>nil</code> 可更改该计数方式，参见「<a href="#Optional-Mode-Line">可选的模式行功能</a>」章节。）
</p>

<p>
四位及以下的行号，默认会缩进一个空格。该缩进规则由变量 <code>fortran-line-number-indent</code> 控制，该变量用于指定行号允许的最大缩进值，默认值为 1。Fortran 模式会避免行号的数字部分超出 4 列，必要时会将缩进值调至指定的最大值以下。若将 <code>fortran-line-number-indent</code> 设为 5，行号会以右对齐的方式排布，末尾对齐至 4 列。
</p>

<p>
只需直接插入行号，即可按照上述规则完成自动缩进。每插入一个数字，缩进值都会重新计算。若要关闭该功能，将变量 <code>fortran-electric-line-number</code> 设为 <code>nil</code> 即可。
</p>
</div>
</div>
<div id="outline-container-ForIndent-Conv" class="outline-5">
<h5 id="ForIndent-Conv"><span class="section-number-5">28.14.2.4.</span> 语法约定</h5>
<div class="outline-text-5" id="text-ForIndent-Conv">
<p>
Fortran 模式的缩进功能基于以下语法约定实现，遵循这些约定能让编辑器更准确地解析 Fortran 程序并完成合理缩进：
</p>
<ul class="org-ul">
<li>两层嵌套的 do 循环不可共用一条 continue 语句；</li>
<li>if、else、then、do 等 Fortran 关键字书写时，内部不可包含空格或换行；</li>
<li>尽管 Fortran 编译器通常会忽略字符串常量外的空白字符，但如果关键字书写不连续，Fortran 模式将无法识别。else if、end do这类组合写法是允许的，但第二个单词必须与第一个单词在同一行，不可写在续行中。</li>
</ul>

<p>
若未遵循上述约定，缩进命令对部分代码行的缩进效果可能不够规整。但即便如此，对符合语法规范的 Fortran 程序重新缩进后，其程序语义也不会发生改变。
</p>
</div>
</div>
<div id="outline-container-ForIndent-Vars" class="outline-5">
<h5 id="ForIndent-Vars"><span class="section-number-5">28.14.2.5.</span> Fortran 缩进相关变量</h5>
<div class="outline-text-5" id="text-ForIndent-Vars">
<p>
另有多个变量用于控制 Fortran 代码的缩进行为：
</p>
<dl class="org-dl">
<dt><code>fortran-do-indent</code></dt><dd>do语句每一层嵌套内的额外缩进值（默认值为 3）。</dd>
<dt><code>fortran-if-indent</code></dt><dd>if、select case或where语句每一层嵌套内的额外缩进值（默认值为 3）。</dd>
<dt><code>fortran-structure-indent</code></dt><dd>structure、union、map或interface语句每一层嵌套内的额外缩进值（默认值为 3）。</dd>
<dt><code>fortran-continuation-indent</code></dt><dd>续行主体部分的额外缩进值（默认值为 5）。</dd>
<dt><code>fortran-check-all-num-for-matching-do</code></dt><dd>在 Fortran 77 中，带行号的do语句可由任意行号匹配的语句终止，通常（非强制）使用continue语句完成该操作。若该变量设为非nil值，对任意带行号语句进行缩进时，都需检查是否存在以此为终止的do语句。若你始终使用continue语句终止do语句（或使用更现代的enddo语法），可将该变量设为nil（默认值）以提升缩进效率。</dd>
<dt><code>fortran-blink-matching-if</code></dt><dd>若该变量设为t，对endif（或enddo）语句进行缩进时，光标会短暂跳转到匹配的if（或do）语句处，以显示其位置。默认值为nil。</dd>
<dt><code>fortran-minimum-statement-indent-fixed</code></dt><dd>使用固定格式续行风格时，Fortran 语句的最小缩进值。语句主体的缩进值绝不会低于该数值，默认值为 6。</dd>
<dt><code>fortran-minimum-statement-indent-tab</code></dt><dd>使用制表符格式续行风格时，Fortran 语句的最小缩进值。语句主体的缩进值绝不会低于该数值，默认值为 8。</dd>
</dl>

<p>
下一节将介绍用于控制注释缩进的相关变量。
</p>
</div>
</div>
</div>
<div id="outline-container-Fortran-Comments" class="outline-4">
<h4 id="Fortran-Comments"><span class="section-number-4">28.14.3.</span> Fortran 注释</h4>
<div class="outline-text-4" id="text-Fortran-Comments">
<p>
Emacs 的常规注释命令默认注释可跟随在代码行后方，但在 Fortran 77 中，标准的注释语法要求整行仅为注释内容。因此 Fortran 模式重写了 Emacs 的标准注释命令，并定义了部分新的相关变量。
</p>

<p>
Fortran 模式也支持 Fortran 90 的注释语法：以 ‘!’ 开头的注释可跟随在其他文本后方。由于仅有部分 Fortran 77 编译器支持该语法，除非你提前配置，否则 Fortran 模式不会自动插入此类注释。如需启用，将变量 <code>fortran-comment-line-start</code> 设为 <code>"!"</code> 即可；若你设置了特殊的注释起始符，可能还需要修改变量 <code>fortran-comment-line-start-skip</code> 。
</p>
<dl class="org-dl">
<dt><code>M-;</code></dt><dd>对齐现有注释，或插入新注释 (<code>comment-dwim</code>) 。</dd>
<dt><code>C-x ;</code></dt><dd>仅适用于非标准的!注释 (<code>comment-set-column</code>) 。</dd>
<dt><code>C-c ;</code></dt><dd>将选区中的所有行转换为注释；若带前缀参数，则将选区中的注释行还原为正常代码 (<code>fortran-comment-region</code>) 。</dd>
</dl>

<p>
Fortran 模式下的 <code>M-;</code> 会调用标准的 <code>comment-dwim</code> 命令，该命令能识别任意类型的现有注释并对注释文本进行适配性对齐；若当前行无注释，则插入注释并完成对齐。需要注意的是，Fortran 模式中注释的插入与对齐逻辑，与其他 Emacs 模式存在差异。
</p>

<p>
当需要插入新注释时，规则如下：若当前行为空行，直接插入整行注释；若当前行为非空行，若你已配置启用 ‘!’ 注释，则插入非标准的!注释，否则会在当前行上方新建一行并插入整行注释。
</p>

<p>
非标准的 ‘!’ 注释的对齐方式与其他编程语言的注释一致，而整行注释的对齐规则则有所不同。在标准的整行注释中，注释分隔符本身必须始终出现在第 0 列，可进行对齐操作的仅为注释内部的文本。你可通过将变量 <code>fortran-comment-indent-style</code> 设为以下任一值，选择三种注释文本对齐风格之一：
</p>
<dl class="org-dl">
<dt><code>fixed</code></dt><dd>（固定列对齐）将注释文本对齐至固定列位置，该列数为 <code>fortran-comment-line-extra-indent</code> 的取值与语句最小缩进值之和，为默认对齐风格。其中语句最小缩进值的规则为：使用制表符格式续行时，取 <code>fortran-minimum-statement-indent-tab</code> 的取值；使用固定格式续行时，取 <code>fortran-minimum-statement-indent-fixed</code> 的取值。</dd>
<dt><code>relative</code></dt><dd>（相对对齐）将注释文本按照代码行的缩进规则对齐，再额外增加 <code>fortran-comment-line-extra-indent</code> 列的缩进量。</dd>
<dt><code>nil</code></dt><dd>（不自动对齐）不对整行注释中的文本进行自动对齐操作。</dd>
</dl>

<p>
此外，你可通过设置变量 <code>fortran-comment-indent-char</code> 为单个字符的字符串，指定在整行注释内用于缩进的字符。
</p>

<p>
编译器指令行（或预处理器行）的显示形式与注释行十分相似，但无论 <code>fortran-comment-indent-style</code> 取何值，这类行始终不进行任何缩进，这一点至关重要。变量 <code>fortran-directive-re</code> 是一个正则表达式，用于指定哪些行属于编译器指令行；匹配的行不仅不会被缩进，还会被赋予独特的语法高亮样式。
</p>

<p>
Emacs 的常规注释命令 <code>C-x ;</code> (<code>comment-set-column</code>) 未被 Fortran 模式重写：若你使用 ‘!’ 注释，该命令可正常生效，否则在 Fortran 模式中此命令无实际作用。
</p>

<p>
命令 <code>C-c ;</code> (<code>fortran-comment-region</code>) 的作用是在选区每行的开头插入字符串 '<code>c$$$</code>' 将其转换为注释行；若带数字前缀参数，则删除选区每行开头的 '<code>c$$$</code>' ，将注释行还原为可执行代码。用于注释转换的该字符串可通过设置变量 <code>fortran-comment-region</code> 进行自定义。需要注意的是，此处出现了命令与变量同名的情况，但在 Lisp 语言和 Emacs 中，上下文会明确区分二者的含义，因此绝不会产生冲突。
</p>
</div>
</div>
<div id="outline-container-Fortran-Autofill" class="outline-4">
<h4 id="Fortran-Autofill"><span class="section-number-4">28.14.4.</span> Fortran 模式下的自动填充</h4>
<div class="outline-text-4" id="text-Fortran-Autofill">
<p>
Fortran 模式为自动换行模式提供了专属适配支持，该次要模式会在你输入的语句过长时，自动将其拆分。语句拆分过程会通过 <code>fortran-continuation-string</code> 生成续行（参见<a href="#ForIndent-Cont">续行</a>章节）。当你键入空格、回车键、制表符，或是执行 Fortran 缩进命令时，都会触发该拆分操作。你可通过常规方式在 Fortran 模式中启用自动换行模式，详见<a href="#Auto-Fill">自动换行模式</a>章节。
</p>

<p>
当代码行长度超过指定宽度（~fill-column~ 变量的取值）时，自动换行模式会在空格或分隔符处拆分代码行。除空白字符外，可触发拆分的分隔符包括+、-、/、*、=、&lt;、&gt;和,。若变量 <code>fortran-break-before-delimiters</code> 设为 <code>nil</code> ，换行操作会在 <b>分隔符后</b> 执行；该变量默认取非nil值，此时换行操作会在 <b>分隔符前</b> 执行。
</p>

<p>
若要在所有 Fortran 缓冲区中启用自动换行模式，可将 <code>auto-fill-mode</code> 添加至 <code>fortran-mode-hook</code> 钩子中，详见<a href="#Hooks">钩子</a>章节。
</p>
</div>
</div>
<div id="outline-container-Fortran-Columns" class="outline-4">
<h4 id="Fortran-Columns"><span class="section-number-4">28.14.5.</span> Fortran 列检查</h4>
<div class="outline-text-4" id="text-Fortran-Columns">
<p>
在标准 Fortran 77 语法中，第 72 列之后的所有内容都会被编译器忽略。多数编译器提供了修改该列数限制的选项（例如 GNU Fortran 中的 ‘-ffixed-line-length-N’ 参数）。可通过自定义变量 <code>fortran-line-length</code> ，修改 Fortran 模式中的代码行长度限制，超出该列数的内容会被语法高亮标记为注释样式（字符串内的内容除外：若字符串超出 <code>fortran-line-length</code> 设定的列数，会导致语法高亮功能识别异常）。
</p>

<dl class="org-dl">
<dt><code>C-c C-r</code></dt><dd>在当前行上方临时显示列数标尺 (<code>fortran-column-ruler</code>) 。</dd>
<dt><code>C-c C-w</code></dt><dd>临时水平拆分当前窗口，使新窗口宽度恰好为 <code>fortran-line-length</code> 设定的列数 (<code>fortran-window-create-momentarily</code>) ，该功能可帮助你避免编写超出 Fortran 编译器列数限制的代码行。</dd>
<dt><code>C-u C-c C-w</code></dt><dd>水平拆分当前窗口，使新窗口宽度为 <code>fortran-line-length</code> 设定的列数 (<code>fortran-window-create</code>) ，拆分后可继续在该窗口中编辑代码。</dd>
<dt><code>M-x fortran-strip-sequence-nos</code></dt><dd>删除所有行中 <code>fortran-line-length</code> 设定列数及之后的所有文本内容。</dd>
</dl>

<p>
命令 <code>C-c C-r</code> (<code>fortran-column-ruler</code>) 会在当前行上方临时显示列数标尺，该标尺由两行文本构成，标注出 Fortran 程序中具有特殊意义的列位置：方括号[]标记出行号的有效列范围，大括号 <code>{}</code> 标记出语句主体的有效列范围，列编号会显示在对应范围的上方。
</p>

<p>
请注意，与 GNU Emacs 的常规设定一致，此处的列编号从 0 开始计数（可通过自定义变量 <code>column-number-indicator-zero-based</code> ，将列数显示方式改为与 Fortran 标准一致的从 1 计数，参见「<a href="#Optional-Mode-Line">可选的模式行功能</a>」章节）。因此，标尺上的列编号可能比你熟悉的编号小 1，但标尺标注的列位置完全符合 Fortran 的标准规范。
</p>

<p>
列数标尺的显示样式由变量 <code>indent-tabs-mode</code> 的取值决定：若该变量设为 <code>nil</code> ，会使用变量 <code>fortran-column-ruler-fixed</code> 定义的样式显示标尺；若为非nil值，则使用变量 <code>fortran-column-ruler-tab</code> 定义的样式，可通过修改这两个变量自定义标尺的显示效果。
</p>

<p>
命令 <code>C-c C-w</code> (<code>fortran-window-create-momentarily</code>) 会临时水平拆分窗口，使新窗口宽度匹配 <code>fortran-line-length</code> 的列数限制，方便你直观查看过长的代码行，键入空格键即可恢复窗口的原始宽度。
</p>

<p>
你也可水平拆分窗口后，在固定的窄窗口中持续编辑代码，只需执行 <code>C-u C-c C-w</code> （即 <code>M-x fortran-window-create</code> ）即可。在该窄窗口中编辑时，能即时发现编写的代码行是否超出了 Fortran 的合法列数限制。
</p>

<p>
命令 <code>M-x fortran-strip-sequence-nos</code> 会删除当前缓冲区中，所有行里 <code>fortran-line-length</code> 设定列数及之后的全部文本，这是清除旧的程序行序号最简便的方法。
</p>
</div>
</div>
<div id="outline-container-Fortran-Abbrev" class="outline-4">
<h4 id="Fortran-Abbrev"><span class="section-number-4">28.14.6.</span> Fortran 关键字缩写</h4>
<div class="outline-text-4" id="text-Fortran-Abbrev">
<p>
Fortran 模式为常用关键字和声明语句提供了诸多内置缩写，这类缩写与你自行定义的缩写类型完全相同。使用这些缩写前，你必须先开启缩写模式，详见<a href="#Abbrevs">缩写</a>章节。
</p>

<p>
这些内置缩写有一个特殊之处：均以分号开头。例如，内置缩写 ‘;c’ 对应的完整内容为 ‘continue’。若已启用缩写模式，当你输入 ‘;c’ 后，再键入空格、换行等标点符号时， ‘;c’会自动展开为 ‘continue’。
</p>

<p>
键入 ‘;?’ 或 ‘;C-h’ ，即可查看所有 Fortran 内置缩写及其对应的完整内容列表。
</p>
</div>
</div>
</div>
</section>
<section id="outline-container-Building" class="outline-2">
<h2 id="Building"><span class="section-number-2">29.</span> 程序编译与测试</h2>
<div class="outline-text-2" id="text-Building">
<p>
上一章介绍了在编辑程序时实用的 Emacs 命令，本章将讲解辅助程序编译和测试过程的相关命令。
</p>

<ul class="org-ul">
<li><a href="#Compilation">在 Emacs 中运行编译</a></li>
<li><a href="#Compilation-Mode">编译模式</a></li>
<li><a href="#Compilation-Shell">编译用子 shell</a></li>
<li><a href="#Grep-Searching">在 Emacs 中使用 Grep 搜索</a></li>
<li><a href="#Flymake">实时语法错误检测</a></li>
<li><a href="#Debuggers">在 Emacs 中运行调试器</a></li>
<li><a href="#Executing-Lisp">执行 Lisp 表达式</a></li>
<li><a href="#Lisp-Libraries">Emacs Lisp 代码库</a></li>
<li><a href="#Lisp-Eval">求值 Emacs Lisp 表达式</a></li>
<li><a href="#Lisp-Interaction">Lisp 交互缓冲区</a></li>
<li><a href="#External-Lisp">运行外部 Lisp 解释器</a></li>
</ul>
</div>
<div id="outline-container-Compilation" class="outline-3">
<h3 id="Compilation"><span class="section-number-3">29.1.</span> 在 Emacs 中运行编译</h3>
<div class="outline-text-3" id="text-Compilation">
<p>
Emacs 可为 C、Fortran 等语言调用编译器，并将编译日志输出至 Emacs 缓冲区，同时能解析错误信息并定位错误发生位置。
</p>

<p>
<b>核心编译命令</b>
</p>
<dl class="org-dl">
<dt><code>M-x compile</code></dt><dd>在 Emacs 中异步运行编译器，错误信息输出至 <code>*compilation*</code> 缓冲区。</dd>
<dt><code>M-x recompile</code></dt><dd></dd>

<dt><code>g（编译模式下）</code></dt><dd>使用上一次 <code>M-x compile</code> 调用的相同命令重新执行编译。</dd>
<dt><code>M-x kill-compilation</code></dt><dd>终止正在运行的编译子进程。</dd>
</dl>

<p>
<b>编译命令的执行规则</b>
</p>

<p>
执行 <code>make</code> 或其他编译命令时，键入 <code>M-x compile</code> ，Emacs 会通过迷你缓冲区读取一条 Shell 命令，随后以 Emacs 子进程（ 或 <i>inferior process 下级进程</i> ）的方式启动 Shell 执行该命令，输出内容会插入至名为 <code>*compilation*</code> 的缓冲区。命令的工作目录为当前缓冲区的默认目录，因此编译操作默认在该目录下执行。
</p>

<p>
<b>默认编译命令与自定义</b>
</p>

<p>
默认编译命令为 'make -k' ，该命令通常适用于通过 <code>make</code> 工具编译的程序（'-k' 参数表示编译发生错误后，尽可能继续完成后续编译）。相关细节可参考《GNU Make 手册》中的<a href="https://www.gnu.org/software/make/manual/html_node/index.html#Top">make命令</a>说明。若此前执行过 <code>M-x compile</code> ，所指定的命令会自动保存至变量 <code>compile-command</code> ，并作为下一次 <code>M-x compile</code> 的默认命令。也可为单个文件设置 <code>compile-command</code> 的文件本地值（详见《<a href="#File-Variables">文件中的本地变量</a>》）。
</p>

<p>
<b>编译过程的缓冲区与模式行提示</b>
</p>

<p>
启动编译后， <code>*compilation*</code> 缓冲区会在新窗口中显示，但不会被选中。编译运行期间，该缓冲区的主模式指示器会显示 'run' 运行，所有缓冲区的模式行都会出现 'Compiling' 编译中字样。编译过程中无需保持 <code>*compilation*</code> 缓冲区可见，编译会持续执行。无论因何种原因结束编译， <code>*compilation*</code> 缓冲区的模式行会更新提示：正常退出显示 'exit' 退出（后跟随退出码， <code>[0]</code> 表示正常退出），因信号终止则显示 'signal' 信号。
</p>

<p>
<b>编译输出的查看方式</b>
</p>

<p>
若想实时查看编译输出，可切换至 <code>*compilation*</code> 缓冲区并将光标移至缓冲区末尾。光标位于末尾时，新的编译输出会插入在光标上方，且光标始终保持在末尾；若光标未在末尾，新输出会添加至缓冲区末尾，光标位置保持不变。
</p>

<p>
编译过程中，模式行会实时显示编译器当前输出的错误、警告及信息类提示的数量。
</p>

<p>
<b>编译输出的自动滚动设置</b>
</p>

<p>
将变量 <code>compilation-scroll-output</code> 设为非nil值时， <code>*compilation*</code> 缓冲区会自动滚动以跟随编译输出：
</p>
<ul class="org-ul">
<li>若值为 <code>first-error</code> ，滚动会在首个错误出现时停止，且光标定位至该错误位置；</li>
<li>若为其他非nil值，滚动会持续至编译输出结束。</li>
</ul>

<p>
<b>重新编译与编译进程的管理</b>
</p>

<p>
键入 <code>M-x recompile</code> 可使用上一次的命令重新编译，该命令会复用 <code>*compilation*</code> 缓冲区，并在该缓冲区的默认目录（即上一次编译的启动目录）中执行编译，且在 <code>*compilation*</code> 缓冲区中，该命令绑定至快捷键 <code>g</code> 。
</p>

<p>
启动新的编译时，会终止 <code>*compilation*</code> 缓冲区中正在运行的编译进程（该缓冲区同一时间仅能处理一个编译任务）。但 <code>M-x compile</code> 和 <code>M-x recompile</code> 在终止运行中的编译前会请求确认；若想跳过确认直接终止，可将变量 <code>compilation-always-kill</code> 设为 <code>t</code> ，也可直接使用 <code>M-x kill-compilation</code> 终止编译进程。
</p>

<p>
若需同时运行两个编译任务，可先启动第一个编译，再重命名 <code>*compilation*</code> 缓冲区（可使用 <code>rename-uniquely</code> 命令，详见《<a href="#Misc-Buffer">缓冲区的杂项操作</a>》），随后切换缓冲区并启动第二个编译，Emacs 会自动创建新的 <code>*compilation*</code> 缓冲区。
</p>

<p>
<b>编译的环境变量控制</b>
</p>

<p>
可通过变量 <code>compilation-environment</code> 控制传递给编译命令的环境变量，该变量的值为环境变量设置列表，每个元素为 "envvarname=value" 格式的字符串，这些设置会覆盖系统默认的环境变量。
</p>

<p>
<b>超长编译输出行的优化</b>
</p>

<p>
在编译输出中显示极长的行可能会降低 Emacs 运行效率。长度超过 <code>compilation-max-output-line-length</code> 的行，其超出限制的部分会被隐藏，并显示一个可点击的按钮，点击后可展开隐藏内容；若将该变量设为 <code>nil</code> ，则不会隐藏任何内容。
</p>
</div>
</div>
<div id="outline-container-Compilation-Mode" class="outline-3">
<h3 id="Compilation-Mode"><span class="section-number-3">29.2.</span> 编译模式</h3>
<div class="outline-text-3" id="text-Compilation-Mode">
<p>
<code>*compilation*</code> 缓冲区使用的主模式为  Compilation mode。该模式会将缓冲区中的每条 <b>错误</b> 信息 <b>转换为超链接</b> ；将光标移至超链接处按下 <code>RET</code> 回车键，或用鼠标点击超链接（参见《<a href="#Mouse-References">通过鼠标跟踪引用</a>》），即可在新窗口中跳转到错误信息对应的代码位置，该位置即错误发生的文件具体行位。
</p>

<p>
编译模式下 <code>*compilation*</code> 缓冲区的显示效果，可通过自定义相关高亮面版来控制，不同面版对应缓冲区不同内容的高亮样式，例如 <code>compilation-error</code> （编译错误面版）和 <code>compilation-warning</code> （编译警告面版）分别用于高亮错误和警告信息。需注意，这类面版均继承自 <code>error</code> （错误通用面版）和 <code>warning</code> （警告通用面版），因此也可直接自定义父级面版，实现对所有错误、警告类高亮的统一设置。
</p>

<p>
键入 <code>M-x customize-group RET compilation</code> 可打开编译模式的自定义组，查看所有相关的自定义变量和面版。
</p>

<p>
若将变量 <code>compilation-auto-jump-to-first-error</code> 设为非nil值，Emacs 会在 <code>*compilation*</code> 缓冲区出现第一条错误信息时，自动跳转到其对应的代码位置。（该变量还可设为 <code>if-location-known</code> 和 <code>first-known</code> ，两种值会分别修改自动跳转错误位置的触发条件。）
</p>

<p>
编译模式提供了以下附加命令，这些命令同样可在 <code>*grep*</code> 缓冲区中使用 —— 该缓冲区中，超链接对应的是搜索匹配结果而非错误信息（参见《<a href="#Grep-Searching">在 Emacs 中使用 Grep 搜索</a>》）。
</p>

<p>
<b>编译模式核心快捷键与命令</b>
</p>
<dl class="org-dl">
<dt>M-g M-n=</dt><dd></dd>

<dt><code>M-g n</code></dt><dd></dd>

<dt><code>C-x `</code></dt><dd>跳转到下一条错误信息或匹配结果对应的位置 (<code>next-error</code>) 。</dd>
<dt><code>M-g M-p</code></dt><dd></dd>

<dt><code>M-g p</code></dt><dd>跳转到上一条错误信息或匹配结果对应的位置 (<code>previous-error</code>) 。</dd>
<dt><code>M-n</code></dt><dd>将光标移至下一条错误信息或匹配结果处，不跳转至其对应的代码位置 (<code>compilation-next-error</code>) 。</dd>
<dt><code>M-p</code></dt><dd>将光标移至上一条错误信息或匹配结果处，不跳转至其对应的代码位置 (<code>compilation-previous-error</code>) 。</dd>
<dt><code>M-}</code></dt><dd>将光标移至另一个文件中的下一条错误信息或匹配结果处 (<code>compilation-next-file</code>) 。</dd>
<dt><code>M-{</code></dt><dd>将光标移至另一个文件中的上一条错误信息或匹配结果处 (<code>compilation-previous-file</code>) 。</dd>
<dt><code>C-c C-f</code></dt><dd>切换下一条错误跟随次模式，开启后，在编译缓冲区中移动光标时，会自动在对应窗口显示光标所在错误的源代码位置。</dd>
<dt><code>g</code></dt><dd>重新执行最后一次在 <code>*compilation*</code> 缓冲区输出结果的命令（即重新编译 / 重新执行 grep 等）。</dd>
<dt><code>M-x next-error-select-buffer</code></dt><dd>选择一个缓冲区，作为后续执行 <code>next-error</code> 和 <code>previous-error</code> 命令时的操作对象。</dd>
</dl>

<p>
<b>错误信息的顺序遍历</b>
</p>

<p>
要按顺序跳转到各错误位置，可键入 <code>C-x `</code> (<code>next-error</code>) ，也可使用等效快捷键 <code>M-g M-n</code> 或 <code>M-g n</code> 。该命令可在 <b>任意缓冲区</b> 中调用，并非仅限编译模式缓冲区。 编译完成后首次调用该命令，会跳转到第一条错误信息对应的位置；后续每次键入 <code>M-g M-n</code> ，会依次跳转到下一条错误位置。若在 <code>*compilation*</code> 缓冲区中通过 <code>RET</code> 回车键或鼠标点击，跳转到了某条特定错误的位置，后续的 <code>M-g M-n</code> 会从该错误开始继续向后遍历。当 <code>M-g M-n</code> 遍历至最后一条错误无后续内容时，会触发错误提示；键入 <code>C-u M-g M-n</code> 可重置遍历位置，从编译缓冲区开头重新开始，跳转到第一条错误的位置。
</p>

<p>
<code>M-g M-p</code> 或 <code>M-g p</code> (<code>previous-error</code>) 则按反向顺序遍历错误信息。
</p>

<p>
<code>next-error</code> 和 <code>previous-error</code> 命令并非仅作用于 <code>*compilation*</code> 和 <code>*grep*</code> 缓冲区中的错误 / 匹配结果，还支持遍历其他命令生成的错误 / 匹配列表，例如 <code>M-x occur</code> （参见《<a href="#Other-Repeating-Search">其他搜索与循环命令</a>》）生成的匹配结果。命令的遍历规则为：若当前缓冲区包含错误 / 匹配信息，则直接遍历该缓冲区；若没有，Emacs 会先在选中框架的所有窗口中查找包含错误 / 匹配信息的缓冲区（若变量 <code>next-error-find-buffer-function</code> 自定义为 <code>next-error-buffer-on-selected-frame</code> ），再查找此前被  <code>next-error</code> / <code>previous-error</code> 命令使用过的缓冲区，最后查找所有其他缓冲区。被遍历的缓冲区若未在任何窗口中显示，会自动在窗口中展示。可通过 <code>next-error-select-buffer</code> 命令切换操作缓冲区，让后续的 <code>next-error</code> 命令作用于新选择的缓冲区。
</p>

<p>
默认情况下， <code>next-error</code> 和 <code>previous-error</code> 会跳过重要性较低的信息，该行为由变量 <code>compilation-skip-threshold</code> 控制：
</p>
<ul class="org-ul">
<li>默认值1：跳过所有比警告级别低的信息；</li>
<li>值为2：跳过所有比错误级别低的信息（即仅遍历错误）；</li>
<li>值为0：不跳过任何信息，遍历所有内容。</li>
</ul>

<p>
<b>错误位置的高亮与定位提示</b>
</p>

<p>
当 Emacs 跳转到错误信息对应的代码位置时，会对相关源代码行进行 <b>临时高亮</b> ，高亮持续时长由两个变量控制：选中缓冲区中的错误位置，由 <code>next-error-highlight</code> 定义；非选中缓冲区中的错误位置，由 <code>next-error-highlight-no-select</code> 定义。此外，还可自定义变量 <code>next-error-message-highlight</code> ，设置在信息缓冲区中如何高亮当前选中的错误信息。
</p>

<p>
若显示 <code>*compilation*</code> 缓冲区的窗口带有 <b>左侧边缘区</b> （参见《<a href="#Fringes">窗口边缘区</a>》），跳转到错误位置的命令会在边缘区绘制一个箭头，指向当前的错误信息；若窗口无左侧边缘区（如文本终端中的窗口），命令会自动滚动窗口，让当前错误信息显示在窗口顶部。
</p>
<ul class="org-ul">
<li>若将变量 <code>compilation-context-lines</code> 设为 <code>t</code> ，会在列号 0 前插入一个可见箭头，替代边缘区箭头作为定位标识；</li>
<li>若将该变量设为整数值 <code>n</code> ，无论窗口是否有边缘区，命令都会滚动窗口，让当前错误信息显示在距离窗口顶部 <code>n</code> 行的位置；</li>
<li>变量默认值 <code>nil</code> ，即上述默认的边缘区箭头 / 窗口顶部定位行为。</li>
</ul>

<p>
<b>编译输出的过滤与隐藏</b>
</p>

<p>
编译输出有时会非常冗长，其中大部分内容对用户无实际意义。可通过用户选项 <code>compilation-hidden-output</code> 过滤隐藏无关内容，该选项的值可为一个正则表达式，或正则表达式列表， <b>匹配正则的输出内容会被设为不可见</b> 。例如，要隐藏递归执行 makefiles 时的冗长输出，可进行如下设置：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq</span> compilation-hidden-output
      '(<span style="color: #8b2252;">"^make[</span><span style="color: #8b2252;">^</span><span style="color: #8b2252;">\n]+\n"</span>))
</pre>
</div>

<p>
<b>错误信息的解析规则</b>
</p>

<p>
编译模式通过变量 <code>compilation-error-regexp-alist</code> 解析编译器输出的信息，该变量中列出了多种错误信息的格式，并定义了 Emacs 如何从每种格式中提取错误对应的代码位置。与之类似的变量 <code>grep-regexp-alist</code> ，则定义了 Emacs 如何解析 grep 命令的输出结果（参见《<a href="#Grep-Searching">在 Emacs 中使用 Grep 搜索</a>》）。
</p>

<p>
有时 <code>compilation-error-regexp-alist</code> 无法正确识别错误对应的源文件名，此时可使用用户选项 <code>compilation-transform-file-match-alist</code> 进行必要调整，例如为文件名添加 / 修改目录组件，甚至将某些编译器信息直接排除在错误信息之外。
</p>

<p>
<b>编译模式的额外按键与次模式</b>
</p>

<p>
编译模式还为部分基础操作绑定了快捷键：
</p>
<ul class="org-ul">
<li>空格键（SPC）和删除键（DEL）：按屏滚动缓冲区；</li>
<li><code>M-n</code> (<code>compilation-next-error</code>) 和 <code>M-p</code> (<code>compilation-previous-error</code>) ：移动光标至下一条 / 上一条错误信息；</li>
<li><code>M-{</code> (<code>compilation-next-file</code>) 和 <code>M-}</code> (<code>compilation-previous-file</code>) ：移动光标至另一个源文件中的下一条 / 上一条错误信息。</li>
</ul>

<p>
键入 <code>C-c C-f</code> 可切换 <b>下一条错误跟随模式</b> ，开启该次模式后，在编译缓冲区中进行普通的光标移动时，会自动更新源代码缓冲区 —— 即光标移至某条错误信息上时，会立即显示该错误对应的代码位置。
</p>

<p>
编译模式的所有功能，也可通过编译次模式在其他缓冲区中使用，该次模式允许在 <b>任意缓冲区</b> 中解析错误信息，而非仅限标准的编译输出缓冲区。键入 <code>M-x compilation-minor-mode</code> 即可启用该次模式。例如，在 Rlogin 缓冲区中（参见《<a href="#Remote-Host">远程主机 Shell</a>》），启用编译次模式后，可通过 FTP 自动访问远程源文件（参见《<a href="#File-Names">文件名</a>》），解析远程编译的错误信息并跳转到对应代码位置。
</p>
</div>
</div>
<div id="outline-container-Compilation-Shell" class="outline-3">
<h3 id="Compilation-Shell"><span class="section-number-3">29.3.</span> 编译用子 shell</h3>
<div class="outline-text-3" id="text-Compilation-Shell">
<p>
本节介绍在编译缓冲区中使用 Shell 及其相关功能的各类技巧与注意事项。本部分内容仅适用于 <b>本地编译</b> ，对于默认目录位于远程主机的编译缓冲区，这些方法大概率无法生效（或不具备实际意义）。
</p>

<p>
<code>M-x compile</code> 命令会通过 Shell 执行编译指令，但会为 Shell 指定 <b>非交互式</b> 运行选项。这意味着，该 Shell 启动时不应显示命令行提示符。若你发现常用的 Shell 提示符出现在 <code>*compilation*</code> 缓冲区中，造成显示混乱，原因是你在 Shell 的初始化文件中 <b>无条件设置了提示符</b> （该初始化文件的名称依 Shell 类型而定，可能是 <code>.bashrc</code> 、 <code>.profile</code> 、 <code>.cshrc</code> 、 <code>.shrc</code>  等）。正确的做法是，仅当 Shell 检测到已存在提示符时，再对其进行设置。bash 中的设置方式：
</p>
<div class="org-src-container">
<pre class="src src-shell">sh
<span style="color: #a020f0;">if</span> [ <span style="color: #8b2252;">"${PS1+set}"</span> = set ]
<span style="color: #a020f0;">then</span> <span style="color: #a0522d;">PS1</span>=&#8230;
<span style="color: #a020f0;">fi</span>
</pre>
</div>

<p>
csh 中的设置方式：
</p>
<div class="org-src-container">
<pre class="src src-shell">csh
<span style="color: #a020f0;">if</span> ($<span style="color: #a0522d;">?</span>prompt) <span style="color: #483d8b;">set</span> <span style="color: #a0522d;">prompt</span> = &#8230;
</pre>
</div>

<p>
若需自定义传递给编译子 Shell 的 <code>TERM</code> 环境变量值，可通过自定义变量 <code>comint-terminfo-terminal</code> 实现（参见《<a href="#Shell-Options">Shell 模式选项</a>》）。
</p>

<p>
Emacs 并不支持编译器进程启动 <b>异步子进程</b> ；若编译器进程启动了此类异步子进程，且主编译器进程终止后这些子进程仍在运行，Emacs 可能会将其强制终止，或这些子进程的输出无法正常传入 Emacs 中。要避免该问题，需让主编译进程 <b>等待其所有子进程执行完毕后再退出</b> 。在 Shell 脚本中，可通过 '<code>$!</code>' 和 '<code>wai</code>' t命令实现该功能，示例如下：
</p>

<div class="org-src-container">
<pre class="src src-shell">(sleep 10; <span style="color: #483d8b;">echo</span> 2nd)&amp; <span style="color: #a0522d;">pid</span>=$<span style="color: #a0522d;">!</span>  <span style="color: #b22222;"># </span><span style="color: #b22222;">&#35760;&#24405;&#23376;&#36827;&#31243;&#30340;&#36827;&#31243;&#21495;
</span><span style="color: #483d8b;">echo</span> first message
<span style="color: #483d8b;">wait</span> $<span style="color: #a0522d;">pid</span>                     <span style="color: #b22222;"># </span><span style="color: #b22222;">&#31561;&#24453;&#35813;&#23376;&#36827;&#31243;&#25191;&#34892;&#23436;&#27605;</span>
</pre>
</div>

<p>
若后台子进程无需向编译缓冲区输出内容，仅需防止其在主编译进程终止时被 Emacs 杀死，执行以下命令即可实现：
</p>

<div class="org-src-container">
<pre class="src src-shell">nohup command; sleep 1
</pre>
</div>

<p>
在 MS-DOS 系统中， <b>不支持异步子进程</b> ，因此 <code>M-x compile</code> 会 <b>同步执行</b> 编译命令（即必须等待编译命令执行完毕后，才能在 Emacs 中进行其他操作）。相关细节参见《<a href="#MS_002dDOS">Emacs 与 MS-DOS</a>》。
</p>
</div>
</div>
<div id="outline-container-Grep-Searching" class="outline-3">
<h3 id="Grep-Searching"><span class="section-number-3">29.4.</span> 在 Emacs 中使用 Grep 搜索</h3>
<div class="outline-text-3" id="text-Grep-Searching">
<p>
如同在 Emacs 中运行编译器并跳转到含编译错误的代码行一样，你也可以在 Emacs 中运行 <code>grep</code> 命令，再跳转到匹配到结果的代码行。这一功能的实现原理是，将 <code>grep</code> 报告的匹配结果当作错误信息来处理。 <code>grep</code> 命令的输出缓冲区使用Grep mode，该模式是编译模式的一个变体（参见《<a href="#Compilation-Mode">编译模式</a>》）。
</p>

<p>
<b>核心 Grep 相关命令</b>
</p>

<dl class="org-dl">
<dt><code>M-x grep</code></dt><dd></dd>

<dt><code>M-x lgrep</code></dt><dd>在 Emacs 中异步运行 <code>grep</code> 命令，在名为 <code>*grep*</code> 的缓冲区中列出匹配到的行。</dd>
<dt><code>M-x grep-find</code></dt><dd></dd>

<dt><code>M-x find-grep</code></dt><dd></dd>

<dt><code>M-x rgrep</code></dt><dd>通过 <code>find</code> 命令调用 <code>grep</code> 进行搜索，将输出结果汇总至 <code>*grep*</code> 缓冲区。</dd>
<dt><code>M-x zrgrep</code></dt><dd>运行 <code>zgrep</code> 命令，将输出结果汇总至 <code>*grep*</code> 缓冲区。</dd>
<dt><code>M-x kill-grep</code></dt><dd>终止正在运行的 <code>grep</code> 子进程。</dd>
</dl>

<p>
<b>基础 Grep 命令使用方法</b>
</p>

<p>
键入=M-x grep= ，随后输入执行 <code>grep</code> 的命令行即可运行该工具，命令行参数与在终端中正常运行 <code>grep</code> 时一致：先输入 <code>grep</code> 风格的正则表达式（通常用单引号包裹，以转义 Shell 的特殊字符），后接文件名，文件名可使用通配符。若为 <code>M-x grep</code> 指定前缀参数，Emacs 会在光标所在缓冲区中查找标识符（参见《<a href="#Xref">查找标识符引用</a>》），并将该标识符作为 <code>grep</code> 命令的默认搜索内容。
</p>

<p>
你输入的命令并非只能单纯运行 <code>grep</code> ，也可使用任何能输出 <b>相同格式结果</b> 的 Shell 命令。例如，可将多个 grep 命令串联使用，示例如下：
</p>

<div class="org-src-container">
<pre class="src src-shell">grep -nH -e foo *.el | grep bar | grep toto
</pre>
</div>

<p>
grep 命令的输出会写入 <code>*grep*</code> 缓冲区，你可以使用 <code>M-g M-n</code> 、 <code>RET</code> 回车键等方式跳转到原文件中对应的匹配行，操作方式与跳转到编译错误行完全相同。关于 <code>*grep*</code> 缓冲区中可用的命令和快捷键绑定细节，参见《<a href="#Compilation-Mode">编译模式</a>》章节。
</p>

<p>
部分 <code>grep</code> 程序支持 '<code>--color</code>' 选项，该选项会在匹配结果两侧添加特殊标记以实现高亮效果。将变量 <code>grep-highlight-matches</code> 设为 <code>t</code> 即可启用该功能，此时在源代码缓冲区中显示匹配结果时， <b>仅会高亮精确匹配的内容</b> ，而非整行源代码。该高亮功能通过匹配 <code>grep</code> 输出的 ANSI 转义序列实现，序列的匹配规则由变量 <code>grep-match-regexp</code> 控制，可通过自定义该变量适配不同的 grep 程序。
</p>

<p>
与编译命令的行为一致（参见《<a href="#Compilation">在 Emacs 中运行编译</a>》）， <code>grep</code> 命令运行期间，模式行会实时显示当前已找到并高亮的匹配结果数量。
</p>

<p>
<b>Grep 运行前的缓冲区保存设置</b>
</p>

<p>
grep 命令运行前，Emacs 会提示是否保存相关缓冲区，该行为由变量 <code>grep-save-buffers</code> 控制，其可选值如下：
</p>
<ul class="org-ul">
<li><code>nil</code> ：不保存任何缓冲区；</li>
<li><code>ask</code> ：保存前进行询问（默认值）；</li>
<li>自定义函数：将该函数作为判定谓词（函数会以文件名为参数被调用，返回非nil时表示保存对应缓冲区）；</li>
<li>其他非nil值：无需询问，直接保存所有缓冲区。</li>
</ul>

<p>
<b>Grep 结果的显示格式定制</b>
</p>

<p>
默认情况下，grep 匹配结果的每一行前都会添加文件名前缀。若将变量 <code>grep-use-headings</code> 自定义为非nil值，匹配结果会按文件进行分块展示 —— 每个包含匹配结果的文件对应一个分块，文件名会以 <code>grep-heading</code> 专用面版样式显示在分块标题处。
</p>

<p>
<b>高级 Grep 搜索命令</b>
</p>

<p>
命令 <code>M-x grep-find</code> （也可通过 <code>M-x find-grep</code> 调用）与 <code>M-x grep</code> 功能类似，但会提供不同的初始默认命令 —— 该默认命令会同时运行 <code>find</code> 和 <code>grep</code> ，从而实现对 <b>整个目录树</b> 中的所有文件进行搜索。相关还可参见《<a href="#Dired-and-Find">Dired 与 find</a>》中的 <code>find-grep-dired</code> 命令。
</p>

<p>
命令 <code>M-x lgrep</code> （本地 <code>grep</code> ）和 <code>M-x rgrep</code> （递归 <code>grep</code> ）是grep和grep-find的 <b>更友好版本</b> ，这两个命令会分别提示你输入待匹配的正则表达式、待搜索的文件、搜索的基准目录。搜索的大小写敏感性由变量 <code>case-fold-search</code> 的当前值控制。命令 <code>M-x zrgrep</code> 与 <code>M-x rgrep</code> 功能类似，区别在于其调用 zgrep 而非 grep，用于搜索压缩文件（gzipped） 中的内容。
</p>

<p>
上述这些命令会基于以下变量构建对应的 Shell 命令：
</p>
<ul class="org-ul">
<li><code>grep-template</code> ：为lgrep提供命令模板；</li>
<li><code>grep-find-template</code> ：为rgrep提供命令模板。</li>
<li>待搜索的文件名可使用变量 <code>grep-files-aliases</code> 中定义的别名。</li>
</ul>

<p>
变量 <code>grep-find-ignored-directories</code> 中列出的目录，会被 <code>M-x rgrep</code> 自动跳过，该变量的默认值包含各类版本控制系统使用的数据目录。
</p>

<p>
<b>Grep 命令行的缩写显示</b>
</p>

<p>
默认情况下，为lgrep、rgrep、zrgrep构建的 Shell 命令会进行缩写显示 —— 命令中包含待忽略的长文件 / 目录列表的部分会被隐藏，仅显示省略号按钮。点击该省略号按钮即可展开隐藏的内容，也可键入 <code>M-x grep-find-toggle-abbreviation</code> 交互式切换是否显示隐藏部分。若要禁用 Shell 命令的缩写功能，将选项 <code>grep-find-abbreviate</code> 自定义为 <code>nil</code> 即可。
</p>
</div>
</div>
<div id="outline-container-Flymake" class="outline-3">
<h3 id="Flymake"><span class="section-number-3">29.5.</span> 实时语法错误检测</h3>
<div class="outline-text-3" id="text-Flymake">
<p>
Flymake 模式是一款次模式，可为 C、C++、Perl、HTML、TeX/LaTeX 等多种编程语言和标记语言执行实时语法检查。该模式与拼写检查的 Flyspell 模式原理相似，后者以同类实时方式为自然语言做拼写检查（参见《<a href="#Spelling">拼写检查与修正</a>》）。在你编辑文件时，Flymake 模式会在后台利用缓冲区的临时副本，调用适配的语法检查工具；随后解析工具输出的错误与警告信息，并在缓冲区中高亮显示存在错误的代码行。所使用的语法检查工具依语言而定，例如对 C/C++ 文件，默认使用 C 语言编译器；对于复杂的项目工程，Flymake 也可调用 make 等构建工具完成语法检查。
</p>

<p>
启用 Flymake 模式可键入命令 <code>M-x flymake-mode</code> 。你可通过 <code>M-x flymake-goto-next-error</code> 和 <code>M-x flymake-goto-prev-error</code> 命令，跳转到模式检测到的错误位置。若要查看当前缓冲区的语法诊断详细汇总，可使用 <code>M-x flymake-show-buffer-diagnostics</code> 命令；若要查看整个项目的语法诊断汇总（参见《<a href="#Projects">项目操作</a>》），可使用 <code>M-x flymake-show-project-diagnostics</code> 命令。
</p>

<p>
关于 Flymake 模式的更多使用细节，参见《<a href="https://www.gnu.org/software/emacs/manual/html_node/flymake/index.html#Top">Flymake 手册</a>》中的相关章节。
</p>
</div>
</div>
<div id="outline-container-Debuggers" class="outline-3">
<h3 id="Debuggers"><span class="section-number-3">29.6.</span> 在 Emacs 中运行调试器</h3>
<div class="outline-text-3" id="text-Debuggers">
<p>
GUD（统一调试器，Grand Unified Debugger）库为各类符号调试器提供了 Emacs 交互接口，可运行 GNU 调试器（GDB），同时也支持 LLDB、DBX、SDB、XDB、Guile 交互式解释器调试命令、Perl 调试模式、Python 调试器 PDB 以及 Java 调试器 JDB。
</p>

<p>
Emacs 为 GDB 提供了专用交互接口，该接口会通过额外的 Emacs 窗口展示被调试程序的运行状态，详见<a href="#GDB-Graphical-Interface">GDB 图形化接口</a>章节。
</p>

<p>
Emacs 还内置了针对 Emacs Lisp 程序的调试器，详见《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Debugging.html#Debugging">Lisp 调试器</a>章节。
</p>
</div>
<div id="outline-container-Starting-GUD" class="outline-4">
<h4 id="Starting-GUD"><span class="section-number-4">29.6.1.</span> 启动 GUD 调试器</h4>
<div class="outline-text-4" id="text-Starting-GUD">
<p>
Emacs 提供了多个用于启动调试器子进程的命令，每个命令对应一款特定的调试器程序。
</p>

<dl class="org-dl">
<dt><code>M-x gdb</code></dt><dd>将 GDB 作为子进程运行，并通过类集成开发环境（IDE）的 Emacs 交互界面与其交互。有关该命令的更多信息，参见<a href="#GDB-Graphical-Interface">GDB 图形化接口</a>章节。</dd>

<dt><code>M-x gud-gdb</code></dt><dd>运行 GDB，通过 GUD 交互缓冲区实现与 GDB 子进程的输入输出交互（参见<a href="#Debugger-Operation">调试器操作</a>章节）。若该类缓冲区已存在，则直接切换至该缓冲区；若不存在，则创建并切换至该缓冲区。</dd>
</dl>

<p>
下述命令的工作逻辑与上述一致，分别对应其他调试器程序：
</p>
<dl class="org-dl">
<dt><code>M-x lldb</code></dt><dd>运行 LLDB 调试器。</dd>
<dt><code>M-x perldb</code></dt><dd>以调试模式运行 Perl 解释器。</dd>
<dt><code>M-x jdb</code></dt><dd>运行 Java 调试器。</dd>
<dt><code>M-x pdb</code></dt><dd>运行 Python 调试器。</dd>
<dt><code>M-x guiler</code></dt><dd>启动 Guile 交互式解释器，用于调试 Guile Scheme 程序。</dd>
<dt><code>M-x dbx</code></dt><dd>运行 DBX 调试器。</dd>
<dt><code>M-x xdb</code></dt><dd>运行 XDB 调试器。</dd>
<dt><code>M-x sdb</code></dt><dd>运行 SDB 调试器。</dd>
</dl>

<p>
上述每一个命令都会通过迷你缓冲区读取一条用于调用调试器的命令行。迷你缓冲区的初始内容包含该调试器的标准可执行文件名、运行选项，有时还会自动填充待调试可执行文件的猜测名称。该命令行中不允许使用 Shell 通配符和环境变量。Emacs 会将命令行中第一个不以短横线 "-" 开头的参数识别为待调试的可执行文件名。
</p>

<p>
Tramp 工具提供了远程调试功能，可让调试器与待调试程序运行在同一台远程主机上。具体细节参见《Tramp 手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/tramp/Running-a-debugger-on-a-remote-host.html#Running-a-debugger-on-a-remote-host">在远程主机上运行调试器</a>章节。此功能与 GDB 自身的远程调试特性相区分 ——GDB 原生远程调试支持调试器与待调试程序运行在不同的机器上（参见《GNU 调试器手册》中的<a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Remote-Debugging.html#Remote-Debugging">调试远程程序</a>章节）。
</p>
</div>
</div>
<div id="outline-container-Debugger-Operation" class="outline-4">
<h4 id="Debugger-Operation"><span class="section-number-4">29.6.2.</span> 调试器操作</h4>
<div class="outline-text-4" id="text-Debugger-Operation">
<p>
<i>GUD interaction buffer</i> GUD 交互缓冲区是 Emacs 的专用缓冲区，用于向调试器子进程发送文本命令并记录其输出结果。这是与调试器交互的基础接口， <code>M-x gud-gdb</code> 及《<a href="#Starting-GUD">启动 GUD</a>》章节中列出的其他命令均会使用该接口。而 <code>M-x gdb</code> 命令对该接口进行了扩展，新增了多个专用缓冲区，分别用于控制断点、栈帧及调试器状态的其他相关项（参见<a href="#GDB-Graphical-Interface">GDB 图形化接口</a>章节）。
</p>

<p>
GUD 交互缓冲区采用 Shell 模式的变体，因此 Shell 模式下定义的所有 Emacs 命令均能在此使用（参见《<a href="#Shell-Mode">Shell 模式</a>》）。绝大多数调试器命令都支持补全功能（参见《<a href="#Completion">命令补全</a>》），你也可以使用 Shell 模式常规的历史命令功能重复执行调试命令。关于可在 GUD 交互缓冲区中使用的专用命令，详见<a href="#Commands-of-GUD">GUD相关命令</a>章节。
</p>

<p>
调试程序时，Emacs 会通过在缓冲区中打开相关源文件的方式展示代码， <b>左侧边缘区</b> 会显示一个箭头，指向当前程序的执行行（在文本终端中，该箭头会以 "=&gt;" 的形式显示，覆盖在文本的前两列位置）。在该缓冲区中移动光标，并不会改变箭头的位置。你可以随意编辑这些源文件，但需注意：插入或删除代码行会导致箭头定位失效，因为 Emacs 无法判断编辑后的源代码行，与调试器子进程报告的执行行存在怎样的对应关系。若要更新执行行的定位信息，通常需要重新编译并重启程序。
</p>

<p>
此外，GUD 还能通过两种方式之一，在窗口文本内为当前执行行添加视觉标记：
</p>
<ul class="org-ul">
<li>若启用用户选项 <code>gud-highlight-current-line</code> ，会为当前执行行添加一个覆盖层，其显示样式由 <code>gud-highlight-current-line-face</code> 面版定义；</li>
<li>若启用高亮行模式（HL Line Mode，参见《<a href="#Cursor-Display">光标显示</a>》），会将该模式生成的覆盖层临时移至当前执行行，直至执行后续的编辑命令，覆盖层才会重新回到光标所在行。</li>
</ul>

<p>
GUD 工具提示模式是一款全局次模式，为 GUD 增加了工具提示支持，键入 <code>M-x gud-tooltip-mode</code> 可切换该模式的开启 / 关闭状态，其默认处于禁用状态。启用后，将鼠标指针移至变量、函数或宏（统称标识符）上方时，会在工具提示中显示其对应的值（参见《<a href="#Tooltips">工具提示</a>》）。若仅将鼠标指针悬停在表达式上，未显示预期的表达式值，可通过鼠标拖动选中该表达式，且保持鼠标指针停留在选中区域内，以此明确告知 Emacs 需要计算的表达式。GUD 工具提示模式会在 GUD 交互缓冲区，以及所有主模式包含在变量 <code>gud-tooltip-modes</code> 中的源文件缓冲区中生效。若禁用该模式，标识符的值会显示在回显区，而非工具提示中。
</p>

<p>
在 <code>M-x gud-gdb</code> 中使用 GUD 工具提示模式时，GDB 中显示表达式的值有时会展开宏，这可能会对被调试的程序造成 <b>副作用</b> ，因此 <code>gud-gdb</code> 中默认禁用了工具提示功能。而在 <code>M-x gdb</code> 接口中则不存在该问题 —— 该接口包含专门的代码以避免副作用，此外，即便程序未处于执行状态，你也能通过该接口查看与标识符关联的宏定义。
</p>
</div>
</div>
<div id="outline-container-Commands-of-GUD" class="outline-4">
<h4 id="Commands-of-GUD"><span class="section-number-4">29.6.3.</span> GUD 调试器命令</h4>
<div class="outline-text-4" id="text-Commands-of-GUD">
<p>
GUD 提供了设置 / 清除断点、选择栈帧以及单步执行程序的相关命令。
</p>

<dl class="org-dl">
<dt><code>C-x C-a C-b</code></dt><dd>在光标所在的源代码行设置断点(<code>gud-break</code>)。</dd>
</dl>

<p>
在源码缓冲区中调用该命令 (<code>gud-break</code>) ，会在当前源代码行设置调试器断点，此命令仅在启动 GUD 后可用；若在未关联任何调试器子进程的缓冲区中调用，将触发错误。
</p>

<p>
以下命令可在 GUD 交互缓冲区和全局环境中使用，但绑定的快捷键不同：以 <code>C-c</code> 开头的快捷键仅在 GUD 交互缓冲区生效，以 <code>C-x C-a</code> 开头的快捷键为全局生效。其中部分命令也可通过工具栏调用，部分命令并非所有调试器都支持。
</p>

<dl class="org-dl">
<dt><code>C-c C-l</code></dt><dd></dd>

<dt><code>C-x C-a C-l</code></dt><dd>在新窗口中显示 GUD 交互缓冲区中最近引用的源代码行 (<code>gud-refresh</code>) 。</dd>
<dt><code>C-c C-s</code></dt><dd></dd>

<dt><code>C-x C-a C-s</code></dt><dd>执行下一行代码 (<code>gud-step</code> ，单步进入) 。若该行包含函数调用，程序会在进入被调用函数后暂停。</dd>
<dt><code>C-c C-n</code></dt><dd></dd>

<dt><code>C-x C-a C-n</code></dt><dd>执行下一行代码，跳过函数调用且不在函数内部暂停 (<code>gud-next</code> ，单步跳过) 。</dd>
<dt><code>C-c C-i</code></dt><dd></dd>

<dt><code>C-x C-a C-i</code></dt><dd>执行单条机器指令（gud-stepi，单步执行指令）。</dd>
<dt><code>C-c C-p</code></dt><dd></dd>

<dt><code>C-x C-a C-p</code></dt><dd>计算光标所在位置的表达式值（gud-print，打印表达式）。若 Emacs 未能识别你需要计算的准确表达式，可先将其标记为选区。</dd>
<dt><code>C-c C-r</code></dt><dd></dd>

<dt><code>C-x C-a C-r</code></dt><dd>继续执行程序，无需指定暂停点（gud-cont，继续执行）。程序会持续运行，直至触发断点、执行终止，或接收到调试器正在监听的信号。</dd>
<dt><code>C-c C-d</code></dt><dd></dd>

<dt><code>C-x C-a C-d</code></dt><dd>删除当前源代码行上的所有断点（若存在）（gud-remove，移除断点）。若在 GUD 交互缓冲区中调用该命令，将作用于程序上一次暂停的代码行。</dd>
<dt><code>C-c C-t</code></dt><dd></dd>

<dt><code>C-x C-a C-t</code></dt><dd>在当前源代码行设置临时断点（若存在）（gud-tbreak，临时断点）。若在 GUD 交互缓冲区中调用该命令，将作用于程序上一次暂停的代码行。</dd>
<dt><code>C-c &lt;</code></dt><dd></dd>

<dt><code>C-x C-a &lt;</code></dt><dd>选择外层的下一个栈帧（gud-up，上移栈帧），等效于 GDB 中的 up 命令。</dd>
<dt><code>C-c &gt;</code></dt><dd></dd>

<dt><code>C-x C-a &gt;</code></dt><dd>选择内层的下一个栈帧（gud-down，下移栈帧），等效于 GDB 中的 down 命令。</dd>
<dt><code>C-c C-u</code></dt><dd></dd>

<dt><code>C-x C-a C-u</code></dt><dd>继续执行程序至当前光标所在行（gud-until，执行至指定行）。程序会持续运行，直至触发断点、执行终止、接收到调试器正在监听的信号，或运行到光标当前所在行。</dd>
<dt><code>C-c C-f</code></dt><dd></dd>

<dt><code>C-x C-a C-f</code></dt><dd>运行程序，直至选中的栈帧执行返回，或因其他原因暂停（gud-finish，执行至函数结束）。</dd>
</dl>

<p>
<b>GDB 专属快捷键</b>
</p>

<p>
若使用 GDB 调试器，还可使用以下附加快捷键：
</p>

<dl class="org-dl">
<dt><code>C-x C-a C-j</code></dt><dd>仅在源码缓冲区中生效， <code>gud-jump</code> 会将程序的执行点跳转到当前光标所在行。即程序下一行执行的代码，为调用该命令时光标所在的行。若新的执行行与上一行属于不同函数，GDB 会弹出确认提示（因该操作可能导致程序执行结果异常），详细说明可参考 GDB 手册中关于 <code>jump</code> 命令的章节。</dd>
<dt><code>TAB</code></dt><dd>在 GDB 中补全符号名（gud-gdb-complete-command，符号补全），该快捷键仅在 GUD 交互缓冲区中生效。</dd>
</dl>

<p>
补充说明
</p>
<ul class="org-ul">
<li>上述命令中，若数字参数具备实际意义，可将其视为命令的重复执行次数。</li>
<li>由于 TAB 键被用作补全命令，在使用 GDB 调试时，无法直接用其向被调试程序输入制表符，需输入 <code>C-q TAB</code> 来插入制表符。</li>
</ul>
</div>
</div>
<div id="outline-container-GUD-Customization" class="outline-4">
<h4 id="GUD-Customization"><span class="section-number-4">29.6.4.</span> GUD 调试器定制</h4>
<div class="outline-text-4" id="text-GUD-Customization">
<p>
GUD 启动时会运行下述钩子函数之一：使用 GDB 时执行 <code>gdb-mode-hook</code> ；使用 DBX 时执行 <code>dbx-mode-hook</code> ；使用 SDB 时执行 <code>sdb-mode-hook</code> ；使用 XDB 时执行 <code>xdb-mode-hook</code> ；调试 Guile 交互式解释器时执行 <code>guiler-mode-hook</code> ；Perl 调试模式下执行 <code>perldb-mode-hook</code> ；PDB 调试模式下执行 <code>pdb-mode-hook</code> 。详见钩子函数相关说明。
</p>

<p>
Lisp 宏 <code>gud-def</code> （参见《Emacs Lisp 参考手册》中<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Defining-Macros.html#Defining-Macros">宏定义</a>相关章节）提供了一种便捷方式，可定义向调试器发送指定命令字符串的 Emacs 命令，并为其在 GUD 交互缓冲区中配置按键绑定，语法如下：
</p>

<div class="org-src-container">
<pre class="src src-shell">(gud-def <span style="color: #a020f0;">function</span> <span style="color: #0000ff;">cmdstring</span> binding docstring)
</pre>
</div>

<p>
该宏定义一个名为 <i>function</i> 的命令，功能为向调试器进程发送字符串 <i>cmdstring</i> ，并为其添加说明文档字符串 <i>docstring</i> 。定义完成后，可在任意缓冲区中调用该 <i>function</i> 命令。若 <i>binding</i> 参数非空， <code>gud-def</code> 还会将该命令绑定至 GUD 缓冲区模式下的 <code>C-c binding</code> 快捷键，同时全局绑定为 <code>C-x C-a binding</code> 快捷键。
</p>

<p>
命令字符串 <i>cmdstring</i> 中可包含特定的 <code>%</code> 格式序列，这类序列会在 <i>function</i> 命令被调用时填充对应数据，各格式序列含义如下：
</p>
<dl class="org-dl">
<dt><code>%f</code></dt><dd>当前源文件的文件名。若当前缓冲区为 GUD 缓冲区，则指程序暂停执行时所在的源文件。</dd>
<dt><code>%l</code></dt><dd>当前源文件的行号。若当前缓冲区为 GUD 缓冲区，则指程序暂停执行时所在的代码行号。</dd>
<dt><code>%e</code></dt><dd>若开启临时标记模式且选区处于激活状态，为选区中的文本；否则为光标所在位置或相邻位置的 C 语言左值或函数调用表达式文本。</dd>
<dt><code>%a</code></dt><dd>光标所在位置或相邻位置的十六进制地址文本。</dd>
<dt><code>%p</code></dt><dd><p>
被调用函数的数字参数，以十进制数表示。若调用命令时未传入数字参数， <code>%p</code> 将被替换为空字符串。
</p>

<p>
若命令字符串中未使用 <code>%p</code> ，则所定义的命令会忽略所有传入的数字参数。
</p></dd>
<dt><code>%d</code></dt><dd>当前源文件所在的目录名。</dd>
<dt><code>%c</code></dt><dd>由光标周围的表达式推导得到的全限定类名（仅适用于 JDB 调试器）。</dd>
</dl>
</div>
</div>
<div id="outline-container-GDB-Graphical-Interface" class="outline-4">
<h4 id="GDB-Graphical-Interface"><span class="section-number-4">29.6.5.</span> GDB 图形界面</h4>
<div class="outline-text-4" id="text-GDB-Graphical-Interface">
<p>
<code>M-x gdb</code> 命令会以类集成开发环境（IDE）的界面启动 GDB，同时创建专用缓冲区，用于管理断点、栈帧及调试器状态的其他相关内容。该界面还支持通过鼠标操控调试会话，例如在源码缓冲区的页边区域点击，即可在对应位置设置断点。
</p>

<p>
若仅需使用 GUD 交互缓冲区界面运行 GDB，而不启用上述附加功能，可执行 <code>M-x gud-gdb</code> 命令（参见<a href="#Starting-GUD">启动 GUD</a>相关章节）。
</p>

<p>
在内部实现上， <code>M-x gdb</code> 会告知 GDB 其屏幕显示尺寸无限制；为保证调试正常运行，在调试会话期间请勿修改 GDB 的屏幕高度和宽度参数。
</p>
</div>
<div id="outline-container-GDB-User-Interface-Layout" class="outline-5">
<h5 id="GDB-User-Interface-Layout"><span class="section-number-5">29.6.5.1.</span> GDB 图形界面布局</h5>
<div class="outline-text-5" id="text-GDB-User-Interface-Layout">
<p>
若变量gdb-many-windows的值为nil（默认设置），执行M-x gdb通常仅显示 GUD 交互缓冲区。而若变量gdb-show-main的值非nil，启动时会打开两个窗口：一个显示 GUD 交互缓冲区，另一个展示待调试程序中main函数的源码。
</p>

<p>
若gdb-many-windows的值非nil，执行M-x gdb会显示如下窗口布局
</p>


<div class="org-src-container">
<pre class="src src-org"><span style="color: #0000ff;">+-------------------------+--------------------------------+</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|   GUD &#20132;&#20114;&#32531;&#20914;&#21306;        |   &#26412;&#22320;&#21464;&#37327; / &#23492;&#23384;&#22120;&#32531;&#20914;&#21306;      |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">+-------------------------+--------------------------------+</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|      &#20027;&#28304;&#30721;&#32531;&#20914;&#21306;       | &#34987;&#35843;&#35797;&#31243;&#24207;&#30340;&#36755;&#20837; / &#36755;&#20986;&#32531;&#20914;&#21306;  |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">+-------------------------+--------------------------------+</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">|      &#26632;&#32531;&#20914;&#21306;           |    &#26029;&#28857; / &#32447;&#31243;&#32531;&#20914;&#21306;           |</span><span style="color: #0000ff;">
</span><span style="color: #0000ff;">+-------------------------+--------------------------------+</span>
</pre>
</div>

<p>
你可基于上述布局自定义窗口样式，并通过 <code>gdb-save-window-configuration</code> 将该布局保存至文件，后续可使用 <code>gdb-load-window-configuration</code> 重新加载该布局。（Emacs 内部使用 <b>term window configuration 窗口配置</b> 一词，而非 <b>window layout窗口布局</b> 。）通过自定义变量 <code>gdb-default-window-configuration-file</code> ，可将你的自定义布局设为 <code>gdb-many-windows</code> 使用的默认布局。若该变量指定的并非绝对文件名，GDB 会在 <code>gdb-window-configuration-directory</code> 目录下查找该文件，此目录的默认值为 <code>user-emacs-directory</code> （参见《<a href="#Find-Init">Emacs 如何查找初始化文件</a>》章节）。
</p>

<p>
若你修改了窗口布局，可输入 <code>M-x gdb-restore-windows</code> 恢复默认布局。输入 <code>M-x gdb-many-windows</code> 可在 <b>多窗口布局</b> 与 <b>简易布局</b> 间切换，简易布局仅包含 GUD 交互缓冲区和一个源码文件窗口。
</p>

<p>
若你已有复杂的窗口配置，且不想让 <code>gdb-many-windows</code> 破坏该配置，建议在独立的 Emacs 框架中执行 <code>M-x gdb</code> ，这样原有框架的窗口布局就不会受到影响。在纯文本模式终端中工作时，为 GDB 调试会话单独创建一个框架会格外实用 —— 这类终端的窗口显示空间通常十分宝贵。若你选择在原有框架中启动 GDB，可将变量 <code>gdb-restore-window-configuration-after-quit</code> 设为非nil值，这样 GDB 退出后，Emacs 会自动恢复你原本的窗口布局。该变量可设为以下值：设为 <code>t</code> 则始终恢复原有布局；设为 <code>if-gdb-many-windows</code> 则仅当 <code>gdb-many-windows</code> 非nil时恢复；设为 <code>if-gdb-show-main</code> 则仅当 <code>gdb-show-main</code> 非nil时恢复。
</p>

<p>
你也可指定额外的 GDB 相关缓冲区进行显示，这些缓冲区可置于当前框架，也可置于其他独立框架。输入 <code>M-x gdb-display-&lt;buffertype&gt;-buffer</code> 或 <code>M-x gdb-frame-&lt;buffertype&gt;-buffer</code> 即可选择要显示的缓冲区（其中 <code>&lt;buffertype&gt;</code> 为缓冲区类型，如breakpoints（断点）、io（输入输出）等）。你也可通过菜单栏操作：在GUD菜单下的 'GDB-Windows' 和 'GDB-Frames' 子菜单中完成上述操作。
</p>

<p>
默认情况下，GDB 最多仅使用一个窗口显示源码文件。通过自定义变量 <code>gdb-max-source-window-count</code> ，可让 GDB 使用更多窗口显示源码；同时也可自定义 <code>gdb-display-source-buffer-action</code> ，以此控制 GDB 显示源码文件的方式。
</p>

<p>
调试结束后，可使用 <code>C-x k</code> 关闭 GUD 交互缓冲区，该操作会同时关闭所有与本次调试会话关联的缓冲区。但如果在 Emacs 中编辑并重新编译源码后，你希望继续调试，则无需执行此关闭操作：重启程序执行时，GDB 会自动找到新的可执行文件。保留 GUD 交互缓冲区的优势在于，可同时保留 Shell 命令历史记录和 GDB 中设置的所有断点。你仅需检查近期编辑过的源码文件中，断点是否仍处于正确位置即可。
</p>
</div>
</div>
<div id="outline-container-Source-Buffers" class="outline-5">
<h5 id="Source-Buffers"><span class="section-number-5">29.6.5.2.</span> 源代码缓冲区</h5>
<div class="outline-text-5" id="text-Source-Buffers">
<dl class="org-dl">
<dt><code>mouse-1</code> （点击页边区）</dt><dd>在对应行设置或清除断点 (<code>gdb-mouse-set-clear-breakpoint</code>) 。</dd>
<dt><code>C-mouse-1</code> （点击页边区）</dt><dd>启用或禁用对应行的断点 (<code>gdb-mouse-toggle-breakpoint-margin</code>) 。</dd>
<dt><code>mouse-3</code> （点击页边区）</dt><dd>继续执行程序至对应行 (<code>gdb-mouse-until</code>) 。</dd>
<dt><code>C-mouse-3</code> （点击页边区）</dt><dd>将程序执行点跳转到对应行 (<code>gdb-mouse-jump</code>) 。</dd>
</dl>

<p>
在图形化显示界面中，可在源码缓冲区的页边区点击鼠标左键（mouse-1），为对应行设置断点（参见《<a href="#Fringes">窗口页边</a>》相关章节）。点击位置的页边区会出现一个红点，若该位置已存在断点，点击操作会将其清除。 <code>C-mouse-1</code> 可启用或禁用已存在的断点；已禁用但未清除的断点，会在页边区以灰点标识。
</p>

<p>
在文本终端中，或页边区被禁用时，已启用的断点会在窗口左边界以字符 'B' 标识，已禁用的断点则以字符 'b' 标识（仅当存在断点时，该边界标识才会显示）。
</p>

<p>
源码缓冲区左页边区的 <b>实心箭头</b> ，标识被调试程序暂停时，最内层栈帧对应的代码行； <b>空心箭头</b> 则标识高层级栈帧的当前执行行。若按住 <code>mouse-1</code> 鼠标左键拖动页边区的箭头，释放鼠标时，程序会执行至箭头释放位置对应的行。也可在页边区点击鼠标右键（mouse-3），让程序执行至对应行；按住 <code>C-mouse-3</code> 可直接跳转到对应行，无需执行中间的代码行。该跳转命令支持回退执行，可用于重新运行已执行过的代码，以便更细致地检查其执行过程。
</p>

<p>
默认情况下，被调试程序中的源文件名和非 ASCII 字符串，会通过 Emacs 默认编码系统解码。若需要使用其他编码解码（例如被调试程序采用了不同的字符编码），可将变量 <code>gdb-mi-decode-strings</code> 设为对应的编码系统；若将该变量设为 <code>nil</code> ，非 ASCII 字符会保留为未解码的八进制转义序列。
</p>
</div>
</div>
<div id="outline-container-Breakpoints-Buffer" class="outline-5">
<h5 id="Breakpoints-Buffer"><span class="section-number-5">29.6.5.3.</span> 断点缓冲区</h5>
<div class="outline-text-5" id="text-Breakpoints-Buffer">
<p>
GDB 断点缓冲区会显示调试会话中的断点、观察点和捕获点（详见《GNU 调试器》中的<a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Breakpoints.html#Breakpoints">断点</a>相关章节）。该缓冲区提供下述命令，且这些命令大多作用于当前断点（即光标所在位置的断点）：
</p>
<dl class="org-dl">
<dt><code>SPC</code></dt><dd>启用 / 禁用当前断点 (<code>gdb-toggle-breakpoint</code>) 。在图形化显示界面中，此操作会改变对应源码行页边区断点标识点的颜色：断点启用时标识点为红色，禁用时为灰色。</dd>
<dt><code>D</code></dt><dd>删除当前断点 (<code>gdb-delete-breakpoint</code>) 。</dd>
<dt><code>RET</code></dt><dd>跳转到当前断点对应的源码行 (<code>gdb-goto-breakpoint</code>) 。</dd>
<dt><code>mouse-2</code></dt><dd>跳转到鼠标点击位置的断点对应的源码行 (<code>gdb-goto-breakpoint</code>) 。</dd>
</dl>

<p>
当变量 <code>gdb-many-windows</code> 值为非nil时，GDB 断点缓冲区与 GDB 线程缓冲区共用同一个窗口。可通过在窗口标题行的对应按钮上点击 <code>mouse-1</code> ，实现两个缓冲区之间的切换。若变量 <code>gdb-show-threads-by-default</code> 值为非nil，则默认显示 GDB 线程缓冲区。
</p>
</div>
</div>
<div id="outline-container-Threads-Buffer" class="outline-5">
<h5 id="Threads-Buffer"><span class="section-number-5">29.6.5.4.</span> 线程缓冲区</h5>
<div class="outline-text-5" id="text-Threads-Buffer">
<p>
GDB 线程缓冲区会展示被调试程序中所有线程的概览信息（详见《GNU 调试器》中的<a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Threads.html#Threads">多线程程序调试</a>章节）。选中线程的操作方式为：将光标移至对应线程行并按下 <code>RET</code> 回车键 (<code>gdb-select-thread</code>) ，或使用 <code>mouse-2</code> 鼠标中键点击该线程行。执行选中操作后，Emacs 会同步显示该线程对应的源码缓冲区，并更新其他所有 GDB 相关缓冲区的内容。
</p>

<p>
你可通过自定义 <code>gdb-buffers</code> 配置组中的相关变量，选择线程缓冲区中需要展示的信息字段：
</p>
<dl class="org-dl">
<dt><code>gdb-thread-buffer-verbose-names</code></dt><dd>展示线程的完整名称，格式示例： 'Thread 0x4e2ab70 (LWP 1983)' 。</dd>
<dt><code>gdb-thread-buffer-arguments</code></dt><dd>展示各线程顶层栈帧的入参信息。</dd>
<dt><code>gdb-thread-buffer-locations</code></dt><dd>展示线程对应的文件信息或库名称。</dd>
<dt><code>gdb-thread-buffer-addresses</code></dt><dd>在线程缓冲区中展示各线程栈帧的内存地址。</dd>
</dl>

<p>
若需同时查看多个线程的详细信息，可在 GDB 线程缓冲区中执行以下命令，所有命令均作用于光标当前所在的线程行：
</p>
<dl class="org-dl">
<dt><code>d</code></dt><dd>为当前线程展示反汇编缓冲区 (<code>gdb-display-disassembly-for-thread</code>) 。</dd>
<dt><code>f</code></dt><dd>为当前线程展示 GDB 栈缓冲区 (<code>gdb-display-stack-for-thread</code>) 。</dd>
<dt><code>l</code></dt><dd>为当前线程展示 GDB 本地变量缓冲区 (<code>gdb-display-locals-for-thread</code>) 。</dd>
<dt><code>r</code></dt><dd>为当前线程展示 GDB 寄存器缓冲区 (<code>gdb-display-registers-for-thread</code>) 。</dd>
</dl>

<p>
上述命令对应的大写形式D、F、L、R，会在新的 Emacs 帧中打开对应的缓冲区。
</p>

<p>
当你为某一特定线程创建专属信息缓冲区后，该缓冲区会与该线程建立绑定关系；在后续调试过程中，该缓冲区会持续展示此线程的实时信息。每个 GDB 缓冲区的模式指示区，都会标注出该缓冲区所绑定的线程编号；同时，该线程编号也会包含在所有绑定缓冲区的名称中，便于识别。
</p>

<p>
GDB 线程缓冲区中还提供了其他调试命令，这类命令的功能取决于用于控制程序执行的 GDB 运行模式，相关说明详见<a href="#Multithreaded-Debugging">多线程调试</a>章节。
</p>
</div>
</div>
<div id="outline-container-Stack-Buffer" class="outline-5">
<h5 id="Stack-Buffer"><span class="section-number-5">29.6.5.5.</span> 堆栈缓冲区</h5>
<div class="outline-text-5" id="text-Stack-Buffer">
<p>
GDB 栈缓冲区用于展示程序的调用栈，调试会话中每一层嵌套的子程序调用（ <i>stack frames栈帧</i> ）各占一行显示（详见《GNU 调试器》中的<a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Backtrace.html#Backtrace">回溯信息</a>相关章节）。
</p>

<p>
在图形化显示界面中，已选中的栈帧会在页边区以箭头标识；在文本终端中，或页边区被禁用时，已选中的栈帧会以反色显示。选中栈帧的操作方式为：将光标移至对应栈帧行并按下 <code>RET</code> 回车键 (<code>gdb-frames-select</code>) ，或用 <code>mouse-2</code> 鼠标中键点击该栈帧行。执行此操作后，本地变量缓冲区的内容也会同步更新（参见<a href="#Other-GDB-Buffers">其他 GDB 缓冲区</a>章节）。
</p>

<p>
若希望在每个栈帧行旁显示帧地址，可将变量 <code>gdb-stack-buffer-addresses</code> 自定义设为非 nil 值。
</p>
</div>
</div>
<div id="outline-container-Other-GDB-Buffers" class="outline-5">
<h5 id="Other-GDB-Buffers"><span class="section-number-5">29.6.5.6.</span> 其他 GDB 缓冲区</h5>
<div class="outline-text-5" id="text-Other-GDB-Buffers">
<p>
执行 <code>M-x gdb</code> 后可按需调出的其他缓冲区包括以下几类：
</p>

<dl class="org-dl">
<dt>Locals Buffer 本地变量缓冲区</dt><dd><p>
该缓冲区展示当前栈帧中简单数据类型的本地变量值（详见《GNU 调试器》中<a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Frame-Info.html#Frame-Info">帧的相关信息</a>章节）。若需编辑变量值，可将光标移至对应值处按下回车键，或用鼠标中键点击该值。
</p>

<p>
数组与结构体类型仅展示类型信息，不显示具体值。在 GDB 6.4 及更高版本中，将光标移至本地变量处按回车键或鼠标中键点击，即可查看其具体值；在更早的 GDB 版本中，需在类型描述（'<code>[struct/union]</code>' （结构体 / 联合体）或 '<code>[array]</code>' （数组））上执行 <code>RET</code> 回车键或 <code>mouse-2</code> 鼠标中键点击操作。相关说明详见<a href="#Watch-Expressions">监视表达式</a>章节。
</p>

<p>
调出本地变量缓冲区的命令： <code>M-x gdb-display-locals-buffer</code> 。
</p></dd>

<dt>I/O Buffer 输入输出缓冲区</dt><dd>若被调试程序通过标准输入输出流与用户交互，或向标准输出打印大量内容，可将程序的输入输出与 GDB 的交互操作分离。执行命令 <code>M-x gdb-display-io-buffer</code> ，Emacs 会调出独立窗口和缓冲区，并重定向被调试程序的所有输入输出至该缓冲区。若变量 <code>gdb-display-io-buffer</code> 设为 <code>nil</code> ，Emacs 则不会创建和显示独立的输入输出缓冲区，程序的输入输出会直接重定向至 GUD 交互缓冲区。</dd>

<dt>Registers Buffer 寄存器缓冲区</dt><dd>该缓冲区展示处理器寄存器中存储的值（详见《GNU 调试器》中<a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Registers.html#Registers">寄存器</a>章节），调出命令为 <code>M-x gdb-display-registers-buffer</code> 。若需编辑寄存器值，可将光标移至对应寄存器处按回车键，或用鼠标中键点击。在 GDB 6.4 及更高版本中，近期被修改的寄存器值会以语法高亮警告样式显示。</dd>

<dt>Assembler Buffer 汇编缓冲区</dt><dd>该缓冲区以机器码形式展示当前栈帧的内容，其中有箭头指向当前执行的指令，且支持像源码缓冲区一样设置和清除断点，断点标识也会显示在页边区或边界处。调出该缓冲区的命令： <code>M-x gdb-display-disassembly-buffer</code> 。</dd>

<dt>Memory Buffer 内存缓冲区</dt><dd>该缓冲区可用于查看程序内存的指定区域（详见《GNU 调试器》中<a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Memory.html#Memory">查看内存</a>章节）。点击缓冲区标题行的对应区域，可修改缓冲区展示的内存起始地址或数据项数量，也可分别通过快捷键 <code>S</code> 和 <code>N</code> 完成上述操作；在标题行点击 <code>mouse-3</code> 鼠标右键，可选择数据项的展示格式和单位大小。调出内存缓冲区的命令： <code>M-x gdb-display-memory-buffer</code> 。</dd>
</dl>

<p>
当变量 <code>gdb-many-windows</code> 设为非nil值时，本地变量缓冲区与寄存器缓冲区会共用一个窗口，与断点缓冲区和线程缓冲区的窗口复用方式一致。可通过在窗口标题行的对应按钮上点击 <code>mouse-1</code> 鼠标左键，实现两个缓冲区之间的切换。
</p>
</div>
</div>
<div id="outline-container-Watch-Expressions" class="outline-5">
<h5 id="Watch-Expressions"><span class="section-number-5">29.6.5.7.</span> 监视表达式</h5>
<div class="outline-text-5" id="text-Watch-Expressions">
<p>
若你希望查看程序每次暂停时某个变量的变化情况，可将光标移至该变量名处，点击工具栏中的监视图标(<code>gud-watch</code>) ，或按下快捷键 <code>C-x C-a C-w</code> 。若指定前缀参数，可在迷你缓冲区中手动输入待监视的变量名。
</p>

<p>
所有监视表达式均会显示在速览栏中（参见《<a href="#Speedbar">速览栏</a>》章节）。数组、结构体、联合体等复杂数据类型会以树形结构展示：叶子节点与简单数据类型会显示表达式名称及其值，且当选中速览栏时，鼠标悬停会以工具提示形式显示其类型；上层节点中，指针类型会显示名称、类型和地址值，其他类型则仅显示名称与类型；根表达式还会将帧地址作为工具提示展示，助力识别其定义所在的栈帧。
</p>

<p>
展开或折叠复杂数据类型的操作：在表达式左侧的标签处点击 <code>mouse-2</code> 鼠标中键，或按下 <code>SPC</code> 空格键即可。若某表达式的直接子节点数量超过变量 <code>gdb-max-children</code> 的取值，Emacs 会在展开该表达式前弹出确认提示。
</p>

<p>
删除复杂监视表达式的操作：将光标移至速度条中该表达式的根节点处，按下 <code>D</code> 键 (<code>gdb-var-delete</code>) 即可。
</p>

<p>
编辑简单数据类型变量或复杂数据类型中简单元素的操作：将光标移至速度条中对应位置并按下 <code>RET</code> 回车键 (<code>gdb-edit-value</code>) ，或用 <code>mouse-2</code> 鼠标中键点击对应值，两种方式均会通过迷你缓冲区读取你输入的新值。
</p>

<p>
若将变量 <code>gdb-show-changed-values</code> 设为非nil值（默认配置），Emacs 会用语法高亮警告样式突出显示近期发生变化的值，并使用阴影样式弱化显示已超出作用域的变量。变量超出作用域后，其值将无法被编辑。
</p>

<p>
若将变量 <code>gdb-delete-out-of-scope</code> 设为非nil值（默认配置），Emacs 会自动删除已超出作用域的监视表达式。当程序多次重新进入同一函数时，可将该变量设为nil，无需重新创建监视表达式，该设置会更实用。
</p>

<p>
若将变量 <code>gdb-use-colon-colon-notation</code> 设为非nil值，Emacs 会采用 'function::variable' 的命名格式，支持用户显示同名的监视表达式，该变量默认值为 <code>nil</code> 。
</p>

<p>
若希望监视表达式的显示内容每次更新时，速度条都自动置顶显示，可将变量 <code>gdb-speedbar-auto-raise</code> 设为非nil值。在使用全屏 Emacs 帧进行调试时，该设置会尤为实用。
</p>
</div>
</div>
<div id="outline-container-Multithreaded-Debugging" class="outline-5">
<h5 id="Multithreaded-Debugging"><span class="section-number-5">29.6.5.8.</span> 多线程调试</h5>
<div class="outline-text-5" id="text-Multithreaded-Debugging">
<p>
在 GDB 的全停止模式下，程序暂停时所有执行线程都会停止；同理，重启程序时所有线程也会一并开始执行。详见《GNU 调试器手册》中的「<a href="https://sourceware.org/gdb/current/onlinedocs/gdb/All_002dStop-Mode.html#All_002dStop-Mode">全停止模式</a>」章节。对于部分多线程目标程序，GDB 还支持一种进阶运行模式 —— 非停止模式，该模式下调试器可查看已暂停的程序线程，同时其他线程能不受干扰地继续执行。详见《GNU 调试器手册》中的「<a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Non_002dStop-Mode.html#Non_002dStop-Mode">非停止模式</a>」章节。GDB 7.0 之前的版本不支持非停止模式，且该模式并非对所有目标程序都适用。
</p>

<p>
变量 <code>gdb-non-stop-setting</code> 用于决定 Emacs 以全停止模式还是非停止模式运行 GDB，默认值为 <code>t</code> ，即若目标环境支持非停止模式，则优先启用。若将该值改为 <code>nil</code> ，或当前环境不支持非停止模式，Emacs 会以全停止模式运行 GDB。此变量仅在 Emacs 启动调试会话时生效，若修改其值，需重启当前所有活跃的调试会话。
</p>

<p>
非停止模式下，当某个线程暂停时，Emacs 通常会自动切换至该线程。若希望当已有其他暂停线程被选中时，Emacs 不再执行此自动切换操作，可将变量 <code>gdb-switch-when-another-stopped</code> 设为 <code>nil</code> 。
</p>

<p>
Emacs 可根据线程的暂停原因，决定是否自动切换至该暂停线程。可自定义变量 <code>gdb-switch-reasons</code> ，指定触发线程自动切换的暂停原因。
</p>

<p>
变量 <code>gdb-stopped-functions</code> 支持在任意线程暂停时，执行自定义的函数。
</p>

<p>
非停止模式下，可切换 GUD 执行控制命令的作用模式，主要分为以下两种：
</p>

<dl class="org-dl">
<dt>Non-stop/A</dt><dd>当变量 <code>gdb-gud-control-all-threads</code> 为 <code>t</code> （默认值）时，中断和继续类命令会作用于所有线程：可分别使用 <code>gud-stop-subjob</code> 和 <code>gud-cont</code> 命令，一键暂停或继续所有线程。工具栏中，当至少有一个线程处于暂停状态时会显示「Go」按钮；当至少有一个线程处于运行状态时会显示「Stop」按钮。</dd>

<dt>Non-stop/T</dt><dd>当变量 <code>gdb-gud-control-all-threads</code> 为 <code>nil</code> 时，中断和继续类命令仅作用于当前线程。GUD 工具栏的「Go」和「Stop」按钮，会根据当前线程的状态显示。</dd>
</dl>

<p>
可通过工具栏，或「GUD -&gt; GDB-MI」菜单修改 <code>gdb-gud-control-all-threads</code> 的当前值。
</p>

<p>
单步调试命令始终仅作用于当前线程。
</p>

<p>
非停止模式下，无需选中线程即可对其执行中断 / 继续操作：在线程缓冲区中，按下 <code>i</code> 键可中断光标所在的线程，按下 <code>c</code> 键可继续该线程，按下 <code>s</code> 键可对该线程执行单步调试。未来可能会新增更多此类快捷命令。
</p>

<p>
注意：中断线程时，该线程会以「singnal received」为原因暂停。若该原因被包含在 <code>gdb-switch-reasons</code> 的配置中（默认包含），Emacs 会自动切换至该线程。
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-Executing-Lisp" class="outline-3">
<h3 id="Executing-Lisp"><span class="section-number-3">29.7.</span> 执行 Lisp 表达式</h3>
<div class="outline-text-3" id="text-Executing-Lisp">
<p>
Emacs 为多款 Lisp 方言提供了主模式，这些模式与其他编程语言模式使用相同的编辑命令（参见《<a href="#Programs">编辑程序</a>》章节），并额外提供了执行 Lisp 表达式的专用命令。
</p>

<dl class="org-dl">
<dt>Emacs Lisp mode</dt><dd>用于编辑 Emacs Lisp 源文件的模式，该模式将组合键 <code>C-M-x</code> 定义为求值当前顶级 Lisp 表达式的快捷键（参见《<a href="#Lisp-Eval">求值 Emacs Lisp 表达式</a>》章节）。</dd>

<dt>Lisp Interaction mode</dt><dd>用于 Emacs Lisp 交互式会话的模式，该模式将组合键 <code>C-j</code> 定义为求值光标前方的表达式，并将求值结果插入至缓冲区中（参见《<a href="#Lisp-Interaction">Lisp 交互缓冲区</a>》章节）。</dd>

<dt>Lisp mode</dt><dd>用于编辑非 Emacs Lisp 方言的 Lisp 程序源文件的模式，该模式将组合键 <code>C-M-x</code> 定义为在外部 Lisp 环境中求值当前顶级表达式的快捷键（参见《<a href="#External-Lisp">运行外部 Lisp 环境</a>》章节）。</dd>

<dt>Inferior Lisp mode</dt><dd>用于与外部 Lisp 进行交互式会话的模式，该外部 Lisp 作为 Emacs 的子进程（下级进程）运行（参见《<a href="#External-Lisp">运行外部 Lisp 环境</a>》章节）。</dd>

<dt>Scheme mode</dt><dd>功能与 Lisp 模式一致，专为 Scheme 程序设计。</dd>

<dt>Inferior Scheme mode</dt><dd>功能与下级 Lisp 模式一致，专为 Scheme 语言设计。</dd>
</dl>
</div>
</div>
<div id="outline-container-Lisp-Libraries" class="outline-3">
<h3 id="Lisp-Libraries"><span class="section-number-3">29.8.</span> Emacs Lisp 代码库</h3>
<div class="outline-text-3" id="text-Lisp-Libraries">
<p>
Emacs Lisp 代码存储在惯例以 <code>.el</code> 为后缀的文件中，此类文件被打开时会自动启用 Emacs Lisp 模式。
</p>

<p>
Emacs Lisp 代码可编译为 <b>byte-code字节码</b> ，字节码具有加载速度更快、占用空间更小、执行效率更高的特点。按照惯例，编译后的 Emacs Lisp 字节码会单独存放在以 '<code>.elc</code>' 为后缀的文件中，例如 <code>foo.el</code> 对应的字节码文件为 <code>foo.elc</code> 。相关详情参见《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Byte-Compilation.html#Byte-Compilation">字节编译</a>章节。
</p>

<p>
Emacs Lisp 代码也可编译为 <b>native code原生代码</b> ：这种机器码与 C 或 Fortran 编译器生成的代码并无本质区别，运行速度比字节码更快。原生编译后的 Emacs Lisp 代码存储在以 '<code>.eln</code>' 为后缀的文件中。相关详情参见《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Native-Compilation.html#Native-Compilation">原生编译</a>章节。
</p>

<p>
<b>加载 Emacs Lisp 文件</b>
</p>

<p>
键入 <code>M-x load-file</code> 可 <i>load加载</i> Emacs Lisp 文件，该命令会通过迷你缓冲区读取文件名，并将文件内容作为 Emacs Lisp 代码执行。执行此命令无需提前打开文件，它会直接从磁盘读取文件，而非从 Emacs 已有的缓冲区中读取。
</p>

<p>
若 Emacs Lisp 文件被安装在 Emacs Lisp <b><i>load path加载路径</i></b> （下文定义）中，可直接键入 <code>M-x load-library</code> 加载，无需使用 <code>load-file</code> 。 <code>load-library</code> 命令会提示输入 <b>libray name库名</b> 而非文件名，并在 Emacs Lisp 加载路径的所有目录中依次搜索，匹配与库名对应的文件。若库名为 'foo' ，该命令会依次查找 <code>foo.elc</code> 、 <code>foo.el</code> 和 <code>foo</code> 文件（若 Emacs 编译时启用了原生编译功能， <code>load-library</code> 会优先查找 <code>foo.el</code> 对应的 <code>.eln</code> 文件，并优先加载该文件而非 <code>foo.elc</code> ）。该命令的默认行为是加载 <b>第一个找到的文件</b> ，且优先级为： <code>.eln</code> 文件 ＞ <code>.elc</code> 文件 ＞ <code>.el</code> 文件，原因是编译后的文件加载和运行速度更快。
</p>

<p>
若检测到 <code>lib.el</code> 的修改时间晚于 <code>lib.elc</code> ，该命令会发出警告（防止开发者修改了 <code>.el</code> 源文件后忘记重新编译），但仍会加载 <code>lib.elc</code> 文件。借助这一特性，你可将未完成的编辑保存至 Emacs Lisp 源文件，待修改完成并准备投入使用后再进行编译。若将选项 <code>load-prefer-newer</code> 设置为非 nil 值，Emacs 会放弃上述查找规则，转而加载 <b>版本最新</b> 的文件。
</p>

<p>
若 Emacs 启用了原生编译功能，且未找到 <code>lib.el</code> 对应的 '.eln' 文件，会先加载 <code>lib.elc</code> ，并在后台启动 <code>lib.el</code> 的原生编译；待编译完成后，会自动加载生成的 <code>.eln</code> 文件。
</p>

<p>
Emacs Lisp 程序通常通过 <code>load</code> 函数加载 Emacs Lisp 文件，该函数与 <code>load-library</code> 功能类似，但属于更底层的实现，且支持传入额外参数。相关详情参见《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/How-Programs-Do-Loading.html#How-Programs-Do-Loading">程序的加载方式</a>章节。
</p>

<p>
<b>Emacs Lisp 加载路径</b>
</p>

<p>
Emacs Lisp 加载路径由变量 <code>load-path</code> 指定，其值应为 <b>目录字符串构成的列表</b> 。 <code>M-x load-library</code> 命令、底层的 <code>load</code> 函数，以及其他用于查找 Emacs Lisp 库的 Emacs 函数，都会按照该列表指定的顺序搜索这些目录。
</p>

<p>
<code>load-path</code> 中的项也可使用特殊值 <code>nil</code> ，代表当前默认目录，但 <b>几乎不建议使用该值</b> —— 因为其实际指向的目录会随 Emacs 中当前激活的缓冲区变化而改变。若你希望加载当前目录的文件，更合适的方式是使用 <code>M-x load-file</code> 。
</p>

<p>
<code>load-path</code> 的默认值为存储 Emacs 自身 Lisp 代码的目录列表。若你在其他目录中有自定义的代码库，可将该目录添加至加载路径。与本手册介绍的大多数变量不同， <code>load-path</code> 无法通过自定义界面修改（参见<a href="#Easy-Customization">简易自定义界面</a>章节），但可在初始化文件中添加如下语句实现目录添加（参见<a href="#Init-File">Emacs 初始化文件</a>章节）：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-to-list 'load-path <span style="color: #8b2252;">"/path/to/my/lisp/library"</span>)
</pre>
</div>

<p>
按照惯例，本地安装的代码库可放在 <code>site-lisp</code> 目录（该目录已包含在 <code>load-path</code> 的默认值中）或其任意子目录下，这样就无需修改 <code>load-path</code> 的默认值。
</p>

<p>
与 <code>load-path</code> 类似，Emacs 搜索原生编译 Lisp 代码（ <code>*.eln</code> 文件）的目录列表，由变量 <code>native-comp-eln-load-path</code> 指定。
</p>

<p>
<b>自动加载</b>
</p>

<p>
部分命令为 <b><i>autoloaded自动加载命令</i></b> ：当你运行此类命令时，Emacs 会先自动加载其关联的代码库。例如 <code>M-x compile</code> 命令（参见<a href="#Compilation">在 Emacs 中运行编译</a>章节）即为自动加载命令，调用该命令时，Emacs 会先自动加载编译相关的代码库。与之相反， <code>M-x recompile</code> 命令并非自动加载命令，因此在手动加载编译代码库前，该命令无法使用。
</p>

<p>
当你查阅自动加载命令的文档时（参见<a href="#Name-Help">按命令或变量名获取帮助</a>章节），若文档中引用了其代码库中的其他函数和变量，Emacs 也会触发自动加载（加载代码库后，Emacs 才能正确设置 <code>*Help*</code> 缓冲区中的超链接）。若要禁用该功能，可将变量 <code>help-enable-autoload</code> 设为 nil。
</p>

<p>
在为 <code>describe-variable</code> 和 <code>describe-function</code> 命令补全名称时，Emacs 也会根据补全的前缀触发自动加载。若要禁用该功能，可将变量 <code>help-enable-completion-autoload</code> 设为 <code>nil</code> 。
</p>

<p>
<b>让代码库在启动时可用</b>
</p>

<p>
将自定义代码库放在 Emacs 可查找并加载的目录后，你可能希望其在 Emacs 启动时即处于可用状态。当代码库定义的功能需要按需自动可用、手动加载又较为繁琐时，这一设置会非常实用。
</p>

<p>
可在初始化文件中添加合适的表达式，确保代码库被加载：若需要 <b>启动时始终加载</b> ，可使用 <code>load</code> 或 <code>require</code> ；若需要调用特定命令 / 函数时才加载，则使用 <code>autoload</code> 。示例如下：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#26080;&#26465;&#20214;&#21152;&#36733; my-shining-package.elc
</span>(<span style="color: #a020f0;">require</span> '<span style="color: #008b8b;">my-shining-package</span>)
<span style="color: #b22222;">;; </span><span style="color: #b22222;">&#35843;&#29992; my-func &#26102;&#25165;&#21152;&#36733; my-shining-package.elc
</span>(autoload 'my-func <span style="color: #8b2252;">"my-shining-package"</span>)
</pre>
</div>

<p>
注意：使用 <code>package-install</code> 安装包时（参见<a href="#Package-Installation">包安装</a>章节），Emacs 会自动将该包的 Lisp 文件放在可查找的目录中，并根据需要扩展 <code>load-path</code> ，因此对于通过该方式安装的包，无需进行上述手动自定义操作。
</p>
</div>
</div>
<div id="outline-container-Lisp-Eval" class="outline-3">
<h3 id="Lisp-Eval"><span class="section-number-3">29.9.</span> 求值 Emacs Lisp 表达式</h3>
<div class="outline-text-3" id="text-Lisp-Eval">
<p>
Emacs Lisp mode 是编辑 Emacs Lisp 代码的主模式，其模式调用命令为 <code>M-x emacs-lisp-mode</code> 。
</p>

<p>
Emacs 提供了多款用于求值 Emacs Lisp 表达式的命令，你可在 Emacs Lisp 模式中使用这些命令，在编写代码的同时完成测试。例如，重写某个函数后，可对该函数定义进行求值，使其在后续的函数调用中生效。这些命令同样支持全局调用，可在 Emacs Lisp 模式外使用。
</p>

<p>
<b>核心求值命令</b>
</p>
<dl class="org-dl">
<dt><code>M-:</code></dt><dd>在迷你缓冲区中读取单个 Emacs Lisp 表达式并求值，最终在回显区打印求值结果 (<code>eval-expression</code>) 。</dd>
<dt><code>C-x C-e</code></dt><dd>求值得光标前方的 Emacs Lisp 表达式，在回显区打印求值结果 (<code>eval-last-sexp</code>) 。</dd>
<dt><code>C-M-x</code> （Emacs Lisp 模式下）</dt><dd></dd>

<dt><code>M-x eval-defun</code></dt><dd>求值得包含光标或光标后方的整个顶级函数定义，在回显区打印求值结果 (<code>eval-defun</code>) 。</dd>
<dt><code>M-x eval-region</code></dt><dd>求值得选中区域内的所有 Emacs Lisp 表达式。</dd>
<dt><code>M-x eval-buffer</code></dt><dd>求值得当前缓冲区中的所有 Emacs Lisp 表达式。</dd>
</dl>

<p>
<b>命令细节说明</b>
</p>

<p>
<code>M-:</code> (<code>eval-expression</code>) 会通过迷你缓冲区读取表达式并完成求值， <b>在求值前，当前缓冲区会切回按下 <code>M-:</code> 时的原缓冲区</b> ，而非输入表达式的迷你缓冲区。
</p>

<p>
命令 <code>C-x C-e</code> (<code>eval-last-sexp</code>) 对缓冲区中光标前方的表达式求值后，会在回显区展示结果。若求值结果为整数，会同时以其他格式展示该整数值（八进制、十六进制；若满足下文所述 <code>eval-expression-print-maximum-character</code> 的限制条件，还会展示对应的字符形式）。
</p>

<p>
若为 <code>M-:</code> 或 <code>C-x C-e</code> 添加 <b>前缀参数</b> ，求值结果将插入到当前缓冲区的光标位置，而非在回显区展示；若前缀参数为 0，整数结果会连带其八进制、十六进制、字符形式一同插入。添加此类前缀参数后，求值结果的输出也将不再受变量 <code>eval-expression-print-level</code> 和 <code>eval-expression-print-length</code> 的缩写限制（下文将介绍这两个变量）；同理，前缀参数设为 -1 时，将单独取消 <code>eval-expression-print-length</code> 的缩写限制。
</p>

<p>
<code>C-x C-e</code> (<code>eval-last-sexp</code>) 对 <code>defvar</code> 表达式做特殊处理：常规情况下，若 <code>defvar</code> 定义的变量已存在值，对该表达式求值将无任何效果；而该命令会 <b>无条件将变量重置为 <code>defvar</code> 中指定的初始值</b> ，这一特性对调试 Emacs Lisp 程序十分便捷。 <code>defcustom</code> 和 <code>defface</code> 表达式也会被做同样的特殊处理。注意：本节介绍的其他命令（ <code>eval-defun</code> 除外）均无此特殊处理机制。
</p>

<p>
<code>eval-defun</code> 命令在 Emacs Lisp 模式中绑定为 <code>C-M-x</code> ，用于求值包 <b>含光标或光标后方的顶级 Lisp 表达式</b> 并在回显区打印结果。此语境下的顶级表达式虽被称作「defun」，但并非必须是实际的函数定义。
</p>

<p>
该命令对 <code>defvar/defcustom/defface</code> 形式的处理方式，与 <code>eval-last-sexp</code> 完全一致。
</p>

<p>
若为 <code>C-M-x</code> 添加前缀参数，该命令会为函数定义添加 <b>Edebug（Emacs Lisp 调试器）的插桩代码</b> ，开启调试支持。详情参见《Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Instrumenting.html#Instrumenting">为 Edebug 插桩</a>」章节。
</p>

<p>
命令 <code>M-x eval-region</code> 会将选中区域的文本解析为一个或多个 Lisp 表达式，并依次对其求值； <code>M-x eval-buffer</code> 功能与之类似，仅求值对象为整个缓冲区的内容。
</p>

<p>
<b>相关配置选项</b>
</p>

<p>
变量 <code>eval-expression-print-level</code> 和 <code>eval-expression-print-length</code> ：用于控制求值命令的结果输出时，列表被缩写前的最大嵌套深度和最大长度。为 <code>eval-expression</code> 或 <code>eval-last-sexp</code> 添加前缀参数 0，列表将以完整形式打印，不做任何缩写。
</p>

<p>
变量 <code>eval-expression-debug-on-error</code> ：控制使用上述求值命令时，若发生求值错误，是否调用调试器，其默认值为 <code>t</code> （开启调试）。
</p>

<p>
变量 <code>eval-expression-print-maximum-character</code> ：用于限制整数的字符形式展示，数值超过该变量设定值的整数，将不会被转换为字符形式展示。
</p>
</div>
</div>
<div id="outline-container-Lisp-Interaction" class="outline-3">
<h3 id="Lisp-Interaction"><span class="section-number-3">29.10.</span> Lisp 交互缓冲区</h3>
<div class="outline-text-3" id="text-Lisp-Interaction">
<p>
Emacs 启动时会自动创建一个名为 <code>*scratch*</code> 的缓冲区，该缓冲区用于交互式求值 Emacs Lisp 表达式，其主模式为 Lisp Interaction mode。你也可以通过键入 <code>M-x lisp-interaction-mode</code> 手动启用该模式。
</p>

<p>
若你关闭了 <code>*scratch*</code> 缓冲区，可通过 <code>M-x scratch-buffer</code> 命令重新创建。
</p>

<p>
在 <code>*scratch*</code> 缓冲区及其他 Lisp 交互模式的缓冲区中，按下 <code>C-j</code>  (<code>eval-print-last-sexp</code>) 会求值得光标前方的 Lisp 表达式，并将求值结果插入到光标位置。因此，当你在缓冲区中输入表达式后，为每个表达式按下一次 <code>C-j</code> ，缓冲区会自动记录下所有被求值的表达式及其结果，形成一份完整的操作记录。Lisp 交互模式下的所有其他命令，与 Emacs Lisp mode完全一致。
</p>

<p>
Emacs 启动时， <code>*scratch*</code> 缓冲区中会包含一段简短的提示信息，该信息以 Lisp 注释的形式呈现，用于说明此缓冲区的用途。这段提示信息由变量 <code>initial-scratch-message</code> 控制，该变量的值可以是一个文档字符串，也可以设为 <code>nil</code> （表示隐藏该提示信息）。
</p>

<p>
交互式求值 Emacs Lisp 表达式还有另一种方式：使用下级 Emacs Lisp 模式。该模式为 Emacs Lisp 表达式求值提供了一套类似 Shell 模式（参见《<a href="#Shell-Mode">Shell 模式</a>》章节）的操作界面。键入 <code>M-x ielm</code> 可创建一个使用该模式的 <code>*ielm*</code> 缓冲区，更多相关信息可查阅该命令的说明文档。
</p>
</div>
</div>
<div id="outline-container-External-Lisp" class="outline-3">
<h3 id="External-Lisp"><span class="section-number-3">29.11.</span> 运行外部 Lisp 解释器</h3>
<div class="outline-text-3" id="text-External-Lisp">
<p>
Lisp mode是编辑通用 Lisp 方言程序（如通用 Lisp）的主模式，其模式命令为 <code>M-x lisp-mode</code> 。Emacs 会为后缀为 <code>.l</code> 、 <code>.lsp</code> 或 <code>.lisp</code> 的文件自动启用 Lisp 模式。
</p>

<p>
你可以将外部 Lisp 会话作为 Emacs 的子进程（ <i>inferior 下级进程</i> ）运行，并向其传递表达式进行求值。要启动外部 Lisp 会话，键入 <code>M-x run-lisp</code> 即可。该命令会运行名为 <code>lisp</code> 的程序，并将其输入输出均定向至 Emacs 的 <code>*inferior-lisp*</code> 缓冲区。若要修改 <code>M-x run-lisp</code> 所运行的 Lisp 程序名称，可更改变量 <code>inferior-lisp-program</code> 的值。
</p>

<p>
<code>*lisp*</code> 缓冲区的主模式为 Inferior Lisp 模式，该模式融合了 Lisp 模式与 Shell 模式的特性（参见《<a href="#Shell-Mode">Shell 模式</a>》章节）。向 Lisp 会话发送输入时，只需移至 <code>*lisp*</code> 缓冲区末尾，输入内容后按下 <code>RET</code> 回车键即可；Lisp 会话的终端输出会自动插入到该缓冲区中。
</p>

<p>
在 Lisp 模式下编辑 Lisp 程序时，可键入 <code>C-M-x</code> (<code>lisp-eval-defun</code>) ，将 Lisp 模式缓冲区中的表达式发送至通过 <code>M-x run-lisp</code> 启动的 Lisp 会话。被发送的表达式为光标所在位置或光标后方的顶级 Lisp 表达式，求值结果会按常规方式输出至 <code>*inferior-lisp*</code> 缓冲区。需注意，Lisp 模式下 <code>C-M-x</code> 的作用与 Emacs Lisp 模式中极为相似（参见《<a href="#Lisp-Eval">求值 Emacs Lisp 表达式</a>》章节），唯一区别是表达式会被发送至外部 Lisp 环境求值，而非在 Emacs 内部求值。
</p>

<p>
编辑 Scheme 代码并向 Scheme 子进程发送表达式的相关功能与之高度相似。Scheme 源文件在 Scheme 模式下编辑，该模式可通过 <code>M-x scheme-mode</code> 显式启用；键入 <code>M-x run-scheme</code> 可启动 Scheme 会话（与 Scheme 交互的缓冲区名为 <code>*scheme*</code> ），同样通过 <code>C-M-x</code> 向其发送表达式。
</p>
</div>
</div>
</section>
<section id="outline-container-Maintaining" class="outline-2">
<h2 id="Maintaining"><span class="section-number-2">30.</span> 大型程序维护</h2>
<div class="outline-text-2" id="text-Maintaining">
<p>
本章介绍 Emacs 中用于维护中大型程序及软件包的功能，这些功能包括：
</p>
<ul class="org-ul">
<li>版本控制系统（VCS）的统一操作界面，该系统用于记录源文件的修改历史</li>
<li>处理编程项目的专用命令</li>
<li>维护变更日志文件的专属模式，此类文件用于按时间顺序记录程序的修改内容</li>
<li>交叉引用（Xref）功能：一组用于显示符号（又称 “标识符”）定义及引用位置的命令</li>
<li>Emacs 开发环境（EDE）：Emacs 内置的集成开发环境</li>
<li>分支合并模式：用于合并在不同开发分支上对程序源码做出的修改</li>
<li>缺陷引用次要模式：可高亮显示缺陷引用信息，并在对应的问题追踪系统中打开相关缺陷报告</li>
</ul>

<p>
若你正在维护大型 Lisp 程序，除本章介绍的功能外，Emacs Lisp 回归测试库（ERT）也会为你提供帮助（参见《Emacs Lisp 回归测试》中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/ert/index.html#Top">ERT</a> 相关章节）。
</p>

<ul class="org-ul">
<li><a href="#Version-Control">版本控制</a></li>
<li><a href="#Projects">项目管理</a></li>
<li><a href="#Change-Log">变更日志</a></li>
<li><a href="#Xref">查找标识符引用</a></li>
<li><a href="#EDE">Emacs 开发环境</a></li>
<li><a href="#Emerge">使用 Emerge 合并文件</a></li>
<li><a href="#Bug-Reference">漏洞引用</a></li>
</ul>
</div>
<div id="outline-container-Version-Control" class="outline-3">
<h3 id="Version-Control"><span class="section-number-3">30.1.</span> 版本控制</h3>
<div class="outline-text-3" id="text-Version-Control">
<p>
<i>version control 版本控制</i> 系统是一款可记录源文件多个版本的程序，能存储各版本的创建时间、修改人以及修改内容说明等信息。
</p>

<p>
Emacs 的版本控制界面名为 <b><i>VC</i></b> ，VC 命令可适配多款不同的版本控制系统；目前支持的系统包括 Bazaar、CVS、Git、Mercurial、Monotone、RCS、SRC、SCCS/CSSC 以及 Subversion。其中，CVS、RCS 和 Bazaar 由 GNU 项目发布维护。
</p>

<p>
当你打开受版本控制系统管理的文件时，VC 会自动启用。若要完全禁用 VC，可将可自定义变量 <code>vc-handled-backends</code> 的值设为 <code>nil</code> （参见《<a href="#Customizing-VC">自定义 VC</a>》章节）。
</p>

<p>
若要更新当前缓冲区中已打开文件的 VC 状态信息，可使用命令 <code>vc-refresh-state</code> 。当你在 Emacs 外部执行版本控制命令（如在 Shell 提示符下操作）、将缓冲区文件切换至其他版本控制系统管理，或把文件从版本控制中彻底移除时，该命令会非常实用。
</p>

<p>
在展示受版本控制系统管理文件所在目录的 Dired 缓冲区中（参见《<a href="#Dired">目录编辑器 Dired</a>》章节），VC 也会自动启用。本节介绍的所有 VC 命令，均可在任意展示 VC 受控文件目录的 Dired 缓冲区中调用；Dired 缓冲区中被标记的所有文件（参见《<a href="#Marks-vs-Flags">Dired 标记与标志</a>》章节）会被视为属于 <b>当前文件集</b> ，VC 命令将对该文件集中的文件执行操作。这一特性允许你自定义构建 VC 文件集，包含任意所需文件，不受其 VC 状态限制。（若在 Dired 缓冲区中调用 VC 命令时无文件被标记，则缓冲区当前行显示的文件会被视为文件集中的唯一文件。）
</p>

<ul class="org-ul">
<li><a href="#Introduction-to-VC">版本控制简介</a></li>
<li><a href="#VC-Mode-Line">版本控制与模式行</a></li>
<li><a href="#Basic-VC-Editing">版本控制下的基本编辑</a></li>
<li><a href="#Log-Buffer">日志条目缓冲区的功能</a></li>
<li><a href="#Registering">为文件注册版本控制</a></li>
<li><a href="#Old-Revisions">查看与比较旧版本</a></li>
<li><a href="#VC-Change-Log">版本控制变更日志</a></li>
<li><a href="#VC-Undo">撤销版本控制操作</a></li>
<li><a href="#VC-Ignore">忽略版本控制文件</a></li>
<li><a href="#VC-Directory-Mode">版本控制目录模式</a></li>
<li><a href="#Branches">版本控制分支</a></li>
<li><a href="#Miscellaneous-VC">版本控制的杂项命令与功能</a></li>
<li><a href="#Customizing-VC">定制版本控制</a></li>
</ul>
</div>
<div id="outline-container-Introduction-to-VC" class="outline-4">
<h4 id="Introduction-to-VC"><span class="section-number-4">30.1.1.</span> 版本控制简介</h4>
<div class="outline-text-4" id="text-Introduction-to-VC">
<p>
VC 允许你在 Emacs 中使用版本控制系统，将版本控制操作与编辑操作无缝融合，同时为多款版本控制系统的通用操作提供了统一的操作界面。
</p>

<p>
部分不常用或复杂的版本控制操作（例如修改代码库配置）并非 VC 支持的功能，你需要在 VC 外部执行此类操作，比如通过命令行完成。
</p>

<p>
本节将对版本控制进行整体概述，并介绍 VC 所支持的版本控制系统。若你已熟悉将要使用的版本控制系统，可跳过本节内容。
</p>

<ul class="org-ul">
<li><a href="#Why-Version-Control_003f">理解版本控制解决的问题</a></li>
<li><a href="#Version-Control-Systems">VC 支持的版本控制系统</a></li>
<li><a href="#VCS-Concepts">版本控制的核心概念</a></li>
<li><a href="#VCS-Merging">基于合并与基于锁定的版本控制</a></li>
<li><a href="#VCS-Changesets">基于变更集与基于文件的版本控制</a></li>
<li><a href="#VCS-Repositories">分布式与集中式代码仓库</a></li>
<li><a href="#Types-of-Log-File">日志文件类型</a></li>
</ul>
</div>
<div id="outline-container-Why-Version-Control_003f" class="outline-5">
<h5 id="Why-Version-Control_003f"><span class="section-number-5">30.1.1.1.</span> 理解版本控制解决的问题</h5>
<div class="outline-text-5" id="text-Why-Version-Control_003f">
<p>
版本控制系统为使用者提供三项核心能力：
</p>
<ul class="org-ul">
<li>可回滚性：当发现某次修改存在错误或考虑不周时，能够将文件恢复至先前的状态。</li>
<li>并发性：支持多人同时修改同一组文件，且能检测并解决修改过程中出现的冲突。</li>
<li>历史追溯性：可为文件数据附加历史相关信息，例如为每次修改添加说明其设计意图的注释。即便对于独立开发的程序员，修改历史也是辅助记忆的重要工具；而在多人协作的项目中，修改历史更是开发者之间至关重要的沟通形式。</li>
</ul>
</div>
</div>
<div id="outline-container-Version-Control-Systems" class="outline-5">
<h5 id="Version-Control-Systems"><span class="section-number-5">30.1.1.2.</span> VC 支持的版本控制系统</h5>
<div class="outline-text-5" id="text-Version-Control-Systems">
<p>
VC 目前兼容多款不同的版本控制系统，并称这些系统为后端，具体如下：
</p>
<ul class="org-ul">
<li>Git 是一款分布式版本控制系统，最初由林纳斯・托瓦兹为支持 Linux 内核的开发而设计。VC 支持 Git 的多数常用操作，而代码库同步等部分操作仍需通过命令行执行。</li>
<li>CVS 是一款免费的版本控制系统，2008 年前后之前，曾被绝大多数自由软件项目采用，后被新一代版本控制系统取代。CVS 支持多用户在本地或通过网络同时协作开发，但与新一代系统不同，该系统不支持原子提交，也无文件移动 / 重命名的相关功能。VC 支持 CVS 环境下的所有基础编辑操作。</li>
<li>Subversion（简称 svn）是一款免费的版本控制系统，设计初衷为兼容 CVS 并解决其固有问题，例如支持文件集的原子提交，同时可对目录、符号链接、元数据进行版本管理，也支持文件的重命名、复制与删除操作。</li>
<li>SCCS 是史上首款版本控制系统，早已被功能更完善的同类系统取代。VC 会自行实现 SCCS 缺失的部分功能以做补充，例如版本发布的标签命名功能；而多分支管理等其他 VC 功能，在 SCCS 环境下则完全无法使用。由于 SCCS 为非免费软件，我们建议避免使用。</li>
<li>CSSC 是 SCCS 的免费替代方案，仅当因特殊原因无法使用设计更优的新一代版本控制系统时，才建议选用该系统。</li>
<li>RCS 是一款免费的版本控制系统，也是 VC 最初的开发基础，该系统功能相对基础：不支持网络远程操作，仅能对单个文件进行版本管理。几乎所有可通过 RCS 完成的操作，都能在 VC 中实现。</li>
<li>Mercurial（简称 hg）是一款分布式版本控制系统，功能与 Git 高度相似。VC 支持 Mercurial 的绝大多数命令，仅不支持代码库同步操作。</li>
<li>Bazaar（简称 bzr）是一款分布式版本控制系统，同时支持基于代码库的版本管理与分布式版本管理两种模式。VC 支持 Bazaar 环境下的多数基础编辑操作。</li>
<li>SRC（简称 src）是 RCS 的升级优化版本，是专为单人开发的单文件项目设计的专用版本控制系统。该系统允许单个目录中存在多个版本控制历史相互独立的文件，因此特别适用于小型文档、脚本与配置点文件的维护。SRC 基于 RCS 实现版本存储，同时提供了现代化的操作界面，支持无锁操作与整数连续版本号功能。VC 支持 SRC 的几乎所有操作。</li>
</ul>
</div>
</div>
<div id="outline-container-VCS-Concepts" class="outline-5">
<h5 id="VCS-Concepts"><span class="section-number-5">30.1.1.3.</span> 版本控制的核心概念</h5>
<div class="outline-text-5" id="text-VCS-Concepts">
<p>
当一个文件被纳入版本控制管理时，我们称该文件已在版本控制系统中 <b><i>registered注册</i></b> 。版本控制系统会维护一个 <b><i>repository代码库</i></b> ，其中既存储文件的当前状态，也保存其完整的修改历史 —— 这些信息足以重建文件的当前版本或任意历史版本。代码库中还会存储其他相关信息，例如描述各文件修改内容的日志条目。
</p>

<p>
你实际编辑的、受版本控制的文件副本被称作 <b><i>work file工作文件</i></b> 。工作文件的编辑方式与普通文件完全一致，当完成一系列修改后，你可以对这些修改执行 <b><i>commit提交（check in签入）</i></b> 操作；该操作会将修改记录至代码库中，同时附带一段描述性的日志条目。
</p>

<p>
由工作文件构成的目录树被称作 <b><i>working tree工作树</i></b> 。
</p>

<p>
每一次提交操作都会在代码库中生成一个新的 <b><i>revison版本</i></b> 。版本控制系统会追踪所有历史版本，以及每个版本中发生的具体修改。每个版本都会有一个 <b><i>revison ID版本标识</i></b> ，其格式由对应的版本控制系统决定；最简单的形式就是一个整数。
</p>

<p>
若要深入理解版本控制的进阶用法，你需要掌握版本控制系统的三大核心差异维度。后续三节将详细说明：版本控制系统分为基于锁定和基于合并两类、基于文件和基于变更集两类，以及集中式和分布式两类。VC 支持所有这些运作模式，但无法完全屏蔽不同模式之间的本质差异。
</p>
</div>
</div>
<div id="outline-container-VCS-Merging" class="outline-5">
<h5 id="VCS-Merging"><span class="section-number-5">30.1.1.4.</span> 基于合并与基于锁定的版本控制</h5>
<div class="outline-text-5" id="text-VCS-Merging">
<p>
版本控制系统通常会提供相应机制，协调多位用户对同一文件的修改操作，实现方式主要分为两种： <b>合并式</b> 与 <b>锁定式</b> 。
</p>

<p>
在采用合并机制的版本控制系统中，每位用户可随时修改工作文件。系统支持将你本地包含未提交修改的工作文件，与其他用户已提交的最新修改进行合并。
</p>

<p>
早期的版本控制系统则采用 <i>locking 锁定</i> 机制，该模式下的工作文件默认处于只读状态。若要编辑文件，需向版本控制系统发起锁定请求，解锁后文件才会变为可写状态；同一文件在同一时间仅能被一位用户锁定。此锁定机制与 Emacs 中用于检测普通文件被多人同时编辑的锁定功能原理类似，但实现方式不同（参见《<a href="#Interlocking">防止同时编辑</a>》章节）。当你提交修改后，文件会自动解锁并恢复为只读状态，其他用户此时方可锁定该文件进行修改。
</p>

<p>
当多位用户尝试同时修改同一文件时，锁定式和合并式系统均可能出现冲突问题。锁定式系统会产生 <b><i>lock conflicsts锁定冲突</i></b> ：用户尝试检出文件时，可能因文件已被锁定而操作失败。合并式系统会产生 <b><i>merge conflicts合并冲突</i></b> ：当你提交的文件修改，与其他用户在你检出文件后提交的修改存在冲突时，就会触发该问题。这两类冲突均需开发者通过人工判断与沟通来解决。实践证明，无论是从开发者的使用便捷性，还是从减少实际冲突的发生次数、降低冲突严重程度来看， <b>合并机制都优于锁定机制</b> 。
</p>

<p>
SCCS 系统始终采用锁定机制；RCS 默认使用锁定机制，但可配置为合并模式运行；CVS 与 Subversion 默认采用合并机制，也可切换至锁定模式；Git、Mercurial 等分布式版本控制系统则 <b>仅支持合并机制</b> 。
</p>

<p>
VC 模式同时兼容锁定式和合并式版本控制系统。新一代版本控制系统中常用 <b>commit提交</b> 和 <b>update更新</b> 表述操作，而早期的锁定式系统则使用 <b>check in签入</b> 和 <b>check out检出</b> 。VC 会尽可能屏蔽这些表述上的差异，提供统一的操作体验。
</p>
</div>
</div>
<div id="outline-container-VCS-Changesets" class="outline-5">
<h5 id="VCS-Changesets"><span class="section-number-5">30.1.1.5.</span> 基于变更集与基于文件的版本控制</h5>
<div class="outline-text-5" id="text-VCS-Changesets">
<p>
在 SCCS、RCS、CVS 等早期版本控制系统（以及 SRC 系统）中，版本控制操作均为 <b>file-base 基于文件</b> 的模式：每个文件都拥有独立的注释和版本修订历史，与其他所有文件互不关联。而以 Subversion 为开端的新一代版本控制系统，则采用 <b><i>changeset-based 基于变更集</i></b> 的模式：一次提交操作可包含对多个文件的修改，且整组修改会作为一个独立单元被系统处理。与此次修改相关的注释不再归属单个文件，而是附属于该变更集本身。
</p>

<p>
基于变更集的版本控制相比基于文件的版本控制，具备更高的灵活性和功能性；在实际开发中，当需要回滚对多个文件的批量修改时，基于变更集的模式能让开发者更便捷地定位并移除整组修改，这一优势尤为突出。
</p>
</div>
</div>
<div id="outline-container-VCS-Repositories" class="outline-5">
<h5 id="VCS-Repositories"><span class="section-number-5">30.1.1.6.</span> 分布式与集中式代码仓库</h5>
<div class="outline-text-5" id="text-VCS-Repositories">
<p>
早期的版本控制系统均基于 <b><i>centralized model集中式模型</i></b> 设计，即一个项目仅配备一个代码库，供所有开发者共同使用。SCCS、RCS、CVS、Subversion 和 SRC 均采用该类模型，其弊端之一是代码库会成为影响系统可靠性与运行效率的 <b>瓶颈节点</b> 。
</p>

<p>
GNU Arch 率先提出了 <b><i>distributed or decentralized分布式版本控制</i></b> 的概念，后续 Git、Mercurial 和 Bazaar 均实现了该技术。分布式模式下，一个项目可拥有多个独立的代码库，这类系统支持在不同代码库间执行一种超级合并操作，能够对各代码库的修改历史进行调和统一。实际使用中，每位开发者均可拥有专属代码库，而代码库之间的合并操作则替代了传统的提交操作。
</p>

<p>
VC 可协助你管理个人工作文件与代码库之间的交互操作。无论对应的代码库是单一的主代码库，还是对等代码库网络中的其中一个，均无需 VC 做额外适配处理。
</p>
</div>
</div>
<div id="outline-container-Types-of-Log-File" class="outline-5">
<h5 id="Types-of-Log-File"><span class="section-number-5">30.1.1.7.</span> 日志文件类型</h5>
<div class="outline-text-5" id="text-Types-of-Log-File">
<p>
使用版本控制系统的项目可维护两类修改日志。一类是 <b>版本控制系统日志</b> ，由版本控制系统自行维护：每次提交修改时，你需要为该次修改填写一条 /log entry日志条目. （参见《<a href="#Log-Buffer">日志条目缓冲区的功能</a>》章节）。
</p>

<p>
另一类是 <b>ChangeLog 文件日志</b> （参见《<a href="#Change-Log">变更日志</a>》章节），该日志会按时间顺序记录程序中一大部分内容的所有修改 —— 通常为一个目录及其子目录下的内容。小型程序一般只需一个 ChangeLog 文件，大型程序则可在每个主要目录下各放置一个 ChangeLog 文件（详见《<a href="#Change-Log">变更日志</a>》章节）。早在版本控制系统出现之前，程序员就已开始使用这类变更日志。
</p>

<p>
基于变更集的版本控制系统，通常会为整个系统维护一份 <b>基于变更集的修改日志</b> ，这在一定程度上让 ChangeLog 文件显得有些多余。但 ChangeLog 文件仍保留着两点优势：其一，有时需要将单个目录的修改历史与其他目录的修改历史分开查看，该文件可满足这一需求；其二，许多版本控制系统中，提交日志的内容无法修改，而 ChangeLog 文件则支持编辑。
</p>

<p>
采用版本控制的项目，可仅使用版本控制系统日志，也可同时使用两类日志，还能对不同文件分别采用不同的日志记录方式。每个项目都有对应的日志使用规范，你需遵循项目的既定规则。
</p>

<p>
若项目规范要求同时使用两类日志，通常的做法是为每次修改只编写一次日志条目，再将其同步至两类日志中。你可先在 ChangeLog 文件中编写条目，提交修改时按下 <code>C-c C-a</code> 将条目复制到版本控制的日志缓冲区（参见《<a href="#Log-Buffer">日志条目缓冲区的功能</a>》章节）；也可在提交修改时，在日志缓冲区中编写条目（可借助 <code>C-c C-w</code> 快捷键辅助），后续再使用 <code>C-x v a</code> 命令将条目复制到 ChangeLog 文件中（参见《<a href="#Change-Logs-and-VC">变更日志与版本控制</a>》章节）。
</p>
</div>
</div>
</div>
<div id="outline-container-VC-Mode-Line" class="outline-4">
<h4 id="VC-Mode-Line"><span class="section-number-4">30.1.2.</span> 版本控制与模式行</h4>
<div class="outline-text-4" id="text-VC-Mode-Line">
<p>
当你打开受版本控制的文件时，Emacs 会在 <b>模式行</b> 中显示相关标识。例如，标识 'Bzr-1223' 表示该文件由 Bazaar 版本控制系统管理，且当前版本标识为 1223。
</p>

<p>
版本控制系统后端名称与版本标识之间的 <b>字符</b> ，用于表示工作文件的版本控制状态。
</p>

<p>
在 <b>基于合并</b> 的版本控制系统中：
</p>
<ul class="org-ul">
<li>字符 '-' 表示工作文件未被修改；</li>
<li>字符 ':' 表示工作文件已被修改；</li>
<li>字符 '!' 表示文件因近期的合并操作产生了冲突（参见《<a href="#Merging">合并分支</a>》章节），或文件已从版本控制中移除，亦或是文件虽被版本化但同时被标记为 <i>ignored忽略</i> （该情况通常为异常状态，参见《<a href="#VC-Ignore">忽略版本控制文件</a>》章节）；</li>
<li>字符 '?' 表示文件受版本控制管理，但在工作树中缺失。</li>
</ul>

<p>
在 <b>基于锁定</b> 的版本控制系统中：
</p>
<ul class="org-ul">
<li>字符 '-' 表示文件未被锁定；</li>
<li>字符 ':' 表示文件已被锁定；</li>
<li>若文件被其他用户锁定（例如用户jim），模式行会显示为 'RCS:jim:1.3' ；</li>
<li>字符 '@' 表示文件已在本地添加，但尚未提交至主代码库。</li>
</ul>

<p>
在图形化显示界面中，将鼠标悬停在模式行的版本控制标识上，会弹出 <b>工具提示框</b> ，展示版本控制状态的详细描述信息。在该标识上单击 <code>mouse-1</code> 鼠标左键，会弹出 VC 命令菜单，与菜单栏中「Tools / Version Control」选项的内容完全一致。
</p>

<p>
当 Auto Revert mode自动恢复模式（参见《<a href="#Reverting">恢复缓冲区</a>》章节）恢复受版本控制的缓冲区时，会同步更新模式行中的版本控制信息。但如果在当前 Emacs 会话外，版本控制状态发生了变更且未对工作文件做任何修改，自动恢复模式可能无法正确更新该信息。若将变量 <code>auto-revert-check-vc-info</code> 设为 <code>t</code> ，自动恢复模式会每隔 <code>auto-revert-interval</code> 秒更新一次版本控制状态信息，即便工作文件本身无任何变化。该操作带来的 CPU 占用率因版本控制系统而异，通常不会过高。
</p>
</div>
</div>
<div id="outline-container-Basic-VC-Editing" class="outline-4">
<h4 id="Basic-VC-Editing"><span class="section-number-4">30.1.3.</span> 版本控制下的基本编辑</h4>
<div class="outline-text-4" id="text-Basic-VC-Editing">
<p>
绝大多数 VC 命令均作用于 <b><i>VC filesets(VC 文件集)</i></b> 。VC 文件集是指一次 VC 操作所针对的一个或多个文件的集合。在打开受版本控制文件的缓冲区中执行 VC 命令时，VC 文件集即为该单个文件；在 VC 目录缓冲区中执行命令且其中部分文件被标记时，VC 文件集由所有被标记的文件组成（参见《<a href="#VC-Directory-Mode">VC 目录模式</a>》章节）。同理，在 Dired 缓冲区中调用 VC 命令时，VC 文件集也由被标记的文件构成（参见《<a href="#Marks-vs-Flags">Dired 标记与标志</a>》章节），若未标记任何文件，则默认以缓冲区当前行显示的文件作为唯一文件集。
</p>

<p>
对于 Git、Mercurial、Bazaar 等现代 <b>基于变更集的版本控制系统</b> （参见《<a href="#VCS-Changesets">基于变更集与基于文件的版本控制</a>》章节），VC 命令会将多文件 VC 文件集作为一个整体处理。例如，提交一个多文件 VC 文件集只会生成一个版本，该版本包含所有文件的修改内容。而在 CVS 等早期基于文件的版本控制系统中，多文件 VC 文件集中的每个文件会被单独处理；因此，提交一个文件集会为其中每个被修改的文件各生成一个版本。
</p>

<dl class="org-dl">
<dt><code>C-x v v</code></dt><dd>对当前 VC 文件集执行下一步相应的版本控制操作。</dd>
</dl>

<p>
VC 的核心命令是多功能命令 <code>C-x v v</code> (<code>vc-next-action</code>) ，该命令会对当前 VC 文件集执行最贴合场景的操作：可为文件集在版本控制系统中完成注册，也可执行提交、解锁，或是将外部修改合并至文件集等操作。不同场景下的具体执行行为将在后续小节中详细说明。你可在文件访问缓冲区、Dired 缓冲区或 VC 目录缓冲区中使用 <code>C-x v v</code> 命令；在后两种缓冲区中，该命令将作用于由被标记文件组成的文件集。此外，在 Diff 模式下的补丁缓冲区中（参见《<a href="#Diff-Mode">Diff 模式</a>》章节）也可使用该命令，此时命令会作用于缓冲区中展示差异对比的所有文件。
</p>

<p>
请注意， <b>VC 文件集</b> 与用于按功能组查看和打开文件的 <b>命名文件集</b> 并非同一概念（参见《<a href="#Filesets">文件集</a>》章节）。与命名文件集不同，VC 文件集无命名标识，且不会在不同 Emacs 会话间持久化保存。
</p>

<ul class="org-ul">
<li><a href="#VC-With-A-Merging-VCS">基于合并的基本版本控制</a></li>
<li><a href="#VC-With-A-Locking-VCS">基于锁定的基本版本控制</a></li>
<li><a href="#Advanced-C_002dx-v-v">C-x v v 中的高级控制</a></li>
</ul>
</div>
<div id="outline-container-VC-With-A-Merging-VCS" class="outline-5">
<h5 id="VC-With-A-Merging-VCS"><span class="section-number-5">30.1.3.1.</span> 基于合并的基本版本控制</h5>
<div class="outline-text-5" id="text-VC-With-A-Merging-VCS">
<p>
在 Git、Mercurial 等现代基于合并的版本控制系统中（参见《<a href="#VCS-Merging">基于合并与基于锁定的版本控制</a>》章节），若在打开受版本控制文件的缓冲区、VC 目录缓冲区或 Dired 缓冲区中调用 <code>C-x v v</code> 命令，该命令将按以下规则执行操作：
</p>
<ul class="org-ul">
<li>若 VC 文件集中包含多个文件，且各文件的版本控制状态不一致，触发错误提示。（但需注意，文件集允许同时包含新添加的文件和已修改的文件，参见《<a href="#Registering">将文件注册到版本控制系统</a>》章节。）若文件集中的文件已缺失（从文件系统中移除但仍被版本控制系统追踪），或被版本控制系统标记为忽略，同样触发错误提示。</li>
<li>若 VC 文件集中的所有文件均已完成注册，且相较于最新版本无任何修改，不执行任何操作。</li>
<li>若 VC 文件集中的所有文件均未在版本控制系统中注册，将为文件集中的新添加文件完成注册，即纳入版本控制系统管理（参见《<a href="#Registering">将文件注册到版本控制系统</a>》章节）。若 Emacs 无法找到可用的注册系统，会提示用户选择代码库类型、创建新的代码库，并将该 VC 文件集注册至新代码库。你也可显式指定使用的版本控制系统，参见《<a href="#Advanced-C_002dx-v-v">C-x v v 的高级用法</a>》章节。注意：文件注册操作不会触发提交，需再次调用 <code>C-x v v</code> 方可执行提交，详见下文。</li>
<li>若 VC 文件集中的所有文件均为新添加文件或已修改文件，提交其中的已修改文件。执行该操作时，Emacs 会弹出 <code>*vc-log*</code> 缓冲区，用户需为本次修改编写日志条目，完成后按下 <code>C-c C-c</code> 即可提交（参见《<a href="#Log-Buffer">日志条目缓冲区的功能</a>》章节）。
<ul class="org-ul">
<li>对于 Git、Mercurial 等现代分布式版本控制系统，修改会被提交至本地代码库，且不会自动同步至上游代码库（通常部署在远程主机）。若自你上次更新后，上游代码库已发生变更，此次提交可能失败。遇此情况，你需先从上游代码库更新内容后重试，可使用 <code>C-x v +</code> 命令（参见《<a href="#Pulling-_002f-Pushing">将修改拉取 / 推送至分支 / 从分支拉取</a>》章节）或C-x v m命令（参见《合并分支》章节）完成更新。</li>
<li>对于集中式版本控制系统，若因上游代码库变更导致提交失败，再次调用 <code>C-x v v</code> 即可合并上游代码库的修改内容。</li>
</ul></li>
<li>若使用集中式版本控制系统，且 VC 文件集中存在任意文件相较于上游代码库已过期，将提示用户从代码库更新该文件集。</li>
</ul>

<p>
上述规则同样适用于非锁定模式下的 RCS 系统，例外情况为：该模式下不会从代码库自动合并修改内容。若自你开始编辑文件后，其他用户已提交了对同一文件的修改，系统不会向你发出任何通知；当你提交自身的版本时，其他用户的修改会被覆盖（但这些修改仍保存在代码库中，并非永久性丢失）。因此，你必须在提交前确认当前版本未发生变更。此外，即便在非锁定模式下，RCS 仍支持锁定操作：对未修改文件执行 <code>C-x v v</code> 命令会锁定该文件，与 RCS 在常规锁定模式下的操作一致（参见《<a href="#VC-With-A-Locking-VCS">基于锁定的基础版本控制</a>》章节）。
</p>

<p>
若在 Diff 模式的缓冲区中调用 <code>C-x v v</code> 命令，该命令会默认此缓冲区中保存了一个或多个文件的补丁集，随后将补丁中的修改应用至对应文件，并弹出 <code>*vc-log*</code> 缓冲区供用户编写合适的提交日志，完成后执行提交操作。
</p>
</div>
</div>
<div id="outline-container-VC-With-A-Locking-VCS" class="outline-5">
<h5 id="VC-With-A-Locking-VCS"><span class="section-number-5">30.1.3.2.</span> 基于锁定的基本版本控制</h5>
<div class="outline-text-5" id="text-VC-With-A-Locking-VCS">
<p>
在 SCCS、默认模式下的 RCS 等基于 <b>锁定的版本控制系统</b> 中， <code>C-x v v</code> 命令将执行以下操作：
</p>
<ul class="org-ul">
<li>若 VC 文件集中包含多个文件且各文件的版本控制状态不一致，触发错误提示；若文件集中的文件已缺失（从文件系统中移除但仍被版本控制系统追踪），同样触发错误提示。</li>
<li>若 VC 文件集中的所有文件均未在版本控制系统中完成注册，将为文件集中的新添加文件完成注册（参见《<a href="#Registering">将文件注册到版本控制系统</a>》章节）。若 Emacs 无法找到可用的注册系统，会提示用户选择代码库类型、创建新的代码库并将该 VC 文件集注册至新代码库。你也可显式指定使用的版本控制系统，详见《<a href="#Advanced-C_002dx-v-v">C-x v v 的高级用法</a>》章节。</li>
<li>若 VC 文件集中的所有文件均已注册且处于未锁定状态，将执行 <b>check out检出</b> 操作：为每个文件加锁并将其设为可写状态，以便你开始编辑。</li>
<li>若 VC 文件集中的所有文件均由你锁定且包含修改内容，将 <b>commit提交（check-in签入）</b> 本次修改。执行该操作时，Emacs 会弹出 <code>*vc-log*</code> 缓冲区，你需为新版本编写日志条目，完成后按下 <code>C-c C-c</code> 即可提交（参见《<a href="#Log-Buffer">日志条目缓冲区的功能</a>》章节）。</li>
<li>若 VC 文件集中的所有文件均由你锁定，但你未对其做出任何修改，将 <b>释放锁</b> 并将文件恢复为只读状态。此操作可撤销此前对未做修改文件执行的检出操作。</li>
<li>若 VC 文件集中的所有文件均被其他用户锁定，会询问你是否要 <b>抢占该锁</b> 。若选择是，文件将转为由你锁定，且系统会向原锁定用户发送警告信息。</li>
<li>若 VC 文件集中的文件处于未锁定状态，但相较于最新版本存在修改内容，会提示你为每个该类文件 <b>获取锁</b> ，或将文件 <b>恢复至最近一次签入的版本</b> （该情况属于异常情况，正常使用中不应出现）。</li>
</ul>

<p>
上述规则同样适用于 <b>锁定模式下的 CVS 系统</b> ，唯一例外为：CVS 不支持抢占锁的操作。
</p>
</div>
</div>
<div id="outline-container-Advanced-C_002dx-v-v" class="outline-5">
<h5 id="Advanced-C_002dx-v-v"><span class="section-number-5">30.1.3.3.</span> C-x v v 中的高级控制</h5>
<div class="outline-text-5" id="text-Advanced-C_002dx-v-v">
<p>
为 <code>vc-next-action</code> 命令 (<code>C-u C-x v v</code>) 添加前缀参数后，该命令仍会执行逻辑上的下一个版本控制操作，同时会接收额外参数，用于精准指定操作的执行方式。
</p>

<p>
你可通过额外参数指定版本控制系统的名称。当某个文件集可被多个版本控制系统管理，而 Emacs 未能检测出正确的系统时，该用法会非常实用。
</p>

<p>
除此之外，若使用的是 CVS、RCS 或 SRC 系统，你还可指定版本标识，具体行为分以下两种情况：
</p>
<ul class="org-ul">
<li>若文件集已被修改（或处于锁定状态），指定版本标识后，Emacs 会以该标识提交文件。你可通过传入合适的版本标识来创建新的分支（参见《<a href="#Branches">版本控制分支</a>》章节）。</li>
<li>若文件集未被修改（且处于未锁定状态），指定版本标识后，会将该版本检出至工作树中。你也可通过传入其他分支的版本标识或分支标识，检出该分支上的对应版本（参见《<a href="#Switching-Branches">分支间的切换</a>》章节）。输入空参数（即执行 <code>C-u C-x v v</code> 后按 <code>RET</code> 回车键），则会检出当前分支的最新（又称 head主干）版本。</li>
</ul>

<p>
注意：分布式版本控制系统会直接忽略以这种方式指定的 <b>版本标识</b> 。这类系统既不允许用户自定义版本标识，也不采用「检出单个文件」的设计逻辑。
</p>
</div>
</div>
</div>
<div id="outline-container-Log-Buffer" class="outline-4">
<h4 id="Log-Buffer"><span class="section-number-4">30.1.4.</span> 日志条目缓冲区的功能</h4>
<div class="outline-text-4" id="text-Log-Buffer">
<p>
当你通过 VC 执行提交修改操作时，Emacs 会弹出一个名为 <code>*vc-log*</code> 的缓冲区。你需要在该缓冲区中编写日志条目，描述本次所做的修改内容（参见《<a href="#Why-Version-Control_003f">版本控制的解决场景</a>》章节）。编写完成后，键入 <code>C-c C-c</code> (<code>log-edit-done</code>) 即可退出该缓冲区，同时将修改与编写的日志条目一并提交。
</p>

<p>
<code>*vc-log*</code> 缓冲区的主模式为 <b>Log Edite mode日志编辑模式</b> ，该模式是文本模式的一个变体（参见《<a href="#Text-Mode">文本模式</a>》章节）。进入日志编辑模式时，Emacs 会运行 <code>text-mode-hook</code> 和 <code>vc-log-mode-hook</code> 两个钩子函数（参见《<a href="#Hooks">钩子函数</a>》章节）。
</p>

<p>
在 <code>*vc-log*</code> 缓冲区中，你可以编写一行或多行 <b><i>header lines(头信息行)</i></b> ，用于向版本控制系统提供额外的说明信息。每一行头信息都必须单独位于缓冲区的顶部；缓冲区中第一行非头信息的内容，将被视为日志条目的起始位置。例如，以下头信息行表明本次修改并非由你编写，而是由另一位开发者完成：
</p>

<div class="org-src-container">
<pre class="src src-shell">Author: J. R. Hacker <a href="mailto:jrh%40example.com">&lt;jrh@example.com&gt;</a>
</pre>
</div>

<p>
除 'Author' 头信息外，Emacs 还支持识别 'Summary' （对本次变更集的单行摘要）、 'Date' （手动指定的提交时间）和 'Fixes' （本次修改所修复的缺陷引用）这几种头信息。并非所有版本控制系统都支持上述全部头信息，若你为某一版本控制系统指定了其不支持的头信息，该头信息会被当作日志条目的一部分处理。
</p>

<p>
在 <code>*vc-log*</code> 缓冲区中，当前的 VC 文件集即为执行 <code>C-c C-c</code> 后将被提交的文件集。键入 <code>C-c C-f</code> (<code>log-edit-show-files</code>) ，可查看该 VC 文件集中的所有文件列表；键入 <code>C-c C-d</code> (<code>log-edit-show-diff</code>) ，可查看 VC 文件集与你开始编辑时的版本之间的修改差异对比（参见《<a href="#Old-Revisions">查看并比较旧版本</a>》章节）。
</p>

<p>
为辅助生成 ChangeLog 条目，你可键入 <code>C-c C-w</code> (<code>log-edit-generate-changelog-from-diff</code>) ，基于 VC 文件集的修改差异，自动生成 ChangeLog 条目框架，其中会列出所有被修改的文件名和函数名。连续的空条目可通过 <code>M-q</code> (<code>fill-paragraph</code>) 合并。默认情况下，该框架仅包含文件名，不带任何上级目录；若你希望在文件名前添加直至 VC 根目录的上级目录，可自定义变量 <code>diff-add-log-use-relative-names</code> 实现。
</p>

<p>
若当前 VC 文件集中包含一个或多个 ChangeLog 文件（参见《<a href="#Change-Log">变更日志</a>》章节），键入 <code>C-c C-a</code> (<code>log-edit-insert-changelog</code>) ，可将相关的 ChangeLog 条目提取并插入到 <code>*vc-log*</code> 缓冲区中。如果各 ChangeLog 文件中最上方的条目是你以当前用户名在当日创建的，该命令会在该条目中检索与待提交文件匹配的内容，并将其插入。若你使用的是 CVS 或 RCS 系统，可参考《<a href="#Change-Logs-and-VC">变更日志与版本控制</a>》章节，了解反向操作 —— 从日志编辑缓冲区生成 ChangeLog 条目。
</p>

<p>
若要中止本次提交，只需不在 <code>*vc-log*</code> 缓冲区中键入 <code>C-c C-c</code> 即可。你可以切换至其他缓冲区进行其他编辑操作，只要不尝试执行新的提交操作，正在编辑的日志条目就会保留在 <code>*vc-log*</code> 缓冲区中，你可随时返回该缓冲区完成提交。
</p>

<p>
你也可以浏览历史日志条目，复用已有提交注释，这在需要多次提交且注释内容相近时非常实用。用于浏览历史的 <code>M-n</code> 、 <code>M-p</code> 、 <code>M-s</code> 和 <code>M-r</code> 命令，其使用方式与迷你缓冲区的历史记录命令完全一致（参见《<a href="#Minibuffer-History">迷你缓冲区历史记录</a>》章节），区别仅在于这些命令可在迷你缓冲区外使用。
</p>
</div>
</div>
<div id="outline-container-Registering" class="outline-4">
<h4 id="Registering"><span class="section-number-4">30.1.5.</span> 为文件注册版本控制</h4>
<div class="outline-text-4" id="text-Registering">
<dl class="org-dl">
<dt><code>C-x v i</code></dt><dd>将当前打开的文件注册至版本控制系统。</dd>
</dl>

<p>
命令 <code>C-x v i</code> (<code>vc-register</code>) 会将当前 VC 文件集中的所有文件完成 <i>register 注册</i> ，纳入版本控制系统管理。该操作本质上与对未注册的 VC 文件集执行 <code>C-x v v</code> 的效果一致（参见《<a href="#Basic-VC-Editing">版本控制下的基础编辑</a>》章节），唯一区别是：若 VC 文件集已完成注册，执行 <code>C-x v i</code> 会触发错误提示，而 <code>C-x v v</code> 会执行其他对应的版本控制操作。
</p>

<p>
注册文件时，Emacs 需要先选定对应的版本控制系统。针对多文件 VC 文件集，由 VC 目录缓冲区指定所使用的版本控制系统（参见《<a href="#VC-Directory-Mode">VC 目录模式</a>》章节）；针对单文件 VC 文件集，若该文件所在目录中已有文件完成版本控制注册，或该目录属于某一版本控制系统管理的目录树，Emacs 会选用该系统。若存在多个适用的版本控制系统，Emacs 将采用变量 <code>vc-handled-backends</code> 中排在首位的系统（参见《<a href="#Customizing-VC">自定义 VC</a>》章节）。若 Emacs 未找到可用于注册文件的版本控制系统，会提示用户选择代码库类型，创建新的代码库并将文件注册至该代码库中。
</p>

<p>
对于大多数版本控制系统，通过 <code>C-x v i</code> 或 <code>C-x v v</code> 注册文件，仅会将文件添加至工作树，不会执行提交操作 —— 即不会将文件纳入代码库管理。此类文件在 VC 目录缓冲区中会被标记为已添加，打开该文件的缓冲区模式行中，版本标识会显示为 '@@' 。若要让注册操作在代码库中生效，你必须提交这些新添加的文件（参见《<a href="#Basic-VC-Editing">版本控制下的基础编辑</a>》章节）。请注意，单次提交操作可同时包含新添加的文件，以及对版本控制系统中已存在文件的编辑修改。
</p>

<p>
在基于锁定的版本控制系统中（参见《<a href="#VCS-Merging">基于合并与基于锁定的版本控制</a>》章节），文件完成注册后会处于未锁定、只读的状态。需键入 <code>C-x v v</code> 执行检出操作，方可开始编辑文件。
</p>
</div>
</div>
<div id="outline-container-Old-Revisions" class="outline-4">
<h4 id="Old-Revisions"><span class="section-number-4">30.1.6.</span> 查看与比较旧版本</h4>
<div class="outline-text-4" id="text-Old-Revisions">
<dl class="org-dl">
<dt><code>C-x v =</code></dt><dd>将当前版本控制文件集中的工作文件与编辑起始版本进行对比 (<code>vc-diff</code>) 。带前缀参数执行时，会提示输入当前文件集的两个版本并对其进行对比，该命令也可在 Dired 缓冲区中调用（参见《<a href="#Dired">目录编辑器 Dired</a>》章节）。</dd>
<dt><code>M-x vc-ediff</code></dt><dd>功能与 <code>C-x v =</code> 类似，差异为使用 Ediff 工具进行对比，详见《Ediff 使用手册》中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/ediff/index.html#Top">Ediff</a> 相关章节。</dd>
<dt><code>C-x v D</code></dt><dd>将整个工作树与编辑起始版本进行对比 (<code>vc-root-diff</code>) 。带前缀参数执行时，会提示输入两个版本并对比其对应的工作树。</dd>
<dt><code>C-x v ~</code></dt><dd>提示输入当前文件的指定版本，并在独立缓冲区中打开该版本 (<code>vc-revision-other-window</code>) 。</dd>
<dt><code>C-x v g</code></dt><dd>显示当前文件的带注释版本：为每一行标注其最后一次被修改的版本号 (<code>vc-annotate</code>) 。</dd>
</dl>

<p>
<code>C-x v =</code> (<code>vc-diff</code>) 会生成差异对比结果，将当前版本控制文件集中每个工作文件与编辑起始版本进行比对，对比结果会在另一个窗口的 <code>*vc-diff*</code> 缓冲区中显示，该缓冲区采用 Diff 模式（参见《<a href="#Diff-Mode">Diff 模式</a>》章节），可使用 Diff 模式的所有常规命令。其中 <code>g</code> (<code>revert-buffer</code>) 命令会重新执行文件对比并生成新的差异结果。
</p>

<p>
若要对比当前版本控制文件集的任意两个版本，可带前缀参数调用 <code>vc-diff</code> ： (<code>C-u C-x v =</code>) ，该操作会提示输入两个版本标识（参见《<a href="#VCS-Concepts">版本控制的核心概念</a>》章节），并展示这两个版本间的差异。注意：若所使用的版本控制系统为基于文件的类型（如 CVS）而非基于变更集，该操作对多文件版本控制文件集的对比结果可能不可靠，因为不同文件的版本标识之间无实际关联意义。
</p>

<p>
部分版本控制系统支持以非版本标识的格式指定版本，例如在 Bazaar 系统中，执行 <code>C-u C-x v =</code> （及相关命令）时，可输入 'date:yesterday' 作为参数，指定为昨日之后提交的第一个版本。具体格式可参考对应版本控制系统的官方文档。
</p>

<p>
在 Dired 缓冲区中（参见《<a href="#Dired">目录编辑器 Dired</a>》章节）调用 <code>C-x v =</code> 或 <code>C-u C-x v =</code> 时，缓冲区当前行显示的文件会被视为当前版本控制文件集，文件集也可包含多个被标记的文件。
</p>

<p>
<code>M-x vc-ediff</code> 的功能与 <code>C-x v =</code> 基本一致，区别在于该命令会启动 Ediff 会话进行对比，详见《Ediff 使用手册》中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/ediff/index.html#Top">Ediff</a> 相关章节。
</p>

<p>
<code>C-x v D</code> (<code>vc-root-diff</code>) 与 <code>C-x v =</code> 功能类似，差异为该命令会展示当前整个工作树（即包含当前版本控制文件集的工作树）中的所有修改。在 Dired 缓冲区中调用该命令时，对比范围为包含该目录的整个工作树。
</p>

<p>
若要对比整个工作树的任意两个版本，可带前缀参数调用 <code>vc-root-diff</code> ： <code>C-u C-x v D</code> ，该操作会提示输入两个版本标识（参见《<a href="#VCS-Concepts">版本控制的核心概念</a>》章节），并展示这两个版本对应的整个版本控制目录树之间的差异（RCS、SCCS、CVS 和 SRC 系统不支持此功能）。
</p>

<p>
你可自定义 <code>C-x v =</code> 和 <code>C-x v D</code> 生成差异对比时使用的 Diff 参数，所用参数会按顺序从 <code>vc-backend-diff-switches</code> 、 <code>vc-diff-switches</code> 和 <code>diff-switches</code> 这三个变量中，选取第一个非空值（参见《<a href="#Comparing-Files">文件对比</a>》章节）。其中 <i>backend</i> 代表对应的版本控制系统，例如 Bazaar 系统对应 bzr 。由于空值表示继续检查下一个变量，前两个变量均可将值设为 t ，表示不使用任何参数。大多数 <code>vc-backend-diff-switches</code> 变量的默认值为空，部分变量默认值为 t ，这类变量适用于 Subversion 等自身 Diff 实现不支持通用 Diff 参数的版本控制系统。
</p>

<p>
若要直接查看文件的旧版本，可先打开该文件的工作版本，再键入 <code>C-x v ~ 版本号 RET</code> (<code>vc-revision-other-window</code>) 。该操作会提取对应版本的文件内容，保存为文件名 <code>.~revision~</code> 的文件，并在独立窗口中打开。
</p>

<p>
多数版本控制系统支持通过键入 <code>C-x v g</code> (<code>vc-annotate</code>) ，查看带逐行版本信息注释的文件。该命令会创建一个新的 “注释缓冲区”，展示文件内容的同时，为每一行按修改时间上色：红色代表最新修改，蓝色代表最早修改，中间色调对应中间修改时间。默认情况下，颜色会覆盖整个时间跨度，最早的修改为蓝色，最新的修改为红色。若将变量 <code>vc-annotate-background-mode</code> 设为非空值，行的修改时间会通过背景色体现，前景色保持默认。
</p>

<p>
你可通过自定义 <code>vc-backend-annotate-switches</code> 和 <code>vc-annotate-switches</code> 变量，设置 <code>C-x v g</code> 的注释展示参数，这两个变量的作用方式与前文所述的 <code>vc-backend-diff-switches</code> 和 <code>vc-diff-switches</code> 类似。
</p>

<p>
带前缀参数执行 <code>C-x v g</code> 时，Emacs 会通过迷你缓冲区读取两个参数：一是要展示并添加注释的目标版本（替代当前文件内容），二是颜色跨度对应的天数。
</p>

<p>
在 “注释缓冲区” 中，可通过「VC-Annotate」菜单设置上述及其他颜色缩放相关选项，同时可使用以下快捷键浏览历史版本注释、查看差异或查看日志条目：
</p>
<dl class="org-dl">
<dt><code>p</code></dt><dd>为上一个版本添加注释（即当前注释版本的前一个版本）。数字前缀参数表示重复次数，例如 <code>C-u 10 p</code> 会跳回前 10 个版本并添加注释。</dd>
<dt><code>n</code></dt><dd>为下一个版本添加注释（即当前注释版本的后一个版本）。数字前缀参数表示重复次数。</dd>
<dt><code>j</code></dt><dd>为当前行标注的版本添加注释。</dd>
<dt><code>a</code></dt><dd>为当前行标注版本的前一个版本添加注释，便于查看当前行修改前的文件状态。</dd>
<dt><code>f</code></dt><dd>在缓冲区中打开当前行标注的文件版本。</dd>
<dt><code>d</code></dt><dd>展示当前行标注版本与其前一个版本之间的差异，便于查看该版本对当前行的具体修改内容。</dd>
<dt><code>D</code></dt><dd>展示当前行标注版本与其前一个版本在变更集中所有文件的差异（适用于支持变更集的版本控制系统），便于查看该版本对整个工作树的具体修改内容。</dd>
<dt><code>l</code></dt><dd>展示当前行标注版本的日志，便于查看开发者对该版本修改内容的描述。</dd>
<dt><code>w</code></dt><dd>为工作版本添加注释（即正在编辑的版本）。若通过p和n浏览了其他版本，可通过该快捷键返回工作版本。</dd>
<dt><code>v</code></dt><dd>切换注释的显示 / 隐藏状态，便于专注查看文件内容，不受注释干扰。</dd>
</dl>
</div>
</div>
<div id="outline-container-VC-Change-Log" class="outline-4">
<h4 id="VC-Change-Log"><span class="section-number-4">30.1.7.</span> 版本控制变更日志</h4>
<div class="outline-text-4" id="text-VC-Change-Log">
<dl class="org-dl">
<dt><code>C-x v l</code></dt><dd>显示当前文件集的修改历史 (<code>vc-print-log</code>) 。</dd>
<dt><code>C-x v L</code></dt><dd>显示当前代码库的修改历史 (<code>vc-print-root-log</code>) 。</dd>
<dt><code>C-u 1 C-x v L 版本标识 RET</code></dt><dd>显示单个版本的日志条目及修改内容（差异对比） (<code>vc-print-root-log</code>) 。</dd>
<dt><code>C-x v b l</code></dt><dd>显示其他分支的修改历史 (<code>vc-print-branch-log</code>) 。</dd>
<dt><code>C-x v I</code></dt><dd>显示 “pull拉取” 操作将获取的修改内容 (<code>vc-log-incoming</code>) 。</dd>
<dt><code>C-x v O</code></dt><dd>显示下一次 “push推送” 操作将发送的修改内容 (<code>vc-log-outgoing</code>) 。</dd>
<dt><code>C-x v h</code></dt><dd>显示当前缓冲区所打开文件中，选定区域的修改历史 (<code>vc-region-history</code>) 。</dd>
<dt><code>M-x vc-log-search RET</code></dt><dd>在修改历史中搜索指定匹配模式。</dd>
</dl>

<p>
<code>C-x v l</code> (<code>vc-print-log</code>) 会打开名为 <code>*vc-change-log*</code> 的缓冲区，以详细格式展示当前文件集的修改历史，包括修改人、修改日期，以及每次修改对应的日志条目（即你在 <code>*vc-log*</code> 缓冲区中填写的日志条目，参见《<a href="#Log-Buffer">日志条目缓冲区的功能</a>》章节）。若在文件访问缓冲区中调用该命令，当前文件集即为该单个文件，且打开的 <code>*vc-change-log*</code> 缓冲区中，光标会定位在该文件对应版本的位置。若在版本控制目录缓冲区（参见《<a href="#VC-Directory-Mode">版本控制目录模式</a>》章节）或目录编辑器缓冲区（参见《<a href="#Dired">目录编辑器 Dired</a>》章节）中调用，文件集包含所有被标记的文件；若未标记任何文件，则默认以目录缓冲区当前行显示的文件为文件集。
</p>

<p>
若文件集中包含一个或多个目录，若版本控制后端支持，生成的 <code>*vc-change-log*</code> 缓冲区会以简易格式展示修改日志（每条修改占一行）；若不支持，则以详细格式展示。
</p>

<p>
带前缀参数调用该命令时，会提示输入 <code>*vc-change-log*</code> 缓冲区中光标要定位的版本，以及需要展示的最大版本数量。
</p>

<p>
<code>C-x v L</code> (<code>vc-print-root-log</code>) 会打开 <code>*vc-change-log*</code> 缓冲区，展示整个版本控制目录树的修改历史（RCS、SCCS、CVS 和 SRC 系统不支持此功能）。带前缀参数调用时，会提示输入需要展示的最大版本数量；数字型前缀参数可直接指定该最大值，无需再次提示。
</p>

<p>
若数字型前缀参数设为 <code>1</code> （如执行 <code>C-1 C-x v L</code> 或 <code>C-u 1 C-x v L</code> ），该命令会提示输入版本标识，并展示该版本的日志条目，以及其引入的修改内容（差异对比）。（部分功能相对简单的版本控制系统，如 RCS 和 CVS，无命令可同时展示版本日志与差异对比；对于这类系统，该命令仅展示日志条目，你可通过键入 <code>d</code> 或 <code>D</code> 查看差异对比，详见下文。）
</p>

<p>
<code>C-x v L</code> 展示的历史记录为精简格式，通常仅显示每条日志条目的第一行。你可在 <code>*vc-change-log*</code> 缓冲区中键入 <code>RET</code> 回车键 (<code>log-view-toggle-entry-display</code>) ，展开光标所在版本的完整日志条目；再次按下 <code>RET</code> 回车键则会重新隐藏。
</p>

<p>
<code>C-x v b l branch-name RET</code> (<code>vc-print-branch-log</code>) 会打开 <code>*vc-change-log*</code> 缓冲区展示版本控制目录树的修改历史，功能与 <code>vc-print-root-log</code> 一致，区别在于该命令展示的是当前分支之外的其他分支历史，且会先提示输入要查看的分支名称。
</p>

<p>
在分布式版本控制系统中， <code>C-x v I</code> (<code>vc-log-incoming</code>) 命令会打开日志缓冲区，展示下一次执行版本控制系统的拉取命令、从其他远程位置获取新版本时，将应用的修改内容（参见《<a href="#Pulling-_002f-Pushing">将修改拉取 / 推送至分支 / 从分支拉取</a>》章节）。该远程位置为版本控制系统定义的、默认拉取修改的源地址；带前缀参数调用 <code>vc-log-incoming</code> 时，会提示输入具体的远程位置。同理， <code>C-x v O</code> (<code>vc-log-outgoing</code>) 会展示下一次执行推送命令时，将发送至其他远程位置的修改内容；带前缀参数调用时，会提示输入具体的目标地址，部分版本控制系统中该地址也可设为分支名。
</p>

<p>
在 <code>*vc-change-log*</code> 缓冲区中，你可使用以下快捷键在不同版本和文件的日志间导航，以及查看、对比历史版本（参见《<a href="#Old-Revisions">查看并比较旧版本</a>》章节）：
</p>
<dl class="org-dl">
<dt><code>p</code></dt><dd>跳至前一条版本条目（日志缓冲区中的版本条目通常按时间倒序排列，因此前一条条目一般对应更新的版本），数字型前缀参数表示重复跳转次数。</dd>
<dt><code>n</code></dt><dd>跳至下一条版本条目，数字型前缀参数表示重复跳转次数。</dd>
<dt><code>a</code></dt><dd>为当前行对应的版本生成注释标注（参见《查看并比较旧版本》章节）。</dd>
<dt><code>e</code></dt><dd>修改光标所在位置的修改注释，注意并非所有版本控制系统都支持修改注释功能。</dd>
<dt><code>f</code></dt><dd>打开当前行所指向的版本文件。</dd>
<dt><code>d</code></dt><dd>展示光标所在版本与上一个更早版本之间，对应单个文件的差异对比。</dd>
<dt><code>D</code></dt><dd>展示光标所在版本与上一个更早版本之间的变更集差异对比，即该版本中所有文件的修改内容。</dd>
<dt><code>RET</code></dt><dd>在精简格式的日志缓冲区中（如 <code>C-x v L</code> 创建的缓冲区），切换光标所在版本完整日志条目的显示 / 隐藏状态。</dd>
</dl>

<p>
由于获取大量日志条目可能耗时， <code>*vc-change-log*</code> 缓冲区默认最多展示 2000 个版本。变量 <code>vc-log-show-limit</code> 用于指定该上限值，若设为 0 则表示取消限制。你也可点击缓冲区末尾的「显示 2 倍条目」或「显示无限制条目」按钮，增加已有 <code>*vc-change-log*</code> 缓冲区中展示的版本数量（RCS、SCCS、CVS 和 SRC 系统不支持此功能）。
</p>

<p>
<code>vc-region-history</code> 命令（默认绑定至 <code>C-x v h</code> ）提供了查看修改历史的实用变体功能，该命令会打开 <code>*VC-history*</code> 缓冲区，展示当前缓冲区文件中，光标与标记之间选定区域的修改历史（参见《<a href="#Mark">标记与区域</a>》章节）。该修改历史包含提交日志信息，同时也会以差异对比格式展示修改内容本身。
</p>

<p>
先在当前缓冲区中标记出你想要查看修改历史的区域，再调用该命令即可。其弹出的 <code>*VC-history*</code> 缓冲区中，可使用上述 <code>*vc-change-log*</code> 缓冲区的所有命令，同时也支持差异对比模式的各类命令（参见《<a href="#Diff-Mode">差异对比模式</a>》章节）。
</p>

<p>
该命令目前仅适用于 Git 和 Mercurial（hg）系统。
</p>

<p>
<code>vc-log-search</code> 命令可在修改日志中搜索指定匹配模式，该命令会提示输入匹配模式（正则表达式），并展示所有日志信息匹配该模式的修改历史条目。带前缀参数调用时，还会提示输入用于执行该搜索的、版本控制系统的具体 Shell 命令。
</p>
</div>
</div>
<div id="outline-container-VC-Undo" class="outline-4">
<h4 id="VC-Undo"><span class="section-number-4">30.1.8.</span> 撤销版本控制操作</h4>
<div class="outline-text-4" id="text-VC-Undo">
<dl class="org-dl">
<dt><code>C-x v u</code></dt><dd>将当前版本控制文件集中的工作文件恢复至最新版本 (<code>vc-revert</code>) 。</dd>
</dl>

<p>
若你想要舍弃对当前版本控制文件集所做的所有修改，可键入 <code>C-x v u</code> (<code>vc-revert</code>) 。该命令会在舍弃修改前向你确认，确认后文件集将被恢复至原有状态。
</p>

<p>
若变量 <code>vc-revert-show-diff</code> 设为非空值，该命令会先展示工作文件与编辑起始版本之间的差异对比。对比完成后，差异对比缓冲区会被直接关闭（若该变量值设为 <code>kill</code> ），或被隐藏至后台（若设为其他任意非空值）。若你不希望 <code>C-x v u</code> 展示差异对比，可将该变量设为空值（你仍可通过 <code>C-x v =</code> 直接查看差异，参见《<a href="#Old-Revisions">查看并比较旧版本</a>》章节）。
</p>

<p>
在基于锁定的版本控制系统中，执行 <code>C-x v u</code> 后文件会保持未锁定状态；若要继续编辑，你需要重新为文件加锁。若你已锁定文件但后续决定不做任何修改，也可通过 <code>C-x v u</code> 为文件解锁。
</p>
</div>
</div>
<div id="outline-container-VC-Ignore" class="outline-4">
<h4 id="VC-Ignore"><span class="section-number-4">30.1.9.</span> 忽略版本控制文件</h4>
<div class="outline-text-4" id="text-VC-Ignore">
<dl class="org-dl">
<dt><code>C-x v G</code></dt><dd>将文件设为当前版本控制系统的忽略文件 (<code>vc-ignore</code>) 。</dd>
</dl>

<p>
许多源码目录中会包含无需纳入版本管理的文件，例如编辑器备份文件、目标文件、字节码文件以及编译生成的程序文件等。你可以选择不将这些文件添加到版本控制中，但这样它们会始终以未知文件的形式显示。你也可以将这些文件添加至目录树根目录的忽略文件中，告知版本控制系统忽略它们， <code>C-x v G</code> (<code>vc-ignore</code>) 命令可协助你完成这一操作。带前缀参数调用该命令时，可将文件从忽略文件列表中移除。
</p>
</div>
</div>
<div id="outline-container-VC-Directory-Mode" class="outline-4">
<h4 id="VC-Directory-Mode"><span class="section-number-4">30.1.10.</span> 版本控制目录模式</h4>
<div class="outline-text-4" id="text-VC-Directory-Mode">
<p>
<i>VC Directory buffer版本控制目录缓冲区</i> 是一款专用缓冲区，用于查看目录树中各文件的版本控制状态，并对这些文件执行版本控制操作。该缓冲区的核心用途之一，是为 <code>C-x v v</code> 等命令指定待操作的多文件版本控制文件集（参见《<a href="#VC-Directory-Commands">版本控制目录缓冲区命令</a>》章节）。
</p>

<p>
要使用版本控制目录缓冲区，键入 <code>C-x v d</code> (<code>vc-dir</code>) 即可。该命令会通过迷你缓冲区读取目录名称，并切换至对应目录的版本控制目录缓冲区。缓冲区默认命名为 <code>*vc-dir*</code> ，其具体内容说明参见《<a href="#VC-Directory-Buffer">版本控制目录缓冲区</a>》章节。
</p>

<p>
<code>vc-dir</code> 命令会自动检测指定目录中使用的版本控制系统。若该目录中同时使用了多个版本控制系统，需带前缀参数调用此命令（ <code>C-u C-x v d</code> ），命令会提示你指定版本控制目录缓冲区要使用的版本控制系统。
</p>

<p>
除版本控制目录缓冲区外，Emacs 还提供了一款功能类似的工具 ——PCL-CVS，该工具是专为 CVS 系统设计的专用工具，详见《<a href="https://www.gnu.org/software/emacs/manual/html_node/pcl-cvs/index.html#Top">PCL-CVS 简介：CVS 的 Emacs 前端</a>》章节。
</p>

<p>
你也可在 Dired 缓冲区中调用版本控制相关命令（参见《<a href="#Dired">目录编辑器 Dired</a>》章节）。在此场景下，你调用的所有版本控制命令都会将被标记的文件视作当前文件集（参见《<a href="#Basic-VC-Editing">版本控制下的基础编辑</a>》章节）；若未标记任何文件，则默认以当前行的文件作为操作对象。
</p>

<ul class="org-ul">
<li><a href="#VC-Directory-Buffer">版本控制目录缓冲区</a></li>
<li><a href="#VC-Directory-Commands">版本控制目录命令</a></li>
</ul>
</div>
<div id="outline-container-VC-Directory-Buffer" class="outline-5">
<h5 id="VC-Directory-Buffer"><span class="section-number-5">30.1.10.1.</span> 版本控制目录缓冲区</h5>
<div class="outline-text-5" id="text-VC-Directory-Buffer">
<p>
版本控制目录缓冲区中会列出受版本控制的文件及其版本控制状态，仅展示当前目录（即调用 <code>C-x v d</code> 时指定的目录）及其子目录中 <b>状态特殊</b> 的文件，与代码库内容保持一致的最新文件会被省略；若某个子目录下的所有文件均为最新状态，该子目录也不会被列出。例外情况为：若某文件因执行 VC 命令直接变为最新状态，该文件仍会被列出。
</p>

<p>
以下是 VC 目录缓冲区的列表示例：
</p>

<div class="org-src-container">
<pre class="src src-shell">                     ./
    edited           configure.ac
*   added            README
    unregistered     temp.txt
                     src/
*   edited           src/main.c
</pre>
</div>

<p>
有两个工作文件已修改但未提交：当前目录下的 <code>configure.ac</code> 和 <code>src/</code> 子目录下的 <code>main.c</code> ； <code>README</code> 文件已添加至版本控制但尚未提交；而 <code>temp.txt</code> 文件未被纳入版本控制（参见《<a href="#Registering">将文件注册到版本控制系统</a>》章节）。
</p>

<p>
<code>README</code> 和 <code>src/main.c</code> 条目旁的 '<code>*</code>' 符号，表示用户已将这些文件标记为 <b>当前 VC 文件集</b> （参见《<a href="#VC-Directory-Commands">版本控制目录缓冲区命令</a>》章节）。
</p>

<p>
上述示例是 Bazaar、Git、Mercurial 等分布式版本控制系统的典型显示形式，其他系统会展示不同的状态标识。例如，若代码库中的修改尚未同步至工作文件，CVS 会为该文件标注 'needs-update' （需更新）状态；RCS 和 SCCS 则会将锁定文件的用户名作为该文件的状态展示。
</p>

<p>
在 CVS 系统中， <code>vc-dir</code> 命令通常会连接代码库（该代码库可能位于远程服务器）检查更新。若将变量 <code>vc-cvs-stay-local</code> 设为 <code>nil</code> （参见《<a href="#CVS-Options">CVS 专属配置项</a>》章节），Emacs 在生成版本控制目录缓冲区时会避免连接远程代码库（仅在必要时仍会建立连接，例如执行提交操作时）。该设置适用于离线工作或网络速度较慢的场景。
</p>

<p>
版本控制目录缓冲区会忽略变量 <code>vc-directory-exclusion-list</code> 中列出的子目录，该变量的默认值包含版本控制系统内部使用的各类目录。
</p>
</div>
</div>
<div id="outline-container-VC-Directory-Commands" class="outline-5">
<h5 id="VC-Directory-Commands"><span class="section-number-5">30.1.10.2.</span> 版本控制目录命令</h5>
<div class="outline-text-5" id="text-VC-Directory-Commands">
<p>
Emacs 提供了多个命令，用于在版本控制目录缓冲区中导航，以及将文件标记为当前版本控制文件集的成员。
</p>

<dl class="org-dl">
<dt><code>n</code></dt><dd></dd>

<dt><code>SPC</code></dt><dd>将光标移至下一个条目 (<code>vc-dir-next-line</code>) 。</dd>
<dt><code>p</code></dt><dd>将光标移至上一个条目 (<code>vc-dir-previous-line</code>) 。</dd>
<dt><code>TAB</code></dt><dd>移至下一个目录条目 (<code>vc-dir-next-directory</code>) 。</dd>
<dt><code>S-TAB</code></dt><dd>移至上一个目录条目 (<code>vc-dir-previous-directory</code>) 。</dd>
<dt><code>RET</code></dt><dd></dd>

<dt><code>f</code></dt><dd>打开当前行列出的文件或目录 (<code>vc-dir-find-file</code>) 。</dd>
<dt><code>o</code></dt><dd>在独立窗口中打开当前行的文件或目录 (<code>vc-dir-find-file-other-window</code>) 。</dd>
<dt><code>m</code></dt><dd><p>
标记当前行的文件或目录 (<code>vc-dir-mark</code>) ，将其加入当前版本控制文件集。若区域处于激活状态，则标记区域内的所有文件。
</p>

<p>
若文件已位于被标记的目录或其子目录中，无法通过此命令标记该文件；同理，若目录树中存在已标记的文件，也无法通过此命令标记该目录。
</p></dd>
<dt><code>M</code></dt><dd>若光标位于文件条目上，标记所有同状态的文件；若光标位于目录条目上，标记该目录树中的所有文件 (<code>vc-dir-mark-all-files</code>) 。带前缀参数时，标记所有列出的文件和目录。</dd>
<dt><code>% m</code></dt><dd></dd>

<dt><code>* %</code></dt><dd>通过正则表达式标记文件 (<code>vc-dir-mark-by-regexp</code>) 。带前缀参数时，执行反向取消标记操作。</dd>
<dt><code>* r</code></dt><dd>标记所有处于已注册状态的文件，包括已编辑、已添加或已移除的文件 (<code>vc-dir-mark-registered-files</code>) 。</dd>
<dt><code>G</code></dt><dd>将光标所在文件加入版本控制的忽略文件列表 (<code>vc-dir-ignore</code>) 。例如，若使用 Git 作为版本控制系统，该命令会将此文件追加至 <code>.gitignore</code> 文件中。带前缀参数时，对所有已标记文件执行此操作。</dd>
<dt><code>q</code></dt><dd>退出版本控制目录缓冲区并将其隐藏至后台 (<code>quit-window</code>) 。</dd>
<dt><code>u</code></dt><dd>取消标记当前行的文件或目录。若区域处于激活状态，则取消标记区域内的所有文件 (<code>vc-dir-unmark</code>) 。</dd>
<dt><code>U</code></dt><dd>若光标位于文件条目上，取消标记所有同状态的文件；若光标位于目录条目上，取消标记该目录树中的所有文件 (<code>vc-dir-unmark-all-files</code>) 。带前缀参数时，取消标记所有文件和目录。</dd>
<dt><code>x</code></dt><dd>隐藏状态为「up-to-date最新」或「ignored已忽略」的文件 (<code>vc-dir-hide-up-to-date</code>) 。带前缀参数时，隐藏所有与光标所在条目状态相同的项。</dd>
</dl>

<p>
在版本控制目录缓冲区中，通过 <code>m</code> (<code>vc-dir-mark</code>) 或 <code>M</code> (<code>vc-dir-mark-all-files</code>) 标记的所有文件，均会归入当前版本控制文件集。若使用 <code>m</code> 标记目录条目，则该目录树中所有列出的文件都会加入当前版本控制文件集。属于当前版本控制文件集的文件和目录，会在版本控制目录缓冲区中其状态旁标注 '<code>*</code>' 符号。通过这种方式，你可以创建多文件版本控制文件集，供 <code>C-x v v</code> （参见《<a href="#Basic-VC-Editing">版本控制下的基础编辑</a>》）、 <code>C-x v =</code> （参见《<a href="#Old-Revisions">查看并比较旧版本</a>》）、 <code>C-x v u</code> （参见《<a href="#VC-Undo">撤销版本控制操作</a>》）等版本控制命令操作。
</p>

<p>
版本控制目录缓冲区还为带 <code>C-x v</code> 前缀的版本控制命令定义了部分单键快捷方式：=、+、l、i、D、L、G、I、O 和 v。
</p>

<p>
例如，提交一组已编辑文件的操作流程为：打开版本控制目录缓冲区（其中已编辑文件会标注「edited」状态）→ 标记目标文件 → 键入 <code>v</code> 或 <code>C-x v v</code> (<code>vc-next-action</code>) 。若使用的是基于变更集的版本控制系统，Emacs 会将这些文件一次性提交为一个新版本。
</p>

<p>
在版本控制目录缓冲区中，还可对当前版本控制文件集执行查找和替换操作，相关命令如下：
</p>
<dl class="org-dl">
<dt><code>S</code></dt><dd>在文件集中执行查找 (<code>vc-dir-search</code>) 。</dd>
<dt><code>Q</code></dt><dd>在文件集中执行正则表达式查询替换 (<code>vc-dir-query-replace-regexp</code>) 。</dd>
<dt><code>M-s a C-s</code></dt><dd>在文件集中执行增量查找 (<code>vc-dir-isearch</code>) 。</dd>
<dt><code>M-s a C-M-s</code></dt><dd>在文件集中执行增量正则表达式查找 (<code>vc-dir-isearch-regexp</code>) 。</dd>
</dl>

<p>
除可作用于多个文件外，这些命令的行为与单缓冲区对应的查找替换命令基本一致（参见《<a href="#Search">查找与替换</a>》章节）。
</p>

<p>
版本控制目录缓冲区还定义了一组以 <code>b</code> 为前缀的分支相关命令：
</p>
<dl class="org-dl">
<dt><code>b c</code></dt><dd>创建新分支 (<code>vc-create-branch</code>) ，参见《<a href="#Creating-Branches">创建新分支</a>》章节。</dd>
<dt><code>b l</code></dt><dd>提示输入分支名称，并展示该分支的修改历史 (<code>vc-print-branch-log</code>) 。</dd>
<dt><code>b s</code></dt><dd>切换至指定分支 (<code>vc-switch-branch</code>) ，参见《<a href="#Switching-Branches">分支间的切换</a>》章节。</dd>
<dt><code>d</code></dt><dd>删除已标记的文件；若无标记文件，则删除当前行文件 (<code>vc-dir-clean-delete</code>) 。该命令不会在版本控制系统中将文件标记为已删除，因此主要适用于未注册的文件。</dd>
</dl>

<p>
上述所有命令均可通过菜单栏调用，也可通过鼠标中键（ <code>mouse-2</code> ）调出的上下文菜单调用。此外，部分版本控制后端会通过菜单提供专属的扩展命令，例如 Git 和 Bazaar 支持操作暂存区与搁置区（二者均用于临时保存未提交的修改，并可在后续恢复这些修改）。
</p>
</div>
</div>
</div>
<div id="outline-container-Branches" class="outline-4">
<h4 id="Branches"><span class="section-number-4">30.1.11.</span> 版本控制分支</h4>
<div class="outline-text-4" id="text-Branches">
<p>
版本控制的一项用途是支持多条独立的开发线，这些开发线被称为 <i>branche分支</i> 。分支可用于多种场景，例如维护程序相互独立的稳定版本与开发版本，以及在隔离环境中开发互不相关的功能模块。
</p>

<p>
目前版本控制（VC）对分支操作的支持尚较为有限。针对分布式版本控制系统，VC 提供了相关命令，可将一个分支的内容更新至另一分支，也可合并对两个不同分支所做的修改（参见《<a href="#Merging">合并分支</a>》章节）。针对集中式版本控制系统，VC 支持检出不同分支，并将修改提交至新分支或其他已有分支。
</p>

<ul class="org-ul">
<li><a href="#Switching-Branches">分支切换</a></li>
<li><a href="#Pulling-_002f-Pushing">分支间的变更拉取 / 推送</a></li>
<li><a href="#Merging">分支合并</a></li>
<li><a href="#Creating-Branches">新建分支</a></li>
</ul>
</div>
<div id="outline-container-Switching-Branches" class="outline-5">
<h5 id="Switching-Branches"><span class="section-number-5">30.1.11.1.</span> 分支切换</h5>
<div class="outline-text-5" id="text-Switching-Branches">
<p>
不同版本控制系统对分支的实现方式存在差异，而这些差异无法通过版本控制（VC）完全屏蔽。
</p>

<p>
在部分分布式版本控制系统中 —— 包括 Bazaar、以及默认模式下的 Mercurial，每个分支都拥有独立的工作目录树，因此分支间的切换仅需切换目录即可。在 Git 中，分支通常共存于同一目录下，通过 <code>git checkout</code> 命令完成分支切换，该命令会修改工作树的内容，使其与目标分支保持一致。Bazaar 也支持分支共存模式，此种情况下可通过 <code>bzr switch</code> 命令在当前目录中切换分支。在 Subversion 中，使用 <code>svn switch</code> 命令切换至其他分支；在 Mercurial 中，切换分支则通过 <code>hg update</code> 命令实现。
</p>

<p>
在当前目录中切换至其他分支的 VC 命令为： <code>C-x v b s branch-name RET</code>  (<code>vc-switch-branch</code>) 。
</p>

<p>
在集中式版本控制系统中，也可在 <b>状态为最新</b> 的工作文件中键入 <code>C-u C-x v v</code> （参见《<a href="#Advanced-C_002dx-v-v">C-x v v 的高级用法</a>》章节），并输入其他分支上某一版本的版本标识，完成分支切换。例如在 CVS 中，主干（主开发线）的版本标识格式通常为 1.1、1.2、1.3……；基于版本 1.2 创建的第一个分支，其版本标识为 1.2.1.1、1.2.1.2……；基于版本 1.2 创建的第二个分支，版本标识则为 1.2.2.1、1.2.2.2……，依此类推。你也可指定 <b><i>branch ID分支标识</i></b> （即去掉最后一个组成部分的分支版本标识，如 1.2.1），直接切换至该分支的最新版本。
</p>

<p>
在基于锁定的版本控制系统中，切换至其他分支的同时，会对工作树执行解锁操作（设置为写保护状态）。
</p>

<p>
切换至某一分支后，所有 VC 命令将默认作用于该分支，直至你切换至其他分支；例如，你提交的所有版本控制文件集，都会被提交至该特定分支。
</p>
</div>
</div>
<div id="outline-container-Pulling-_002f-Pushing" class="outline-5">
<h5 id="Pulling-_002f-Pushing"><span class="section-number-5">30.1.11.2.</span> 分支间的变更拉取 / 推送</h5>
<div class="outline-text-5" id="text-Pulling-_002f-Pushing">
<dl class="org-dl">
<dt><code>C-x v P</code></dt><dd>在分布式版本控制系统中，将当前分支的本地提交修改同步至另一代码库（又称推送修改）。该概念在集中式版本控制系统中不存在。</dd>
<dt><code>C-x v +</code></dt><dd>在分布式版本控制系统中，从另一代码库拉取修改，更新本地代码库的当前分支。在集中式版本控制系统中，从代码库更新当前版本控制文件集。</dd>
</dl>

<p>
在分布式版本控制系统中， <code>C-x v P</code> (<code>vc-push</code>) 会将当前分支的本地提交修改，同步至另一远程位置（通常为上游代码库）。带前缀参数执行时，命令会提示输入要运行的具体版本控制命令，你可通过该方式指定修改的推送目标；不同系统的默认推送命令分别为：Bazaar 使用 <code>bzr push</code> 、Git 使用 <code>git push</code> 、Mercurial 使用 <code>hg push</code> 。默认命令会始终将修改推送至版本控制系统根据分支配置确定的默认位置的代码库。
</p>

<p>
执行推送操作前，可使用 <code>C-x v O</code> (<code>vc-log-outgoing</code>) 查看即将推送到上游的修改日志缓冲区，详见《<a href="#VC-Change-Log">版本控制变更日志</a>》章节。
</p>

<p>
该命令目前仅支持 Bazaar、Git 和 Mercurial 系统。 <b>推送</b> 的概念在集中式版本控制系统中并不存在，此类系统中该操作属于变更集提交的一部分，因此在集中式版本控制系统中调用该命令会触发错误提示。若在 Bazaar 的绑定分支中执行该命令，同样会触发错误 —— 因为绑定分支中提交变更集时，会自动将修改推送至本地分支所绑定的远程代码库。
</p>

<p>
在分布式版本控制系统中， <code>C-x v +</code> (<code>vc-pull</code>) 会从上游代码库拉取修改，更新本地代码库的当前分支及其工作树。该命令通常用于更新远程分支的副本（又称克隆版）。带前缀参数执行时，命令会提示输入要使用的具体版本控制命令，你可通过该方式指定修改的拉取源；若未带前缀参数，会从版本控制系统根据分支配置确定的默认位置的代码库拉取修改。
</p>

<p>
在分布式版本控制系统中， <code>C-x v +</code> 命令目前仅支持 Bazaar、Git 和 Mercurial 系统。在 Bazaar 中，该命令对普通分支调用 <code>bzr pull</code> （将主分支的修改拉取至镜像分支），对绑定分支调用 <code>bzr update</code> （从中央代码库拉取修改）；在 Git 中，调用 <code>git pull</code> 从远程代码库获取修改并合并至当前分支；在 Mercurial 中，调用 <code>hg pull -u</code> 从默认远程代码库获取变更集并更新工作目录。
</p>

<p>
执行拉取操作前，可使用 <code>C-x v I</code> (<code>vc-log-incoming</code>) 查看即将应用的修改日志缓冲区，详见《<a href="#VC-Change-Log">版本控制变更日志</a>》章节。
</p>

<p>
在 CVS 等集中式版本控制系统中， <code>C-x v +</code> 命令的作用是从代码库更新当前版本控制文件集。
</p>
</div>
</div>
<div id="outline-container-Merging" class="outline-5">
<h5 id="Merging"><span class="section-number-5">30.1.11.3.</span> 分支合并</h5>
<div class="outline-text-5" id="text-Merging">
<dl class="org-dl">
<dt><code>C-x v m</code></dt><dd><p>
在分布式版本控制系统中，将其他分支的修改合并至当前分支。
</p>

<p>
在集中式版本控制系统中，将其他分支的修改合并至当前版本控制文件集。
</p></dd>
</dl>

<p>
在分支开发过程中，你有时需要将其他分支中已完成的修改合并至当前分支。这并非简单的操作，因为两个分支可能存在重叠的修改，甚至出现修改冲突。
</p>

<p>
在分布式版本控制系统中，可通过 <code>C-x v m</code> (<code>vc-merge</code>) 执行合并操作。在 Bazaar 系统中，该命令会提示输入需传递给 <code>bzr merge</code> 命令的具体参数，并在可能的情况下提供合理的默认值；在 Git 系统中，会提示输入待合并的分支名称，且支持补全功能（基于当前代码库中已有的分支名）；在 Mercurial 系统中，会提示输入需传递给 <code>hg merge</code> 命令的参数。合并命令的输出结果会在独立的缓冲区中展示。
</p>

<p>
在 CVS 等集中式版本控制系统中， <code>C-x v m</code> 会提示输入分支标识，或一对版本标识（参见《<a href="#Switching-Branches">分支间的切换</a>》章节）；随后系统会提取该分支的修改，或你指定的两个版本之间的修改，并将这些修改合并至当前版本控制文件集。若你在提示时直接按下回车键，Emacs 会直接合并自你检出文件后，同一分支上产生的所有修改。
</p>

<p>
执行合并操作后，仅有工作树会被修改，你可通过 <code>C-x v D</code> 及相关命令查看合并产生的修改内容（参见《<a href="#Old-Revisions">查看并比较旧版本</a>》章节）。若两个分支存在重叠的修改，合并操作会产生 <i>conflict冲突</i> ；合并命令的输出结果中会出现警告提示，且每个受影响的工作文件中会插入 <i>conflict markers冲突标记</i> ，将两组冲突的修改内容包裹其中。此时你需要通过编辑文件解决冲突，Emacs 默认会将包含版本控制冲突的缓冲区置于专用的 <b>Smerge 模式</b> ，该模式提供了用于解决合并冲突的专属命令。冲突解决完成并保存文件后，你必须按常规方式提交这些文件，合并操作才能正式生效（参见《<a href="#Basic-VC-Editing">版本控制下的基础编辑</a>》章节）。
</p>
</div>
</div>
<div id="outline-container-Creating-Branches" class="outline-5">
<h5 id="Creating-Branches"><span class="section-number-5">30.1.11.4.</span> 新建分支</h5>
<div class="outline-text-5" id="text-Creating-Branches">
<p>
在 CVS 这类集中式版本控制系统中，Emacs 支持将创建新分支作为提交操作的一部分。提交已修改的版本控制文件集时，键入 <code>C-u C-x v v</code> （带前缀参数的 <code>vc-next-action</code> 命令，参见《<a href="#Advanced-C_002dx-v-v">C-x v v 的高级用法</a>》章节），Emacs 会随即提示为新版本指定版本标识。你需要为基于当前版本创建的新分支，设定一个合适的分支标识。例如，若当前版本标识为 2.5，那么新分支的标识可设为 2.5.1、2.5.2 等，具体编号根据该节点已有的分支数量而定。
</p>

<p>
该操作流程不适用于 Git、Mercurial 这类分布式版本控制系统，此类系统中需使用 <code>vc-create-branch</code> 命令（ <code>C-x v b c branch-name RET</code> ）来创建新分支。
</p>

<p>
若要在旧版本（已非某分支最新版本的版本）上创建新分支，需先选中该版本（参见《<a href="#Switching-Branches">分支间的切换</a>》章节），后续操作步骤则根据所使用的是基于锁定还是基于合并的版本控制系统有所不同。
</p>

<p>
在基于锁定的版本控制系统中，你需要通过 <code>C-x v v</code> 为该旧版本分支加锁。锁定旧版本时，系统会让你确认是否确实要创建新分支 —— 若选择否，系统会提供锁定最新版本的选项。而在基于合并的版本控制系统中，可跳过此步骤。
</p>

<p>
完成上述操作后，对文件做出所需修改，再次键入 <code>C-x v v</code> 提交新版本，即可从选中的旧版本开始创建一条新分支。
</p>

<p>
新分支创建完成后，后续的所有提交操作都会在该分支上生成新版本。若要退出该分支，你必须通过 <code>C-u C-x v v</code> 显式选中其他版本。
</p>
</div>
</div>
</div>
<div id="outline-container-Miscellaneous-VC" class="outline-4">
<h4 id="Miscellaneous-VC"><span class="section-number-4">30.1.12.</span> 版本控制的杂项命令与功能</h4>
<div class="outline-text-4" id="text-Miscellaneous-VC">
<p>
本节介绍版本控制（VC）中一些较少使用的功能。
</p>

<ul class="org-ul">
<li><a href="#Change-Logs-and-VC">变更日志与版本控制</a></li>
<li><a href="#VC-Delete_002fRename">删除与重命名版本控制文件</a></li>
<li><a href="#Revision-Tags">版本标签</a></li>
<li><a href="#Version-Headers">插入版本控制头信息</a></li>
<li><a href="#Editing-VC-Commands">编辑版本控制命令</a></li>
<li><a href="#Preparing-Patches">准备补丁文件</a></li>
</ul>
</div>
<div id="outline-container-Change-Logs-and-VC" class="outline-5">
<h5 id="Change-Logs-and-VC"><span class="section-number-5">30.1.12.1.</span> 变更日志与版本控制</h5>
<div class="outline-text-5" id="text-Change-Logs-and-VC">
<p>
若你在维护带有 ChangeLog 文件的程序时使用 RCS 或 CVS 版本控制系统（参见《<a href="#Change-Log">变更日志</a>》章节），可通过过往提交的版本控制日志条目，自动生成变更日志条目。
</p>

<p>
注意：该功能仅适用于 RCS 和 CVS 系统。在现代基于变更集的版本控制系统中，此操作方式并不适用 —— 这类系统中，对 ChangeLog 文件的修改通常会作为变更集的一部分一同提交。此种情况下，你应先编写好变更日志条目，再在提交时将其提取至 <code>*vc-log*</code> 缓冲区中（参见《<a href="#Log-Buffer">日志条目缓冲区的功能</a>》章节）。
</p>

<dl class="org-dl">
<dt><code>C-x v a</code></dt><dd>打开当前目录的 ChangeLog 文件，并为该目录下的已注册文件，针对自最新变更日志条目之后提交的版本创建新的变更日志条目 (<code>vc-update-change-log</code>) 。</dd>

<dt><code>C-u C-x v a</code></dt><dd>功能与上述命令一致，仅针对当前缓冲区对应的文件生成相关条目。</dd>
</dl>

<p>
举例来说，假设 ChangeLog 文件的首行日期为 1999-04-10，此后仅有纳撒尼尔・鲍迪奇（Nathaniel Bowditch）在 1999-05-22 向 rcs2log 提交过一次版本，其日志条目为「Ignore log messages that start with '#'.」，执行 <code>C-x v a</code> 后，会在 ChangeLog 中插入如下条目：
</p>

<div class="org-src-container">
<pre class="src src-shell">1999-05-22  Nathaniel Bowditch  <a href="mailto:nat%40apn.org">&lt;nat@apn.org&gt;</a>

        * rcs2log: Ignore log messages that start with <span style="color: #8b2252;">'#'</span>.
</pre>
</div>

<p>
若版本控制日志条目中指定了函数名（位于某行开头的圆括号内），该信息也会体现在生成的变更日志条目中。例如， <code>vc.el</code> 文件的某条日志条目为「(vc-do-command): Check call-process status.」，则生成的变更日志条目为：
</p>

<div class="org-src-container">
<pre class="src src-shell">1999-05-06  Nathaniel Bowditch  <a href="mailto:nat%40apn.org">&lt;nat@apn.org&gt;</a>

        * vc.el (vc-do-command): Check call-process status.
</pre>
</div>

<p>
当 <code>C-x v a</code> 一次性添加多条变更日志条目时，若多条条目为同一作者在相近时间提交，命令会将这些相关条目归为一组；若多个文件对应的日志条目文本完全相同，会将其合并为单个条目。
</p>
</div>
</div>
<div id="outline-container-VC-Delete_002fRename" class="outline-5">
<h5 id="VC-Delete_002fRename"><span class="section-number-5">30.1.12.2.</span> 删除与重命名版本控制文件</h5>
<div class="outline-text-5" id="text-VC-Delete_002fRename">
<dl class="org-dl">
<dt><code>M-x vc-delete-file</code></dt><dd>提示输入文件名，将该文件从工作树中删除，并将此删除操作标记为待提交状态。</dd>
<dt><code>M-x vc-rename-file</code></dt><dd>提示输入两个文件名（原文件名和新文件名），在工作树中完成文件重命名，并将此重命名操作标记为待提交状态。若当前缓冲区的文件受版本控制管理，原文件名会默认填充为该文件名。</dd>
</dl>

<p>
若你想要删除受版本控制的文件，请使用 <code>M-x vc-delete-file</code> 命令。该命令会先提示输入待删除的文件名，再通过版本控制系统执行删除操作。文件会从工作树中移除，且在版本控制目录缓冲区中（参见《<a href="#VC-Directory-Mode">版本控制目录模式</a>》章节），该文件会被标注为 'removed' （已移除）状态。当你执行提交操作后，此次删除才会在代码库中正式生效。
</p>

<p>
若要重命名受版本控制的文件，键入 <code>M-x vc-rename-file</code> 即可。该命令会依次提示输入两个参数：待重命名的原文件名和新文件名，随后通过版本控制系统完成重命名。重命名操作会立即在工作树中生效，待你提交该重命名后的文件后，此次修改才会在代码库中正式生效。
</p>

<p>
对于原生支持重命名操作的现代版本控制系统，重命名后的文件会保留原文件的完整修改历史。而在 CVS 及其他早期版本控制系统中， <code>vc-rename-file</code> 命令的实际执行逻辑为：以新文件名创建原文件的副本并完成注册，再删除原文件；此种情况下，文件的修改历史无法被保留。
</p>
</div>
</div>
<div id="outline-container-Revision-Tags" class="outline-5">
<h5 id="Revision-Tags"><span class="section-number-5">30.1.12.3.</span> 版本标签</h5>
<div class="outline-text-5" id="text-Revision-Tags">
<p>
大多数版本控制系统都支持为版本控制目录树的特定版本添加 <b><i>revision tag版本标签</i></b> 。在现代基于变更集的版本控制系统中，版本标签只是某一特定版本的符号名称；而在 CVS 这类早期的基于文件的系统中，标签会被添加至所有受版本控制的文件中，使这些文件可作为一个整体被管理。版本标签通常用于标识分发给用户的软件发布版本。
</p>

<p>
针对标签操作有两个基础命令：一个用于创建指定名称的标签，另一个用于调取已命名的标签。
</p>
<dl class="org-dl">
<dt><code>C-x v s name RET</code></dt><dd>将当前目录及其子目录下所有已注册文件的工作版本，定义为名为 <b>标签名</b> 的版本标签 (<code>vc-create-tag</code>) 。</dd>
<dt><code>C-x v r name RET</code></dt><dd>为当前目录及其子目录下的所有已注册文件，调取标有标签名的版本。若该名称为分支名，且所使用的版本控制系统会区分分支与标签，此命令会切换至对应分支 (<code>vc-retrieve-tag</code>) 。</dd>
</dl>

<p>
若当前目录及其子目录下存在任何被锁定的文件，该命令会直接抛出错误，且不执行任何修改操作；此设计是为了避免覆盖正在进行的工作内容。
</p>

<p>
你可将标签名或分支名作为参数，传入 <code>C-x v =</code> 或 <code>C-x v ~</code> 命令中（参见《<a href="#Old-Revisions">查看并比较旧版本</a>》章节）。通过这种方式，你可以将带标签的版本与当前文件进行对比，也可对两个带标签的版本相互对比。
</p>

<p>
在 SCCS 系统中，版本标签功能由 VC 自行实现，这类标签仅能通过 VC 查看；而后续的大多数版本控制系统（包括 CVS、Subversion、Bazaar、Git 和 Mercurial）都拥有原生的标签功能，VC 会在可用时直接调用该功能，这类标签即便不通过 VC 操作也能被查看。
</p>

<p>
在基于文件的版本控制系统中，若你重命名了已注册的文件，需同时重命名其主文件， <code>vc-rename-file</code> 命令会自动完成这一操作（参见《<a href="#VC-Delete_002fRename">删除和重命名受版本控制的文件</a>》章节）。若使用的是 SCCS 系统，你还需更新标签记录，将文件的新名称录入其中（该操作 <code>vc-rename-file</code> 也会自动完成）。若某一旧标签所指向的主文件，已不再以记录中的名称存在，该标签将失效，VC 也无法再调取此标签。本手册不会详细讲解如何手动更新 RCS 和 SCCS 的标签，相关内容超出了手册的讲解范围。使用 <code>vc-rename-file</code> 命令虽能保证标签仍可被正常调取，但无法解决所有问题。例如，程序中的部分文件可能会通过文件名引用其他文件，至少编译配置文件（ <code>makefile</code> ）中大概率会提及你重命名的文件。若你调取某一旧标签，被重命名的文件会以新名称被调取，而这并非编译配置文件所期望的文件名，因此调取后的程序将无法正常运行。
</p>
</div>
</div>
<div id="outline-container-Version-Headers" class="outline-5">
<h5 id="Version-Headers"><span class="section-number-5">30.1.12.4.</span> 插入版本控制头信息</h5>
<div class="outline-text-5" id="text-Version-Headers">
<p>
在 Subversion、CVS、RCS 和 SCCS 系统中，你可以在工作文件中加入一类名为 <i>version headers版本头信息</i> 的特殊字符串。当文件被提交时，版本控制系统会自动将版本号、提交者用户名以及其他相关信息填充到该版本头信息中。
</p>

<p>
版本控制（VC）通常不会调用版本头信息中的内容。仅有一个例外：使用 RCS 系统时，若文件中存在版本头信息，Emacs 会通过它来确定文件版本 —— 因为这种方式往往比读取 RCS 主文件更可靠。若要禁止该行为，可将变量 <code>vc-consult-headers</code> 设为 <code>nil</code> ，此后 VC 会始终通过文件权限（若开启了文件权限信任机制）来判断，或直接检查主文件。
</p>

<p>
要在当前缓冲区中插入合适的头信息字符串，可使用命令 <code>M-x vc-insert-headers</code> 。该命令仅适用于 Subversion、CVS、RCS 和 SCCS 系统。变量 <code>vc-backend-header</code> 中存储了需要插入版本头信息的关键字列表；例如 CVS 系统会使用变量 <code>vc-cvs-header</code> ，其默认值为 <code>'("\$Id\$")</code> （额外的反斜杠是为了防止：若定义该变量的 Emacs Lisp 文件本身受版本控制管理，这个字符串常量会被误解析为版本头信息）。 <code>vc-insert-headers</code> 命令会将列表中的每个关键字，在光标位置单独另起一行插入，两侧用制表符分隔；若有需要，还会将关键字包裹在对应语言的注释定界符中。
</p>

<p>
变量 <code>vc-static-header-alist</code> 可根据缓冲区名称，指定需要额外添加的头信息字符串。该变量的值为一个列表，每个元素的格式为 <code>(正则表达式 . 格式字符串)</code> 。当正则表达式匹配当前缓冲区名称时，对应的格式字符串也会作为版本头信息的一部分被插入。格式字符串中的%s会被替换为该文件所使用的版本控制类型。
</p>
</div>
</div>
<div id="outline-container-Editing-VC-Commands" class="outline-5">
<h5 id="Editing-VC-Commands"><span class="section-number-5">30.1.12.5.</span> 编辑版本控制命令</h5>
<div class="outline-text-5" id="text-Editing-VC-Commands">
<p>
你可以使用前缀命令 <code>C-x v !</code> (<code>vc-edit-next-command</code>) 编辑版本控制（VC）即将执行的 Shell 命令行。该功能主要用于为版本控制系统命令添加可选的命令行参数，同时避免让 VC 的命令集及其与后端的接口产生不必要的复杂改动。
</p>

<p>
例如，Git 可生成多个分支的日志，但 <code>C-x v b l</code> (<code>vc-print-branch-log</code>) 命令仅会提示输入单个分支的名称。若要获取多个分支的日志，你可以键入 <code>C-x v ! C-x v b l</code> ，随后在 VC 即将执行的 <code>git log</code> 命令末尾追加其他分支的名称即可。
</p>
</div>
</div>
<div id="outline-container-Preparing-Patches" class="outline-5">
<h5 id="Preparing-Patches"><span class="section-number-5">30.1.12.6.</span> 准备补丁文件</h5>
<div class="outline-text-5" id="text-Preparing-Patches">
<p>
在项目协作过程中，通过电子邮件发送补丁文件来共享修改内容是一种常见做法。你可以使用 VC 的 <code>vc-prepare-patch</code> 命令完成此操作。该命令会先提示你输入想要共享的版本号，以及接收补丁的目标邮箱地址（多个地址按 <i>crm-separator</i> 的取值分隔，默认以逗号分隔）。随后命令会通过你的邮件用户代理（MUA）处理这些版本的补丁文件，生成后供你检查并发送。
</p>

<p>
若在日志查看缓冲区中，已标记部分版本并以交互方式调用该命令，系统将直接使用这些被标记的版本生成补丁。
</p>

<p>
根据用户配置项 <code>vc-prepare-patches-separately</code> 的取值， <code>vc-prepare-patch</code> 命令会生成一封或多封邮件：默认值 <code>t</code> 表示为每个版本单独生成一封邮件，依次展示；若设为 <code>nil</code> ，则会生成单封邮件，并将所有补丁文件附加在邮件正文中。
</p>

<p>
若你需要定期提交补丁文件，可将用户配置项 <code>vc-default-patch-addressee</code> 设为常用的接收邮箱地址，该地址会在调用 <code>vc-prepare-patch</code> 时作为默认值使用。项目维护者可将该配置项设为目录局部变量（参见《<a href="#Directory-Variables">按目录设置局部变量</a>》章节）。
</p>
</div>
</div>
</div>
<div id="outline-container-Customizing-VC" class="outline-4">
<h4 id="Customizing-VC"><span class="section-number-4">30.1.13.</span> 定制版本控制</h4>
<div class="outline-text-4" id="text-Customizing-VC">
<p>
变量 <code>vc-handled-backends</code> 用于指定版本控制（VC）需要支持的版本控制系统。其默认值为(RCS CVS SVN SCCS SRC Bzr Git Hg)，包含当前所有受支持的版本控制系统。若希望 VC 忽略其中一个或多个系统，将对应系统名称从该列表中移除即可。若要完全禁用 VC，将该变量设为 <code>nil</code> 。
</p>

<p>
列表中各系统的排序具有实际意义：当你打开一个在多个系统中均完成注册的文件时，VC 默认会使用 <code>vc-handled-backends</code> 中排在靠前位置的系统；文件首次注册时（参见《<a href="#Registering">将文件注册到版本控制系统</a>》章节），系统的排序也会影响 VC 的选择逻辑。
</p>

<ul class="org-ul">
<li><a href="#General-VC-Options">通用选项</a></li>
<li><a href="#RCS-and-SCCS">RCS 与 SCCS 相关选项</a></li>
<li><a href="#CVS-Options">CVS 专用选项</a></li>
</ul>
</div>
<div id="outline-container-General-VC-Options" class="outline-5">
<h5 id="General-VC-Options"><span class="section-number-5">30.1.13.1.</span> 通用选项</h5>
<div class="outline-text-5" id="text-General-VC-Options">
<p>
Emacs 通常不会为受版本控制的源文件生成备份文件。若希望即便对版本控制文件也生成备份文件，可将变量 <code>vc-make-backup-files</code> 设为非空值。
</p>

<p>
若你未察觉符号链接指向的是受版本控制的文件，通过该符号链接编辑此文件可能会导致意外结果。变量 <code>vc-follow-symlinks</code> 用于控制 Emacs 打开指向版本控制文件的符号链接时的行为：值设为 <code>ask</code> （默认值）时，Emacs 会先请求确认；设为 <code>nil</code> 时，仅显示警告信息；设为 <code>t</code> 时，会自动跟随符号链接并打开实际的文件。
</p>

<p>
若将 <code>vc-suppress-confirm</code> 设为非空值，执行 <code>C-x v v</code> 和 <code>C-x v i</code> 时会直接保存当前缓冲区而不弹出确认提示，执行 <code>C-x v u</code> 时也会直接操作，无需确认。
</p>

<p>
VC 模式的大部分操作，都是通过执行对应版本控制系统的 Shell 命令完成的。若将 <code>vc-command-messages</code> 设为非空值，版本控制模块会实时显示正在执行的 Shell 命令，且在命令执行完成后展示额外的提示信息。
</p>
</div>
</div>
<div id="outline-container-RCS-and-SCCS" class="outline-5">
<h5 id="RCS-and-SCCS"><span class="section-number-5">30.1.13.2.</span> RCS 与 SCCS 相关选项</h5>
<div class="outline-text-5" id="text-RCS-and-SCCS">
<p>
默认情况下，RCS 通过加锁机制协调多用户的操作，同时也支持非严格加锁模式，该模式下无需先锁定文件即可提交修改。可使用 <code>rcs -U</code> 命令为指定文件开启非严格加锁模式，详细说明参见 RCS 的手册页。
</p>

<p>
VC 推导 RCS 文件的版本控制状态时，会首先在文件中查找 RCS 版本头信息字符串（参见《<a href="#Version-Headers">插入版本控制头信息</a>》章节）。若文件中无此头信息字符串，VC 通常会检查工作文件的文件权限，该方式效率较高。但部分场景下文件权限不可信，此时就必须读取主文件信息，该操作的开销相对较大。此外，主文件仅能告知文件是否被加锁，无法验证当前工作文件是否为该加锁版本。
</p>

<p>
将变量 <code>vc-consult-headers</code> 设为 <code>nil</code> ，可让 VC 不再通过版本头信息判断文件状态。此后 VC 会始终优先通过文件权限判断（若开启了文件权限信任机制），否则直接检查主文件。
</p>

<p>
VC 判断 SCCS 文件版本控制状态的逻辑与 RCS 基本一致，但不会读取 SCCS 的版本头信息，因此变量 <code>vc-consult-headers</code> 的设置对 SCCS 的使用无任何影响。
</p>
</div>
</div>
<div id="outline-container-CVS-Options" class="outline-5">
<h5 id="CVS-Options"><span class="section-number-5">30.1.13.3.</span> CVS 专用选项</h5>
<div class="outline-text-5" id="text-CVS-Options">
<p>
可在变量 <code>vc-cvs-global-switches</code> 中指定需要传递给所有 CVS 操作的额外命令行参数，这些参数会直接插入在cvs命令后、待执行的操作名之前。
</p>

<p>
当使用位于远程服务器的 CVS 代码库时，VC 可尽量减少网络交互，该行为由变量 <code>vc-cvs-stay-local</code> 控制。若该变量值为 <code>only-file</code> （默认值），VC 仅会通过本地 CVS 子目录中的条目，以及此前 CVS 命令返回的信息，判断每个文件的版本控制状态。这会导致一种情况：若你修改了某文件后，其他用户又向代码库提交了该文件的修改，你在尝试提交自己的修改前，不会收到任何冲突提醒。
</p>

<p>
若将 <code>vc-cvs-stay-local</code> 设为 <code>nil</code> ，VC 在执行 <code>vc-next-action</code> 命令（ <code>C-x v v</code> ）并决定操作逻辑前，会先查询远程代码库，与处理本地代码库的逻辑保持一致。
</p>

<p>
你也可将 <code>vc-cvs-stay-local</code> 设为正则表达式，该表达式会与代码库的主机名进行匹配；此时 VC 仅会对主机名匹配该规则的代码库采用本地查询的方式。
</p>

<p>
使用远程代码库时，Emacs 通常会为每个被编辑文件的原始版本自动创建版本备份。当你首次保存对某文件的修改时，这些本地备份就会生成，而在你将修改提交至代码库后，备份文件会被自动删除。（注意：这类备份并非 Emacs 的普通备份文件，详见《<a href="#Backup">备份文件</a>》章节。） <code>C-x v =</code> 、 <code>C-x v u</code> 等命令会尽可能使用这些自动版本备份，以避免发起网络请求。
</p>

<p>
将 <code>vc-cvs-stay-local</code> 设为 <code>nil</code> 会禁用自动版本备份功能。
</p>

<p>
自动版本备份的文件名格式为文件 <code>.~version.~</code> ，与 <code>C-x v ~</code> 命令保存旧版本时的命名格式相近（详见《<a href="#Old-Revisions">查看并比较旧版本</a>》章节），区别仅在于版本号后多了一个英文句点（'.'）。相关 VC 命令可兼容这两种版本备份，核心差异是： <code>C-x v ~</code> 创建的手动版本备份，不会在你执行提交操作后被自动删除。
</p>

<p>
CVS 默认不使用加锁机制，但可通过其 <code>CVSREAD</code> 或 <i>watch</i> 功能实现类加锁的行为，详细说明参见 CVS 官方文档。若开启了该功能，你可在 Emacs 中使用 <code>C-x v v</code> 命令切换文件的加锁状态，操作方式与基于加锁机制的版本控制系统一致（详见《<a href="#VC-With-A-Locking-VCS">基于加锁的基础版本控制操作</a>》章节）。
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-Projects" class="outline-3">
<h3 id="Projects"><span class="section-number-3">30.2.</span> 项目管理</h3>
<div class="outline-text-3" id="text-Projects">
<p>
<i>project项目</i> 是用于开发一个或多个程序的文件集合。属于某一项目的文件通常存储在层级目录结构中，该结构的顶层目录被称为 <b><i>project root项目根目录</i></b> 。
</p>

<p>
一个目录是否为某项目的根目录，由项目专属的底层架构（即 <b><i>project back-end项目后端</i></b> ）判定。Emacs 目前支持两种项目后端：一是支持版本控制（VC）的后端（参见《<a href="#Version-Control">版本控制</a>》章节），该后端将版本控制系统（VCS）的代码库视作一个项目；二是 EDE 后端（即 Emacs 开发环境，参见《<a href="#EDE">Emacs 开发环境</a>》章节）。未来该功能还会扩展，以支持更多类型的项目。
</p>

<p>
哪些文件属于或不属于某一项目，同样由项目后端判定。例如，支持版本控制的项目后端不会将「ignored被忽略的文件」（参见《<a href="#VC-Ignore">忽略版本控制文件</a>》章节）纳入项目范围；同时，该后端默认会将「untracked未被追踪的文件」视作项目的一部分，此行为可通过变量 <code>project-vc-include-untracked</code> 进行控制。
</p>

<dl class="org-dl">
<dt>用户配置项： <code>project-mode-line</code></dt><dd>若该用户配置项设为非空值，Emacs 会在模式行显示当前项目的名称（若存在）；在项目名称上单击 <code>mouse-1</code> 鼠标左键，会弹出包含所有项目相关命令的菜单。该配置项默认值为 <code>nil</code> 。</dd>
</dl>


<ul class="org-ul">
<li><a href="#Project-File-Commands">作用于文件的项目命令</a></li>
<li><a href="#Project-Buffer-Commands">作用于缓冲区的项目命令</a></li>
<li><a href="#Switching-Projects">项目切换</a></li>
<li><a href="#Managing-Projects">项目列表文件管理</a></li>
</ul>
</div>
<div id="outline-container-Project-File-Commands" class="outline-4">
<h4 id="Project-File-Commands"><span class="section-number-4">30.2.1.</span> 作用于文件的项目命令</h4>
<div class="outline-text-4" id="text-Project-File-Commands">
<dl class="org-dl">
<dt><code>C-x p f</code></dt><dd>打开当前项目中的文件 (<code>project-find-file</code>) 。</dd>
<dt><code>C-x p g</code></dt><dd>在当前项目的所有文件中查找正则表达式匹配内容 (<code>project-find-regexp</code>) 。</dd>
<dt><code>M-x project-search</code></dt><dd>以交互方式在当前项目的所有文件中查找正则表达式匹配内容。</dd>
<dt><code>C-x p r</code></dt><dd>在当前项目的所有文件中对正则表达式执行查询替换 (<code>project-query-replace-regexp</code>) 。</dd>
<dt><code>C-x p D</code></dt><dd>在当前项目的根目录中启动 Dired 目录编辑器 (<code>project-dired</code>) 。</dd>
<dt><code>C-x p v</code></dt><dd>在当前项目的根目录中启动版本控制目录缓冲区 (<code>project-vc-dir</code>) 。</dd>
<dt><code>C-x p s</code></dt><dd>在当前项目的根目录中启动子 Shell (<code>project-shell</code>) 。</dd>
<dt><code>C-x p e</code></dt><dd>在当前项目的根目录中启动 Eshell (<code>project-eshell</code>) 。</dd>
<dt><code>C-x p c</code></dt><dd>在当前项目的根目录中执行编译操作 (<code>project-compile</code>) 。</dd>
<dt><code>C-x p !</code></dt><dd>在当前项目的根目录中执行 Shell 命令 (<code>project-shell-command</code>) 。</dd>
<dt><code>C-x p &amp;</code></dt><dd>在当前项目的根目录中异步执行 Shell 命令 (<code>project-async-shell-command</code>) 。</dd>
<dt><code>C-x p o</code></dt><dd>在当前项目中执行后续输入的任意命令 (<code>project-any-command</code>) 。</dd>
</dl>

<p>
Emacs 提供了一系列便捷操作项目文件的命令，本节将对这些命令进行详细说明。
</p>

<p>
本节介绍的所有命令均基于 <b><i>current project当前项目</i></b> 的概念运行。当前项目由调用命令时的当前缓冲区的默认目录（参见《<a href="#File-Names">文件名</a>》章节）判定；若该目录不属于可识别的项目，这些命令会提示你输入项目目录。
</p>

<p>
<code>C-x p f</code> (<code>project-find-file</code>) 命令可便捷打开当前项目中的文件（参见《<a href="#Visiting">打开文件</a>》章节）。与 <code>C-x C-f</code> 不同，该命令无需输入待打开文件的完整路径，仅需输入文件的基名（即省略前置目录）即可。此外，该命令的补全候选列表仅包含当前项目的文件，无其他无关内容。若光标位置存在文件名，该命令会将此文件名作为「future history未来历史记录」的首个候选项；带前缀参数执行时，会包含项目根目录下的所有文件（ <code>vc-directory-exclusion-list</code> 中列出的版本控制系统目录除外）。
</p>

<p>
<code>C-x p g</code> (<code>project-find-regexp</code>) 命令与rgrep功能类似（参见《<a href="#Grep-Searching">在 Emacs 中使用 Grep 查找</a>》章节），但仅在当前项目的文件中执行查找。该命令会提示输入待查找的正则表达式，随后在 Xref 模式缓冲区中展示查找结果，你可通过 Xref 模式的相关命令选择匹配项（参见《<a href="#Xref-Commands">xref缓冲区中的可用命令</a>》章节）。带前缀参数执行时，该命令会额外提示输入查找的起始基目录，例如可通过此方式将查找范围限定在项目根目录下的某个子目录内。该命令的匹配结果展示方式，受 <code>xref-auto-jump-to-first-xref</code> 变量值影响（参见《<a href="#Identifier-Search">通过标识符查找与替换</a>》章节）。
</p>

<p>
<code>M-x project-search</code> 是 <code>project-find-regexp</code> 的连续查找版。该命令会提示输入待在项目文件中查找的正则表达式，但不会一次性查找所有匹配项并展示，而是找到首个匹配项后即停止，同时打开该匹配文件并定位至匹配位置，方便你对文件进行编辑。若要继续查找后续匹配项，键入 <code>M-x fileloop-continue RET</code> 即可。
</p>

<p>
<code>C-x p r</code> (<code>project-query-replace-regexp</code>) 命令与 <code>project-search</code> 功能类似，但会像 <code>query-replace</code> 命令一样（参见《<a href="#Query-Replace">查询替换</a>》章节），对每个找到的匹配项提示你是否执行替换，你做出响应后再继续查找下一个匹配项。若你的响应导致 Emacs 退出查询替换循环，后续可通过 <code>M-x fileloop-continue RET</code> 恢复执行。
</p>

<p>
<code>C-x p d</code> (<code>project-find-dir</code>) 命令会通过补全功能，提示你选择当前项目内的目录，随后打开 Dired 缓冲区列出该目录下的文件（参见《<a href="#Dired">目录编辑器 Dired</a>》章节）。
</p>

<p>
<code>C-x p D</code> (<code>project-dired</code>) 命令会打开 Dired 缓冲区，列出当前项目根目录下的所有文件（参见《<a href="#Dired">目录编辑器 Dired</a>》章节）。
</p>

<p>
<code>C-x p v</code> (<code>project-vc-dir</code>) 命令会打开版本控制目录缓冲区，列出当前项目根目录下整个目录树中文件的版本控制状态（参见《<a href="#VC-Directory-Mode">版本控制目录模式</a>》章节）。
</p>

<p>
<code>C-x p s</code> (<code>project-shell</code>) 命令会在新缓冲区中启动 Shell 会话，并将当前项目根目录设为工作目录（参见《<a href="#Shell">从 Emacs 中执行 Shell 命令</a>》章节）。
</p>

<p>
<code>C-x p e</code> (<code>project-eshell</code>) 命令会在新缓冲区中启动 Eshell 会话，并将当前项目根目录设为工作目录（参见《<a href="https://www.gnu.org/software/emacs/manual/html_node/eshell/index.html#Top">Eshell：Emacs 内置 Shell</a>》章节）。
</p>

<p>
<code>C-x p c</code> (<code>project-compile</code>) 命令会在当前项目的根目录中执行编译操作（参见《<a href="#Compilation">在 Emacs 中执行编译</a>》章节）。
</p>

<p>
<code>C-x p !</code> (<code>project-shell-command</code>) 命令会在当前项目的根目录中执行 Shell 命令。
</p>

<p>
<code>C-x p &amp;</code> (<code>project-async-shell-command</code>) 命令会在当前项目的根目录中异步执行 Shell 命令。
</p>

<p>
最后， <code>C-x p o</code> (<code>project-any-command</code>) 命令可让你在当前项目环境中，执行后续输入的任意命令（无论是否与文件相关）。
</p>
</div>
</div>
<div id="outline-container-Project-Buffer-Commands" class="outline-4">
<h4 id="Project-Buffer-Commands"><span class="section-number-4">30.2.2.</span> 作用于缓冲区的项目命令</h4>
<div class="outline-text-4" id="text-Project-Buffer-Commands">
<dl class="org-dl">
<dt><code>C-x p b</code></dt><dd>切换至当前项目的其他缓冲区 (<code>project-switch-to-buffer</code>) 。</dd>
<dt><code>C-x p C-b</code></dt><dd>列出当前项目的所有缓冲区 (<code>project-list-buffers</code>) 。</dd>
<dt><code>C-x p k</code></dt><dd>关闭当前项目的所有活动缓冲区 (<code>project-kill-buffers</code>) 。</dd>
<dt><code>C-x p o</code></dt><dd>在当前项目中执行后续输入的任意命令 (<code>project-any-command</code>) 。</dd>
</dl>

<p>
进行项目开发时，Emacs 中可能会打开大量属于该项目的缓冲区 —— 既包括打开了项目文件的缓冲区，也包括属于项目但未关联任何文件的缓冲区（例如 <code>project-compile</code> 命令创建的 <code>*compilation*</code> 编译缓冲区）。 <code>C-x p b</code> (<code>project-switch-to-buffer</code>) 命令可便捷实现当前项目内的缓冲区切换，该命令会提示输入目标缓冲区名称，且补全候选列表仅包含当前项目的缓冲区。
</p>

<p>
与 <code>list-buffers</code> 命令功能类似（参见《<a href="#List-Buffers">列出已存在的缓冲区</a>》章节）， <code>C-x p C-b</code> (<code>project-list-buffers</code>) 命令会列出已存在的缓冲区，但仅展示属于当前项目的缓冲区内容。
</p>

<p>
当你完成某个项目的开发工作后，可关闭该项目的所有相关缓冲区，以精简 Emacs 的会话环境， <code>C-x p k</code> (<code>project-kill-buffers</code>) 命令可实现此功能：该命令会关闭当前项目中所有满足 <code>project-kill-buffer-conditions</code> 变量判定条件的活动缓冲区。若 <code>project-kill-buffers-display-buffer-list</code> 变量设为非空值，命令会先展示待关闭的缓冲区列表，再执行关闭操作。
</p>

<p>
最后， <code>C-x p o</code> (<code>project-any-command</code>) 命令可让你在当前项目环境中，执行后续输入的任意命令（无论是否与缓冲区相关）。
</p>
</div>
</div>
<div id="outline-container-Switching-Projects" class="outline-4">
<h4 id="Switching-Projects"><span class="section-number-4">30.2.3.</span> 项目切换</h4>
<div class="outline-text-4" id="text-Switching-Projects">
<dl class="org-dl">
<dt><code>C-x p p</code></dt><dd>为其他项目执行 Emacs 命令 (<code>project-switch-project</code>) 。</dd>
</dl>

<p>
对项目文件执行操作的相关命令（参见《<a href="#Project-File-Commands">对文件执行操作的项目命令</a>》章节），在当前无可用项目时，会便捷地提示你输入项目目录。若你正处于某一项目中，却需要对另一项目执行操作，可使用 <code>C-x p p</code> (<code>project-switch-project</code>) 。该命令会提示你从已识别的项目根目录中选择一个目录，随后展示可对所选项目执行的命令菜单。变量 <code>project-switch-commands</code> 用于控制该菜单中的可用命令，以及每个命令对应的调用快捷键。
</p>

<p>
变量 <code>project-list-file</code> 指定了 Emacs 用于记录已识别项目列表的文件，其默认值为 <code>user-emacs-directory</code> 目录下的projects文件（参见《<a href="#Find-Init">Emacs 如何查找你的初始化文件</a>》章节）。
</p>
</div>
</div>
<div id="outline-container-Managing-Projects" class="outline-4">
<h4 id="Managing-Projects"><span class="section-number-4">30.2.4.</span> 项目列表文件管理</h4>
<div class="outline-text-4" id="text-Managing-Projects">
<dl class="org-dl">
<dt><code>M-x project-forget-project</code></dt><dd>将已识别的项目从项目列表文件中移除。</dd>
</dl>

<p>
Emacs 通常会自动在项目列表文件中添加和移除项目，但有时你可能需要手动编辑可用项目列表。执行 <code>M-x project-forget-project</code> 后，命令会提示你从现有可用项目中选择一个，随后将该项目从项目列表文件中移除。
</p>
</div>
</div>
</div>
<div id="outline-container-Change-Log" class="outline-3">
<h3 id="Change-Log"><span class="section-number-3">30.3.</span> 变更日志</h3>
<div class="outline-text-3" id="text-Change-Log">
<p>
许多软件项目都会维护一份 <i>change log变更日志</i> ，这是一个通常命名为 <code>ChangeLog</code> 的文件，按时间顺序记录程序的修改时间与修改内容。有时这类文件会从版本控制系统中存储的变更日志条目自动生成，也可能用于生成这些日志条目；部分项目会维护多个变更日志文件，分别记录某一目录或目录树中的修改内容。
</p>
<ul class="org-ul">
<li><a href="#Change-Log-Commands">变更日志命令</a></li>
<li><a href="#Format-of-ChangeLog">ChangeLog 文件的格式</a></li>
</ul>
</div>
<div id="outline-container-Change-Log-Commands" class="outline-4">
<h4 id="Change-Log-Commands"><span class="section-number-4">30.3.1.</span> 变更日志命令</h4>
<div class="outline-text-4" id="text-Change-Log-Commands">
<p>
Emacs 命令 <code>C-x 4 a</code> 会为当前编辑的文件在变更日志文件中添加一条新条目 (<code>add-change-log-entry-other-window</code>) 。若当前编辑的是备份文件，该命令会为原文件添加适配的条目 —— 此功能适用于为当前版本中已删除的函数编写日志条目。
</p>

<p>
执行 <code>C-x 4 a</code> 会打开变更日志文件并创建新条目， <b>除非</b> 最新的条目已是你以本人名义在今日创建的。该命令还会为当前文件创建一个新的条目项，对于多数编程语言，它甚至能自动推测出被修改的函数或其他对象的名称。
</p>

<p>
Emacs 会从当前编辑文件所在目录开始，向上遍历目录树查找变更日志文件。默认情况下，若找到版本控制代码库的根目录，查找会停止；可通过自定义变量 <code>change-log-directory-files</code> 修改此规则。
</p>

<p>
当变量 <code>add-log-keep-changes-together</code> 设为非空值时， <code>C-x 4 a</code> 会在该文件已有的条目项中追加内容，而非新建条目项。
</p>

<p>
你可将多个同类型的修改合并记录。若首次执行 <code>C-x 4 a</code> 后未输入任何文本，后续再次执行 <code>C-x 4 a</code> 会为该变更日志条目添加另一个相关符号。
</p>

<p>
若变量 <code>add-log-always-start-new-record</code> 设为非空值，无论上一条目是否由你在当日创建， <code>C-x 4 a</code> 都会始终新建一条条目。
</p>

<p>
当变量 <code>change-log-version-info-enabled</code> 设为非空值时， <code>C-x 4 a</code> 会将文件的版本号添加至变更日志条目中。它会搜索文件的前 10% 内容，通过变量 <code>change-log-version-number-regexp-list</code> 中的正则表达式匹配获取版本号。
</p>

<p>
打开变更日志文件时，Emacs 会自动启用 <b>变更日志模式</b> 。在该主模式下，一组相关的条目项视为一个段落，每条日志条目视为一个页面，以此简化条目编辑操作。按下 <code>C-j</code> 或触发自动换行时，新行会继承上一行的缩进格式，方便录入条目内容。
</p>

<p>
启用变更日志模式后，可使用命令 <code>change-log-goto-source</code> （默认绑定快捷键 <code>C-c C-c</code> ）跳至光标附近的变更日志条目对应的源码位置。此后，连续执行 <code>next-error</code> 命令（默认绑定快捷键 <code>M-g M-n</code> 和 <code>C-x `</code> ）可在变更日志的各条目间跳转，且会直接跳转到文件中实际被修改的位置，而非仅在日志条目间切换；也可使用 <code>previous-error</code>  命令向后跳转日志条目。
</p>

<p>
可使用命令 <code>M-x change-log-merge</code> 将其他日志文件合并至变更日志模式的缓冲区中，且会保留条目按日期的排序规则。
</p>

<p>
版本控制系统是另一种追踪程序修改、维护变更日志的方式。如今许多使用版本控制系统的项目，不会再维护单独的带版本控制的变更日志文件，因此你可能希望将此类文件排除在代码库外。若变量 <code>add-log-dont-create-changelog-file</code> 设为非空值，当变更日志文件尚未存在时， <code>C-x 4 a</code> (<code>add-change-log-entry-other-window</code>) 等命令会将修改记录在一个命名规范的临时缓冲区中，而非创建实际的文件。
</p>

<p>
无论你使用实体的变更日志文件，还是临时缓冲区记录变更日志，若存在相关的变更日志条目，均可在版本控制日志缓冲区中按下 <code>C-c C-a</code> (<code>log-edit-insert-changelog</code>) 插入这些条目。详见《<a href="#Log-Buffer">日志条目缓冲区的功能</a>》章节。
</p>
</div>
</div>
<div id="outline-container-Format-of-ChangeLog" class="outline-4">
<h4 id="Format-of-ChangeLog"><span class="section-number-4">30.3.2.</span> ChangeLog 文件的格式</h4>
<div class="outline-text-4" id="text-Format-of-ChangeLog">
<p>
一条变更日志条目以标题行开头，标题行包含当前日期、你的姓名（取自变量 <code>add-log-full-name</code> ）以及电子邮箱地址（取自变量 <code>add-log-mailing-address</code> ）。除标题行外，变更日志中的所有行均以空格或制表符开头。日志条目的主体由若干条目项组成，每个条目项的起始行均为「空白符 + 星号」的格式。以下是两个示例条目，均记录于 1993 年 5 月，分别包含两个条目项和一个条目项：
</p>

<div class="org-src-container">
<pre class="src src-shell">1993-05-25  Richard Stallman  <a href="mailto:rms%40gnu.org">&lt;rms@gnu.org&gt;</a>

        * man.el: Rename symbols <span style="color: #8b2252;">'man-*'</span> to <span style="color: #8b2252;">'Man-*'</span>.
        (manual-entry): Make prompt string clearer.

        * simple.el (blink-matching-paren-distance):
        Change default to 12,000.

1993-05-24  Richard Stallman  <a href="mailto:rms%40gnu.org">&lt;rms@gnu.org&gt;</a>

        * vc.el (minor-mode-map-alist): Don<span style="color: #8b2252;">'t use it if it'</span>s void.
        (vc-cancel-version): Doc fix.
</pre>
</div>

<p>
单个日志条目可描述多项修改内容，每项修改应单独作为一个条目项，或作为同一条目项中的独立行。条目项之间通常需保留一个空行；若多个条目项彼此关联（如同一修改在不同位置的实现），则无需空行，将其归为一组即可。
</p>

<p>
你需要在变更日志文件的末尾添加版权声明和授权声明，示例如下：
</p>

<div class="org-src-container">
<pre class="src src-shell">Copyright 1997--1998, 2025 Free Software Foundation, Inc.
Copying and distribution of this file, with or without modification, are
permitted provided the copyright notice and this notice are preserved.
</pre>
</div>

<p>
当然，你需要将示例中的年份和版权持有方替换为实际信息。
</p>
</div>
</div>
</div>
<div id="outline-container-Xref" class="outline-3">
<h3 id="Xref"><span class="section-number-3">30.4.</span> 查找标识符引用</h3>
<div class="outline-text-3" id="text-Xref">
<p>
<i>identifier标识符</i> 指程序语法子单元的名称，包括函数、子程序、方法、类、数据类型、宏等。在编程语言中，每个标识符都是该语言语法中的一个符号，标识符也被称作 <i>tag标记</i> 。
</p>

<p>
程序的开发与维护，需要具备快速查找各标识符的定义位置和引用位置、在整个项目中重命名标识符等能力。这些能力在非编程类的主模式中查找引用时同样适用，例如文本文档或 TeX 文档中的章节、小节、附录等也可被视作子单元，其名称可作为标识符使用。在本章中， <b>identifiers标识符</b> 一词为统称，既包括程序源码中的各类子单元名称，也涵盖其他文本中的子单元名称。
</p>

<p>
Emacs 为这些功能提供了一个统一的接口，即 'Xref' （交叉引用）。
</p>

<p>
Xref 需结合对应主模式的专属信息和方法实现功能，例如要检索哪些文件中的标识符、如何查找标识符的引用、如何对标识符进行补全等，这些均为与模式相关的专属逻辑。Xref 会将这类模式相关的功能委托给对应主模式提供的后端实现；对于未实现专属后端的主模式，Xref 也为其部分命令提供了默认实现。
</p>

<p>
Xref 后端可通过多种方式实现功能，以下为几类典型示例：
</p>

<ol class="org-ol">
<li>部分主模式内置了语言符号的查找方式。例如 Emacs Lisp 模式的后端，可通过检索 Emacs Lisp 解释器维护的包加载历史、查阅内置文档字符串来识别 Emacs Lisp 符号，进而实现符号定义的查找。（此类后端的一个缺点是，仅能识别已加载到解释器中的子单元。）</li>

<li>若当前缓冲区所属项目（参见《<a href="#Projects">项目操作</a>》章节）和主模式已启用 Eglot 插件，Eglot 会调用外部语言服务器程序，获取服务器提供的项目内标识符定义相关数据并对接至 Xref。详见《Eglot：Emacs 语言服务器协议客户端》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/eglot_html/Eglot-Features.html#Eglot-Features">Eglot 功能</a>》章节。</li>
<li>可通过外部程序扫描相关文件提取标识符引用信息，并构建引用数据库，后端在需要列出或查找引用时直接访问该数据库即可。Emacs 发行版中内置了 <code>etags</code> 工具，该命令可提取程序中的标识符定义并生成标记表，支持多种编程语言及 HTML 等非编程主模式，相关说明参见《<a href="#Create-Tags-Table">创建标记表</a>》章节。支持 etags 的语言主模式，可将标记表作为其后端的实现基础。（此类后端的一个缺点是，标记表需要定期重新构建，才能保证内容的时效性。）</li>
</ol>



<ul class="org-ul">
<li><a href="#Find-Identifiers">查找标识符</a></li>
<li><a href="#Tags-Tables">标签表</a></li>
<li><a href="#Select-Tags-Table">选择标签表</a></li>
</ul>
</div>
<div id="outline-container-Find-Identifiers" class="outline-4">
<h4 id="Find-Identifiers"><span class="section-number-4">30.4.1.</span> 查找标识符</h4>
<div class="outline-text-4" id="text-Find-Identifiers">
<p>
本节介绍用于查找标识符引用并对标识符执行各类查询的命令。标识符的每一处引用，既可以是 <b><i>define an identifier标识符的定义</i></b> （例如给出程序子单元的实现代码、文档章节的正文内容），也可以是 <b><i>use th identifier标识符的使用</i></b> （例如调用某个函数或方法、为变量赋值、在交叉引用中提及某一章节等）。
</p>

<ul class="org-ul">
<li><a href="#Looking-Up-Identifiers">标识符查阅</a></li>
<li><a href="#Xref-Commands">xref 缓冲区中的可用命令</a></li>
<li><a href="#Identifier-Search">基于标识符的搜索与替换</a></li>
<li><a href="#List-Identifiers">标识符查询</a></li>
</ul>
</div>
<div id="outline-container-Looking-Up-Identifiers" class="outline-5">
<h5 id="Looking-Up-Identifiers"><span class="section-number-5">30.4.1.1.</span> 标识符查阅</h5>
<div class="outline-text-5" id="text-Looking-Up-Identifiers">
<p>
xref 最核心的功能，是帮助你查找指定标识符的定义位置。
</p>

<dl class="org-dl">
<dt><code>M-.</code></dt><dd>查找标识符的定义 (<code>xref-find-definitions</code>)</dd>
<dt><code>C-M-. pattern RET</code></dt><dd>查找名称匹配指定模式的所有标识符 (<code>xref-find-apropos</code>)</dd>
<dt><code>C-x 4 . RET</code></dt><dd>查找标识符的定义，并在另一个窗口中展示结果 (<code>xref-find-definitions-other-window</code>)</dd>
<dt><code>C-x 5 . RET</code></dt><dd>查找标识符的定义，并在新框架中展示结果 (<code>xref-find-definitions-other-frame</code>)</dd>
<dt><code>M-x xref-find-definitions-at-mouse</code></dt><dd>查找鼠标点击位置的标识符定义</dd>
<dt><code>M-,</code></dt><dd>返回上一次调用M-.及相关命令的位置 (<code>xref-go-back</code>)</dd>
<dt><code>C-M-,</code></dt><dd>前进到上一次调用M-,后跳转离开的位置 (<code>xref-go-forward</code>)</dd>
<dt><code>M-x xref-etags-mode</code></dt><dd>切换 <code>xref</code> 至 <code>etags</code> 后端模式</dd>
</dl>

<p>
<code>M-.</code> (<code>xref-find-definitions</code>) 会查找光标所在位置标识符的定义。若带前缀参数执行，或光标处无标识符，命令会提示你输入待查找的标识符（若希望该命令始终弹出输入提示，可将配置项 <code>xref-prompt-for-identifier</code> 设为 <code>t</code> ）。
</p>

<p>
在为 <code>M-.</code> 输入标识符参数时，可使用迷你缓冲区的常规补全命令（参见《<a href="#Completion">补全</a>》章节），补全候选列表会显示所有已识别的标识符名称。
</p>

<p>
与多数可切换缓冲区的命令一致， <code>xref-find-definitions</code> 也提供了变体命令：一个在新窗口展示目标缓冲区，一个为目标缓冲区新建框架，分别对应 <code>C-x 4 .</code> (<code>xref-find-definitions-other-window</code>) 和 <code>C-x 5 .</code> (<code>xref-find-definitions-other-frame</code>)。
</p>

<p>
<code>xref-find-definitions-at-mouse</code> 命令的功能与 <code>xref-find-definitions</code> 一致，区别在于它会查找鼠标事件发生位置及附近的标识符名称。该命令通常绑定至鼠标事件，例如 <code>C-M-mouxe-1</code> 。
</p>

<p>
<code>C-M-.</code> (<code>xref-find-apropos</code>) 是适用于标记的类apropos命令（参见《<a href="#Apropos">Apropos 命令</a>》章节），会在已选中的标记表中，列出名称匹配指定正则表达式的所有标识符。该命令与 <code>M-.</code> 的核心区别是：它通过正则表达式匹配标识符，而非将符号名作为固定字符串进行匹配。默认情况下，命令会像 <code>M-.</code> 一样弹出 <code>*xref*</code> 缓冲区，若需展示额外输出，可自定义配置项 <code>tags-apropos-additional-actions</code> ，具体说明参见该配置项的文档。
</p>

<p>
若上述任一命令找到多个匹配的定义，默认会弹出 <code>*xref*</code> 缓冲区展示所有匹配候选，并选中该缓冲区所在的窗口（ <code>C-M-.</code> 只要找到至少一个匹配结果，就会弹出 <code>*xref*</code> 缓冲区）。缓冲区中会为每个候选结果显示文件名，以及该文件中匹配的标识符。在该缓冲区中，你可选择任意候选结果进行展示，同时还能使用多种扩展命令（详见《<a href="#Xref-Commands">xref缓冲区中的可用命令</a>》章节）。此外，若配置项 <code>xref-auto-jump-to-first-definition</code> 的值为 <code>move</code> ，Emacs 会自动将光标移至 <code>*xref*</code> 缓冲区中首个候选结果的位置，此时按下 <code>RET</code> 回车即可展示该候选的定义；若该配置项值为 <code>t</code> 或 <code>show</code> ，首个候选结果会自动在专属窗口中展示 —— <code>t</code> 会同时选中展示首个候选定义的窗口， <code>show</code> 则保持 <code>*xref*</code> 缓冲区的窗口为选中状态。该配置项默认值为 <code>nil</code> ，即仅在 <code>*xref*</code> 缓冲区展示候选结果，不会自动选中或展示任何候选的定义，直至你在缓冲区中手动选择。
</p>

<p>
若你切换离开展示多个候选结果的 <code>*xref*</code> 缓冲区窗口，可通过 <code>M-g M-n</code> (<code>next-error</code>) 和 <code>M-g M-p</code> (<code>previous-error</code>) 命令在候选结果间切换（参见《<a href="#Compilation-Mode">编译模式</a>》章节）。
</p>

<p>
如需返回此前展示标识符定义的位置，可使用 <code>M-,</code> (<code>xref-go-back</code>) ，该命令会跳回上一次调用 <code>M-.</code> 的位置。因此，你可通过 <code>M-.</code> 查找并查看某标识符的定义，再通过 <code>M-,</code> 返回操作前的位置。 <code>M-,</code> 支持回溯你在位置历史中向前跳转的所有步骤，直至首次调用 <code>M-.</code> 的初始位置，也可停留在历史中的任意中间位置。
</p>

<p>
若你此前通过 <code>M-,</code> 回溯了过多步骤，或希望重新查看某次回溯前的位置，可使用 <code>C-M-,</code> (<code>xref-go-forward</code>) 再次向前跳转。该命令与 <code>M-.</code> 的区别是：每一步跳转无需将光标移至待查找定义的标识符处。 <code>C-M-,</code> 支持回溯你在位置历史中向后跳转的所有步骤，直至最后一次调用 <code>M-,</code> 的位置，也可停留在历史中的任意中间位置。
</p>

<p>
部分主模式提供的 <code>xref</code> 支持功能，可能无法找到某些标识符。例如在 Emacs Lisp 模式中（参见《<a href="#Lisp-Eval">执行 Emacs Lisp 表达式</a>》章节）， <code>M-.</code> 默认仅能查找已加载至当前 Emacs 会话，或支持自动加载的 Lisp 包中的函数和变量（参见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Autoload.html#Autoload">自动加载</a>》章节）。若 <code>M-.</code> 无法找到目标标识符，可尝试强制 <code>xref</code> 使用 <code>etags</code> 后端（参见《<a href="#Xref">查找标识符引用</a>》章节）：通过 <code>M-x xref-etags-mode</code> 开启 Xref Etags 次要模式，再重新调用 <code>M-.</code> 即可（需提前在源码文件的目录树中运行 etags 命令创建标记表，详见《<a href="#Create-Tags-Table">创建标记表</a>》章节）。
</p>
</div>
</div>
<div id="outline-container-Xref-Commands" class="outline-5">
<h5 id="Xref-Commands"><span class="section-number-5">30.4.1.2.</span> xref 缓冲区中的可用命令</h5>
<div class="outline-text-5" id="text-Xref-Commands">
<p>
专用的 XREF 模式为 <code>*xref*</code> 缓冲区提供了以下命令：
</p>
<dl class="org-dl">
<dt><code>RET</code></dt><dd></dd>

<dt><code>mouse-1</code></dt><dd>跳转到当前行对应的引用位置 (<code>xref-goto-xref</code>) 。带前缀参数执行时，会同时隐藏 <code>*xref*</code> 缓冲区。</dd>
<dt><code>mouse-2</code></dt><dd>功能与 <code>mouse-1</code> 一致，且会将展示 <code>*xref*</code> 缓冲区的窗口设为当前选中窗口 (<code>xref-select-and-show-xref</code>) 。</dd>
<dt><code>n</code></dt><dd></dd>

<dt><code>.</code></dt><dd>跳转到下一个引用位置，并在另一个窗口中展示 (<code>xref-next-line</code>) 。</dd>
<dt><code>N</code></dt><dd>跳转到下一个引用组的首个引用位置，并在另一个窗口中展示 (<code>xref-next-group</code>) 。</dd>
<dt><code>p</code></dt><dd></dd>

<dt><code>,</code></dt><dd>跳转到上一个引用位置，并在另一个窗口中展示 (<code>xref-prev-line</code>) 。</dd>
<dt><code>P</code></dt><dd>跳转到上一个引用组的首个引用位置，并在另一个窗口中展示 (<code>xref-prev-group</code>) 。</dd>
<dt><code>C-o</code></dt><dd>在另一个窗口中展示当前行对应的引用位置 (<code>xref-show-location-at-point</code>) 。</dd>
<dt><code>r pattern RET replacement RET</code></dt><dd>对匹配指定模式的引用执行交互式查询替换 (<code>xref-query-replace-in-results</code>) ，将匹配内容替换为指定的替换内容。该命令仅可在展示了所有相关文件中某一标识符所有匹配结果的 <code>*xref*</code> 缓冲区中使用。详见《<a href="#Identifier-Search">通过标识符进行查找与替换</a>》章节。</dd>
<dt><code>g</code></dt><dd>刷新 <code>*xref*</code> 缓冲区的内容 (<code>revert-buffer</code>) 。详见《<a href="#Reverting">恢复缓冲区</a>》章节。</dd>
<dt><code>M-,</code></dt><dd>关闭展示 <code>*xref*</code> 缓冲区的窗口，随后跳转到 Xref 栈的上一个位置 (<code>xref-quit-and-pop-marker-stack</code>) 。</dd>
<dt><code>q</code></dt><dd>关闭展示 <code>*xref*</code> 缓冲区的窗口 (<code>xref-quit</code>) 。</dd>
</dl>

<p>
此外，方向键、 <code>C-n</code> 、 <code>C-p</code> 等常规导航命令也可在该缓冲区中使用，仅用于移动光标位置，不会跳转展示对应的引用。
</p>
</div>
</div>
<div id="outline-container-Identifier-Search" class="outline-5">
<h5 id="Identifier-Search"><span class="section-number-5">30.4.1.3.</span> 基于标识符的搜索与替换</h5>
<div class="outline-text-5" id="text-Identifier-Search">
<p>
本节介绍的命令可对标识符本身，或引用了标识符的文件执行各类查找与替换操作。
</p>

<dl class="org-dl">
<dt><code>M-?</code></dt><dd>查找光标所在位置标识符的所有引用。</dd>
<dt><code>r</code></dt><dd></dd>

<dt><code>M-x xref-query-replace-in-results RET replacement RET</code></dt><dd></dd>

<dt><code>C-u M-x xref-query-replace-in-results RET regexp RET replacement RET</code></dt><dd>在 <code>*xref*</code> 缓冲区显示的所有标识符名称中，以交互方式将匹配 <i>regexp正则表达式</i> 的内容替换为指定替换内容。</dd>
<dt><code>M-x xref-find-references-and-replace RET from RET to RET</code></dt><dd>以交互方式将标识符原标识符的所有引用重命名为新名称新标识符。</dd>
<dt><code>M-x tags-search RET regexp RET</code></dt><dd>在已选中的标记表对应的所有文件中查找指定正则表达式。</dd>
<dt><code>M-x tags-query-replace RET regexp RET replacement RET</code></dt><dd>在已选中的标记表对应的每个文件中执行正则表达式查询替换。</dd>
<dt><code>M-x fileloop-continue</code></dt><dd>从当前光标位置重新执行上述最后两条命令中的任意一条。</dd>
</dl>

<p>
<code>M-?</code> 会查找光标所在位置标识符的所有引用，必要时会提示输入标识符并提供补全功能。根据当前使用的后端（参见《<a href="#Xref">查找标识符引用</a>》章节），即便光标处能识别出有效标识符，该命令也可能弹出输入提示；带前缀参数执行时，始终会提示输入标识符。（若希望该命令始终弹出提示，可将变量 <code>xref-prompt-for-identifier</code> 自定义为 <code>t</code> ；若设为 <code>nil</code> ，则仅在光标处无可用标识符时才弹出提示。）执行后会在 <code>*xref*</code> 缓冲区展示该标识符的所有引用，包含引用所在的文件名和行号，该缓冲区可使用 XREF 模式的所有命令（参见《<a href="#Xref-Commands">xref缓冲区中的可用命令</a>》章节）。
</p>

<p>
若变量 <code>xref-auto-jump-to-first-xref</code> 的值为 <code>t</code> ， <code>xref-find-references</code> 会自动跳转到 <code>*xref*</code> 缓冲区中的首个结果，并选中展示该引用的窗口；可通过 <code>M-g M-n</code> (<code>next-error</code>) 和 <code>M-g M-p</code> (<code>previous-error</code>) 选择其他结果（参见《<a href="#Compilation-Mode">编译模式</a>》章节）。若值为 <code>show</code> ，首个结果会被展示，但仍保持 <code>*xref*</code> 缓冲区的窗口为选中状态。若值为 <code>move</code> ，首个结果会在 <code>*xref*</code> 缓冲区中被选中，但不会展示；此时按下回车即可实际跳转到该引用位置。该变量默认值为 <code>nil</code> ，即仅在 <code>*xref*</code> 缓冲区展示结果，不会选中任何结果，也不会跳转到引用本身，直至手动在缓冲区中选择结果。
</p>

<p>
<code>r</code> (<code>xref-query-replace-in-results</code>) 与常规的 <code>M-x query-replace-regexp</code> 类似，会先读取替换内容，随后将 <code>*xref*</code> 缓冲区中显示的标识符，在其所有被引用的文件和位置中统一重命名为该替换内容，该功能在重构时代理标识符重命名非常实用。此命令需在 <code>M-?</code> 生成的 <code>*xref*</code> 缓冲区中调用，默认会将每个标识符的完整名称替换为指定内容；若带前缀参数执行，会先提示输入匹配标识符名称的正则表达式，仅将标识符名称中匹配该正则的部分替换为指定内容。
</p>

<p>
<code>M-x xref-find-references-and-replace</code> 与 <code>xref-query-replace-in-results</code> 功能类似，在需要将指定名称原标识符的单个标识符重命名时，使用该命令会更便捷。
</p>

<p>
<code>M-x tags-search</code> 会通过迷你缓冲区读取正则表达式，随后在已选中的标记表对应的所有文件中逐个查找匹配内容，过程中会显示当前正在搜索的文件名，方便查看进度，找到首个匹配项后即停止执行。该命令需要存在可用的标记表（参见《<a href="#Tags-Tables">标记表</a>》章节）。
</p>

<p>
使用 <code>tags-search</code> 找到首个匹配项后，通常需要继续查找其余匹配项，可通过 <code>M-x fileloop-continue</code> 恢复执行 <code>tags-search</code> ，查找下一个匹配项，该命令会先搜索当前缓冲区的剩余内容，再继续搜索标记表中的其他文件。
</p>

<p>
<code>M-x tags-query-replace</code> 会在标记表对应的所有文件中执行一次正则表达式查询替换，与常规的 <code>M-x query-replace-regexp</code> 类似，会先读取待搜索的正则表达式和替换内容，查找逻辑与 <code>M-x tags-search</code> 基本一致，但会反复执行并根据用户的操作处理匹配项，关于查询替换的更多信息，参见《<a href="#Query-Replace">查询替换</a>》章节。
</p>

<p>
可通过自定义变量 <code>tags-case-fold-search</code> 的值，控制标记表查找命令的大小写敏感性，默认与 <code>case-fold-search</code> 的设置保持一致（参见《<a href="#Lax-Search">查找时的宽松匹配</a>》章节）。
</p>

<p>
单次调用 <code>M-x tags-query-replace</code> 即可遍历标记表中的所有文件，但实际使用中常需要临时退出，可通过任意无查询替换特殊含义的输入事件实现；后续可键入 <code>M-x fileloop-continue</code> 恢复执行查询替换，该命令会恢复最近一次执行的标记表查找或替换命令。例如，若要跳过当前文件的剩余内容，可键入 <code>M-&gt; M-x fileloop-continue</code> 。
</p>

<p>
请注意，本节介绍的命令比 <code>xref-find-definitions</code> 系列命令的查找范围更广： <code>xref-find-definitions</code> 系列仅查找匹配指定字符串或正则表达式的标识符定义，而 <code>xref-find-references</code> 、 <code>tags-search</code> 和 <code>tags-query-replace</code> 会像常规的查找和替换命令在当前缓冲区中执行的逻辑一样，查找标识符或正则表达式的 <b>所有出现位置</b> 。
</p>

<p>
除了 <code>xref-find-references</code> 和 <code>tags-search</code> ，也可将 <code>grep</code> 作为子进程运行，让 Emacs 逐个展示匹配的行，参见《<a href="#Grep-Searching">在 Emacs 中使用 Grep 查找</a>》章节。
</p>
</div>
</div>
<div id="outline-container-List-Identifiers" class="outline-5">
<h5 id="List-Identifiers"><span class="section-number-5">30.4.1.4.</span> 标识符查询</h5>
<div class="outline-text-5" id="text-List-Identifiers">
<dl class="org-dl">
<dt><code>C-M-i</code></dt><dd></dd>

<dt><code>M-TAB</code></dt><dd>对光标附近的文本执行补全，若已加载标记表则可调用其完成补全 (<code>completion-at-point</code>) 。</dd>
<dt><code>M-x list-tags RET file RET</code></dt><dd>展示程序文件文件名中定义的所有标识符列表。</dd>
<dt><code>C-M-. regexp RET</code></dt><dd>展示所有匹配该正则表达式的标识符列表 (<code>xref-find-apropos</code>) ，详见《<a href="#Looking-Up-Identifiers">标识符查找</a>》章节。</dd>
<dt><code>M-x tags-next-file</code></dt><dd>访问已选中标记表中记录的文件。</dd>
</dl>

<p>
在大多数编程语言模式下，键入 <code>C-M-i</code> 或 <code>M-TAB</code> (<code>completion-at-point</code>) 可对光标处的符号执行补全。部分模式会为该命令提供适配自身的专属补全逻辑；对于未提供专属补全的模式，若当前已加载标记表，该命令会调用标记表生成补全候选项，详见《<a href="#Symbol-Completion">符号名称的补全</a>》章节。
</p>

<p>
<code>M-x list-tags</code> 会通过补全功能读取已选中标记表所覆盖的某个文件名称，随后展示该文件中定义的所有标记；命令会将当前缓冲区对应的文件名，作为待列出标记的默认文件。注意：请勿在文件名中包含目录路径，除非标记表中记录的该文件名本身带有目录。该命令仅适用于 etags 后端，且要求项目存在可用的标记表，详见《<a href="#Tags-Tables">标记表</a>》章节。
</p>

<p>
<code>M-x tags-next-file</code> 用于访问已选中标记表中覆盖的文件。首次调用时，会打开标记表中的第一个文件；后续每次调用会依次打开下一个文件，若带前缀参数执行，则会返回并打开第一个文件。该命令要求当前已选中某一标记表。
</p>
</div>
</div>
</div>
<div id="outline-container-Tags-Tables" class="outline-4">
<h4 id="Tags-Tables"><span class="section-number-4">30.4.2.</span> 标签表</h4>
<div class="outline-text-4" id="text-Tags-Tables">
<p>
<i>tags table标记表</i> 会记录对某一程序或文档的源码进行扫描后提取出的标记<sup><a id="fnr.18" class="footref" href="#fn.18" role="doc-backlink">18</a></sup>。从生成文件中提取的标记，指向的是原始文件，而非标记提取过程中被扫描的生成文件。生成文件包括从 Cweb 源文件、Yacc 解析器定义、Lex 扫描器定义生成的 C 文件，经过预处理的 <code>C.i</code> 文件，以及对 <code>.fpp</code> 源文件预处理后生成的 Fortran 文件。
</p>

<p>
生成标记表时，需在文档或源码文件上执行 shell 命令 <code>etags</code> 。etags程序会将标记写入标记表文件（简称 <i>tags file标记文件</i> ），标记文件的惯用名称为 <code>TAGS</code> ，详见《<a href="#Create-Tags-Table">创建标记表</a>》章节。（也可通过其他软件包的相关命令创建标记表，只需保证生成的文件格式一致即可。）
</p>

<p>
Emacs 通过 etags 软件包将标记表用作 <code>xref</code> 的受支持后端之一。由于标记表由 Emacs 发行版自带的 <code>etags</code> 命令生成，本节将对其进行详细介绍。
</p>

<p>
Ebrowse 工具与 etags 功能类似，专为 C++ 语言定制，详见《Ebrowse 用户手册》中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/ebrowse/index.html#Top">Ebrowse</a> 章节。Semantic 软件包则提供了另一套独立于 etags 的标记生成与使用方案，详见 <a href="#Semantic">Semantic</a> 相关章节。
</p>

<ul class="org-ul">
<li><a href="#Tag-Syntax">源文件标签语法</a></li>
<li><a href="#Create-Tags-Table">创建标签表</a></li>
<li><a href="#Etags-Regexps">Etags 正则表达式</a></li>
</ul>
</div>
<div id="outline-container-Tag-Syntax" class="outline-5">
<h5 id="Tag-Syntax"><span class="section-number-5">30.4.2.1.</span> 源文件标签语法</h5>
<div class="outline-text-5" id="text-Tag-Syntax">
<p>
以下为最常用编程语言的标记语法定义规则：
</p>
<ul class="org-ul">
<li><p>
在 C 语言代码中，所有 C 函数、类型定义（typedef），以及结构体（struct）、共用体（union）、枚举（enum）的定义均为标记。宏定义#define、宏取消#undef和枚举常量也会被视作标记，除非生成标记表时指定 '<code>--no-defines</code>' 参数；全局变量同理，除非指定 '<code>--no-globals</code>' ，结构体成员亦是如此，除非指定 '<code>--no-members</code>' 。使用 '<code>--no-globals</code>'、'<code>--no-defines</code>'和'<code>--no-members</code>'参数可大幅减小标记表文件的体积。
</p>

<p>
为 etags 命令添加'<code>--declarations</code>'参数，除函数定义外，函数声明和外部变量也会被标记。
</p></li>

<li>在 C++ 语言代码中，除支持所有 C 语言的标记结构外，成员函数也会被识别；成员变量同样会被识别，除非使用 '<code>--no-members</code>' 参数。运算符定义的标记名格式为 '<code>operator+</code>' 这类形式。若指定 '<code>--class-qualify</code>' 参数，类中的变量和函数标记名将以 '<code>class::variable</code>'、'<code>class::function</code>'的格式命名。默认情况下，类的方法和成员不会添加类限定符，此举能更精准地在源码中匹配其名称。</li>

<li>在 Java 语言代码中，标记包含所有 C++ 支持的结构，同时新增接口（interface）、继承（extends）和实现（implements）相关结构。类中的变量和函数标记名格式为 '<code>class.variable</code>'、'<code>class.function</code>'。</li>

<li><p>
在 LaTeX 文档中， <code>\chapter</code> 、 <code>\section</code> 、 <code>\subsection</code> 、 <code>\subsubsection</code> 、 <code>\eqno</code> 、 <code>\label</code> 、 <code>\ref</code> 、 <code>\cite</code> 、 <code>\bibitem</code> 、 <code>\part</code> 、 <code>\appendix</code> 、 <code>\entry</code> 、 <code>\index</code> 、 <code>\def</code> 、 <code>\newcommand</code> 、 <code>\renewcommand</code> 、 <code>\newenvironment</code> 、 <code>\renewenvironment</code> 这些命令的参数均为标记。
</p>

<p>
若在调用 <code>etags</code> 前，于环境变量 <code>TEXTAGS</code> 中指定其他命令，这些命令的参数也可成为标记。该环境变量的值为以冒号分隔的命令名列表，示例如下：
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #a0522d;">TEXTAGS</span>=<span style="color: #8b2252;">"mycommand:myothercommand"</span>
<span style="color: #483d8b;">export</span> TEXTAGS
</pre>
</div>

<p>
以上代码（使用 Bourne Shell 语法）指定 '<code>\mycommand</code>' 和 '<code>\myothercommand</code>' 命令的参数也会被定义为标记。
</p></li>

<li>在 Lisp 语言代码中，所有通过 <code>defun</code> 定义的函数、 <code>defvar</code> 或 <code>defconst</code> 定义的变量，以及所有行首以( <code>def</code> 开头的表达式的第一个参数，均为标记。例外情况为： <code>(defvar foo)</code> 形式的表达式会被视作声明，仅当指定 '<code>--declarations</code>' 参数时才会被标记。</li>

<li>在 Scheme 语言代码中，标记包括所有通过 <code>def</code> 定义的内容、名称以 'def' 开头的结构定义的内容，同时还包括文件顶层通过 <code>set!</code> 赋值的变量。</li>
</ul>

<p>
etags 同时支持多种其他编程语言，各语言标记规则如下：
</p>

<ul class="org-ul">
<li><p>
Ada 语言：函数、过程、包、任务和类型为标记；指定 '<code>--packages-only</code>' 参数，可仅为包创建标记。
</p>

<p>
Ada 中同一名称可用于不同类型的实体（如同时作为过程和函数名）；包、过程、函数等实体还分为规约（spec，即接口）和体（body，即实现）。为方便精准选择所需定义，Ada 的标记名会添加后缀标识实体类型：
</p>
<ul class="org-ul">
<li>/b：包体</li>
<li>/f：函数</li>
<li>/k：任务</li>
<li>/p：过程</li>
<li>/s：包规约</li>
<li>/t：类型</li>
</ul>

<p>
例如，执行 <code>M-x find-tag RET bidule/b RET</code> 会直接跳转到包 bidule 的包体，而执行 <code>M-x find-tag RET bidule RET</code> 会搜索所有名为 bidule 的标记。
</p></li>

<li>汇编语言：行首出现且后接冒号的标签为标记。</li>

<li>Bison/Yacc 输入文件：每条规则会将其定义的非终结符作为标记；文件中包含的 C 代码部分会按 C 语言规则解析标记。</li>
<li>Cobol 语言：段落名为标记，即第 8 列开始且后接句点的单词。</li>
<li>Erlang 语言：文件中定义的函数、记录和宏为标记。</li>
<li>Fortran 语言：函数、子程序和块数据为标记。</li>
<li>Go 语言：包、函数和类型为标记。</li>
<li>HTML 输入文件：标题（title）、一级至三级标题（h1、h2、h3）为标记；锚点中的name=属性、所有id=属性也为标记。</li>
<li>Lua 语言：所有函数为标记。</li>
<li>Makefile 文件：目标为标记；变量同样为标记，除非指定 '<code>--no-globals</code>' 参数。</li>
<li>Objective C 语言：类、类分类、方法和协议的定义为标记；类中的变量和函数标记名格式为 '<code>class::variable</code>'、'<code>class::function</code>'。</li>
<li>Pascal 语言：文件中定义的函数和过程为标记。</li>
<li>Perl 语言：通过package、sub、use constant、my、local关键字定义的包、子程序和变量为标记；若需为全局变量创建标记，可使用 '<code>--globals</code>' 参数。子程序标记名格式为 '<code>package::sub</code>' ，默认包中定义的子程序标记名格式为 '<code>main::sub</code>' 。</li>
<li>PHP 语言：函数、类和宏定义（defines）为标记；变量同样为标记，除非使用 '<code>--no-members</code>' 参数。</li>
<li>PostScript 语言：函数为标记。</li>
<li>Prolog 语言：行首的谓词和规则为标记。</li>
<li>Python 语言：行首的def或class定义会生成标记。</li>
<li>Ruby 语言：行首的def、class或module定义会生成标记；常量也会生成标记。</li>
<li>Rust 语言：所有通过fn、enum、struct或 <code>macro_rules!</code> 定义的内容为标记。</li>
</ul>

<p>
你也可基于正则表达式匹配生成标记（参见《<a href="#Etags-Regexps">Etags 正则表达式</a>》章节），以适配其他文件格式和编程语言。
</p>
</div>
</div>
<div id="outline-container-Create-Tags-Table" class="outline-5">
<h5 id="Create-Tags-Table"><span class="section-number-5">30.4.2.2.</span> 创建标签表</h5>
<div class="outline-text-5" id="text-Create-Tags-Table">
<p>
<code>etags</code> 程序用于创建标记表文件，它支持多种编程语言的语法解析，具体规则详见《<a href="#Tag-Syntax">源文件标记语法</a>》章节。etags 的运行方式如下：
</p>

<div class="org-src-container">
<pre class="src src-shell">etags inputfiles&#8230;
</pre>
</div>

<p>
<code>etags</code> 程序会读取指定的文件，并在当前工作目录下生成一个名为 TAGS 的标记表文件。你可通过 '<code>--output=file</code>' 选项自定义标记表的文件名；若将文件名指定为 '-'，则会将标记表内容输出至标准输出。也可使用 '<code>--append</code>' 选项，将新生成的标记表内容追加至已存在的文件中。
</p>

<p>
若指定的文件不存在，etags 会自动查找其压缩版本，解压缩后再进行读取。在 MS-DOS 系统中，若命令行指定了 <code>mycode.c</code> 但该文件不存在，etags 还会查找 <code>mycode.cgz</code> 这类命名的文件。
</p>

<p>
当标记表中记录的文件发生修改，导致标记表失效时，可重新运行 etags 程序更新。若标记表未记录某一标记，或标记关联到了错误的文件，在更新标记表前，Emacs 将无法找到该标记的定义；但如果仅因文件编辑导致标记表中记录的位置略有偏差，Emacs 仍能找到正确位置，只是会有轻微的延迟。
</p>

<p>
因此，无需在每次编辑文件后都更新标记表。仅当新增了需要纳入列表的标记、将标记定义从一个文件移至另一个文件，或文件发生大量修改时，才需要更新标记表。
</p>

<p>
通过向 etags 传递 '<code>--include=file</code>' 选项，可让一个标记表包含另一个标记表的内容，此时该标记表的覆盖范围将同时包含自身处理的文件和被包含标记表所覆盖的所有文件。
</p>

<p>
若运行 etags 时使用相对路径指定源文件，生成的标记表中将记录相对于标记表初始生成目录的文件路径。这种方式下，若将包含标记表和所有源文件的整个目录树移动，标记表仍能正确指向源文件。但如果标记表的输出目标为 '-' （标准输出）或位于 <code>/dev</code> 目录下，文件名将以当前工作目录为基准生成相对路径，这在将标记表内容写入标准输出时会非常实用。
</p>

<p>
使用相对路径时，标记表文件不应是指向其他目录中标记表的符号链接，否则会导致表中的文件路径全部失效。
</p>

<p>
若运行 etags 时使用绝对路径指定源文件，生成的标记表中将记录绝对文件路径。这种方式下，只要源文件的位置不变，即便移动标记表文件，它仍能正确指向对应的源文件。在 MS-DOS 和 MS-Windows 系统中，绝对路径以设备名 '<code>:/</code>' 开头，其他系统则以 '<code>/</code>' 开头。
</p>

<p>
当需要为大量文件生成标记表时，直接在命令行列出所有文件名可能会因系统命令行长度限制而失败。此时可在文件名的位置输入 '-' ，让 etags 从标准输入读取文件名，以此规避该限制，示例如下：
</p>

<div class="org-src-container">
<pre class="src src-shell">find . -name <span style="color: #8b2252;">"*.[chCH]"</span> -print | etags -
</pre>
</div>

<p>
etags 会根据输入文件的文件名和内容自动识别其使用的编程语言：首先通过文件名和扩展名匹配常用编程语言的命名规则；对于部分有专属解释器的语言（如 Perl 的 perl、Prolog 的 pl），etags 会接着检查文件首行是否有 '<code>#!解释器名</code>' 形式的解释器指定语句，并与已知的解释器进行匹配。
</p>

<p>
若上述自动识别方式失效，或你需要手动指定编程语言，可通过 '<code>--language=name</code>' 选项显式声明。该选项可与文件名交替使用，后续的所有文件都将使用该选项指定的语言解析。指定 '<code>--language=auto</code>' 可让 etags 恢复通过文件名和内容自动推测编程语言；指定 '<code>--language=none</code>' 则会完全关闭针对特定语言的解析逻辑，此时 etags 将仅通过正则表达式匹配识别标记（详见《<a href="#Etags-Regexps">Etags 正则表达式</a>》章节）。当处理的文件使用 etags 暂不支持的编程语言时，该选项非常实用，可避免 etags 默认以 Fortran 和 C 语言的规则解析文件。
</p>

<p>
'<code>--parse-stdin=file</code>' 选项主要用于从其他程序中调用 etags 的场景，该选项在命令行中只能使用一次，替代文件名的位置。使用该选项时，etags 会从标准输入读取内容，并将生成的所有标记关联至指定的文件。
</p>

<p>
对于 C 和 C++ 语言，若源文件未遵循 GNU 编码规范 —— 即仅让函数、结构体定义等顶层定义的大括号（ '{' 和 '}' ）出现在行首，建议使用 '<code>--ignore-indentation</code>' 选项，防止 etags 将行首的闭合大括号错误解析，导致标记识别异常。
</p>

<p>
执行 <code>etags --help</code> 会输出 etags 支持的所有编程语言列表、通过文件名推测语言的规则，以及所有可用选项的简短说明。若在该命令后追加一个或多个 <code>'--language=name</code>' 选项，还会输出该语言的标记生成详细规则。
</p>

<p>
除了手动调用 etags 创建和更新标记表，也可让 Emacs 自动完成该操作。启用全局次要模式 <code>etags-regen-mode</code> 后，Emacs 会根据需要自动生成标记表，并在编辑任何参与标记生成的源文件时，自动更新标记表。该模式会通过当前的项目配置（详见《<a href="#Projects">项目操作</a>》章节）确定需要传递给 etags 的文件，以重新生成项目的标记表。可通过以下用户配置项自定义该次要模式的行为：
</p>

<dl class="org-dl">
<dt><code>etags-regen-program</code></dt><dd>用于重新生成标记表的程序，默认值为 <code>etags</code> 。</dd>
<dt><code>etags-regen-program-options</code></dt><dd>传递给标记表重新生成程序的命令行选项。</dd>
<dt><code>etags-regen-ignores</code></dt><dd>重新生成标记表时需要忽略的文件匹配模式列表（通配符形式）。</dd>
</dl>

<p>
若通过 <code>M-x visit-tags-table</code> 手动选择了标记表（详见《<a href="#Select-Tags-Table">选择标记表</a>》章节）， <code>etags-regen-mode</code> 会自动失效，不再创建和更新标记表 —— 该行为默认你希望手动管理标记表。若要取消该效果，可执行 <code>tags-reset-tags-tables</code> 命令。
</p>
</div>
</div>
<div id="outline-container-Etags-Regexps" class="outline-5">
<h5 id="Etags-Regexps"><span class="section-number-5">30.4.2.3.</span> Etags 正则表达式</h5>
<div class="outline-text-5" id="text-Etags-Regexps">
<p>
etags 工具的 '<code>--regex</code>' 选项支持通过正则表达式匹配来识别标签。该选项可与文件名混合使用，每个 '<code>--regex</code>' 选项仅对其后的源文件生效。若指定多个 '<code>--regex</code>' 选项，所有选项会并行生效。其语法格式为：
</p>

<div class="org-src-container">
<pre class="src src-shell">--regex=[{language&#35821;&#35328;}]/tagregexp&#26631;&#31614;&#27491;&#21017;&#34920;&#36798;&#24335;/[baneregexo&#21517;&#31216;&#27491;&#21017;&#34920;&#36798;&#24335;/]modifiers&#20462;&#39280;&#31526;
</pre>
</div>

<p>
该选项值的核心部分是标签正则表达式（tagregexp），用于匹配标签。此正则表达式始终为锚定匹配，即仅在行首进行匹配。若需支持缩进的标签，需在正则表达式中匹配行首空白字符，可将表达式以 '<code>[ \t]*</code>' 开头。
</p>

<p>
在这类正则表达式中，反斜杠 '<code>\</code>' 用于转义后续字符，同时支持所有 C 语言字符转义序列：'<code>\a</code>' 代表响铃符、'<code>\b</code>' 代表退格符、'<code>\e</code>' 代表转义符、 '<code>\f</code>' 代表换页符、 '<code>\n</code>' 代表换行符、'<code>\r</code>' 代表回车符、 '<code>\t</code>' 代表制表符、 '<code>\v</code>' 代表垂直制表符，此外  '<code>\d</code>' 代表删除符（ <code>DEL</code> ）。除此之外，其正则表达式语法与 Emacs 基本一致，差异点在于：反斜杠转义规则与 GNU grep 相同（例如，不支持非捕获组的软分组），且不支持  '<code>[:ascii:]</code>' 、'<code>[:multibyte:]</code>' 、 '<code>[:nonascii:]</code>' 、 '<code>[:word:]</code>' 、 '<code>[:unibyte:]</code>'  这些字符类。
</p>

<p>
理想情况下，标签正则表达式应仅匹配识别标签所需的字符，避免多余匹配。若因语法限制，标签正则表达式需匹配标签之外的更多字符，则应添加名称正则表达式（nameregexp），精准提取标签本身。这能让 Emacs 更准确地查找标签，并更可靠地实现标签名补全。在名称正则表达式中，通常可便捷地使用 'back references反向引用' （参见《<a href="#Regexp-Backslash">正则表达式中的反斜杠</a>》），引用标签正则表达式中用 '<code>\( … \)</code>'  包裹的分组，例如 '<code>\1</code>' 代表第一个该类分组。下文会给出相关示例。
</p>

<p>
修饰符是由 0 个或多个字符组成的序列，用于修改 etags 的匹配方式。无修饰符的正则表达式会按行遍历输入文件，且为大小写敏感匹配。各修饰符及其含义如下：
</p>
<dl class="org-dl">
<dt>'i'</dt><dd>匹配时忽略大小写</dd>
<dt>'m'</dt><dd>对整个文件进行正则匹配，支持多行匹配</dd>
<dt>'s'</dt><dd>对整个文件进行正则匹配，且允许标签正则表达式中的 . 匹配换行符</dd>
</dl>

<p>
'<code>-R</code>' 选项会取消此前所有 '<code>--regex</code>' 选项定义的正则表达式，该选项同样对其后的文件名生效，示例如下：
</p>

<div class="org-src-container">
<pre class="src src-shell">etags --regex=/reg1/i voo.doo --regex=/reg2/m <span style="color: #8b2252;">\</span>
    bar.ber -R --lang=lisp los.er
</pre>
</div>

<p>
上述命令中，etags 会根据文件内容为 <code>voo.doo</code> 和 <code>bar.ber</code> 自动选择解析语言；同时会用正则 <i>reg1</i> 为 <code>voo.doo</code> 识别额外标签，用 <i>reg1</i> 和 <i>reg2</i> 为 <code>bar.ber</code> 识别额外标签。对 <code>voo.doo</code> 和 <code>bar.ber</code> ， <i>reg1</i> 会按行进行大小写不敏感匹配；对 <code>bar.ber</code> ， <i>reg2</i> 会对整个文件进行匹配，支持多行且大小写敏感。对 <code>los.er</code> ，etags 仅使用 Lisp 语言的默认标签规则，不启用任何用户自定义的正则匹配。
</p>

<p>
可通过可选前缀 {语言}，限制 '<code>--regex</code>' 选项仅对指定语言的文件生效（执行 <code>etags --help</code> 可查看 etags 支持的语言列表）。当在文件中存储大量 etags 预定义正则表达式时，该用法尤为实用。以下示例为 Emacs 的 C 语言源文件，仅为其中的 DEFVAR 宏生成标签：
</p>

<div class="org-src-container">
<pre class="src src-shell">--regex=<span style="color: #8b2252;">'{c}/[ \t]*DEFVAR_[A-Z_ \t(]+"\([^"]+\)"/\1/'</span>
</pre>
</div>

<p>
若正则表达式逻辑复杂，可将其列表存储在文件中。通过以下选项语法，可让 etags 读取两个正则表达式文件，且第二个文件中的正则表达式会以大小写不敏感方式匹配：
</p>

<div class="org-src-container">
<pre class="src src-shell">--regex=@&#21306;&#20998;&#22823;&#23567;&#20889;&#25991;&#20214; --ignore-case-regex=@&#24573;&#30053;&#22823;&#23567;&#20889;&#25991;&#20214;
</pre>
</div>

<p>
etags 的正则表达式文件遵循以下规则：每行一个正则表达式；空行、以空格或制表符开头的行会被忽略；若行首字符为 '<code>@</code>' ，etags 会将该行剩余部分视为另一个正则表达式文件的名称，即支持文件的嵌套引用；其余所有行均为有效正则表达式；若行首首个非空白字符为 '<code>--</code>' ，则该行视为注释。
</p>

<p>
例如，创建名为 emacs.tags 的文件，内容如下：
</p>

<div class="org-src-container">
<pre class="src src-shell">        -- &#27492;&#37197;&#32622;&#36866;&#29992;&#20110;GNU Emacs&#30340;C&#35821;&#35328;&#28304;&#25991;&#20214;
{c}/[ \t]*DEFVAR_[A-Z_ \t(]+<span style="color: #8b2252;">"\([^"</span>]+<span style="color: #8b2252;">\)"/\1/</span>
</pre>
</div>

<p>
可通过以下命令使用该文件：
</p>

<div class="org-src-container">
<pre class="src src-shell">etags --regex=@emacs.tags *.[ch] */*.[ch]
</pre>
</div>

<p>
再给出更多实用示例（正则表达式需加引号，避免被 Shell 解析）：
</p>
<ul class="org-ul">
<li><p>
为 Octave 文件生成标签
</p>

<div class="org-src-container">
<pre class="src src-shell">etags --language=none <span style="color: #8b2252;">\</span>
      --regex=<span style="color: #8b2252;">'/[ \t]*function.*=[ \t]*\([^ \t]*\)[ \t]*(/\1/'</span> <span style="color: #8b2252;">\</span>
      --regex=<span style="color: #8b2252;">'/###key \(.*\)/\1/'</span> <span style="color: #8b2252;">\</span>
      --regex=<span style="color: #8b2252;">'/[ \t]*global[ \t].*/'</span> <span style="color: #8b2252;">\</span>
      *.m
</pre>
</div>

<p>
注意：etags 不会为脚本自动生成标签，若需跳转到脚本，需手动在脚本中添加 ###key 脚本名 格式的行。
</p></li>

<li><p>
为 Tcl 文件生成标签
</p>

<div class="org-src-container">
<pre class="src src-shell">etags --language=none --regex=<span style="color: #8b2252;">'/proc[ \t]+\([^ \t]+\)/\1/'</span> *.tcl
</pre>
</div></li>

<li><p>
为 VHDL 文件生成标签
</p>

<div class="org-src-container">
<pre class="src src-shell">etags --language=none <span style="color: #8b2252;">\</span>
  --regex=<span style="color: #8b2252;">'/[ \t]*\(ARCHITECTURE\|CONFIGURATION\) +[^ ]* +OF/'</span> <span style="color: #8b2252;">\</span>
  --regex=<span style="color: #8b2252;">'/[ \t]*\(ATTRIBUTE\|ENTITY\|FUNCTION\|PACKAGE\
  \( BODY\)?\|PROCEDURE\|PROCESS\|TYPE\)[ \t]+\([^ \t(]+\)/\3/'</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-Select-Tags-Table" class="outline-4">
<h4 id="Select-Tags-Table"><span class="section-number-4">30.4.3.</span> 选择标签表</h4>
<div class="outline-text-4" id="text-Select-Tags-Table">
<p>
Emacs 在任一时刻最多仅有一个 <b><i>selected tags table已选标签表</i></b> ，所有操作标签表的命令都会优先使用该标签表。要选择标签表，可执行命令 <code>M-x visit-tags-table</code> ，该命令会以参数形式读取标签表文件名，默认值为 <code>TAGS</code> ；程序会从默认目录向上递归搜索，将首个包含 TAGS 文件的目录作为该命令的默认目录。
</p>

<p>
Emacs 并不会在执行选择操作时立即读取标签表内容， <code>visit-tags-table</code> 命令的核心作用仅为将文件名存入变量 <code>tags-file-name</code> ，无其他额外操作。该变量的初始值为 <code>nil</code> ，此值会触发所有标签表操作命令，使其向用户请求待使用的标签表文件名。
</p>

<p>
除已选标签表外，Emacs 还会维护一个 <b>标签表列表</b> ，用于管理你需要协同使用的多个标签表。例如，当你开发的程序依赖某一函数库时，可同时加载程序自身和该函数库的标签表，让 Emacs 能快速检索到两者中的所有标识符。若已选标签表中无目标标识符，或未包含标签命令所需的源文件，该命令会自动尝试使用标签表列表中的其他所有标签表。
</p>

<p>
当已有标签表处于加载状态时，再次执行 <code>visit-tags-table</code> 加载新标签表，Emacs 会提供两种选择：将新标签表 <b>添加至当前标签表列表</b> ，或 <b>清空当前列表并新建列表</b> （仅保留新标签表）。若选择添加，新标签表会与原有标签表协同生效；若选择新建，新标签表将替代所有原有标签表。
</p>

<p>
你也可通过设置变量 <code>tags-table-list</code> 为 <b>目录名列表</b> ，来指定精准的标签表集合，示例如下：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq</span> tags-table-list
      '(<span style="color: #8b2252;">"~/.emacs.d"</span> <span style="color: #8b2252;">"/usr/local/lib/emacs/src"</span>))
</pre>
</div>

<p>
上述配置会让标签命令检索 <code>~/.emacs.d</code> 目录和 <code>/usr/local/lib/emacs/src</code> 目录下的 <code>TAGS</code> 文件。检索的优先级由当前编辑的文件所属目录、以及哪个标签表包含该文件共同决定。
</p>

<p>
注意：请勿同时设置 <code>tags-file-name</code> 和 <code>tags-table-list</code> 两个变量。
</p>
</div>
</div>
</div>
<div id="outline-container-EDE" class="outline-3">
<h3 id="EDE"><span class="section-number-3">30.5.</span> Emacs 开发环境</h3>
<div class="outline-text-3" id="text-EDE">
<p>
EDE（Emacs Development Environment）是一款扩展包，可简化在 Emacs 中创建、构建和调试大型程序的操作，为 Emacs 提供了集成开发环境（IDE）的部分核心功能。
</p>

<p>
本节仅对 EDE 的使用方法作简要说明，完整详情请参阅《Emacs 开发环境》中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/ede/index.html#Top">EDE</a> 相关章节。
</p>

<p>
EDE 以 <b>全局次要模式</b> 实现（参见 “<a href="#Minor-Modes">次要模式</a>” 相关内容）。启用该模式可执行命令 <code>M-x global-ede-mode</code> ，或点击菜单栏中 <b>工具</b> 选项下的「项目支持（EDE）」项；也可在 Emacs 初始化文件中添加以下代码，实现启动时自动启用 EDE：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(global-ede-mode t)
</pre>
</div>

<p>
激活 EDE 后，菜单栏会新增 <b>Development开发</b> 选项，本节介绍的各类 EDE 命令及其他多数 EDE 命令，均可通过该菜单调用。
</p>

<p>
EDE 将文件按 <b><i>projects项目</i></b> 组织，每个项目对应一个目录树， <b><i>project root项目根目录</i></b> 为该目录树的最顶层目录。定义新项目的操作步骤：打开目标项目根目录下的任意文件，执行命令 <code>M-x ede-new</code> ，该命令会提示选择 <b><i>project type项目类型</i></b> —— 项目类型决定了 EDE 管理该项目的底层方式（参见《Emacs 开发环境》中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/ede/Creating-a-project.html#Creating-a-project">EDE</a> 相关章节）。最常用的项目类型为「Make」（基于 Makefile 管理）和「Automake」（基于 GNU Automake 管理，参见《<a href="https://www.gnu.org/software/automake/manual/html_node/index.html#Top">Automake</a>》相关内容）。无论选择哪种类型，EDE 都会在项目根目录生成名为 <code>Project.ede</code> 的文件，用于存储该项目的相关配置信息。
</p>

<p>
一个项目可包含 <b>一个或多个 <i>targets目标</i></b> ，目标可以是目标文件、可执行程序，或由项目中一个 / 多个文件构建生成的其他类型文件。
</p>

<p>
向项目中添加新目标：执行快捷键 <code>C-c . t</code> (<code>M-x ede-new-target</code>) ，该命令会同时询问是否将 <b>当前文件</b> 添加至该目标（即该目标会基于此文件构建）。目标创建完成后，可通过快捷键 <code>C-c . a</code> (<code>ede-add-file</code>) 为其添加更多文件。
</p>

<p>
构建单个目标：执行快捷键 <code>C-c . c</code> (<code>ede-compile-target</code>) ；构建项目中所有目标：执行快捷键 <code>C-c . C</code> (<code>ede-compile-project</code>) 。EDE 会根据 <b>文件类型</b> 自动推断目标的构建方式。
</p>
</div>
</div>
<div id="outline-container-Emerge" class="outline-3">
<h3 id="Emerge"><span class="section-number-3">30.6.</span> 使用 Emerge 合并文件</h3>
<div class="outline-text-3" id="text-Emerge">
<p>
程序员在协作中出现思路偏差，对同一程序做出不同方向的修改，这种情况十分常见。要解决这一问题，就需要对两个版本的程序进行合并，而 Emerge 工具能让这项工作变得更简便。关于文件对比的其他方法，可参阅<a href="#Comparing-Files">文件对比</a>章节，以及《Ediff 使用手册》中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/ediff/index.html#Top">Ediff</a> 相关内容。
</p>

<ul class="org-ul">
<li><a href="#Overview-of-Emerge">Emerge 概述</a></li>
<li><a href="#Submodes-of-Emerge">Emerge 的子模式</a></li>
<li><a href="#State-of-Difference">差异状态</a></li>
<li><a href="#Merge-Commands">合并命令</a></li>
<li><a href="#Exiting-Emerge">退出 Emerge</a></li>
<li><a href="#Combining-in-Emerge">合并两个版本的内容</a></li>
<li><a href="#Fine-Points-of-Emerge">Emerge 的细节要点</a></li>
</ul>
</div>
<div id="outline-container-Overview-of-Emerge" class="outline-4">
<h4 id="Overview-of-Emerge"><span class="section-number-4">30.6.1.</span> Emerge 概述</h4>
<div class="outline-text-4" id="text-Overview-of-Emerge">
<p>
启动 Emerge 可执行以下四条命令之一：
</p>
<dl class="org-dl">
<dt><code>M-x emerge-files</code></dt><dd>合并两个指定的文件。</dd>
<dt><code>M-x emerge-files-with-ancestor</code></dt><dd>参照共同的原始版本，合并两个指定的文件。</dd>
<dt><code>M-x emerge-buffers</code></dt><dd>合并两个缓冲区。</dd>
<dt><code>M-x emerge-buffers-with-ancestor</code></dt><dd>以第三个缓冲区作为两个待合并缓冲区的共同原始版本，完成合并操作。</dd>
</dl>

<p>
Emerge 相关命令会对比两个文件或缓冲区，并在三个缓冲区中展示对比结果：两个缓冲区分别对应两份待合并的源文本（/A 缓冲区/ 和 <i>B 缓冲区</i> ），第三个为合并缓冲区，所有合并操作均在此完成。合并缓冲区中会显示完整的合并后文本，而非仅展示差异内容。在两份源文本存在差异的任意位置，你可选择将其中一份的内容纳入合并缓冲区。
</p>

<p>
若待合并的源文本来自已做 <b>区域窄化</b> 的缓冲区，那么从现有缓冲区读取内容的 Emerge 命令，仅会使用这些缓冲区中可访问的文本区域（参见「<a href="#Narrowing">区域窄化</a>」相关内容）。
</p>

<p>
若两份待合并文本均衍生自同一个 <b>共同原始版本</b> ，Emerge 可借助该版本自动判断哪一方的修改更合理。当其中一个当前版本与原始版本内容一致时，Emerge 会认定另一个当前版本的内容为主动修改，并将其保留至合并后的文本中。如需指定共同原始文本，可使用上述带 'with-ancestor' 后缀的命令，这类命令会依次读取三个文件或缓冲区名称 ——A 变体、B 变体以及共同原始版本。
</p>

<p>
完成文本对比并准备好相关缓冲区后，即可开始交互式合并。你可在合并缓冲区中输入专属的合并命令，操控整个合并过程（参见「<a href="#Merge-Commands">合并命令</a>」相关内容）。对于源文本中每一处连续的差异区域，你可选择保留其中一方的内容，也可对双方内容进行协同编辑。
</p>

<p>
合并缓冲区采用专属的主模式 ——Emerge 模式，该模式内置了用于选择差异内容的各类命令，同时你也可使用常规的 Emacs 命令编辑该缓冲区。
</p>

<p>
在任意时刻，Emerge 都会将焦点聚焦于某一处特定的差异，该差异被称为 <b><i>selected difference选中的差异</i></b> 。这一处差异会在三个缓冲区中以如下标记标注出来：
</p>

<div class="org-src-container">
<pre class="src src-shell">vvvvvvvvvvvvvvvvvvvv
text that differs
^^^^^^^^^^^^^^^^^^^^
</pre>
</div>

<p>
Emerge 会为所有差异按顺序编号，且模式行中会始终显示当前选中差异的编号。
</p>

<p>
默认情况下，合并缓冲区初始会载入源文本的 A 版本内容；但如果某一处差异的 A 版本与共同原始版本内容一致，那么该差异位置会优先载入 B 版本内容作为初始值。
</p>

<p>
退出 Emerge 时，合并后的文本会保留在合并缓冲区中，此时你可使用 <code>C-x C-w</code> 将其保存至文件。若为 <code>emerge-files</code> 或 <code>emerge-files-with-ancestor</code> 命令传入数字参数，命令会通过迷你缓冲区读取输出文件的名称（该名称为这类命令最后读取的文件名），退出 Emerge 时，合并后的文本会自动保存至该输出文件。
</p>

<p>
默认情况下，退出 Emerge 时，相关命令会将输出缓冲区的内容保存至对应文件；若使用 <code>C-]</code> 中止 Emerge 操作，命令则不会自动保存输出缓冲区，但你可根据需要手动保存。
</p>
</div>
</div>
<div id="outline-container-Submodes-of-Emerge" class="outline-4">
<h4 id="Submodes-of-Emerge"><span class="section-number-4">30.6.2.</span> Emerge 的子模式</h4>
<div class="outline-text-4" id="text-Submodes-of-Emerge">
<p>
执行合并命令时可选择两种模式： <b>Fast mode快速模式</b> 和 <b>Edit mode编辑模式</b> 。快速模式下，基础合并命令仅需输入单个字符即可执行，但常规的 Emacs 命令会被禁用；若你仅需使用合并命令，该模式会更为便捷。编辑模式下，所有合并命令均需以前缀键 <code>C-c C-c</code> 开头，同时保留所有常规 Emacs 命令的使用权限；该模式支持对合并缓冲区进行编辑操作，但会降低 Emerge 的操作效率。
</p>

<p>
输入 <code>e</code> 可切换至编辑模式，输入 <code>C-c C-c f</code> 可切换至快速模式。模式行会分别以字符 'E' 和 'F' 标识编辑模式与快速模式。
</p>

<p>
Emerge 另有两个附加子模式，会影响特定合并命令的执行方式： <b>Auto Advance mode自动前进模式</b> 和 <b>Skipp Prefers mode跳过优选模式</b> 。
</p>

<p>
开启自动前进模式后，执行 <code>a</code> 和 <code>b</code> 命令选择差异内容的同时，会自动跳转到下一处差异。若你仅需从两份源文本中选择其一作为合并内容，该模式能让你更快完成整个合并流程。模式行会以字符A标识自动前进模式。
</p>

<p>
开启跳过优选模式后，执行 <code>n</code> 和 <code>p</code> 命令跳转差异时，会跳过处于「prefer-A」和「prefer-B」状态的差异（参见「<a href="#State-of-Difference">差异的状态</a>」），仅展示无默认正确版本的差异内容。模式行会以字符 'S' 标识跳过优选模式，该模式仅在指定了共同原始版本时生效。
</p>

<p>
输入命令 <code>s a</code> (<code>emerge-auto-advance</code>) 可开启或关闭自动前进模式，输入命令 <code>s s</code> (<code>emerge-skip-prefers</code>) 可开启或关闭跳过优选模式。为这两个命令传入正数值参数会开启对应模式，传入负数或 0 参数会关闭对应模式，无参数时则会切换模式的开启 / 关闭状态。
</p>
</div>
</div>
<div id="outline-container-State-of-Difference" class="outline-4">
<h4 id="State-of-Difference"><span class="section-number-4">30.6.3.</span> 差异状态</h4>
<div class="outline-text-4" id="text-State-of-Difference">
<p>
在合并缓冲区中，差异区域会以由 '<code>v</code>' 和 '<code>^</code>' 字符组成的行进行标记。每一处差异都会处于以下七种状态之一：
</p>

<dl class="org-dl">
<dt><code>A</code></dt><dd>差异区域显示 A 版本内容。执行 <code>a</code> 命令会将差异强制设为该状态，模式行会以字符 'A' 标识此状态。</dd>
<dt><code>B</code></dt><dd>差异区域显示 B 版本内容。执行 <code>b</code> 命令会将差异强制设为该状态，模式行会以字符 'B' 标识此状态。</dd>
<dt><code>default-A</code></dt><dd></dd>

<dt><code>default-B</code></dt><dd><p>
差异区域默认显示 A 或 B 版本内容，该状态表示你尚未对该差异做出选择。所有差异的初始状态均为 <code>default-A</code> （因此合并缓冲区初始为 A 缓冲区的副本）， <b>被标记为优选</b> 的差异除外（详见下文）。
</p>

<p>
当你选中某一处差异时，其状态会从 <code>default-A</code> 或 <code>default-B</code> 切换为普通的 A 或 B 状态。因此，被选中的差异绝不会处于 <code>default-A</code> 或 <code>default-B</code> 状态，且这两种状态也不会在模式行中显示。
</p>

<p>
执行命令 <code>d a</code> 可将 <code>default-A</code> 设为全局默认状态， <code>d b</code> 则可将 <code>default-B</code> 设为全局默认状态。该默认设置会作用于 <b>所有你从未选中、且无优选版本的差异。若你按顺序逐个处理合并中的差异</b> ，未选中的差异即为当前选中差异之后的所有差异。因此，在按顺序处理时，你可在不同差异段之间使用 <code>d a</code> 和 <code>d b</code> ，灵活将合并缓冲区的某段区域默认设为 A 版本、另一段设为 B 版本。
</p></dd>

<dt><code>prefer-A</code></dt><dd></dd>

<dt><code>prefer-B</code></dt><dd><p>
差异区域显示 A 或 B 版本内容，该状态表示此版本为 <b>优选版本</b> 。优选状态意味着你未对此差异做出显式选择，但 Emerge 根据 <b>共同原始版本</b> 判断，其中一个版本更可能是合理修改 —— 当其中一个版本与共同原始版本内容一致时，另一个版本会被判定为主动修改，进而标记为优选。例如，当 A 缓冲区内容与共同原始版本一致时，B 版本会被设为 <code>prefer-B</code> ，因为其更可能是实际需要保留的修改。
</p>

<p>
这两种状态在模式行中分别以 <code>A*</code> 和 <code>B*</code> 标识。
</p></dd>

<dt><code>combined</code></dt><dd><p>
差异区域显示 A、B 两个版本的 <b>合并内容</b> ，该状态由执行 <code>x c</code> 或 <code>x C</code> 命令触发。
</p>

<p>
一旦差异进入此状态，直接执行 <code>a</code> 和 <code>b</code> 命令将不再对其生效，除非为这两个命令传入 <b>数字参数</b> 。
</p>

<p>
该状态在模式行中以 'comb' 标识。
</p></dd>
</dl>
</div>
</div>
<div id="outline-container-Merge-Commands" class="outline-4">
<h4 id="Merge-Commands"><span class="section-number-4">30.6.4.</span> 合并命令</h4>
<div class="outline-text-4" id="text-Merge-Commands">
<p>
以下为快速模式下的合并命令；若在编辑模式中使用，需在所有命令前添加前缀键 <code>C-c C-c</code> ：
</p>
<dl class="org-dl">
<dt><code>p</code></dt><dd>选中上一处差异。</dd>
<dt><code>n</code></dt><dd>选中下一处差异。</dd>
<dt><code>a</code></dt><dd>选用当前差异的 A 版本内容。</dd>
<dt><code>b</code></dt><dd>选用当前差异的 B 版本内容。</dd>
<dt><code>C-u n j</code></dt><dd>选中第 n 处差异。</dd>
<dt><code>.</code></dt><dd>选中光标所在位置的差异。</dd>
<dt><code>q</code></dt><dd>退出 —— 完成合并操作。</dd>
<dt><code>C-]</code></dt><dd>中止 —— 退出合并流程，且不保存输出内容。</dd>
<dt><code>f</code></dt><dd>切换至快速模式（编辑模式下实际为 <code>C-c C-c f</code> ）。</dd>
<dt><code>e</code></dt><dd>切换至编辑模式。</dd>
<dt><code>l</code></dt><dd>重绘所有三个窗口的内容（功能同 <code>C-l</code> ）；带参数执行时，恢复三个窗口的默认显示布局。</dd>
<dt><code>-</code></dt><dd>输入前缀数字参数的一部分。</dd>
<dt><code>数字键</code></dt><dd>同样用于输入前缀数字参数的一部分。</dd>
<dt><code>d a</code></dt><dd>将当前位置往后的合并缓冲区内容，默认设为 A 版本。</dd>
<dt><code>d b</code></dt><dd>将当前位置往后的合并缓冲区内容，默认设为 B 版本。</dd>
<dt><code>c a</code></dt><dd>将当前差异的 A 版本内容复制至杀环。</dd>
<dt><code>c b</code></dt><dd>将当前差异的 B 版本内容复制至杀环。</dd>
<dt><code>i a</code></dt><dd>在光标位置插入当前差异的 A 版本内容。</dd>
<dt><code>i b</code></dt><dd>在光标位置插入当前差异的 B 版本内容。</dd>
<dt><code>m</code></dt><dd>在当前差异的首尾位置标记光标和标记位。</dd>
<dt><code>^</code></dt><dd>将三个窗口同步向下滚动（功能同 <code>M-v</code> ）。</dd>
<dt><code>v</code></dt><dd>将三个窗口同步向上滚动（功能同 <code>C-v</code> ）。</dd>
<dt><code>&lt;</code></dt><dd>将三个窗口同步向左滚动（功能同 <code>C-x &lt;</code> ）。</dd>
<dt><code>&gt;</code></dt><dd>将三个窗口同步向右滚动（功能同 <code>C-x &gt;</code> ）。</dd>
<dt><code>|</code></dt><dd>重置所有三个窗口的水平滚动位置。</dd>
<dt><code>x 1</code></dt><dd>将合并窗口收缩为单行显示（可使用 <code>C-u l</code> 恢复全屏显示）。</dd>
<dt><code>x c</code></dt><dd>合并当前差异的两个版本内容（参见「<a href="#Combining-in-Emerge">合并两个版本的内容</a>」章节）。</dd>
<dt><code>x f</code></dt><dd>在帮助窗口中显示 Emerge 当前操作的文件 / 缓冲区名称（可使用 <code>C-u l</code> 恢复窗口布局）。</dd>
<dt><code>x j</code></dt><dd>将当前差异与下一处差异合并为一个差异（带参数执行 <code>C-u x j</code> 时，将当前差异与上一处差异合并）。</dd>
<dt><code>x s</code></dt><dd>将当前差异拆分为两个差异；使用该命令前，需在三个缓冲区的光标位置，分别定位到想要拆分差异的位置。</dd>
<dt><code>x t</code></dt><dd>剔除当前差异首尾处的相同行；此类行出现的场景为：A、B 版本内容一致，但均与原始版本存在差异</dd>
</dl>
</div>
</div>
<div id="outline-container-Exiting-Emerge" class="outline-4">
<h4 id="Exiting-Emerge"><span class="section-number-4">30.6.5.</span> 退出 Emerge</h4>
<div class="outline-text-4" id="text-Exiting-Emerge">
<p>
执行 <code>q</code> 命令 (<code>emerge-quit</code>) 会完成合并操作；若你已指定输出文件，该命令会将合并结果写入此文件。命令会将 A、B 缓冲区恢复至原有内容；若这两个缓冲区由 Emerge 创建且你未对其做任何修改，命令会直接删除这两个缓冲区。同时，该命令会禁用合并缓冲区中的所有 Emerge 命令，避免后续执行此类命令破坏各缓冲区的内容。
</p>

<p>
按下 <code>C-]</code> 会 <b>中止</b> 合并操作，即退出 Emerge 且不会将内容写入输出文件。若你未指定输出文件，中止合并与完成合并这两种操作并无实际区别。
</p>

<p>
若 Emerge 命令由其他 Lisp 程序调用，该命令会返回布尔值t表示合并成功完成，返回 <code>nil</code> 则表示你中止了合并操作。
</p>
</div>
</div>
<div id="outline-container-Combining-in-Emerge" class="outline-4">
<h4 id="Combining-in-Emerge"><span class="section-number-4">30.6.6.</span> 合并两个版本的内容</h4>
<div class="outline-text-4" id="text-Combining-in-Emerge">
<p>
有时你希望为某一处特定差异保留两个版本的内容，可执行 <code>x c</code> 命令实现此需求，该命令会按如下形式编辑合并缓冲区：
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#ifdef</span> NEW
B&#32531;&#20914;&#21306;&#20013;&#30340;&#29256;&#26412;&#20869;&#23481;
<span style="color: #483d8b;">#else</span> <span style="color: #b22222;">/* </span><span style="color: #b22222;">not NEW</span><span style="color: #b22222;"> */</span>
A&#32531;&#20914;&#21306;&#20013;&#30340;&#29256;&#26412;&#20869;&#23481;
<span style="color: #483d8b;">#endif</span> <span style="color: #b22222;">/* </span><span style="color: #b22222;">not NEW</span><span style="color: #b22222;"> */</span>
</pre>
</div>

<p>
上述示例使用 C 语言预处理器条件编译指令分隔两个版本的内容，你也可通过设置变量 <code>emerge-combine-versions-template</code> 为自定义字符串，指定分隔所用的标识格式。在该自定义字符串中， '<code>%a</code>' 表示 A 版本内容的插入位置， '<code>%b</code>' 表示 B 版本内容的插入位置。生成上述示例效果的默认配置如下：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #8b2252;">"#ifdef NEW\n%b#else /* not NEW */\n%a#endif /* not NEW */\n"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-Fine-Points-of-Emerge" class="outline-4">
<h4 id="Fine-Points-of-Emerge"><span class="section-number-4">30.6.7.</span> Emerge 的细节要点</h4>
<div class="outline-text-4" id="text-Fine-Points-of-Emerge">
<p>
合并过程中， <b>切勿手动编辑 A、B 缓冲区</b> 。Emerge 会对这两个缓冲区做临时修改，最终会将其恢复至原始状态。
</p>

<p>
你可以同时执行多个合并操作，但 <b>不可将同一个缓冲区作为多个合并操作的输入源</b> —— 因为这类缓冲区中的临时修改会互相干扰，导致操作异常。
</p>

<p>
启动 Emerge 的耗时可能较长，原因是程序需要对文件进行完整的对比；在 <code>diff</code> 对比操作完成前，Emacs 无法执行其他任何操作。未来或许会有开发者对 Emerge 做优化，让程序在处理大文件时，于后台执行对比操作 —— 如此一来，在 Emerge 准备好接收命令前，你仍可使用 Emacs 进行其他操作。
</p>

<p>
完成合并环境的初始化后，Emerge 会执行钩子函数 <code>emerge-startup-hook</code> （详见「<a href="#Hooks">钩子函数</a>」相关内容）
</p>
</div>
</div>
</div>
<div id="outline-container-Bug-Reference" class="outline-3">
<h3 id="Bug-Reference"><span class="section-number-3">30.7.</span> 漏洞引用</h3>
<div class="outline-text-3" id="text-Bug-Reference">
<p>
多数拥有一定用户量的项目，会通过 <b>缺陷跟踪软件</b> 记录缺陷报告，并为每份报告分配一个唯一且简短的编号或标识符。这类标识可用于引用特定缺陷，例如在修复某一缺陷的代码上方添加源码注释、在文档文件中提及，或是在邮件列表、IRC 频道的讨论中引用。
</p>

<p>
次要模式 <code>bug-reference-mode</code> （缺陷引用模式）和 <code>bug-reference-prog-mode</code> （编程缺陷引用模式）可对这类缺陷引用进行高亮显示，还能实现点击引用直接跳转到项目缺陷跟踪系统中对应的缺陷报告页面。其中 <code>bug-reference-prog-mode</code> 是 <code>bug-reference-mode</code> 的变体，仅会对 <b>源码注释和字符串内</b> 的缺陷引用进行高亮。
</p>

<p>
该模式的正常运行，需要提前配置两个核心参数：缺陷引用的语法规则（变量 <code>bug-reference-bug-regexp</code> ），以及用于查阅缺陷报告的跟踪系统 URL 格式（变量 <code>bug-reference-url-format</code> ）。由于不同项目的配置规则通常不同，建议在 <b><a href="#Directory-Variables">按目录本地变量</a></b> 或 <b><a href="#File-Variables">文件本地变量</a></b> 中单独指定这些参数。
</p>

<p>
举个例子，若项目中通常以 'bug#1234' 或 'Bug-1234' 的形式引用缺陷报告，且该缺陷在跟踪系统中的访问地址为 <a href="https://project.org/issues/1234">https://project.org/issues/1234</a>，只需在文件中添加以下本地变量配置即可：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #b22222;">;; </span><span style="color: #b22222;">Local Variables&#58;
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">bug-reference-bug-regexp: "\\([Bb]ug[#-]\\([0-9]+\\)\\)"
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">bug-reference-url-format: "https://project.org/issues/%s"
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">End:</span>
</pre>
</div>

<p>
正则表达式的 <b>第一个捕获组</b> 匹配的字符串，会作为 bug-reference 创建高亮覆盖层的范围，即这部分内容会被高亮并设置为可点击状态。
</p>

<p>
<code>bug-reference-bug-regexp</code> 中 <b>第二个捕获组</b> 匹配的字符串，会用于替换 <code>bug-reference-url-format</code> 中的 <code>%s</code> 占位符。
</p>

<p>
需要注意的是， <code>bug-reference-url-format</code> 也可设为 <b>函数</b> ，以适配更复杂的使用场景。例如，当需要通过缺陷引用中的不同部分区分普通缺陷和合并请求，进而跳转至不同 URL 时，即可使用函数配置。
</p>

<p>
<b>自动配置</b>
</p>

<p>
若激活 <code>bug-reference-mode</code> 并执行了钩子函数 <code>bug-reference-mode-hook</code> 后， <code>bug-reference-bug-regexp</code> 或 <code>bug-reference-url-format</code> 仍为 <code>nil</code> ，该模式会自动调用 <code>bug-reference-auto-setup-functions</code> 中的函数，依次尝试为这两个变量配置合适的值，直至某个函数执行成功。
</p>

<p>
目前该变量中包含三类自动配置函数：
</p>
<ul class="org-ul">
<li>版本控制文件配置：由变量 <code>bug-reference-forge-alist</code> 和 <code>bug-reference-setup-from-vc-alist</code> 配置，默认支持 GNU 项目（使用 <a href="https://debbugs.gnu.org">https://debbugs.gnu.org</a>作为缺陷跟踪系统，缺陷通常以 'bug#13' 形式引用，同时兼容多种其他写法），也支持 GitLab、Gitea、SourceHut、GitHub 等主流代码托管平台。若部署了这类平台的私有实例，可通过 <code>bug-reference-forge-alist</code> 快速配置 bug-reference。</li>
<li>邮件信息推导配置：由变量 <code>bug-reference-setup-from-mail-alist</code> 配置，可从邮件文件夹 / 邮箱文件名、邮件头信息中自动推导配置，支持 Emacs 内置的<a href="#Gnus">新闻和邮件阅读器 Gnus</a>（网络新闻）与 <a href="#Rmail">Rmail</a>（邮件阅读）。</li>
<li>IRC 频道配置：由变量 <code>bug-reference-setup-from-irc-alist</code> 配置，支持 Emacs 内置的 IRC 客户端 Rcirc（详见《<a href="https://www.gnu.org/software/emacs/manual/html_node/rcirc/index.html#Top">Rcirc 使用手册</a>》）和 ERC（详见《<a href="https://www.gnu.org/software/emacs/manual/html_node/erc/index.html#Top">ERC 使用手册</a>》）。</li>
</ul>

<p>
对于上述几乎所有模式，只需直接启用 <code>bug-reference-mode</code> 即可完成配置，仅 Rmail 需要稍作特殊设置，配置示例如下：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#33509;&#25991;&#20214;&#21463;&#29256;&#26412;&#25511;&#21046;&#65292;&#21551;&#29992;&#22522;&#20110;&#29256;&#26412;&#25511;&#21046;&#30340;&#37197;&#32622;
</span>(add-hook 'prog-mode-hook #'bug-reference-prog-mode)

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Gnus&#65288;&#25688;&#35201;&#21644;&#25991;&#31456;&#32531;&#20914;&#21306;&#65289;
</span>(add-hook 'gnus-mode-hook #'bug-reference-mode)

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Rmail &#29305;&#27530;&#37197;&#32622;
</span>(add-hook 'rmail-show-message-hook #'bug-reference-mode-force-auto-setup)

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Rcirc
</span>(add-hook 'rcirc-mode-hook #'bug-reference-mode)

<span style="color: #b22222;">;; </span><span style="color: #b22222;">ERC
</span>(add-hook 'erc-mode-hook #'bug-reference-mode)
</pre>
</div>

<p>
Rmail 的配置中，不能直接使用模式钩子，需将 <code>rmail-show-message-hook</code> 与函数 <code>bug-reference-mode-force-auto-setup</code> 配合使用 —— 该函数会激活 <code>bug-reference-mode</code> 并强制触发自动配置。原因是 Rmail 中所有邮件都存放在同一个缓冲区，而每次显示新邮件时，都需要重新执行配置。
</p>

<p>
<b>为第三方包添加支持</b>
</p>

<p>
为第三方包添加bug-reference自动配置的流程通常十分简单，只需完成以下步骤：
</p>

<ul class="org-ul">
<li>编写一个 <b>无参配置函数</b> ，用于收集所需的配置信息（例如邮件客户端需获取邮件头的 List-Id/To/From/Cc 等字段值）；</li>
<li><p>
在函数中调用以下辅助函数之一完成配置：
</p>
<ul class="org-ul">
<li><code>bug-reference-maybe-setup-from-vc</code> ：根据 <code>bug-reference-setup-from-vc-alist</code> 完成版本控制相关配置；</li>
<li><code>bug-reference-maybe-setup-from-mail</code> ：根据 <code>bug-reference-setup-from-mail-alist</code> 完成邮件相关配置；</li>
<li><code>bug-reference-maybe-setup-from-irc</code> ：根据 <code>bug-reference-setup-from-irc-alist</code> 完成 IRC 相关配置。</li>
</ul>

<p>
若配置函数能成功为 <code>bug-reference-mode</code> 完成配置，需返回非 nil 值（通常将上述辅助函数作为函数最后一步执行，即可满足该要求）。
</p></li>

<li>最后将该配置函数添加至 <code>bug-reference-auto-setup-functions</code> 中即可。</li>
</ul>

<p>
注意：所有自动配置函数的 <b>第一步</b> ，都应先检查自身是否适用当前场景（例如通过判断 <code>major-mode</code> 的值）。
</p>

<p>
<b>与 debbugs 包的集成</b>
</p>

<p>
若项目的缺陷跟踪系统部署在 <a href="https://debbugs.gnu.org">https://debbugs.gnu.org</a> 服务器，可通过 Emacs 的debbugs包在 Emacs 内直接浏览和回复缺陷报告，该包可通过 <b>包菜单</b> 下载安装（详见《<a href="#Packages">Emacs Lisp 包</a>》章节）。debbugs包提供了次要模式 <code>debbugs-browse-mode</code> ，可在 <code>bug-reference-mode</code> 和 <code>bug-reference-prog-mode</code> 基础上叠加激活，配置如下：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'bug-reference-mode-hook 'debbugs-browse-mode)
(add-hook 'bug-reference-prog-mode-hook 'debbugs-browse-mode)
</pre>
</div>
</div>
</div>
</section>
<section id="outline-container-Abbrevs" class="outline-2">
<h2 id="Abbrevs"><span class="section-number-2">31.</span> 缩写</h2>
<div class="outline-text-2" id="text-Abbrevs">
<p>
已定义 <i>abbrev缩写</i> 指输入后会自动展开为其他文本的词汇，由用户自定义展开规则。例如，你可将 'foo' 定义为缩写，使其展开为 'find outer otter' ；此后只需输入 'foo' 并按下 <code>SPC</code> 空格键，即可在缓冲区中插入 'find outer otter' 。
</p>

<p>
Emacs 还提供第二种缩写功能 —— <i>dynamic abbrev expansion动态缩写展开</i> ，需通过显式命令触发：以光标前的字符为前缀，在缓冲区中查找以该前缀开头的其他词汇，实现对应字符的展开。详见「<a href="#Dynamic-Abbrevs">动态缩写展开</a>」章节。
</p>

<p>
第三种是 <i>hippie expansion嬉皮式展开</i> ，是对缩写展开功能的通用化扩展。详见《自动输入相关功能》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/autotype/Hippie-Expand.html#Hippie-Expand">嬉皮式展开</a>」章节。
</p>
</div>
<div id="outline-container-Abbrev-Concepts" class="outline-3">
<h3 id="Abbrev-Concepts"><span class="section-number-3">31.1.</span> 缩写概念</h3>
<div class="outline-text-3" id="text-Abbrev-Concepts">
<p>
<b><i>abbrev缩写</i></b> 指被定义为可 <i>expand展开</i> 为指定文本的词汇。当你在缩写后输入 <b>单词分隔符</b> 时，该缩写会自动展开 —— 即用其对应的展开文本替换缩写本身。例如，若将 'foo' 定义为展开为 'find outer otter' 的缩写，那么输入 <code>f o o .</code> 后，缓冲区中会插入 'find outer otter.' 。
</p>

<p>
缩写仅在 <b>缩写模式（Abbrev mode）</b> 开启时生效，该模式是一个缓冲区局部的次要模式。关闭缩写模式并不会让已定义的缩写规则丢失，只是在重新开启该模式前，缩写不会自动展开。执行命令 <code>M-x abbrev-mode</code> 可切换缩写模式的开关；若为该命令传入数字参数，正参数会开启缩写模式，非正参数则会关闭。详见「<a href="#Minor-Modes">次要模式</a>」相关内容。
</p>

<p>
缩写可设置 <b><i>mode-specific definitions模式专属定义</i></b> ，仅在某一种主模式下生效；也可设置 <b><i>global definitions全局定义</i></b> ，在所有主模式中均生效。同一个缩写可同时拥有全局定义，以及针对不同主模式的多个模式专属定义。当前主模式对应的模式专属定义，会 <b>覆盖</b> 其全局定义。
</p>

<p>
无论缩写模式是否开启，你都可在编辑会话中 <b>交互式定义缩写</b> 。同时，你也能将缩写定义列表保存至文件中，后续编辑会话可重新加载该文件，复用已定义的缩写规则。
</p>
</div>
</div>
<div id="outline-container-Defining-Abbrevs" class="outline-3">
<h3 id="Defining-Abbrevs"><span class="section-number-3">31.2.</span> 定义缩写</h3>
<div class="outline-text-3" id="text-Defining-Abbrevs">
<dl class="org-dl">
<dt><code>C-x a g</code></dt><dd>定义全局缩写，将光标前的一个或多个单词设为该缩写的展开文本 (<code>add-global-abbrev</code>) 。</dd>
<dt><code>C-x a l</code></dt><dd>功能与上一命令类似，定义 <b>当前主模式专属</b> 的缩写 (<code>add-mode-abbrev</code>) 。</dd>
<dt><code>C-x a i g</code></dt><dd>将缓冲区中的指定单词定义为全局缩写 (<code>inverse-add-global-abbrev</code> ，反向定义) 。</dd>
<dt><code>C-x a i l</code></dt><dd>将缓冲区中的指定单词定义为当前主模式专属的缩写 (<code>inverse-add-mode-abbrev</code> ，反向定义) 。</dd>
<dt><code>M-x define-global-abbrev RET 缩写名 RET 展开文本 RET</code></dt><dd>自定义全局缩写，将指定的 <b>缩写名</b> 定义为展开为指定 <b>展开文本</b> 的全局缩写。</dd>
<dt><code>M-x define-mode-abbrev RET abbrev RET exp RET</code></dt><dd>自定义模式专属缩写，将指定的 <b>缩写名</b> 定义为当前主模式下展开为指定 <b>展开文本</b> 的缩写。</dd>
<dt><code>M-x kill-all-abbrevs</code></dt><dd>清除所有缩写定义，恢复为无缩写的初始状态。</dd>
</dl>

<p>
<b>常规定义方法</b>
</p>

<p>
定义缩写的常用方式为：先输入该缩写想要展开成的目标文本，将光标移至文本末尾，执行 <code>C-x a g</code> (<code>add-global-abbre</code>) 。该命令会通过迷你缓冲区读取你要定义的 <b>缩写名</b> ，并将光标前的内容设为该缩写的展开文本。可通过数字参数指定取光标前多少个单词作为展开文本。例如，要将 'foo' 定义为展开为 'find outer otter' 的缩写，需先在缓冲区中输入 'find outer otter' ，再执行 <code>C-u 3 C-x a g foo RET</code> 即可。
</p>

<p>
若开启了临时标记模式（ <code>transient-mark-mode</code> ，默认开启），会直接将 <b>激活的选区内容</b> 设为待定义缩写的展开文本；若未开启该模式，为 <code>C-x a g</code> 传入0 参数（ <code>C-u 0 C-x a g</code> ），同样可将选区内容设为展开文本。
</p>

<p>
命令 <code>C-x a l</code> (<code>add-mode-abbrev</code>) 的操作方式与 <code>C-x a g</code> 完全一致，唯一区别是该命令定义的缩写仅在当前主模式下生效。
</p>

<p>
<b>反向定义方法</b>
</p>

<p>
<code>C-x a i g</code> (<code>inverse-add-global-abbrev</code>) 和 <code>C-x a i l</code> (<code>inverse-add-mode-abbrev</code>) 为 <b>反向定义命令</b> ，适用于 <b>缩写名已在缓冲区中</b> 的场景：只需将光标定位到该缩写名处，执行对应命令，通过迷你缓冲区输入该缩写的 <b>展开文本</b> ，即可完成定义。定义完成后，该缩写名会立即展开为你指定的文本。
</p>

<p>
<b>无缓冲区内容定义</b>
</p>

<p>
若不想在缓冲区中输入任何内容，也可通过 <code>define-global-abbrev</code> 命令定义全局缩写，该命令会直接依次读取缩写名和展开文本两个参数，无需依赖缓冲区内容； <code>define-mode-abbrev</code> 命令则以同样方式定义模式专属缩写。
</p>

<p>
<b>修改与删除缩写</b>
</p>

<p>
修改缩写定义的方式为：直接对该缩写名重新执行定义命令即可。若该缩写已有定义，重新定义时，Emacs 会先弹出确认提示，确认后才会覆盖原有定义。
</p>

<p>
删除缩写定义的方式为：为缩写定义命令传入负参数。其中 <code>C-u - C-x a g</code> 用于删除全局缩写的定义， <code>C-u - C-x a l</code> 用于删除当前模式专属缩写的定义。执行 <code>M-x kill-all-abbrevs</code> 可一次性删除所有缩写定义（包括全局和模式专属）。
</p>
</div>
</div>
<div id="outline-container-Expanding-Abbrevs" class="outline-3">
<h3 id="Expanding-Abbrevs"><span class="section-number-3">31.3.</span> 控制缩写展开</h3>
<div class="outline-text-3" id="text-Expanding-Abbrevs">
<p>
启用缩写模式后，若光标前的缓冲区内容为已定义的缩写，此时输入自插入的空白字符或标点符号（空格、逗号等），该缩写会自动展开。更准确地说，非单词构成字符均可触发缩写展开，而单词构成字符可作为缩写的组成部分。使用缩写最常用的方式是：输入缩写后，输入一个标点或空白字符触发其展开。
</p>

<p>
缩写展开会保留大小写格式：'foo' 展开为 'find outer otter' ， 'Foo' 展开为 'Find outer otter' 。全大写的 'FOO' 默认展开为 'Find Outer Otter' ；若将变量 <code>abbrev-all-caps</code> 设为非 nil 值，该缩写会展开为全大写的 'FIND OUTER OTTER' 。
</p>

<p>
以下为控制缩写展开的相关命令：
</p>
<dl class="org-dl">
<dt><code>M-'</code></dt><dd>为后续待展开的缩写分隔出前缀 (<code>abbrev-prefix-mark</code>) 。</dd>
<dt><code>C-x a e</code></dt><dd>展开光标前的缩写 (<code>expand-abbrev</code>) ，该命令在缩写模式未启用时也可生效。</dd>
<dt><code>M-x unexpand-abbrev</code></dt><dd>撤销上一次的缩写展开操作。</dd>
<dt><code>M-x expand-region-abbrevs</code></dt><dd>展开选区中部分或全部的已定义缩写。</dd>
</dl>

<p>
你可能需要在缩写展开后的文本前添加前缀，例如：若 'cnst' 展开为 'construction' ，希望通过该缩写输入 'reconstruction' 。直接输入 'recnst' 无法实现，因为该字符串并非已定义的缩写。正确操作是在前缀 're' 和缩写 'cnst' 之间使用命令 <code>M-'</code> （缩写前缀标记），步骤如下：
</p>
<ul class="org-ul">
<li>输入前缀 're' ；</li>
<li>按下 <code>M-'</code> ，缓冲区中会插入一个连字符 '-' ，表示该命令已生效；</li>
<li>输入缩写 'cnst'，此时缓冲区内容为 're-cnst' ；</li>
<li>输入一个非单词字符触发缩写展开，'cnst' 会展开为 'construction' ，且步骤 2 中插入的连字符会被自动删除，最终得到目标文本 'reconstruction' 。</li>
</ul>

<p>
若希望在缓冲区中保留缩写本身而非展开后的文本，可通过 <code>C-q</code> 搭配标点的方式输入终止字符。例如，输入 'foo' 后按下 <code>C-q ,</code> ，缓冲区中会保留 'foo,' ，缩写不会被展开。
</p>

<p>
若误触发了缩写展开，可按下 <code>C-/</code> (<code>undo</code>)撤销操作（详见「<a href="#Undo">撤销</a>」章节），该操作会删除展开后的文本，恢复缩写本身。若你希望保留终止的非单词字符，同时恢复未展开的缩写，需通过 <code>C-q</code> 重新输入该终止字符；也可使用命令 <code>M-x unexpand-abbrev</code> ，仅撤销上一次的展开操作，而保留终止字符。
</p>

<p>
<code>M-x expand-region-abbrevs</code> 会在选区内检索所有已定义的缩写，并逐个询问是否将其展开为对应文本。该命令适用于以下场景：输入文本时使用了缩写，但忘记提前开启缩写模式；也可配合一组专用的缩写定义，实现多处文本的批量替换。该命令在缩写模式未启用时也可生效。
</p>

<p>
<code>expand-abbrev</code> 函数会通过调用 <code>abbrev-expand-function</code> 变量指定的函数执行缩写展开操作。修改该变量对应的函数，即可对缩写展开的逻辑进行任意自定义（详见《Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Abbrev-Expansion.html#Abbrev-Expansion">缩写展开</a>」章节）。
</p>
</div>
</div>
<div id="outline-container-Abbrevs-Suggestions" class="outline-3">
<h3 id="Abbrevs-Suggestions"><span class="section-number-3">31.4.</span> 缩写建议</h3>
<div class="outline-text-3" id="text-Abbrevs-Suggestions">
<p>
当你手动输入的文本，恰好是当前已启用的缩写所对应的展开文本时，Emacs 会为你给出 <b>缩写建议</b> 。例如，若已定义缩写 'foo' ，其展开文本为 'find outer otter' ，当你手动完整输入 'find outer otter' 后，停止输入时 Emacs 会识别到这一情况，并在回显区显示相关的缩写提示。
</p>

<p>
要启用缩写建议功能，需将配置项 <code>abbrev-suggest</code> 自定义设为非nil值。
</p>

<p>
变量 <code>abbrev-suggest-hint-threshold</code> 用于控制向用户推送缩写建议的触发条件，该变量定义了 Emacs 给出缩写建议所需的 <b>最小字符节省量</b> （即使用缩写相比手动输入能少打的字符数）。例如，若你手动输入了 'foo bar' （共 7 个字符），而当前已定义缩写 'fubar' （5 个字符）可展开为该文本，那么只有当该阈值设为 2 或更小值时，Emacs 才会给出建议；该变量默认值为 3，此情况下上述示例不会触发建议，因为使用该缩写的字符节省量未达到阈值要求。若希望始终收到缩写建议，可将该变量值设为 0。
</p>

<p>
执行命令 <code>abbrev-suggest-show-report</code> ，会打开一个缓冲区，展示当前编辑会话中出现过的所有缩写建议。如果你收到了多条缩写建议但无法全部记住，该命令会非常实用。
</p>
</div>
</div>
<div id="outline-container-Editing-Abbrevs" class="outline-3">
<h3 id="Editing-Abbrevs"><span class="section-number-3">31.5.</span> 查看与编辑缩写</h3>
<div class="outline-text-3" id="text-Editing-Abbrevs">
<dl class="org-dl">
<dt><code>M-x list-abbrevs</code></dt><dd>展示所有缩写的定义列表；若传入数字参数，仅列出 <b>模式专属缩写</b> 。</dd>
<dt><code>M-x edit-abbrevs</code></dt><dd>编辑缩写列表，可对缩写定义进行添加、修改或删除操作。</dd>
</dl>

<p>
<code>M-x list-abbrevs</code> 命令的输出格式示例如下：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">&#21508;&#31867;&#20854;&#20182;&#32553;&#20889;&#34920;&#8230;
(python-mode-skeleton-abbrev-table)
<span style="color: #8b2252;">"class"</span> (sys)       0 <span style="color: #8b2252;">""</span> python-skeleton-class
(lisp-mode-abbrev-table)
<span style="color: #8b2252;">"ks"</span>          0    <span style="color: #8b2252;">"keymap-set"</span>
(global-abbrev-table)
<span style="color: #8b2252;">"dfn"</span>         0    <span style="color: #8b2252;">"definition"</span>
</pre>
</div>

<p>
（示例中省略了无实际语义的空行及其他部分缩写表。）
</p>

<p>
以括号包裹名称的行，是对应 <b>专属缩写表</b> 的标题： <code>global-abbrev-table</code> 包含所有全局缩写，其余以主模式命名的缩写表，则存放对应模式的专属缩写。
</p>

<p>
在每个缩写表内，非空行各定义一个缩写：行首的单词为 <b>缩写名</b> ，其后的数字是该缩写的 <b>展开次数</b> 。Emacs 会统计该数值，帮助你了解实际常用的缩写，从而清理不常使用的缩写；行尾的字符串则是该缩写的 <b>展开文本</b> 。
</p>

<p>
部分缩写会标注 '<code>(sys)</code>' 标识，这类 <b><i>system abbrevs系统缩写</i></b> （详见《Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Abbrevs.html#Abbrevs">缩写</a>」章节）由各类模式预先定义， <b>不会被保存至你的缩写文件</b> 。若要禁用某个系统缩写，可定义一个同名缩写并将其展开文本设为自身，再将该定义保存至缩写文件即可。系统缩写会关联一个钩子函数，用于执行缩写展开操作；在 <code>list-abbrevs</code> 命令展示的缓冲区中，该函数名会紧跟在系统缩写的展开文本之后。
</p>

<p>
<code>M-x edit-abbrevs</code> 命令允许你在 Emacs 缓冲区中编辑缩写列表，完成缩写定义的添加、修改和删除，该列表的格式与上述 <code>list-abbrevs</code> 的输出格式一致。存放缩写的缓冲区名为 <code>*Abbrevs*</code> ，并启用 <b>编辑缩写模式</b> （Edit-Abbrevs mode）。在该缓冲区中按下 <code>C-c C-c</code> ，会按照缓冲区中的内容加载缩写定义，同时 <b>删除所有未在列表中列出的缩写定义</b> 。
</p>

<p>
实际上 <code>edit-abbrevs</code> 与 <code>list-abbrevs</code> 是同一命令，唯一区别在于： <code>edit-abbrevs</code> 会直接选中 <code>*Abbrevs*</code> 缓冲区，而 <code>list-abbrevs</code> 仅在其他窗口中展示该缓冲区。
</p>
</div>
</div>
<div id="outline-container-Saving-Abbrevs" class="outline-3">
<h3 id="Saving-Abbrevs"><span class="section-number-3">31.6.</span> 保存缩写</h3>
<div class="outline-text-3" id="text-Saving-Abbrevs">
<p>
下述命令可让你在不同的编辑会话中保留缩写定义。
</p>
<dl class="org-dl">
<dt><code>M-x write-abbrev-file RET file RET</code></dt><dd>将所有已定义的缩写信息写入指定文件。</dd>
<dt><code>M-x read-abbrev-file RET file RET</code></dt><dd>读取指定文件，并根据文件内容定义对应的缩写。</dd>
<dt><code>M-x define-abbrevs</code></dt><dd>根据当前缓冲区中的定义内容创建缩写。</dd>
<dt><code>M-x insert-abbrevs</code></dt><dd>将所有缩写及其对应的展开文本插入当前缓冲区。</dd>
</dl>

<p>
<code>M-x write-abbrev-file</code> 会通过迷你缓冲区读取文件名，随后将当前所有的缩写定义信息写入该文件，用于将缩写定义保存下来，供后续编辑会话使用。文件中存储的是一系列 Lisp 表达式，这些表达式执行后，就能还原出你当前所有的缩写定义。
</p>

<p>
<code>M-x read-abbrev-file</code> 会通过迷你缓冲区读取文件名，再读取该文件的内容，并依照文件中的配置定义缩写。函数 <code>quietly-read-abbrev-file</code> 的功能与其类似，区别在于该函数不会在回显区显示提示信息；此函数无法以交互方式调用，主要用于你的初始化文件中（参见《<a href="#Init-File">Emacs 初始化文件</a>》章节）。若为这两个函数传入 <code>nil</code> 作为参数，它们会使用变量 <code>abbrev-file-name</code> 指定的文件，该变量的默认值为 <code>~/.emacs.d/abbrev_defs</code> ，这是你的标准缩写定义文件，Emacs 启动时会自动从中加载缩写定义。（例外情况：当 Emacs 以批处理模式启动时，不会加载该缩写文件，批处理模式的说明参见《<a href="#Initial-Options">初始化选项</a>》章节。）
</p>

<p>
当 Emacs 提示你保存所有文件时（如执行 <code>C-x s</code> 或 <code>C-x C-c</code> 命令时），若你对缩写定义做过任何修改，Emacs 会自动提示你保存缩写，并将其保存至 <code>abbrev-file-name</code> 指定的文件中。将变量 <code>save-abbrevs</code> 设为 <code>nil</code> ，可禁用该自动保存功能；若将其设为 <code>silently</code> ，Emacs 会自动保存缩写，且不会弹出确认提示。
</p>

<p>
<code>M-x insert-abbrevs</code> 和 <code>M-x define-abbrevs</code> 与前述命令功能相近，区别在于二者针对的是 Emacs 缓冲区中的文本。 <code>M-x insert-abbrevs</code> 会在光标后方，将当前所有的缩写定义信息插入到当前缓冲区； <code>M-x define-abbrevs</code> 会解析整个当前缓冲区的内容，并据此定义对应的缩写。
</p>
</div>
</div>
<div id="outline-container-Dynamic-Abbrevs" class="outline-3">
<h3 id="Dynamic-Abbrevs"><span class="section-number-3">31.7.</span> 动态缩写展开</h3>
<div class="outline-text-3" id="text-Dynamic-Abbrevs">
<p>
前文介绍的缩写功能会在你输入文本时自动生效，但所有缩写都必须经过显式定义。与之不同， <b><i>dynamic abbrevs动态缩写</i></b> 的含义可由缓冲区内容自动推导得出，而动态缩写的展开仅在你显式触发时执行。
</p>

<dl class="org-dl">
<dt><code>M-/</code></dt><dd>搜索缓冲区中以光标前字符为 /dynamic abbrev/前缀的词汇 ，将其作为动态缩写展开光标前的内容 (<code>dabbrev-expand</code>) 。</dd>
<dt><code>C-M-/</code></dt><dd>将光标前的内容作为动态缩写完成补全 (<code>dabbrev-completion</code>) 。</dd>
</dl>

<p>
例如，若缓冲区中已有内容 'does this follow ' ，此时输入 <code>f o M-/</code> ，会自动插入 'follow' —— 因为这是缓冲区中最后一个以fo开头的词汇。为 <code>M-/</code> 传入 <b>数字参数</b> ，表示选取从光标位置向前搜索时，找到的第 2 个、第 3 个…… 不同的展开结果。重复按下 <code>M-/</code> 会继续向前搜索，寻找其他可选的展开结果；当扫描完光标前的所有文本后，会继续搜索光标后的文本。变量 <code>dabbrev-limit</code> 若设为非nil值，可指定在缓冲区中搜索展开结果的最大范围。
</p>

<p>
扫描完当前缓冲区后， <code>M-/</code> 通常会继续搜索其他缓冲区。可通过变量 <code>dabbrev-check-all-buffers</code> 和 <code>dabbrev-check-other-buffers</code> 设置是否搜索、以及搜索哪些其他缓冲区。所有主模式派生自 <code>dabbrev-ignored-buffer-modes</code> 中任一模式的缓冲区，都会被跳过不做搜索。
</p>

<p>
若需更精细地控制待扫描的缓冲区，可自定义变量 <code>dabbrev-ignored-buffer-names</code> 和 <code>dabbrev-ignored-buffer-regexps</code> 。前者的值为需跳过的缓冲区名称列表，后者的值为正则表达式列表；若某个缓冲区的名称匹配其中任意一个正则表达式，动态缩写展开时会跳过该缓冲区。
</p>

<p>
为 <code>M-/</code> 传入负参数（如 <code>C-u - M-/</code> ），表示优先搜索光标后的文本以获取展开结果，再搜索其他缓冲区，仅将光标前的文本作为最后选择。若需重复按下 <code>M-/</code> 查找其他展开结果，无需再指定参数；重复按下时会先遍历光标后的所有展开结果，再遍历光标前的结果。
</p>

<p>
展开动态缩写后，你可复制该缩写在原始语境中后续的多个词汇：只需为每个需要复制的后续词汇，按下一次 <code>SPC M-/</code> 即可，词汇之间的空格和标点会随词汇一同被复制。
</p>

<p>
你可自定义 <code>M-/</code> 识别待展开词汇的规则及展开方式，详见「<a href="#Dabbrev-Customization">自定义动态缩写</a>」章节。
</p>

<p>
命令 <code>C-M-/</code> (<code>dabbrev-completion</code>) 用于完成动态缩写的补全操作。该命令不会逐个尝试可能的展开结果，而是先找出所有匹配的结果，再插入这些结果的 <b>公共前缀文本</b> ；若结果无公共前缀， <code>C-M-/</code> 会展示所有补全候选列表，你可按常规方式选择所需结果（详见「<a href="#Completion">补全</a>」章节）。
</p>

<p>
动态缩写展开与 <b>Abbrev mode缩写模式</b> 完全独立：使用 <code>M-/</code> 展开词汇的操作，与该词汇是否被定义为普通缩写毫无关联。
</p>
</div>
</div>
<div id="outline-container-Dabbrev-Customization" class="outline-3">
<h3 id="Dabbrev-Customization"><span class="section-number-3">31.8.</span> 定制动态缩写</h3>
<div class="outline-text-3" id="text-Dabbrev-Customization">
<p>
默认情况下，动态缩写展开在搜索匹配的展开文本时 <b>忽略大小写</b> ，即展开文本的大小写无需与待展开的缩写保持一致。
</p>

<p>
该特性由变量 <code>dabbrev-case-fold-search</code> 控制：若值为t，搜索时完全忽略大小写；若值为 <code>nil</code> ，待展开缩写与展开文本必须大小写完全匹配；若值为 <code>case-fold-search</code> （默认值），则由变量 <code>case-fold-search</code> 决定搜索展开文本时是否忽略大小写（参见「<a href="#Lax-Search">搜索中的宽松匹配</a>」章节）。
</p>

<p>
默认情况下，动态缩写展开会 <b><i>dynamic abbrev you are expanding保留待展开缩写的大小写格式</i></b> ，并将匹配到的展开文本转换为对应的大小写形式。
</p>

<p>
变量 <code>dabbrev-case-replace</code> 控制是否保留动态缩写的大小写格式：若值为t，绝大多数情况下会保留待展开缩写的大小写格式；若值为 <code>nil</code> ，展开文本会始终按原格式直接复制，不做大小写转换；若值为 <code>case-replace</code> （默认值），则由变量 <code>case-replace</code> 决定是否直接原格式复制展开文本（参见「<a href="#Replacement-and-Lax-Matches">替换命令与宽松匹配</a>」章节）。
</p>

<p>
但如果匹配到的展开文本本身包含 <b>复杂的混合大小写格式</b> ，且待展开的动态缩写在已输入范围内与该大小写格式完全匹配，那么无论上述变量如何设置，展开文本都会 <b>始终按原格式直接复制</b> 。例如，若缓冲区中存在文本 <code>variableWithSillyCasePattern</code> ，当你输入 <code>v a M-/</code> 时，展开后的文本会完整保留原有的大小写格式。
</p>

<p>
变量 <code>dabbrev-abbrev-char-regexp</code> （若非nil）用于定义动态缩写展开中 <b>被视为单词组成部分的字符</b> ，该正则表达式必须仅匹配单个字符，不可匹配多个字符；同时，该正则表达式也会决定哪些字符可作为展开文本的组成部分。该变量的默认值为 <code>nil</code> ，具有特殊含义：动态缩写（即光标处的待展开词汇）仅由 <b>单词字符</b> 构成，但搜索展开文本时，会匹配由 <b>单词字符和符号字符</b> 组成的序列。该默认规则通常适用于程序源码中的符号展开，也适用于多种语言的自然可读文本，但对于包含特殊标点字符的文本缓冲区可能并不适用；此种情况下，将该变量值设为 <code>"\\sw"</code> 可能会得到更理想的效果。
</p>

<p>
在 Shell 脚本和 Makefile 文件中，变量名有时会带 '<code>$</code>' 前缀，有时则不带。针对这类文本的主模式，可通过设置变量 <code>dabbrev-abbrev-skip-leading-regexp</code> ，让动态缩写展开支持 <b>忽略可选的前缀字符</b> 。该变量的值应为一个正则表达式，用于匹配动态缩写展开时需要忽略的可选前缀；默认值为 <code>nil</code> ，表示不忽略任何字符。
</p>
</div>
</div>
</section>
<section id="outline-container-Dired" class="outline-2">
<h2 id="Dired"><span class="section-number-2">32.</span> 目录编辑器（Dired）</h2>
<div class="outline-text-2" id="text-Dired">
<p>
Dired 功能会在 Emacs 中创建一个缓冲区，显示某个目录的文件列表，也可按需显示其部分子目录的内容。你可以使用 Emacs 常规命令在该缓冲区中移动，还能通过 Dired 专属命令对列表中的文件执行操作。Dired 同时支持本地目录和远程目录的操作。
</p>

<p>
Dired 缓冲区默认处于只读状态，不允许插入文本（不过 Wdired mode 支持编辑该缓冲区，详见「<a href="#Wdired">编辑 Dired 缓冲区</a>」）。 <code>d</code> 、 <code>x</code> 这类普通的可打印字符，在 Dired 中会被重新定义为专属命令。部分 Dired 命令会为当前行对应的文件（即 <b><i>current file当前文件</i></b> ）添加 <i>mark标记</i> 或 <i>flag标记标识</i> ；另有一些命令则会对带标记的文件或带标识的文件执行批量操作。你可先为目标文件添加标记，再通过单个命令对所有标记文件执行统一操作。
</p>

<p>
Dired-X 扩展包为 Dired 模式提供了各类额外功能，详见《Dired 扩展用户手册》中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/dired-x/index.html#Top">Dired-X</a> 相关章节。
</p>

<p>
你也可以使用 <code>C-x C-d</code> (<code>list-directory</code>) 查看目录的文件列表，该命令与 Dired 不同，无法对列出的文件执行后续操作，详见「<a href="#Directories">文件目录</a>」章节。
</p>

<ul class="org-ul">
<li><a href="#Dired-Enter">进入 Dired</a></li>
<li><a href="#Dired-Navigation">Dired 缓冲区中的导航</a></li>
<li><a href="#Dired-Deletion">用 Dired 删除文件</a></li>
<li><a href="#Flagging-Many-Files">批量标记多个文件</a></li>
<li><a href="#Dired-Visiting">在目录编辑器中打开文件</a></li>
<li><a href="#Marks-vs-Flags">Dired 中的标记与标记符</a></li>
<li><a href="#Operating-on-Files">对文件执行操作</a></li>
<li><a href="#Shell-Commands-in-Dired">Dired 中的 Shell 命令</a></li>
<li><a href="#Shell-Command-Guessing">Shell 命令自动推测</a></li>
<li><a href="#Transforming-File-Names">Dired 中的文件名转换</a></li>
<li><a href="#Comparison-in-Dired">通过 Dired 对比文件</a></li>
<li><a href="#Subdirectories-in-Dired">Dired 中的子目录操作</a></li>
<li><a href="#Subdir-Switches">Dired 中的子目录切换</a></li>
<li><a href="#Subdirectory-Motion">遍历子目录</a></li>
<li><a href="#Hiding-Subdirectories">隐藏子目录</a></li>
<li><a href="#Dired-Updating">更新 Dired 缓冲区</a></li>
<li><a href="#Dired-and-Find">Dired 与 find 命令</a></li>
<li><a href="#Wdired">编辑 Dired 缓冲区</a></li>
<li><a href="#Image_002dDired">在 Dired 中查看图片缩略图</a></li>
<li><a href="#Misc-Dired-Features">Dired 的其他功能</a></li>
</ul>
</div>
<div id="outline-container-Dired-Enter" class="outline-3">
<h3 id="Dired-Enter"><span class="section-number-3">32.1.</span> 进入 Dired</h3>
<div class="outline-text-3" id="text-Dired-Enter">
<p>
启动 Dired，请按 <code>C-x d</code> (<code>dired</code>) 。该命令会通过迷你缓冲区读取一个目录名，并打开一个 <i>Dired 缓冲区</i> ，列出该目录下的文件。你也可以在迷你缓冲区中输入通配符文件名模式，此时 Dired 缓冲区会列出所有匹配该模式的文件。通配符也可以出现在目录部分，例如：
</p>

<div class="org-src-container">
<pre class="src src-shell">C-x d  ~/foo/*.el  RET
C-x d  ~/foo/*/*.el  RET
</pre>
</div>

<p>
前者列出目录 'foo' 下所有后缀为 '.el' 的文件。后者列出 'foo' 下所有一级子目录中后缀为 '.el' 的文件。
</p>

<p>
在 POSIX 系统上，如果系统 Shell 支持 <i>globstar</i> （递归通配功能）且已启用，你可以在 Dired 中使用递归通配：
</p>

<div class="org-src-container">
<pre class="src src-shell">C-x d ~/foo/**/*.el RET
</pre>
</div>

<p>
该命令会递归遍历 'foo' 下所有子目录，列出所有 '.el' 文件。注意：不同 Shell 对通配功能的实现略有差异，请查阅你的 Shell 手册确认具体行为。
</p>

<p>
如果 Shell 支持 globstar 但默认未启用，你仍可以让 Dired 使用该功能：
</p>
<ul class="org-ul">
<li>将变量 <code>dired-maybe-use-globstar</code> 设为非 nil，Dired 会为它已知的 Shell 自动开启 globstar（支持的 Shell 列表见 <code>dired-enable-globstar-in-shell</code> ）。</li>
</ul>

<p>
你可以在迷你缓冲区中使用常规的历史记录与补全命令；特别地， <code>M-n</code> 会将当前已访问文件的文件名（如果有）填入迷你缓冲区（见 “<a href="#Minibuffer-History">迷你缓冲区历史</a>”）。
</p>

<p>
你也可以直接给 <code>C-x C-f</code> (<code>find-file</code>) 传入一个目录名，来启动 Dired。
</p>

<p>
按 <code>C-x C-j</code> (<code>dired-jump</code>) ，可以让 Emacs 对任意缓冲区的 <code>default-directory</code> （<a href="#File-Names">当前目录</a>）打开 Dired。
</p>
<ul class="org-ul">
<li>如果该缓冲区关联着一个文件，此命令会在打开的 Dired 缓冲区中把光标定位到该文件所在行。</li>
<li>否则光标会停在目录列表的第一个文件上。</li>
<li>一个例外：如果你在 Dired 缓冲区中按 <code>C-x C-j</code> ，Emacs 会显示上级目录的列表，并将光标定位到你刚才所在的目录那一行。</li>
<li>按 <code>C-x 4 C-j</code> (<code>dired-jump-other-window</code>) 效果相同，但会在新窗口中显示 Dired 缓冲区。</li>
</ul>

<p>
变量 <code>dired-listing-switches</code> 用于指定传给 <code>ls</code> 命令的目录列表参数；这个字符串必须包含 '-l' 。如果你给 <code>dired</code> 命令加前缀参数，可以在输入目录前，通过迷你缓冲区另行指定 <code>ls</code> 参数。无论以哪种方式指定，ls 参数都可以包含：
</p>
<ul class="org-ul">
<li>无需参数的短选项（单个字符）</li>
<li>以 '<code>--</code>' 开头、用 '=' 指定参数的长选项。</li>
</ul>

<p>
Dired 对文件名中包含换行符的文件支持不佳。如果你有很多这类文件，可以考虑在 <code>dired-listing-switches</code> 中加入 '-b'，它会对所有特殊字符转义，让 Dired 能更好地处理这些文件名。（你也可以临时用 <code>C-u C-x d</code> 加上 '-b'。）
</p>

<p>
<code>dired-listing-switches</code> 可以声明为连接局部变量，以便适配远程系统的要求（见 “<a href="#Connection-Variables">按连接局部变量</a>”）。
</p>

<p>
Dired 会在模式行中显示调用 <code>ls</code> 时使用的参数。默认情况下，Dired 会尝试判断参数是按文件名还是按日期排序，并在模式行中显示。
</p>

<ul class="org-ul">
<li>如果变量 <code>dired-switches-in-mode-line</code> 设为 <code>as-is</code> ，会原样显示参数。</li>
<li>如果值是一个整数，参数显示会被截断到该长度。</li>
<li>该变量也可以是一个函数：会以 <code>dired-actual-switches</code> 为唯一参数调用，并返回要在模式行显示的字符串。</li>
</ul>

<p>
如果你的 <code>ls</code> 程序支持 '<code>--dired</code>' 选项，Dired 会自动传入该选项。它让 ls 对某些特殊文件名输出特殊转义序列，否则 Dired 无法正确解析这些文件名。
</p>

<p>
在一个 Emacs 会话中第一次运行 Dired 时，它会带 '<code>--dired</code>' 选项调用一次 ls 以检测支持：
</p>
<ul class="org-ul">
<li>退出码为 0，则后续都使用 '<code>--dired</code>' 。</li>
<li>否则不使用。</li>
</ul>

<p>
你可以通过自定义变量 <code>dired-use-ls-dired</code> 禁用这一检测：
</p>
<ul class="org-ul">
<li><code>unspecified</code> （默认）：执行检测</li>
<li>其他非 nil 值：直接使用 '<code>--dired</code>'</li>
<li><code>nil</code> ：不使用 '<code>--dired</code>'</li>
</ul>

<p>
在 MS-Windows、MS-DOS 以及部分远程系统上，Emacs 会自行模拟 <code>ls</code> 命令。相关选项与特性见 “<a href="#ls-in-Lisp">MS-Windows 上的 ls 模拟</a>”。
</p>

<p>
要在另一个窗口显示 Dired 缓冲区，使用： <code>C-x 4 d</code> (<code>dired-other-window</code>) 。要在另一个独立框架显示： <code>C-x 5 d</code> (<code>dired-other-frame</code>)
</p>

<p>
按 <code>q</code> (<code>quit-window</code>) 会隐藏 Dired 缓冲区；如果该窗口是专门为它新建的，会直接关闭该窗口。
</p>
</div>
</div>
<div id="outline-container-Dired-Navigation" class="outline-3">
<h3 id="Dired-Navigation"><span class="section-number-3">32.2.</span> Dired 缓冲区中的导航</h3>
<div class="outline-text-3" id="text-Dired-Navigation">
<p>
Dired 缓冲区中可以使用所有常规的 Emacs 光标移动命令。按键 <code>C-n</code> 和 <code>C-p</code> 被分别重新定义为 <code>dired-next-line</code> 和 <code>dired-previous-line</code> ，它们会将光标定位到 <b>该行文件名的开头</b> ，而不是整行的开头。
</p>

<p>
为更方便使用，Dired 中的 <code>SPC</code> 和 <code>n</code> 等同于 <code>C-n</code> ， <code>p</code> 等同于 <code>C-p</code> 。（在行之间移动在 Dired 中非常常用，值得设置成易按的键。） <code>DEL</code> （向上移动并取消标记）通常也可简单用于向上移动（见 “<a href="#Dired-Deletion">使用 Dired 删除文件</a>”）。
</p>

<p>
<code>j</code> (<code>dired-goto-file</code>) 通过迷你缓冲区提示输入文件名，并将光标移动到 Dired 缓冲区中描述该文件的那一行。
</p>

<p>
<code>M-s f C-s</code> (<code>dired-isearch-filenames</code>) 在 Dired 缓冲区中执行向前增量搜索， <b>只在文件名中匹配</b> ，忽略缓冲区中的其他文本。 <code>M-s f M-C-s</code> (<code>dired-isearch-filenames-regexp</code>) 功能相同，但使用正则表达式搜索。如果将变量 <code>dired-isearch-filenames</code> 设为 <code>t</code> ，那么普通搜索命令也会只在文件名中搜索；例如 <code>C-s</code> 会和 <code>M-s f C-s</code> 行为一致。如果值为 <code>dwim</code> ，则只有当光标原本就在文件名上时，搜索命令才只匹配文件名。有关增量搜索的说明，见 “<a href="#Search">搜索与替换</a>”。
</p>

<p>
当 Dired 缓冲区包含多个目录时，还可以使用一些额外的导航命令。见 “<a href="#Subdirectory-Motion">遍历子目录</a>”。
</p>
</div>
</div>
<div id="outline-container-Dired-Deletion" class="outline-3">
<h3 id="Dired-Deletion"><span class="section-number-3">32.3.</span> 用 Dired 删除文件</h3>
<div class="outline-text-3" id="text-Dired-Deletion">
<p>
Dired 最常见的用法之一是：先把文件 <b><i>flag标记</i> 为待删除</b> ，再一次性删除所有被标记的文件。
</p>

<dl class="org-dl">
<dt><code>d</code></dt><dd>将当前文件标记为待删除 (<code>dired-flag-file-deletion</code>) 。</dd>
<dt><code>u</code></dt><dd>取消删除标记 (<code>dired-unmark</code>) 。</dd>
<dt><code>DEL</code></dt><dd>光标移到上一行，并取消该行的删除标记 (<code>dired-unmark-backward</code>) 。</dd>
<dt><code>x</code></dt><dd>删除所有标记为待删除的文件 (<code>dired-do-flagged-delete</code>) 。</dd>
</dl>

<p>
你可以将光标移到对应文件行，按 <code>d</code> 为文件打上删除标记。删除标记会在行首以 'D' 显示。该命令会自动将光标移到下一行，因此连续按 <code>d</code> 可以依次标记多个文件。数字前缀参数表示重复次数；负数表示标记前面的文件。
</p>

<p>
如果选区已激活， <code>d</code> 会标记选区中的所有文件，此时不移动光标，也忽略前缀参数。
</p>

<p>
先标记再删除，而不是直接删除，是为了降低误删风险。在按 <code>x</code> 执行删除前，你可以用 <code>u</code> 或 <code>DEL</code> 取消标记。 <code>u</code> 与 <code>d</code> 操作类似，只是取消标记而非添加标记。 <code>DEL</code> 向上移动并取消标记，相当于带参数 −1 的 <code>u</code> 。这两个命令的数字前缀同样表示次数，负数表示反向操作。若选区激活，则直接取消选区内所有文件的标记，不移动光标。
</p>

<p>
要真正删除已标记的文件，按 <code>x</code> (<code>dired-do-flagged-delete</code>) 。该命令会显示所有待删文件列表，并要求输入 <code>yes</code> 确认。确认后，Dired 会删除这些文件，并从 Dired 缓冲区中移除对应行，缓冲区保持打开。
</p>

<p>
如果你回答 <code>no</code> 或用 <code>C-g</code> 退出确认，将直接回到 Dired，所有删除标记保留，文件不会被删除。
</p>

<p>
你可以像普通文件一样删除空目录，但默认 Dired 不能删除非空目录。如果将变量 <code>dired-recursive-deletes</code> 设为非 nil，Dired 允许递归删除非空目录及其所有内容，这有一定风险。如果设为 <code>always</code> ，则无条件递归删除非空目录，风险更高。
</p>

<p>
即使你将 <code>dired-recursive-deletes</code> 设为 nil，有时也可能想一次性递归删除多个目录而不想逐个确认。当你标记了多个目录并确定可以安全删除时，对每个非空目录的删除确认，你可以回答 <code>all</code> ，之后所有剩余目录将不再询问直接删除。
</p>

<p>
如果将变量 <code>delete-by-moving-to-trash</code> 设为 <code>t</code> ，上述删除命令会把文件或目录 <b>移到系统回收站</b> ，而不是直接永久删除。详见 “<a href="#Misc-File-Ops">杂项文件操作</a>”。
</p>

<p>
另一种删除方式：先用 <code>m</code> 标记文件，再用 <code>D</code> 删除，见 “<a href="#Operating-on-Files">对文件执行操作</a>”。
</p>
</div>
</div>
<div id="outline-container-Flagging-Many-Files" class="outline-3">
<h3 id="Flagging-Many-Files"><span class="section-number-3">32.4.</span> 批量标记多个文件</h3>
<div class="outline-text-3" id="text-Flagging-Many-Files">
<p>
<code>#</code> 、 <code>~</code> 、 <code>.</code> 、 <code>% &amp;</code> 和 <code>% d</code> 命令可以根据文件名一次性标记多个文件以待删除：
</p>

<dl class="org-dl">
<dt><code>#</code></dt><dd>标记所有自动保存文件（文件名以 '#' 开头和结尾的文件）以待删除（见 “<a href="#Auto-Save">自动保存：防止意外丢失</a>”）。</dd>
<dt><code>~</code></dt><dd>标记所有备份文件（文件名以 '~' 结尾的文件）以待删除（见 “<a href="#Backup">备份文件</a>”）。</dd>
<dt><code>.</code> （句号）</dt><dd>标记多余的数字编号备份文件以待删除。每个文件的最新几个和最旧几个备份会被保留，中间的备份会被标记。</dd>
<dt><code>% &amp;</code></dt><dd>标记那些文件名表明可以轻松重新生成的文件以待删除。</dd>
<dt><code>% d regexp RET</code></dt><dd>标记所有文件名匹配指定正则表达式的文件以待删除。</dd>
</dl>

<p>
<code>#</code> (<code>dired-flag-auto-save-files</code>) 标记所有文件名看起来是自动保存文件的文件 —— 即文件名以 '#' 开头和结尾的文件。（见 “<a href="#Auto-Save">自动保存：防止意外丢失</a>”）
</p>

<p>
<code>~</code> (<code>dired-flag-backup-files</code>) 标记所有文件名表明是备份文件的文件 —— 即文件名以 ~ 结尾的文件。（见 “<a href="#Backup">备份文件</a>”）
</p>

<p>
<code>.</code> (句号， <code>dired-clean-directory</code>) 只标记部分备份文件：每个文件除了最新几个和最旧几个版本之外的备份都会被标记。通常，每个文件保留的最新版本数量由变量 <code>dired-kept-versions</code> 决定（而非 <code>kept-new-versions</code> ，后者只在保存时生效）。保留的最旧版本数量由变量 <code>kept-old-versions</code> 决定。
</p>

<p>
带正数字参数的句号命令，例如 <code>C-u 3 .</code> ，会指定保留的最新版本数量，覆盖 <code>dired-kept-versions</code> 。带负数字参数会覆盖 <code>kept-old-versions</code> ，用参数的绝对值指定每个文件保留的最旧版本数量。
</p>

<p>
<code>% &amp;</code> (<code>dired-flag-garbage-files</code>) 标记文件名匹配变量 <code>dired-garbage-files-regexp</code> 所指定正则表达式的文件。默认情况下，它匹配 TeX 生成的某些文件、'.bak' 文件，以及 patch 生成的 '.orig' 和 '.rej' 文件。
</p>

<p>
<code>% d</code> (<code>dired-flag-files-regexp</code>) 标记所有文件名匹配指定正则表达式的文件。匹配时只使用文件名中的非目录部分。你可以用 '<code>^</code>' 和 '<code>$</code>' 限定匹配首尾。在使用 <code>% d</code> 时，你可以通过隐藏子目录来避免它们被标记。见 “<a href="#Hiding-Subdirectories">隐藏子目录</a>”。
</p>
</div>
</div>
<div id="outline-container-Dired-Visiting" class="outline-3">
<h3 id="Dired-Visiting"><span class="section-number-3">32.5.</span> 在目录编辑器中打开文件</h3>
<div class="outline-text-3" id="text-Dired-Visiting">
<p>
Dired 提供多条命令用于访问或查看 Dired 缓冲区中列出的文件。所有这些命令都作用于当前行对应的文件；如果该文件实际是一个目录，这些命令会对该子目录启动 Dired（新建一个独立的 Dired 缓冲区）。
</p>

<dl class="org-dl">
<dt><code>f</code></dt><dd>访问当前行所描述的文件，效果等同于输入 <code>C-x C-f</code> 并指定该文件名 (<code>dired-find-file</code>) 。参见 “<a href="#Visiting">访问文件</a>”。</dd>
<dt><code>RET</code></dt><dd></dd>

<dt><code>e</code></dt><dd>与 f 等效。</dd>
<dt><code>o</code></dt><dd>与 f 类似，但在另一个窗口中显示文件缓冲区 (<code>dired-find-file-other-window</code>) 。Dired 缓冲区仍在原窗口可见，类似于使用 <code>C-x 4 C-f</code> 访问文件。参见 “<a href="#Windows">多窗口</a>”。</dd>
<dt><code>C-o</code></dt><dd>访问当前行所描述的文件，并在另一个窗口显示其缓冲区，但不激活该窗口 (<code>dired-display-file</code>) 。</dd>
<dt><code>mouse-1</code></dt><dd></dd>

<dt><code>mouse-2</code></dt><dd>访问你点击的文件 (<code>dired-mouse-find-file-other-window</code>) ，会在另一个窗口打开，与 <code>o</code> 命令类似。</dd>
<dt><code>v</code></dt><dd>以 <b>查看模式（View mode）</b> 查看当前行对应的文件 (<code>dired-view-file</code>) 。查看模式提供方便的浏览命令，但禁止修改文件；参见 “<a href="#View-Mode">查看模式</a>”。</dd>
<dt><code>^</code></dt><dd>访问当前目录的上级目录 (<code>dired-up-directory</code>) 。等效于将光标移到 <code>..</code> 所在行并按 <code>f</code> 。</dd>

<dt>用户选项： <code>dired-kill-when-opening-new-dired-buffer</code></dt><dd>在 Dired 中访问新的子目录时，Emacs 默认会打开新缓冲区显示该目录，并保留旧的 Dired 缓冲区。如果此选项设为非 nil，则在进入新目录后会关闭旧的 Dired 缓冲区。这样在遍历目录结构时，始终只会保留一个 Dired 缓冲区。</dd>
</dl>
</div>
</div>
<div id="outline-container-Marks-vs-Flags" class="outline-3">
<h3 id="Marks-vs-Flags"><span class="section-number-3">32.6.</span> Dired 中的标记与标记符</h3>
<div class="outline-text-3" id="text-Marks-vs-Flags">
<p>
除了用 'D' 为文件做删除标识外，你还可以用其他字符（通常是 '<code>*</code>'）为文件做 <b><i>mark标记</i></b> 。大多数用于操作文件的 Dired 命令，都是对带 '<code>*</code>' 标记的文件生效；唯一对带 'D' 标识文件生效的命令是 <code>x</code> ，用于删除它们。
</p>

<p>
下面是用于添加 '<code>*</code>' 标记、取消标记以及操作标记的命令。（用于添加和取消删除标识的命令，见 “<a href="#Dired-Deletion">使用 Dired 删除文件</a>”。）
</p>

<dl class="org-dl">
<dt><code>m</code></dt><dd></dd>

<dt><code>* m</code></dt><dd>用 '<code>*</code>' 标记当前文件 (<code>dired-mark</code>)。如果选区已激活，则标记选区中的所有文件；否则，如果提供了数字参数 <code>n</code> ，则从当前文件开始，标记后面的 <code>n</code> 个文件（ <code>n</code> 为负时标记前面的 <code>-n</code> 个文件）。如果在子目录标题行上执行此命令，会标记该子目录下的所有文件。</dd>
<dt><code>* N</code></dt><dd>显示已标记文件的数量与总大小信息 (<code>dired-number-of-marked-files</code>) 。</dd>
<dt><code>* *</code></dt><dd>用 '*' 标记所有可执行文件 (<code>dired-mark-executables</code>)。带数字参数时则取消这些文件的标记。</dd>
<dt><code>* @</code></dt><dd>用 '*' 标记所有符号链接 (<code>dired-mark-symlinks</code>) 。带数字参数时则取消这些文件的标记。</dd>
<dt><code>* /</code></dt><dd>用 '*' 标记所有目录（=.= 和 <code>..</code> 除外） (<code>dired-mark-directories</code>) 。带数字参数时则取消这些目录的标记。</dd>
<dt><code>* s</code></dt><dd>标记当前子目录内除 <code>.</code> 和 <code>..</code> 之外的所有文件 (<code>dired-mark-subdir-files</code>)。</dd>
<dt>u=</dt><dd></dd>

<dt><code>* u</code></dt><dd>取消当前行的标记 (<code>dired-unmark</code>) 。如果选区已激活，则取消选区中所有文件的标记；否则，如果提供了数字参数 n，则从当前文件开始，取消后面 n 个文件的标记（n 为负时取消前面 -n 个文件）。</dd>
<dt><code>DEL</code></dt><dd></dd>

<dt><code>* DEL</code></dt><dd>光标移到上一行，并取消该行的标记 (<code>dired-unmark-backward</code>) 。如果选区已激活，则取消选区中所有文件的标记；否则，如果提供了数字参数 n，则从当前文件开始，取消前面 n 个文件的标记（n 为负时取消后面 -n 个文件）。</dd>
<dt><code>* !</code></dt><dd></dd>

<dt><code>U</code></dt><dd>取消当前 Dired 缓冲区中所有文件的所有标记 (<code>dired-unmark-all-marks</code>) 。</dd>
<dt><code>* ? markchar</code></dt><dd></dd>

<dt><code>M-DEL</code></dt><dd><p>
取消所有使用指定标记字符的标记 (<code>dired-unmark-all-files</code>) 。使用 <code>M-DEL</code> 时，命令会提示输入标记字符。标记字符为单个字符，不要用回车结束。（可通过下面介绍的 <code>* c</code> 命令，将一种标记字符替换为另一种。）
</p>

<p>
带数字参数时，该命令会逐个询问是否取消标记： <code>y</code> 确认取消; <code>n</code> 不取消; <code>!</code> 对剩余文件直接全部取消。
</p></dd>
<dt><code>* C-n</code></dt><dd></dd>

<dt><code>M-}</code></dt><dd>向下跳转到下一个带标记的文件 (<code>dired-next-marked-file</code>) 。只要文件带有任意类型的标记，就算作 “marked已标记”。</dd>
<dt><code>* C-p</code></dt><dd></dd>

<dt><code>M-{</code></dt><dd>向上跳转到上一个带标记的文件 (<code>dired-prev-marked-file</code>) 。</dd>
<dt><code>t</code></dt><dd></dd>

<dt><code>* t</code></dt><dd>反转所有 '<code>*</code>' 标记 (<code>dired-toggle-marks</code>) ：带 '<code>*</code>' 的文件取消标记，不带 '<code>*</code>' 的文件加上 '<code>*</code>' 。以其他方式标记的文件不受影响。</dd>
<dt><code>* c old-markchar new-markchar</code></dt><dd><p>
将所有使用 <i>old-markchar旧标记字符</i> 的标记，替换为 <i>new-markchar新标记字符</i> (<code>dired-change-marks</code>) 。这是创建和使用 '<code>*</code>' 、 '<code>D</code>' 以外标记的主要方式。参数均为单个字符，不要用回车结束。
</p>

<p>
你几乎可以用任意字符作为标记字符，以区分不同类别的文件。
</p>
<ul class="org-ul">
<li>如果 <i>old-markchar旧标记字符</i> 是空格（' '），则对所有未标记文件执行操作；</li>
<li>如果 <i>new-markchar新标记字符</i> 是空格，则会取消对应文件的标记。</li>
</ul>

<p>
举例说明该命令的用法，下面这组按键可以：
</p>
<ul class="org-ul">
<li>给所有无标记文件打上 'D' 删除标识; 同时取消所有已有 'D' 标识的文件</li>
</ul>

<div class="org-src-container">
<pre class="src src-shell">* c D t  * c SPC D  * c t SPC
</pre>
</div>
<p>
前提是没有文件已使用 't' 作为标记。
</p></dd>
<dt><code>% m regexp RET</code></dt><dd></dd>

<dt><code>* % regexp RET</code></dt><dd><p>
用 '<code>*</code>' 标记所有文件名匹配指定正则表达式的文件 (<code>dired-mark-files-regexp</code>) 。该命令与 <code>% d</code> 类似，区别是用 '<code>*</code>' 标记，而不是用 '<code>D</code>' 标识。
</p>

<p>
匹配时只使用文件名中的非目录部分。可用 '<code>^</code>' 和 '<code>$</code>' 限定首尾。可以临时隐藏子目录，避免它们被标记（见 “<a href="#Hiding-Subdirectories">隐藏子目录</a>”）。
</p></dd>
<dt><code>% g regexp RET</code></dt><dd><p>
用 '<code>*</code>' 标记所有文件内容匹配该正则表达式的文件 (<code>dired-mark-files-containing-regexp</code>) 。与 <code>% m</code> 类似，区别是搜索文件内容而非文件名。
</p>

<p>
注意：如果文件已在 Emacs 缓冲区中打开，且 <code>dired-always-read-filesystem</code> 为 <code>nil</code> （默认），该命令会直接读取缓冲区内容，而不是重新读取磁盘文件。如果文件已被修改但未保存，结果可能与磁盘实际内容不一致。若要避免此问题，可以先恢复文件，或在对应缓冲区开启自动恢复模式。如果希望该命令始终重新读取磁盘文件，可将 <code>dired-always-read-filesystem</code> 设为非 nil。
</p></dd>
<dt><code>C-/</code></dt><dd></dd>

<dt><code>C-x u</code></dt><dd></dd>

<dt><code>C-_</code></dt><dd><p>
撤销 Dired 缓冲区中的操作，例如添加或取消标记 (<code>dired-undo</code>) 。该命令不会撤销实际的文件操作，也无法恢复 <i>lost files已丢失的文件</i> ！它只撤销缓冲区本身里的改动。
</p>

<p>
在某些对文件执行过实际操作的命令之后使用撤销可能会导致不同步。例如重命名文件后再撤销，会使 Dired 缓冲区里的文件名与磁盘实际目录不一致。
</p></dd>
<dt><code>touchscreen-hold</code></dt><dd><p>
进入 “点击选择” 模式：在文件名上按下鼠标按键 <code>mouse‑2</code> 会切换该文件的标记状态。在使用触屏设备进行文件管理时，该模式非常实用。
</p>

<p>
当在文件名上检测到 “hold长按” 手势时（参见《<a href="#Touchscreens">在触屏上使用 Emacs</a>》），此模式会自动启用；一旦对标记文件执行任意 Dired 命令，该模式便会自动关闭。
</p></dd>
</dl>
</div>
</div>
<div id="outline-container-Operating-on-Files" class="outline-3">
<h3 id="Operating-on-Files"><span class="section-number-3">32.7.</span> 对文件执行操作</h3>
<div class="outline-text-3" id="text-Operating-on-Files">
<p>
本节介绍用于操作单个或多个文件的基本 Dired 命令。所有这些命令均为 <b>大写字母</b> ；执行操作前，它们都会使用迷你缓冲区（minibuffer）读取参数或请求确认。它们都允许通过以下方式指定要操作的文件：
</p>
<ul class="org-ul">
<li>如果给命令一个数字前缀参数 <code>n</code> ，则从当前文件开始，对接下来的 <code>n</code> 个文件执行操作。（如果 <code>n</code> 为负数，则对当前行前面的 <code>−n</code> 个文件执行操作。）</li>
<li>否则，如果有文件被标记为 '<code>*</code>' ，则命令对所有这些标记文件执行操作。</li>
<li>否则，命令只对当前文件执行操作。</li>
</ul>

<p>
其他一些 Dired 命令（如 <code>!</code> 和以 '%' 开头的命令）也遵循相同规则来确定操作对象。
</p>

<p>
除本节介绍的 Dired 命令外，你还可以对 Dired 缓冲区中显示的一个或多个文件执行 <b>版本控制（VC）</b> 命令。参见：<a href="#Version-Control">版本控制</a>。
</p>

<p>
需要目标目录的命令（如复制、重命名文件或创建链接）会尝试自动推测默认目标目录。通常它们会使用当前 Dired 缓冲区的默认目录；但如果选项 <code>dired-dwim-target</code> 非 nil，且某个窗口中显示了另一个 Dired 缓冲区，则会改用该缓冲区的目录作为建议。
</p>

<p>
你可以自定义 <code>dired-dwim-target</code> ，使其优先选择：
</p>
<ul class="org-ul">
<li>下一个显示 Dired 缓冲区的窗口</li>
<li>最近使用的显示 Dired 缓冲区的窗口</li>
<li>或任意其他函数。当值为函数时，该函数将无参调用，并返回一个目录列表，用作默认值（即默认目标与 “历史记录”）。</li>
</ul>

<p>
以下是用于文件操作的 Dired 命令。
</p>

<dl class="org-dl">
<dt><code>C new RET</code></dt><dd><p>
复制指定文件 (<code>dired-do-copy</code>) 。参数 <i>new</i> 是目标目录；若只复制单个文件，也可以是新文件名。效果类似 Shell 命令 cp。
</p>

<p>
选项 <code>dired-create-destination-dirs</code> 控制在复制 / 重命名时，是否自动创建不存在的目标目录：
</p>
<ul class="org-ul">
<li>默认值 <code>nil</code> ：从不创建</li>
<li>值为 <code>always</code> ：自动创建</li>
<li>值为 <code>ask</code> ：创建前询问确认</li>
</ul>

<p>
如果同时开启 <code>dired-create-destination-dirs-on-trailing-dirsep</code> ，则目标路径末尾的目录分隔符会被特殊处理。例如复制到 'test/' 而 'test' 不存在时，会先创建 'test' 目录，再将源文件 / 目录复制进去。
</p>

<p>
如果 <code>dired-copy-preserve-time</code> 非 nil，复制时会保留原文件的修改时间，类似 '<code>cp -p</code>' 。
</p>

<p>
变量 <code>dired-recursive-copies</code> 控制是否递归复制目录（类似 '<code>cp -r</code>' ）。默认值 <code>top</code> 表示递归复制目录前会询问。
</p>

<p>
变量 <code>dired-copy-dereference</code> 控制符号链接是原样复制还是解引用后复制（类似 '<code>cp -L</code>' ）。默认 <code>nil</code> ，表示新建符号链接进行复制。
</p>

<p>
用户选项 <code>dired-keep-marker-copy</code> 控制此命令如何处理文件标记。默认会给所有新复制的文件打上 'C' 标记。
</p></dd>

<dt><code>D</code></dt><dd><p>
删除指定文件 (<code>dired-do-delete</code>) 。类似 Shell 命令 <code>rm</code> 。
</p>

<p>
与本节其他命令一样，作用于标记文件或接下来 <code>n</code> 个文件。与之相对， <code>x</code> (<code>dired-do-flagged-delete</code>) 删除所有 <b>标记位（flagged）</b> 文件。
</p></dd>

<dt><code>E</code></dt><dd>使用外部程序 “打开” 指定文件 (<code>dired-do-open</code>) 。程序按系统惯例选择，由变量 <code>shell-command-guess-open</code> 决定。</dd>

<dt><code>R new RET</code></dt><dd><p>
重命名指定文件 (<code>dired-do-rename</code>) 。
</p>
<ul class="org-ul">
<li>重命名单个文件时， <i>new</i> 是新文件名。</li>
<li>重命名多个文件时， <i>new</i> 是目标目录（类似 Shell 命令 <code>mv</code> ）。</li>
</ul>

<p>
选项 <code>dired-create-destination-dirs</code> 控制是否在 <i>new</i> 中创建不存在的目录。
</p>

<p>
若同时设置 <code>dired-create-destination-dirs-on-trailing-dirsep</code> ，则目标路径末尾的目录分隔符会被特殊处理。例如将目录 'old' 重命名为 'new/' 而 'new' 不存在时，会先创建 'new' 目录，再将 'old' 移入；否则 'old' 会直接改名为 'new' 。
</p>

<p>
Dired 会自动更新与重命名文件关联的缓冲区的访问文件名，使其指向新名称。
</p>

<p>
如果变量 <code>dired-vc-rename-file</code> 非 nil，则会通过底层版本控制系统命令重命名文件，使用 <code>vc-rename-file</code> 。参见：<a href="#VC-Delete_002fRename">删除与重命名版本控制文件</a>。
</p></dd>

<dt><code>H new RET</code></dt><dd>为指定文件创建硬链接 (<code>dired-do-hardlink</code>) 。类似 Shell 命令 <code>ln</code> 。参数 <i>new</i> 是链接存放目录；若只创建一个链接，也可以是链接名。</dd>

<dt><code>S new RET</code></dt><dd>为指定文件创建符号链接 (<code>dired-do-symlink</code>) 。类似 '<code>ln -s</code>' 。参数 <i>new</i> 是链接存放目录；若只创建一个链接，也可以是链接名。</dd>

<dt><code>Y new RET</code></dt><dd><p>
为指定文件创建相对符号链接 (<code>dired-do-relsymlink</code>) 。参数 <i>new</i> 是链接存放目录；若只创建一个链接，也可以是链接名。与 <code>dired-do-symlink</code> 类似，但生成相对路径符号链接，例如：
</p>

<div class="org-src-container">
<pre class="src src-shell">foo -&gt; ../bar/foo
</pre>
</div>

<p>
而不是绝对路径：
</p>

<div class="org-src-container">
<pre class="src src-shell">foo -&gt; /path/that/may/change/any/day/bar/foo
</pre>
</div></dd>

<dt><code>M modespec RET</code></dt><dd>修改指定文件的权限位 (<i>permission bits</i>) (<code>dired-do-chmod</code>) 。 <i>modespec</i> 可以是八进制或符号表示法，与 <code>chmod</code> 程序参数格式一致。该命令不跟随符号链接，在符号链接权限不可修改的平台上会报错。</dd>

<dt><code>G newgroup RET</code></dt><dd>将指定文件的所属组改为 <i>newgroup</i>  (<code>dired-do-chgrp</code>) 。</dd>

<dt><code>O newowner RET</code></dt><dd><p>
将指定文件的所有者改为 <i>newowner</i> (<code>dired-do-chown</code>) 。（大多数系统上只有超级用户可执行。）
</p>

<p>
变量 <code>dired-chown-program</code> 指定实际执行的程序名。（不同系统中 <code>chown</code> 位置不同，因此需要此变量。）
</p></dd>

<dt><code>T timestamp RET</code></dt><dd>更新指定文件时间戳 (<code>dired-do-touch</code>) 。将修改时间更新为 <i>timestamp</i> ，默认为当前时间。类似 Shell 命令 <code>touch</code> 。</dd>

<dt><code>P command RET</code></dt><dd>打印指定文件 (<code>dired-do-print</code>) 。必须指定打印命令，小缓冲区会根据变量 <code>lpr-command</code> 和 <code>lpr-switches</code> 给出默认建议（与 <code>lpr-buffer</code> 使用相同变量）。参见：<a href="#Printing">打印硬拷贝</a>。</dd>

<dt><code>Z</code></dt><dd><p>
压缩指定文件 (<code>dired-do-compress</code>) 。若文件看起来已是压缩文件，则执行 <b>解压</b> 。每个标记文件单独压缩；优先使用 <code>gzip</code> ，否则用 <code>compress</code> 。
</p>

<p>
对目录执行此命令时，生成的压缩归档格式由用户选项 <code>dired-compress-directory-default-suffix</code> 控制。默认为 <code>.tar.gz</code> ，通过 <code>tar</code> 管道到 <code>gzip</code> 实现。对 <code>.tar.gz</code> 或 <code>.tgz</code> 文件按 <code>Z</code> 可解压到同名（去掉后缀）目录。
</p></dd>

<dt><code>c</code></dt><dd>将指定文件压缩为单个归档文件 (<code>dired-do-compress-to</code>) ，可存放在文件系统任意位置。默认归档格式由 <code>dired-compress-directory-default-suffix</code> 控制。另见 <code>dired-compress-files-alist</code> 。</dd>

<dt><code>:d</code></dt><dd>解密指定文件 (<code>epa-dired-do-decrypt</code>) 。参见：EasyPG 助手用户手册中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/epa/Dired-integration.html#Dired-integration">Dired 集成</a>。</dd>
<dt><code>:v</code></dt><dd>验证指定文件的数字签名 (<code>epa-dired-do-verify</code>) 。参见：EasyPG 助手用户手册中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/epa/Dired-integration.html#Dired-integration">Dired 集成</a>。</dd>
<dt><code>:s</code></dt><dd>对指定文件进行数字签名 (<code>epa-dired-do-sign</code>) 。参见：EasyPG 助手用户手册中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/epa/Dired-integration.html#Dired-integration">Dired 集成</a>。</dd>
<dt><code>:e</code></dt><dd>加密指定文件 (<code>epa-dired-do-encrypt</code>) 。参见：EasyPG 助手用户手册中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/epa/Dired-integration.html#Dired-integration">Dired 集成</a>。</dd>
<dt><code>L</code></dt><dd>加载指定的 Emacs Lisp 文件 (<code>dired-do-load</code>) 。参见：<a href="#Lisp-Libraries">Emacs Lisp 代码库</a>。</dd>
<dt><code>B</code></dt><dd>对指定的 Emacs Lisp 文件进行字节编译 (<code>dired-do-byte-compile</code>) 。参见：《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Byte-Compilation.html#Byte-Compilation">字节编译</a>。</dd>
<dt><code>I</code></dt><dd>对当前文件运行 Info（假定为 Info 格式文件）。</dd>
<dt><code>N</code></dt><dd>对当前文件运行 man（假定为 <code>nroff</code> 格式手册页文件）。</dd>
<dt><code>A regexp RET</code></dt><dd><p>
在所有指定文件中正则表达式搜索 <i>regexp</i> (<code>dired-do-find-regexp</code>) 。
</p>

<p>
该命令是 <code>xref-find-references</code> 的变体，会显示 <code>*xref*</code> 缓冲区，你可在其中浏览匹配项，并使用该缓冲区支持的命令按需显示。
</p>

<p>
如果标记文件中包含目录，此命令会递归搜索这些目录及其所有子目录中的文件，跳过名称匹配 <code>grep-find-ignored-files</code> 的文件和匹配 <code>grep-find-ignored-directories</code> 的目录。
</p></dd>

<dt><code>Q regexp RET to RET</code></dt><dd><p>
对每个指定文件执行正则表达式查询替换，将 <i>regexp</i> 替换为字符串 <i>to</i> (<code>dired-do-find-regexp-and-replace</code>) 。
</p>

<p>
该命令是 <code>xref-query-replace-in-results</code> 的变体。它会打开一个 <code>*xref*</code> 缓冲区，列出正则表达式的所有匹配项，你可以在该缓冲区中使用专用命令（参见 <a href="#Xref-Commands"> <code>*xref*</code> 缓冲区中的可用命令</a>）。特别地，如果你退出了查询替换循环，仍可在该缓冲区中按 <code>r</code> 继续替换更多匹配项。参见《<a href="#Identifier-Search">使用标识符进行搜索和替换</a>》。
</p>

<p>
与 <code>dired-do-find-regexp</code> 一样，如果被标记的文件中包含目录，此命令会递归地在这些目录及其所有子目录下的所有文件中执行替换，但会跳过名称匹配 <code>grep-find-ignored-files</code> 的文件，以及名称匹配 <code>grep-find-ignored-directories</code> 的子目录。
</p></dd>
</dl>
</div>
</div>
<div id="outline-container-Shell-Commands-in-Dired" class="outline-3">
<h3 id="Shell-Commands-in-Dired"><span class="section-number-3">32.8.</span> Dired 中的 Shell 命令</h3>
<div class="outline-text-3" id="text-Shell-Commands-in-Dired">
<p>
Dired 命令 <code>!</code> (<code>dired-do-shell-command</code>) 会在迷你缓冲区读取一条 Shell 命令字符串，并在一个或多个文件上执行该命令。Shell 命令操作的文件按照 Dired 命令的常规规则确定（见<a href="#Operating-on-Files">文件操作</a>）。命令 <code>X</code> 是 <code>!</code> 的别名。
</p>

<p>
命令 <code>&amp;</code> (<code>dired-do-async-shell-command</code>) 功能与之相同，区别在于它 <b>异步执行</b> Shell 命令。（你也可以在 <code>!</code> 的命令末尾加上 '<code>&amp;</code>' 实现异步。）当命令作用于多个文件时，会为每个文件并行启动一条独立的 Shell 命令。一个例外：如果指定的 Shell 命令以  '<code>;</code>' 或 '<code>;&amp;</code>' 结尾，则会在后台 <b>依次</b> 对每个文件执行命令；Emacs 会等待前一条命令结束后再执行下一条。
</p>

<p>
对于 <code>!</code> 和 <code>&amp;</code> ，Shell 命令的 <b>工作目录</b> 都是当前 Dired 缓冲区所在的顶层目录。
</p>

<p>
如果让 <code>!</code> 或 <code>&amp;</code> 操作多个文件，命令字符串的写法决定了文件如何传给 Shell 命令：
</p>
<ul class="org-ul">
<li><p>
如果命令字符串中使用被空白包围的 '<code>*</code>'， <b>命令只执行一次</b> ，并用文件列表替换 '<code>*</code>' 。文件名顺序与 Dired 缓冲区中的显示顺序一致。
</p>

<p>
例如： <code>! tar cf foo.tar * RET</code> 会把所有选中的文件打包进 <code>foo.tar</code> 。
</p>

<ul class="org-ul">
<li>如果你想把 '<code>*</code>' 当作普通 Shell 通配符（带空白），可以写成 “=*""<code>” 。在 Shell 中等价于 ‘*’ ，但因为 ’*’ 没有被空白单独包围，Dired 不会对其特殊处理。这样做时 Emacs 会要求确认，除非将 ~dired-confirm-shell-command~ 设为 =nil</code> 。</li>
</ul></li>
<li>否则，如果命令字符串包含被空白包围的 <code>?</code> 或 <code>`?`</code> ，Emacs 会 '<code>*</code>' 为每个文件单独执行一次 '<code>*</code>' 命令，每次用当前文件名替换 <code>?</code> 和 <code>`?`</code> 。一条命令中可多次使用 <code>?</code> 或 <code>`?`</code> ，都会被同一个文件名替换。如果与 '<code>*</code>' 混用会报错。</li>
<li>如果命令字符串中既没有 '<code>*</code>' ，也没有 <code>?</code> 和 <code>`?`</code> ，Emacs 仍会 <b>为每个文件执行一次</b> 命令，并把文件名追加到命令末尾。例如： <code>! uudecode RET</code> 会对每个文件执行 <code>uudecode</code> 。</li>
</ul>

<p>
如需以更复杂的方式遍历文件名，可以直接写 Shell 循环。例如，对每个文件执行 <code>uuencode</code> ，并以原文件名加 <code>.uu</code> 作为输出：
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #a020f0;">for</span> file<span style="color: #a020f0;"> in</span> * ; <span style="color: #a020f0;">do</span> uuencode <span style="color: #8b2252;">"$file"</span> <span style="color: #8b2252;">"$file"</span> &gt;<span style="color: #8b2252;">"$file"</span>.uu; <span style="color: #a020f0;">done</span>
</pre>
</div>

<p>
用 <code>`?`</code> 写法实现同样效果：
</p>

<div class="org-src-container">
<pre class="src src-shell">uuencode ? ? &gt; <span style="color: #ff00ff;">`?`</span>.uu
</pre>
</div>

<p>
<code>!</code> 和 <code>&amp;</code> 不会自动刷新 Dired 缓冲区来显示新增或修改的文件，因为它们无法预知会改动哪些文件。可使用 <code>g</code> 命令手动刷新 Dired 缓冲区（见<a href="#Dired-Updating">刷新 Dired 缓冲区</a>）。
</p>

<p>
关于在 Dired 之外执行 Shell 命令的信息，参见<a href="#Single-Shell">单条 Shell 命令</a>。
</p>
</div>
</div>
<div id="outline-container-Shell-Command-Guessing" class="outline-3">
<h3 id="Shell-Command-Guessing"><span class="section-number-3">32.9.</span> Shell 命令自动推测</h3>
<div class="outline-text-3" id="text-Shell-Command-Guessing">
<p>
Dired 会根据文件名，尝试推测你可能想要对它执行的 Shell 命令。例如，当光标位于名为 <code>foo.tar</code> 的文件上并按下 <code>!</code> 时，Dired 会推测你想执行 '<code>tar xvf</code>'，并将其作为默认 Shell 命令提示。
</p>

<p>
你可以按下 <code>M-n</code> 将默认命令填入小缓冲区进行编辑。如果一个文件对应多条可用命令，多次按 <code>M-n</code> 可依次查看每条匹配命令。
</p>

<p>
Dired 仅对单个文件尝试推测命令，不会对标记文件列表进行推测。
</p>

<dl class="org-dl">
<dt>变量： <code>dired-guess-shell-alist-default</code></dt><dd>该变量定义了用于推测适用于某些文件的 Shell 命令的 <b>预设规则</b> 。将其设为 <code>nil</code> 可关闭自动推测。用户定义的 <code>dired-guess-shell-alist-user</code> 中的条目会覆盖这些规则。</dd>

<dt>变量： <code>dired-guess-shell-alist-optional</code></dt><dd>该变量与 <code>dired-guess-shell-alist-default</code> 类似，但包含适用于各类媒体格式的外部查看器与播放器。设为 <code>nil</code> 可关闭对应推测功能。 <code>dired-guess-shell-alist-user</code> 和 <code>dired-guess-shell-alist-default</code> 会覆盖这些规则。</dd>

<dt>变量： <code>dired-guess-shell-alist-user</code></dt><dd><p>
若非 nil，该变量存放用户自定义的「文件正则表达式 → 建议命令」关联列表。运行 <code>dired-do-shell-command</code> 时，这些规则优先级高于 <code>dired-guess-shell-alist-default</code> 和 <code>dired-guess-shell-alist-optional</code> 中的预设规则。默认值为 <code>nil</code> 。
</p>

<p>
该关联列表的每个元素格式为：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(regexp command&#8230;)
</pre>
</div>

<p>
其中每条 <i>command</i> 可以是字符串，或求值后为字符串的 Lisp 表达式。如果给出多条命令，它们会被临时加入命令历史。
</p>

<p>
Shell 命令中的 '<code>*</code>' 代表匹配该 <i>regexp正则表达式</i> 的文件名。Emacs 执行命令时，会将每个 '<code>*</code>' 替换为匹配的文件名。
</p>

<p>
若要为 '.foo' 和 '.bar' 文件后缀添加规则，可将以下代码加入配置文件：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq</span> dired-guess-shell-alist-user
      (list
       (list <span style="color: #8b2252;">"\\.foo$"</span> <span style="color: #8b2252;">"foo-command"</span>)  <span style="color: #b22222;">; </span><span style="color: #b22222;">&#22266;&#23450;&#35268;&#21017;
</span>       <span style="color: #b22222;">;; </span><span style="color: #b22222;">&#21487;&#28155;&#21152;&#26356;&#22810;&#35268;&#21017;...
</span>       (list <span style="color: #8b2252;">"\\.bar$"</span>  <span style="color: #b22222;">; </span><span style="color: #b22222;">&#24102;&#26465;&#20214;&#21028;&#26029;&#30340;&#35268;&#21017;
</span>             '(if condition
                  <span style="color: #8b2252;">"bar-command-1"</span>
                <span style="color: #8b2252;">"bar-command-2"</span>))))
</pre>
</div></dd>
</dl>

<p>
这会覆盖相同后缀的所有预设规则。
</p>

<p>
你可以通过 <code>M-x customize-group RET dired-guess RET</code> 查看更多用户选项。
</p>
</div>
</div>
<div id="outline-container-Transforming-File-Names" class="outline-3">
<h3 id="Transforming-File-Names"><span class="section-number-3">32.10.</span> Dired 中的文件名转换</h3>
<div class="outline-text-3" id="text-Transforming-File-Names">
<p>
本节介绍用于系统性修改文件名的 Dired 命令。每条命令都会通过对原有文件名进行变换得到新文件名，并对部分或全部标记文件执行操作。
</p>

<p>
与基本的 Dired 文件操作命令类似（见<a href="#Operating-on-Files">文件操作</a>），这里介绍的命令可以对接下来的 <code>n</code> 个文件、所有标有 '<code>*</code>' 的文件，或当前文件进行操作。（标记文件的方法见 <a href="#Marks-vs-Flags">Dired 标记与标记位对比</a>。）
</p>

<p>
本节所有命令均为 <i>interactively交互式</i> 工作：会让你对每个待处理文件确认是否执行。因此，你可以先选中比实际需要更多的文件（例如用一条匹配很多文件的正则表达式），然后在命令提示确认时，通过按 <code>y</code> 或 <code>n</code> 来筛选文件名。
</p>

<dl class="org-dl">
<dt><code>% u</code></dt><dd>将选中的每个文件重命名为全大写（dired-upcase）。如果原文件名为 Foo 和 bar，新名将为 FOO 和 BAR。</dd>
<dt><code>% l</code></dt><dd>将选中的每个文件重命名为全小写（dired-downcase）。如果原文件名为 Foo 和 bar，新名将为 foo 和 bar。</dd>
<dt><code>% R 匹配规则 RET 替换规则 RET</code></dt><dd></dd>

<dt><code>% C from RET to RET</code></dt><dd></dd>

<dt><code>% H from RET to RET</code></dt><dd></dd>

<dt><code>% S from RET to RET</code></dt><dd></dd>

<dt><code>% Y from RET to RET</code></dt><dd>这五条命令分别对应：rename重命名、copy复制、make hard links创建硬链接、make soft links创建软链接、make relative soft links创建相对软链接。它们都会通过正则表达式替换，从旧文件名计算出新文件名。</dd>
</dl>

<p>
这四条正则替换命令会在选中的文件名上搜索并替换。它们读取两个参数：正则表达式 <i>from</i> 和替换模板 <i>to</i> ；将每个旧文件名与 <i>from</i> 匹配，然后把匹配部分替换为 <i>to</i> 。你可以在 <i>to</i> 中使用 '<code>\&amp;</code>' 和 '<code>\数字</code>' 来引用旧文件名中匹配到的全部或部分内容，用法与 <code>replace-regexp</code> 相同（见<a href="#Regexp-Replace">正则表达式替换</a>）。如果正则表达式在文件名中多次匹配，只替换第一个匹配。
</p>

<p>
示例： <code>% R ^.*$ RET x-\&amp; RET</code> 会给每个文件名前面加上 'x-' 。反向操作（从每个文件名开头去掉 'x-'）也可以实现：
</p>
<ul class="org-ul">
<li>方法一： <code>% R ^x-\(.*\)$ RET \1 RET</code></li>
<li>方法二： <code>% R ^x- RET RET</code> （可用 '<code>^</code>' 和 '<code>$</code>' 限定必须匹配整个文件名。）</li>
</ul>

<p>
通常，替换过程不考虑文件所在目录名，只对目录内的文件名生效。如果你指定数字前缀 0，替换会影响包含目录在内的完整绝对路径名。（非零数字前缀用于指定要操作的文件个数。）
</p>

<p>
你可能希望先用即将用于操作的同一个正则表达式 <i>from</i> 来选中文件。做法是：先用 <code>% m from RET</code> 标记这些文件，再在操作命令中使用同一个正则表达式。为方便使用，所有以 <code>%</code> 开头的文件操作命令，都会默认使用上一条 <code>%</code> 命令的正则表达式。
</p>
</div>
</div>
<div id="outline-container-Comparison-in-Dired" class="outline-3">
<h3 id="Comparison-in-Dired"><span class="section-number-3">32.11.</span> 通过 Dired 对比文件</h3>
<div class="outline-text-3" id="text-Comparison-in-Dired">
<p>
<code>=</code> (<code>dired-diff</code>) 命令使用 <code>diff</code> 程序，将当前文件（光标所在文件）与另一个文件（通过迷你缓冲区输入）进行比较。通过迷你缓冲区指定的文件是 <code>diff</code> 的第一个参数，光标所在文件是第二个参数。 <code>diff</code> 程序的输出会在一个采用 Diff 模式的缓冲区中显示（参见<a href="#Comparing-Files">文件比较</a>）。
</p>

<p>
如果选区（region）处于激活状态，迷你缓冲区默认读取的文件是 <b>标记（mark）</b> 所在位置的文件（即普通 Emacs 标记，而非 Dired 标记；参见<a href="#Setting-Mark">设置标记</a>）。否则，如果光标所在文件存在备份文件（参见<a href="#Backup">备份文件</a>），则默认使用该备份文件进行比较。
</p>

<p>
你也可以使用 <code>ediff-files</code> 比较文件，参见《Ediff 用户手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/ediff/Major-Entry-Points.html#Major-Entry-Points">主入口点</a>。
</p>
</div>
</div>
<div id="outline-container-Subdirectories-in-Dired" class="outline-3">
<h3 id="Subdirectories-in-Dired"><span class="section-number-3">32.12.</span> Dired 中的子目录操作</h3>
<div class="outline-text-3" id="text-Subdirectories-in-Dired">
<p>
一个 Dired 缓冲区通常只显示单个目录，但你也可以选择同时显示它的子目录。
</p>

<p>
在一个 Dired 缓冲区中显示多个目录的最简单方法，是为 <code>ls</code> 命令指定选项 '<code>-lR</code>' 。（如果你在运行 Dired 时给出数字前缀参数，就可以在迷你缓冲区中指定这些选项。）这样会生成 <b>递归目录列表</b> ，显示所有层级的子目录。
</p>

<p>
更常见的情况是，你只希望显示 <b>特定的子目录</b> 。可以使用命令 <code>i</code> (<code>dired-maybe-insert-subdir</code>) 实现：
</p>
<dl class="org-dl">
<dt><code>i</code></dt><dd>在缓冲区的下方插入某个子目录的内容。</dd>
</dl>

<p>
如果你将此命令用在表示目录的那一行上，它会把该目录的内容插入到同一个 Dired 缓冲区中，并跳转到那里。插入的子目录内容接在 Dired 缓冲区的顶层目录之后，就和 '<code>ls -lR</code>' 的输出格式一样。
</p>

<p>
如果该子目录的内容已经在缓冲区中存在， <code>i</code> 命令只会直接跳转到那里。
</p>

<p>
无论哪种情况， <code>i</code> 在跳转前都会设置 Emacs 标记，因此使用 <code>C-u C-SPC</code> 可以回到你在 Dired 缓冲区中之前的位置（参见<a href="#Setting-Mark">设置标记</a>）。你也可以使用 '<code>^</code>' 在同一个 Dired 缓冲区中返回上一级目录（参见<a href="#Dired-Visiting">在 Dired 中访问文件</a>）。
</p>

<p>
使用 <code>l</code> 命令 (<code>dired-do-redisplay</code>) 可以更新子目录的内容，在子目录标题行上使用 <code>C-u k</code> 可以移除该子目录的列表（参见<a href="#Dired-Updating">刷新 Dired 缓冲区</a>）。你还可以隐藏和显示已插入的子目录（参见<a href="#Hiding-Subdirectories">隐藏子目录</a>）。
</p>
</div>
</div>
<div id="outline-container-Subdir-Switches" class="outline-3">
<h3 id="Subdir-Switches"><span class="section-number-3">32.13.</span> Dired 中的子目录切换</h3>
<div class="outline-text-3" id="text-Subdir-Switches">
<p>
你可以使用 <code>C-u i</code> 在 Dired 缓冲区中带指定 <code>ls</code> 开关插入子目录。对于已经插入的、光标所在的子目录，可使用 <code>C-u l</code> 修改它的 <code>ls</code> 开关。
</p>

<p>
如果你刷新（revert）缓冲区，Dired 会保留这些开关；但删除子目录后，对应的开关会被遗忘。
</p>

<p>
使用 <code>dired-undo</code> （见 <a href="#Marks-vs-Flags">Dired 标记与标记位对比</a>）来重新插入或删除那些 <b>带显式开关</b> 插入的子目录时，会绕过 Dired 原本 “记住 / 遗忘开关” 的机制：
</p>
<ul class="org-ul">
<li>通过 <code>dired-undo</code> 删除子目录不会忘记它的开关；之后用 <code>i</code> 重新插入时，会沿用旧的开关。</li>
<li>对普通 Dired 命令（非  <code>dired-undo</code> ）删除的子目录，用 <code>dired-undo</code> 恢复时，最初会用旧开关插入；但一旦刷新缓冲区，就会改用缓冲区默认开关。</li>
<li>如果上述行为出现问题，你可以直接用 <code>C-u i</code> 或 <code>C-u l</code> 修正。</li>
</ul>

<p>
Dired 不会记住 <code>R</code> 开关。带 <code>R</code> 开关插入子目录，等价于用剩下的所有开关逐个插入其下所有子目录。例如，对带 <code>R</code> 插入的子目录执行更新或删除，不会递归更新 / 删除它的下级子目录。
</p>

<p>
缓冲区的默认 <code>ls</code> 开关不会影响那些 <b>显式指定过开关</b> 的子目录。具体来说，像 <code>s</code> 这类修改缓冲区开关的命令，不会影响这类子目录；但会影响没有手动指定开关的普通子目录。
</p>

<p>
你可以使用命令： <code>M-x dired-reset-subdir-switches RET</code> 让 Dired 忘记所有子目录的开关，并 <b>全部改用缓冲区默认开关</b> 重新列出，同时刷新整个 Dired 缓冲区。
</p>
</div>
</div>
<div id="outline-container-Subdirectory-Motion" class="outline-3">
<h3 id="Subdirectory-Motion"><span class="section-number-3">32.14.</span> 遍历子目录</h3>
<div class="outline-text-3" id="text-Subdirectory-Motion">
<p>
当 Dired 缓冲区列出子目录时，你可以使用页面移动命令 <code>C-x [</code> 和 <code>C-x ]</code> 按整个目录进行跳转（见 “<a href="#Pages">页面操作</a>”）。
</p>

<p>
下面这些命令用于在同一个 Dired 缓冲区的目录树中前后、上下移动。它们会跳转到目录标题行—— 也就是在目录内容开头、显示目录名称的那一行。
</p>
<dl class="org-dl">
<dt><code>C-M-n</code></dt><dd>跳转到下一个子目录标题行，不考虑层级 (<code>dired-next-subdir</code>) 。</dd>
<dt><code>C-M-p</code></dt><dd>跳转到上一个子目录标题行，不考虑层级 (<code>)dired-prev-subdir</code>) 。</dd>
<dt><code>C-M-u</code></dt><dd>向上跳转到父目录的标题行 (<code>dired-tree-up</code>) 。</dd>
<dt><code>C-M-d</code></dt><dd>在目录树中向下跳转到第一个子目录的标题行 (<code>dired-tree-down</code>) 。</dd>
<dt><code>&lt;</code></dt><dd>向上跳转到上一个目录文件行 (<code>dired-prev-dirline</code>) 。这类行是目录在其父目录中作为文件显示的行。</dd>
<dt><code>&gt;</code></dt><dd>向下跳转到下一个目录文件行 (<code>dired-next-dirline</code>) 。</dd>
<dt><code>M-G</code></dt><dd>提示输入一个目录，并跳转到该目录的目录文件行 (<code>dired-goto-subdir</code>) 。</dd>
</dl>
</div>
</div>
<div id="outline-container-Hiding-Subdirectories" class="outline-3">
<h3 id="Hiding-Subdirectories"><span class="section-number-3">32.15.</span> 隐藏子目录</h3>
<div class="outline-text-3" id="text-Hiding-Subdirectories">
<p>
<i>hding隐藏</i> 一个子目录，是指让目录内容不可见，只保留其标题行。
</p>
<dl class="org-dl">
<dt><code>$</code></dt><dd>隐藏或显示光标所在的子目录，并将光标移到下一个子目录 (<code>dired-hide-subdir</code>) 。这是一个切换命令。数字前缀参数可作为重复次数。</dd>
<dt><code>M-$</code></dt><dd>隐藏当前 Dired 缓冲区中的所有子目录，只保留它们的标题行 (<code>dired-hide-all</code>) 。如果已有子目录被隐藏，则执行此命令会重新显示所有子目录。你可以用这个命令对极深的目录树做概览，或快速跳转到远处的子目录。</dd>
</dl>

<p>
普通的 Dired 命令 <b>永远不会处理隐藏子目录内的文件</b> 。例如，操作标记文件的命令会忽略隐藏目录中的文件，即使它们已被标记。因此，你可以用隐藏功能，临时把某些子目录排除在操作范围之外，而不必清除这些目录内文件上的 Dired 标记。
</p>

<p>
关于如何插入子目录列表，参见 <a href="#Subdirectories-in-Dired">Dired 中的子目录</a>；关于如何删除子目录列表，参见<a href="#Dired-Updating">刷新 Dired 缓冲区</a>。
</p>
</div>
</div>
<div id="outline-container-Dired-Updating" class="outline-3">
<h3 id="Dired-Updating"><span class="section-number-3">32.16.</span> 更新 Dired 缓冲区</h3>
<div class="outline-text-3" id="text-Dired-Updating">
<p>
本节介绍用于刷新 Dired 缓冲区，以反映目录和文件在外部（非 Dired 操作）产生的改动，以及删除 Dired 缓冲区部分内容的命令。
</p>

<dl class="org-dl">
<dt><code>g</code></dt><dd>刷新 Dired 缓冲区的全部内容 (<code>revert-buffer</code>) 。</dd>
<dt><code>l</code></dt><dd>刷新指定的文件 (<code>dired-do-redisplay</code>) 。指定文件的方式与文件操作命令相同。</dd>
<dt><code>k</code></dt><dd>删除缓冲区中指定的文件行 —— <b>只删行，不删实际文件</b>  (<code>dired-do-kill-lines</code>) 。</dd>
<dt><code>s</code></dt><dd>在按字母序和按日期 / 时间序之间切换 (<code>dired-sort-toggle-or-edit</code>) 。</dd>
<dt>(no term)</dt><dd><code>C-u s switches RET</code> ::使用指定的开关作为 <code>dired-listing-switches</code> ，重新刷新 Dired 缓冲区。</dd>
</dl>

<p>
按 <code>g</code> (<code>revert-buffer</code>) 可根据文件和目录的实际变化刷新 Dired 缓冲区内容。此操作会保留所有标记， <b>已被删除的文件除外</b> 。隐藏的子目录会被刷新，但仍保持隐藏状态。
</p>

<p>
若只想刷新部分文件，按 <code>l</code> (<code>dired-do-redisplay</code>) 。与 Dired 文件操作命令一样，该命令可作用于接下来的 <code>n</code> 个文件（或前面的 <code>−n</code> 个文件）、所有标记文件，或当前文件。刷新文件意味着重新读取其当前状态，并更新缓冲区中对应的行以反映该状态。
</p>

<p>
如果在子目录标题行上按 <code>l</code> ，会刷新对应子目录的内容。
</p>

<p>
如果你用 <code>C-x d</code> 或其他 Dired 命令打开一个已在 Dired 缓冲区中显示的目录，Dired 会切换到该缓冲区，但 <b>不会自动刷新</b> 。如果缓冲区内容已过时，Dired 会显示警告，提示你按 <code>g</code> 刷新。你可以将变量 <code>dired-auto-revert-buffer</code> 设为非 nil，让 Emacs 在重新访问时 <b>自动刷新</b> 每个 Dired 缓冲区。
</p>

<p>
若要 <b>只从缓冲区删除文件行，而不真正删除文件</b> ，按  <code>k</code> (<code>dired-do-kill-lines</code>) 。与文件操作命令类似，它可作用于接下来的 <code>n</code> 个文件或所有标记文件；但 <b>不会作用于当前文件</b> ，避免误按 <code>k</code> 带来不便。
</p>

<p>
如果你用 <code>k</code> 删除已作为子目录插入到 Dired 缓冲区中的目录行，对应的子目录列表也会被一并移除。在子目录标题行上按 <code>C-u k</code> 同样会从 Dired 缓冲区中删除该子目录内容。
</p>

<p>
<code>g</code> 命令可以恢复被这样删除的普通文件行，但 <b>无法恢复子目录</b> ；你必须用 <code>i</code> 重新插入子目录。
</p>

<p>
Dired 缓冲区中的文件默认按文件名 <b>字母序</b> 排列，也可按 <b>日期 / 时间</b> 排序。Dired 命令 <code>s</code> (<code>dired-sort-toggle-or-edit</code>) 在这两种排序方式间切换。Dired 缓冲区的模式行会提示当前是按名称还是按日期排序。
</p>

<p>
<code>C-u s switches RET</code> 可让你为 <code>dired-listing-switches</code> 指定新的值。
</p>
</div>
</div>
<div id="outline-container-Dired-and-Find" class="outline-3">
<h3 id="Dired-and-Find"><span class="section-number-3">32.17.</span> Dired 与 find 命令</h3>
<div class="outline-text-3" id="text-Dired-and-Find">
<p>
你可以借助 find 工具来筛选文件，更灵活地选取一组文件并在 Dired 缓冲区中显示。
</p>

<p>
若要按 <b>文件名通配符</b> 搜索文件，使用 <code>M-x find-name-dired</code> 。它会读取两个参数：目录（directory）与匹配模式（pattern），并选取该目录及其子目录下所有文件名与模式匹配的文件。
</p>

<p>
筛选出的文件会显示在一个 Dired 缓冲区中，普通 Dired 命令均可正常使用。
</p>

<p>
若想按 <b>文件内容</b> 而非文件名筛选，使用 <code>M-x find-grep-dired</code> 。该命令读取两个迷你缓冲区参数：目录（directory）与正则表达式（regexp）；它会选取该目录及其子目录下所有 <b>包含该正则表达式匹配内容</b> 的文件，通过运行 <code>find</code> 和 <code>grep</code> 实现。另见 <code>M-x grep-find</code> （见<a href="#Grep-Searching">在 Emacs 中使用 Grep 搜索</a>）。注意：这里的正则表达式是写给 <code>grep</code> 使用的，而非 Emacs 正则。（另一种显示内容匹配正则表达式文件的方法是 <code>% g regexp</code> 命令，见 <a href="#Marks-vs-Flags">Dired 标记与标记位对比</a>。）
</p>

<p>
这一系列命令中最通用的是 <code>M-x find-dired</code> ，它允许你指定 <code>find</code> 所能判断的任意条件。它接收两个参数：目录（directory）与 find 参数（find-args）；它会在指定 <i>direcory目录</i> 中运行 <code>find</code> ，并把 <i>find-args</i> 传给 <code>find</code> 作为筛选条件。使用该命令需要了解 <code>find</code> 的用法。
</p>

<p>
这些命令生成的列表格式由变量 <code>find-ls-option</code> 控制。它是一对选项：第一个选项指定如何调用 <code>find</code> 来生成文件列表，第二个选项告诉 Dired 如何解析输出。
</p>

<p>
命令 <code>M-x locate</code> 提供与 <code>locate</code> 程序类似的接口。 <code>M-x locate-with-filter</code> 与之相似，但只保留文件名匹配指定正则表达式的文件。
</p>

<p>
这类缓冲区的行为与普通 Dired 缓冲区 <b>不完全一样</b> ：文件操作可以执行，但不一定会自动刷新缓冲区。使用 <code>g</code> 刷新缓冲区会 <b>删除所有已插入的子目录</b> ，并清空所有标记（flag）与选中标记（mark）。
</p>
</div>
</div>
<div id="outline-container-Wdired" class="outline-3">
<h3 id="Wdired"><span class="section-number-3">32.18.</span> 编辑 Dired 缓冲区</h3>
<div class="outline-text-3" id="text-Wdired">
<p>
Wdired 是一种特殊模式，允许你 <b>直接编辑 Dired 缓冲区</b> 来执行文件操作（Wdired 中的 “W” 代表 “可写 writable”）。在 Dired 缓冲区中按 <code>C-x C-q</code> (<code>dired-toggle-read-only</code>) 即可进入 Wdired mode；也可以使用菜单选项「Immediate / Edit File Names」。
</p>

<p>
在 Wdired 模式下，你可以直接编辑 Dired 缓冲区里显示的文件名来 <b>重命名文件</b> 。所有普通的 Emacs 编辑命令（包括矩形操作、查询替换等）都可以使用。编辑完成后，按 C-c C-c（wdired-finish-edit），会应用你的修改并切回普通 Dired 模式。
</p>

<p>
除了简单重命名，你还可以直接输入新文件名（绝对路径或相对路径），把文件 <b>移动到另一个目录</b> 。想要标记删除某个文件，直接把它的 <b>整个文件名删掉</b> 即可。想要修改符号链接的目标，编辑链接名旁边显示的链接目标路径即可。
</p>

<p>
如果你通过编辑文件名创建新的子目录，Wdired 会 <b>自动创建这些新目录</b> 。如果要关闭此行为，把 <code>wdired-create-parent-directories</code> 设为 nil。
</p>

<p>
缓冲区里的其他内容（如文件大小、修改时间）会被标记为只读，无法编辑。但如果你把 <code>wdired-allow-to-change-permissions</code> 设为 <code>t</code> ，就可以编辑 <b>文件权限</b> 。例如，把 '<code>-rw-r--r--</code>' 改成 '<code>-rw-rw-rw-</code>' ，让文件对所有用户可写。这些改动在按下 <code>C-c C-c</code> 后同样会生效。
</p>
</div>
</div>
<div id="outline-container-Image_002dDired" class="outline-3">
<h3 id="Image_002dDired"><span class="section-number-3">32.19.</span> 在 Dired 中查看图片缩略图</h3>
<div class="outline-text-3" id="text-Image_002dDired">
<p>
Image-Dired 是用于浏览图片文件的工具。它可以将图片以缩略图或原图大小显示，既可在 Emacs 内部查看，也可通过外部查看器打开。这与在 Emacs 缓冲区中直接查看图片的 Image 模式不同（参见<a href="#Image-Mode">查看图片文件</a>）。
</p>

<p>
进入 Image-Dired 的方法：在 Dired 缓冲区中，像平常一样用 <code>m</code> 标记你想要查看的图片文件，然后按 <code>C-t d</code> (<code>image-dired-display-thumbs</code>) 。这会创建并切换到对应这些标记文件的 Image-Dired 缓冲区。
</p>

<p>
你也可以直接输入 <code>M-x image-dired</code> 进入 Image-Dired。该命令会提示输入一个目录，指定一个存放图片文件的目录即可。它会为该目录下所有图片生成缩略图，并在缩略图缓冲区中全部显示。缩略图在后台生成，生成完毕后自动加载。
</p>

<p>
Image-Dired 支持三种缩略图生成与存储方式，由选项 <code>image-dired-thumbnail-storage</code> 控制：
</p>
<dl class="org-dl">
<dt><code>image-dired</code></dt><dd>默认方式。将缩略图以 JPEG 格式统一存放在变量 <code>image-dired-dir</code> 指定的目录中。缩略图文件名由变量 <code>image-dired-thumb-naming</code> 决定。</dd>
<dt><code>standard</code></dt><dd></dd>

<dt><code>standard-large</code></dt><dd></dd>

<dt><code>standard-x-large</code></dt><dd></dd>

<dt><code>standard-xx-large</code></dt><dd>遵循缩略图管理标准（<a href="https://specifications.freedesktop.org/thumbnail-spec/thumbnail-spec-latest.html">Thumbnail Managing Standard</a>）。将缩略图以 PNG 格式存放在环境变量 <code>XDG_CACHE_HOME</code> （默认为 <code>~/.cache</code> ）下的 <code>thumbnails</code> 子目录中。</dd>
<dt><code>per-directory</code></dt><dd>在每个图片所在目录下的 <code>.image-dired</code> 子目录中，以 JPEG 格式存放该目录图片的缩略图。</dd>
</dl>

<p>
你可以通过自定义变量 <code>image-dired-thumb-size</code> 控制缩略图尺寸，默认为 128 像素。该变量只对上面第一种和第三种存储方式生效；标准缩略图方式使用固定尺寸： <code>standard</code> 为 128 像素， <code>standard-large</code> 为 256 像素等。如果在已有缩略图后修改尺寸，需要删除旧缩略图文件，新尺寸才会生效。
</p>

<p>
在缩略图缓冲区中：
</p>
<ul class="org-ul">
<li>按 <code>RET</code> (<code>image-dired-display-this</code>) ：在另一个窗口显示该图片。</li>
<li>使用 Emacs 标准移动键或方向键浏览缩略图。</li>
<li>按 <code>SPC</code> (<code>image-dired-display-next</code>) ：显示下一张图片。</li>
<li>按 <code>DEL</code> (<code>image-dired-display-previous</code>) ：显示上一张图片。</li>
</ul>

<p>
按 <code>C-RET</code> (<code>image-dired-thumbnail-display-external</code>) ：用外部查看器打开图片。你需要先配置 <code>image-dired-external-viewer</code> 。
</p>

<p>
你也可以通过 Image-Dired 删除图片：
</p>
<ul class="org-ul">
<li>按 <code>d</code> (<code>image-dired-flag-thumb-original-file</code>) ：在 Dired 缓冲区中标记该图片待删除。</li>
<li>按 <code>C-d</code> (<code>image-dired-delete-char</code>) ：仅从缩略图缓冲区移除该缩略图， <b>不标记删除原文件</b> 。</li>
</ul>

<p>
你还可以在 Dired 中直接进行 “inline内嵌式” 操作：
</p>
<ul class="org-ul">
<li>按 <code>C-t C-t</code> ：在选中的图片文件名前显示缩略图 (<code>image-dired-dired-toggle-marked-thumbs</code>) 。</li>
<li>按 <code>C-t i</code> ：在 Emacs 中打开光标下的图片。</li>
<li>按 <code>C-t x</code> ：用外部查看器打开光标下的图片。</li>
</ul>

<p>
更高级的功能包括 <b><i>image tags图片标签</i></b> ，这是用于分类图片的元数据。标签存放在由 <code>image-dired-tags-db-file</code> 指定的纯文本文件中。
</p>
<ul class="org-ul">
<li>给图片打标签：在 Dired 中标记文件（也可在缩略图缓冲区按 <code>m</code> 标记），然后按 <code>C-t t</code> (<code>image-dired-tag-files</code>) ，在小缓冲区输入标签名。</li>
<li>标记带有某标签的文件：按 <code>C-t f</code> (<code>image-dired-mark-tagged-files</code>) 。标记后可用 <code>C-t d</code> 查看这些图片。</li>
</ul>

<p>
你也可以直接在缩略图缓冲区：
</p>
<ul class="org-ul">
<li>按 <code>t t</code> ：给当前文件打标签。</li>
<li>按 <code>t r</code> ：移除标签。</li>
</ul>

<p>
每个文件还有一个特殊的 “注释（comment）” 标签（用法与普通标签略有不同），用于输入图片说明。
</p>
<ul class="org-ul">
<li>在缩略图缓冲区按 <code>c</code> ：为图片添加注释。</li>
<li>在 Dired 中按 <code>C-t c</code> ：为文件添加注释 (<code>image-dired-dired-comment-files</code>) 。</li>
<li>按 <code>C-t e</code> ：打开缓冲区编辑注释与标签 (<code>image-dired-dired-edit-comment-and-tags</code>) 。</li>
</ul>

<p>
如果安装了 <code>exiftool</code> ，可以在图片缩略图上执行 <code>image-dired-thumbnail-set-image-description</code> 命令，设置图片的 EXIF 'ImageDescription' 字段。
</p>

<p>
如果 <code>image-dired-thumb-visible-marks</code> 为非 nil（默认开启），在 Dired 中标记的文件，在 Image-Dired 中也会显示为已标记。
</p>

<p>
Image-Dired 还提供简单的图片处理功能。在缩略图缓冲区中：
</p>
<ul class="org-ul">
<li>按 <code>L</code> ：将原图逆时针旋转 90 度。</li>
<li>按 <code>R</code> ：将原图顺时针旋转 90 度。该旋转为无损旋转，需要先安装外部工具 <code>jpegtran</code> 。</li>
</ul>
</div>
</div>
<div id="outline-container-Misc-Dired-Features" class="outline-3">
<h3 id="Misc-Dired-Features"><span class="section-number-3">32.20.</span> Dired 的其他功能</h3>
<div class="outline-text-3" id="text-Misc-Dired-Features">
<p>
默认情况下，Dired 会在目录列表的第一行、目录名之后，显示该目录所在磁盘的可用空间。你可以通过自定义变量 <code>dired-free-space</code> 控制这一显示：
</p>
<ul class="org-ul">
<li>默认值 <code>first</code> ：在目录名同一行显示可用空间。</li>
<li>设为 <code>separate</code> ：在目录名下 <b>单独一行</b> 显示磁盘空间，同时包含当前目录文件占用空间与可用空间。</li>
<li>设为 <code>nil</code> ： <b>完全不显示</b> 磁盘空间信息。</li>
</ul>

<p>
命令 <code>+</code> (<code>dired-create-directory</code>) 会读取目录名并创建该目录。若目录已存在，则报错。
</p>

<p>
命令 (<code>dired-create-empty-file</code>) 会读取文件名并创建空文件。若文件已存在，则报错。
</p>

<p>
命令 <code>M-s a C-s</code> (<code>dired-do-isearch</code>) 对标记的文件启动多文件增量搜索。如果在一个文件末尾搜索失败，按 <code>C-s</code> 会跳到下一个标记文件并继续搜索；在最后一个标记文件末尾时，搜索会回到第一个标记文件循环。命令 <code>M-s a M-C-s</code> (<code>dired-do-isearch-regexp</code>) 功能相同，只是使用正则表达式搜索。有关搜索重复的说明，参见 “<a href="#Repeat-Isearch">重复增量搜索</a>”。
</p>

<p>
命令 <code>w</code> (<code>dired-copy-filename-as-kill</code>) 将已标记（或接下来 <code>n</code> 个）文件的名称放入剪切环（kill ring），效果如同用 <code>C-w</code> 剪切。文件名之间用空格分隔。
</p>
<ul class="org-ul">
<li>带零前缀参数时：使用每个标记文件的 <b>绝对路径</b> 。</li>
<li>仅用 <code>C-u</code> 作前缀时：使用相对于当前 Dired 缓冲区默认目录的 <b>相对路径</b> （若在子目录中仍可能包含斜杠）。</li>
<li>特殊情况：若光标位于目录标题行， <code>w</code> 会给出该目录的绝对路径，此时忽略任何前缀参数与已标记文件。</li>
</ul>

<p>
该命令的主要用途是方便你将文件名 <b>粘贴（yank）</b> 到其他 Emacs 命令的参数中。它同时会在回显区显示已加入剪切环的内容，因此也可用于查看当前标记文件列表。
</p>

<p>
如果文件列表中有 HTML 文件，用浏览器查看会很方便。命令 <code>W</code> (<code>browse-url-of-dired-file</code>) 会使用系统配置的默认浏览器打开该文件。
</p>

<p>
命令 (<code>dired-hide-details-mode</code>) 用于切换是否在当前 Dired 缓冲区中显示文件详情（如文件所有者、权限等）。默认同时隐藏符号链接目标，以及除标题行与文件 / 目录列表外的其他行。如需修改，可分别自定义选项： <code>dired-hide-details-hide-symlink-targets</code> 、 <code>dired-hide-details-hide-information-lines</code>
</p>

<p>
如果你访问的目录受版本控制（见<a href="#Version-Control">VC</a>）管理，普通的 VC 对比与日志命令可直接作用于选中文件。
</p>

<p>
命令 <code>M-x dired-compare-directories</code> 用于对比当前 Dired 目录与另一个目录。它会标记出两个目录中存在差异的所有文件，并在所有显示这些文件的 Dired 缓冲区中加上标记（当然也包括当前缓冲区）。
</p>

<p>
默认对比方式（直接按 <code>RET</code> ）： <b>只对比文件名</b> —— 文件不存在于另一目录即视为不同。你可以输入一个 Lisp 表达式来指定更严格的对比条件，可用变量包括：
</p>
<ul class="org-ul">
<li>size1、size2：文件大小</li>
<li>mtime1、mtime2：最后修改时间（浮点数秒数）</li>
<li>fa1、fa2：文件属性列表（由 file-attributes 返回）</li>
</ul>

<p>
该表达式会对每一对同名文件求值，结果非 nil 即视为文件不同。
</p>

<p>
示例： <code>M-x dired-compare-directories RET (&gt; mtime1 mtime2) RET</code> 会标记：
</p>
<ul class="org-ul">
<li>当前目录中比另一目录 <b>更新</b> 的文件</li>
<li>另一目录中比当前目录更旧的文件</li>
<li>以及两边目录中 <b>不存在对应文件</b> 的文件（始终标记）</li>
</ul>

<p>
在 X Window 系统下，Emacs 支持 <b>拖放协议</b> 。你可以从其他程序拖曳文件对象到 Dired 缓冲区，实现移动、复制或创建链接，具体行为由源程序决定。
</p>

<p>
同时也支持从 Dired 缓冲区向外拖曳文件：开启用户选项 <code>dired-mouse-drag-files</code> 后，可用鼠标将文件拖到其他程序。
</p>
<ul class="org-ul">
<li>设为 <code>link</code> ：让文件管理器等程序创建符号链接</li>
<li>设为 <code>move</code> ：执行移动操作</li>
<li>设为其他非 nil 值：执行打开或复制操作。拖放时按下的键盘修饰键也可控制目标程序对文件的操作。</li>
</ul>
</div>
</div>
</section>
<section id="outline-container-Calendar_002fDiary" class="outline-2">
<h2 id="Calendar_002fDiary"><span class="section-number-2">33.</span> 日历与日记</h2>
<div class="outline-text-2" id="text-Calendar_002fDiary">
<p>
Emacs 提供桌面日历功能，并可记录计划或已发生的事件日记。它还能管理你的日程安排，并统计你在特定项目上花费的时间。
</p>

<p>
输入 <code>M-x calendar</code> 即可进入日历。该命令会显示以当前月份为中心的三个月日历，光标定位在当天日期。若带数字参数，例如 <code>C-u M-x calendar</code> ，会提示你指定月份和年份，作为三个月日历的中心月份。日历使用独立缓冲区，其主模式为日历模式（Calendar mode）。
</p>

<p>
在日历中点击 <code>mouse-3</code> （鼠标右键）可弹出针对特定日期的操作菜单； <code>mouse-2</code> （鼠标中键）弹出与具体日期无关的常用日历功能菜单。输入 <code>q</code> 退出日历。
</p>
</div>
<div id="outline-container-Calendar-Motion" class="outline-3">
<h3 id="Calendar-Motion"><span class="section-number-3">33.1.</span> 日历中的移动</h3>
<div class="outline-text-3" id="text-Calendar-Motion">
<p>
<i>Calendar mode日历模式</i> 提供多种命令，可按天、周、月、年等逻辑时间单位在日历中移动。如果你移动到了最初显示的三个月范围之外，日历会自动滚动，让选中的日期可见。移动到某一日期后，你可以查看该日的节假日或日记条目，或将其转换为其他历法；长时间跨度的移动也可用于快速翻阅日历。
</p>

<ul class="org-ul">
<li><a href="#Calendar-Unit-Motion">按标准时间长度移动</a></li>
<li><a href="#Move-to-Beginning-or-End">星期、月份、年份的开始或结尾</a></li>
<li><a href="#Specified-Dates">指定日期跳转</a></li>
</ul>
</div>
<div id="outline-container-Calendar-Unit-Motion" class="outline-4">
<h4 id="Calendar-Unit-Motion"><span class="section-number-4">33.1.1.</span> 按标准时间长度移动</h4>
<div class="outline-text-4" id="text-Calendar-Unit-Motion">
<p>
日历缓冲区中的移动命令，与文本移动命令的设计思路类似。你可以按天、周、月、年向前或向后跳转。
</p>

<dl class="org-dl">
<dt><code>C-f</code></dt><dd>光标向前移动一天 (<code>calendar-forward-day</code>) 。光标向右移动1天。方向与现代含义有区别，见<a href="#Scrolling">滚动操作</a></dd>
<dt><code>C-b</code></dt><dd>光标向后移动一天 (<code>calendar-backward-day</code>) 。</dd>
<dt><code>C-n</code></dt><dd>光标向前移动一周 (<code>calendar-forward-week</code>) 。</dd>
<dt><code>C-p</code></dt><dd>光标向后移动一周 (<code>calendar-backward-week</code>) 。</dd>
<dt><code>M-}</code></dt><dd>光标向前移动一月 (<code>calendar-forward-month</code>) 。</dd>
<dt><code>M-{</code></dt><dd>光标向后移动一月 (<code>calendar-backward-month</code>) 。</dd>
<dt><code>C-x ]</code></dt><dd>光标向前移动一年 (<code>calendar-forward-year</code>) 。</dd>
<dt><code>C-x [</code></dt><dd>光标向后移动一年 (<code>calendar-backward-year</code>) 。</dd>
</dl>

<p>
按天和按周移动的命令，对应 Emacs 平常按字符、按行移动的逻辑。就像普通模式下 <code>C-n</code> 会跳到下一行同一列，在日历模式中它绑定到 <code>calendar-forward-week</code> ，会跳到下一周的同一星期几； <code>C-p</code> (<code>calendar-backward-week</code>) 则跳至上一周的同一星期几。 <code>C-f</code> (<code>calendar-forward-day</code>) 和 <code>C-b</code> (<code>calendar-backward-day</code>) 按天前后移动。
</p>

<p>
方向键功能与 <code>C-f</code> 、 <code>C-b</code> 、 <code>C-n</code> 、 <code>C-p</code> 等价，和其他模式一致。
</p>

<p>
按月、按年移动的命令用法与按周类似，只是跨度更大。月命令  <code>M-}</code> (<code>calendar-forward-month</code>) 和 <code>M-{</code> (<code>calendar-backward-month</code>) 整月前后跳转；年命令 <code>C-x ]</code> (<code>calendar-forward-year</code>) 和 <code>C-x [</code> (<code>calendar-backward-year</code>) 整年前后跳转。
</p>

<p>
方便记忆的方式：把 <b>月</b> 类比成文本里的 <b>段落</b> ，把 <b>年</b> 类比成 <b>页面</b> 。但日历命令与普通文本命令并不完全相同：普通段落命令会跳到段落开头或结尾，而日历中的月、年命令会保持当月、当年的同一日期，整体移动一个月或一整年。
</p>

<p>
所有这些命令都接受数字前缀参数作为重复次数。为方便使用，在日历模式下，即使不按 Meta 键，直接按数字键和减号也能指定数字参数。例如： <code>100 C-f</code> 会从当前位置向后移动 100 天
</p>
</div>
</div>
<div id="outline-container-Move-to-Beginning-or-End" class="outline-4">
<h4 id="Move-to-Beginning-or-End"><span class="section-number-4">33.1.2.</span> 星期、月份、年份的开始或结尾</h4>
<div class="outline-text-4" id="text-Move-to-Beginning-or-End">
<p>
一周（或一月、一年）不只是一段天数；我们通常认为周（月、年）是从特定日期开始的。因此日历模式提供了跳至周、月、年开头或结尾的命令：
</p>
<dl class="org-dl">
<dt><code>C-a</code></dt><dd>光标移至本周开头 (<code>calendar-beginning-of-week</code>) 。</dd>
<dt><code>C-e</code></dt><dd>光标移至本周结尾 (<code>calendar-end-of-week</code>) 。</dd>
<dt><code>M-a</code></dt><dd>光标移至本月开头 (<code>calendar-beginning-of-month</code>) 。</dd>
<dt><code>M-e</code></dt><dd>光标移至本月结尾 (<code>calendar-end-of-month</code>) 。</dd>
<dt><code>M-&lt;</code></dt><dd>光标移至本年开头 (<code>calendar-beginning-of-year</code>) 。</dd>
<dt><code>M-&gt;</code></dt><dd>光标移至本年结尾 (<code>calendar-end-of-year</code>) 。</dd>
</dl>

<p>
这些命令同样接受数字前缀参数作为重复次数，参数表示向前或向后移动多少周、月、年。
</p>

<p>
默认情况下，一周从星期日开始。如果想改为从星期一开始，可将变量 <code>calendar-week-start-day</code> 设置为 1。若要修改哪些日期标题会高亮显示为周末，可设置变量 <code>calendar-weekend-days</code> 。
</p>
</div>
</div>
<div id="outline-container-Specified-Dates" class="outline-4">
<h4 id="Specified-Dates"><span class="section-number-4">33.1.3.</span> 指定日期跳转</h4>
<div class="outline-text-4" id="text-Specified-Dates">
<p>
日历模式提供了多种命令，可跳转到以不同方式指定的具体日期。
</p>

<dl class="org-dl">
<dt><code>g d</code></dt><dd>跳转到指定日期 (<code>calendar-goto-date</code>) 。</dd>
<dt><code>g D</code></dt><dd>跳转到年内指定天数 (<code>calendar-goto-day-of-year</code>) 。</dd>
<dt><code>g w</code></dt><dd>跳转到年内指定周（ISO 周） (<code>calendar-iso-goto-week</code>) 。</dd>
<dt><code>o</code></dt><dd>以指定月份为中心重新显示三个月日历 (<code>calendar-other-month</code>) 。</dd>
<dt><code>.</code></dt><dd>跳转到今天的日期 (<code>calendar-goto-today</code>) 。</dd>
</dl>

<p>
<code>g d</code> (<code>calendar-goto-date</code>) 会提示输入年、月、日，然后跳转到该日期。由于日历包含当前纪元的所有日期，年份必须完整输入；例如输入 2010，而不是 10。
</p>

<p>
<code>g D</code> (<code>calendar-goto-day-of-year</code>) 提示输入年份和天数，然后跳转到对应日期。负数天数表示从年末向前倒数。
</p>

<p>
<code>g w</code> (<code>calendar-iso-goto-week</code>) 提示输入年份和周数，跳转到对应周。
</p>

<p>
<code>o</code> (<code>calendar-other-month</code>) 提示输入月份和年份，然后以该月为中心显示三个月日历。
</p>

<p>
使用 <code>.</code> (<code>calendar-goto-today</code>) 可以快速回到今天。
</p>
</div>
</div>
</div>
<div id="outline-container-Scroll-Calendar" class="outline-3">
<h3 id="Scroll-Calendar"><span class="section-number-3">33.2.</span> 日历滚动</h3>
<div class="outline-text-3" id="text-Scroll-Calendar">
<p>
当你移动超出日历当前可见区域时，日历会 <b>自动滚动</b> 。你也可以手动滚动。可以把日历窗口想象成一长条印有月份的纸带，滚动日历就是水平移动这条纸带，让新的月份显示在窗口中。
</p>

<dl class="org-dl">
<dt><code>&gt;</code></dt><dd>向前滚动一个月 (<code>calendar-scroll-left</code>) 。</dd>
<dt><code>&lt;</code></dt><dd>向后滚动一个月 (<code>calendar-scroll-right</code>) 。</dd>
<dt><code>C-v</code></dt><dd></dd>

<dt><code>PageDown</code></dt><dd></dd>

<dt><code>next</code></dt><dd>向前滚动三个月 (<code>calendar-scroll-left-three-months</code>) 。</dd>
<dt><code>M-v</code></dt><dd></dd>

<dt><code>PageUp</code></dt><dd></dd>

<dt><code>prior</code></dt><dd>向后滚动三个月 (<code>calendar-scroll-right-three-months</code>) 。</dd>
</dl>

<p>
最基础的日历滚动命令每次滚动 <b>一个月</b> ，这意味着滚动前后的显示内容会有 <b>两个月重叠</b> 。 <code>&gt;</code> (<code>calendar-scroll-left</code>) 让时间上更晚的月份显示出来； <code>&lt;</code> (<code>calendar-scroll-right</code>) 让时间上更早的月份显示出来。
</p>

<p>
命令 <code>C-v</code> (<code>calendar-scroll-left-three-months</code>) 和 <code>M-v</code> (<code>calendar-scroll-right-three-months</code>) 一次滚动一整屏（三个月），用法和它们在普通文本中的含义类似。 <code>C-v</code> 显示更晚的日期， <code>M-v</code> 显示更早的日期。
</p>

<p>
这些命令都接受数字前缀参数作为滚动次数。特别地， <code>C-u</code> 会把下一条命令的执行次数乘以 4，所以 <code>C-u C-v</code> 会向前滚动一整年， <code>C-u M-v</code> 会向后滚动一整年。
</p>

<p>
功能键 <code>PageDown</code> (<code>next</code>) 和 <code>PageUp</code> (<code>prior</code>)  分别等价于 <code>C-v</code> 和 <code>M-v</code> ，与其他模式一致。
</p>
</div>
</div>
<div id="outline-container-Counting-Days" class="outline-3">
<h3 id="Counting-Days"><span class="section-number-3">33.3.</span> 天数计算</h3>
<div class="outline-text-3" id="text-Counting-Days">
<dl class="org-dl">
<dt><code>M-=</code></dt><dd>显示当前区域内的天数 (<code>calendar-count-days-region</code>) 。</dd>
</dl>

<p>
要统计一段日期范围内的天数，请使用 <code>C-SPC</code> 在一个日期上设置标记，将光标移动到另一个日期，然后输入 <code>M-=</code> (<code>calendar-count-days-region</code>) 。显示的天数是包含首尾的，即同时计入标记所在日期和光标所在日期。
</p>
</div>
</div>
<div id="outline-container-General-Calendar" class="outline-3">
<h3 id="General-Calendar"><span class="section-number-3">33.4.</span> 日历杂项命令</h3>
<div class="outline-text-3" id="text-General-Calendar">
<dl class="org-dl">
<dt><code>p d</code></dt><dd>显示年内第几天 (<code>calendar-print-day-of-year</code>) 。</dd>
<dt><code>C-c C-l</code></dt><dd>重新生成日历窗口 (<code>calendar-redraw</code>) 。</dd>
<dt><code>SPC</code></dt><dd>向上滚动另一个窗口 (<code>scroll-other-window</code>) 。</dd>
<dt><code>DEL</code></dt><dd></dd>

<dt><code>S-SPC</code></dt><dd>向下滚动另一个窗口 (<code>scroll-other-window-down</code>) 。</dd>
<dt><code>q</code></dt><dd>退出日历 (<code>calendar-exit</code>) 。</dd>
</dl>

<p>
要查看从年初到当天已过的天数，以及本年剩余天数，可使用命令 <code>p d</code> (<code>calendar-print-day-of-year</code>) 。这两个数值都会显示在回显区：已过天数 <b>包含</b> 当前选中日期，剩余天数 <b>不包含</b> 当前日期。
</p>

<p>
如果日历窗口内容显示错乱，可输入 <code>C-c C-l</code> (<code>calendar-redraw</code>) 重新绘制。（这种情况只会在你使用了非日历模式的编辑命令时出现。）
</p>

<p>
在日历模式中，你可以用 <code>SPC</code> 和 <code>DEL</code> 分别向上 / 向下滚动另一个窗口（如果存在）。当你在另一个窗口中查看节假日或日记条目时，这会很方便。
</p>

<p>
输入 <code>q</code> (<code>calendar-exit</code>) 即可退出日历。该操作会隐藏所有与日历相关的缓冲区，并切换到其他缓冲区。（如果某个框架是专门的日历窗口，退出时会根据变量 <code>calendar-remove-frame-by-deleting</code> 的值决定删除或最小化该框架。）
</p>
</div>
</div>
<div id="outline-container-Writing-Calendar-Files" class="outline-3">
<h3 id="Writing-Calendar-Files"><span class="section-number-3">33.5.</span> 编写日历文件</h3>
<div class="outline-text-3" id="text-Writing-Calendar-Files">
<p>
你可以将日历与日记条目导出为 HTML 和 LaTeX 文件。
</p>

<p>
<b>HTML 导出</b>
</p>

<p>
日历 HTML 命令会生成包含日历、节假日和日记条目的 HTML 文件。每个文件对应一个月份，文件名为 <i>yyyy-mm</i>.html 格式，其中 <i>yyyy</i> 是 4 位年份， <i>mm</i> 是 2 位月份。
</p>
<ul class="org-ul">
<li>变量 <code>cal-html-directory</code> 指定 HTML 文件的默认输出目录。</li>
<li>若要隐藏节假日，可自定义 <code>cal-html-holidays</code> 。</li>
</ul>

<p>
被 <code>&lt;</code> 和 <code>&gt;</code> 包裹的日记条目会被当作 HTML 标签解析（例如：这是一条带有 <code>&lt;font color="red"&gt;红色文字&lt;/font&gt;</code> 的日记）。你可以通过 HTML 文件所在目录中的样式表 cal.css 来修改页面整体外观（如颜色、标题样式等）。相关样式设置可参考变量 <code>cal-html-css-default</code> 。
</p>

<dl class="org-dl">
<dt><code>H m</code></dt><dd>生成当月日历 (<code>cal-html-cursor-month</code>) 。</dd>
<dt><code>H y</code></dt><dd>为一年中每个月生成日历文件，并生成索引页 (<code>cal-html-cursor-year</code>) 。默认会写入以年份命名的子目录中；若修改此设置，年份之间的部分超链接可能失效。</dd>
</dl>

<p>
若变量 <code>cal-html-print-day-number-flag</code> 不为 nil，月历会显示年内第几天。变量 <code>cal-html-year-index-cols</code> 设置年度索引页的列数。
</p>

<p>
<b>LaTeX 导出</b>
</p>

<p>
日历 LaTeX 命令会生成可打印为日历的 LaTeX 代码缓冲区。根据所用命令不同，可输出光标所在的日、周、月、年日历。
</p>

<dl class="org-dl">
<dt><code>t m</code></dt><dd>生成单月日历 (<code>cal-tex-cursor-month</code>)。</dd>
<dt><code>t M</code></dt><dd>生成横向打印的单月日历 (<code>cal-tex-cursor-month-landscape</code>) 。</dd>
<dt><code>t d</code></dt><dd>生成单日日历 (<code>cal-tex-cursor-day</code>) 。</dd>
<dt><code>t w 1</code></dt><dd>生成带小时的单周单页日历 (<code>cal-tex-cursor-week</code>) 。</dd>
<dt><code>t w 2</code></dt><dd>生成带小时的单周双页日历 (<code>cal-tex-cursor-week2</code>) 。</dd>
<dt><code>t w 3</code></dt><dd>生成 ISO 风格、无小时的单周日历 (<code>cal-tex-cursor-week-iso</code>) 。</dd>
<dt><code>t w 4</code></dt><dd>生成以周一为起始、带小时的单周日历 (<code>cal-tex-cursor-week-monday</code>) 。</dd>
<dt><code>t w W</code></dt><dd>生成无小时的单周双页日历 (<code>cal-tex-cursor-week2-summary</code>) 。</dd>
<dt><code>t f w</code></dt><dd>生成 Filofax 风格双周概览日历 (<code>cal-tex-cursor-filofax-2week</code>) 。</dd>
<dt><code>t f W</code></dt><dd>生成 Filofax 风格单周概览日历 (<code>cal-tex-cursor-filofax-week</code>) 。</dd>
<dt><code>t y</code></dt><dd>生成年历 (<code>cal-tex-cursor-year</code>) 。</dd>
<dt><code>t Y</code></dt><dd>生成横向打印的年历 (<code>cal-tex-cursor-year-landscape</code>) 。</dd>
<dt><code>t f y</code></dt><dd>生成 Filofax 风格年历 (<code>cal-tex-cursor-filofax-year</code>) 。</dd>
</dl>

<p>
部分命令会横向打印日历（横版模式）；部分使用 Filofax 纸张尺寸（3.75in × 6.75in）。所有这些命令都接受前缀参数，用于指定要打印的天数、周数、月数或年数（从当前选中日期开始）。
</p>
<ul class="org-ul">
<li>若变量 <code>cal-tex-holidays</code> 为非 nil（默认 nil ），打印日历会显示 <code>calendar-holidays</code> 中的节假日。</li>
<li>若变量 <code>cal-tex-diary</code> 为非 nil（默认为 nil），会同时包含日记条目（仅支持月历、Filofax、ISO 周历）。</li>
<li>若变量 <code>cal-tex-rules</code> 为非 nil（默认为 nil），在空间足够的样式中会显示带行线的页面。</li>
</ul>

<p>
可查阅各个 <code>cal-tex</code> 函数的文档，了解哪些日历支持哪些功能。
</p>

<p>
如需，可使用变量 <code>cal-tex-preamble-extra</code> 在生成文档的导言区插入额外 LaTeX 命令。
</p>
</div>
</div>
<div id="outline-container-Holidays" class="outline-3">
<h3 id="Holidays"><span class="section-number-3">33.6.</span> 节假日显示</h3>
<div class="outline-text-3" id="text-Holidays">
<p>
Emacs 日历内置了众多大小节假日并可以显示它们。你可以在默认列表中添加自定义节假日。
</p>

<dl class="org-dl">
<dt><code>mouse-3</code> 鼠标右键 &#x2013;&gt; 'Holidays'</dt><dd></dd>

<dt><code>h</code></dt><dd>显示选中日期的节假日 (<code>calendar-cursor-holidays</code>) 。</dd>
<dt><code>x</code></dt><dd>在日历窗口中标记节假日(假日分布情况) (<code>calendar-mark-holidays</code>) 。</dd>
<dt><code>u</code></dt><dd>取消日历窗口中的标记 (<code>calendar-unmark</code>) 。</dd>
<dt><code>a</code></dt><dd>在另一个窗口列出当前显示三个月内的所有节假日 (<code>calendar-list-holidays</code>) 。</dd>
<dt><code>M-x holidays</code></dt><dd>在另一个窗口列出以今天为中心的三个月内的所有节假日。</dd>
<dt><code>M-x list-holidays</code></dt><dd>在另一个窗口列出指定年份范围内的节假日。</dd>
</dl>

<p>
想要查看某一天是否有节假日，在日历窗口中将光标移到该日期，然后使用 <code>h</code> (<code>calendar-cursor-holidays</code>) 命令。或者用 <code>mouse-3</code> 鼠标右键点击该日期，在弹出的菜单中选择 'Holidays' 。两种方式都会显示当天的节假日：内容较短则显示在回显区，较长则在独立窗口中显示。
</p>

<p>
想要查看当前日历中所有节假日的分布情况，使用 <code>x</code> (<code>calendar-mark-holidays</code>) 命令。该命令会用不同的字体高亮显示节假日日期，可参见 <a href="#Calendar-Customizing">calendar-holiday-marker</a> 。标记不仅作用于当前可见月份，也会作用于后续滚动显示出来的月份。输入 <code>u</code> (<code>calendar-unmark</code>) 可关闭标记并清除当前高亮，同时也会清除日记标记（见 “<a href="#Diary">日记</a>” 章节）。如果变量 <code>calendar-mark-holidays-flag</code> 设为非 nil，创建或更新日历时会自动标记节假日。
</p>

<p>
想要更详细的信息，可以使用 <code>a</code> (<code>calendar-list-holidays</code>) 命令，它会在独立缓冲区中列出当前三个月内的所有节假日。你可以在日历窗口中用 <code>SPC</code> 和 <code>DEL</code> 分别上下滚动该列表。
</p>

<p>
命令 <code>M-x holidays</code> 会显示当前月及前后各一个月的节假日列表；即使没有打开日历窗口也能使用。如果变量 <code>calendar-view-holidays-initially-flag</code> 设为非 nil，创建日历时会自动以这种方式显示节假日。如果想以其他月份为中心显示节假日，可以使用 <code>C-u M-x holidays</code> ，它会提示你输入月份和年份。
</p>

<p>
Emacs 已知的节假日包括 United States(美国节假日)，以及 Bahá’í(巴哈伊教)、Chinese(中国节日)、Christian(基督教)、Islamic(伊斯兰教)、Jewish(犹太教)主要节日；同时还包含solstices and equinoxes(冬至、夏至、春分、秋分)等节气。
</p>

<p>
命令 <code>M-x holiday-list</code> 会列出一段年份范围内的节假日。该函数会提示你输入起始年份和结束年份，并允许你选择查看全部节日或某一类节日。即使没有打开日历窗口，也可以使用该命令。
</p>

<p>
Emacs 所使用的节假日日期基于现行通用规则，而非严格历史事实。例如，退伍军人纪念日始于 1919 年，但在更早的年份里也会显示。
</p>
</div>
</div>
<div id="outline-container-Sunrise_002fSunset" class="outline-3">
<h3 id="Sunrise_002fSunset"><span class="section-number-3">33.7.</span> 日出日落时间</h3>
<div class="outline-text-3" id="text-Sunrise_002fSunset">
<p>
专用的日历命令可以为你精确到一两分钟内，显示任意日期的日出与日落时间。
</p>

<dl class="org-dl">
<dt><code>mouse-3 Sunrise/sunset</code></dt><dd></dd>

<dt><code>S</code></dt><dd>显示所选日期的日出与日落时间 (<code>calendar-sunrise-sunset</code>) 。</dd>
<dt><code>M-x sunrise-sunset</code></dt><dd>显示今天的日出与日落时间。</dd>
<dt><code>C-u M-x sunrise-sunset</code></dt><dd>显示指定日期的日出与日落时间。</dd>
<dt><code>M-x calendar-sunrise-sunset-month</code></dt><dd>显示所选月份每一天的日出与日落时间。</dd>
</dl>

<p>
在日历中，要在回显区显示某地的当地日出与日落时间，只需将光标移到目标日期，然后按 <code>S</code> (<code>calendar-sunrise-sunset</code>) 。你也可以在日期上单击鼠标 <code>mouse-3</code> ，然后在弹出的菜单中选择「Sunrise/sunset」。
</p>

<p>
在日历之外，可使用命令 <code>M-x sunrise-sunset</code> 查看今天或指定日期的信息。若要指定非今天的日期，使用 <code>C-u M-x sunrise-sunset</code> ，它会提示你输入年、月、日。
</p>

<p>
使用 <code>C-u C-u M-x sunrise-sunset</code> ，可以显示任意地点、任意日期的日出日落时间。该命令会依次询问你：经度、纬度、与世界协调时间（UTC）的分钟差、日期，然后显示该地在该日的日出日落时间。
</p>

<p>
由于日出日落时间取决于地球上的具体位置，使用这些命令前，你需要先告诉 Emacs 你的纬度、经度和位置名称。以下是设置示例：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq</span> calendar-latitude 40.1)
(<span style="color: #a020f0;">setq</span> calendar-longitude -88.2)
(<span style="color: #a020f0;">setq</span> calendar-location-name <span style="color: #8b2252;">"Urbana, IL"</span>)
</pre>
</div>
<p>
<code>calendar-latitude</code> 和 <code>calendar-longitude</code> 的值请使用一位小数。
</p>

<p>
时区也会影响当地的日出日落时间。Emacs 通常从操作系统获取时区信息，但如果这些值不符合你的需求（或操作系统未提供），你需要自行设置。示例：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq</span> calendar-time-zone -360)
(<span style="color: #a020f0;">setq</span> calendar-standard-time-zone-name <span style="color: #8b2252;">"CST"</span>)
(<span style="color: #a020f0;">setq</span> calendar-daylight-time-zone-name <span style="color: #8b2252;">"CDT"</span>)
</pre>
</div>

<p>
<code>calendar-time-zone</code> 的值是你当地标准时间与世界协调时间（又称 “格林威治时间”）的分钟差值。 <code>calendar-standard-time-zone-name</code> 和 <code>calendar-daylight-time-zone-name</code> 是你所在时区使用的标准时与夏令时缩写。Emacs 会根据夏令时对日出日落时间进行修正。夏令时的判定方式见「<a href="#Daylight-Saving">夏令时</a>」一节。
</p>

<p>
如果你希望显示数字形式的时区（如 "+0100"），而非符号缩写（如 "CET"），可将变量 <code>calendar-time-zone-style</code> 设为 <code>numeric</code> 。
</p>

<p>
作为用户，你可以在 <code>.emacs</code> 配置文件中设置常用地理位置的日历相关变量，方便使用。如果你是系统管理员，也可以在 <code>default.el</code> 中为所有用户统一设置这些变量。参见「<a href="#Init-File">Emacs 初始化文件</a>」。
</p>
</div>
</div>
<div id="outline-container-Lunar-Phases" class="outline-3">
<h3 id="Lunar-Phases"><span class="section-number-3">33.8.</span> 月相显示</h3>
<div class="outline-text-3" id="text-Lunar-Phases">
<p>
本节介绍的日历命令可显示月相（new moon新月、first quarter上弦月、full moon满月、last quarter下弦月）的日期与时间。该功能在调试与月相相关的问题时很有用。
</p>

<dl class="org-dl">
<dt><code>M</code></dt><dd>显示当前日历所展示的三个月期间内所有月相的日期与时间 (<code>calendar-lunar-phases</code>) 。</dd>
<dt><code>M-x lunar-phases</code></dt><dd>显示以今天为中心、前后共三个月的月相日期与时间。</dd>
</dl>

<p>
在日历界面内，使用命令 <code>M</code> (<code>calendar-lunar-phases</code>) 可在独立缓冲区中显示当前三个月范围内的月相。列出的日期与时间精度可达几分钟以内。
</p>

<p>
在日历界面外，使用命令 <code>M-x lunar-phases</code> 可显示本月、上月与下月的月相列表。如需查看其他月份，可使用 <code>C-u M-x lunar-phases</code> ，该命令会提示你输入月份与年份。
</p>

<p>
月相对应的日期与时间均以本地时间给出（必要时会做夏令时修正）。参见上一节的说明（<a href="#Sunrise_002fSunset">日出与日落时间</a>）。
</p>
</div>
</div>
<div id="outline-container-Other-Calendars" class="outline-3">
<h3 id="Other-Calendars"><span class="section-number-3">33.9.</span> 与其他日历系统的转换</h3>
<div class="outline-text-3" id="text-Other-Calendars">
<p>
Emacs 显示的日历始终是公历（ <i>Gregorian calendar格里高利历</i> ），也被称作 <i>New Style calendar新历</i> ，是当今世界大部分地区所使用的历法。但这种历法在 16 世纪之前并不存在，18 世纪之前也未被广泛使用；直到 20 世纪初，它才彻底取代儒略历并获得普遍认可。
</p>

<p>
Emacs 日历可以显示公元 1 年 1 月以来的任意月份，但 <b>显示的始终是公历</b> ，即便对于公历尚未出现的历史日期也是如此。
</p>

<p>
虽然 Emacs 不能直接显示其他历法，但可以在公历与 <b>其他多种历法之间进行日期转换</b> 。
</p>

<ul class="org-ul">
<li><a href="#Calendar-Systems">支持的日历系统</a></li>
<li><a href="#To-Other-Calendar">转换到其他日历系统</a></li>
<li><a href="#From-Other-Calendar">从其他日历系统转换</a></li>
</ul>
</div>
<div id="outline-container-Calendar-Systems" class="outline-4">
<h4 id="Calendar-Systems"><span class="section-number-4">33.9.1.</span> 支持的日历系统</h4>
<div class="outline-text-4" id="text-Calendar-Systems">
<p>
ISO 商业历常用于商业领域。
</p>

<p>
<i>Julian calendar儒略历</i> 以尤利乌斯・恺撒命名，是欧洲中世纪通用的历法，许多国家一直使用到 19 世纪。
</p>

<p>
天文学家使用一种简单的纪日方式：从儒略历公元前 4713 年 1 月 1 日星期一中午起累计经过的天数。这个累计天数称为儒略日数或天文日数。
</p>

<p>
<i>Hebrew calendar希伯来历</i> 是犹太教传统使用的历法。Emacs 日历使用希伯来历推算犹太教节日日期。希伯来历的日期以日落为起止点。
</p>

<p>
<i>Islamic calendar伊斯兰历</i> 在许多以伊斯兰教为主的国家使用。Emacs 用它推算伊斯兰教节日。伊斯兰世界对该历法并无完全统一的标准；Emacs 使用的是广为接受的版本，但伊斯兰教节日的确切日期通常由宗教权威宣告，而非仅依靠计算，因此实际庆祝日期可能与 Emacs 计算结果略有出入。伊斯兰历的日期以日落为起止点。
</p>

<p>
<i>French Revolutionary calendar法国共和历</i> 是雅各宾派在 1789 年法国大革命后制定的历法，旨在以更世俗、贴近自然的方式表达年度周期，并推行 10 天一旬的制度，类似公制度量衡的合理化改革。法国政府于 1805 年底正式废除该历法。
</p>

<p>
中美洲的玛雅人使用三套独立且相互重叠的历法： <i>long count长计历</i> 、 <i>tzolkin卓尔金历</i> 和 <i>haab哈布历</i> 。Emacs 支持这三种历法。玛雅历与现行公历的确切对应关系在专家中仍有争议；Emacs 在计算中采用古德曼–马丁内斯–汤普森对应法。
</p>

<p>
科普特历基于古埃及 <i>solar calendar太阳历</i> ，一年分为 12 个 30 天的月份，外加额外 5 天。每四年在这一额外时段中增加 1 天闰日，变为 6 天。埃塞俄比亚历结构与之相同，但年份与月份名称不同。
</p>

<p>
<i>Persians波斯历</i> 是基于莪默・伽亚谟设计的太阳历。一年 12 个月：前 6 个月各 31 天，中间 5 个月各 30 天，最后 1 个月平年 29 天、闰年 30 天。闰年以复杂的规律每 4 年或 5 年出现一次。此处实现的是比拉什克算术波斯历，以 2820 年为周期，与基于天文现象的天文波斯历不同。截至本文撰写时，预计首次差异将出现在 2025 年 3 月 20 日，届时伊朗官方将使用何种历法尚不清楚。
</p>

<p>
<i>Chinese calendar中国农历</i> 是一套复杂的阴阳合历，以阴历月配合阳历年。年份以 60 年为一周期；平年 12 个月，闰年 13 个月；每月 29 天或 30 天。年、普通月份和日期由 <i>ten celestial stems十天干</i> 与 <i>twelve terrestrial branches十二地支</i> 组合命名，共 60 个名称，以 60 为周期循环。
</p>

<p>
<i>Bahá’í calendar巴哈伊历</i> 以太阳年为基础，每年 19 个月，每月 19 天。剩余 4 天置于第 18 个月与第 19 个月之间，作为闰日。
</p>
</div>
</div>
<div id="outline-container-To-Other-Calendar" class="outline-4">
<h4 id="To-Other-Calendar"><span class="section-number-4">33.9.2.</span> 转换到其他日历系统</h4>
<div class="outline-text-4" id="text-To-Other-Calendar">
<p>
以下命令用于以其他各种历法显示选中的日期（光标所在日期）：
</p>

<dl class="org-dl">
<dt><code>mouse-3</code> &#x2013;&gt; Other calendars</dt><dd></dd>

<dt><code>p o</code></dt><dd>以其他多种历法显示选中的日期 (<code>calendar-print-other-dates</code>) 。</dd>
<dt><code>p c</code></dt><dd>显示选中日期对应的 <i>ISO commercial calendar ISO 商业历</i> 日期 (<code>calendar-iso-print-date</code>) 。</dd>
<dt><code>p j</code></dt><dd>显示选中日期的 <i>Julian儒略历</i> 日期 (<code>calendar-julian-print-date</code>) 。</dd>
<dt><code>p a</code></dt><dd>显示选中日期的 <i>astronomical (Julian) 天文（儒略）</i> 日数 (<code>calendar-astro-print-day-number</code>) 。</dd>
<dt><code>p h</code></dt><dd>显示选中日期的 <i>Hebrew希伯来历</i> 日期 (<code>calendar-hebrew-print-date</code>) 。</dd>
<dt><code>p i</code></dt><dd>显示选中日期的 <i>Islamic伊斯兰历</i> 日期 (<code>calendar-islamic-print-date</code>) 。</dd>
<dt><code>p f</code></dt><dd>显示选中日期的 <i>French Revolutionary法国共和历</i> 日期 (<code>calendar-french-print-date</code>) 。</dd>
<dt><code>p b</code></dt><dd>显示选中日期的 <i>Bahá’í巴哈伊历</i> 日期 (<code>calendar-bahai-print-date</code>) 。</dd>
<dt><code>p C</code></dt><dd>显示选中日期的 <i>Chinese中国农历</i> 日期 (<code>calendar-chinese-print-date</code>) 。</dd>
<dt><code>p k</code></dt><dd>显示选中日期的 <i>Coptic科普特历</i> 日期 (<code>calendar-coptic-print-date</code>) 。</dd>
<dt><code>p e</code></dt><dd>显示选中日期的 <i>Ethiopic埃塞俄比亚历</i> 日期 (<code>calendar-ethiopic-print-date</code>) 。</dd>
<dt><code>p p</code></dt><dd>显示选中日期的 <i>Persian波斯历</i> 日期 (<code>calendar-persian-print-date</code>) 。</dd>
<dt><code>p m</code></dt><dd>显示选中日期的 <i>Mayan玛雅历</i> 日期 (<code>calendar-mayan-print-date</code>) 。</dd>
</dl>

<p>
使用方法：将光标移动到要转换的日期，然后输入上表中以 <code>p</code> 开头的对应命令。前缀 <code>p</code> 是 “print（打印）” 的助记符，Emacs 会在回显区 “打印” 出对应日期。 <code>p o</code> (<code>calendar-print-other-dates</code>) 会以 Emacs 支持的所有历法格式显示该日期。
</p>

<p>
你也可以用鼠标右键（ <code>mouse-3</code> ）点击日期，然后在菜单中选择 'Other calendars' 。它会以菜单形式列出 Emacs 支持的所有历法下的对应日期。（从该菜单中选择某一项并不会执行其他操作，仅用于显示。）
</p>
</div>
</div>
<div id="outline-container-From-Other-Calendar" class="outline-4">
<h4 id="From-Other-Calendar"><span class="section-number-4">33.9.3.</span> 从其他日历系统转换</h4>
<div class="outline-text-4" id="text-From-Other-Calendar">
<p>
你可以使用 Emacs 支持的其他历法来指定要跳转到的日期。本节介绍玛雅历之外的历法跳转命令；玛雅历相关用法见下一节。
</p>

<dl class="org-dl">
<dt><code>g c</code></dt><dd>跳转到 ISO 商业历指定的日期 (<code>calendar-iso-goto-date</code>) 。</dd>
<dt><code>g w</code></dt><dd>跳转到 ISO 商业历指定的周 (<code>calendar-iso-goto-week</code>) 。</dd>
<dt><code>g j</code></dt><dd>跳转到 <i>Julian儒略历</i> 指定的日期 (<code>calendar-julian-goto-date</code>) 。</dd>
<dt><code>g a</code></dt><dd>根据天文（儒略）日数跳转到对应日期 (<code>calendar-astro-goto-day-number</code>) 。</dd>
<dt><code>g b</code></dt><dd>跳转到 <i>Bahá’í巴哈伊历</i> 指定的日期 (<code>calendar-bahai-goto-date</code>) 。</dd>
<dt><code>g h</code></dt><dd>跳转到 <i>Hebrew希伯来历</i> 指定的日期 (<code>calendar-hebrew-goto-date</code>) 。</dd>
<dt><code>g i</code></dt><dd>跳转到 <i>Islamic伊斯兰历</i> 指定的日期 (<code>calendar-islamic-goto-date</code>) 。</dd>
<dt><code>g f</code></dt><dd>跳转到 <i>French Revolutionary法国共和历</i> 指定的日期 (<code>calendar-french-goto-date</code>) 。</dd>
<dt><code>g C</code></dt><dd>跳转到 <i>Chinese中国农历</i> 指定的日期 (<code>calendar-chinese-goto-date</code>) 。</dd>
<dt><code>g p</code></dt><dd>跳转到 <i>Persian波斯历</i> 指定的日期 (<code>calendar-persian-goto-date</code>) 。</dd>
<dt><code>g k</code></dt><dd>跳转到 <i>Coptic科普特历</i> 指定的日期 (<code>calendar-coptic-goto-date</code>) 。</dd>
<dt><code>g e</code></dt><dd>跳转到 <i>Ethiopic埃塞俄比亚历</i> 指定的日期 (<code>calendar-ethiopic-goto-date</code>) 。</dd>
</dl>

<p>
这些命令会提示你输入其他历法的日期，然后将光标跳转到公历对应的日期，并在回显区显示该历法日期。当 Emacs 提示你输入月份名称时，会使用 <b>严格补全</b> （参见<a href="#Completion-Exit">补全退出</a>），因此你不必担心希伯来语、伊斯兰语或法语名称的拼写问题。
</p>

<p>
关于希伯来历的一个常见问题是计算忌日周年，称为雅尔茨伊特（yahrzeit）。Emacs 日历内置了相关计算功能：若已在日历中，命令 <code>M-x calendar-hebrew-list-yahrzeits</code> 会提示你输入年份范围，然后列出光标所在日期在这些年份里对应的雅尔茨伊特日期。
</p>

<p>
若不在日历中，该命令会先提示你输入忌日日期和年份范围，再显示对应的雅尔茨伊特日期列表。
</p>
</div>
</div>
</div>
<div id="outline-container-Diary" class="outline-3">
<h3 id="Diary"><span class="section-number-3">33.10.</span> 日记</h3>
<div class="outline-text-3" id="text-Diary">
<p>
Emacs 日记可以配合日历， <b>逐日记录日程安排或其他事件</b> 。要使用日记功能，必须先创建一个日记文件，写明事件及其日期。之后 Emacs 就能自动筛选并显示 <b>今天、近期或任意指定日期</b> 的事件。
</p>

<p>
虽然你通常会先手动创建日记，但 Emacs 还提供了一系列命令，用于查看、添加和修改日记条目。
</p>

<ul class="org-ul">
<li><a href="#Format-of-Diary-File">日记文件</a></li>
<li><a href="#Displaying-the-Diary">显示日记</a></li>
<li><a href="#Date-Formats">日期格式</a></li>
<li><a href="#Adding-to-Diary">添加日记条目的命令</a></li>
<li><a href="#Special-Diary-Entries">特殊日记条目</a></li>
<li><a href="#Appointments">约会提醒</a></li>
<li><a href="#Importing-Diary">日记条目的导入与导出</a></li>
</ul>
</div>
<div id="outline-container-Format-of-Diary-File" class="outline-4">
<h4 id="Format-of-Diary-File"><span class="section-number-4">33.10.1.</span> 日记文件</h4>
<div class="outline-text-4" id="text-Format-of-Diary-File">
<p>
<i>diary file日记文件</i> 用于记录与特定日期相关的事件。日记文件名由变量 <code>diary-file</code> 指定，默认为 <code>~/.emacs.d/diary</code> ；为兼容旧版本，若存在 <code>~/diary</code> ，Emacs 会优先使用它。
</p>

<p>
日记文件中的每一项记录描述一个事件，由一行或多行组成。每条记录 <b>必须以日期格式顶格开头</b> ，其余内容为事件描述。如果记录超过一行，从第二行开始必须以 <b>空白字符</b> 开头，表示续行。不以有效日期开头、也不是续行的行会被忽略。示例：
</p>

<div class="org-src-container">
<pre class="src src-shell">12/22/2015  &#32467;&#23130;&#20108;&#21313;&#21608;&#24180;&#32426;&#24565;&#26085;&#65281;
10/22       Ruth &#30340;&#29983;&#26085;&#12290;
* 21, *:    &#21457;&#34218;&#26085;
Tuesday--&#27599;&#21608;&#19978;&#21320;10&#28857;&#19982;&#30740;&#31350;&#29983;&#20363;&#20250;
         Supowit, Shen, Bitner, &#21644; Kapoor &#21442;&#21152;&#12290;
1/13/89     &#40657;&#33394;&#26143;&#26399;&#20116;&#65281;
thu 4pm     &#19982; Lloyd &#25171;&#22721;&#29699;&#12290;
mar 16      &#29240;&#29240;&#30340;&#29983;&#26085;
April 15, 2016 &#25253;&#31246;&#25130;&#27490;&#12290;
* 15        &#32771;&#21220;&#34920;&#25130;&#27490;&#12290;
</pre>
</div>


<p>
本例用额外空格对齐大部分条目的事件描述，这种格式纯属个人习惯。
</p>

<p>
你也可以使用这种格式：日记条目第一行 <b>只写日期或星期</b> （后面无空格或标点），例如：
</p>

<div class="org-src-container">
<pre class="src src-shell">02/11/2012
      Bill B. &#20170;&#26085;&#35775;&#38382;&#26222;&#26519;&#26031;&#39039;
      2pm &#35748;&#30693;&#30740;&#31350;&#22996;&#21592;&#20250;&#20250;&#35758;
      2:30&#8211;5:30 Liz &#22312;&#21171;&#20262;&#26031;&#32500;&#23572;
      4:00pm &#29273;&#21307;&#39044;&#32422;
      7:30pm &#22312; George &#23478;&#26202;&#39184;
      8:00&#8211;10:00pm &#38899;&#20048;&#20250;
</pre>
</div>

<p>
如果使用简易日记显示模式，这种条目会隐藏开头的日期行，只显示续行内容。该风格在只查看单日记录时更整洁，但同时显示多天记录时容易混淆。
</p>
</div>
</div>
<div id="outline-container-Displaying-the-Diary" class="outline-4">
<h4 id="Displaying-the-Diary"><span class="section-number-4">33.10.2.</span> 显示日记</h4>
<div class="outline-text-4" id="text-Displaying-the-Diary">
<p>
创建日记文件后，你可以通过日历查看日记内容，也可以在非日历模式下查看当天事件。以下按键绑定均针对日历缓冲区。
</p>

<dl class="org-dl">
<dt><code>mouse-3 Diary</code></dt><dd></dd>

<dt><code>d</code></dt><dd>显示所选日期的所有日记条目 (<code>diary-view-entries</code>) 。</dd>
<dt><code>s</code></dt><dd>显示整个日记文件 (<code>diary-show-all-entries</code>) 。</dd>
<dt><code>m</code></dt><dd>标记所有包含日记条目的可见日期 (<code>diary-mark-entries</code>) 。</dd>
<dt><code>u</code></dt><dd>取消日历窗口中的标记 (<code>calendar-unmark</code>) 。</dd>
<dt><code>M-x diary-print-entries</code></dt><dd>将当前显示的日记内容打印输出。</dd>
<dt><code>M-x diary</code></dt><dd>显示今天日期的所有日记条目。</dd>
<dt><code>M-x diary-mail-entries</code></dt><dd>向自己发送即将到来的日记条目邮件提醒。</dd>
</dl>

<p>
使用 <code>d</code> (<code>diary-view-entries</code>) 显示日记条目时，会在独立缓冲区中展示日历中所选日期的日记内容。新缓冲区的模式行会显示日记条目的日期。节假日会显示在缓冲区或模式行中，具体取决于你选择的显示方式（见<a href="#Diary-Display">日记显示</a>）。如果为 <code>d</code> 指定数字前缀参数，则会显示连续对应天数的所有日记条目。例如， <code>2 d</code> 会显示所选日期及次日的所有条目。
</p>

<p>
另一种显示某日期日记条目的方法是：在日期上单击鼠标右键 <code>mouse-3</code> ，然后在弹出菜单中选择 'Diary entries' 。如果变量 <code>calendar-view-diary-initially-flag</code> 设为非 nil，则创建日历时会自动列出当前日期的日记条目（前提是当前日期可见）。
</p>

<p>
若要更直观地查看日记中涉及哪些日期，可使用 <code>m</code> (<code>diary-mark-entries</code>) 命令。该命令会用不同的外观标记出有日记条目的日期。详见 <a href="#Calendar-Customizing">diary-entry-marker</a>。
</p>

<p>
该命令不仅作用于当前可见的月份，也会作用于滚动后后续显示的月份。输入 <code>u</code> (<code>calendar-unmark</code>) 可关闭标记并清除当前标记，同时也会取消节假日标记（见<a href="#Holidays">节假日</a>）。如果变量 <code>calendar-mark-diary-entries-flag</code> 设为非 nil，则创建或刷新日历时会自动标记日记日期。
</p>

<p>
若要让某条日记条目 <b>不在日历上标记日期</b> ，可在条目开头、日期之前插入变量 <code>diary-nonmarking-symbol</code> 指定的字符串（默认为 '<code>&amp;</code>' ）。这对日记缓冲区中的条目显示没有影响，只影响日历中的日期标记。无需标记的条目对于通用条目很有用，否则会标记许多不同日期。
</p>

<p>
若要查看完整日记文件而非部分条目，可使用 <code>s</code> (<code>diary-show-all-entries</code>) 命令。
</p>

<p>
命令 <code>M-x diary</code> 可独立于日历显示当前日期的日记条目，还可选择性显示未来几天的内容；变量 <code>diary-number-of-entries</code> 用于指定包含的天数。详见 <a href="#Diary-Customizing">diary-number-of-entries</a>。
</p>

<p>
如果在 <code>.emacs</code> 文件中加入 (diary)，启动 Emacs 时会自动显示包含当日日记条目的窗口。
</p>

<p>
部分用户希望通过邮件接收日记事件通知。使用 <code>M-x diary-mail-entries</code> 可向自己发送此类邮件。前缀参数指定检查的天数（从今天开始）；否则由变量 <code>diary-mail-days</code> 指定天数。
</p>
</div>
</div>
<div id="outline-container-Date-Formats" class="outline-4">
<h4 id="Date-Formats"><span class="section-number-4">33.10.3.</span> 日期格式</h4>
<div class="outline-text-4" id="text-Date-Formats">
<p>
下面是一些日记条目示例，展示不同的日期写法。示例均使用美式日期格式（月/日/年），但日历模式也支持欧式格式（日/月/年）和 ISO 格式（年/月/日）。
</p>

<div class="org-src-container">
<pre class="src src-shell">4/20/12    &#20999;&#25442;&#21040;&#26032;&#30340;&#21046;&#34920;&#31995;&#32479;
apr. 25    &#24320;&#22987;&#32479;&#35745;&#24180;&#24230;&#32467;&#26524;
4/30      &#22235;&#26376;&#32467;&#26524;&#25552;&#20132;&#25130;&#27490;
*/25      &#26376;&#24230;&#21608;&#26399;&#32467;&#26463;
Friday    &#22791;&#20221;&#25991;&#20214;&#20877;&#31163;&#24320;
</pre>
</div>

<p>
第一条只在 2012 年 4 月 20 日出现一次。第二条和第三条每年指定日期生效。第四条月份用通配符（星号 '*'），表示每月 25 号生效。最后一条每周星期五生效。
</p>

<p>
你可以只用数字表示日期，格式为 'month/day' 或 'month/day/year' ，后面必须跟非数字字符。月份和日期可以是 1～2 位数字，年份可省略前两位，如 '11/12/2012' 或 '11/12/12' 。
</p>

<p>
日期也可以写成：'<code>monthname day</code>' 或 '<code>monthname day, year</code>' 月份名可全写或缩写（可带点号）。月份和星期的缩写方式可通过变量 <code>calendar-abbrev-length</code> 、 <code>calendar-month-abbrev-array</code> 、 <code>calendar-day-abbrev-array</code> 设置。默认使用前 3 个字母，大小写不敏感。
</p>

<p>
日期可以是 <b>通用日期</b> （部分不指定），表示匹配所有符合条件的日期。不写年份即表示每一年都生效。月份、日期、年份都可以用 '<code>*</code>' 表示任意。例如： '<code>3/*/*</code>' 或 '<code>march *</code>' 表示任意年份 3 月的每一天。
</p>

<p>
如果你更喜欢欧式日期（日在前，月在后）或 ISO 格式（年 / 月 / 日），可以在日历时执行 <code>M-x calendar-set-date-style</code> ，或自定义变量 <code>calendar-date-style</code> 。这会影响日记日期的解析、显示以及部分命令的参数顺序。
</p>

<p>
你可以直接用星期几作为通用日期，表示每周这一天都生效。星期名可全写或缩写，大小写不敏感。
</p>
</div>
</div>
<div id="outline-container-Adding-to-Diary" class="outline-4">
<h4 id="Adding-to-Diary"><span class="section-number-4">33.10.4.</span> 添加日记条目的命令</h4>
<div class="outline-text-4" id="text-Adding-to-Diary">
<p>
在日历界面中，可以使用多个命令来创建日记条目。这里列出基础命令；更高级的命令见下一节（<a href="#Special-Diary-Entries">特殊日记条目</a>）。日记条目也可以基于非公历创建，参见<a href="#Non_002dGregorian-Diary">使用非公历的日记条目</a>。
</p>

<dl class="org-dl">
<dt><code>i d</code></dt><dd>为选中的日期添加一条日记条目 (<code>diary-insert-entry</code>) 。</dd>
<dt><code>i w</code></dt><dd>为选中的星期几添加每周重复的日记条目 (<code>diary-insert-weekly-entry</code>) 。</dd>
<dt><code>i m</code></dt><dd>为选中的日期添加每月重复的日记条目 (<code>diary-insert-monthly-entry</code>) 。</dd>
<dt><code>i y</code></dt><dd>为选中的日期添加每年重复的日记条目 (<code>diary-insert-yearly-entry</code>) 。</dd>
</dl>

<p>
你可以在日历窗口中选中某个日期，然后按 <code>i d</code> (<code>diary-insert-entry</code>) 为该日期创建日记条目。此命令会在另一个窗口中打开日记文件末尾并插入日期，之后你可以输入条目剩余内容。
</p>

<p>
如果想创建 <b>每周固定星期几</b> 重复的条目，选中该星期的任意一天，按 <code>i w</code> (<code>diary-insert-weekly-entry</code>) 。它会将该星期几作为通用日期插入，你再补充后续内容。每月重复的条目用法类似：选中日期，使用 <code>i m</code> (<code>diary-insert-monthly-entry</code>) ，然后输入条目内容。同样，你可以用 <code>i y</code> (<code>diary-insert-yearly-entry</code>) 插入每年重复的日记条目。
</p>

<p>
以上所有命令默认创建 <b>会在日历上标记</b> 的日记条目。如果要创建不标记的条目，给命令加上前缀参数。例如： <code>C-u i w</code> 创建一个不标记的每周重复日记条目。
</p>

<p>
修改日记文件后，退出 Emacs 前请记得保存。使用上述插入命令后保存日记文件，会自动更新日历窗口里的日记标记（如适用）。你也可以随时使用命令 <code>calendar-redraw</code> 强制刷新。
</p>
</div>
</div>
<div id="outline-container-Special-Diary-Entries" class="outline-4">
<h4 id="Special-Diary-Entries"><span class="section-number-4">33.10.5.</span> 特殊日记条目</h4>
<div class="outline-text-4" id="text-Special-Diary-Entries">
<p>
除了基于公历日期的条目，日记文件还可以包含 Lisp 表达式（sexp）条目，用于记录周年纪念日等周期性事件。这类条目以 '<code>%%</code>' 开头，后接一对括号包裹的 Lisp 表达式，由 Emacs 求值来判断该条目适用于哪些日期。
</p>

<p>
日历模式提供了插入常用表达式条目的命令：
</p>
<dl class="org-dl">
<dt><code>i a</code></dt><dd>为选中日期添加周年纪念日日记条目 (<code>diary-insert-anniversary-entry</code>) 。</dd>
<dt><code>i b</code></dt><dd>为当前选中区域添加连续时间段日记条目 (<code>diary-insert-block-entry</code>) 。</dd>
<dt><code>i c</code></dt><dd>从指定日期开始添加循环周期日记条目 (<code>diary-insert-cyclic-entry</code>) 。</dd>
</dl>

<p>
如果要为某个特定日期创建纪念日日记条目，将光标移到该日期并使用 <code>i a</code> (<code>diary-insert-anniversary-entry</code>) 命令。该命令会在另一个窗口显示日记文件末尾并插入纪念日描述，你只需补充剩余内容即可。条目格式示例：
</p>

<div class="org-src-container">
<pre class="src src-shell">%%(diary-anniversary 10 31 1988) Arthur<span style="color: #8b2252;">'s birthday</span>
</pre>
</div>

<p>
该条目在 1988 年之后的每年 10 月 31 日生效；'10 31 1988' 为起始日期。（若使用欧洲或 ISO 日历格式，月、日、年的输入顺序会不同。）要求填写起始年份，是为了让高级日记功能可以计算已过去的周年数。
</p>

<p>
连续日期块日记条目 适用于一段连续日期。示例：2012 年 6 月 24 日至 2012 年 7 月 10 日全部生效：
</p>

<div class="org-src-container">
<pre class="src src-shell">%%(diary-block 6 24 2012 7 10 2012) Vacation
</pre>
</div>

<p>
'6 24 12' 为起始日期， '7 10 12' 为结束日期。（若使用欧洲或 ISO 日历格式，月、日、年顺序不同。）
</p>

<p>
插入块条目时，将光标和标记分别设在起止日期上，然后按 <code>i b</code> (<code>diary-insert-block-entry</code>)。命令会在另一窗口打开日记文件末尾并插入块描述，你再补充完整条目即可。
</p>

<p>
周期性日记条目 按固定天数重复。选中起始日期后使用 <code>i c</code> (<code>diary-insert-cyclic-entry</code>) ，命令会提示输入间隔天数，生成类似如下条目：
</p>

<div class="org-src-container">
<pre class="src src-shell">%%(diary-cyclic 50 3 1 2012) Renew medication
</pre>
</div>

<p>
该条目从 2012 年 3 月 1 日开始，每 50 天重复一次。（欧洲 / ISO 日历格式下日期输入顺序不同。）
</p>

<p>
以上三条命令默认生成带标记的日记条目。若要插入不带标记的条目，给命令加上前缀参数即可。例如： <code>C-u i a</code> 插入无标记的纪念日日记条目。
</p>

<p>
在日历中标记表达式日记条目可能比较耗时，因为日历窗口中每个可见日期都要单独判断。因此建议尽可能将表达式条目设为无标记（用 '<code>&amp;</code>'）。
</p>

<p>
另一种高级表达式条目是浮动日记条目，它通过日、周、月的偏移量来指定定期事件，功能类似于 <code>cron</code> 工具的定时任务。下面是一条无标记、匹配每年 11 月第四个星期四的浮动日记条目：
</p>

<div class="org-src-container">
<pre class="src src-shell">&amp;%%(diary-float 11 4 4) American Thanksgiving
</pre>
</div>
<ul class="org-ul">
<li>第 1 个 11：表示 11 月（第 11 个月）</li>
<li>第 1 个 4：表示星期四（周日为 0，依次计数）</li>
<li>第 2 个 4：表示第四个（1 = 第一个，2 = 第二个，-2 = 倒数第二个，依此类推）</li>
</ul>

<p>
月份可以是单个月份或月份列表。例如将 11 改为 ‘'(1 2 3)’ ，条目就会匹配 1、2、3 月的第四个星期四。若月份为 <code>t</code> ，则条目全年每个月都生效。示例：每月第三个星期四的后两天（即星期六）开会：
</p>

<div class="org-src-container">
<pre class="src src-shell">%%(diary-offset <span style="color: #8b2252;">'(diary-float t 3 4) 2) Monthly committee meeting</span>
</pre>
</div>

<p>
2 表示在 <code>'(diary-float t 3 4)</code> 匹配的日期之后再顺延 2 天。这在跨时区会议、定期活动顺延等场景中非常实用。
</p>

<p>
所有标准表达式日记条目都支持一个可选参数，用于指定在日历中标记时使用的外观（face）或单个字符。更通用地，表达式日记条目可以通过任意计算来决定生效日期。详见：<a href="#Sexp-Diary-Entries">表达式条目与高级日记显示</a>
</p>
</div>
</div>
<div id="outline-container-Appointments" class="outline-4">
<h4 id="Appointments"><span class="section-number-4">33.10.6.</span> 约会提醒</h4>
<div class="outline-text-4" id="text-Appointments">
<p>
如果你的某条日记条目对应一个预约，并且该条目以可识别的时刻开头，Emacs 可以 <b>提前提醒</b> 你即将到来的预约。Emacs 会按照变量 <code>appt-display-format</code> 指定的格式显示提醒消息。如果变量 <code>appt-audible</code> 不为 nil，提醒还会包含 <b>声音提示</b> 。此外，如果 <code>appt-display-mode-line</code> 不为 nil，Emacs 会在 <b>模式行</b> 上显示距离预约还有多少分钟。
</p>

<p>
如果 <code>appt-display-format</code> 的值为 <code>window</code> ，则变量 <code>appt-display-duration</code> 控制提醒窗口的显示时长；变量 <code>appt-disp-window-function</code> 和 <code>appt-delete-window-function</code> 分别指定用于创建和销毁提醒窗口的函数。
</p>

<p>
要启用预约提醒功能，输入 <code>M-x appt-activate</code> 。
</p>
<ul class="org-ul">
<li>带正数值前缀参数：启用提醒</li>
<li>带负数值前缀参数：禁用提醒</li>
<li>不带参数：切换启用 / 禁用状态</li>
</ul>

<p>
启用提醒时，Emacs 还会从日记文件中生成 <b>今日预约列表</b> ，提取所有带可识别时刻的日记条目，并在每个预约即将到来时提醒你。
</p>

<p>
例如，假设日记文件包含以下内容：
</p>

<div class="org-src-container">
<pre class="src src-shell">Monday
  9:30am Coffee break
 12:00pm Lunch
</pre>
</div>

<p>
那么每周一，你会在上午约 9:20 收到休息提醒，约 11:50 收到午餐提醒。变量 <code>appt-message-warning-time</code> 指定提前多少分钟提醒（默认为 12 分钟）。这是全局默认提醒时间。每个预约可以通过匹配 <code>appt-warning-time-regexp</code> 的片段单独指定提醒时间（详情见该变量的文档）。
</p>

<p>
你可以使用 12 小时制（12:00am 表示午夜，12:00pm 表示中午）或 24 小时制 书写时间，两种格式可以混用。时刻必须写在日记条目 <b>开头</b> ，才能被系统识别。
</p>

<p>
Emacs 会在午夜过后自动从日记文件更新当日预约列表。你也可以通过重新启用预约提醒来 <b>手动强制更新</b> 。除非将 <code>appt-display-diary</code> 设为 <code>nil</code> ，否则上述操作都会显示当天的日记缓冲区。每当日记文件（或其包含的文件，见<a href="#Fancy-Diary-Display">高级日记显示</a>）被保存时，预约列表也会自动更新。如果你使用 Org 模式并在 Org 议程文件中记录预约，可以使用 <code>org-agenda-to-appt</code> 命令将这些预约加入提醒列表，相关内容参见《Org 手册》中的 “<a href="https://www.gnu.org/software/emacs/manual/html_node/org/Weekly_002fdaily-agenda.html#Weekly_002fdaily-agenda">预约提醒</a>” 一节。
</p>

<p>
你还可以把预约提醒功能当作 <b>闹钟</b> 使用。
</p>
<ul class="org-ul">
<li>命令 <code>M-x appt-add</code> ：直接向预约列表添加条目，不修改日记文件。</li>
<li>命令 <code>M-x appt-delete</code> ：从预约列表中删除条目。</li>
</ul>
</div>
</div>
<div id="outline-container-Importing-Diary" class="outline-4">
<h4 id="Importing-Diary"><span class="section-number-4">33.10.7.</span> 日记条目的导入与导出</h4>
<div class="outline-text-4" id="text-Importing-Diary">
<p>
你可以在 Emacs 日记文件与多种其他格式之间互相转换日记条目。
</p>

<p>
可以从 Outlook 生成的预约邮件中 <b>导入</b> 日记条目。在 Rmail 或 Gnus 中查看此类邮件时，执行 <code>M-x diary-from-outlook</code> 即可导入条目。通过自定义变量 <code>diary-outlook-formats</code> ，可以让该命令识别更多预约邮件格式。其他邮件客户端可将 <code>diary-from-outlook-function</code> 设置为合适的值。
</p>

<p>
icalendar 包支持在 Emacs 日记文件与 iCalendar 文件之间交换数据，iCalendar 格式定义于 <i>RFC 2445《互联网日历与日程安排核心对象规范（iCalendar）》</i> （同时也兼容更早的 vCalendar 格式）。
</p>

<p>
命令 <code>icalendar-import-buffer</code> 从当前缓冲区提取 iCalendar 数据并添加到你的日记文件中。该函数也适用于自动提取 iCalendar 数据；例如在 Rmail 中可以这样配置：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'rmail-show-message-hook 'icalendar-import-buffer)
</pre>
</div>

<p>
命令 <code>icalendar-import-file</code> 导入一个 iCalendar 文件并将结果添加到 Emacs 日记文件中。示例：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(icalendar-import-file <span style="color: #8b2252;">"/here/is/calendar.ics"</span>
                       <span style="color: #8b2252;">"/there/goes/ical-diary"</span>)
</pre>
</div>

<p>
你可以使用 <code>#include</code> 指令将导入文件的内容加入主日记文件（如果二者不是同一个文件）。详见「<a href="#Fancy-Diary-Display">高级日记显示</a>」。
</p>

<p>
使用 <code>icalendar-export-file</code> 可交互式地将整个 Emacs 日记文件 <b>导出</b> 为 iCalendar 格式。如果只想导出日记文件的一部分，先标记相应区域，再调用 <code>icalendar-export-region</code> 。两种方式下，Emacs 都会将结果追加到目标文件末尾。
</p>
</div>
</div>
</div>
<div id="outline-container-Daylight-Saving" class="outline-3">
<h3 id="Daylight-Saving"><span class="section-number-3">33.11.</span> 夏令时</h3>
<div class="outline-text-3" id="text-Daylight-Saving">
<p>
Emacs 能够区分标准时间与 <i>daylight夏令时</i> —— 日出、日落、二至点、二分点以及月相的计算时间都会把夏令时考虑在内。夏令时规则因地而异，且在历史上不同年份也会发生变化。要正确计算，Emacs 需要知道应采用哪套规则。
</p>

<p>
部分操作系统会记录你所在地区适用的夏令时规则；在这类系统上，Emacs 会自动从系统获取所需信息。如果这些信息部分或全部缺失，Emacs 会使用美国马萨诸塞州剑桥市当前采用的规则来补足。若得到的规则不符合你的需求，可以通过设置以下变量来指定 Emacs 使用的规则： <code>calendar-daylight-savings-starts</code> 和 <code>calendar-daylight-savings-ends</code> 。
</p>

<p>
这些变量的值应当是引用了变量 <code>year</code> 的 Lisp 表达式，求值后得到夏令时开始或结束的公历日期，格式为列表 <code>(月份 日期 年份)</code> 。如果你所在地区不使用夏令时，应将其值设为 <code>nil</code> 。
</p>

<p>
Emacs 使用这些表达式来确定节假日列表中的夏令时起始日期，并修正日月相关计算中的时刻。
</p>

<p>
马萨诸塞州剑桥市的对应取值如下：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(calendar-nth-named-day 2 0 3 year)
(calendar-nth-named-day 1 0 11 year)
</pre>
</div>

<p>
含义为：当年 3 月（第 3 个月）的第 2 个星期日（第 0 天），以及当年 11 月（第 11 个月）的第 1 个星期日。
</p>

<p>
如果要把夏令时改为从 10 月 1 日开始，可将 <code>calendar-daylight-savings-starts</code> 设置为：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(list 10 1 year)
</pre>
</div>

<p>
如果你所在地区 <b>不使用夏令时</b> ，或希望所有时间都按标准时间计算，可将 <code>calendar-daylight-savings-starts</code> 和 <code>calendar-daylight-savings-ends</code> 都设为 <code>nil</code> 。
</p>

<p>
变量 <code>calendar-daylight-time-offset</code> 用于指定夏令时与标准时间的差值，单位为分钟。马萨诸塞州剑桥市的该值为 60。
</p>

<p>
最后，两个变量 <code>calendar-daylight-savings-starts-time</code> 和 <code>calendar-daylight-savings-ends-time</code> 分别指定：在当地时间午夜过后多少分钟，发生进入或退出夏令时的切换。马萨诸塞州剑桥市这两个变量的值均为 120
</p>
</div>
</div>
<div id="outline-container-Time-Intervals" class="outline-3">
<h3 id="Time-Intervals"><span class="section-number-3">33.12.</span> 时间间隔求和</h3>
<div class="outline-text-3" id="text-Time-Intervals">
<p>
timeclock（时间计时）包可以对时间间隔进行求和，方便你（例如）跟踪在特定项目上花费的时间。（更高级的替代方案是使用 Org 模式的计时功能，参见《Org 手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/org/Clocking-Work-Time.html#Clocking-Work-Time">工作时间计时</a>」。）
</p>

<p>
开始处理一个项目时使用 <code>M-x timeclock-in</code> ，完成时使用 <code>M-x timeclock-out</code> 。每次操作都会为该项目的记录添加一个时间间隔。你可以使用 <code>M-x timeclock-change</code> 切换到另一个项目。
</p>

<p>
在积累了多个时间间隔数据后，你可以：
</p>
<ul class="org-ul">
<li>使用 <code>M-x timeclock-workday-remaining</code> 查看今天还需要工作多长时间（默认按每天 8 小时计算）。</li>
<li>使用 <code>M-x timeclock-when-to-leave</code> 计算可以下班的时间。</li>
</ul>

<p>
如果你希望 Emacs 在模式行中显示当日剩余工作时长，可以：
</p>
<ul class="org-ul">
<li>自定义变量 <code>timeclock-mode-line-display</code> 并将其设为 <code>t</code> ；</li>
<li>或者直接执行命令 <code>M-x timeclock-mode-line-display</code> 。</li>
</ul>

<p>
关闭当前 Emacs 会话是否意味着你已停止工作，默认情况下 Emacs 会向你询问。你可以将变量 <code>timeclock-ask-before-exiting</code> 设为 <code>nil</code> 来关闭这个询问；这样，只有显式执行 <code>M-x timeclock-out</code> 或 <code>M-x timeclock-change</code> 才会结束当前计时。
</p>

<p>
timeclock 功能会把数据保存在文件 <code>~/.emacs.d/timelog</code> 中。你可以通过自定义变量 <code>timeclock-file</code> 来指定其他文件名。
</p>

<p>
如果你手动编辑了时间日志文件，或修改了 timeclock 的任何可自定义变量，应当执行命令 <code>M-x timeclock-reread-log</code> ，让 Emacs 从文件重新加载并更新数据。
</p>
</div>
</div>
<div id="outline-container-Advanced-Calendar_002fDiary-Usage" class="outline-3">
<h3 id="Advanced-Calendar_002fDiary-Usage"><span class="section-number-3">33.13.</span> 日历与日记的高级功能</h3>
<div class="outline-text-3" id="text-Advanced-Calendar_002fDiary-Usage">
<p>
本节介绍日历与日记的一些更高级、更专用的功能。首先介绍你可以用来自定义日历和日记、使其符合个人使用习惯的多种方式。
</p>

<ul class="org-ul">
<li><a href="#Calendar-Customizing">定制日历</a></li>
<li><a href="#Holiday-Customizing">定制节假日</a></li>
<li><a href="#Mayan-Calendar">玛雅日历转换</a></li>
<li><a href="#Date-Display-Format">日期显示格式</a></li>
<li><a href="#Time-Display-Format">时间显示格式</a></li>
<li><a href="#Diary-Customizing">定制日记</a></li>
<li><a href="#Non_002dGregorian-Diary">使用非公历的日记条目</a></li>
<li><a href="#Diary-Display">日记显示</a></li>
<li><a href="#Fancy-Diary-Display">高级日记显示</a></li>
<li><a href="#Sexp-Diary-Entries">Sexp 条目与高级日记显示</a></li>
</ul>
</div>
<div id="outline-container-Calendar-Customizing" class="outline-4">
<h4 id="Calendar-Customizing"><span class="section-number-4">33.13.1.</span> 定制日历</h4>
<div class="outline-text-4" id="text-Calendar-Customizing">
<p>
遗憾的是，日历显示无法从三个月的布局改为其他形式，但你可以通过设置以下变量来自定义空白间距： <code>calendar-left-margin</code> 、 <code>calendar-day-header-width</code> 、 <code>calendar-day-digit-width</code> 、 <code>calendar-column-width</code> 以及 <code>calendar-intermonth-spacing</code> 。若要在月份之间显示文本（例如周数），可按照文档说明自定义变量 <code>calendar-intermonth-header</code> 和 <code>calendar-intermonth-text</code> 。
</p>

<p>
变量 <code>calendar-month-header</code> 控制日历中每个月份上方显示的文本，默认显示月份与年份。变量 <code>calendar-day-header-array</code> 控制每个月中每日列上方显示的文本，默认显示每周日期名称的前两个字母。
</p>

<p>
变量 <code>calendar-holiday-marker</code> 指定如何标记节假日日期，其值可以是一个单字符字符串（显示在日期旁），也可以是用于渲染日期的样式（face）名称。同样，变量 <code>diary-entry-marker</code> 指定如何标记含有日记条目的日期。函数 <code>calendar-mark-today</code> 使用 <code>calendar-today-marker</code> 来标记当天日期。默认情况下，日历分别使用名为 holiday、diary 和 calendar-today 的样式来实现这些标记。
</p>

<p>
启动日历时会运行常规钩子 <code>calendar-initial-window-hook</code> ，重新计算日历显示时不会运行该钩子。但如果你使用 <code>q</code> 命令退出日历后再次进入，该钩子会重新运行。
</p>

<p>
变量 <code>calendar-today-visible-hook</code> 是一个常规钩子，当日历缓冲区已准备好、且当前日期在窗口中可见时运行。该钩子的一种用途是标记当天日期，可使用以下任一函数实现： <code>calendar-mark-today</code> 或 <code>calendar-star-date</code> ：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'calendar-today-visible-hook 'calendar-mark-today)
</pre>
</div>

<p>
与之类似的常规钩子 <code>calendar-today-invisible-hook</code> 会在当前日期不在窗口中可见时运行。
</p>

<p>
每一个日历光标移动命令都会在移动光标之后运行钩子 <code>calendar-move-hook</code> 。
</p>
</div>
</div>
<div id="outline-container-Holiday-Customizing" class="outline-4">
<h4 id="Holiday-Customizing"><span class="section-number-4">33.13.2.</span> 定制节假日</h4>
<div class="outline-text-4" id="text-Holiday-Customizing">
<p>
Emacs 内置了多个列出默认节假日的变量，它们分别是： <code>holiday-general-holidays</code> 、 <code>holiday-local-holidays</code> 、 <code>holiday-solar-holidays</code> 、 <code>holiday-bahai-holidays</code> 、 <code>holiday-christian-holidays</code> 、 <code>holiday-hebrew-holidays</code> 、 <code>holiday-islamic-holidays</code> 、 <code>holiday-oriental-holidays</code> 和 <code>holiday-other-holidays</code> 。这些变量名含义一目了然；例如 <code>holiday-solar-holidays</code> 列出与太阳、月亮相关的节假日。
</p>

<p>
你可以根据自身需求自定义这些节假日列表，按照下面的说明删除或添加节假日。将其中任意变量设为 <code>nil</code> 即可不显示对应的节假日。
</p>

<p>
<b>通用节假日</b> 默认是全美国通用的节假日。相比之下， <code>holiday-local-holidays</code> 和 <code>holiday-other-holidays</code> 默认均为空，分别用于 <b>系统级设置</b> 和 <b>个人自定义</b> 。
</p>

<p>
默认情况下，Emacs 不会包含它所支持的所有宗教节日，只包含世俗日历中常见的那些。如需显示更完整的宗教节假日，可以将以下一个或全部变量设为 <code>t</code> ： <code>calendar-bahai-all-holidays-flag</code> 、 <code>calendar-christian-all-holidays-flag</code> 、 <code>calendar-hebrew-all-holidays-flag</code> 或 <code>calendar-islamic-all-holidays-flag</code> 。
</p>

<p>
每个节假日变量都是一个 <b>节假日格式（holiday form）</b> 列表，每个格式描述一个（或一组）节假日。下表列出所有可用的节假日格式。日期与月份从 1 开始计数，但星期几从周日为 0 开始。参数 <i>string</i> 始终是节假日的描述字符串。
</p>

<dl class="org-dl">
<dt><code>(holiday-fixed month day string)</code></dt><dd>公历中的固定日期。</dd>

<dt><code>(holiday-float month dayname k string &amp;optional day)</code></dt><dd>公历月份 month、日期 day 前后的第 k 个星期 dayname（0 = 周日，依此类推）。k 为负数表示从月末倒数。可选参数 day 在 k 为正时默认为 1，为负时默认为当月最后一天。</dd>

<dt><code>(holiday-chinese month day string)</code></dt><dd>农历中的固定日期。</dd>
<dt><code>(holiday-hebrew month day string)</code></dt><dd>希伯来历中的固定日期。</dd>
<dt><code>(holiday-islamic month day string)</code></dt><dd>伊斯兰历中的固定日期。</dd>
<dt><code>(holiday-julian month day string)</code></dt><dd>儒略历中的固定日期。</dd>
<dt><code>(holiday-sexp sexp string)</code></dt><dd>由 Lisp 表达式 sexp 计算出的日期。该表达式应使用变量 <code>year</code> 计算并返回节假日日期，格式为列表 <code>(month day year)</code> ；若当年无该节日则返回 <code>nil</code> 。</dd>
<dt><code>(if condition holiday-form)</code></dt><dd>仅当 <i>condition</i> 为真时才生效的节假日。</dd>
<dt><code>(function [args])</code></dt><dd>由函数 <i>function</i> 调用参数 <i>args</i> 计算得到的日期列表。</dd>
</dl>

<p>
示例: 例如，你想添加法国 7 月 14 日的巴士底日，可以这样写：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq</span> holiday-other-holidays '((holiday-fixed 7 14 <span style="color: #8b2252;">"Bastille Day"</span>)))
</pre>
</div>

<p>
许多节日在每月某个特定星期几。以下是维尔京群岛 7 月第四个周一的 “飓风祈祷日”：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(holiday-float 7 1 4 <span style="color: #8b2252;">"Hurricane Supplication Day"</span>)
</pre>
</div>

<p>
这里 7 = 七月，1 = 周一（0 = 周日，2 = 周二），4 = 当月第四个。1 = 第一个，-1 = 最后一个，-2 = 倒数第二个，依此类推。
</p>

<p>
你也可以指定巴哈伊、农历、希伯来历、伊斯兰历、儒略历的固定节日，例如：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq</span> holiday-other-holidays
      '((holiday-hebrew 10 2 <span style="color: #8b2252;">"Last day of Hanukkah"</span>)
        (holiday-islamic 3 12 <span style="color: #8b2252;">"Mohammed's Birthday"</span>)
        (holiday-julian 4 2 <span style="color: #8b2252;">"Jefferson's Birthday"</span>)))
</pre>
</div>

<p>
添加了光明节最后一天（因为希伯来历的月份从尼散月开始计为 1）、纪念穆罕默德诞辰的伊斯兰节日（因为伊斯兰历的月份从穆哈兰姆月开始计为 1），以及托马斯・杰斐逊的生日 —— 按儒略历计算为 1743 年 4 月 2 日。
</p>

<p>
如需 <b>条件生效</b> 的节日，可使用 Emacs Lisp 的 <code>if</code> 或 <code>holiday-sexp</code> 。例如，美国总统选举在能被 4 整除的年份 11 月第一个周一之后的第一个周二：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(holiday-sexp '(if (zerop (% year 4))
                   (calendar-gregorian-from-absolute
                    (1+ (calendar-dayname-on-or-before
                          1 (+ 6 (calendar-absolute-from-gregorian
                                  (list 11 1 year)))))))
              <span style="color: #8b2252;">"US Presidential Election"</span>)
</pre>
</div>

<p>
或：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">if</span> (zerop (% displayed-year 4))
    (holiday-fixed 11
           (calendar-extract-day
             (calendar-gregorian-from-absolute
               (1+ (calendar-dayname-on-or-before
                     1 (+ 6 (calendar-absolute-from-gregorian
                              (list 11 1 displayed-year)))))))
           <span style="color: #8b2252;">"US Presidential Election"</span>))
</pre>
</div>

<p>
有些节日无法用上述格式表示，因为需要特殊计算。这种情况下你需要编写 Lisp 函数。例如添加日食、月食，可在 <code>holiday-other-holidays</code> 中加入 <code>(eclipses)</code> ，并编写函数 <code>eclipses</code> 返回公历日期与描述的列表，格式如下：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(((6 4 2012) <span style="color: #8b2252;">"Lunar Eclipse"</span>) ((11 13 2012) <span style="color: #8b2252;">"Solar Eclipse"</span>) ... )
</pre>
</div>
</div>
</div>
<div id="outline-container-Mayan-Calendar" class="outline-4">
<h4 id="Mayan-Calendar"><span class="section-number-4">33.13.3.</span> 玛雅日历转换</h4>
<div class="outline-text-4" id="text-Mayan-Calendar">
<p>
以下是基于玛雅日历选择日期的命令：
</p>

<dl class="org-dl">
<dt><code>g m l</code></dt><dd>跳转到由长计历指定的日期 (<code>calendar-mayan-goto-long-count-date</code>) 。</dd>
<dt><code>g m n t</code></dt><dd>跳转到卓尔金历中下一个出现的指定日期 (<code>calendar-mayan-next-tzolkin-date</code>) 。</dd>
<dt><code>g m p t</code></dt><dd>跳转到卓尔金历中上一个出现的指定日期 (<code>calendar-mayan-previous-tzolkin-date</code>) 。</dd>
<dt><code>g m n h</code></dt><dd>跳转到哈布历中下一个出现的指定日期 (<code>calendar-mayan-next-haab-date</code>) 。</dd>
<dt><code>g m p h</code></dt><dd>跳转到哈布历中上一个出现的指定日期 (<code>calendar-mayan-previous-haab-date</code>) 。</dd>
<dt><code>g m n c</code></dt><dd>跳转到日历轮中下一个出现的指定组合日期 (<code>calendar-mayan-next-calendar-round-date</code>) 。</dd>
<dt><code>g m p c</code></dt><dd>跳转到日历轮中上一个出现的指定组合日期 (<code>calendar-mayan-previous-calendar-round-date</code>) 。</dd>
</dl>

<p>
要理解这些命令，你需要了解玛雅历法。长计历是按以下单位对天数进行计数：
</p>
<div class="org-src-container">
<pre class="src src-shell">1 &#37329;&#65288;kin&#65289; = 1 &#22825;       1 &#32500;&#32435;&#23572;&#65288;uinal&#65289; = 20 &#37329;     1 &#21534;&#65288;tun&#65289; = 18 &#32500;&#32435;&#23572;
1 &#21345;&#21534;&#65288;katun&#65289; = 20 &#21534;   1 &#24052;&#20811;&#21534;&#65288;baktun&#65289; = 20 &#21345;&#21534;
</pre>
</div>

<p>
因此，长计历日期 12.16.11.16.6 表示：12 巴克吞、16 卡吞、11 吞、16 维纳尔、6 金。Emacs 日历可处理最早为 7.17.18.13.3 的玛雅长计历日期，更早则不支持。使用 <code>g m l</code> 命令时，请以点号分隔baktun, katun, tun, uinal, and kin的方式输入玛雅长计历日期。
</p>

<p>
玛雅 <b>卓尔金历（tzolkin）</b> 是由 13 天和 20 天两个独立周期组成的 260 天循环。由于该周期无限循环，Emacs 提供了在周期中向前、向后跳转的命令。输入 <code>g m p t</code> 可跳转到上一个卓尔金日期；Emacs 会提示你输入一个卓尔金日期，并将光标移至该日期上一次出现的位置。同理，输入 <code>g m n t</code> 可跳转到该日期下一次出现的位置。
</p>

<p>
玛雅 <b>哈布历（haab）</b> 是 365 天的循环，分为 18 个月，每月 20 天，最后再加 5 天无月份时段。与卓尔金历类似，该周期也无限循环，同样提供向前、向后跳转命令。输入 <code>g m p h</code> 可跳转到上一个哈布日期；Emacs 会提示你输入哈布日期，并将光标移至该日期上一次出现的位置。同理，输入 <code>g m n h</code> 可跳转到该日期下一次出现的位置。
</p>

<p>
玛雅人还会将卓尔金历与哈布历结合使用。这种组合形成约 52 年的周期，称为日历轮（calendar round）。输入 <code>g m p c</code> 时，Emacs 会同时要求你输入哈布日期与卓尔金日期，然后将光标移至该组合上一次出现的位置。使用 <code>g m n c</code> 可跳转到该组合下一次出现的位置。若你输入的哈布 / 卓尔金日期组合在历法中不合法，这些命令会报错。
</p>

<p>
每当 Emacs 要求你输入玛雅名称时，都会使用 <b>严格补全</b> （见<a href="#Completion-Exit">补全退出</a>），因此你不必担心拼写问题。
</p>
</div>
</div>
<div id="outline-container-Date-Display-Format" class="outline-4">
<h4 id="Date-Display-Format"><span class="section-number-4">33.13.4.</span> 日期显示格式</h4>
<div class="outline-text-4" id="text-Date-Display-Format">
<p>
你可以通过设置 <code>calendar-date-display-form</code> 来自定义日期在日记、模式行和消息中的显示方式。该变量是一个表达式列表，表达式中可以使用以下变量：
</p>
<ul class="org-ul">
<li>month、day、year：均为字符串形式的数字</li>
<li>monthname、dayname：均为字母形式的字符串</li>
</ul>

<p>
美式风格下，该列表的默认值如下：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">((<span style="color: #a020f0;">if</span> dayname (concat dayname <span style="color: #8b2252;">", "</span>)) monthname <span style="color: #8b2252;">" "</span> day <span style="color: #8b2252;">", "</span> year)
</pre>
</div>

<p>
而欧式风格的默认值为：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">((<span style="color: #a020f0;">if</span> dayname (concat dayname <span style="color: #8b2252;">", "</span>)) day <span style="color: #8b2252;">" "</span> monthname <span style="color: #8b2252;">" "</span> year)
</pre>
</div>

<p>
ISO 日期的默认表示形式为：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">((format <span style="color: #8b2252;">"%s-%.2d-%.2d"</span> year (string-to-number month)
         (string-to-number day)))
</pre>
</div>

<p>
另一种常见的美式格式为：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(month <span style="color: #8b2252;">"/"</span> day <span style="color: #8b2252;">"/"</span> (substring year -2))
</pre>
</div>
</div>
</div>
<div id="outline-container-Time-Display-Format" class="outline-4">
<h4 id="Time-Display-Format"><span class="section-number-4">33.13.5.</span> 时间显示格式</h4>
<div class="outline-text-4" id="text-Time-Display-Format">
<p>
日历与日记默认采用美式常规时间格式显示时刻，即小时为 1–12、后跟分钟，并标注 am（上午）或 pm（下午）。若你偏好欧洲制式（在美国也称为军用时间），即小时采用 00–23 的 24 小时制，可以修改变量 <code>calendar-time-display-form</code> 。
</p>

<p>
该变量是一个表达式列表，可使用以下变量：
</p>
<ul class="org-ul">
<li>12-hours、24-hours、minutes：均为字符串形式的数字</li>
<li>am-pm、time-zone：均为字母字符串</li>
</ul>

<p>
默认取值为：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(12-hours <span style="color: #8b2252;">":"</span> minutes am-pm
          (<span style="color: #a020f0;">if</span> time-zone <span style="color: #8b2252;">" ("</span>) time-zone (<span style="color: #a020f0;">if</span> time-zone <span style="color: #8b2252;">")"</span>))
</pre>
</div>
<p>
以下取值可实现欧洲制式时间：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(24-hours <span style="color: #8b2252;">":"</span> minutes
          (<span style="color: #a020f0;">if</span> time-zone <span style="color: #8b2252;">" ("</span>) time-zone (<span style="color: #a020f0;">if</span> time-zone <span style="color: #8b2252;">")"</span>))
</pre>
</div>

<p>
注意：目前只有极少数日历函数会返回具体时刻（现阶段仅有太阳相关函数）。
</p>
</div>
</div>
<div id="outline-container-Diary-Customizing" class="outline-4">
<h4 id="Diary-Customizing"><span class="section-number-4">33.13.6.</span> 定制日记</h4>
<div class="outline-text-4" id="text-Diary-Customizing">
<p>
通常情况下，日记窗口会在模式行或缓冲区本身中，标注日记条目对应日期的节假日。检查节假日的过程可能较慢，具体取决于已定义的节假日数量。此时，将 <code>diary-show-holidays-flag</code> 设置为 <code>nil</code> 可以加快日记显示速度。
</p>

<p>
变量 <code>diary-number-of-entries</code> 用于控制一次显示多少天的日记条目。它会影响 <code>calendar-view-diary-initially-flag</code> 为 <code>t</code> 时的初始显示，以及命令 <code>M-x diary</code> 的行为。例如：值为 1（默认）时，只显示当天的日记条目；值为 2 时，还会显示次日的条目。该变量的值也可以是一个包含 7 个整数的向量。例如，值为 <code>[0 2 2 2 2 4 1]</code> 时：
</p>
<ul class="org-ul">
<li>周日不显示任何日记条目；</li>
<li>周一至周四显示当天及次日的日记条目；</li>
<li>周五显示周五到下周一的条目；</li>
<li>周六只显示当天的条目。</li>
</ul>

<p>
你可以通过设置变量 <code>diary-date-forms</code> 来自定义日记文件中的日期格式。该变量是一个用于识别日期的模式列表。每个日期模式都是一个列表，其元素可以是：
</p>
<ul class="org-ul">
<li>正则表达式（详见《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Regular-Expressions.html#Regular-Expressions">正则表达式</a>）；</li>
<li>或符号：month、day、year、monthname、dayname。</li>
</ul>

<p>
所有这些元素都作为模式，匹配日记文件中的特定文本。只有当所有元素连续匹配时，整个日期模式才算匹配成功。
</p>

<p>
日期模式中的正则表达式按常规方式匹配，使用经过调整的标准语法表，其中 '<code>*</code>' 被视为词构成成分。
</p>

<p>
符号 month、day、year、monthname、dayname 分别匹配：月份数字、日期数字、年份数字、月份名称、星期名称。匹配数字的符号允许前导零；匹配名称的符号允许大小写与缩写（由 <code>calendar-month-abbrev-array</code> 和 <code>calendar-day-abbrev-array</code> 指定）。所有符号都可以匹配 '<code>*</code>' ；因为日记条目中的 '<code>*</code>' 表示 “任意日”“任意月” 等，无论当前日期是什么都应匹配。
</p>

<p>
美式风格下 <code>diary-date-forms</code> 的默认值由 <code>diary-american-date-forms</code> 提供：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">((month <span style="color: #8b2252;">"/"</span> day <span style="color: #8b2252;">"[</span><span style="color: #8b2252;">^</span><span style="color: #8b2252;">/0-9]"</span>)
 (month <span style="color: #8b2252;">"/"</span> day <span style="color: #8b2252;">"/"</span> year <span style="color: #8b2252;">"[</span><span style="color: #8b2252;">^</span><span style="color: #8b2252;">0-9]"</span>)
 (monthname <span style="color: #8b2252;">" *"</span> day <span style="color: #8b2252;">"[</span><span style="color: #8b2252;">^</span><span style="color: #8b2252;">,0-9]"</span>)
 (monthname <span style="color: #8b2252;">" *"</span> day <span style="color: #8b2252;">", *"</span> year <span style="color: #8b2252;">"[</span><span style="color: #8b2252;">^</span><span style="color: #8b2252;">0-9]"</span>)
 (dayname <span style="color: #8b2252;">"\\W"</span>))
</pre>
</div>

<p>
变量 <code>diary-european-date-forms</code> 和 <code>diary-iso-date-forms</code> 提供其他默认风格。
</p>

<p>
列表中的日期模式必须 <b>互斥</b> ，且 <b>只能匹配日期和一个空白字符</b> ，不能匹配日记条目本身的内容。如果为了互斥，模式必须匹配日期结束空白之外的日记条目内容，则日期模式的 <b>第一个元素必须是 backup</b> 。这会让日期识别器在匹配完成后，回退到日记条目当前词的开头。即使使用 backup，日期模式也绝对不能匹配日记条目第一个词以外的内容。
</p>

<p>
例如， <code>diary-european-date-forms</code> 的默认值为：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">((day <span style="color: #8b2252;">"/"</span> month <span style="color: #8b2252;">"[</span><span style="color: #8b2252;">^</span><span style="color: #8b2252;">/0-9]"</span>)
 (day <span style="color: #8b2252;">"/"</span> month <span style="color: #8b2252;">"/"</span> year <span style="color: #8b2252;">"[</span><span style="color: #8b2252;">^</span><span style="color: #8b2252;">0-9]"</span>)
 (backup day <span style="color: #8b2252;">" *"</span> monthname <span style="color: #8b2252;">"\\W+\\&lt;</span><span style="color: #8b2252; font-weight: bold;">\\</span><span style="color: #8b2252; font-weight: bold;">(</span><span style="color: #8b2252;">[</span><span style="color: #8b2252;">^</span><span style="color: #8b2252;">*0-9]</span><span style="color: #8b2252; font-weight: bold;">\\</span><span style="color: #8b2252; font-weight: bold;">|</span><span style="color: #8b2252; font-weight: bold;">\\</span><span style="color: #8b2252; font-weight: bold;">(</span><span style="color: #8b2252;">[0-9]+[:aApP]</span><span style="color: #8b2252; font-weight: bold;">\\</span><span style="color: #8b2252; font-weight: bold;">)</span><span style="color: #8b2252; font-weight: bold;">\\</span><span style="color: #8b2252; font-weight: bold;">)</span><span style="color: #8b2252;">"</span>)
 (day <span style="color: #8b2252;">" *"</span> monthname <span style="color: #8b2252;">" *"</span> year <span style="color: #8b2252;">"[</span><span style="color: #8b2252;">^</span><span style="color: #8b2252;">0-9]"</span>)
 (dayname <span style="color: #8b2252;">"\\W"</span>))
</pre>
</div>

<p>
注意第三个模式中使用了 <code>backup</code> ，因为它需要匹配日期之外的部分词内容，以便与第四个模式区分开。
</p>
</div>
</div>
<div id="outline-container-Non_002dGregorian-Diary" class="outline-4">
<h4 id="Non_002dGregorian-Diary"><span class="section-number-4">33.13.7.</span> 使用非公历的日记条目</h4>
<div class="outline-text-4" id="text-Non_002dGregorian-Diary">
<p>
除基于标准公历的条目外，你的日记还可使用巴哈伊历、农历、希伯来历或伊斯兰历日期。不过，识别这类条目可能比较耗时；且由于大多数用户并不使用，你必须显式启用该功能。例如，若希望日记识别希伯来历日期条目，需添加如下配置：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'diary-nongregorian-listing-hook 'diary-hebrew-list-entries)
(add-hook 'diary-nongregorian-marking-hook 'diary-hebrew-mark-entries)
</pre>
</div>

<p>
同理，要启用伊斯兰历、巴哈伊历、农历条目，可分别添加：
</p>
<ul class="org-ul">
<li>伊斯兰历： <code>diary-islamic-list-entries</code> 、 <code>diary-islamic-mark-entries</code></li>
<li>巴哈伊历： <code>diary-bahai-list-entries</code> 、 <code>diary-bahai-mark-entries</code></li>
<li>农历： <code>diary-chinese-list-entries</code> 、 <code>diary-chinese-mark-entries</code></li>
</ul>

<p>
这类日记条目的格式与公历条目基本一致，区别在于需要在日期前添加对应历法的标识：
</p>
<ul class="org-ul">
<li>巴哈伊历： <code>diary-bahai-entry-symbol</code> （默认为 B）</li>
<li>农历： <code>diary-chinese-entry-symbol</code> （默认为 C）</li>
<li>希伯来历： <code>diary-hebrew-entry-symbol</code> （默认为 H）</li>
<li>伊斯兰历： <code>diary-islamic-entry-symbol</code> （默认为 I）</li>
</ul>

<p>
此外，非公历月份名称不允许缩写（因为前三个字母通常不唯一）。（同时注意：若要表示平年希伯来历的亚达月，必须写作 "Adar I"。）
</p>

<p>
示例：希伯来历 Heshvan 25 日的日记条目可写作：
</p>

<div class="org-src-container">
<pre class="src src-shell">HHeshvan 25 Happy Hebrew birthday!
</pre>
</div>

<p>
该条目会在对应希伯来历 Heshvan 25 的公历日期当天显示。伊斯兰历 Dhu al-Qada 25 日的日记条目示例：
</p>

<div class="org-src-container">
<pre class="src src-shell">IDhu al-Qada 25 Happy Islamic birthday!
</pre>
</div>

<p>
与公历条目一样，如果在非公历条目前加上 <code>diary-nonmarking-symbol</code> （默认为 '<code>&amp;</code>' ），则该条目不做标记显示。
</p>

<p>
下表为在日历中创建巴哈伊历、农历、希伯来历、伊斯兰历日记条目的命令：
</p>


<dl class="org-dl">
<dt><code>i h d</code></dt><dd>diary-hebrew-insert-entry</dd>
<dt><code>i h m</code></dt><dd>diary-hebrew-insert-monthly-entry</dd>
<dt><code>i h y</code></dt><dd>diary-hebrew-insert-yearly-entry</dd>
<dt><code>i i d</code></dt><dd>diary-islamic-insert-entry</dd>
<dt><code>i i m</code></dt><dd>diary-islamic-insert-monthly-entry</dd>
<dt><code>i i y</code></dt><dd>diary-islamic-insert-yearly-entry</dd>
<dt><code>i B d</code></dt><dd>diary-bahai-insert-entry</dd>
<dt><code>i B m</code></dt><dd>diary-bahai-insert-monthly-entry</dd>
<dt><code>i B y</code></dt><dd>diary-bahai-insert-yearly-entry</dd>
<dt><code>i C d</code></dt><dd>diary-chinese-insert-entry</dd>
<dt><code>i C m</code></dt><dd>diary-chinese-insert-monthly-entry</dd>
<dt><code>i C y</code></dt><dd>diary-chinese-insert-yearly-entry</dd>
<dt><code>i C a</code></dt><dd>diary-chinese-insert-anniversary-entry</dd>
</dl>

<p>
这些命令的用法与普通日记条目命令类似：作用于光标所在的日历日期，并在日记文件末尾仅插入日期部分，之后你需要手动补充条目内容。
</p>
<ul class="org-ul">
<li>基础命令：为指定的非公历日期创建条目</li>
<li>'monthly' 命令：每月对应非公历日创建条目</li>
<li>'yearly' 命令：每年对应非公历月、日创建条目</li>
</ul>
</div>
</div>
<div id="outline-container-Diary-Display" class="outline-4">
<h4 id="Diary-Display"><span class="section-number-4">33.13.8.</span> 日记显示</h4>
<div class="outline-text-4" id="text-Diary-Display">
<p>
<i>diary日记</i> 显示的工作流程是：先生成日记条目列表，再运行由变量 <code>diary-display-function</code> 指定的函数。其默认值 <code>diary-fancy-display</code> 会将日记条目与节假日复制到一个仅用于显示的专用缓冲区中进行展示。将条目复制到独立缓冲区，可以对显示内容进行美化处理 —— 例如按日期对条目进行排序。
</p>

<p>
默认情况下，精美日记缓冲区 <b>不会显示没有任何日记条目的日期</b> ，即便当天是节假日。如果你希望在缓冲区中显示这些空白日期，可将变量 <code>diary-list-include-blanks</code> 设置为 <code>t</code> 。
</p>

<p>
精美日记缓冲区会自动启用查看模式（View mode）。
</p>

<p>
另一种显示方式 <code>diary-simple-display</code> 则直接显示 <b>真实的日记缓冲区</b> ，并通过隐藏文本的方式隐藏不相关的条目。节假日信息会显示在模式行中。这种方式的优点是：你可以直接编辑缓冲区，并将修改保存到日记文件中。但它不如精美显示方式灵活，例如无法对条目排序。另一个缺点是隐藏文本可能造成困扰：比如选中区域复制时，可能会包含隐藏的文本；而且由于你看到的日记缓冲区是 “经过伪装” 的，直接打印缓冲区可能与屏幕显示不一致。
</p>

<p>
因此，Emacs 提供了专门用于按所见效果打印日记的命令： <code>M-x diary-print-entries</code> 该命令对两种显示方式都有效；不过在精美显示模式下，你也可以像普通缓冲区一样直接打印。
</p>

<p>
若要打印一周的逐日日记录：将光标定位到该周第一天，输入 <code>7 d</code> ，然后执行 <code>M-x diary-print-entries</code> 。和之前一样，显示节假日会略微降低速度，你可以将 <code>diary-show-holidays-flag</code> 设置为 <code>nil</code> 来加快速度。
</p>

<p>
该命令会创建一个临时缓冲区，只包含日记缓冲区中当前可见的条目。与简单显示不同，这些无关条目是真正被移除，而不只是隐藏。创建完缓冲区后，会运行钩子 <code>diary-print-entries-hook</code> 。该钩子的默认行为是使用 <code>lpr-buffer</code> 命令直接将内容发送到打印机（参见 “<a href="#Printing">打印硬拷贝</a>”）。如果你想使用其他命令进行打印，只需修改这个钩子的值。你也可以用它实现其他功能，例如按日期和时间重新排序行。
</p>

<p>
你可以在简单显示的日记窗口中编辑条目，但要记住：当前显示的缓冲区实际上是完整的日记文件，只是部分内容被隐藏了。这意味着，例如 <code>C-f</code> (<code>forward-char</code>) 可能会把光标移到看起来是行尾、但实际是某隐藏行中间的位置。
</p>

<p>
<i>在简单显示模式下编辑日记时请格外小心！</i> 在可见行中间插入行或增删字符通常不会有问题，但在行尾编辑可能达不到预期效果。删除一行时，可能会同时删除其后隐藏的其他条目。在简单日记缓冲区编辑前，建议先按 <code>s</code> (<code>diary-show-all-entries</code>) 显示整个文件。
</p>
</div>
</div>
<div id="outline-container-Fancy-Diary-Display" class="outline-4">
<h4 id="Fancy-Diary-Display"><span class="section-number-4">33.13.9.</span> 高级日记显示</h4>
<div class="outline-text-4" id="text-Fancy-Diary-Display">
<p>
以下功能仅在精美日记显示模式下生效。
</p>

<p>
你可以使用常规钩子 <code>diary-list-entries-hook</code> ，将每天的日记条目按当天时间排序。配置方法如下：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'diary-list-entries-hook 'diary-sort-entries t)
</pre>
</div>

<p>
这样会对每天中以可识别时间开头的日记条目按时间排序，不带时间的条目排在最前面。注意排序命令放在钩子列表的末尾，以防前面的钩子函数改变了日记条目顺序或新增内容。
</p>

<p>
你可以在日记条目中书写注释：只需将变量 <code>diary-comment-start</code> 和 <code>diary-comment-end</code> 设置为用于界定注释的字符串即可。精美显示模式不会显示注释内容。你可以在注释中存放供其他扩展包使用的元信息（例如提醒包 appointment，参见「<a href="#Appointments">提醒</a>」相关内容）。
</p>

<p>
主日记文件可以 <b>包含其他文件</b> 。这允许多人共享一份适用于所有人的公共日记文件。在日记文件中，以 <code>diary-include-string</code> 开头的行：
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">include "filename"</span>
</pre>
</div>

<p>
会将文件 <i>filename</i> 中的日记条目包含到精美日记缓冲区中。该包含机制支持 <b>递归</b> ，即被包含的文件还可以继续包含其他文件（当然要注意避免循环包含）。启用包含功能的配置：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'diary-list-entries-hook 'diary-include-other-diary-files)
(add-hook 'diary-mark-entries-hook 'diary-mark-included-diary-files)
</pre>
</div>

<p>
包含机制仅在精美日记显示模式下有效，因为简单日记显示模式是直接从你的日记文件中展示条目。
</p>
</div>
</div>
<div id="outline-container-Sexp-Diary-Entries" class="outline-4">
<h4 id="Sexp-Diary-Entries"><span class="section-number-4">33.13.10.</span> Sexp 条目与高级日记显示</h4>
<div class="outline-text-4" id="text-Sexp-Diary-Entries">
<p>
Sexp 格式日记条目不仅能设置复杂的生效条件，还能实现更多功能。在日记文件中，Sexp 条目必须以 <code>diary-sexp-entry-symbol</code> （默认为 '%%' ）开头。在精美日记显示模式下，Sexp 条目可以根据日期自动生成条目文本。
</p>

<p>
例如，纪念日日记条目可以将纪念日至今的年数插入到条目中。下面这条日记条目中的 '%d' ：
</p>

<div class="org-src-container">
<pre class="src src-shell">%%(diary-anniversary 10 31 1948) Arthur<span style="color: #8b2252;">'s birthday (%d years old)</span>
</pre>
</div>
<p>
会被替换为年龄。因此在 1990 年 10 月 31 日，精美日记缓冲区中会显示为：
</p>

<div class="org-src-container">
<pre class="src src-shell">Arthur<span style="color: #8b2252;">'s birthday (42 years old)</span>
</pre>
</div>
<p>
如果日记文件中是这样写：
</p>

<div class="org-src-container">
<pre class="src src-shell">%%(diary-anniversary 10 31 1948) Arthur<span style="color: #8b2252;">'s %d%s birthday</span>
</pre>
</div>
<p>
那么 1990 年 10 月 31 日的显示效果为：
</p>

<div class="org-src-container">
<pre class="src src-shell">Arthur<span style="color: #8b2252;">'s 42nd birthday</span>
</pre>
</div>
<p>
同理，循环日记条目可以插入已重复的次数：
</p>

<div class="org-src-container">
<pre class="src src-shell">%%(diary-cyclic 50 1 1 2012) Renew medication (%d%s time)
</pre>
</div>
<p>
在 2012 年 9 月 7 日的精美日记显示中会变成：
</p>

<div class="org-src-container">
<pre class="src src-shell">Renew medication (5th time)
</pre>
</div>
<p>
还有一种提前提醒的 Sexp 日记函数，它不仅在事件当天显示条目，还会在之前的日期显示。例如，想在纪念日提前一周提醒：
</p>

<div class="org-src-container">
<pre class="src src-shell">%%(diary-remind <span style="color: #8b2252;">'(diary-anniversary 12 22 1968) 7) Ed'</span>s anniversary
</pre>
</div>

<p>
精美日记会在12 月 15 日和 12 月 22 日都显示 Ed's anniversary。
</p>

<p>
函数 <code>diary-date</code> 用于匹配由月、日、年组合描述的日期，每个部分可以是：整数、整数列表或 t（表示所有值）。例如：
</p>

<div class="org-src-container">
<pre class="src src-shell">%%(diary-date <span style="color: #8b2252;">'(10 11 12) 22 t) Rake leaves</span>
</pre>
</div>
<p>
会让精美日记在每年 10、11、12 月的 22 日都显示：
</p>

<div class="org-src-container">
<pre class="src src-shell">Rake leaves
</pre>
</div>

<p>
函数 <code>diary-float</code> 可用于描述相对日期，例如 “11 月第三个周五”“4 月最后一个周二”。参数为：month、dayname、序号 n。条目会出现在当月 1 日之后的第 n 个指定星期。
</p>
<ul class="org-ul">
<li>dayname：0 = 周日，1 = 周一，依此类推</li>
<li>n 为负时，从月末倒数计数</li>
<li>月份可以是列表、单个月或 t（所有月份） 例如：</li>
</ul>

<div class="org-src-container">
<pre class="src src-shell">%%(diary-float t 1 -1) Pay rent
</pre>
</div>
<p>
表示每个月最后一个周一显示：
</p>

<div class="org-src-container">
<pre class="src src-shell">Pay rent
</pre>
</div>

<p>
Sexp 日记条目的通用性极强，任何能用算法描述的规则都可以实现。Sexp 条目包含一个表达式，用于计算该条目是否适用于给定日期：
</p>
<ul class="org-ul">
<li>表达式返回非 nil → 当天显示</li>
<li>表达式返回 nil → 当天不显示</li>
<li>表达式中可使用变量 date 获取当前判断的日期，格式为公历列表 <code>(月 日 年)</code> 。</li>
</ul>

<p>
表达式返回非 nil 时，部分值有特殊含义：返回字符串：该字符串作为当天事件的描述。返回 <code>(mark . string)</code> ： mark 控制日历中日期的标记方式，string 是事件描述。
</p>
<ul class="org-ul">
<li>mark 为单个字符：显示在日期旁</li>
<li>mark 为 Face 名称：用该样式显示日期</li>
<li>mark 为 nil：不特殊高亮</li>
</ul>

<p>
举个实用例子：如果每月 21 日是工作日就发工资，若是周末则提前到上一个周五。对应的 Sexp 条目：
</p>

<div class="org-src-container">
<pre class="src src-shell">&amp;%%(<span style="color: #483d8b;">let</span> ((dayname (calendar-day-of-week date))
         (day (cadr date)))
      (or (and (= day 21) (memq dayname <span style="color: #8b2252;">'(1 2 3 4 5)))
          (and (memq day '</span>(19 20)) (= dayname 5)))
         ) Pay check deposited
</pre>
</div>

<p>
以下 Sexp 日记条目可在精美日记显示中根据日期动态生成内容：
</p>
<dl class="org-dl">
<dt><code>%%(diary-sunrise-sunset)</code></dt><dd>生成条目，显示当天当地日出日落时间。</dd>
<dt><code>%%(diary-lunar-phases)</code></dt><dd>生成条目，显示月相。</dd>
<dt><code>%%(diary-day-of-year)</code></dt><dd>生成条目，显示今天是当年第几天、还剩几天。</dd>
<dt><code>%%(diary-iso-date)</code></dt><dd>生成条目，显示对应 ISO 商业日期。</dd>
<dt><code>%%(diary-julian-date)</code></dt><dd>生成条目，显示对应儒略日期。</dd>
<dt><code>%%(diary-astro-day-number)</code></dt><dd>生成条目，显示对应天文（儒略）日数。</dd>
<dt><code>%%(diary-bahai-date)</code></dt><dd>生成条目，显示对应巴哈伊历日期。</dd>
<dt><code>%%(diary-chinese-date)</code></dt><dd>生成条目，显示对应农历日期。</dd>
<dt><code>%%(diary-coptic-date)</code></dt><dd>生成条目，显示对应科普特历日期。</dd>
<dt><code>%%(diary-ethiopic-date)</code></dt><dd>生成条目，显示对应埃塞俄比亚历日期。</dd>
<dt><code>%%(diary-french-date)</code></dt><dd>生成条目，显示对应法国共和历日期。</dd>
<dt><code>%%(diary-hebrew-date)</code></dt><dd>生成条目，显示对应希伯来历日期。</dd>
<dt><code>%%(diary-islamic-date)</code></dt><dd>生成条目，显示对应伊斯兰历日期。</dd>
<dt><code>%%(diary-mayan-date)</code></dt><dd>生成条目，显示对应玛雅历日期。</dd>
<dt><code>%%(diary-persian-date)</code></dt><dd>生成条目，显示对应波斯历日期。</dd>
</dl>

<p>
例如，在日记中加入：
</p>

<div class="org-src-container">
<pre class="src src-shell">&amp;%%(diary-hebrew-date)
</pre>
</div>

<p>
使用精美日记显示时，每天都会显示对应的希伯来历日期。（简单显示模式下只会原样显示这行代码。）
</p>

<p>
以下函数用于生成希伯来相关的标准 Sexp 日记条目：
</p>
<dl class="org-dl">
<dt><code>%%(diary-hebrew-rosh-hodesh)</code></dt><dd>显示希伯来新月（月初）的到来与宗教宣告。</dd>
<dt><code>%%(diary-hebrew-parasha)</code></dt><dd>每周六显示当周犹太教堂诵读的经文段落。</dd>
<dt><code>%%(diary-hebrew-sabbath-candles)</code></dt><dd>每周五显示当地安息日点灯时间。</dd>
<dt><code>%%(diary-hebrew-omer)</code></dt><dd>适当日期显示俄默计数。</dd>
<dt><code>%%(diary-hebrew-yahrzeit 月 日 年) 姓名</code></dt><dd>显示忌日纪念日。日期为公历，会在希伯来历对应日及前一天显示。（参数的顺序会根据日历日期格式而变化；例如在欧洲格式下为日、月、年。）</dd>
<dt><code>%%(diary-hebrew-birthday 月 日 年)</code></dt><dd>按希伯来历显示生日。</dd>
</dl>

<p>
以上所有函数都接受可选参数 <i>mark</i> ，用于指定在日历中如何标记日期。如果函数判定当天生效，会返回包含 <i>mark</i> 信息的值。
</p>
</div>
</div>
</div>
</section>
<section id="outline-container-Sending-Mail" class="outline-2">
<h2 id="Sending-Mail"><span class="section-number-2">34.</span> 发送邮件</h2>
<div class="outline-text-2" id="text-Sending-Mail">
<p>
要在 Emacs 中发送电子邮件，按 <code>C-x m</code> 。这会切换到名为 <code>*unsent mail*</code> 的缓冲区，你可以在其中编辑邮件的正文和头部。完成后，按 <code>C-c C-s</code> 或 <code>C-c C-c</code> 发送邮件。
</p>

<dl class="org-dl">
<dt><code>C-x m</code></dt><dd>开始撰写邮件 (<code>compose-mail</code>) 。</dd>
<dt><code>C-x 4 m</code></dt><dd>功能同上，但在另一个窗口中打开 (<code>compose-mail-other-window</code>) 。</dd>
<dt><code>C-x 5 m</code></dt><dd>功能同上，但在新框架中打开 (<code>compose-mail-other-frame</code>) 。</dd>
<dt><code>C-c C-s</code></dt><dd>在邮件缓冲区中，发送邮件 (<code>message-send</code>) 。</dd>
<dt><code>C-c C-c</code></dt><dd>在邮件缓冲区中，发送邮件并隐藏该缓冲区 (<code>message-send-and-exit</code>) 。</dd>
</dl>

<p>
邮件缓冲区是一个普通的 Emacs 缓冲区，因此你在撰写邮件时可以切换到其他缓冲区。如果你想在完成当前邮件之前发送另一封邮件，再次按 <code>C-x m</code> ，会打开一个带有不同数字后缀的新邮件缓冲区（参见 “<a href="#Misc-Buffer">杂项缓冲区操作</a>”）。（这仅在使用默认的 Message 模式撰写邮件时有效；参见 “<a href="#Mail-Commands">邮件命令</a>”。）
</p>

<p>
如果你想继续编辑之前未完成的邮件，使用前缀参数执行该命令： <code>C-u C-x m</code> ，Emacs 会切换到你上次使用的邮件缓冲区，从中断处继续编辑。
</p>

<p>
命令 <code>C-x 4 m</code> (<code>compose-mail-other-window</code>) 与 <code>C-x m</code> 功能相同，只是在另一个窗口显示邮件缓冲区。命令 <code>C-x 5 m</code> (<code>compose-mail-other-frame</code>) 则在新框架中打开。
</p>

<p>
当你按 <code>C-c C-c</code> 或 <code>C-c C-s</code> 发送邮件时，Emacs 可能会询问你邮件的投递方式 ——是直接通过 SMTP，还是使用其他方式。详情参见 “<a href="#Mail-Sending">发送邮件</a>”。
</p>

<ul class="org-ul">
<li><a href="#Mail-Format">邮件缓冲区格式</a></li>
<li><a href="#Mail-Headers">邮件头字段</a></li>
<li><a href="#Mail-Aliases">邮件别名</a></li>
<li><a href="#Mail-Commands">邮件命令</a></li>
<li><a href="#Mail-Signature">邮件签名</a></li>
<li><a href="#Mail-Amusements">邮件娱乐功能</a></li>
<li><a href="#Mail-Methods">邮件撰写方式</a></li>
</ul>
</div>
<div id="outline-container-Mail-Format" class="outline-3">
<h3 id="Mail-Format"><span class="section-number-3">34.1.</span> 邮件缓冲区格式</h3>
<div class="outline-text-3" id="text-Mail-Format">
<p>
下面是一个邮件缓冲区内容的示例
</p>

<div class="org-src-container">
<pre class="src src-shell">To: subotai@example.org
CC: mongol.soldier@example.net, rms@gnu.org
Subject: Re: What is best<span style="color: #a020f0;"> in</span> life?
From: conan@example.org
--text follows this line--
To crush your enemies, see them driven before you, and to
hear the lamentation of their women.
</pre>
</div>

<p>
邮件缓冲区的顶部是一组 <b><i>header fields头字段</i></b> ，用于指定邮件的收件人、主题等信息。上面的缓冲区包含 'To'、'CC'、'Subject' 和 'From' 头字段。在合适的情况下，部分头字段会在邮件缓冲区中自动预先填充。
</p>

<p>
标注为 '<code>--text follows this line--</code>' 的这一行，用于将 <b>邮件头</b> 与 <b>/ body (or text)邮件正文/</b> 分隔开。该行以上的所有内容都被视为邮件头；该行以下的所有内容都被视为邮件正文。这条分隔线本身 <b>不会</b> 出现在实际发送的邮件中。
</p>

<p>
你可以使用普通的编辑命令来插入和修改头字段。有关专门用于编辑邮件头的命令，请参见「<a href="#Header-Editing">邮件头编辑</a>」章节。某些头字段（如 'Date' 和 'Message-Id' ）通常不会出现在邮件缓冲区中，而是在邮件发送时自动生成。
</p>
</div>
</div>
<div id="outline-container-Mail-Headers" class="outline-3">
<h3 id="Mail-Headers"><span class="section-number-3">34.2.</span> 邮件头字段</h3>
<div class="outline-text-3" id="text-Mail-Headers">
<p>
邮件缓冲区中的头字段以一行开头的字段名开始，以冒号结束。字段名不区分大小写。冒号与可选的空白字符之后是该字段的内容。
</p>

<p>
你可以为头字段使用任意名称，但通常人们只使用具有公认含义的 <b>标准字段名</b> 。
</p>

<p>
'<code>From</code>' 头字段标识发送邮件的人（也就是你）。它应当是一个合法的邮件地址，因为回复邮件通常会发送到该地址。此字段的默认内容由变量 <code>user-full-name</code> （指定你的全名）和 <code>user-mail-address</code> （你的邮件地址）计算得出。在某些操作系统上，Emacs 会通过环境变量初始化这两个变量（参见 “<a href="#General-Variables">通用变量”</a>）。如果这些信息不可用或不正确，你需要自行定制这些变量（参见 “<a href="#Easy-Customization">简易定制界面”</a>）。
</p>

<p>
除 '<code>From</code>' 之外，下面是常用字段一览表：
</p>
<dl class="org-dl">
<dt>'<code>To</code>'</dt><dd>邮件的目标收件地址。填写多个地址时，用逗号分隔。</dd>
<dt>'<code>Subject</code>'</dt><dd>邮件主题。</dd>
<dt>'<code>CC</code>'</dt><dd>邮件的抄送地址。与 '<code>To</code>' 类似，但这些接收者不应将邮件视为直接发给自己。</dd>
<dt>'<code>BCC</code>'</dt><dd>邮件的密送地址。这些地址 <b>不会</b> 出现在实际发送的邮件头部中。 '<code>BCC</code>' 是 “盲抄送”（blind carbon copies）的缩写。</dd>
<dt>'<code>FCC</code>'</dt><dd>一个文件名，已发送邮件的副本会追加到该文件中。Emacs 以 mbox 格式写入邮件，除非该文件是 Babyl 格式（Emacs 23 之前 Rmail 使用的格式），此时会以 Babyl 格式写入。如果某个 Rmail 缓冲区正在访问该文件，Emacs 会相应地更新它。如需指定多个文件，可使用多个 '<code>FCC</code>' 字段，每个字段填写一个文件名。</dd>
<dt>'<code>Reply-To</code>'</dt><dd>回复邮件时应发送到的地址，替代 '<code>From</code>' 地址。当你的 '<code>From</code>' 地址无法接收回复时会用到此字段。</dd>
<dt>'<code>Mail-Reply-To</code>'</dt><dd>优先级高于 '<code>Reply-To</code>' 。之所以使用此字段，是因为某些邮件列表会出于自身目的设置 '<code>Reply-To</code>' （这一做法存在一定争议）。</dd>
<dt>'<code>Mail-Followup-To</code>'</dt><dd>后续跟进邮件默认使用的一个或多个地址。通常用于你订阅了邮件列表并回复列表中的邮件，且希望回复直接发到列表、而不额外发给自己的场景。</dd>
<dt>'<code>In-Reply-To</code>'</dt><dd>你正在回复的邮件的标识符。大多数邮件阅读器会用该信息将相关邮件归为一组。通常，在 Emacs 内置的任意邮件程序中回复邮件时，此字段会 <b>自动填充</b> 。</dd>
<dt>'<code>References</code>'</dt><dd>此前相关邮件的标识符列表。与 '<code>In-Reply-To</code>' 类似，通常也会自动为你填充。</dd>
</dl>

<p>
'<code>To</code>' 、 '<code>CC</code>' 和 '<code>BCC</code>' 字段可以出现任意多次，每个头字段都可包含多个以逗号分隔的地址。通过这种方式，你可以指定任意数量的收件目标。这些字段还支持 <b>续行</b> ：在字段起始行之后，以空白字符开头的一行或多行，都会被视为该字段的一部分。下面是带续行的 '<code>To</code>' 字段示例：
</p>

<div class="org-src-container">
<pre class="src src-shell">To: foo@example.net, this@example.net,
  bob@example.com
</pre>
</div>

<p>
你可以通过将变量 <code>mail-default-headers</code> 设置为一个字符串，让 Emacs 在邮件缓冲区中自动插入某些默认头部。之后使用 <code>C-x m</code> 时就会把该字符串插入到邮件头部。例如，下面的代码会为每封邮件添加 '<code>Reply-To</code>' 和 '<code>FCC</code>' 头：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq</span> mail-default-headers
      <span style="color: #8b2252;">"Reply-To: foo@example.com\nFCC: ~/Mail/sent"</span>)
</pre>
</div>

<p>
如果默认头部不适用于某封邮件，在发送前按需编辑即可。
</p>
</div>
</div>
<div id="outline-container-Mail-Aliases" class="outline-3">
<h3 id="Mail-Aliases"><span class="section-number-3">34.3.</span> 邮件别名</h3>
<div class="outline-text-3" id="text-Mail-Aliases">
<p>
你可以定义 <i>mail aliases邮件别名</i> ，即用简短易记的名称来代表一个或多个邮件地址。默认情况下，邮件别名定义在文件 <code>~/.mailrc</code> 中。你可以通过设置变量 <code>mail-personal-alias-file</code> 来指定其他文件。
</p>

<p>
在 <code>~/.mailrc</code> 中 <b>定义别名</b> 的格式如下：
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #483d8b;">alias</span> nick&#21035;&#21517; fulladdresses&#23436;&#25972;&#22320;&#22336;&#21015;&#34920;
</pre>
</div>

<p>
这表示 <i>nick</i> 会展开为对应的 <i>fulladdresses</i> ，后者可以是单个地址，也可以是用空格分隔的多个地址。例如，让 maingnu 代表 gnu@gnu.org 以及你自己的一个本地地址，可以写：
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #483d8b;">alias</span> maingnu gnu@gnu.org local-gnu
</pre>
</div>

<p>
如果地址中包含空格，需要用一对双引号将整个地址括起来：
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #483d8b;">alias</span> jsmith <span style="color: #8b2252;">"John Q. Smith <a href="mailto:none%40example.com">&lt;none@example.com&gt;</a>"</span>
</pre>
</div>

<p>
注意：你不需要给地址里的单独部分（比如人名）加引号，Emacs 会在需要时自动添加。例如上面的地址会被插入为： <code>"John Q. Smith" &lt;none@example.com&gt;</code> 。
</p>

<p>
编辑 <code>~/.mailrc</code> 文件后，或该文件在 Emacs 外部被修改时，可以在已运行的 Emacs 中执行： <code>M-x rebuild-mail-abbrevs RET</code> 来更新当前使用的邮件别名。命令会提示输入别名文件，默认使用 <code>mail-personal-alias-file</code> 指定的文件。类似的命令 <code>merge-mail-abbrevs</code> 会提示选择一个别名文件，然后将该文件中的别名 <b>合并</b> 到已有的别名中。
</p>

<p>
你也可以直接用 Emacs 命令定义邮件别名： <code>define-mail-abbrev</code> 会提示输入别名和完整地址，然后将该别名定义为展开为对应地址。Emacs 在执行保存所有文件（ <code>C-x s</code> 或 <code>C-x C-c</code> ）时，会像保存其他缩写一样自动保存新增的别名（参见 “<a href="#Saving-Abbrevs">保存缩写</a>”）。
</p>

<p>
Emacs 同样支持在 <code>~/.mailrc</code> 中使用 <b>包含命令</b> ，格式如下：
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #483d8b;">source</span> filename
</pre>
</div>

<p>
<code>~/.mailrc</code> 并非 Emacs 专用文件；许多其他邮件客户端也用它存放别名，文件中还可以包含其他各类命令。但 Emacs 只识别 <b>别名定义</b> 和 <b>包含命令</b> ，其余内容都会忽略。
</p>

<p>
邮件别名会像普通缩写一样展开：即在别名后输入 <b>分词字符</b> 时立即展开（参见 “<a href="#Abbrevs">缩写</a>”）。展开只发生在以下头字段内：To、From、CC、BCC、Reply-To（以及它们以 Resent- 开头的变体）；在其他头字段（如 Subject）中不会展开。
</p>

<p>
你还可以直接插入别名对应的地址，使用命令： <code>M-x mail-abbrev-insert-alias</code> 它会带补全地读取一个别名，并在光标处插入其展开后的地址。
</p>

<p>
命令 <code>mail-abbrev-complete-alias</code> 用于对光标前的邮件别名进行 <b>补全</b>
</p>
</div>
</div>
<div id="outline-container-Mail-Commands" class="outline-3">
<h3 id="Mail-Commands"><span class="section-number-3">34.4.</span> 邮件命令</h3>
<div class="outline-text-3" id="text-Mail-Commands">
<p>
<code>*mail*</code> 缓冲区默认的主模式称为消息模式（Message mode）。它在很多方面与文本模式（Text mode）相似，但在 <code>C-c</code> 前缀键下提供了若干额外命令，让编辑邮件更加方便。
</p>

<p>
本节将介绍消息模式中一些最常用的命令。消息模式还有专门的手册，会更详细地描述其功能。参见《Message》手册中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/message/index.html#Top">Message</a> 节点。
</p>
<ul class="org-ul">
<li><a href="#Mail-Sending">邮件发送</a></li>
<li><a href="#Header-Editing">邮件头编辑</a></li>
<li><a href="#Citing-Mail">邮件引用</a></li>
<li><a href="#Mail-Misc">邮件杂项功能</a></li>
</ul>
</div>
<div id="outline-container-Mail-Sending" class="outline-4">
<h4 id="Mail-Sending"><span class="section-number-4">34.4.1.</span> 邮件发送</h4>
<div class="outline-text-4" id="text-Mail-Sending">
<dl class="org-dl">
<dt><code>C-c C-c</code></dt><dd>发送邮件，并隐藏邮件缓冲区 (<code>message-send-and-exit</code>) 。</dd>
<dt><code>C-c C-s</code></dt><dd>发送邮件，并保持邮件缓冲区为当前选中状态 (<code>message-send</code>) 。</dd>
</dl>

<p>
发送邮件最常用的命令是 <code>C-c C-c</code> (<code>message-send-and-exit</code>) 。它会发送邮件并将邮件缓冲区 <b>隐藏</b> ，降低其重新被选中的优先级。如果你希望发送后直接 <b>关闭</b> 邮件缓冲区，可以将变量 <code>message-kill-buffer-on-exit</code> 设为 <code>t</code> 。
</p>

<p>
命令 <code>C-c C-s</code> (<code>message-send</code>) 会发送邮件，但 <b>不退出</b> 邮件缓冲区。适合需要继续修改邮件（例如添加新收件人）并再次发送的场景。
</p>

<p>
发送邮件时会运行钩子 <code>message-send-hook</code> 。同时会将邮件缓冲区标记为 <b>未修改</b> ，除非该缓冲区同时关联到文件（这种情况下只有保存文件才会标记为未修改，重复发送同一邮件也不会出现警告）。
</p>

<p>
变量 <code>message-send-mail-function</code> 控制邮件的发送方式（Mail mode 下使用 <code>send-mail-function</code> ）。 <code>send-mail-function</code> 可以取以下函数之一：
</p>

<dl class="org-dl">
<dt><code>sendmail-query-once</code></dt><dd>询问一次发送方式（从下面列表中选择），本次邮件使用该方式发送，并将方式保存到 <code>send-mail-function</code> ，以后默认使用该方式。这是默认值，除非你已经通过 <code>smtpmail-send-it</code> 设置过发信相关变量。</dd>

<dt><code>smtpmail-send-it</code></dt><dd>通过外部邮件服务器发送邮件，例如你的网络服务提供商提供的外发 SMTP 服务器。如果尚未告诉 Emacs 如何连接 SMTP 服务器，Emacs 会提示你输入信息，这些信息会保存在变量 <code>smtpmail-smtp-server</code> 以及文件 <code>~/.authinfo</code> 中。参见《通过 SMTP 发送邮件》中的 “<a href="https://www.gnu.org/software/emacs/manual/html_node/smtpmail/index.html">Emacs SMTP 库</a>” 一节。</dd>

<dt><code>sendmail-send-it</code></dt><dd>使用系统默认的 <code>sendmail</code> 程序（或等价程序）发送邮件。这要求系统已配置为可直接通过 SMTP 投递邮件。</dd>

<dt><code>mailclient-send-it</code></dt><dd>将邮件缓冲区交给系统指定的邮件客户端处理。详情参见文件 <code>mailclient.el</code> 中的注释说明。</dd>

<dt><code>feedmail-send-it</code></dt><dd>与 <code>sendmail-send-it</code> 类似，但允许你将邮件加入队列，稍后再统一发送。详情参见文件 <code>feedmail.el</code> 中的注释说明。</dd>
</dl>

<p>
当你发送包含非 ASCII 字符的邮件时，这些字符需要通过 <b>编码系统</b> 进行编码(见 <a href="#Coding-Systems">Coding Systems</a>).。通常编码系统会由你当前选择的语言环境自动指定 (see <a href="#Language-Environments">Language Environments</a>)。你可以通过设置变量 <code>sendmail-coding-system</code> 显式指定外发邮件使用的编码系统(see <a href="#Recognize-Coding">Recognizing Coding Systems</a>)。如果自动确定的编码无法处理邮件中的某些字符，Emacs 会让你从可选编码列表中选择一个编码。See <a href="#Output-Coding">Choosing Coding Systems for Output</a>.
</p>
</div>
</div>
<div id="outline-container-Header-Editing" class="outline-4">
<h4 id="Header-Editing"><span class="section-number-4">34.4.2.</span> 邮件头编辑</h4>
<div class="outline-text-4" id="text-Header-Editing">
<p>
邮件编辑模式提供了以下专用命令，用于跳转到指定的邮件头部字段，并自动补全邮件地址。
</p>

<dl class="org-dl">
<dt><code>C-c C-f C-t</code></dt><dd>跳转到「收件人（To）」头部 (<code>message-goto-to</code>) 。</dd>
<dt><code>C-c C-f C-s</code></dt><dd>跳转到「主题（Subject）」头部 (<code>message-goto-subject</code>) 。</dd>
<dt><code>C-c C-f C-c</code></dt><dd>跳转到「抄送（CC）」头部 (<code>message-goto-cc</code>) 。</dd>
<dt><code>C-c C-f C-b</code></dt><dd>跳转到「密送（BCC）」头部 (<code>message-goto-bcc</code>) 。</dd>
<dt><code>C-c C-f C-r</code></dt><dd>跳转到「回复地址（Reply-To）」头部 (<code>message-goto-reply-to</code>) 。</dd>
<dt><code>C-c C-f C-f</code></dt><dd>跳转到「邮件后续回复地址（Mail-Followup-To）」头部字段 (<code>message-goto-followup-to</code>) 。</dd>
<dt><code>C-c C-f C-w</code></dt><dd>添加新的「FCC」头部字段，支持文件名补全 (<code>message-goto-fcc</code>) 。</dd>
<dt><code>C-c C-b</code></dt><dd>跳转到邮件正文起始位置 (<code>message-goto-body</code>) 。</dd>
<dt><code>TAB</code></dt><dd>补全邮件地址 (<code>message-tab</code>) 。</dd>
</dl>

<p>
这些将光标定位到指定头部字段的命令，均以前缀键 <code>C-c C-f</code> 开头（ 'C-f' 代表「字段 field」）。如果目标字段不存在，该命令会自动创建该字段（唯一例外是 '<code>FCC</code>' 头部，每次执行都会新建一个）。
</p>

<p>
命令 <code>C-c C-b</code> (<code>message-goto-body</code>) 会将光标移动到头部分隔线之后，即邮件正文的开头。
</p>

<p>
在编辑包含地址的头部字段（如 'To:' 、'CC:'、'BCC:'）时，可按 <code>TAB</code> (<code>message-tab</code>) 补全地址。系统会通过多种方式尝试补全对应完整姓名，包括使用 EUDC 库（支持多种目录服务器协议，参见《Emacs 统一目录客户端》中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/eudc/index.html#Top">EUDC</a> 章节）。若上述方式失败，则会尝试将地址作为邮件别名进行展开（参见「<a href="#Mail-Aliases">邮件别名</a>」）。如果光标位于不接收地址的头部字段，或在邮件正文中，按 <code>TAB</code> 则直接插入制表符。
</p>
</div>
</div>
<div id="outline-container-Citing-Mail" class="outline-4">
<h4 id="Citing-Mail"><span class="section-number-4">34.4.3.</span> 邮件引用</h4>
<div class="outline-text-4" id="text-Citing-Mail">
<dl class="org-dl">
<dt><code>C-c C-y</code></dt><dd>从邮件阅读器中提取选中的邮件，作为引用内容插入 (<code>message-yank-original</code>) 。</dd>
<dt><code>C-c C-q</code></dt><dd>对从其他邮件引用过来的每个段落进行自动换行排版 (<code>message-fill-yanked-message</code>) 。</dd>
</dl>

<p>
你可以使用命令 <code>C-c C-y</code> (<code>message-yank-original</code>) 来引用你正在回复的邮件。该命令会将原邮件内容插入到邮件编辑缓冲区中。只有当邮件编辑缓冲区是从 Emacs 内置的邮件阅读器（如 Rmail）中打开时，此命令才有效。
</p>

<p>
默认情况下，Emacs 会在引用内容的每一行前插入符号 '<code>&gt;</code> ' ；这个前缀符号由变量 <code>message-yank-prefix</code> 指定。如果带前缀参数调用 <code>message-yank-original</code> ，则不会插入引用前缀。
</p>

<p>
使用 <code>C-c C-y</code> 之后，你可以输入 <code>C-c C-q</code> (<code>message-fill-yanked-message</code>) 对引用邮件的段落进行自动排版。执行一次 <code>C-c C-q</code> 就会对所有引用段落分别进行排版。如果只想对某一段引用内容排版，可使用 <code>M-q</code> 。如果自动排版无法正确处理你使用的引用前缀，可以尝试显式设置填充前缀。参见「<a href="#Filling">文本填充</a>」。
</p>

<p>
你可以通过钩子 <code>mail-citation-hook</code> 来自定义邮件引用方式。例如，可以使用 Supercite 扩展包，它提供更灵活的引用格式（参见 Supercite 中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/sc/Introduction.html#Introduction">简介</a>」章节）
</p>
</div>
</div>
<div id="outline-container-Mail-Misc" class="outline-4">
<h4 id="Mail-Misc"><span class="section-number-4">34.4.4.</span> 邮件杂项功能</h4>
<div class="outline-text-4" id="text-Mail-Misc">
<p>
在邮件编辑缓冲区中，输入 <code>C-c C-a</code> (<code>mml-attach-file</code>) 可以为待发送邮件 <b><i>attach添加</i> 附件</b> 。添加附件遵循多用途互联网邮件扩展（MIME）标准。
</p>

<p>
<code>mml-attach-file</code> 命令会提示你输入文件名、附件的内容类型、 <i>description描述</i> 和 <i>disposition处理方式</i> 。 <i>内容类型</i> 通常会自动检测，直接按 <code>RET</code> 接受默认值即可。 <i>描述</i> 是一段单行文本，收件人会在附件旁看到这段文字；你也可以选择留空。 <i>disposition处理方式</i> 有两种：
</p>
<ul class="org-ul">
<li>'<code>inline</code>' ：收件人会在邮件正文内看到附件链接</li>
<li>'<code>attachment</code>' ：附件链接与正文分开显示</li>
</ul>

<p>
<code>mml-attach-file</code> 是 Message 模式专用命令；在 Mail mode下请改用 <code>mail-add-attachment</code> 。该命令仅提示输入文件名，并自动判断内容类型与处理方式。如果你想为附件添加描述，可以直接写在邮件正文中。
</p>

<p>
附件的实际内容 <b>不会</b> 插入到邮件缓冲区中，而是插入一段占位文本，示例如下：
</p>

<div class="org-src-container">
<pre class="src src-shell">&lt;<span style="color: #b22222;">#</span><span style="color: #b22222;">part type="text/plain" filename="~/foo.txt" disposition=inline&gt;
</span>&lt;<span style="color: #b22222;">#</span><span style="color: #b22222;">/part&gt;</span>
</pre>
</div>

<p>
当你输入 <code>C-c C-c</code> 或 <code>C-c C-s</code> 发送邮件时，附件会随邮件一同发送。
</p>

<p>
撰写邮件时，输入 <code>M-x ispell-message</code> 可以对邮件文本进行拼写检查。如果你将收到的邮件引用到草稿中，该命令会跳过引用内容，只检查你自己输入的文本（它通过缩进或 <code>mail-yank-prefix</code> 区分引用行和你输入的内容）。参见「<a href="#Spelling">拼写检查与更正</a>」。
</p>

<p>
启用 Message 模式（ <code>C-x m</code> 会自动启用）会运行常规钩子 <code>text-mode-hook</code> 和 <code>message-mode-hook</code> 。初始化一封新的待发邮件会运行常规钩子 <code>message-setup-hook</code> ；如果你需要修改邮件缓冲区的外观，可以使用这个钩子。参见「<a href="#Hooks">钩子</a>」。
</p>

<p>
这些钩子的主要区别在于触发时机：
</p>
<ul class="org-ul">
<li>每当你输入 <code>C-x m</code> ， <code>message-mode-hook</code> 会在邮件缓冲区创建后立即运行。</li>
<li>之后 <code>message-setup</code> 函数会插入缓冲区默认内容。</li>
<li>默认内容插入完成后， <code>message-setup-hook</code> 才会运行。</li>
</ul>

<p>
如果你使用 <code>C-x m</code> 继续编辑已有的草稿， <code>message-mode-hook</code> 会在切换到邮件缓冲区后立即运行。如果缓冲区未被修改，或你选择清空并重写， <code>message-setup-hook</code> 会在默认内容插入后运行。
</p>
</div>
</div>
</div>
<div id="outline-container-Mail-Signature" class="outline-3">
<h3 id="Mail-Signature"><span class="section-number-3">34.5.</span> 邮件签名</h3>
<div class="outline-text-3" id="text-Mail-Signature">
<p>
你可以在每封邮件末尾添加一段固定文本 —— 即 <b><i>mail signature邮件签名</i></b> ，签名中可包含电话、地址等信息。变量 <code>message-signature</code> 用于控制 Emacs 如何处理邮件签名。
</p>

<p>
<code>message-signature</code> 的默认值为 <code>t</code> ，表示 Emacs 会从文件 <code>~/.signature</code> 中读取你的邮件签名。如果该文件存在，其内容会自动插入到邮件缓冲区的末尾。你可以通过变量 <code>message-signature-file</code> 修改签名文件路径。
</p>

<p>
若将 <code>message-signature</code> 设置为一个 <b>字符串</b> ，则该字符串会直接作为签名内容。
</p>

<p>
若将 <code>message-signature</code> 设置为 <code>nil</code> ，Emacs 不会自动插入签名。你可以在邮件缓冲区中按下 <code>C-c C-w</code> (<code>message-insert-signature</code>) 手动插入签名，Emacs 仍会从签名文件中读取内容。
</p>

<p>
如果你使用的是 Mail mode而非 Message 模式撰写邮件，对应的控制变量为 <code>mail-signature</code> 和 <code>mail-signature-file</code> 。
</p>

<p>
按照惯例，邮件签名应以一行 '&#x2013; ' 开头。如果你的签名没有这行前缀，Emacs 会自动补上。签名的其余内容建议不超过四行。
</p>
</div>
</div>
<div id="outline-container-Mail-Amusements" class="outline-3">
<h3 id="Mail-Amusements"><span class="section-number-3">34.6.</span> 邮件娱乐功能</h3>
<div class="outline-text-3" id="text-Mail-Amusements">
<p>
<code>M-x spook</code> 会往待发送的邮件里添加一行随机选取的关键词。这些关键词选自一份词表，会让人觉得你在讨论某些敏感、“颠覆性” 的话题。
</p>

<p>
这个功能的初衷是：有人怀疑美国国家安全局（NSA<sup><a id="fnr.19" class="footref" href="#fn.19" role="doc-backlink">19</a></sup>）及其他情报机构会监听所有包含 “敏感关键词” 的电子邮件。（这些机构声称并不会这么做，但他们本来就会这么说。）设计思路是：如果大量用户都在邮件里加入可疑词汇，情报机构就会被大量虚假信息淹没，从而不得不放弃全部审阅。不管这是否真的有效，至少能博一些人一笑。
</p>

<p>
你可以使用 <code>fortune</code> 程序，在发出的邮件里插入一段类似 “幸运签语” 的文字。做法是把 <code>fortune-to-signature</code> 添加到 <code>mail-setup-hook</code> 中：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'mail-setup-hook 'fortune-to-signature)
</pre>
</div>

<p>
使用之前，你可能还需要先设置变量 <code>fortune-file</code> 。
</p>
</div>
</div>
<div id="outline-container-Mail-Methods" class="outline-3">
<h3 id="Mail-Methods"><span class="section-number-3">34.7.</span> 邮件撰写方式</h3>
<div class="outline-text-3" id="text-Mail-Methods">
<p>
本章中我们介绍了 Emacs 里用于编辑和发送邮件的默认模式 ——Message 模式。但它只是多种可用模式中的一种。在 Emacs 23.2 之前，默认模式是 Mail 模式。它在很多方面与 Message 模式相似，但功能更少：例如它只支持基础的 MIME 功能，可以添加附件，但缺少更复杂的 MIME 特性。另一种可用模式是 MH-E（参见《Emacs MH 接口》中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/mh-e/index.html#Top">MH-E</a> 章节）。
</p>

<p>
你可以任选其中一种 <i>mail user agents邮件客户端</i> ，作为编辑和发送邮件的 <b>首选方式</b> 。命令 <code>C-x m</code> 、 <code>C-x 4 m</code> 和 <code>C-x 5 m</code> 都会使用你指定的工具；Emacs 中其他发送邮件的功能（见 <a href="#Bugs">错误报告</a>）也是如此。
</p>

<p>
要指定邮件客户端，只需自定义变量 <code>mail-user-agent</code> 。目前合法的值包括：
</p>
<ul class="org-ul">
<li><code>message-user-agent</code> （Message 模式）</li>
<li><code>sendmail-user-agent</code> （Mail 模式）</li>
<li><code>gnus-user-agent</code></li>
<li><code>mh-e-user-agent</code></li>
</ul>

<p>
可能还有其他可选值，详情可查看对应邮件客户端包的手册。你也可以用 <code>define-mail-user-agent</code> 自定义一个邮件客户端。
</p>

<p>
如果你选择了其他邮件撰写方式，本章中关于邮件缓冲区和 Message 模式的内容将 <b>不再适用</b> ：其他方式会在不同缓冲区中使用不同的文本格式，快捷键命令也不一样。
</p>

<p>
类似地，若要指定 <b>首选的邮件阅读</b> 方式，可以自定义变量 <code>read-mail-command</code> 。其默认值为 <code>rmail</code> （参见《<a href="#Rmail">使用 Rmail 阅读邮件</a>》）。
</p>
</div>
</div>
</section>
<section id="outline-container-Rmail" class="outline-2">
<h2 id="Rmail"><span class="section-number-2">35.</span> 使用 Rmail 阅读邮件</h2>
<div class="outline-text-2" id="text-Rmail">
<p>
Rmail 是 Emacs 中的一个子系统，用于阅读和处理收到的邮件。Rmail 将邮件消息存储在称为 Rmail 文件 的文件中。在 Rmail 文件中阅读邮件会在一个专用的主模式 ——Rmail 模式下进行，该模式重新定义了大部分按键，用于执行邮件管理相关命令。
</p>

<p>
Emacs 还自带一个功能更强大、更灵活的邮件阅读子系统，名为 Gnus。Gnus 是一个非常庞大的软件包，因此在独立的手册中说明，详见《<a href="https://www.gnu.org/software/emacs/manual/html_node/gnus/index.html#Top">Gnus 新闻阅读器</a>》。
</p>

<ul class="org-ul">
<li><a href="#Rmail-Basics">Rmail 基本概念</a></li>
<li><a href="#Rmail-Scrolling">邮件内滚动</a></li>
<li><a href="#Rmail-Motion">邮件间移动</a></li>
<li><a href="#Rmail-Deletion">删除邮件</a></li>
<li><a href="#Rmail-Inbox">Rmail 文件与收件箱</a></li>
<li><a href="#Rmail-Files">多个 Rmail 文件</a></li>
<li><a href="#Rmail-Output">将邮件复制到外部文件</a></li>
<li><a href="#Rmail-Labels">标签</a></li>
<li><a href="#Rmail-Attributes">Rmail 属性</a></li>
<li><a href="#Rmail-Reply">发送回复</a></li>
<li><a href="#Rmail-Summary">摘要</a></li>
<li><a href="#Rmail-Sorting">Rmail 文件排序</a></li>
<li><a href="#Rmail-Display">邮件显示</a></li>
<li><a href="#Rmail-Coding">Rmail 与编码系统</a></li>
<li><a href="#Rmail-Editing">邮件内编辑</a></li>
<li><a href="#Rmail-Digest">邮件摘要</a></li>
<li><a href="#Rmail-Rot13">阅读 Rot13 加密邮件</a></li>
<li><a href="#Movemail">movemail 程序</a></li>
<li><a href="#Remote-Mailboxes">从远程邮箱获取邮件</a></li>
<li><a href="#Other-Mailbox-Formats">从多种格式的本地邮箱获取邮件</a></li>
</ul>
</div>
<div id="outline-container-Rmail-Basics" class="outline-3">
<h3 id="Rmail-Basics"><span class="section-number-3">35.1.</span> Rmail 基本概念</h3>
<div class="outline-text-3" id="text-Rmail-Basics">
<p>
最简单的 Rmail 使用方式是：只有一个 Rmail 文件 <code>~/RMAIL</code> ，所有邮件都保存在这里，它被称为 <i>primary Rmail file(主 Rmail 文件)</i> 。命令 <code>M-x rmail</code> 会读取你的主 Rmail 文件，从收件箱合并新邮件，显示你尚未阅读的第一封邮件，并让你开始阅读。变量 <code>rmail-file-name</code> 用于指定主 Rmail 文件的文件名。
</p>

<p>
Rmail 一次只显示 Rmail 文件中的 <b>一封邮件</b> ，当前显示的邮件称为 <b><i>current message当前邮件</i></b> 。Rmail 模式的专用命令可以执行如下操作：删除当前邮件、将其复制到另一个文件、发送回复，或切换到另一封邮件。你也可以创建多个 Rmail 文件（参见<a href="#Files">文件处理</a>），并使用 Rmail 在它们之间移动邮件（参见<a href="#Rmail-Output">将邮件复制到文件</a>）。
</p>

<p>
在 Rmail 文件中，邮件通常按 <b>接收顺序</b> 依次排列；你也可以指定其他排序方式（参见<a href="#Rmail-Sorting">对 Rmail 文件排序</a>）。邮件用连续整数标识，即 <b><i>message numbers邮件编号</i></b> 。当前邮件的编号会显示在 Rmail 的模式行上，后面跟着文件中的邮件总数。你可以使用 <code>j</code> 键指定邮件编号来跳转到该邮件（参见<a href="#Rmail-Motion">在邮件间切换</a>）。
</p>

<p>
按照 Emacs 的常规规则，对 Rmail 文件的修改只有在 <b>保存文件</b> 后才会永久生效。你可以用 <code>s</code> (<code>rmail-expunge-and-save</code>) 保存，它会先从文件中彻底清除已删除的邮件（参见<a href="#Rmail-Deletion">删除邮件</a>）。若要 <b>不清除已删邮件</b> 直接保存，使用 <code>C-x C-s</code> 。Rmail 在从收件箱文件合并新邮件后会 <b>自动保存</b> Rmail 文件（参见 <a href="#Rmail-Inbox">Rmail 文件与收件箱</a>）。
</p>

<p>
你可以用 <code>q</code> (<code>rmail-quit</code>) 退出 Rmail；它会先清除已删邮件并保存 Rmail 文件，然后隐藏 Rmail 缓冲区及其摘要缓冲区（如果有）（参见<a href="#Rmail-Summary">摘要</a>）。但不必正式退出。如果你从 Rmail 切换到其他缓冲区编辑且不再回来，就相当于退出了。只要最终记得保存 Rmail 文件即可（和其他修改过的文件一样）。 <code>C-x s</code> 是合适的保存方式（参见<a href="#Save-Commands">文件保存命令</a>）。Rmail 命令 <code>b</code> (<code>rmail-bury</code>) 可以隐藏 Rmail 缓冲区及其摘要， <b>不清除、不保存</b> Rmail 文件。
</p>
</div>
</div>
<div id="outline-container-Rmail-Scrolling" class="outline-3">
<h3 id="Rmail-Scrolling"><span class="section-number-3">35.2.</span> 邮件内滚动</h3>
<div class="outline-text-3" id="text-Rmail-Scrolling">
<p>
当 Rmail 显示的邮件长度超过一屏时，你需要滚动屏幕来阅读剩余内容。虽然可以使用常规滚动命令： <code>C-v</code> 、 <code>M-v</code> 和 <code>M-&lt;</code> (参<a href="#Scrolling">见滚动</a>) ，但在 Rmail 中滚动操作非常频繁，因此提供了更简便的按键。
</p>

<dl class="org-dl">
<dt><code>SPC</code></dt><dd>向前滚动一屏 (<code>scroll-up-command</code>) 。</dd>
<dt><code>DEL</code></dt><dd></dd>

<dt><code>S-SPC</code></dt><dd>向后滚动一屏 (<code>scroll-down-command</code>) 。</dd>
<dt><code>.</code></dt><dd>滚动到当前邮件开头 (<code>rmail-beginning-of-message</code>) 。</dd>
<dt><code>/</code></dt><dd>滚动到当前邮件末尾 (<code>rmail-end-of-message</code>) 。</dd>
</dl>

<p>
由于阅读邮件时最常见的操作是按屏滚动，Rmail 将 <code>SPC</code> 和 <code>DEL</code> (或 <code>S-SPC</code> ) 分别设为与 <code>C-v</code> 、 <code>M-v</code> 功能相同。
</p>

<p>
命令 <code>.</code> (<code>rmail-beginning-of-message</code>) 会滚动回当前选中邮件的开头。它与 <code>M-&lt;</code> 不完全相同：一方面，它不会设置标记；另一方面，如果你之前修改过当前邮件的缓冲区边界 (例如通过编辑操作，参见<a href="#Rmail-Editing">在邮件内编辑</a>) ，它会重置这些边界。
</p>

<p>
同理，命令 <code>/</code> (<code>rmail-end-of-message</code>) 会向前滚动到当前选中邮件的末尾
</p>
</div>
</div>
<div id="outline-container-Rmail-Motion" class="outline-3">
<h3 id="Rmail-Motion"><span class="section-number-3">35.3.</span> 邮件间移动</h3>
<div class="outline-text-3" id="text-Rmail-Motion">
<p>
对消息最基本的操作就是阅读。在 Rmail 中，这需要先将该消息设为当前消息。通常的做法是按文件中的顺序依次移动，这也是消息的接收顺序。进入 Rmail 时，光标会定位在你尚未设为当前消息的第一条（即带有「unseen」属性的第一条消息；参见 <a href="#Rmail-Attributes">Rmail 属性</a>）。向后移动可查看其他新消息；向前移动可重新查看旧消息。
</p>

<dl class="org-dl">
<dt><code>n</code></dt><dd>跳转到下一条未被删除的消息，跳过中间已删除的消息 (<code>rmail-next-undeleted-message</code>) 。</dd>
<dt><code>p</code></dt><dd>跳转到上一条未被删除的消息 (<code>rmail-previous-undeleted-message</code>) 。</dd>
<dt><code>M-n</code></dt><dd>跳转到下一条消息（包含已删除消息） (<code>rmail-next-message</code>) 。</dd>
<dt><code>M-p</code></dt><dd>跳转到上一条消息（包含已删除消息） (<code>rmail-previous-message</code>) 。</dd>
<dt><code>C-c C-n</code></dt><dd>跳转到与当前消息主题相同的下一条消息 (<code>rmail-next-same-subject</code>) 。</dd>
<dt><code>C-c C-p</code></dt><dd>跳转到与当前消息主题相同的上一条消息 (<code>rmail-previous-same-subject</code>) 。</dd>
<dt><code>j</code></dt><dd>跳转到第一条消息。带参数 n 时，跳转到编号为 n 的消息 (<code>rmail-show-message</code>) 。</dd>
<dt><code>&gt;</code></dt><dd>跳转到最后一条消息 (<code>rmail-last-message</code>) 。</dd>
<dt><code>&lt;</code></dt><dd>跳转到第一条消息 (<code>rmail-first-message</code>) 。</dd>
<dt><code>M-s regexp RET</code></dt><dd>跳转到下一条匹配该正则表达式的消息 (<code>rmail-search</code>) 。</dd>
<dt><code>- M-s regexp RET</code></dt><dd>跳转到上一条匹配该正则表达式的消息。（这是带负参数的 <code>M-s</code> 。）</dd>
</dl>

<p>
在 Rmail 中， <code>n</code> 和 <code>p</code> 是最常用的消息间移动方式。它们会按顺序遍历消息，但跳过已删除消息，这通常符合使用习惯。对应的命令名为 <code>rmail-next-undeleted-message</code> 和 <code>rmail-previous-undeleted-message</code> 。如果你不想跳过已删除消息（例如要去恢复某条消息），可以使用变体命令 <code>M-n</code> 和 <code>M-p</code> (<code>rmail-next-message</code> 和 <code>rmail-previous-message</code>) 。这些命令都可以接受数字参数作为重复次数。
</p>

<p>
在 Rmail 中，直接输入数字即可指定数字参数，无需先按 <code>C-u</code> 。输入 '<code>-</code>' 即可指定负参数。
</p>

<p>
<code>M-s</code> (<code>rmail-search</code>) 是 Rmail 专用的搜索命令。普通的增量搜索 <code>C-s</code> 在 Rmail 中也可用，但它只在当前消息内搜索。 <code>M-s</code> 的作用是在所有消息之间搜索。它会非增量地读取一个正则表达式（参见<a href="#Regexps">正则表达式语法</a>），然后从下一条消息的开头开始查找匹配项，并选中该消息。如果正则表达式为空， <code>M-s</code> 会复用上一次使用的表达式。
</p>

<p>
要反向在文件中搜索消息，给 <code>M-s</code> 一个负参数即可。在 Rmail 中可直接用 <code>- M-s</code> ，它会从上一条消息的末尾开始向前搜索。
</p>

<p>
你也可以根据标签搜索消息，参见「<a href="#Rmail-Labels">标签</a>」一节。
</p>

<p>
<code>C-c C-n</code> (<code>rmail-next-same-subject</code>) 会跳转到与当前消息主题相同的下一条消息。前缀参数为重复次数。带负参数时，该命令会向前跳转，效果等同于 <code>C-c C-p</code> (<code>rmail-previous-same-subject</code>) 。在比较主题时，这些命令会忽略回复邮件主题中常见的前缀（如 'Re:' ）。它们非常适合阅读同一主题的所有消息，也就是对话串 / 线程。
</p>

<p>
要跳转到指定绝对编号的消息，使用 <code>j</code> (<code>rmail-show-message</code>) 并将消息编号作为参数。不带参数时， <code>j</code> 选中第一条消息。 <code>&lt;</code> (<code>rmail-first-message</code>) 同样选中第一条消息.  <code>&gt;</code> (<code>rmail-last-message</code>) 选中最后一条消息。
</p>
</div>
</div>
<div id="outline-container-Rmail-Deletion" class="outline-3">
<h3 id="Rmail-Deletion"><span class="section-number-3">35.4.</span> 删除邮件</h3>
<div class="outline-text-3" id="text-Rmail-Deletion">
<p>
当你不再需要保留某条消息时，可以将其 <i>delete删除</i> 。这会将它 <b>标记</b> 为可忽略，部分 Rmail 命令会当作它不存在；但它在 Rmail 文件中的位置和消息编号仍然保留。
</p>

<p>
压缩（Expunging） Rmail 文件会真正移除已删除的消息。剩余的消息会重新连续编号。
</p>

<dl class="org-dl">
<dt><code>d</code></dt><dd>删除当前消息，并跳转到下一条未删除的消息 (<code>rmail-delete-forward</code>) 。</dd>
<dt><code>C-d</code></dt><dd>删除当前消息，并跳转到上一条未删除的消息 (<code>rmail-delete-backward</code>) 。</dd>
<dt><code>u</code></dt><dd>恢复当前消息，或回退到上一条已删除消息并将其恢复 (<code>rmail-undelete-previous-message</code>) 。</dd>
<dt><code>x</code></dt><dd>压缩 Rmail 文件（真正删除已标记删除的消息） (<code>rmail-expunge</code>) 。</dd>
</dl>

<p>
Rmail 有两条删除消息的命令，两者都会删除当前消息并选中另一条。 <code>d</code> (<code>rmail-delete-forward</code>) 会向后跳转，跳过已删除消息；而 <code>C-d</code> (<code>rmail-delete-backward</code>) 会跳转到上一条未删除消息。如果在指定方向上没有未删除消息可跳转，刚被删除的消息会保持为当前消息。数字前缀参数可作为 <b>重复次数</b> ，允许单条命令一次性删除多条消息。负参数会反转 <code>d</code> 和 <code>C-d</code> 的行为方向。
</p>

<p>
每当 Rmail 删除一条消息时，都会运行钩子 <code>rmail-delete-message-hook</code> 。钩子函数被调用时，该消息已被标记为删除，但它仍是 Rmail 缓冲区中的当前消息。
</p>

<p>
要让所有已删除消息 <b>真正从 Rmail 文件中消失</b> ，输入 <code>x</code> (<code>rmail-expunge</code>) 。在此之前，你仍然可以恢复已删除消息。恢复命令 <code>u</code> (<code>rmail-undelete-previous-message</code>) 在大多数情况下用于取消 <code>d</code> 命令的效果。如果当前消息已删除，它会恢复当前消息；否则它会向前回退，直到找到一条已删除消息并将其恢复。数字前缀参数可作为重复次数，允许单条命令一次性恢复多条消息。
</p>

<p>
通常你可以用 <code>u</code> 撤销 <code>d</code> ，因为 <code>u</code> 会回退并恢复 <code>d</code> 刚删除的那条消息。但当 <code>d</code> 跳过了其后若干条已删除消息时，这一行为会失效；此时 <code>u</code> 会恢复最后一条被跳过的已删除消息。没有完美的方法避免这个问题。不过，重复执行 <code>u</code> 命令，最终总能回到你想要恢复的那条消息。你也可以用 <code>M-p</code> 命令选中某条特定的已删除消息，然后输入 <code>u</code> 恢复它。
</p>

<p>
已删除消息带有 'deleted' 属性，因此当当前消息被删除时，模式行上会显示 'deleted' 。实际上，删除或恢复消息只不过是 <b>添加或移除这个属性</b> 而已。参见 <a href="#Rmail-Attributes">Rmail 属性</a>。
</p>
</div>
</div>
<div id="outline-container-Rmail-Inbox" class="outline-3">
<h3 id="Rmail-Inbox"><span class="section-number-3">35.5.</span> Rmail 文件与收件箱</h3>
<div class="outline-text-3" id="text-Rmail-Inbox">
<p>
当你在本地接收邮件时，操作系统会将发给你的 incoming 邮件存放在一个文件中，我们称之为你的收件箱（inbox）。启动 Rmail 时，它会运行一个名为 <code>movemail</code> 的 C 程序，把新邮件从收件箱复制到你的 <b>主 Rmail 文件</b> 中，该文件还保存着之前 Rmail 会话里留存的其他邮件。你实际在 Rmail 中阅读的，正是这个文件里的邮件。这一操作叫作 <b><i>getting new mail收取新邮件</i></b> 。在 Rmail 中随时按 <code>g</code> 都可以收取新邮件。
</p>

<p>
变量 <code>rmail-primary-inbox-list</code> 存放着主 Rmail 文件对应的收件箱文件列表。如果你没有显式设置这个变量，Rmail 会使用环境变量 <code>MAIL</code> ；作为最后备选，则会使用基于 <code>rmail-spool-directory</code> 的默认收件箱。默认收件箱文件因操作系统而异，通常是： <code>/var/mail/用户名</code> 、 <code>/var/spool/mail/用户名</code> 或 <code>/usr/spool/mail/用户名</code> 。
</p>

<p>
你可以用命令 <code>set-rmail-inbox-list</code> 为当前会话中的任意 Rmail 文件指定收件箱文件，详见「<a href="#Rmail-Files">多个 Rmail 文件</a>」一节。
</p>

<p>
将 Rmail 文件与收件箱分开，有两个原因：
</p>
<ol class="org-ol">
<li>收件箱文件格式在不同操作系统、不同邮件软件中各不相同。Rmail 只需其中一部分模块了解这些差异，并且只需要知道如何把它们统一转换成 Rmail 自身格式即可。</li>
<li>在不丢失邮件的前提下直接访问收件箱文件非常麻烦，因为必须与邮件投递过程进行互斥（interlock）。而且不同系统使用的互斥方式不同。把邮件一次性从收件箱移到独立的 Rmail 文件中，Rmail 其余部分就不再需要互斥处理，因为只有 Rmail 会操作这个 Rmail 文件。</li>
</ol>

<p>
Rmail 采用 Unix 和 GNU 系统用于收件箱的标准 'mbox' 格式 作为其内部文件格式。（实际上 mbox 有几种略有差异的版本，差别不大。你可以设置变量 <code>rmail-mbox-format</code> 告诉 Rmail 系统使用的是哪种格式，详见该变量的文档。）
</p>

<p>
收取新邮件时，Rmail 会先把新邮件从收件箱复制到 Rmail 文件，然后保存 Rmail 文件，最后清空收件箱。这样一来，即使系统崩溃，最多只会在收件箱和 Rmail 文件中出现重复邮件， <b>不会丢失邮件</b> 。
</p>

<p>
如果 <code>rmail-preserve-inbox</code> 不为 nil，Rmail 收取新邮件时 <b>不会清空收件箱</b> 。你可能需要开启这个选项，例如在便携机上通过 POP 查收邮件时，让邮件保留在服务器上，之后再在主力台式机上保存。
</p>

<p>
某些情况下，Rmail 会 <b>间接</b> 从收件箱复制新邮件：先运行 <code>movemail</code> 程序，把邮件从收件箱移到一个中间文件，文件名为 .newmail-<i>收件箱名</i> ，存放在 Rmail 文件所在目录。然后 Rmail 从该文件合并新邮件、保存 Rmail 文件，之后才删除中间文件。如果恰好在此时崩溃，该文件会保留下来，下次从该收件箱收信时 Rmail 会再次使用它。
</p>

<p>
如果 Rmail 无法把 <code>.newmail-xxx</code> 中的数据转换成 mbox 格式，会把文件重命名为 <code>RMAILOSE.n</code> （n 为保证唯一的整数），避免再次出错。你需要查看该文件，找到让 Rmail 无法解析的消息（通常是包含了控制下划线字符，八进制码 037）并删除，然后用 <code>1 g</code> 从修正后的文件重新收信。
</p>
</div>
</div>
<div id="outline-container-Rmail-Files" class="outline-3">
<h3 id="Rmail-Files"><span class="section-number-3">35.6.</span> 多个 Rmail 文件</h3>
<div class="outline-text-3" id="text-Rmail-Files">
<p>
Rmail 默认操作你的 <i>主 Rmail 文件</i> ，该文件名为 <code>~/RMAIL</code> ，并从系统收件箱文件接收新邮件。但你也可以创建其他 Rmail 文件，并用 Rmail 编辑它们。这些文件可以通过各自的收件箱接收邮件，也可以通过显式的 Rmail 命令把消息移入其中（参见 “<a href="#Rmail-Output">将消息复制到文件</a>”）。
</p>

<dl class="org-dl">
<dt><code>i file RET</code></dt><dd>读取文件到 Emacs 并在其上运行 Rmail (<code>rmail-input</code>) 。</dd>
<dt><code>g</code></dt><dd>从当前 Rmail 文件对应的收件箱合并新邮件 (<code>rmail-get-new-mail</code>) 。</dd>
<dt><code>C-u g file RET</code></dt><dd>从指定的收件箱文件合并新邮件。</dd>
</dl>

<p>
要在非主 Rmail 文件上运行 Rmail，可以在 Rmail 中使用 <code>i</code> (<code>rmail-input</code>) 命令。该命令会以 Rmail 模式打开该文件。即使不在 Rmail 中，也可以使用 <code>M-x rmail-input</code> ；更简便的方式是输入 <code>C-u M-x rmail</code> ，效果相同。
</p>

<p>
用 <code>i</code> 读取的文件通常应为合法的 mbox 文件。如果不是，Rmail 会尝试将其文本转换为 mbox 格式，并在缓冲区中打开转换后的文本。保存缓冲区时，文件也会被转换。
</p>

<p>
如果指定的文件名不存在， <code>i</code> 会初始化一个新缓冲区，用于创建新的 Rmail 文件。
</p>

<p>
你也可以从菜单中选择 Rmail 文件：在 Classify 菜单中选择 'Input Rmail File' ，然后选中想要的 Rmail 文件。
</p>

<p>
变量 <code>rmail-secondary-file-directory</code> 和 <code>rmail-secondary-file-regexp</code> 用于指定菜单中显示哪些文件：
</p>
<ul class="org-ul">
<li>第一个变量指定存放这些文件的目录；</li>
<li>第二个变量指定该目录下哪些文件会被列出（所有匹配该正则表达式的文件）。</li>
</ul>

<p>
如果没有匹配的文件，则无法选中该菜单项。这些变量同样适用于选择输出文件（参见 “<a href="#Rmail-Output">将消息复制到文件</a>”）。
</p>

<p>
要使用的收件箱文件由变量 <code>rmail-inbox-list</code> 指定，该变量在 Rmail 模式下是 <b>缓冲区局部变量</b> 。一个特殊例外：如果未为主 Rmail 文件指定任何收件箱文件，它会使用环境变量 <code>MAIL</code> ，或系统标准收件箱。
</p>

<p>
<code>g</code> 命令 (<code>rmail-get-new-mail</code>) 会从当前 Rmail 文件的收件箱将邮件合并进来。如果该 Rmail 文件没有收件箱， <code>g</code> 不执行任何操作。命令 <code>M-x rmail</code> 同样会将新邮件合并到你的主 Rmail 文件。
</p>

<p>
要从 <b>非常规收件箱</b> 的文件中合并邮件，给 <code>g</code> 一个数字参数，例如 <code>C-u g</code> 。然后它会读取一个文件名，并从该文件合并邮件。使用带参数的 <code>g</code> 时，收件箱文件 <b>不会被删除或修改</b> 。因此，这是将一个消息文件合并到另一个文件的通用方法。
</p>
</div>
</div>
<div id="outline-container-Rmail-Output" class="outline-3">
<h3 id="Rmail-Output"><span class="section-number-3">35.7.</span> 将邮件复制到外部文件</h3>
<div class="outline-text-3" id="text-Rmail-Output">
<p>
这些命令用于将邮件从 Rmail 文件 <b>复制</b> 到另一个文件。
</p>
<dl class="org-dl">
<dt><code>o file RET</code></dt><dd>将当前邮件的完整副本追加到指定文件 (<code>rmail-output</code>) 。</dd>
<dt><code>C-o file RET</code></dt><dd>将当前邮件按显示状态的副本追加到指定文件 (<code>rmail-output-as-seen</code>) 。</dd>
<dt><code>w file RET</code></dt><dd>仅将邮件正文输出到指定文件，默认文件名取自邮件的「Subject」标题。</dd>
</dl>

<p>
命令 <code>o</code> 和 <code>C-o</code> 会将当前邮件复制到指定文件，并追加在文件末尾。正的前缀参数表示重复次数：从当前邮件开始，连续指定数量的邮件会被复制到文件，已删除邮件会被忽略。
</p>

<p>
这两个命令的主要区别在于复制内容：
</p>
<ul class="org-ul">
<li><code>o</code> 复制完整邮件头，即使部分标题并未显示；</li>
<li><code>C-o</code> 只复制当前实际显示的标题。详见 “<a href="#Rmail-Display">邮件显示</a>” 一节。</li>
</ul>

<p>
此外，如果输出文件是 Babyl 格式（Emacs 22 及更早版本 Rmail 使用的格式）， <code>o</code> 会将邮件转为 Babyl 格式；而 <code>C-o</code> 完全不支持输出到 Babyl 文件。
</p>

<p>
如果输出文件当前已在 Emacs 缓冲区中打开，输出命令会将邮件追加到该缓冲区，最终需要你手动保存缓冲区到文件。
</p>

<p>
有时你收到的邮件正文本身就是一个文件内容。可以用 <code>w</code> 命令 (<code>rmail-output-body-to-file</code>) 将正文单独保存到文件（不含邮件头）。这类邮件通常在「Subject」字段中包含了预期的文件名，因此 <code>w</code> 命令会用「Subject」字段作为输出文件的默认名（会替换掉文件名中不可跨平台使用的字符）。文件名通过小缓冲区读取，你可以随时指定其他名称。
</p>

<p>
你也可以通过菜单将邮件输出到 Rmail 文件：在 Classify 菜单中选择 'Output Rmail File' ，然后选择目标 Rmail 文件。效果与 <code>o</code> 命令一样，将当前邮件输出到该文件。
</p>

<p>
变量 <code>rmail-secondary-file-directory</code> 和 <code>rmail-secondary-file-regexp</code> 用于控制菜单显示哪些文件：前者指定目录，后者指定该目录下哪些文件会被列出（匹配正则表达式的文件）。无匹配文件时该菜单项不可用。
</p>

<p>
使用 <code>o</code> 或 <code>C-o</code> 复制邮件后，原邮件会被打上 'filed' 属性，当该邮件为当前邮件时，模式行会显示 'filed' 。
</p>

<p>
如果你希望每份邮件只保留一份副本，可以将变量 <code>rmail-delete-after-output</code> 设为 <code>t</code> ；这样 o、C-o、w 命令在复制完成后会自动删除原邮件。（之后可随时恢复删除，见 “<a href="#Rmail-Deletion">删除邮件</a>” 一节。）
</p>

<p>
默认情况下， <code>o</code> 输出邮件时会保留原邮件的删除状态；即输出前已删除的邮件，在输出文件中也会标记为已删除。将变量 <code>rmail-output-reset-deleted-flag</code> 设为非 nil 可取消这一行为：输出的副本会 <b>清除删除状态</b> ，在输出文件中显示为未删除。此外，当该变量非 nil 时，给 <code>o</code> 指定正参数时，在连续输出时不会忽略已删除邮件。
</p>

<p>
变量 <code>rmail-output-file-alist</code> 允许你根据当前邮件内容，智能设置输出文件的默认名。其值为一个列表，元素格式如下：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(regexp . name-exp)
</pre>
</div>

<p>
如果当前邮件匹配正则表达式 regexp，输出默认文件名就是 <i>name-exp</i> 。多个元素匹配时， <b>第一个匹配项</b> 生效。 <i>name-exp</i> 可以是直接字符串，也可以是任意能返回文件名的 Lisp 表达式。 <code>rmail-output-file-alist</code> 对 <code>o</code> 和 <code>C-o</code> 都生效。
</p>

<p>
Rmail 可以根据变量 <code>rmail-automatic-folder-directives</code> ，将主 Rmail 文件（由 <code>rmail-file-name</code> 指定）中的邮件自动保存到其他文件。该变量是一组 “规则”，指明哪些邮件保存到哪里。每条规则是一个列表：第一个元素是输出文件，后面是一个或多个「标题名 + 正则表达式」对。只要邮件标题匹配对应正则表达式，就会被保存到指定文件。多条标题规则时需要 <b>全部匹配</b> 。Rmail 在显示主 Rmail 文件的邮件时检查规则，并应用第一条匹配项。如果输出文件为 <code>nil</code> ，邮件会被直接删除而不保存。例如，你可以用此功能将来自特定发件人、或特定主题的邮件自动归档到专用文件。
</p>
</div>
</div>
<div id="outline-container-Rmail-Labels" class="outline-3">
<h3 id="Rmail-Labels"><span class="section-number-3">35.8.</span> 标签</h3>
<div class="outline-text-3" id="text-Rmail-Labels">
<p>
每封邮件都可以被赋予多种标签，用于分类。每个标签都有名称；不同名称即为不同标签。对于某一封邮件，任意标签要么存在，要么不存在。有少数标签名称具有标准含义，会在合适时由 Rmail 自动赋予邮件，这些特殊标签称为 <i>attributes属性</i> 。（见 <a href="#Rmail-Attributes">Rmail 属性</a>。）其余所有标签只能由用户手动赋予。
</p>

<dl class="org-dl">
<dt><code>a label RET</code></dt><dd>为当前邮件添加指定标签 (<code>rmail-add-label</code>) 。</dd>
<dt><code>k label RET</code></dt><dd>从当前邮件移除指定标签 (<code>rmail-kill-label</code>) 。</dd>
<dt><code>C-M-n label RET</code></dt><dd>跳转到下一条带有指定标签中任意一个的邮件 (<code>rmail-next-labeled-message</code>) 。</dd>
<dt><code>C-M-p labels RET</code></dt><dd>跳转到上一条带有指定标签中任意一个的邮件 (<code>rmail-previous-labeled-message</code>) 。</dd>
<dt><code>l labels RET</code></dt><dd></dd>

<dt><code>- C-M-l labels RET</code></dt><dd>为所有带有指定标签中任意一个的邮件生成摘要 (<code>rmail-summary-by-labels</code>) 。</dd>
</dl>

<p>
<code>a</code> (<code>rmail-add-label</code>) 和 <code>k</code> (<code>rmail-kill-label</code>) 命令允许你为当前邮件添加或移除任意标签。如果标签参数为空，则表示添加或移除 <b>最近一次</b> 使用过的标签。
</p>

<p>
在你按需要给邮件打上标签分类后，有三种使用标签的方式：跳转邮件、生成摘要、排序。
</p>

<p>
<code>C-M-n labels RET</code> (<code>rmail-next-labeled-message</code>) 跳转到下一条带有指定标签中任意一个的邮件。参数 <i>labels</i> 可以是一个或多个标签名，用逗号分隔。 <code>C-M-p</code> (<code>rmail-previous-labeled-message</code>) 用法类似，只是向前跳转。这两个命令都可以使用数字参数作为跳转次数。
</p>

<p>
<code>C-M-l labels RET</code> (<code>rmail-summary-by-labels</code>) 命令只显示 <b>至少带有指定标签中</b> 一个的邮件摘要。参数 <i>labels</i> 为一个或多个标签名，用逗号分隔。关于摘要的更多信息，见 “<a href="#Rmail-Summary">摘要</a>” 一节。
</p>

<p>
如果给 <code>C-M-n</code> 、 <code>C-M-p</code> 或 <code>C-M-l</code> 的标签参数为空，则表示 <b>复用最近一次</b> 这些命令用过的标签组。
</p>

<p>
关于使用标签对 Rmail 文件中的邮件排序，见 “<a href="#Rmail-Sorting">对 Rmail 文件排序</a>” 一节。
</p>
</div>
</div>
<div id="outline-container-Rmail-Attributes" class="outline-3">
<h3 id="Rmail-Attributes"><span class="section-number-3">35.9.</span> Rmail 属性</h3>
<div class="outline-text-3" id="text-Rmail-Attributes">
<p>
有些标签（如 'deleted' 和 'filed' ）具有内置含义，Rmail 会在合适时机自动把它们赋给邮件；这类标签称为属性。以下是 Rmail 所有属性列表：
</p>

<dl class="org-dl">
<dt>'<code>unseen</code>'</dt><dd>表示该邮件从未被查看过。邮件从收件箱文件导入时会被加上该属性，在邮件被设为当前邮件时移除。启动 Rmail 时，默认显示第一个带有此属性的邮件。</dd>
<dt>'<code>deleted</code>'</dt><dd>表示该邮件已被标记删除。由删除命令添加，由恢复删除命令移除（见 “<a href="#Rmail-Deletion">删除消息</a>”）。</dd>
<dt>'<code>filed</code>'</dt><dd>表示该邮件已被归档复制到其他文件。由 <code>o</code> 和 <code>C-o</code> 输出命令自动添加（见 “<a href="#Rmail-Output">将邮件复制输出到文件</a>”）。</dd>
<dt>'<code>answered</code>'</dt><dd>表示你已回复过该邮件。由 <code>r</code> 命令 (<code>rmail-reply</code>) 添加。见 “<a href="#Rmail-Reply">发送回复</a>”。</dd>
<dt>'<code>forwarded</code>'</dt><dd>表示你已转发过该邮件。由 <code>f</code> 命令 (<code>rmail-forward</code>) 添加。见 “<a href="#Rmail-Reply">发送回复</a>”。</dd>
<dt>'<code>edited</code>'</dt><dd>表示你已在 Rmail 内部编辑过该邮件的文本。见 “<a href="#Rmail-Editing">在邮件内编辑</a>”。</dd>
<dt>'<code>resent</code>'</dt><dd>表示你已重发过该邮件。由命令 <code>M-x rmail-resend</code> 添加。见 “<a href="#Rmail-Reply">发送回复</a>”。</dd>
<dt>'<code>retried</code>'</dt><dd>表示你已重试发送过一封失败的外发邮件。由命令 <code>M-x rmail-retry-failure</code> 添加。见 “<a href="#Rmail-Reply">发送回复</a>”。</dd>
</dl>

<p>
所有其他标签都只能由用户手动添加或删除，没有预定义含义。
</p>
</div>
</div>
<div id="outline-container-Rmail-Reply" class="outline-3">
<h3 id="Rmail-Reply"><span class="section-number-3">35.10.</span> 发送回复</h3>
<div class="outline-text-3" id="text-Rmail-Reply">
<p>
Rmail 提供多条命令用于发送外发邮件。关于使用 Message 模式（包括一些专门配合 Rmail 使用的功能），详见 “<a href="#Sending-Mail">发送邮件</a>” 一节。本节主要记录 Rmail 中用于进入邮件缓冲区以撰写外发邮件的专用命令。注意：常规发送邮件的快捷键 <code>C-x m</code> 、 <code>C-x 4 m</code> 、 <code>C-x 5 m</code> 在 Rmail 模式下同样正常可用。
</p>

<dl class="org-dl">
<dt><code>m</code></dt><dd>撰写一封新邮件 (<code>rmail-mail</code>) 。</dd>
<dt><code>c</code></dt><dd>继续编辑已开始撰写的外发邮件 (<code>rmail-continue</code>)。</dd>
<dt><code>r</code></dt><dd>回复当前 Rmail 邮件 (<code>rmail-reply</code>)。</dd>
<dt><code>f</code></dt><dd>将当前邮件转发给其他用户 (<code>rmail-forward</code>)。</dd>
<dt><code>C-u f</code></dt><dd>重发当前邮件给其他用户 (<code>rmail-resend</code>)。</dd>
<dt><code>M-m</code></dt><dd>重试发送被退回的邮件 (<code>rmail-retry-failure</code>)。</dd>
</dl>

<p>
在 Rmail 中发送邮件最常见的场景，是回复正在阅读的邮件。为此，输入 <code>r</code> (<code>rmail-reply</code>)。它会在另一个窗口中显示邮件撰写缓冲区，用法类似 <code>C-x 4 m</code> ，但会根据你正在回复的邮件 <b>自动预填</b> 以下邮件头字段：Subject、To、CC、In-Reply-To、References。
</p>

<ul class="org-ul">
<li>To 字段初始为原邮件发件人地址。</li>
<li>CC 字段初始为原邮件的所有其他收件人。</li>
</ul>

<p>
你可以使用变量 <code>mail-dont-reply-to-names</code> ，将某些收件人自动排除在回复之外。它的值应为一个正则表达式；任何匹配的收件人都会从 '<code>CC</code>' 字段中排除。它们也会从 '<code>To</code>' 字段排除，除非这样会使 '<code>To</code>' 为空。如果该变量为 <code>nil</code> ，则第一次撰写回复时会被初始化为一个匹配你自己地址的默认值。
</p>

<p>
如果只想仅回复给原发件人，可以给回复命令带上数字参数： <code>C-u r</code> 或 <code>1 r</code> 。这会在本次回复中完全省略 '<code>CC</code>' 字段。
</p>

<p>
邮件撰写缓冲区初始化完成后，编辑与发送邮件的操作与平常一致（见 “<a href="#Sending-Mail">发送邮件</a>”）。你可以修改预设的邮件头字段，也可以使用如 <code>C-c C-y</code> 这样的命令插入正在回复的原邮件内容（见 “<a href="#Mail-Commands">邮件命令</a>”）。你也可以切回 Rmail 缓冲区，选中另一封邮件，再切回撰写缓冲区插入新的当前邮件。
</p>

<p>
有时邮件无法送达目的地，邮件系统通常会将失败邮件退回给你，并包含在一封退信中。Rmail 命令 <code>M-m</code> (<code>rmail-retry-failure</code>) 会准备重新发送同一封邮件：它会创建一个与之前文本、头字段完全相同的撰写缓冲区。如果直接输入 <code>C-c C-c</code> ，就会和第一次一模一样地重发；你也可以先编辑正文或头部再发送。
</p>

<p>
变量 <code>rmail-retry-ignored-headers</code> （格式与 <code>rmail-ignored-headers</code> 相同，见 “<a href="#Rmail-Display">邮件显示</a>”）用于控制在重试发送时，从失败邮件中 <b>剔除哪些头部字段</b> 。
</p>

<p>
在 Rmail 中发送邮件的另一常见场景是转发当前邮件给他人。 <code>f</code> (<code>rmail-forward</code>) 简化了这一操作：自动在邮件撰写缓冲区中填入当前邮件作为正文，并生成形如 <code>[from: subject]</code> 的主题。你只需填写收件人并发送即可。转发邮件时，收件人会看到发件人是你，原邮件作为内容包含在内。
</p>

<p>
Rmail 提供两种转发邮件格式：
</p>
<ul class="org-ul">
<li>默认使用 MIME 格式（见 “<a href="#Rmail-Display">邮件显示</a>”），将原邮件作为独立附件。</li>
<li>若将变量 <code>rmail-enable-mime-composing</code> 设为 <code>nil</code> ，则使用更简单的格式：</li>
</ul>
<p>
原邮件直接包裹在分隔行之间，并对所有以短横线开头的行自动在行首插入 '- ' ，避免格式冲突。
</p>

<p>
当你收到这种格式的转发邮件时（例如里面包含代码等非纯文本内容），可以撤销该转换：选中这封转发邮件，执行 <code>M-x unforward-rmail-message</code> 。该命令会提取原始转发邮件，删除插入的 '- ' 字符串，并将其作为一封独立邮件插入到当前邮件之后。
</p>

<p>
重发（Resending） 是与转发类似的另一种方式，区别在于：重发的邮件发件人仍显示为原作者，就像邮件直接从对方发来一样，只额外添加 'Resent-From' 和 'Resent-To' 头部，表示经由你转发。在 Rmail 中重发邮件使用 <code>C-u f</code> 。（ <code>f</code> 命令默认执行 <code>rmail-forward</code> ，带上数字参数时会调用 <code>rmail-resend</code> 。）
</p>

<p>
使用 <code>m</code> (<code>rmail-mail</code>) 命令开始撰写非回复类的新邮件，头部字段为空。它与 <code>C-x 4 m</code> 的唯一区别是：和 <code>r</code> 一样，允许在撰写时用 <code>C-c C-y</code> 从 Rmail 缓冲区插入内容。
</p>

<p>
<code>c</code> (<code>rmail-continue</code>) 命令用于继续编辑邮件撰写缓冲区，完成之前未写完的外发邮件，或修改已发送过的邮件。
</p>

<p>
如果将变量 <code>rmail-mail-new-frame</code> 设为非 nil，那么所有 Rmail 发信命令都会新建一个框架（frame）来编辑邮件，发送邮件后该框架会被删除（但如果是当前显示器上唯一可见框架，或文本模式框架，则不会删除）。如果无法删除，Emacs 会在下一次撰写邮件时复用该框架。
</p>

<p>
所有 Rmail 发送邮件的命令，都会使用你选定的邮件撰写方法（见 “<a href="#Mail-Methods">邮件撰写方法</a>”）。
</p>
</div>
</div>
<div id="outline-container-Rmail-Summary" class="outline-3">
<h3 id="Rmail-Summary"><span class="section-number-3">35.11.</span> 摘要</h3>
<div class="outline-text-3" id="text-Rmail-Summary">
<p>
<i>summary摘要</i> 是一个缓冲区，其中每一行对应一封邮件，让你概览 Rmail 文件中的所有邮件。每一行会显示：邮件编号、日期、发件人、行数、标签以及主题。在摘要缓冲区中移动光标到某一行，就会选中对应的那封邮件。几乎所有 Rmail 命令在摘要缓冲区中同样有效；在摘要中使用时，这些命令会作用于当前行所对应的邮件。
</p>

<p>
一个摘要缓冲区只对应一个 Rmail 文件；如果你在编辑多个 Rmail 文件，每个文件都可以有自己的摘要缓冲区。摘要缓冲区的名称是在 Rmail 缓冲区名称后加上 '-summary' 。通常一次只显示一个摘要缓冲区。
</p>

<ul class="org-ul">
<li><a href="#Rmail-Make-Summary">生成摘要</a></li>
<li><a href="#Rmail-Summary-Edit">在摘要中编辑</a></li>
</ul>
</div>
<div id="outline-container-Rmail-Make-Summary" class="outline-4">
<h4 id="Rmail-Make-Summary"><span class="section-number-4">35.11.1.</span> 生成摘要</h4>
<div class="outline-text-4" id="text-Rmail-Make-Summary">
<p>
以下是为当前 Rmail 缓冲区创建摘要的命令。一旦 Rmail 缓冲区拥有了摘要，Rmail 缓冲区里的改动（如删除或清除邮件、收取新邮件）都会自动更新摘要。
</p>

<dl class="org-dl">
<dt><code>h</code></dt><dd></dd>

<dt><code>C-M-h</code></dt><dd>为所有邮件生成摘要（rmail-summary）。</dd>
<dt><code>l labels RET</code></dt><dd></dd>

<dt><code>C-M-l labels RET</code></dt><dd>为带有指定标签中至少一个的邮件生成摘要 (<code>rmail-summary-by-labels</code>)。</dd>
<dt><code>C-M-r rcpts RET</code></dt><dd>为匹配指定收件人的邮件生成摘要 (<code>rmail-summary-by-recipients</code>) 。</dd>
<dt><code>C-M-t topic RET</code></dt><dd>为主题中匹配指定正则表达式的邮件生成摘要 (<code>rmail-summary-by-topic</code>) 。</dd>
<dt><code>C-M-s regexp RET</code></dt><dd>为邮件头匹配指定正则表达式的邮件生成摘要 (<code>rmail-summary-by-regexp</code>) 。</dd>
<dt><code>C-M-f senders RET</code></dt><dd>为匹配指定发件人的邮件生成摘要 (<code>rmail-summary-by-senders</code>)。</dd>
</dl>

<p>
<code>h</code> 或 <code>C-M-h</code> (<code>rmail-summary</code>) 命令会在当前 Rmail 缓冲区的摘要缓冲区中填入所有邮件的摘要，并在另一个窗口显示并选中该摘要缓冲区。
</p>

<p>
<code>C-M-l labels RET</code> (<code>rmail-summary-by-labels</code>) 只生成包含至少一个指定标签的邮件摘要。多个标签用逗号分隔。
</p>

<p>
<code>C-M-r rcpts RET</code> (<code>rmail-summary-by-recipients</code>) 只生成收件人匹配正则表达式的邮件摘要。匹配会检查 To、From 和 CC 头（使用前缀参数可排除 CC）。
</p>

<p>
<code>C-M-t topic RET</code> (<code>rmail-summary-by-topic</code>) 只生成主题匹配正则表达式的邮件摘要。使用前缀参数时，会匹配整个邮件而非仅主题。
</p>

<p>
<code>C-M-s regexp RET</code> (<code>rmail-summary-by-regexp</code>) 只生成邮件头（含日期与主题行）匹配正则表达式的邮件摘要。
</p>

<p>
<code>C-M-f senders RET</code> (<code>rmail-summary-by-senders</code>) 只生成 'From' 字段匹配正则表达式的邮件摘要。
</p>

<p>
注意：每个 Rmail 缓冲区只有一个摘要缓冲区；生成任何新摘要都会覆盖之前的摘要。
</p>

<p>
变量 <code>rmail-summary-window-size</code> 用于设置摘要窗口的行数。变量 <code>rmail-summary-line-count-flag</code> 控制摘要行是否显示邮件行数。将其设为 <code>nil</code> 可加快摘要生成速度。
</p>
</div>
</div>
<div id="outline-container-Rmail-Summary-Edit" class="outline-4">
<h4 id="Rmail-Summary-Edit"><span class="section-number-4">35.11.2.</span> 在摘要中编辑</h4>
<div class="outline-text-4" id="text-Rmail-Summary-Edit">
<p>
你可以使用 Rmail 摘要缓冲区完成几乎所有在 Rmail 缓冲区本身能做的操作。实际上，一旦拥有摘要缓冲区，就无需切回 Rmail 缓冲区。
</p>

<p>
只需在摘要缓冲区中将光标移动到不同行，即可从中选择并显示 Rmail 缓冲区中的各类邮件。无论你使用何种 Emacs 命令移动光标，命令执行后光标所在的行，都会在 Rmail 缓冲区中选中对应邮件。
</p>

<p>
几乎所有 Rmail 命令在摘要缓冲区和 Rmail 缓冲区中都能生效。因此，在摘要缓冲区中按 <code>d</code> 删除当前邮件， <code>u</code> 取消删除， <code>x</code> 彻底清除。（但在摘要缓冲区中，若对应方向已无未删除邮件，删除命令会跳转到第一封或最后一封邮件，而非停留在当前邮件。） <code>o</code> 和 <code>C-o</code> 将当前邮件输出到文件； <code>r</code> 回复该邮件；等等。你可以在摘要缓冲区中使用 <code>SPC</code> 和 <code>DEL</code> 滚动当前邮件。不过，在摘要缓冲区中，用 <code>SPC</code> 或 <code>DEL</code> 滚动超出邮件末尾或开头时，会分别跳转到下一封或上一封未删除邮件。将 <code>rmail-summary-scroll-between-messages</code> 选项设为 <code>nil</code> 可禁用跳转到下一封 / 上一封邮件的功能。
</p>

<p>
<code>M-u</code> (<code>rmail-summary-undelete-many</code>) 恢复摘要中所有已删除邮件。带前缀参数表示恢复此前指定数量的已删除邮件。
</p>

<p>
用于在邮件间切换的 Rmail 命令在摘要缓冲区中同样有效，但有一个区别：它们只会遍历摘要中包含的邮件。这些命令还会确保 Rmail 缓冲区显示在屏幕上（不同于光标移动命令，后者仅更新 Rmail 缓冲区内容，若其未在窗口中显示则不会主动展示）。以下是这些命令列表：
</p>

<dl class="org-dl">
<dt><code>n</code></dt><dd>跳转到下一行（跳过标记为 “已删除” 的行）并选中对应邮件 (<code>rmail-summary-next-msg</code>) 。</dd>
<dt><code>p</code></dt><dd>跳转到上一行（跳过标记为 “已删除” 的行）并选中对应邮件 (<code>rmail-summary-previous-msg</code>)。</dd>
<dt><code>M-n</code></dt><dd>跳转到下一行并选中对应邮件 (<code>rmail-summary-next-all</code>)。</dd>
<dt><code>M-p</code></dt><dd>跳转到上一行并选中对应邮件 (<code>rmail-summary-previous-all</code>)。</dd>
<dt><code>&gt;</code></dt><dd>跳转到最后一行并选中对应邮件 (<code>rmail-summary-last-message</code>)。</dd>
<dt><code>&lt;</code></dt><dd>跳转到第一行并选中对应邮件 (<code>rmail-summary-first-message</code>)。</dd>
<dt><code>j</code></dt><dd></dd>

<dt><code>RET</code></dt><dd>选中当前行对应的邮件（确保 Rmail 缓冲区显示在屏幕上； <code>rmail-summary-goto-msg</code> ）。带参数 n 则选中第 n 封邮件并跳转到其在摘要缓冲区的行；若该邮件未在摘要中列出，会报错。</dd>
<dt><code>M-s pattern RET</code></dt><dd>从当前邮件开始搜索指定模式；选中找到的邮件，并将光标移到摘要缓冲区中该邮件的行 (<code>rmail-summary-search</code>) 。前缀参数为重复次数；负数参数表示反向搜索（等价于 <code>rmail-summary-search-backward</code> ）。</dd>
<dt><code>C-M-n labels RET</code></dt><dd>跳转到下一封带有至少一个指定标签的邮件 (<code>rmail-summary-next-labeled-message</code>)。labels 为逗号分隔的标签列表。前缀参数为重复次数。</dd>
<dt><code>C-M-p labels RET</code></dt><dd>跳转到上一封带有至少一个指定标签的邮件 (<code>rmail-summary-previous-labeled-message</code>)。</dd>
<dt><code>C-c C-n RET</code></dt><dd>跳转到下一封与当前邮件主题相同的邮件 (<code>rmail-summary-next-same-subject</code>)。前缀参数为重复次数。</dd>
<dt><code>C-c C-p RET</code></dt><dd>跳转到上一封与当前邮件主题相同的邮件 (<code>rmail-summary-previous-same-subject</code>)。</dd>
</dl>

<p>
在 Rmail 缓冲区中执行删除、取消删除、收取新邮件，甚至切换选中邮件时，都会自动更新摘要缓冲区。若变量 <code>rmail-redisplay-summary</code> 不为 nil，这些操作还会将摘要缓冲区重新显示在屏幕上。
</p>

<p>
使用完摘要后，按 <code>Q</code> (<code>rmail-summary-wipe</code>) 关闭摘要缓冲区窗口。你也可以在摘要界面退出 Rmail： <code>q</code> (<code>rmail-summary-quit</code>) 关闭摘要窗口，随后保存 Rmail 文件并切换到其他缓冲区，从而退出 Rmail。此外，按 <code>b</code> (<code>rmail-summary-bury</code>) 可直接隐藏 Rmail 摘要及缓冲区。
</p>
</div>
</div>
</div>
<div id="outline-container-Rmail-Sorting" class="outline-3">
<h3 id="Rmail-Sorting"><span class="section-number-3">35.12.</span> Rmail 文件排序</h3>
<div class="outline-text-3" id="text-Rmail-Sorting">
<dl class="org-dl">
<dt><code>C-c C-s C-d</code></dt><dd></dd>

<dt><code>M-x rmail-sort-by-date</code></dt><dd>按日期对当前 Rmail 缓冲区的邮件排序。</dd>
<dt><code>C-c C-s C-s</code></dt><dd></dd>

<dt><code>M-x rmail-sort-by-subject</code></dt><dd>按主题对当前 Rmail 缓冲区的邮件排序。</dd>
<dt><code>C-c C-s C-a</code></dt><dd></dd>

<dt><code>M-x rmail-sort-by-author</code></dt><dd>按发件人姓名对当前 Rmail 缓冲区的邮件排序。</dd>
<dt><code>C-c C-s C-r</code></dt><dd></dd>

<dt><code>M-x rmail-sort-by-recipient</code></dt><dd>按收件人姓名对当前 Rmail 缓冲区的邮件排序。</dd>
<dt><code>C-c C-s C-c</code></dt><dd></dd>

<dt><code>M-x rmail-sort-by-correspondent</code></dt><dd>按通信对方姓名对当前 Rmail 缓冲区的邮件排序。</dd>
<dt><code>C-c C-s C-l</code></dt><dd></dd>

<dt><code>M-x rmail-sort-by-lines</code></dt><dd>按行数对当前 Rmail 缓冲区的邮件排序。</dd>
<dt><code>C-c C-s C-k RET labels RET</code></dt><dd></dd>

<dt><code>M-x rmail-sort-by-labels RET labels RET</code></dt><dd>按标签对当前 Rmail 缓冲区的邮件排序。参数 <i>labels</i> 应为逗号分隔的标签列表。这些标签的顺序决定邮件顺序：带有第一个标签的邮件排在最前，第二个标签次之，依此类推。不包含这些标签的邮件排在最后。</dd>
</dl>

<p>
Rmail 的排序命令采用 <b><i>stable sort稳定排序</i></b> ：若两封邮件无明确排序优先级，它们的相对顺序保持不变。你可以利用这一点实现 <b>多条件排序</b> 。例如，先按日期排序 <code>rmail-sort-by-date</code> ，再按作者排序 <code>rmail-sort-by-author</code> ，同一作者的邮件就会按日期顺序排列。
</p>

<p>
所有这些命令带上前缀参数时，会反转排序顺序：即按最新到最旧、最大到最小，或逆字母序排列。
</p>

<p>
在摘要缓冲区中，相同快捷键执行类似功能；例如 <code>C-c C-s C-l</code> 对应 <code>rmail-summary-sort-by-lines</code> 。即使摘要只显示部分邮件，这些命令也始终对 <b>整个 Rmail 缓冲区</b> 排序。
</p>

<p>
注意： <b>排序操作无法撤销</b> ，因此建议在排序前先保存 Rmail 缓冲区。
</p>
</div>
</div>
<div id="outline-container-Rmail-Display" class="outline-3">
<h3 id="Rmail-Display"><span class="section-number-3">35.13.</span> 邮件显示</h3>
<div class="outline-text-3" id="text-Rmail-Display">
<p>
本节介绍 Rmail 如何显示邮件头、MIME 段落与附件、URL 以及加密邮件。
</p>

<dl class="org-dl">
<dt><code>t</code></dt><dd>切换显示完整邮件头 (<code>rmail-toggle-header</code>) 。</dd>
</dl>

<p>
在首次显示每封邮件前，Rmail 会重新格式化邮件头，隐藏无关的头字段以减少杂乱。 <code>t</code> (<code>rmail-toggle-header</code>) 命令可在格式化后的简化头与完整原始头之间切换。带正前缀参数时显示简化头；带 0 或负前缀参数时显示完整头。重新选中该邮件时也会按需重新格式化。
</p>

<p>
变量 <code>rmail-ignored-headers</code> 存放一个正则表达式，用于指定要隐藏的头字段；匹配的行会被隐藏。变量 <code>rmail-nonignored-headers</code> 会覆盖它：即使匹配前者，只要匹配后者就会显示。变量 <code>rmail-displayed-headers</code> 是另一种方案：若非 nil，它用正则表达式指定只显示哪些头（默认为 <code>nil</code> ）。
</p>

<p>
Rmail 会高亮特别重要的头字段，默认是 'From' 和 'Subject' 字段。高亮使用 <code>rmail-highlight</code> 样式。变量 <code>rmail-highlighted-headers</code> 存放正则表达式，匹配开头的整个头字段会被高亮。要关闭此功能，将其设为 <code>nil</code> 。
</p>

<p>
如果邮件是 MIME（多用途互联网邮件扩展）格式并包含多个部分（MIME 实体），Rmail 会为每个部分显示一个标签行（tagline），汇总该部分的序号、大小和内容类型。根据内容类型不同，标签行还可能包含一个或多个按钮，用于执行保存到文件等操作。
</p>

<dl class="org-dl">
<dt><code>RET</code></dt><dd>隐藏或显示光标处的 MIME 部分 (<code>rmail-mime-toggle-hidden</code>)。</dd>
<dt><code>TAB</code></dt><dd>将光标移到下一个 MIME 标签行按钮 (<code>rmail-mime-next-item</code>)。</dd>
<dt><code>S-TAB</code></dt><dd>将光标移到上一个 MIME 部分 (<code>rmail-mime-previous-item</code>)。</dd>
<dt><code>v</code></dt><dd>在 MIME 显示与原始邮件之间切换 (<code>rmail-mime</code>)。</dd>
</dl>

<p>
每个纯文本 MIME 部分默认直接显示在标签行后，作为 Rmail 缓冲区的一部分（除非邮件包含 HTML 部分，见下文）。其他类型的 MIME 部分默认只显示标签行，内容隐藏。无论哪种情况，在该部分或其标签行（非按钮区域）按 <code>RET</code> 都可以切换显示 / 隐藏。按 <code>RET</code> （或鼠标点击）激活标签行按钮，用 <code>TAB</code> 在按钮间切换。
</p>

<p>
<code>v</code> (<code>rmail-mime</code>) 命令在上述默认 MIME 显示与 <b>未解码的原始 MIME 数据</b> 之间切换。带前缀参数时，只切换光标所在实体的显示。
</p>

<p>
如果邮件包含 HTML MIME 部分，且 Emacs 能渲染 HTML<sup><a id="fnr.20" class="footref" href="#fn.20" role="doc-backlink">20</a></sup>，Rmail 优先显示 HTML 而非纯文本。要改为优先显示纯文本，将变量 <code>rmail-mime-prefer-html</code> 设为 <code>nil</code> 。
</p>

<p>
若要让 Rmail 不处理 MIME 解码，将 <code>rmail-enable-mime</code> 设为 <code>nil</code> 。此时 <code>v</code> (<code>rmail-mime</code>) 会创建临时缓冲区显示当前 MIME 邮件。
</p>

<p>
如果当前邮件是加密邮件，使用 <code>C-c C-d</code> (<code>rmail-epa-decrypt</code>) 解密，依赖 EasyPG 库（见《EasyPG 助手用户手册》中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/epa/index.html#Top">EasyPG</a>）。
</p>

<p>
你可以通过 Goto Address 模式高亮并激活 Rmail 缓冲区中的 URL：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'rmail-show-message-hook 'goto-address-mode)
</pre>
</div>

<p>
之后可用鼠标中键（或快速点击左键）浏览 URL，或将光标移至 URL 并按 <code>C-c RET</code> 。参见 “<a href="#Goto-Address-mode">激活 URL</a>”。
</p>
</div>
</div>
<div id="outline-container-Rmail-Coding" class="outline-3">
<h3 id="Rmail-Coding"><span class="section-number-3">35.14.</span> Rmail 与编码系统</h3>
<div class="outline-text-3" id="text-Rmail-Coding">
<p>
Rmail 会自动解码包含非 ASCII 字符的邮件，就像 Emacs 处理你打开的文件和子进程输出一样。Rmail 会利用邮件中标准的 'charset=字符集' 头（如果存在），判断发件人对邮件的编码方式。它会将 <i>charset字符集</i> 映射到对应的 Emacs 编码系统（见 “<a href="#Coding-Systems">编码系统</a>”），并用该编码系统解码邮件文本。如果邮件头没有 'charset' 说明，或该字符集无法识别，Rmail 会使用 Emacs 常规的启发式规则与默认值选择编码系统（见 “<a href="#Recognize-Coding">识别编码系统</a>”）。
</p>

<p>
偶尔会出现邮件解码错误的情况，原因可能是：在缺少 'charset' 说明时 Emacs 猜错了编码系统，或是该说明本身不准确。例如，配置错误的邮件客户端可能发出标有 'charset=iso-8859-1' 的邮件，但实际编码却是 <code>koi8-r</code> 。当你看到邮件文本乱码、部分字符显示为十六进制码或空白方框时，通常就是发生了这种问题。
</p>

<p>
如果你能判断或猜出正确的编码系统，可以用它重新解码邮件来修正问题。方法是执行命令 <code>M-x rmail-redecode-body</code> 。它会读取一个编码系统名称，然后用你指定的编码系统重新解码邮件。只要编码系统选对，邮件就会恢复正常可读。
</p>

<p>
在 Rmail 中收取新邮件时，每封邮件都会自动从其原始编码系统转换，就像它们是独立文件一样。这一过程使用你指定的编码系统优先级列表。如果 MIME 邮件指定了字符集，Rmail 会遵循该设置。对于 Rmail 文件本身的读取与保存，Emacs 使用变量 <code>rmail-file-coding-system</code> 指定的编码系统。其默认值为 <code>nil</code> ，表示 Rmail 文件不进行转换（直接以 Emacs 内部字符编码读写）。
</p>
</div>
</div>
<div id="outline-container-Rmail-Editing" class="outline-3">
<h3 id="Rmail-Editing"><span class="section-number-3">35.15.</span> 邮件内编辑</h3>
<div class="outline-text-3" id="text-Rmail-Editing">
<p>
Rmail 模式下可以使用大部分常用的 Emacs 按键绑定，尽管少数按键（如 <code>C-M-n</code> 和 <code>C-M-h</code> ）会被 Rmail 重新定义为其他用途。不过，Rmail 缓冲区默认是 <b>只读</b> 的，并且大部分字母键都被重新定义为 Rmail 命令。如果你想要编辑邮件正文，必须使用 Rmail 命令 <code>e</code> 。
</p>

<dl class="org-dl">
<dt><code>e</code></dt><dd>以普通文本形式编辑当前邮件。</dd>
</dl>

<p>
<code>e</code> 命令 (<code>rmail-edit-current-message</code>) 会从 Rmail 模式切换到 Rmail 编辑模式，这是另一种主模式，与 Text 模式基本一致。模式行上会显示这个变化。
</p>

<p>
在 Rmail 编辑模式下，字母按键会像平常一样插入字符，Rmail 命令不再生效。你可以编辑邮件正文和头字段。编辑完成后，按 <code>C-c C-c</code> (<code>rmail-cease-edit</code>) 即可切回 Rmail 模式。另外，你也可以按 <code>C-c C-]</code> (<code>rmail-abort-edit</code>) 返回 Rmail 模式，并放弃本次所有编辑修改。
</p>

<p>
进入 Rmail 编辑模式时会先运行钩子 <code>text-mode-hook</code> ，然后运行 <code>rmail-edit-mode-hook</code> （见 <a href="#Hooks">Hooks</a>）。如果在编辑模式中做了任何修改，切回普通 Rmail 模式后，邮件会被加上 'edited' （已编辑）属性（见 <a href="#Rmail-Attributes">Rmail Attributes</a>）。
</p>
</div>
</div>
<div id="outline-container-Rmail-Digest" class="outline-3">
<h3 id="Rmail-Digest"><span class="section-number-3">35.16.</span> 邮件摘要</h3>
<div class="outline-text-3" id="text-Rmail-Digest">
<p>
合集邮件（digest message） 是一种用来容纳、承载多封其他邮件的邮件。合集邮件常用于某些邮件列表：在一天等一段时间内，发送到该列表的所有邮件会被打包进一封合集邮件，再发送给订阅者。虽然总大小相同，但传输一封合集邮件比单独传输每一封邮件更节省计算机资源，因为网络邮件传输中每封邮件都有固定开销。
</p>

<p>
当你收到一封合集邮件时，最方便的阅读方式是 <b><i>undigestify将其拆封</i></b> ：把它还原成多封独立邮件。之后你就可以按自己的需要阅读、删除这些单封邮件。
</p>

<p>
操作方法：选中该合集邮件，执行命令 <code>M-x undigestify-rmail-message</code> 。该命令会把其中的子邮件提取为独立的 Rmail 邮件，并插入在合集邮件之后。合集邮件本身会被标记为已删除。
</p>
</div>
</div>
<div id="outline-container-Rmail-Rot13" class="outline-3">
<h3 id="Rmail-Rot13"><span class="section-number-3">35.17.</span> 阅读 Rot13 加密邮件</h3>
<div class="outline-text-3" id="text-Rmail-Rot13">
<p>
某些可能冒犯或引起部分读者不适的邮件列表消息，会使用一种名为 <i>rot13</i> 的简单编码进行处理 —— 之所以叫这个名字，是因为它将字母表循环偏移 13 位。这种编码 <b>并非用于保密</b> ，而是让不想看到原文的人可以选择不查看。例如，电影影评可能会用 rot13 隐藏关键剧情。
</p>

<p>
要查看使用 rot13 编码的缓冲区内容，使用命令 <code>M-x rot13-other-window</code> 。该命令会在另一个窗口中显示当前缓冲区，并在显示时自动解码。
</p>

<p>
如果你只想处理某一区域，可使用命令 <code>M-x rot13-region</code> 。它会原地对选中区域进行编码 / 解码。如果缓冲区是只读的，它会尝试在回显区显示明文；如果文本过长，超出回显区长度，命令会弹出一个临时缓冲区来显示编码 / 解码后的内容。
</p>
</div>
</div>
<div id="outline-container-Movemail" class="outline-3">
<h3 id="Movemail"><span class="section-number-3">35.18.</span> movemail 程序</h3>
<div class="outline-text-3" id="text-Movemail">
<p>
Rmail 使用 <code>movemail</code> 程序将邮件从收件箱移动到你的 Rmail 文件（见 <a href="#Rmail-Inbox">Rmail 文件与收件箱</a>）。首次加载时，Rmail 会尝试查找 movemail 程序并检测其版本。
</p>

<p>
movemail 有两个版本：
</p>
<ul class="org-ul">
<li>GNU Mailutils 版本（见 GNU Mailutils 手册中的 <a href="https://www.gnu.org/software/mailutils/manual/html_node/movemail.html#movemail">movemail</a>）</li>
<li>Emacs 专用版本：除非配置 Emacs 时使用了 <code>--with-mailutils</code> ，否则会编译并安装此版本。</li>
</ul>

<p>
两个版本的 <code>movemail</code> 支持相同的命令行语法和基本选项集，但 Mailutils 版本提供更多功能且更安全。
</p>

<p>
Emacs 版 <code>movemail</code> 可以读取常见的 Unix 邮箱格式。 <b>警告</b> ：虽然它也支持 POP3 协议，但 <b>不推荐使用</b> ，因为它不支持基于 TLS 加密的 POP3。
</p>

<p>
Mailutils 版 <code>movemail</code> 支持多种邮箱格式，如普通 Unix 邮箱、maildir、MH 等；可通过 POP3 或 IMAP4 协议访问远程邮箱，并能使用 TLS 加密通道收取邮件；同时支持以 URL 格式 指定邮箱。邮箱 URL 的详细说明见 GNU Mailutils 手册。
</p>

<p>
简单来说，URL 格式为：
</p>

<div class="org-src-container">
<pre class="src src-shell">proto://[user[:password]@]host-or-file-name[:port]
</pre>
</div>

<p>
方括号内为可选部分。
</p>

<dl class="org-dl">
<dt><code>proto</code></dt><dd>指定邮箱协议或格式，后续 URL 元素的具体含义取决于 proto。</dd>
<dt><code>user</code></dt><dd>访问远程邮箱的用户名。</dd>
<dt><code>password</code></dt><dd>访问远程邮箱的密码。</dd>
<dt><code>host-or-file-name</code></dt><dd>远程邮箱为服务器主机名，本地邮箱为文件路径。</dd>
<dt><code>port</code></dt><dd>可选端口号，不写则使用协议默认端口。</dd>
</dl>

<p>
proto 可取以下值：
</p>
<dl class="org-dl">
<dt><code>mbox</code></dt><dd>标准 Unix 邮箱格式。不使用 user、pass、port，host-or-file-name 为邮箱文件路径。示例： <code>mbox:///var/spool/mail/smith</code></dd>
<dt><code>mh</code></dt><dd>MH 格式本地邮箱。不使用 user、pass、port，host-or-file-name 为 MH 文件夹路径。示例： <code>mh:///Mail/inbox</code></dd>
<dt><code>maildir</code></dt><dd>Maildir 格式本地邮箱。不使用 user、pass、port，host-or-file-name 为邮箱目录路径。示例： <code>maildir:///mail/inbox</code></dd>
<dt><code>file</code></dt><dd>任意本地邮箱文件， <code>movemail</code> 会自动识别格式。</dd>
<dt><code>pop</code></dt><dd></dd>

<dt><code>pops</code></dt><dd>使用 POP3 协议访问远程邮箱（pops 为加密版本）。详情见 “<a href="#Remote-Mailboxes">从远程邮箱收取邮件</a>”。</dd>
<dt><code>imap</code></dt><dd></dd>

<dt><code>imaps</code></dt><dd>使用 IMAP4 协议访问远程邮箱（imaps 为加密版本）。详情见 “<a href="#Remote-Mailboxes">从远程邮箱收取邮件</a>”。</dd>
</dl>

<p>
你也可以直接指定邮箱文件路径，等价于使用 file 协议：
</p>

<div class="org-src-container">
<pre class="src src-shell">/var/spool/mail/user &#8801; file:///var/spool/mail/user
</pre>
</div>

<p>
变量 <code>rmail-movemail-program</code> 控制使用哪个版本的 <code>movemail</code> 。
</p>
<ul class="org-ul">
<li>若为字符串：指定 movemail 可执行文件的绝对路径。</li>
<li>若为 <code>nil</code> ：Rmail 会依次在 <code>rmail-movemail-search-path</code> 、 <code>exec-path</code> (见 <a href="#Shell">Running Shell Commands from Emacs</a>)、 <code>exec-directory</code> 中查找。该变量应在启动 Rmail 前配置；若启动后修改，需将 <code>rmail-movemail-variant-in-use</code> 设为 <code>nil</code> 并重启 Rmail。</li>
</ul>
</div>
</div>
<div id="outline-container-Remote-Mailboxes" class="outline-3">
<h3 id="Remote-Mailboxes"><span class="section-number-3">35.19.</span> 从远程邮箱获取邮件</h3>
<div class="outline-text-3" id="text-Remote-Mailboxes">
<p>
有些站点使用名为 <b>POP3</b> 的方式来存取用户的收件箱数据，而不是将数据存放在收件箱文件中。Mailutils 版的 movemail 默认支持带 TLS 加密的 POP3。警告：虽然 Emacs 自带的 movemail 也支持 POP3，但 <b>不推荐使用</b> ，因为它不支持加密连接，而 Mailutils 版本支持。两个版本的 movemail 都只支持 POP3，不支持更早版本的 POP 协议。
</p>

<p>
你可以使用 <b>POP3 URL</b> 来指定一个 POP3 收件箱（见 <a href="#Movemail">movemail 程序</a>）。POP3 URL 格式为： '<code>pop://username@hostname:port</code>
</p>
<ul class="org-ul">
<li><i>hostname</i> 和 <i>port</i> 是远程邮件服务器的主机名（或 IP 地址）与端口号。</li>
<li><i>username</i> 是该服务器上的用户名。</li>
</ul>

<p>
你还可以在邮箱 URL 中直接指定密码： '<code>pop://username:password@hostname:port</code>'
</p>
<ul class="org-ul">
<li>这种情况下，URL 中的 <i>password密码</i> 会优先于 rmail-remote-password（见下文）。如果你有多个使用不同密码的远程邮箱，这会非常方便。</li>
</ul>

<p>
如果使用 Mailutils 版 movemail 且服务器支持加密连接，movemail 会尝试使用加密；用 'pops:' 代替 'pop:' 可以 <b>强制</b> 使用加密连接。
</p>

<p>
为了向后兼容，Rmail 还支持另一种指定远程 POP3 邮箱的方式：以 '<code>po:username:hostname:port</code>' 形式指定收件箱名，等价于 '<code>pop://username@hostname:port</code>' 。如果省略 <i>:hostname</i> ，则由环境变量 <code>MAILHOST</code> 指定 POP3 服务器所在主机。
</p>

<p>
另一种存取远程邮箱的方式是 IMAP。该方式 <b>仅由 Mailutils 版 movemail 支持</b> ，使用 IMAP4 协议。在收件箱列表中指定 IMAP 邮箱的 URL 格式为： '<code>imap://username[:password]@hostname:port</code>' 。其中 <i>password密码</i> 部分是可选的，规则同上。如果服务器支持， <code>movemail</code> 会尝试使用加密连接；使用 'imaps:' 可以强制加密。
</p>

<p>
访问远程邮箱通常需要密码。Rmail 按以下顺序获取密码：
</p>
<ul class="org-ul">
<li>如果邮箱 URL 中已包含密码(见上文)，直接使用该密码。</li>
<li>如果变量 <code>rmail-remote-password-required</code> 为 <code>nil</code> ，Rmail 认为不需要密码。</li>
<li>如果变量 <code>rmail-remote-password</code> 非空，使用其值作为密码。</li>
<li>否则，Rmail 会提示你输入密码。</li>
</ul>

<p>
有些邮件服务器的用户名中包含域名信息，即用户名里会有 '@' 字符。而收件箱指定字符串用 '@' 表示服务器名的开始，这会让 <code>movemail</code> 产生混淆。如果你的用户名包含 '@' ，且使用 Mailutils 版 movemail，可以这样解决：将用户名中的 '@' 替换为 URL 编码形式 '<code>%40</code>' 。
</p>

<p>
如果你需要向 <code>movemail</code> 传递额外的命令行参数，可以将变量 <code>rmail-movemail-flags</code> 设置为你要使用的参数列表。 <b>不要</b> 用这个变量传递 '<code>-p</code>' 参数来保留收件箱内容，应使用 <code>rmail-preserve-inbox</code> 。
</p>

<p>
你所在环境安装的 <code>movemail</code> 可能支持 <b>Kerberos 认证</b> 。如果支持，当 <code>rmail-remote-password</code> 和 <code>rmail-remote-password-required</code> 均未设置时，在收取 POP3 邮件时会默认使用 Kerberos。
</p>

<p>
部分 POP3 服务器会以 <b>逆序</b> 存放邮件。如果你希望按邮件接收顺序阅读，可以在 <code>rmail-movemail-flags</code> 中加入 '<code>-r</code>' 参数，让 <code>movemail</code> 反转下载后的邮件顺序。
</p>

<p>
Mailutils 版 movemail 支持 TLS 加密。如果你想启用，可以在 <code>rmail-movemail-flags</code> 中加入 '<code>--tls</code>' 参数。
</p>
</div>
</div>
<div id="outline-container-Other-Mailbox-Formats" class="outline-3">
<h3 id="Other-Mailbox-Formats"><span class="section-number-3">35.20.</span> 从多种格式的本地邮箱获取邮件</h3>
<div class="outline-text-3" id="text-Other-Mailbox-Formats">
<p>
如果你的收件邮件保存在本地机器上，但格式并非 Unix 邮箱格式，那么你需要使用 Mailutils 版的 movemail 来收取邮件。关于 movemail 不同版本的详细说明，请参见 <a href="#Movemail">movemail 程序</a>一节。
例如，要访问位于 <code>/var/spool/mail/in</code> 目录下的 maildir 格式收件箱，你需要在 Rmail 收件箱列表中加入如下内容：
</p>

<div class="org-src-container">
<pre class="src src-shell">maildir:///var/spool/mail/in
</pre>
</div>
</div>
</div>
</section>
<section id="outline-container-Gnus" class="outline-2">
<h2 id="Gnus"><span class="section-number-2">36.</span> 使用 Gnus 处理电子邮件与新闻组</h2>
<div class="outline-text-2" id="text-Gnus">
<p>
Gnus 是一个 Emacs 包，最初主要用于阅读和发布 Usenet 新闻。它也可以用来阅读和回复来自其他多种来源的消息 —— 电子邮件、远程目录、合集邮件等。本章将对 Gnus 进行介绍，并描述几项基础功能。完整细节请参阅《Gnus 手册》中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/gnus/index.html#Top">Gnus</a> 相关内容。
</p>

<ul class="org-ul">
<li><a href="#Buffers-of-Gnus">Gnus 缓冲区</a></li>
<li><a href="#Gnus-Startup">Gnus 启动流程</a></li>
<li><a href="#Gnus-Group-Buffer">使用 Gnus 组缓冲区</a></li>
<li><a href="#Gnus-Summary-Buffer">使用 Gnus 摘要缓冲区</a></li>
</ul>
</div>
<div id="outline-container-Buffers-of-Gnus" class="outline-3">
<h3 id="Buffers-of-Gnus"><span class="section-number-3">36.1.</span> Gnus 缓冲区</h3>
<div class="outline-text-3" id="text-Buffers-of-Gnus">
<p>
Gnus 使用多个缓冲区来展示信息并接收命令。其中最常用的三个 Gnus 缓冲区分别是 <i>group buffer组缓冲区</i> 、 <i>summary buffer摘要缓冲区</i> 和 <i>article buffer文章缓冲区</i> 。
</p>

<p>
组缓冲区里列出了各类文章来源（例如新闻组、电子邮箱收件箱），这些统称为组（groups）。这是 Gnus 启动后第一个显示的缓冲区。默认情况下，它只显示你已订阅且包含未读文章的组。你可以在这个缓冲区中选择要阅读的组。
</p>

<p>
摘要缓冲区会列出单个组里的所有文章，每行显示一篇。默认会展示文章的作者、主题和行号，这些显示格式均可自定义，详见《Gnus 手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/gnus/Summary-Buffer-Format.html#Summary-Buffer-Format">摘要缓冲区格式</a>」部分。当你在组缓冲区选中一个组时，会创建对应的摘要缓冲区；退出该组时，缓冲区会被关闭。
</p>

<p>
在摘要缓冲区中，你可以选择要查看的文章，文章内容会在文章缓冲区中显示。日常使用 Gnus 时，你只需查看这个缓冲区，无需主动选中它 —— 所有常用的 Gnus 命令都可以在摘要缓冲区中直接执行。当然，如果你需要，也可以手动选中文章缓冲区，并在其中执行 Gnus 命令。
</p>
</div>
</div>
<div id="outline-container-Gnus-Startup" class="outline-3">
<h3 id="Gnus-Startup"><span class="section-number-3">36.2.</span> Gnus 启动流程</h3>
<div class="outline-text-3" id="text-Gnus-Startup">
<p>
如果你的系统已经配置好用于阅读 Usenet 新闻，那么启动 Gnus 非常简单 —— 只需输入 <code>M-x gnus</code> 。
启动时，Gnus 会读取你的新闻初始化文件：位于家目录下、名为 <code>.newsrc</code> 的文件，该文件记录了你订阅的 Usenet 新闻组（此文件并非 Gnus 独有，许多其他新闻阅读器也会使用）。随后，它会尝试连接系统默认的新闻服务器，该服务器通常由环境变量 <code>NNTPSERVER</code> 指定。
</p>

<p>
如果你的系统没有默认新闻服务器，或者你希望用 Gnus 来阅读邮件，那么在执行 <code>M-x gnus</code> 之前，需要先告诉 Gnus 从哪里获取新闻和 / 或邮件。为此，你需要自定义变量 <code>gnus-select-method</code> 或 <code>gnus-secondary-select-methods</code> 。详见《Gnus 手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/gnus/Finding-the-News.html#Finding-the-News">查找新闻服务器</a>」部分。
</p>

<p>
Gnus 启动完成后，会显示组缓冲区。默认情况下，组缓冲区只显示少量已订阅的组。其他状态的组 —— 未订阅、已屏蔽或僵尸状态 —— 都会被隐藏。首次启动 Gnus 时，所有你未订阅的组都会被设为 <b>已屏蔽组</b> ；之后新闻服务器上新出现的组则会成为 <b>僵尸组</b> 。
</p>

<p>
要继续操作，你必须在组缓冲区中选中一个组，以打开该组的摘要缓冲区；然后在摘要缓冲区中选择一篇文章，即可在单独窗口中查看对应的文章缓冲区。后续章节会介绍如何使用组缓冲区和摘要缓冲区完成这些操作。
</p>

<p>
退出 Gnus 的方法是：在组缓冲区中按 <code>q</code> 。该操作会自动将你的组状态记录到 <code>.newsrc</code> 和 <code>.newsrc.eld</code> 文件中，以便在后续的 Gnus 会话中生效。
</p>
</div>
</div>
<div id="outline-container-Gnus-Group-Buffer" class="outline-3">
<h3 id="Gnus-Group-Buffer"><span class="section-number-3">36.3.</span> 使用 Gnus 组缓冲区</h3>
<div class="outline-text-3" id="text-Gnus-Group-Buffer">
<p>
在 Gnus 组缓冲区中可使用以下命令：
</p>

<dl class="org-dl">
<dt><code>SPC</code></dt><dd>切换到当前行所在组的摘要缓冲区 (<code>gnus-group-read-group</code>)。</dd>
<dt><code>l</code></dt><dd></dd>

<dt><code>A s</code></dt><dd>在组缓冲区中，只显示你已订阅且包含未读文章的组 (<code>gnus-group-list-groups</code> ；这是默认列表)。</dd>
<dt><code>L</code></dt><dd></dd>

<dt><code>A u</code></dt><dd>列出所有已订阅和未订阅的组，但不显示已屏蔽（killed）或僵尸（zombie）组 (<code>gnus-group-list-all-groups</code>)。</dd>
<dt><code>A k</code></dt><dd>列出已屏蔽组 (<code>gnus-group-list-killed</code>)。</dd>
<dt><code>A z</code></dt><dd>列出僵尸组 (<code>gnus-group-list-zombies</code>)。</dd>
<dt><code>u</code></dt><dd>切换当前行所在组的订阅状态 (<code>gnus-group-toggle-subscription-at-point</code>)。对已屏蔽或僵尸组执行此操作会将其转为未订阅组。</dd>
<dt><code>C-k</code></dt><dd>屏蔽当前行所在的组 (<code>gnus-group-kill-group</code>)。被屏蔽的组不会记录在 <code>.newsrc</code> 文件中，也不会在 <code>l</code> 或 <code>L</code> 列表中显示。</dd>
<dt><code>DEL</code></dt><dd>将光标移到上一个包含未读文章的组 (<code>gnus-group-prev-unread-group</code>)。</dd>
<dt><code>n</code></dt><dd>将光标移到下一个未读组 (<code>gnus-group-next-unread-group</code>)。</dd>
<dt><code>p</code></dt><dd>将光标移到上一个未读组 (<code>gnus-group-prev-unread-group</code>)。</dd>
<dt><code>q</code></dt><dd>保存 Gnus 设置并退出 Gnus (<code>gnus-group-exit</code>)。</dd>
</dl>
</div>
</div>
<div id="outline-container-Gnus-Summary-Buffer" class="outline-3">
<h3 id="Gnus-Summary-Buffer"><span class="section-number-3">36.4.</span> 使用 Gnus 摘要缓冲区</h3>
<div class="outline-text-3" id="text-Gnus-Summary-Buffer">
<p>
在 Gnus 摘要缓冲区中可使用以下命令：
</p>
<dl class="org-dl">
<dt><code>SPC</code></dt><dd>若尚未选中文章，则选中当前行的文章并显示其文章缓冲区。若已选中文章，则在对应窗口中滚动该文章缓冲区；滚动到缓冲区末尾时，自动选中下一篇未读文章 (<code>gnus-summary-next-page</code>)。
因此，反复按 SPC 即可连续阅读所有文章。</dd>
<dt><code>DEL</code></dt><dd>向上滚动文章内容 (<code>gnus-summary-prev-page</code>)。</dd>
<dt><code>n</code></dt><dd>选中下一篇未读文章 (<code>gnus-summary-next-unread-article</code>)。</dd>
<dt><code>p</code></dt><dd>选中上一篇未读文章 (<code>gnus-summary-prev-unread-article</code>)。</dd>
<dt><code>s</code></dt><dd>在当前选中的文章缓冲区中执行增量搜索 (<code>gnus-summary-isearch-article</code>)，效果等同于切换到该缓冲区并按 <code>C-s</code> （参见<a href="#Incremental-Search">增量搜索</a>）。</dd>
<dt><code>M-s M-s regexp RET</code></dt><dd>向前搜索匹配该正则表达式的文章 (<code>gnus-summary-search-article-forward</code>)。</dd>
<dt><code>M-r regexp RET</code></dt><dd>向后搜索匹配该正则表达式的文章 (<code>gnus-summary-search-article-backward</code>)。</dd>
<dt><code>q</code></dt><dd>退出摘要缓冲区，回到组缓冲区 (<code>gnus-summary-exit</code>)。</dd>
</dl>
</div>
</div>
</section>
<section id="outline-container-Host-Security" class="outline-2">
<h2 id="Host-Security"><span class="section-number-2">37.</span> 主机安全</h2>
<div class="outline-text-2" id="text-Host-Security">
<p>
Emacs 运行在 GNU/Linux 等操作系统之上，依赖操作系统来校验文件访问等安全限制。Emacs 的默认配置面向常规使用场景设计；在安全要求高于或低于普通环境的场景中，可能需要进行相应调整。
</p>

<p>
例如，文件局部变量存在一定风险，你可以将变量 <code>enable-local-variables</code> 设置为 <code>:safe</code> ，或（更保守地）设置为 <code>nil</code> ；反之，如果你的所有文件都可信任，而默认的变量校验机制令人困扰，也可将其设为 <code>:all</code> 。详见《<a href="#Safe-File-Variables">文件变量的安全性</a>》。
</p>

<p>
使用 <code>load-file</code> 或 <code>load-library</code> 加载 Emacs Lisp 代码文件（参见《<a href="#Lisp-Libraries">Emacs Lisp 代码库</a>》）会执行文件中的部分 Lisp 代码，因此你只应加载来源可信的 Lisp 文件。不过，Emacs 的某些功能在特定情况下，即使没有你显式执行命令，也可能自动运行 Lisp 代码。例如，Emacs 的实时语法检查工具 Flymake（参见 <a href="https://www.gnu.org/software/emacs/manual/html_node/flymake/index.html#Top">GNU Flymake</a>），若已启用，会在语法检查过程中自动执行你打开的 Lisp 文件中的部分代码。类似地，在编辑 Lisp 文件的缓冲区中，某些补全命令（参见《<a href="#Completion">补全</a>》）有时需要展开 Lisp 宏以获得最佳效果。
</p>

<p>
在这些情况下，仅仅打开一个 Lisp 文件并进行编辑，就可能触发其中代码的执行。如果该文件来自不可信来源，就可能包含危险甚至恶意代码，并被 Emacs 在上述场景中执行。
</p>

<p>
为防范此类风险，除非打开的文件被标记为可信，否则 Emacs 会禁止 Flymake、补全及其他相关功能执行 Lisp 代码。你需要通过自定义用户选项 <code>trusted-content</code> ，来指定系统中哪些文件或目录应被视为可信。
</p>

<dl class="org-dl">
<dt>用户选项： <code>trusted-content</code></dt><dd><p>
该选项的默认值为 <code>nil</code> ，表示不信任任何文件。你可以将其自定义为一个或多个可信文件与目录的名称列表。以斜杠 <code>/</code> 结尾的文件名会被识别为目录，表示该目录下的所有文件与子目录均被信任。
</p>

<p>
特殊值 <code>:all</code> 表示信任系统上的所有文件与目录； <b>不推荐使用此值</b> ，因为它会留下巨大的安全漏洞。
</p></dd>
</dl>

<p>
有关将 Emacs 作为大型应用一部分使用时的安全注意事项，详见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Security-Considerations.html#Security-Considerations">安全考量</a>》。
</p>
</div>
</section>
<section id="outline-container-Network-Security" class="outline-2">
<h2 id="Network-Security"><span class="section-number-2">38.</span> 网络安全</h2>
<div class="outline-text-2" id="text-Network-Security">
<p>
每当 Emacs 建立网络连接时，都会将已建立的连接交给 <i>Network Security Manager 网络安全管理器</i> （NSM）。NSM 负责在你的控制下强制执行网络安全策略。目前，该功能通过 <b><i>Transport Layer Security 传输层安全（TLS）</i></b> 特性实现。
</p>

<p>
<code>network-security-level</code> 变量决定 NSM 强制执行的安全级别。如果其值为 <code>low</code> （低），则不执行任何安全检查。 <b>不推荐使用该值</b> ，因为这基本意味着你的网络连接不可信。不过，在有限场景下（例如排查网络问题时）该设置可能有用。
</p>

<p>
如果该变量为 <code>medium</code> （中，默认值），则会执行多项检查。若 NSM 判断该网络连接可能不可信，会向你发出提示，并询问如何处理该连接。
</p>

<p>
你可以选择为未验证的连接 <b>添加永久安全例外、临时例外，或完全拒绝该连接</b> 。
</p>

<p>
除了基本的证书合法性检查外，NSM 还支持多项 TLS 算法检查。一些过去被认为安全的加密技术现已被证明存在缺陷，因此 Emacs（默认情况下）会对其中部分问题发出警告。
</p>

<p>
协议网络检查由变量 <code>network-security-protocol-checks</code> 控制。它是一个关联列表（alist），每个关联的第一个元素是检查项名称，第二个元素是应启用该检查的安全级别。
</p>

<p>
例如 (rc4 medium) 会导致函数 <code>nsm-protocol-check--rc4</code> 以如下方式调用： <code>(nsm-protocol-check--rc4 host port status settings)</code> 。如果函数返回非空，表示允许继续连接；返回空则拒绝。
</p>

<p>
下面是默认 medium 级别下执行的检查项列表：
</p>
<dl class="org-dl">
<dt>无法验证 TLS 证书</dt><dd><p>
如果是 TLS、SSL 或 STARTTLS 连接，NSM 会检查用于确认服务器身份的证书是否可验证。
</p>

<p>
虽然无效证书通常值得警惕（可能存在中间人劫持连接并窃取密码），但有时也有合理原因继续使用该连接。例如服务器使用自签名证书，或证书已过期。是否继续连接由你自行决定。
</p></dd>

<dt>自签名证书发生变更</dt><dd>如果你之前接受过某个自签名证书，但该证书现在发生变化，这可能只是服务器更换了证书，也可能意味着网络连接已被劫持。</dd>

<dt>此前加密的连接现在变为未加密</dt><dd></dd>
</dl>
<p>
如果当前连接未加密，但之前会话是加密的，可能表示你与服务器之间存在代理，剥离了 STARTTLS 声明，导致连接明文传输。这通常非常可疑。
</p>

<dl class="org-dl">
<dt>发送密码时使用未加密服务</dt><dd>连接 IMAP 或 POP3 服务器时通常应加密，因为这类连接常会传输密码。同样，通过需要密码验证的 SMTP 发送邮件时，通常也希望连接加密。如果连接未加密，NSM 会发出警告。</dd>

<dt>Diffie‑Hellman 素数位数过低</dt><dd>在公钥交换过程中，素数位数应足够高，以防止信道被第三方窃听。如果该数值过低，Emacs 会发出警告。（对应 <code>network-security-protocol-checks</code> 中的 <code>diffie-hellman-prime-bits</code> 检查）</dd>

<dt>RC4 流密码</dt><dd>RC4 流密码被认为安全性较低，可能允许第三方窃听。（对应 <code>network-security-protocol-checks</code> 中的 rc4 检查）</dd>

<dt>主机证书或中间证书使用 SHA1</dt><dd>如果中间证书使用 SHA1 哈希算法，第三方可能伪造证书冒充该签发机构。这类连接易受中间人攻击。（对应 <code>network-security-protocol-checks</code> 中的 <code>signature-sha1</code> 和 <code>intermediate-sha1</code> 检查）</dd>

<dt>SSL1、SSL2、SSL3</dt><dd>早于 TLS1.0 的协议被认为存在多种安全漏洞，若你的场景需要较高安全性，应避免使用。（对应 <code>network-security-protocol-checks</code> 中的 <code>version</code> 检查）</dd>

<dt>三重 DES（3DES）密码</dt><dd>3DES 流密码的有效安全强度最多只有 112 位，且 2016 年已披露重大安全漏洞（CVE-2016-2183）。NIST 已从 2023 年底起在所有应用中弃用该算法。（对应 <code>network-security-protocol-checks</code> 中的 3des-cipher 检查）</dd>
</dl>


<p>
如果 <code>network-security-level</code> 设为 <code>high</code> （高），除上述检查外，还会额外执行：
</p>

<dl class="org-dl">
<dt>已验证证书的公钥发生变更</dt><dd>服务器偶尔会更换密钥，这通常无需担心。但如果你担心网络连接被某些机构劫持 —— 这些机构可利用受控的证书颁发机构为第三方服务签发新证书 —— 你可能需要跟踪这类变更。</dd>
</dl>

<p>
最后，如果 <code>network-security-level</code> 设为 <code>paranoid</code> （最高），则 NSM 首次见到任何新证书时都会通知你。这让你可以检查 Emacs 发起的所有连接的全部证书。
</p>

<p>
以下附加变量可用于控制 NSM 的具体行为：
</p>

<dl class="org-dl">
<dt><code>nsm-settings-file</code></dt><dd>NSM 存储连接详细信息的文件。默认为： <code>~/.emacs.d/network-security.data</code> 。</dd>

<dt><code>nsm-save-host-names</code></dt><dd>默认情况下，非 STARTTLS 连接不会保存主机名，而是使用 主机/端口 哈希值标识连接。这可以防止他人随意读取配置文件，获知用户连接过哪些服务器。如果该变量设为 <code>t</code> ，NSM 会在 <code>nsm-settings-file</code> 中同时保存主机名。</dd>
</dl>
</div>
</section>
<section id="outline-container-Document-View" class="outline-2">
<h2 id="Document-View"><span class="section-number-2">39.</span> 文档查看</h2>
<div class="outline-text-2" id="text-Document-View">
<p>
DocView 模式是用于查看 DVI、PostScript（PS）、PDF、OpenDocument、Microsoft Office、EPUB、CBZ、FB2、XPS 和 OXPS 文档的主模式。它提供切片、缩放、文档内搜索等功能。其工作原理是：使用 <code>gs</code> （GhostScript）或 <code>pdfdraw</code> / <code>mutool draw</code> （MuPDF）命令及其他外部工具，将文档转换为一组图片，然后显示这些转换后的图片。
</p>

<p>
当你打开可由 DocView 模式显示的文档文件时，Emacs 会自动启用该模式<sup><a id="fnr.21" class="footref" href="#fn.21" role="doc-backlink">21</a></sup>。唯一例外是：打开 PostScript 文件时，Emacs 会切换到 PS 模式（一种将 PostScript 文件作为文本编辑的主模式），但同时也会启用 DocView 次模式，因此你可以按 <code>C-c C-c</code> 用 DocView 查看文档。在 DocView 主模式或次模式下，重复按 <code>C-c C-c</code> (<code>doc-view-toggle-display</code>) 可在 DocView 显示与原始文件内容之间切换。
</p>

<p>
若你打开的文件本应由 DocView 处理，但某些条件未满足（例如在终端框架中运行，或 Emacs 不支持 PNG），Emacs 会询问是否以纯文本查看文档内容。确认后，缓冲区将进入文本模式并激活 DocView 次模式。此时按 <code>C-c C-c</code> 可切换到回退模式，再按一次 <code>C-c C-c</code> 回到 DocView 模式。在 DocView 模式中，也可通过 <code>C-c C-t</code> (<code>doc-view-open-text</code>) 直接显示纯文本内容。
</p>

<p>
你可以通过命令 <code>M-x doc-view-mode</code> 显式启用 DocView 模式，通过 <code>M-x doc-view-minor-mode</code> 切换 DocView 次模式。
</p>

<p>
DocView 模式启动时会显示欢迎界面，并开始逐页排版文件。第一页排版完成后便会显示。
关闭 DocView 缓冲区：按 <code>k</code> (<code>doc-view-kill-proc-and-buffer</code>) 。隐藏该窗口：按 <code>q</code> (<code>quit-window</code>)。
</p>

<ul class="org-ul">
<li><a href="#DocView-Navigation">DocView 导航</a></li>
<li><a href="#DocView-Searching">DocView 搜索</a></li>
<li><a href="#DocView-Slicing">DocView 切片</a></li>
<li><a href="#DocView-Conversion">DocView 格式转换</a></li>
</ul>
</div>
<div id="outline-container-DocView-Navigation" class="outline-3">
<h3 id="DocView-Navigation"><span class="section-number-3">39.1.</span> DocView 导航</h3>
<div class="outline-text-3" id="text-DocView-Navigation">
<p>
在文档视图（DocView）模式下，你可以使用 Emacs 常规移动键滚动当前页面： <code>C-p</code> 、 <code>C-n</code> 、 <code>C-b</code> 、 <code>C-f</code> 以及方向键。
</p>

<p>
默认情况下，行移动键 <code>C-p</code> 和 <code>C-n</code> 会分别在当前页面的开头和结尾停止滚动。不过，如果你将变量 <code>doc-view-continuous</code> 设置为非空（non-nil）值，那么当你已处于当前页面开头时， <code>C-p</code> 会显示上一页；当你处于页面末尾时， <code>C-n</code> 会显示下一页。
</p>

<p>
你也可以通过以下按键显示下一页： <code>n</code> 、 <code>PageDown</code> 、 <code>next</code> 或 <code>C-x ]</code> (<code>doc-view-next-page</code>) 。显示上一页： <code>p</code> 、 <code>PageUp</code> 、 <code>prior</code> 或 <code>C-x [</code> (<code>doc-view-previous-page</code>)。
</p>

<p>
<code>SPC</code> (<code>doc-view-scroll-up-or-next-page</code>) 是浏览文档的便捷方式，它会在当前页内滚动或切换到下一页。 <code>DEL</code> 以类似方式向后翻页 (<code>doc-view-scroll-down-or-previous-page</code>)。
</p>

<p>
跳转到第一页： <code>M-&lt;</code> (<code>doc-view-first-page</code>) ；跳转到最后一页： <code>M-&gt;</code> (<code>doc-view-last-page</code>) ；按页码直接跳转： <code>M-g M-g</code> 或 <code>M-g g</code> (<code>doc-view-goto-page</code>) 。
</p>

<p>
你可以使用 <code>+</code> (<code>doc-view-enlarge</code>) 放大文档、 <code>-</code> (<code>doc-view-shrink</code>) 缩小文档。默认情况下，这些命令仅对已渲染的图像进行缩放。如果你希望按新尺寸重新渲染图像，可将 <code>doc-view-scale-internally</code> 设置为 <code>nil</code> 。若要指定文档视图的默认尺寸，可自定义变量 <code>doc-view-resolution</code> 。
</p>

<p>
当系统中存在 <code>mutool</code> 程序时，文档视图会用它为大纲菜单生成条目，可通过 <code>imenu</code> 功能访问（见 <a href="#Imenu">Imenu</a>）。即使系统中装有 <code>mutool</code> ，你也可以将变量 <code>doc-view-imenu-enabled</code> 设为 <code>nil</code> 以关闭此功能。你还可以通过变量 <code>doc-view-imenu-format</code> 和 <code>doc-view-imenu-flatten</code> 进一步自定义 <code>imenu</code> 条目的格式与显示方式。
</p>
</div>
</div>
<div id="outline-container-DocView-Searching" class="outline-3">
<h3 id="DocView-Searching"><span class="section-number-3">39.2.</span> DocView 搜索</h3>
<div class="outline-text-3" id="text-DocView-Searching">
<p>
在文档视图（DocView）模式下，你可以基于正则表达式搜索文件文本（参见<a href="#Regexps">正则表达式语法</a>）。该搜索界面的设计参考了增量搜索 <code>isearch</code> （参见<a href="#Incremental-Search">增量搜索</a>）。
</p>

<p>
开始搜索：
</p>
<ul class="org-ul">
<li>输入 <code>C-s</code> (<code>doc-view-search</code>) ：正向搜索</li>
<li>输入 <code>C-r</code> (<code>doc-view-search-backward</code>) ：反向搜索</li>
</ul>

<p>
这会通过小缓冲区读取一个正则表达式，然后在回显区显示文档中匹配到的数量。你可以通过再次输入 <code>C-s</code> 和 <code>C-r</code> 在匹配项之间前后跳转。
</p>

<p>
文档视图模式无法在页面图片中直接高亮显示匹配内容；它会在鼠标位置弹出提示框（tooltip），列出当前页面内所有匹配的行。如需强制显示该提示框，输入 <code>C-t</code> (<code>doc-view-show-tooltip</code>)。
</p>
</div>
</div>
<div id="outline-container-DocView-Slicing" class="outline-3">
<h3 id="DocView-Slicing"><span class="section-number-3">39.3.</span> DocView 切片</h3>
<div class="outline-text-3" id="text-DocView-Slicing">
<p>
文档在打印时通常会留有较宽的边距。但在屏幕上阅读时，这些边距会很碍事，因为它们会占用屏幕空间，并可能导致不便的滚动操作。
</p>

<p>
在 DocView 中，你可以通过选择页面的一个切片区域来隐藏这些边距。切片是页面区域内的一个矩形；一旦在 DocView 中指定了切片，它将应用到你查看的任意页面。
</p>

<p>
要通过数值方式指定切片，按 <code>C-s</code> (<code>doc-view-set-slice</code>) ；然后输入左上角像素坐标，以及切片的宽度和高度。
</p>

<p>
更便捷的图形化指定切片方式是使用 <code>C-m</code> (<code>doc-view-set-slice-using-mouse</code>) ，通过鼠标来选择切片。只需在想要保留区域的左上角按住 <code>mouse-1</code> 鼠标左键，然后将鼠标指针拖动到右下角并松开按键即可。
</p>

<p>
最便捷的方式是利用从文档自动获取的边界框信息来设置最优切片，按 <code>C-b</code> (<code>doc-view-set-slice-from-bounding-box</code>)。
</p>

<p>
要取消已选中的切片，按 <code>C-r</code> (<code>doc-view-reset-slice</code>) 。之后 DocView 将显示完整页面，包括全部边距。
</p>
</div>
</div>
<div id="outline-container-DocView-Conversion" class="outline-3">
<h3 id="DocView-Conversion"><span class="section-number-3">39.4.</span> DocView 格式转换</h3>
<div class="outline-text-3" id="text-DocView-Conversion">
<p>
为提升效率，DocView 会缓存由 <code>gs</code> （Ghostscript）生成的图片。用于缓存图片的目录名称由变量 <code>doc-view-cache-directory</code> 指定。你可以输入 <code>M-x doc-view-clear-cache</code> 清空缓存目录。
</p>

<p>
若要强制重新转换当前查看的文档，输入 <code>r</code> 或 <code>g</code> (<code>revert-buffer</code>) 。若要终止与当前缓冲区关联的转换进程，输入 <code>K</code> (<code>doc-view-kill-proc</code>) 。命令 <code>k</code> (<code>doc-view-kill-proc-and-buffer</code>) 会同时终止转换进程并关闭 DocView 缓冲区。
</p>
</div>
</div>
</section>
<section id="outline-container-Shell" class="outline-2">
<h2 id="Shell"><span class="section-number-2">40.</span> 从 Emacs 运行 Shell 命令</h2>
<div class="outline-text-2" id="text-Shell">
<p>
Emacs 提供了相关命令，可将单行命令传递给 Shell 子进程、在 Emacs 缓冲区中交互式运行 Shell（输入输出均在缓冲区），以及在终端仿真窗口中运行 Shell。
</p>

<dl class="org-dl">
<dt><code>M-! cmd RET</code></dt><dd>执行 Shell 命令 <i>cmd</i> 并显示输出结果 (<code>shell-command</code>)。</dd>
<dt><code>M-| cmd RET</code></dt><dd>以选中区域的内容作为输入，执行 Shell 命令 <i>cmd</i> ；可选择用输出结果替换选中区域 (<code>shell-command-on-region</code>)。</dd>
<dt><code>M-&amp; cmd RET</code></dt><dd>异步执行 Shell 命令 <i>cmd</i> ，并显示输出结果 (<code>async-shell-command</code>)。</dd>
<dt><code>M-x shell</code></dt><dd>通过 Emacs 缓冲区进行输入输出，启动一个子 Shell。之后可交互式输入命令。</dd>
<dt><code>M-x term</code></dt><dd>通过 Emacs 缓冲区进行输入输出，启动一个子 Shell。之后可交互式输入命令，支持完整的终端仿真。</dd>
</dl>

<p>
当你为可执行程序指定相对路径文件名时（无论是在上述命令的 <i>cmd</i> 参数中，还是在其他场景下），Emacs 会在变量 <code>exec-path</code> 指定的目录中搜索该程序。此变量的值必须是一个目录列表；Emacs 启动时，会从环境变量 <code>PATH</code> 初始化该变量的默认值（参见<a href="#General-Variables">通用变量</a>）。
</p>

<p>
<code>M-x eshell</code> 启动一个完全由 Emacs 自身实现的 Shell。其用法在独立手册中有详细说明，参见《Eshell：Emacs 内置 Shell》中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/eshell/index.html#Top">Eshell</a> 章节。
</p>

<ul class="org-ul">
<li><a href="#Single-Shell">单个 Shell 命令</a></li>
<li><a href="#Interactive-Shell">交互式子 shell</a></li>
<li><a href="#Shell-Mode">Shell 模式</a></li>
<li><a href="#Shell-Prompts">Shell 提示符</a></li>
<li><a href="#Shell-History">Shell 命令历史</a></li>
<li><a href="#Directory-Tracking">目录跟踪</a></li>
<li><a href="#Shell-Options">Shell 模式选项</a></li>
<li><a href="#Terminal-emulator">Emacs 终端模拟器</a></li>
<li><a href="#Term-Mode">终端模式</a></li>
<li><a href="#Remote-Host">远程主机 Shell</a></li>
<li><a href="#Serial-Terminal">串行终端</a></li>
</ul>
</div>
<div id="outline-container-Single-Shell" class="outline-3">
<h3 id="Single-Shell"><span class="section-number-3">40.1.</span> 单个 Shell 命令</h3>
<div class="outline-text-3" id="text-Single-Shell">
<p>
<code>M-!</code> (<code>shell-command</code>) 通过迷你缓冲（minibuffer）读取一行文本，并在专门为此命令创建的子 Shell 中作为 Shell 命令执行。命令的标准输入来自空设备。如果 Shell 命令产生输出，输出会显示在回显区（内容较短时），或显示在名为 <code>*Shell Command Output*</code> （由变量 <code>shell-command-buffer-name</code> 指定）的缓冲区中（内容较长时）。变量 <code>resize-mini-windows</code> 和 <code>max-mini-window-height</code> （见 “<a href="#Minibuffer-Edit">在小缓冲中编辑</a>”）控制 Emacs 何时认为输出过长而不适合显示在回显区。注意：自定义下文介绍的 <code>shell-command-dont-erase-buffer</code> 可能会影响回显区的显示内容。
</p>

<p>
例如，解压名为 <code>foo.gz</code> 的文件可以输入： <code>M-! gunzip foo.gz RET</code> 该 Shell 命令通常会生成文件 foo，且不会产生终端输出。
</p>

<p>
给 <code>shell-command</code> 传递数字前缀参数（如 <code>M-1 M-!</code> ），会让命令将终端输出 <b>插入到当前缓冲区</b> ，而不是单独的输出缓冲区。默认情况下，光标（point）放在输出内容之前，标记（mark）放在输出内容之后（但非默认值的 <code>shell-command-dont-erase-buffer</code> 会改变这一行为，见下文）。例如： <code>M-1 M-! gunzip &lt; foo.gz RET</code> 会将 <code>foo.gz</code> 解压后的内容插入到当前缓冲区。
</p>

<p>
如果指定的 Shell 命令不以 '<code>&amp;</code>' 结尾，它会同步执行，你必须等待命令退出才能继续使用 Emacs。要停止等待，按 <code>C-g</code> 退出；这会发送 <code>SIGINT</code> 信号终止 Shell 命令（与 Shell 中 <code>C-c</code> 的作用相同）。Emacs 会等待命令真正终止。如果 Shell 命令没有停止（因为它忽略了 <code>SIGINT</code> ），再次按 <code>C-g</code> ；这会发送 <code>SIGKILL</code> 信号，该信号无法被忽略。
</p>

<p>
以 '<code>&amp;</code>' 结尾的 Shell 命令会 <b><i>asynchronously异步执行</i></b> ，命令运行时你可以继续使用 Emacs。你也可以输入 <code>M-&amp;</code> (<code>async-shell-command</code>) 来异步执行 Shell 命令；效果与在 <code>M-!</code> 命令末尾加 '<code>&amp;</code>' 完全一样，只是不需要手动输入 '<code>&amp;</code>' 。异步 Shell 命令的输出默认进入 <code>*Async Shell Command*</code> 缓冲区（由变量 <code>shell-command-buffer-name-async</code> 指定）。无论该缓冲区是否在窗口中可见，Emacs 都会实时将输出写入其中。
</p>

<p>
如果你希望 <b>同时运行多个异步 Shell 命令</b> ，它们可能会竞争同一个输出缓冲区。选项 <code>async-shell-command-buffer</code> 用于控制这种情况：例如是重命名已存在的输出缓冲区，还是为新命令使用不同缓冲区。更多行为请查阅该变量的文档。
</p>

<p>
如果你希望异步命令的输出缓冲区 <b>只在有输出时才显示</b> ，将 <code>async-shell-command-display-buffer</code> 设为 <code>nil</code> 。
</p>

<p>
选项 <code>async-shell-command-width</code> 定义异步 Shell 命令输出可用的显示列数。正整数表示指定列数；默认值 <code>nil</code> 表示使用 Shell 提供的列数。
</p>

<p>
要让上述命令在提示符中显示 <b>当前目录</b> ，将变量 <code>shell-command-prompt-show-cwd</code> 设为非 nil 值。
</p>

<p>
<code>M-|</code> (<code>shell-command-on-region</code>) 与 <code>M-!</code> 类似，但会将 <b>选中区域内容</b> 作为标准输入传给 Shell 命令，而不是空输入。如果使用数字前缀参数，它会删除原有区域，并用 Shell 命令的输出替换该区域。
</p>

<p>
例如，你可以用 <code>M-|</code> 配合 <code>gpg</code> 程序查看缓冲区中的密钥。如果缓冲区包含 GnuPG 密钥，输入：=C-x h M-| gpg RET= 将整个缓冲区内容传给 <code>gpg</code> ，密钥列表会输出到 <code>shell-command-buffer-name</code> 命名的缓冲区。
</p>

<p>
上述命令使用由变量 <code>shell-file-name</code> 指定的 Shell。其默认值在 Emacs 启动时由环境变量 <code>SHELL</code> 决定。如果文件名是相对路径，Emacs 会在 <code>exec-path</code> 列出的目录中搜索（见 “<a href="#Shell">在 Emacs 中运行 Shell 命令</a>”）。
</p>

<p>
如果当前默认目录是远程目录（见 “<a href="#Remote-Files">远程文件</a>”）， <code>shell-file-name</code> 默认值为 <code>/bin/sh</code> 。可以通过将 <code>shell-file-name</code> 声明为连接本地变量来修改（见 “<a href="#Connection-Variables">每个连接的本地变量</a>”）。
</p>

<p>
要为 <code>M-!</code> 或 <code>M-|</code> 指定编码系统，在执行前先使用命令 <code>C-x RET c</code> 。见 “<a href="#Communication-Coding">进程间通信的编码系统</a>”。
</p>

<p>
默认情况下，错误输出与普通输出混合在输出缓冲区中。但如果你将变量 <code>shell-command-default-error-buffer</code> 设为字符串，错误输出会插入到该字符串命名的缓冲区中。
</p>

<p>
默认情况下，输出缓冲区在不同 Shell 命令之间会被清空，除非输出直接写入当前缓冲区。如果你将选项 <code>shell-command-dont-erase-buffer</code> 设为 <code>erase</code> ，输出缓冲区 <b>总是会被清空</b> 。其他非 nil 值则 <b>禁止清空</b> 输出缓冲区；并且 —— 如果输出缓冲区不是当前缓冲区 —— 还会控制插入 Shell 命令输出后光标的位置：
</p>
<dl class="org-dl">
<dt><code>beg-last-out</code></dt><dd>光标放在上一次 Shell 命令输出的开头。</dd>
<dt><code>end-last-out</code></dt><dd>光标放在上一次 Shell 命令输出的末尾，即输出缓冲区的末尾。</dd>
<dt><code>save-point</code></dt><dd>恢复插入 Shell 命令输出前的光标位置。</dd>
</dl>

<p>
注意：如果该选项为非 nil，回显区显示的内容可能不只来自最后一条命令，因为回显区只显示输出缓冲区的一部分内容。
</p>

<p>
如果输出缓冲区不是当前缓冲区，Shell 命令的输出会追加到该缓冲区末尾
</p>
</div>
</div>
<div id="outline-container-Interactive-Shell" class="outline-3">
<h3 id="Interactive-Shell"><span class="section-number-3">40.2.</span> 交互式子 shell</h3>
<div class="outline-text-3" id="text-Interactive-Shell">
<p>
要交互式运行子 Shell，输入 <code>M-x shell</code> 。这会创建（或复用）一个名为 <code>*shell*</code> 的缓冲区，并在其中运行一个子 Shell 进程，输入与输出都通过该缓冲区进行。也就是说，子 Shell 的所有终端输出都会写入缓冲区，并移动光标；子 Shell 的所有终端输入都来自缓冲区中的文本。要向子 Shell 输入内容，只需跳到缓冲区末尾，输入内容并按 <code>RET</code> 即可。
</p>

<p>
默认情况下，当以交互方式启动子 Shell 时， <code>*shell*</code> 缓冲区会在新窗口中显示，除非当前窗口已经显示该缓冲区。此行为可通过 <code>display-buffer-alist</code> 自定义（参见 <a href="#Window-Choice">display-buffer 的工作方式</a>）。
</p>

<p>
当子 Shell 处于等待或运行命令状态时，你可以切换窗口或缓冲区，在 Emacs 中进行其他编辑操作。Emacs 会在有空时（例如等待键盘输入时）将子 Shell 的输出插入到 Shell 缓冲区。
</p>

<p>
在 Shell 缓冲区中，提示符使用 <code>comint-highlight-prompt</code> 样式显示，提交的输入行使用 <code>comint-highlight-input</code> 样式显示。这便于区分输入行与 Shell 输出。参见<a href="#Faces">文本外观</a>。
</p>

<p>
要创建多个子 Shell，带前缀参数调用 <code>M-x shell</code> （例如 <code>C-u M-x shell</code> ）。命令会让你输入一个缓冲区名称，并在该缓冲区中创建（或复用）子 Shell。你也可以用 <code>M-x rename-uniquely</code> 重命名现有的 <code>*shell*</code> 缓冲区，然后直接用 <code>M-x shell</code> 新建一个 <code>*shell*</code> 缓冲区。不同缓冲区中的子 Shell 彼此独立、并行运行。
</p>

<p>
Emacs 会尝试通过解析你输入的命令（如 <code>cd</code> 等）来跟踪当前目录。这种方法容易出错，因为修改当前目录的方式很多，因此 Emacs 还会识别专门用于传递目录信息的 OSC（Operating System Commands操作系统命令）转义码，这种方式更可靠。你可以配置 Shell 在每个提示符处输出合适的转义序列，例如使用以下命令：
</p>


<div class="org-src-container">
<pre class="src src-shell">printf <span style="color: #8b2252;">"\e]7;file://%s%s\e\\"</span> <span style="color: #8b2252;">"$HOSTNAME"</span> <span style="color: #8b2252;">"$PWD"</span>
</pre>
</div>

<p>
然后告诉 Emacs 处理这些转义码：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'comint-output-filter-functions #'comint-osc-process-output)
</pre>
</div>

<p>
要指定 <code>M-x shell</code> 使用的 Shell 文件名，自定义变量 <code>explicit-shell-file-name</code> 。如果该变量为 <code>nil</code> （默认），Emacs 会优先使用环境变量 <code>ESHELL</code> （如果存在）。否则通常使用变量 <code>shell-file-name</code> （参见<a href="#Single-Shell">单行 Shell 命令</a>）；但如果默认目录是远程目录（参见<a href="#Remote-Files">远程文件</a>），Emacs 会提示你输入 Shell 文件名。关于如何高效输入远程文件名，参见<a href="#Minibuffer-File">文件名的迷你缓冲</a>。
</p>

<p>
如果存在文件 <code>~/.emacs_shellname</code> （其中 <i>shellname</i> 是所加载 Shell 的文件名），Emacs 会将其内容作为输入发送给新启动的 Shell。例如，使用 <code>bash</code> 时，该文件为 <code>~/.emacs_bash</code> 。如果找不到该文件，Emacs 会尝试 <code>~/.emacs.d/init_shellname.sh</code> 。
</p>

<p>
要为 Shell 指定编码系统，可在 <code>M-x shell</code> 之前使用 <code>C-x RET c</code> 。也可以在 Shell 缓冲区中输入 <code>C-x RET p</code> 来修改正在运行的子 Shell 的编码系统。参见<a href="#Communication-Coding">进程间通信的编码系统</a>。
</p>

<p>
Emacs 会在子 Shell 中将环境变量 <code>INSIDE_EMACS</code> 设置为 '<i>version</i>,comint'，其中 <i>version</i> 是 Emacs 版本号（如 28.1）。程序可以检查此变量，以判断是否运行在 Emacs 子 Shell 中。
</p>
</div>
</div>
<div id="outline-container-Shell-Mode" class="outline-3">
<h3 id="Shell-Mode"><span class="section-number-3">40.3.</span> Shell 模式</h3>
<div class="outline-text-3" id="text-Shell-Mode">
<p>
Shell 缓冲区使用的主模式是 Shell mode。它的许多专用快捷键都以 <code>C-c</code> 为前缀，用法与普通 Shell 里常见的编辑和任务控制键类似，只是需要先按 <code>C-c</code> 。下面是 Shell 模式的命令列表：
</p>

<dl class="org-dl">
<dt><code>RET</code></dt><dd>将当前行作为输入发送给子 Shell (<code>comint-send-input</code>)。行首的 Shell 提示符会被忽略（见 <a href="#Shell-Prompts">Shell 提示符</a>）。如果光标在缓冲区末尾，这就和在普通交互式 Shell 里提交命令行一样。不过，你也可以在 Shell 缓冲区的任意位置按 <code>RET</code> ，将当前行作为输入提交。</dd>
<dt><code>TAB</code></dt><dd>对 Shell 缓冲区中光标前的命令名或文件名进行补全 (<code>completion-at-point</code>)。它使用 Emacs 常规的补全规则（见<a href="#Completion">补全</a>），补全候选项包括文件名、环境变量名、Shell 命令历史以及历史引用（见 <a href="#History-References">Shell 历史引用</a>）。控制补全行为的选项见 <a href="#Shell-Options">Shell 模式选项</a>。</dd>
<dt><code>M-?</code></dt><dd>临时显示光标前文件名的所有可能补全列表 (<code>comint-dynamic-list-filename-completions</code>)。</dd>
<dt><code>C-d</code></dt><dd>要么删除一个字符，要么发送 EOF 结束信号 (<code>comint-delchar-or-maybe-eof</code>)。在 Shell 缓冲区末尾按 <code>C-d</code> 会向子 Shell 发送 EOF；在缓冲区其他位置则照常删除字符。</dd>
<dt><code>C-c C-a</code></dt><dd>跳转到行首，但如果有提示符则跳到提示符之后 (<code>comint-bol-or-process-mark</code>)。如果连续按两次，第二次会跳回到进程标记（process mark），也就是你尚未发送给子 Shell 的输入的起始位置。（通常就是本行提示符的末尾，但在使用 <code>C-c SPC</code> 后，进程标记可能出现在上一行。）</dd>
<dt><code>C-c SPC</code></dt><dd>累积多行输入，之后一起发送 (<code>comint-accumulate</code>)。该命令会在光标前插入换行，但不会把前面的文本发送给子 Shell—— 至少暂时不会。当你按 <code>RET</code> 时，换行前后的两行（以及分隔它们的换行符）会一起发送。</dd>
<dt><code>C-c C-u</code></dt><dd>删除缓冲区末尾待发送的所有输入文本 (<code>comint-kill-input</code>)。如果光标不在缓冲区末尾，只删除光标之前的那部分待输入文本。</dd>
<dt><code>C-c C-w</code></dt><dd>删除光标前的一个单词 (<code>backward-kill-word</code>)。</dd>
<dt><code>C-c C-c</code></dt><dd>中断 Shell 或其当前子任务（如果有） (<code>comint-interrupt-subjob</code>) 。该命令同时会清空 Shell 缓冲区中尚未发送的所有输入。</dd>
<dt><code>C-c C-z</code></dt><dd>暂停 Shell 或其当前子任务（如果有） (<code>comint-stop-subjob</code>)。该命令同时会清空 Shell 缓冲区中尚未发送的所有输入。</dd>
<dt><code>C-c C-\</code></dt><dd>向 Shell 或其当前子任务（如果有）发送退出信号 (<code>comint-quit-subjob</code>) 。该命令同时会清空 Shell 缓冲区中尚未发送的所有输入。</dd>
<dt><code>C-c C-o</code></dt><dd>删除上一条 Shell 命令的最后一批输出 (<code>comint-delete-output</code>)。当某条命令输出大量无用信息时很有用。带前缀参数使用时，会把删除的文本保存到剪切环 (<code>kill-ring</code>)，之后可以在别处粘贴。</dd>
<dt><code>C-c C-s</code></dt><dd>将上一条 Shell 命令的最后一批输出写入文件 (<code>comint-write-output</code>)。带前缀参数时为追加写入。输出末尾的提示符不会被写入。</dd>
<dt><code>C-c C-r</code></dt><dd></dd>

<dt><code>C-M-l</code></dt><dd>滚动窗口，使上一批输出的开头显示在窗口顶部，并将光标移到那里 (<code>comint-show-output</code>)。</dd>
<dt><code>C-c C-e</code></dt><dd>滚动窗口，使缓冲区最后一行显示在窗口底部 (<code>comint-show-maximum-output</code>)。</dd>
<dt><code>C-c C-f</code></dt><dd>向后跳过一条 Shell 命令，但不超出当前行 (<code>shell-forward-command</code>)。变量 <code>shell-command-regexp</code> 用于定义如何识别命令结尾。</dd>
<dt><code>C-c C-b</code></dt><dd>向前跳过一条 Shell 命令，但不超出当前行 (<code>shell-backward-command</code>)。</dd>
<dt><code>M-x dirs</code></dt><dd>向 Shell 查询当前工作目录，并更新 Shell 缓冲区的默认目录。见<a href="#Directory-Tracking">目录跟踪</a>。</dd>
<dt><code>M-x comint-send-invisible RET 文本 RET</code></dt><dd><p>
以不回显的方式读取 <i>text文本</i> ，然后发送给 Shell。当 Shell 命令运行需要输入密码的程序时，这个命令很有用。
</p>

<p>
注意：Emacs 默认不会回显密码。如果你确实需要回显密码，请执行下面的 Elisp 表达式：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(remove-hook 'comint-output-filter-functions
             'comint-watch-for-password-prompt)
</pre>
</div></dd>

<dt><code>M-x comint-continue-subjob</code></dt><dd>继续 Shell 进程。如果你意外挂起了 Shell 进程，这个命令很有用<sup><a id="fnr.22" class="footref" href="#fn.22" role="doc-backlink">22</a></sup>。</dd>
<dt><code>M-x comint-strip-ctrl-m</code></dt><dd><p>
从当前一组 Shell 输出中清除所有控制字符 <code>^M</code> （回车符）。最方便的用法是让它在收到子 Shell 输出时自动运行，执行以下代码：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'comint-output-filter-functions
          'comint-strip-ctrl-m)
</pre>
</div></dd>

<dt><code>M-x comint-truncate-buffer</code></dt><dd><p>
将 Shell 缓冲区截断到指定的最大行数，行数由变量 <code>comint-buffer-maximum-size</code> 决定。若要每次收到输出时都自动截断，执行：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'comint-output-filter-functions
          'comint-truncate-buffer)
</pre>
</div></dd>
</dl>

<p>
默认情况下，Shell 模式会处理常见的 ANSI 转义码（例如修改文字颜色）。Emacs 还可选支持一些扩展转义码，比如部分 OSC（操作系统命令）码，只需在配置文件中加入：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'comint-output-filter-functions #'comint-osc-process-output)
</pre>
</div>

<p>
启用后，例如 <code>ls --hyperlink</code> 的输出会在 Shell 模式缓冲区中变成可点击的链接按钮。
</p>

<p>
Shell 模式继承自 Comint 模式，后者是用于与交互式子进程通信的通用模式。Shell 模式的大部分功能实际来自 Comint 模式，从命令名前缀就能看出来。Shell 模式的特有功能包括目录跟踪和少量用户命令。
</p>

<p>
其他使用 Comint 变体的 Emacs 功能包括 GUD（见<a href="#Debuggers">调试器</a>）和 <code>M-x run-lisp</code> （见<a href="#External-Lisp">运行外部 Lisp 解释</a>）等。
</p>

<p>
你可以用 <code>M-x comint-run</code> 以未经定制的原始 Comint 模式运行任意程序 —— 不带 Shell 模式的那些特殊功能。要给程序传递参数，使用 <code>C-u M-x comint-run</code> 。
</p>
</div>
</div>
<div id="outline-container-Shell-Prompts" class="outline-3">
<h3 id="Shell-Prompts"><span class="section-number-3">40.4.</span> Shell 提示符</h3>
<div class="outline-text-3" id="text-Shell-Prompts">
<p>
提示符是程序输出的一段文本，用于表明它已准备好接收用户新的输入。通常情况下，Comint 模式（以及由此衍生的 Shell 模式）会根据子进程的输出，自动识别缓冲区中的哪一部分是提示符。（具体来说，它会将所有不以换行符结尾的输出行视作提示符。）
</p>

<p>
Comint 模式会将缓冲区分为两类 <i>fields区域</i> ：
</p>
<ul class="org-ul">
<li>输入区域：用户输入命令的位置</li>
<li>输出区域：除此之外的所有内容</li>
</ul>

<p>
提示符属于输出区域。大多数 Emacs 光标移动命令 <b>不会跨越区域边界</b> ，除非命令本身需要跨多行移动。例如，当光标位于某行 Shell 命令的输入区域时，按下 <code>C-a</code> 会将光标定位到 <b>输入区域的开头</b> ，也就是提示符之后。在内部实现中，这些区域是通过文本区域属性（field text property） 来实现的（详见《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Text-Properties.html#Text-Properties">文本属性</a>章节）。
</p>

<p>
如果你将变量 <code>comint-use-prompt-regexp</code> 设置为非空值，Comint 模式就会 <b>使用正则表达式</b> 来识别提示符（详见<a href="#Regexps">正则表达式语法</a>）。在 Shell 模式下，该正则表达式由变量 <code>shell-prompt-pattern</code> 指定。
</p>

<p>
<code>comint-use-prompt-regexp</code> 的默认值为 <code>nil</code> ，因为这种识别提示符的方式并不可靠；但在一些特殊场景下，你可以将其设为非空值。此时，Emacs 不会再把 Comint 缓冲区划分成不同区域，因此常规的光标移动命令会和在普通无特殊属性的缓冲区中行为一致。不过，你仍然可以使用 <b>段落移动命令</b> 来方便地浏览缓冲区（详见<a href="#Paragraphs">段落</a>相关章节）；在 Shell 模式下，Emacs 会把 <code>shell-prompt-pattern</code> 匹配的内容当作段落边界。
</p>
</div>
</div>
<div id="outline-container-Shell-History" class="outline-3">
<h3 id="Shell-History"><span class="section-number-3">40.5.</span> Shell 命令历史</h3>
<div class="outline-text-3" id="text-Shell-History">
<p>
Shell 缓冲区支持三种重复执行之前命令的方式：你可以使用类似迷你缓冲区（minibuffer）历史记录的按键；其工作方式与迷你缓冲区中基本相同，会从之前的命令中插入文本，同时光标始终保持在缓冲区末尾。你可以在缓冲区中移动到之前输入命令的原始位置，然后重新提交或将它们复制到缓冲区末尾。或者，你也可以使用以 '<code>!</code>' 开头的历史引用方式。
</p>
</div>
<div id="outline-container-Shell-Ring" class="outline-4">
<h4 id="Shell-Ring"><span class="section-number-4">40.5.1.</span> Shell 历史环</h4>
<div class="outline-text-4" id="text-Shell-Ring">
<dl class="org-dl">
<dt><code>M-p</code></dt><dd></dd>

<dt><code>C-UP</code></dt><dd>取出上一条更早的 Shell 命令 (<code>comint-previous-input</code>)。</dd>
<dt><code>M-n</code></dt><dd></dd>

<dt><code>C-DOWN</code></dt><dd>取出下一条更近的 Shell 命令 (<code>comint-next-input</code>)。</dd>
<dt><code>M-r</code></dt><dd>开始对过往 Shell 命令进行增量正则表达式搜索 (<code>comint-history-isearch-backward-regexp</code>)。</dd>
<dt><code>C-c C-x</code></dt><dd>从历史记录中取出下一条连续命令 (<code>comint-get-next-from-history</code>)。</dd>
<dt><code>C-c .</code></dt><dd>从旧 Shell 命令中取出一个参数 (<code>comint-input-previous-argument</code>)。</dd>
<dt><code>C-c C-l</code></dt><dd>在另一个窗口中显示缓冲区的 Shell 命令历史 (<code>comint-dynamic-list-input-ring</code>)。</dd>
</dl>

<p>
Shell 缓冲区会保存之前输入过的命令历史。要复用历史中的命令，可使用编辑命令 <code>M-p</code> 、 <code>M-n</code> 和 <code>M-r</code> 。它们的行为与迷你缓冲区（minibuffer）的历史命令类似（参见 “<a href="#Minibuffer-History">迷你缓冲区历史</a>”），区别在于这些命令作用于 Shell 缓冲区而非迷你缓冲区，并且 Shell 缓冲区中的 <code>M-r</code> 会对 Shell 命令历史执行增量搜索。
</p>

<p>
<code>M-p</code> 会将更早的一条 Shell 命令取出到 Shell 缓冲区末尾。连续使用 <code>M-p</code> 会依次取出更早的命令，每条命令都会替换掉当前作为待输入的文本。 <code>M-n</code> 作用类似，只是会依次取出更近的命令。 <code>C-UP</code> 等同于 <code>M-p</code> ， <code>C-DOWN</code> 等同于 <code>M-n</code> 。
</p>

<p>
历史搜索命令 <code>M-r</code> 会启动对过往 Shell 命令的增量正则表达式搜索。按下 <code>M-r</code> 后，输入你想匹配的字符串或正则表达式，最后一条匹配的 Shell 命令会显示在当前行。增量搜索命令保持原有行为 —— 例如 <code>C-s</code> 和 <code>C-r</code> 分别向前、向后查找下一个匹配项（参见 “<a href="#Incremental-Search">增量搜索</a>”）。找到想要的输入后，按 <code>RET</code> 结束搜索，该命令会被放到命令行中。在浏览历史列表前你正在输入的内容，会在回到历史环开头或末尾时自动恢复。
</p>

<p>
有时需要重新执行一连串连续的 Shell 命令。做法是：先找到并重新执行序列中的第一条命令，然后按 <code>C-c C-x</code> ，它会取出紧跟在刚才重复命令之后的下一条命令，再按 <code>RET</code> 执行。反复使用 <code>C-c C-x RET</code> 即可连续重执行多条命令。
</p>

<p>
命令 <code>C-c .</code> (<code>comint-insert-previous-argument</code>) 用于从之前的命令中复制单个参数，类似 <code>Bash</code> 和 <code>zsh</code> 中的 <code>ESC .</code> 。最简单的用法是复制上一条命令的最后一个参数。带前缀参数 <code>n</code> 时，会复制第 <code>n</code> 个参数。重复按 <code>C-c .</code> 会从更早的命令中复制同一位置的参数（重复时不要再加前缀参数）。
</p>

<p>
如果将变量 <code>comint-insert-previous-argument-from-end</code> 设为非空值， <code>C-c .</code> 会改为从末尾往前数第 <code>n</code> 个参数，这模拟了 <code>zsh</code> 中的 <code>ESC .</code> 行为。
</p>

<p>
这些命令从专门的历史列表中获取旧命令文本，而非直接从 Shell 缓冲区读取。因此，编辑 Shell 缓冲区甚至删除其中大部分内容，都不会影响这些命令访问的历史记录。
</p>

<p>
部分 Shell 会将命令历史保存到文件中，以便在不同 Shell 会话间复用。Emacs 会读取你所用 Shell 的历史文件来初始化自身的命令历史。历史文件名由变量 <code>shell-history-file-name</code> 指定：
</p>
<ul class="org-ul">
<li>若该选项为 <code>t</code> ，则不读取命令历史；</li>
<li>若为 <code>nil</code> ，则从环境变量 <code>HISTFILE</code> 指定的文件读取；</li>
<li>Bash： <code>~/.bash_history</code></li>
<li>ksh： <code>~/.sh_history</code></li>
<li>zsh： <code>~/.zsh_history</code></li>
<li>其他 Shell： <code>~/.history</code></li>
</ul>
</div>
</div>
<div id="outline-container-Shell-History-Copying" class="outline-4">
<h4 id="Shell-History-Copying"><span class="section-number-4">40.5.2.</span> Shell 历史复制</h4>
<div class="outline-text-4" id="text-Shell-History-Copying">
<dl class="org-dl">
<dt><code>C-c C-p</code></dt><dd>将光标移到上一个提示符处 (<code>comint-previous-prompt</code>)。</dd>
<dt><code>C-c C-n</code></dt><dd>将光标移到下一个提示符处 (<code>comint-next-prompt</code>)。</dd>
<dt><code>C-c RET</code></dt><dd>复制光标所在位置的输入命令，并将副本插入到缓冲区末尾 (<code>comint-copy-old-input</code>)。当你把光标移回到之前的命令时，这个命令非常有用。复制命令后，你可以按 <code>RET</code> 将复制内容作为新输入提交。如果需要，你可以在重新提交前编辑复制的内容。如果你在输出行上使用此命令，它会将该行复制到缓冲区末尾。</dd>
<dt><code>mouse-2</code></dt><dd>如果 <code>comint-use-prompt-regexp</code> 为 <code>nil</code> （默认值），则复制你点击的旧输入命令，并将副本插入缓冲区末尾 (<code>comint-insert-input</code>)。如果 <code>comint-use-prompt-regexp</code> 为非空值，或者点击位置不在旧输入上，则执行普通的粘贴操作。</dd>
</dl>

<p>
先移到之前的输入，再用 <code>C-c RET</code> 或 <code>mouse-2</code> 复制，得到的缓冲区内容，与你多次按 <code>M-p</code> 从历史记录中取出该旧输入的效果相同。但是， <code>C-c RET</code> 是从缓冲区中复制文本；如果你在命令发送后编辑过缓冲区里的输入内容，缓冲区内容可能与历史记录中的内容不一致。
</p>
</div>
</div>
<div id="outline-container-History-References" class="outline-4">
<h4 id="History-References"><span class="section-number-4">40.5.3.</span> Shell 历史引用</h4>
<div class="outline-text-4" id="text-History-References">
<p>
包括 csh 和 bash 在内的多种 Shell，都支持以 <code>!</code> 和 <code>^</code> 开头的历史引用。Shell 模式能够识别这些语法结构，并为你执行历史替换。
</p>

<p>
如果你输入一条历史引用并按下 <code>TAB</code> ，Emacs 会在输入历史中搜索匹配的命令，按需执行替换，并将结果替换掉原来的历史引用插入到缓冲区中。例如，输入 <code>!mv</code> 再按 <code>TAB</code> ，即可取出最近一条以 'mv' 开头的命令。你可以按需编辑该命令，然后按下 <code>RET</code> 重新提交给 Shell。
</p>

<p>
Shell 模式可以在你将命令发送给 Shell 时，自动展开缓冲区中的历史引用。要启用此功能，可将变量 <code>comint-input-autoexpand</code> 设置为 <code>input</code> 。你还可以将 <code>SPC</code> 键绑定到命令 <code>comint-magic-space</code> ，让 <code>SPC</code> 空格键也执行历史展开（参见<a href="#Rebinding">交互式修改按键绑定</a>）。
</p>

<p>
Shell 模式只识别出现在提示符之后的历史引用。关于 Shell 模式如何识别提示符，可参见「<a href="#Shell-Prompts">Shell 提示符</a>」一节。
</p>
</div>
</div>
</div>
<div id="outline-container-Directory-Tracking" class="outline-3">
<h3 id="Directory-Tracking"><span class="section-number-3">40.6.</span> 目录跟踪</h3>
<div class="outline-text-3" id="text-Directory-Tracking">
<p>
Shell 模式会跟踪发送给子 Shell 的 cd、pushd 和 popd 命令，以便让 Shell 缓冲区的 <b>默认目录</b> （见<a href="#File-Names">文件名</a>）与 Shell 的工作目录保持一致。它通过检查你发送的输入行来识别这些命令。
</p>

<p>
如果你为这些命令设置了别名，可以通过将变量 <code>shell-cd-regexp</code> 、 <code>shell-pushd-regexp</code> 、 <code>shell-popd-regexp</code> 设置为对应的正则表达式，来让 Emacs 也识别这些别名（见<a href="#Regexps">正则表达式语法</a>）。例如，如果 <code>shell-pushd-regexp</code> 与某条 Shell 命令行的开头匹配，该行就会被视为 <code>pushd</code> 命令。这些命令 <b>只在命令行开头</b> 才会被识别。
</p>

<p>
如果 Emacs 对子 Shell 的工作目录变化判断出错，可以输入 <code>M-x dirs</code> 。该命令会向 Shell 查询当前工作目录，并据此更新 Emacs 里的默认目录。它适用于支持最常用命令语法的 Shell，但在一些特殊 Shell 中可能无效。
</p>

<p>
你还可以使用 <b>Dirtrack 模式</b> —— 一种缓冲区本地的次要模式，它提供另一种跟踪 Shell 工作目录的方式。使用该方式时，你的 Shell 提示符必须 <b>始终包含工作目录</b> ，并且你必须提供一个正则表达式，用于识别提示符中哪一部分是工作目录；详情见变量 <code>dirtrack-list</code> 的文档。要启用 Dirtrack 模式，可以在 Shell 缓冲区中输入 <code>M-x dirtrack-mode</code> ，或将 <code>dirtrack-mode</code> 添加到 <code>shell-mode-hook</code> 中（见<a href="#Hooks">钩子</a>）。
</p>
</div>
</div>
<div id="outline-container-Shell-Options" class="outline-3">
<h3 id="Shell-Options"><span class="section-number-3">40.7.</span> Shell 模式选项</h3>
<div class="outline-text-3" id="text-Shell-Options">
<p>
如果变量 <code>comint-scroll-to-bottom-on-input</code> 为非空值，那么在插入和粘贴操作前，当前窗口会自动滚动到缓冲区底部。默认值为 <code>nil</code> 。
</p>

<p>
如果 <code>comint-scroll-show-maximum-output</code> 为非空值，当光标位于缓冲区末尾时，新输出到来时会尽量把最后一行显示在窗口最底部，以展示尽可能多的有效内容。（这模仿了大多数终端的滚动行为。）默认值为 <code>t</code> 。
</p>

<p>
通过设置 <code>comint-move-point-for-output</code> ，你可以让 <b>每当有新输出时，光标自动跳转到缓冲区末尾</b> ，无论光标之前在何处：
</p>
<ul class="org-ul">
<li>值为 this：仅在选中窗口中跳转光标</li>
<li>值为 all：在所有显示该 Comint 缓冲区的窗口中跳转</li>
<li>值为 other：在所有非选中但显示该缓冲区的窗口中跳转</li>
<li>默认值为 nil，表示光标不自动跳转。</li>
</ul>

<p>
如果设置 <code>comint-prompt-read-only</code> ，Comint 缓冲区中的提示符会变为 <b>只读</b> 。
</p>

<p>
变量 <code>comint-input-ignoredups</code> 控制是否在输入历史中保存连续重复的命令。非空值表示忽略与上一条相同的输入；默认值 <code>nil</code> 表示保存所有输入，即使重复。
</p>

<p>
有三个变量用于自定义文件名补全：
</p>
<ul class="org-ul">
<li><code>comint-completion-addsuffix</code> ：控制补全后是否自动添加空格或斜杠来标识已完整匹配的文件或目录（非空表示添加）。</li>
<li><code>comint-completion-recexact</code> ：若为非空，当常规补全无法再增加字符时， <code>TAB</code> 会选择最短的可能匹配项。</li>
<li><code>comint-completion-autolist</code> ：若为非空，当无法精确补全时，自动列出所有可能结果。</li>
</ul>

<p>
命令补全默认只考虑 <b>可执行文件</b> 。如果将 <code>shell-completion-execonly</code> 设为 <code>nil</code> ，则也会包含不可执行文件。
</p>

<p>
变量 <code>shell-completion-fignore</code> 指定在 Shell 模式补全中要忽略的文件后缀列表。默认值为 <code>nil</code> ；很多用户会设为 ("<code>" "#" "%")，忽略以 ~、#、% 结尾的文件。其他相关的 Comint 模式则使用变量 ~comint-completion-fignore</code> 。
</p>

<p>
Shell 命令补全的部分实现细节，可参考 <code>shell-dynamic-complete-command</code> 函数的 Lisp 文档。
</p>

<p>
你可以配置 'pushd' 的行为：
</p>
<ul class="org-ul">
<li><code>shell-pushd-tohome</code> ：无参数时是否像 cd 一样回到家目录</li>
<li><code>shell-pushd-dextract</code> ：使用数字参数时是否直接弹出而非旋转</li>
<li><code>shell-pushd-dunique</code> ：仅当目录不在目录栈中时才加入</li>
</ul>

<p>
这些设置应与底层 Shell 的行为保持一致。
</p>

<p>
Comint 模式会将环境变量 <code>TERM</code> 设置为安全的默认值，但这会禁用部分有用功能，例如很多程序会根据 <code>TERM</code> 判断是否支持颜色，此时颜色会被关闭。因此 Emacs 提供了 <code>comint-terminfo-terminal</code> 选项，让你指定系统 terminfo 数据库中功能更完整的终端类型。只要 <code>system-uses-terminfo</code> 为非空，Emacs 就会用该选项作为 <code>TERM</code> 的值。
</p>

<p>
<code>comint-terminfo-terminal</code> 和 <code>system-uses-terminfo</code> 都可以声明为 <b>连接本地变量</b> ，以便适配不同远程主机的需求（参见 “<a href="#Connection-Variables">按连接本地变量</a>”）。
</p>
</div>
</div>
<div id="outline-container-Terminal-emulator" class="outline-3">
<h3 id="Terminal-emulator"><span class="section-number-3">40.8.</span> Emacs 终端模拟器</h3>
<div class="outline-text-3" id="text-Terminal-emulator">
<p>
要在文本终端模拟器中运行子 Shell，使用 <code>M-x term</code> 。该命令会创建（或复用）名为 <code>*terminal*</code> 的缓冲区，并运行一个子 Shell：输入来自你的键盘，输出则发送到该缓冲区。
</p>

<p>
终端模拟器使用 Term 模式，它包含两种输入模式：
</p>
<ul class="org-ul">
<li>行模式（line mode）：Term 模式的行为基本与 Shell 模式一致（见 <a href="#Shell-Mode">Shell 模式</a>）。</li>
<li><p>
字符模式（char mode）：每个字符会直接作为终端输入发送给子 Shell；唯一的例外是 <b>终端转义字符</b> ，默认为 <code>C-c</code> （见 <a href="#Term-Mode">Term 模式</a>）。
</p>

<p>
输入的回显由子 Shell 负责处理；子 Shell 输出的任何终端内容都会进入缓冲区，并移动光标。
</p></li>
</ul>

<p>
有些程序（如 Emacs 本身）需要精细控制终端屏幕的显示效果，它们会通过发送特殊的控制码来实现。Term 模式能够识别并处理 <b>ANSI 标准 VT100 风格转义序列</b> ，这是包括 <code>xterm</code> 在内的大多数现代终端都支持的格式。（因此，你甚至可以在 Emacs 的 Term 窗口中再运行一个 Emacs。）
</p>

<p>
<code>term</code> 外观指定了终端模拟器中文本的默认外观（默认与默认外观相同）。当使用终端控制码改变文本外观时，终端模拟器会通过以下外观来表示：term-color-black、term-color-red、term-color-green、term-color-yellow、term-color-blue、term-color-magenta、term-color-cyan、term-color-white、term-color-underline、term-color-bold。详见「<a href="#Faces">文本面孔</a>」。
</p>

<p>
你也可以使用 Term 模式与连接到串口的设备进行通信。详见「<a href="#Serial-Terminal">串口终端</a>」。
</p>

<p>
用于加载子 Shell 的文件名，其确定方式与 Shell 模式相同。若要创建多个终端模拟器，可以使用 <code>M-x rename-uniquely</code> 将 <code>*terminal*</code> 缓冲区重命名为其他名称，用法与 Shell 模式一致。
</p>

<p>
与 Shell 模式不同，Term 模式 <b>不会通过解析输入来跟踪当前目录</b> 。但部分 Shell 可以主动告知 Term 当前目录，bash 1.15 及以上版本会自动实现这一点。
</p>
</div>
</div>
<div id="outline-container-Term-Mode" class="outline-3">
<h3 id="Term-Mode"><span class="section-number-3">40.9.</span> 终端模式</h3>
<div class="outline-text-3" id="text-Term-Mode">
<p>
在 Term 模式中，在行模式和字符模式之间切换，使用以下命令：
</p>
<dl class="org-dl">
<dt><code>C-c C-j</code></dt><dd>切换到行模式 (<code>term-line-mode</code>)。如果已经在行模式，则不执行任何操作。</dd>
<dt><code>C-c C-k</code></dt><dd>切换到字符模式 (<code>term-char-mode</code>)。如果已经在字符模式，则不执行任何操作。</dd>
</dl>

<p>
以下命令仅在字符模式下可用：
</p>
<dl class="org-dl">
<dt><code>C-c C-c</code></dt><dd>向子 Shell 发送一个原始的 <code>C-c</code> (<code>term-interrupt-subjob</code>)。</dd>
<dt><code>C-c 字符</code></dt><dd>等价于普通 Emacs 中的 <code>C-x 字符</code> 。例如， <code>C-c o</code> 会触发 <code>C-x o</code> 的全局绑定，该命令通常是「other-window」。</dd>
</dl>

<p>
Term 模式有分页显示功能。启用后，输出会在每屏内容结束时暂停：
</p>
<dl class="org-dl">
<dt><code>C-c C-q</code></dt><dd>切换分页显示功能 (<code>term-pager-toggle</code>)。该命令在行模式和字符模式下均有效。启用该功能后，模式行上会显示单词 'page'；每当 Term 接收到超过一屏的输出时，就会暂停，并在模式行显示 '<code>**MORE**</code>' 。按 <code>SPC</code> 显示下一屏内容，或按 <code>?</code> 查看其他选项。界面与 <code>more</code> 程序类似。</dd>
</dl>
</div>
</div>
<div id="outline-container-Remote-Host" class="outline-3">
<h3 id="Remote-Host"><span class="section-number-3">40.10.</span> 远程主机 Shell</h3>
<div class="outline-text-3" id="text-Remote-Host">
<p>
你可以在 Term 窗口中登录到远程计算机，使用与普通终端相同的命令（例如 <code>ssh</code> 命令）。
</p>

<p>
需要输入密码的程序通常会禁止密码回显，因此密码不会显示在缓冲区中。如果缓冲区处于字符模式，效果与使用真实终端完全一致。如果处于行模式，密码会暂时可见，但按下 <code>RET</code> 回车键后会自动清除。（这一过程是自动的，无需特殊的密码处理。）
</p>

<p>
登录到其他机器时，你需要通过在远程登录命令的环境中设置环境变量 <code>TERM</code> ，来指定你所使用的终端类型。（如果使用 bash，可在远程登录命令之前直接赋值变量，中间无需逗号。）终端类型 'ansi' 或 'vt100' 在大多数系统上都能正常工作。
</p>
</div>
</div>
<div id="outline-container-Serial-Terminal" class="outline-3">
<h3 id="Serial-Terminal"><span class="section-number-3">40.11.</span> 串行终端</h3>
<div class="outline-text-3" id="text-Serial-Terminal">
<p>
如果你的计算机上有设备连接到串口，可以通过输入 <code>M-x serial-term</code> 与其通信。该命令会询问串口名称和波特率，然后切换到一个新的 Term 模式缓冲区。Emacs 通过该缓冲区与串口设备交互，方式与普通 Term 模式下的终端一致。
</p>

<p>
串口的速率以 比特/秒 为单位，最常用的速率是 9600 比特/秒。你可以通过点击模式行来交互式修改速率。
</p>

<p>
点击模式行中的 '8N1' 还可以对串口进行更多配置。串口默认配置为 '8N1'，含义是：每个字节包含 8 个数据位、无校验位、1 个停止位。
</p>

<p>
如果速率或配置错误，将无法与设备正常通信，窗口中很可能只会显示乱码。
</p>
</div>
</div>
</section>
<section id="outline-container-Emacs-Server" class="outline-2">
<h2 id="Emacs-Server"><span class="section-number-2">41.</span> 将 Emacs 用作服务器</h2>
<div class="outline-text-2" id="text-Emacs-Server">
<p>
很多程序可以调用你指定的编辑器来编辑某段文本。例如，版本控制程序会调用编辑器来填写版本控制日志（见<a href="#Version-Control">版本控制</a>），Unix 的邮件工具会调用编辑器来编写要发送的邮件。按照惯例，你选择的编辑器由环境变量 <code>EDITOR</code> 指定。如果把 <code>EDITOR</code> 设为 <code>emacs</code> ，Emacs 会被调用，但方式并不方便 —— 它会 <b>启动一个全新的 Emacs 进程</b> 。这很不方便，因为新的 Emacs 进程不会与已有的 Emacs 进程共享缓冲区、命令历史或其他信息。
</p>

<p>
你可以通过将 Emacs 设置为 <b><i>edit server编辑服务器</i></b> 来解决这个问题，让它 “监听” 外部的编辑请求并做出响应。启动 Emacs 服务器有多种方式：
</p>

<ul class="org-ul">
<li>在已有的 Emacs 进程中运行命令 <code>server-start</code> ：可以输入 <code>M-x server-start</code> ，或者在你的初始化文件中加入表达式  <code>(server-start)</code> （见 <a href="#Init-File">Emacs 初始化文件</a>）。已有的 Emacs 进程就是服务器；当你退出 Emacs 时，服务器会随 Emacs 进程一同关闭。</li>

<li>以守护进程（daemon）方式运行 Emacs，使用 '<code>--daemon</code>' 命令行选项之一。见<a href="#Initial-Options">初始化选项</a>。以这种方式启动时，Emacs 会在初始化后调用 <code>server-start</code> ，且不会打开初始窗口，然后等待来自客户端的编辑请求。</li>

<li>运行 <code>emacsclient</code> 命令并带上 '<code>--alternate-editor=""</code>' 命令行选项。这会在没有 Emacs 守护进程运行时才启动一个 Emacs 守护进程。</li>

<li><p>
如果你的操作系统使用 <code>systemd</code> 管理启动项，可以在登录时通过提供的 <i>systemd unit file</i> 自动以守护进程模式启动 Emacs。启用方法：
</p>

<div class="org-src-container">
<pre class="src src-shell">systemctl --user enable emacs
</pre>
</div>

<p>
（如果你的 Emacs 安装在非标准位置，可能需要将 <code>emacs.service</code> 文件复制到标准目录，如 <code>~/.config/systemd/user/</code> 。）
</p></li>

<li><p>
外部进程可以在指定套接字上发生连接事件时启动 Emacs 服务器，并将套接字传递给新的 Emacs 服务器进程。 <code>systemd</code> 的套接字功能就是一个例子： <code>systemd</code> 服务创建一个套接字并监听连接；当 <code>emacsclient</code> 首次连接时，systemd 会启动 Emacs 服务器，并将套接字交给它处理后续连接。使用该功能的配置示例：
</p>

<p>
~/.config/systemd/user/emacs.socket:
</p>
<div class="org-src-container">
<pre class="src src-shell">[Socket]
<span style="color: #a0522d;">ListenStream</span>=/path/to/.emacs.socket
<span style="color: #a0522d;">DirectoryMode</span>=0700

[Install]
<span style="color: #a0522d;">WantedBy</span>=sockets.target
</pre>
</div>
<p>
（同时必须安装前面提到的 <code>emacs.service</code> 文件。） <code>ListenStream</code> 中的路径就是 Emacs 用来监听 <code>emacsclient</code> 连接的路径，你可以自行指定。
</p></li>
</ul>

<p>
Emacs 服务器启动后，你可以使用名为 <code>emacsclient</code> 的 Shell 命令连接到 Emacs 进程并让它打开文件。然后你可以将环境变量 <code>EDITOR</code> 设置为 <code>emacsclient</code> ，这样外部程序就会使用 <b>已有的 Emacs 进程</b> 进行编辑<sup><a id="fnr.23" class="footref" href="#fn.23" role="doc-backlink">23</a></sup>。
</p>

<p>
你可以在同一台机器上运行多个 Emacs 服务器，通过变量 <code>server-name</code> 给每个服务器设置唯一名称。例如： <code>M-x set-variable RET server-name RET "foo" RET</code> 会将服务器名称设为 <code>foo</code> 。 <code>emacsclient</code> 程序可以通过 '<code>-s</code>' 或 '<code>-f</code>' 选项按名称指定服务器（见 <a href="#emacsclient-Options">emacsclient 选项</a>），具体取决于服务器是否使用 TCP 套接字（见 <a href="#TCP-Emacs-server">TCP Emacs 服务器</a>）。
</p>

<p>
如果要运行多个 Emacs 守护进程（见初始化选项），可以这样为每个守护进程指定服务器名：
</p>

<div class="org-src-container">
<pre class="src src-shell">emacs --daemon=foo
</pre>
</div>

<p>
Emacs 服务器可以在满足特定条件时 <b>自动停止</b> 。要启用此功能，将选项 <code>server-stop-automatically</code> 设置为以下值之一：
</p>
<dl class="org-dl">
<dt><code>empty</code></dt><dd>当服务器没有客户端、没有未保存的文件缓冲区、也没有正在运行的进程时，自动停止服务器。</dd>
<dt><code>delete-frame</code></dt><dd>当最后一个客户端窗口被关闭时，会询问你是否保存所有未保存的文件缓冲区、是否停止所有未完成的进程；如果确认，服务器会停止。</dd>
<dt><code>kill-terminal</code></dt><dd>当用 <code>C-x C-c</code> (<code>save-buffers-kill-terminal</code>) 关闭最后一个客户端窗口时，会询问你是否保存所有未保存的文件缓冲区、是否停止所有未完成的进程；如果确认，服务器会停止。</dd>
</dl>

<p>
如果你用唯一名称定义了服务器，可以从另一个 Emacs 实例连接到该服务器，并使用 <code>server-eval-at</code> 函数在服务器上执行 Lisp 表达式。例如： <code>(server-eval-at "foo" '(+ 1 2))</code> 会在名为 'foo' 的服务器上执行表达式 <code>(+ 1 2)</code> 并返回 <code>3</code> 。（如果不存在该名称的服务器，会抛出错误。）目前该功能主要对开发者有用。
</p>

<p>
如果你的操作系统桌面环境符合 <a href="https://www.freedesktop.org/wiki/Specifications/">freedesktop.org 标准</a> （大多数 GNU/Linux 及较新的类 Unix 图形界面都是如此），你可以使用菜单条目 'Emacs (Client)' 通过 <code>emacsclient</code> 连接到 Emacs 服务器。如果守护进程尚未运行，会自动启动。
</p>

<ul class="org-ul">
<li><a href="#TCP-Emacs-server">TCP Emacs 服务器</a></li>
<li><a href="#Invoking-emacsclient">调用 emacsclient</a></li>
<li><a href="#emacsclient-Options">emacsclient 选项</a></li>
</ul>
</div>
<div id="outline-container-TCP-Emacs-server" class="outline-3">
<h3 id="TCP-Emacs-server"><span class="section-number-3">41.1.</span> TCP Emacs 服务器</h3>
<div class="outline-text-3" id="text-TCP-Emacs-server">
<p>
Emacs 服务器通常在本地 <b>Unix 域套接字</b> 上监听连接。部分操作系统（如 MS-Windows）不支持本地套接字，此时服务器会改用 <b>TCP 套接字</b> 。即使系统支持本地套接字，某些场景下使用 TCP 套接字也更实用，例如需要 <b>从远程机器连接 Emacs 服务器</b> 时。你可以将变量 <code>server-use-tcp</code> 设为非空值，让 Emacs 监听 TCP 套接字而非本地套接字。如果你的操作系统不支持本地套接字，该选项默认为启用。
</p>

<p>
如果 Emacs 服务器设为使用 TCP，默认会在 localhost 接口 的随机端口上监听。你可以通过变量 <code>server-host</code> 和 <code>server-port</code> ，改为监听其他网络接口和 / 或固定端口。
</p>

<p>
TCP 套接字 <b>不受文件系统权限控制</b> 。为了对能通过 TCP 访问 Emacs 服务器的用户进行限制， <code>emacsclient</code> 必须向服务器发送 <b>授权密钥</b> 。该密钥通常由 Emacs 服务器 <b>随机生成</b> ，这是推荐的使用方式。
</p>

<p>
如有需要，你可以通过设置变量 <code>server-auth-key</code> ，将授权密钥设为固定值。密钥必须由 64 个可打印 ASCII 字符 组成（不含空格），即从 '!' 到 '~' （十进制编码 33 到 126）之间的字符。你可以使用 <code>M-x server-generate-key</code> 生成随机密钥。
</p>

<p>
启动 TCP 版 Emacs 服务器时，Emacs 会创建一个 <b>服务器文件</b> ，其中包含 TCP 连接信息，供 <code>emacsclient</code> 连接服务器使用。变量 <code>server-auth-dir</code> 指定存放该服务器文件的默认目录，默认为： <code>~/.emacs.d/server/</code> 。在没有带文件权限的本地套接字时，该目录的权限决定了哪些用户的 <code>emacsclient</code> 进程可以与 Emacs 服务器通信。如果 <code>server-name</code> 是一个 <b>绝对路径</b> ，服务器文件会创建在该路径指定的位置。
</p>

<p>
若要让 <code>emacsclient</code> 通过 TCP 并使用指定服务器文件连接服务器，可以使用选项：'<code>-f</code>' 或 '<code>--server-file</code>' 或设置环境变量 <code>EMACS_SERVER_FILE</code> （见 <a href="#emacsclient-Options">emacsclient 选项</a>）。如果 <code>server-auth-dir</code> 设为非标准路径，或 <code>server-name</code> 设为绝对路径， <code>emacsclient</code> 需要使用 <b>服务器文件的绝对路径</b> 。因为 <code>emacsclient</code> 内部硬编码了默认的 <code>server-auth-dir</code> ，用于解析相对文件名。
</p>
</div>
</div>
<div id="outline-container-Invoking-emacsclient" class="outline-3">
<h3 id="Invoking-emacsclient"><span class="section-number-3">41.2.</span> 调用 emacsclient</h3>
<div class="outline-text-3" id="text-Invoking-emacsclient">
<p>
使用 <code>emacsclient</code> 最简单的方式是在 Shell 中运行命令： 'emacsclient <i>file</i>' 其中 <i>file</i> 是文件名。它会连接到 Emacs 服务器，并让该 Emacs 进程在已有的某个窗口中打开文件 —— 可以是图形窗口，也可以是文本终端窗口（见<a href="#Frames">窗口与图形显示</a>）。之后你可以切换到该窗口开始编辑。
</p>

<p>
如果没有 Emacs 服务器在运行， <code>emacsclient</code> 会报错并停止（你可以通过给 <code>emacsclient</code> 指定 '<code>--alternate-editor=""</code>' 选项避免这种情况，详见 <a href="#emacsclient-Options">emacsclientho 选项</a>）。如果 Emacs 进程没有已打开的框架（以守护进程方式启动时就会出现这种情况，详见「<a href="#Emacs-Server">将 Emacs 用作服务器</a>」），那么 Emacs 会在你调用 emacsclient 的终端上打开一个新窗口。
</p>

<p>
你也可以强制让 <code>emacsclient</code> 新建窗口：
</p>
<ul class="org-ul">
<li>使用 '-c' 选项在图形显示器上新建图形窗口。</li>
<li>使用 '-t' 选项在文本终端上新建终端窗口。详见 <a href="#emacsclient-Options">emacsclient 选项</a>。</li>
</ul>

<p>
如果你只在单个文本终端下操作，可以通过以下两种方法在 <code>emacsclient</code> 所在的 Shell 和 Emacs 服务器之间切换：(i) 在不同的虚拟终端上分别运行 Emacs 服务器和 <code>emacsclient</code> ，调用 <code>emacsclient</code> 后切换到 Emacs 服务器所在的虚拟终端；或者(ii) 在 Emacs 服务器内部，通过 Shell 模式（见<a href="#Interactive-Shell">交互式子 Shell</a>）或 Term 模式（见 <a href="#Term-Mode">Term 模式</a>）调用 <code>emacsclient</code> ；此时 <code>emacsclient</code> 只会阻塞 Emacs 内部的子 Shell，你仍然可以正常使用 Emacs 编辑文件。
</p>

<p>
当你在 Emacs 服务器中编辑完文件后，在对应缓冲区里按 <code>C-x #</code> (<code>server-edit</code>) 。这会保存文件，并向 <code>emacsclient</code> 发送消息让其退出。使用 <code>EDITOR</code> 环境变量的程序通常会等待编辑器（这里是 emacsclient）退出后再继续执行。
</p>

<p>
如果你想 <b>放弃编辑</b> ，可以使用 <code>M-x server-edit-abort</code> 。它会通知 <code>emacsclient</code> 以异常状态退出，且不保存任何缓冲区。
</p>

<p>
你也可以给 <code>emacsclient</code> 传入多个文件名： 'emacsclient <i>file1</i> <i>file2</i> &#x2026;' 它会让 Emacs 服务器依次打开这些文件。Emacs 会选中 <i>file1</i> 对应的缓冲区，并把其他缓冲区埋到缓冲区列表底部（见<a href="#Buffers">使用多个缓冲区</a>）。 <code>emacsclient</code> 会在 <b>所有指定文件都处理完毕</b> （即每个服务器缓冲区都按过 <code>C-x #</code> ）后才退出。
</p>

<p>
完成一个服务器缓冲区的编辑后，该缓冲区会被关闭，除非它在服务器被要求打开之前就已经存在。但如果你把 <code>server-kill-new-buffers</code> 设为 <code>nil</code> ，则会使用另一套规则：只有当文件名匹配 <code>server-temp-file-regexp</code> 正则表达式时，编辑完成才会关闭缓冲区。这一配置用于区分某些临时文件。
</p>

<p>
每次按 <code>C-x #</code> 都会检查是否有其他等待处理的外部编辑请求，并自动切换到下一个待编辑文件。你也可以手动切换到服务器缓冲区，不一定要靠 <code>C-x #</code> 跳过去。但 <code>C-x #</code> 是告诉 <code>emacsclient</code> 你已编辑完成的标准方式。
</p>

<p>
如果把变量 <code>server-window</code> 设置为某个窗口或窗口框架， <code>C-x #</code> 就会始终在该窗口 / 框架中显示下一个服务器缓冲区。
</p>

<p>
当 <code>emacsclient</code> 连接时，服务器通常会输出一段提示，告诉你如何退出客户端窗口。如果把 <code>server-client-instructions</code> 设为 <code>nil</code> ，这段提示就会被关闭。
</p>
</div>
</div>
<div id="outline-container-emacsclient-Options" class="outline-3">
<h3 id="emacsclient-Options"><span class="section-number-3">41.3.</span> emacsclient 选项</h3>
<div class="outline-text-3" id="text-emacsclient-Options">
<p>
你可以向 emacsclient 程序传递一些可选参数，例如：
</p>

<div class="org-src-container">
<pre class="src src-shell">emacsclient -c +12 file1 +4:3 file2
</pre>
</div>

<p>
如 '<code>+行号</code>' 或 '<code>+行号:列号</code>' 的参数，用于为下一个文件参数指定行号（或行号与列号）。这些参数的行为与 Emacs 自身的命令行参数一致。参见「<a href="#Action-Arguments">动作参数</a>」。
</p>

<p>
emacsclient 支持的其他可选参数如下：
</p>

<dl class="org-dl">
<dt>'<code>-a command</code>'</dt><dd></dd>

<dt>'<code>--alternate-editor=command</code>'</dt><dd><p>
如果 <code>emacsclient</code> 无法连接到 Emacs，则执行指定的 Shell 命令。这在脚本中运行 <code>emacsclient</code> 时非常有用。命令中可以包含参数，参数可以像这样 "用引号括起来"。目前不支持引号转义。
</p>

<p>
一个特殊例外：如果命令为空字符串， <code>emacsclient</code> 会以守护进程模式启动 Emacs（即 '<code>emacs --daemon</code>'），然后再次尝试连接。
</p>

<p>
环境变量 <code>ALTERNATE_EDITOR</code> 与 '<code>-a</code>' 选项作用相同。如果两者同时存在，命令行选项优先。
</p></dd>

<dt>'<code>-c</code>'</dt><dd></dd>

<dt>'<code>--create-frame</code>'</dt><dd><p>
新建一个图形 <i>client frame客户端框架</i> ，而不是使用已有的 Emacs 框架。关于客户端框架中 <code>C-x C-c</code> 的特殊行为，见下文。如果 Emacs 无法新建图形框架（例如无法连接 X 服务器），会尝试创建文本终端客户端框架，效果等同于使用 '<code>-t</code>' 选项。
</p>

<p>
在 MS-Windows 上，单个 Emacs 会话不能同时在图形终端和文本终端上显示框架，也不能在多个文本终端上显示。因此，如果 Emacs 服务器运行在文本终端上， '<code>-c</code>' 选项与 '<code>-t</code>' 选项一样，会在服务器当前文本终端中新建框架。
</p>

<p>
如果使用 '<code>-c</code>' 选项但不提供文件名，新框架默认显示 <code>*scratch*</code> 缓冲区。你可以通过变量 <code>initial-buffer-choice</code> 自定义这一行为（见「<a href="#Entering-Emacs">启动 Emacs</a>」）。
</p></dd>
<dt>'<code>-r</code>'</dt><dd></dd>

<dt>'<code>--reuse-frame</code>'</dt><dd>如果没有已存在的框架，则新建图形客户端框架；否则使用已有框架。</dd>
<dt>'-F <i>alist</i>'</dt><dd></dd>

<dt>'<code>--frame-parameters=alist</code>'</dt><dd>为新建的图形框架设置参数（见「<a href="#Frame-Parameters">框架参数</a>」）。</dd>
<dt>'-d <i>display</i>'</dt><dd></dd>

<dt>'<code>--display=display</code>'</dt><dd>告诉 Emacs 在指定的 X 显示端打开文件（假设存在多个 X 显示端）。</dd>
<dt>'<code>-e</code>'</dt><dd></dd>

<dt>'<code>--eval</code>'</dt><dd><p>
让 Emacs 执行一段 Emacs Lisp 代码，而不是打开文件。使用该选项时， <code>emacsclient</code> 的后续参数会被当作待执行的表达式列表，而非文件列表。
</p>

<p>
通过 <code>--eval</code> 传递复杂 Lisp 表达式有时需要对 Shell 特殊字符做繁琐转义。为避免这一点，你可以把表达式中 Lisp 函数所需的参数作为 <code>emacsclient</code> 的独立附加参数传入，并在表达式中用 <code>server-eval-args-left</code> 访问这些参数。注意：无论代码是否执行成功，你的表达式都必须从 <code>server-eval-args-left</code> 中移除已处理的参数（例如用 <code>pop</code> ），否则 Emacs 会尝试把这些参数当作独立 Lisp 表达式再次执行。
</p></dd>
<dt>'-f <i>server-file</i>'</dt><dd></dd>

<dt>'<code>--server-file=server-file</code>'</dt><dd><p>
指定用于通过 TCP 连接 Emacs 服务器的服务器文件（见 <a href="#TCP-Emacs-server">TCP 版 Emacs 服务器</a>）。你也可以设置环境变量 <code>EMACS_SERVER_FILE</code> 指向该服务器文件。（命令行选项优先级高于环境变量。）
</p>

<p>
Emacs 服务器通常使用本地套接字监听连接，但也支持 TCP 连接。要连接 TCP 版 Emacs 服务器， <code>emacsclient</code> 需要读取包含服务器连接信息的服务器文件。该文件的名称由此选项指定，可以是相对于 <code>~/.emacs.d/server</code> 的文件名，或绝对路径。
</p></dd>
<dt>'<code>-n</code>'</dt><dd></dd>

<dt>'<code>--no-wait</code>'</dt><dd>让 <code>emacsclient</code> 立即退出，而不是等待所有服务器缓冲区编辑完成。你可以在 Emacs 内任意时间编辑服务器缓冲区，并且在按 <code>C-x #</code> 时不会杀死这些缓冲区。</dd>
<dt>'<code>-w</code>'</dt><dd></dd>

<dt>'<code>--timeout=N</code>'</dt><dd>等待 Emacs 响应最多 N 秒，超时则放弃。若在指定时间内无响应， <code>emacsclient</code> 会显示警告并退出。默认值为 0，表示无限等待。</dd>
<dt>'<code>--parent-id=id</code>'</dt><dd>通过 XEmbed 协议，在指定 ID 的父 X 窗口中打开 <code>emacsclient</code> 窗口作为子窗口。目前该选项主要对开发者有用。</dd>
<dt>'<code>-q</code>'</dt><dd></dd>

<dt>'<code>--quiet</code>'</dt><dd>不显示关于等待 Emacs 或连接远程服务器套接字的提示信息。</dd>
<dt>'<code>-u</code>'</dt><dd></dd>

<dt>'<code>--suppress-output</code>'</dt><dd>不显示从服务器返回的结果。主要与 '<code>-e</code>' 配合使用，当执行表达式仅为副作用而非获取返回值时。</dd>
<dt>'-s <i>server-name</i>'</dt><dd></dd>

<dt>'<code>--socket-name=server-name</code>'</dt><dd><p>
连接到指定 <i>server-name名称</i> 的 Emacs 服务器。（MS-Windows 不支持此选项。）服务器名称由 Emacs 端的变量 <code>server-name</code> 指定。若省略此选项， <code>emacsclient</code> 连接默认套接字。如果你将 Emacs 服务器的 <code>server-name</code> 设置为绝对路径，则在此选项中传入相同绝对路径，以让 <code>emacsclient</code> 连接到对应服务器。当你以守护进程方式启动 Emacs 并指定了服务器名称时，需要使用此选项。
</p>

<p>
你也可以设置环境变量 <code>EMACS_SOCKET_NAME</code> 指向服务器套接字。（命令行选项优先级更高。）
</p></dd>
<dt>'<code>-t</code>'</dt><dd></dd>

<dt>'<code>--tty</code>'</dt><dd></dd>

<dt>'<code>-nw</code>'</dt><dd></dd>

<dt>'<code>--no-window-system</code>'</dt><dd><p>
在当前文本终端上新建客户端框架，而不是使用已有 Emacs 框架。行为与 '<code>-c</code>' 类似，区别在于它创建文本终端框架(见<a href="#Text-Terminals">文本终端</a>)。
</p>

<p>
在 MS-Windows 上，如果 Emacs 服务器使用图形显示， '<code>-t</code>' 与 '<code>-c</code>' 行为相同；如果服务器运行在文本终端上，则在当前文本终端新建框架。
</p></dd>
<dt>'-T <i>tramp-prefix</i>'</dt><dd></dd>

<dt>'<code>--tramp=tramp-prefix</code>'</dt><dd><p>
设置文件名前缀，让 Emacs 通过 TRAMP 访问远程机器上的文件（见「<a href="#Remote-Files">远程文件</a>」与 <a href="https://www.gnu.org/software/emacs/manual/html_node/tramp/index.html#Top">TRAMP 手册</a>）。这在从远程主机使用 Emacs 服务器时非常有用。通过 SSH 转发监听套接字，或 SSH 转发监听端口（参见 <a href="#TCP-Emacs-server">TCP 版 Emacs 服务器</a>），并让 <i>server-file服务器文件</i> 在远程机器上可用，远程机器上的程序就可以将 <code>EDITOR</code> 变的值设为 <code>emacsclient</code> 等，但文件并不会连接到远程机器上的 Emacs 服务器，而是会借助 TRAMP 在本地 Emacs 会话中打开。
</p>

<p>
设置环境变量 <code>EMACSCLIENT_TRAMP</code> 与 '-T' 选项效果相同，命令行选项优先。
</p>

<p>
示例（本地主机 local、远程主机 remote）：
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #483d8b;">local</span>$ ssh -R <span style="color: #8b2252;">"/home/%r/.emacs.socket"</span>:<span style="color: #8b2252;">"${XDG_RUNTIME_DIR:-${TMPDIR:-/tmp}/emacs%i}${XDG_RUNTIME_DIR:+/emacs}/server"</span> remote
remote$ export <span style="color: #a0522d;">EMACS_SOCKET_NAME</span>=$<span style="color: #a0522d;">HOME</span>/.emacs.socket
remote$ export <span style="color: #a0522d;">EMACSCLIENT_TRAMP</span>=/ssh:remote:
remote$ export <span style="color: #a0522d;">EDITOR</span>=emacsclient
remote$ $<span style="color: #a0522d;">EDITOR</span> /tmp/foo.txt <span style="color: #b22222;"># </span><span style="color: #b22222;">&#20250;&#22312;&#26412;&#22320; Emacs &#20013;&#25171;&#24320;</span>
</pre>
</div>
<p>
如果你所使用的平台中 <code>emacsclient</code> 不采用 Unix 域套接字（例如 Windows 系统），或者你的 SSH 实现不支持套接字转发（比如低于 6.7 版本的 OpenSSH），可以改用 TCP 端口转发。在本示例中，假设本地 Emacs 监听 TCP 端口 12345。进一步假设 <code>/home</code> 位于共享文件系统上，因此服务器文件 <code>~/.emacs.d/server/server</code> 在两台主机上均可读取。
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #483d8b;">local</span>$ ssh -R12345:localhost:12345 remote
remote$ export <span style="color: #a0522d;">EMACS_SERVER_FILE</span>=server
remote$ export <span style="color: #a0522d;">EMACSCLIENT_TRAMP</span>=/ssh:remote:
remote$ export <span style="color: #a0522d;">EDITOR</span>=emacsclient
remote$ $<span style="color: #a0522d;">EDITOR</span> /tmp/foo.txt <span style="color: #b22222;"># </span><span style="color: #b22222;">&#20250;&#22312;&#26412;&#22320; Emacs &#20013;&#25171;&#24320;</span>
</pre>
</div></dd>

<dt>'<code>-V</code>'</dt><dd></dd>

<dt>'<code>--version</code>'</dt><dd>打印版本信息并退出。</dd>
<dt>'<code>-H</code>'</dt><dd></dd>

<dt>'<code>--help</code>'</dt><dd>打印使用信息并退出。</dd>
</dl>

<p>
由 '<code>-c</code>' 或 '<code>-t</code>' 创建的新图形 / 文本终端窗口被视为 <i>client frames客户端框架</i> 。从客户端框架新建的任何框架也属于客户端框架。
</p>

<p>
如果你在客户端框架中按 <code>C-x C-c</code> (<code>save-buffers-kill-terminal</code>)，该命令不会像平常一样杀死整个 Emacs 会话，而是只删除当前客户端框架。此外，如果该客户端框架有 <code>emacsclient</code> 正在等待（即未使用 <code>-n</code> ），Emacs 会删除同一客户端的所有其他窗口，并将该客户端的所有服务器缓冲区标记为已完成，如同在每个缓冲区都按了 <code>C-x #</code> 。如果删除客户端框架后已无任何框架剩余，Emacs 会话才会退出。
</p>

<p>
一个例外：当 Emacs 以守护进程启动时，所有框架都被视为客户端框架， <code>C-x C-c</code> 永远不会杀死 Emacs。要关闭守护进程会话，请使用 <code>M-x kill-emacs</code> 。
</p>

<p>
注意：'<code>-t</code>' 与 '<code>-n</code>' 选项相互矛盾： '<code>-t</code> 表示接管当前文本终端并新建客户端窗口； '<code>-n</code>' 表示不接管文本终端。如果同时使用这两个选项，Emacs 会在已有窗口中打开文件，而不是新建客户端窗口，这会抵消 '<code>-t</code>' 的效果。
</p>
</div>
</div>
</section>
<section id="outline-container-Printing" class="outline-2">
<h2 id="Printing"><span class="section-number-2">42.</span> 打印硬拷贝</h2>
<div class="outline-text-2" id="text-Printing">
<p>
Emacs 提供了用于打印整个缓冲区或部分缓冲区内容的命令。你可以直接调用这些打印命令（具体说明如下），也可以通过菜单栏中的「File文件」菜单使用。
</p>

<p>
除本节介绍的命令外，你还可以在 Dired（参见<a href="#Operating-on-Files">文件操作</a>）和日程记录（参见<a href="#Displaying-the-Diary">显示日程</a>）中打印纸质副本。你也可以使用命令 <code>M-x htmlfontify-buffer</code> 将 Emacs 缓冲区 “打印” 为 HTML 格式，该命令会将当前缓冲区转换为 HTML 文件，并使用基于 CSS 的标记替代 Emacs 面（字体样式）。此外，Org 模式支持将 Org 文件打印为多种格式（例如 PDF），参见 <a href="#Org-Mode">Org 模式</a>。
</p>

<dl class="org-dl">
<dt><code>M-x print-buffer</code></dt><dd>打印当前缓冲区的纸质副本，并添加包含文件名与页码的页标题。</dd>
<dt><code>M-x lpr-buffer</code></dt><dd>打印当前缓冲区的纸质副本，不添加页标题。</dd>
<dt><code>M-x print-region</code></dt><dd>功能与 <code>print-buffer</code> 类似，但仅打印当前选中区域。</dd>
<dt><code>M-x lpr-region</code></dt><dd>功能与 <code>lpr-buffer</code> 类似，但仅打印当前选中区域。</dd>
</dl>

<p>
在大多数操作系统中，上述打印命令会通过调用 <code>lpr</code> 程序提交打印任务。若要更换打印程序，可以自定义变量 <code>lpr-command</code> 。若要为打印程序指定额外参数，可以自定义列表变量 <code>lpr-switches</code> ，其值应为一组选项字符串，每个字符串以 '-' 开头（例如字符串 '-w80' 表示设置行宽为 80 列），默认值为空列表 <code>nil</code> 。
</p>

<p>
若要指定使用的打印机，可以设置变量 <code>printer-name</code> 。默认值 <code>nil</code> 表示使用系统默认打印机；将其设为打印机名称（字符串）后，该名称会通过 '-P' 参数传递给 <code>lpr</code> 。如果你不使用 <code>lpr</code> ，则应通过 <code>lpr-printer-switch</code> 指定对应的参数。
</p>

<p>
变量 <code>lpr-headers-switches</code> 同样用于指定生成页标题时的额外参数。变量 <code>lpr-add-switches</code> 用于控制是否向打印程序提供 '-T ' 和 '-J' 选项（适用于 <code>lpr</code> ）：设为 <code>nil</code> 表示不添加这些选项（如果你的打印程序与 <code>lpr</code> 不兼容，应使用该值）。
</p>

<ul class="org-ul">
<li><a href="#PostScript">PostScript 纸质打开</a></li>
<li><a href="#PostScript-Variables">PostScript 纸质打开相关变量</a></li>
<li><a href="#Printing-Package">打印功能包</a></li>
</ul>
</div>
<div id="outline-container-PostScript" class="outline-3">
<h3 id="PostScript"><span class="section-number-3">42.1.</span> PostScript 纸质打开</h3>
<div class="outline-text-3" id="text-PostScript">
<p>
这些命令将缓冲区内容转换为 PostScript 格式，既可直接打印，也可输出到另一个 Emacs 缓冲区。
</p>
<dl class="org-dl">
<dt><code>M-x ps-print-buffer</code></dt><dd>以 PostScript 格式打印当前缓冲区。</dd>
<dt><code>M-x ps-print-region</code></dt><dd>以 PostScript 格式打印当前选中区域。</dd>
<dt><code>M-x ps-print-buffer-with-faces</code></dt><dd>以 PostScript 格式打印当前缓冲区，并利用 PostScript 特性显示文本所使用的面（字体、颜色等样式）。</dd>
<dt><code>M-x ps-print-region-with-faces</code></dt><dd>以 PostScript 格式打印当前选中区域，并显示文本所使用的样式。</dd>
<dt><code>M-x ps-spool-buffer</code></dt><dd>为当前缓冲区生成并暂存 PostScript 图像。</dd>
<dt><code>M-x ps-spool-region</code></dt><dd>为当前选中区域生成并暂存 PostScript 图像。</dd>
<dt><code>M-x ps-spool-buffer-with-faces</code></dt><dd>为当前缓冲区生成并暂存 PostScript 图像，同时显示所使用的样式。</dd>
<dt><code>M-x ps-spool-region-with-faces</code></dt><dd>为当前选中区域生成并暂存 PostScript 图像，同时显示所使用的样式。</dd>
<dt><code>M-x ps-despool</code></dt><dd>将暂存的 PostScript 内容发送到打印机。</dd>
<dt><code>M-x handwrite</code></dt><dd>为当前缓冲区生成 / 打印手写风格的 PostScript 效果。</dd>
</dl>

<p>
<code>ps-print-buffer</code> 和 <code>ps-print-region</code> 命令以 PostScript 格式打印缓冲区内容，一个打印整个缓冲区，另一个只打印选中区域。~ps-print-buffer-with-faces~ 和 <code>ps-print-region-with-faces</code> 命令作用类似，但会利用 PostScript 特性显示缓冲区文本的外观（字体与颜色）。
</p>

<p>
交互使用时，若带上前缀参数（ <code>C‑u</code> ），这些命令会提示输入文件名，并将 PostScript 图像保存到该文件，而不是发送到打印机。
</p>

<p>
名称中包含 'spool' （暂存）而非 'print' （打印）的命令，会在 Emacs 缓冲区中生成 PostScript 输出，而不是直接发送到打印机。
</p>

<p>
使用命令 <code>ps-despool</code> 可将暂存的图像发送到打印机。该命令会把由 '‑spool‑' 系列命令生成的 PostScript 内容发送至打印机；若带上前缀参数（ <code>C‑u</code> ），则会提示输入文件名，并将暂存的 PostScript 图像保存到文件，而非发送到打印机。
</p>

<p>
<code>M-x handwrite</code> 更偏向趣味用途。它会将当前缓冲区生成类似手写草书的 PostScript 效果，可在 <code>handwrite</code> 组中进行自定义。该函数仅支持 ISO 8859‑1 字符。
</p>
</div>
</div>
<div id="outline-container-PostScript-Variables" class="outline-3">
<h3 id="PostScript-Variables"><span class="section-number-3">42.2.</span> PostScript 纸质打开相关变量</h3>
<div class="outline-text-3" id="text-PostScript-Variables">
<p>
所有 PostScript 打印命令都使用变量 <code>ps-lpr-command</code> 和 <code>ps-lpr-switches</code> 来指定输出方式。 <code>ps-lpr-command</code> 用于指定要运行的命令名称， <code>ps-lpr-switches</code> 用于指定命令行参数， <code>ps-printer-name</code> 用于指定打印机。如果你没有手动设置前两个变量，它们会从 <code>lpr-command</code> 和 <code>lpr-switches</code> 继承初始值。如果 <code>ps-printer-name</code> 为 <code>nil</code> ，则使用 <code>printer-name</code> 。
</p>

<p>
变量 <code>ps-print-header</code> 控制这些命令是否为每页添加页眉行：将其设为 <code>nil</code> 即可关闭页眉。
</p>

<p>
如果你的打印机不支持彩色，应将 <code>ps-print-color-p</code> 设为 <code>nil</code> 以关闭彩色处理。默认情况下，如果显示器支持彩色，Emacs 会生成带色彩信息的打印输出；在黑白打印机上，颜色会用灰度级模拟。即使屏幕颜色只使用灰度，这也可能导致输出难以阅读甚至无法辨认。
</p>

<p>
你也可以将 <code>ps-print-color-p</code> 设置为 <code>black-white</code> ，让颜色在黑白打印机上显示效果更好。其原理是利用 <code>ps-black-white-faces</code> 中的信息，通过可自定义的灰度列表，并结合粗体、斜体等样式属性来表现颜色。
</p>

<p>
默认情况下，PostScript 打印会忽略样式（face）的背景色，除非变量 <code>ps-use-face-background</code> 不为 <code>nil</code> 。这样做是为了避免与斑马条纹、背景图片或文字产生不必要的干扰。
</p>

<p>
变量 <code>ps-paper-type</code> 指定要使用的纸张尺寸；合法值包括：a4、a3、a4small、b4、b5、executive、ledger、legal、letter、letter-small、statement、tabloid。默认为 letter。你可以通过修改变量 <code>ps-page-dimensions-database</code> 定义更多纸张尺寸。
</p>

<p>
变量 <code>ps-landscape-mode</code> 指定页面打印方向。默认值为 <code>nil</code> ，表示纵向（portrait）；任何非 nil 值都表示横向（landscape）。
</p>

<p>
变量 <code>ps-number-of-columns</code> 指定打印的列数，在横向和纵向模式下均生效。默认为 1。
</p>

<p>
变量 <code>ps-font-family</code> 指定打印普通文本所使用的字体族。合法值包括：Courier、Helvetica、NewCenturySchlbk、Palatino 和 Times。变量 <code>ps-font-size</code> 指定普通文本的字号，默认为 8.5 磅。 <code>ps-font-size</code> 的值也可以是两个浮点数组成的 cons 对：一个用于横向模式，另一个用于纵向模式。
</p>

<p>
Emacs 支持的文字书写体系与字符，比普通的 PostScript 打印机更为丰富。因此，缓冲区中的部分字符，可能无法使用打印机内置字体正常打印。你可以用 GNU Intlfonts 字体包 来补充打印机自带的字体，也可以让 Emacs 只使用 Intlfonts 字体。变量 <code>ps-multibyte-buffer</code> 用于控制这一行为：
</p>
<ul class="org-ul">
<li>默认值 <code>nil</code> ：适合打印 ASCII 和 Latin‑1 字符；</li>
<li>值为 <code>non‑latin‑printer</code> ：适用于内置了 ASCII、Latin‑1、日文和韩文字体的打印机；</li>
<li>值为 <code>bdf‑font</code> ：对所有字符统一使用 Intlfonts 字体包中的 BDF 字体；</li>
<li>值为 <code>bdf‑font‑except‑latin</code> ：对 ASCII 和 Latin‑1 字符使用打印机内置字体，其余字符使用 Intlfonts 的 BDF 字体。</li>
</ul>

<p>
要使用 BDF 字体，Emacs 需要知道字体的存放位置。变量 <code>bdf-directory-list</code> 用于保存 Emacs 搜索字体的目录列表；其默认值只包含一个目录： <code>/usr/local/share/emacs/fonts/bdf</code> 。
</p>

<p>
这些命令的许多其他自定义变量，都在 Lisp 文件 <code>ps-print.el</code> 和 <code>ps-mule.el</code> 中定义并说明。
</p>
</div>
</div>
<div id="outline-container-Printing-Package" class="outline-3">
<h3 id="Printing-Package"><span class="section-number-3">42.3.</span> 打印功能包</h3>
<div class="outline-text-3" id="text-Printing-Package">
<p>
Emacs 基础的纸质打印功能可以通过 Printing 包 进行扩展。该包提供了易用的界面，用于选择打印内容、在打印前预览 PostScript 文件，以及设置各类打印选项，例如打印页眉、横向 / 纵向模式、双面打印模式等。在 GNU/Linux 或 Unix 系统中，Printing 包依赖 <code>gs</code> 和 <code>gv</code> 工具，这两个工具随 <code>GhostScript</code> 程序一同发布。在 MS-Windows 系统中，可以使用 Ghostscript 的 <code>gstools</code> 移植版。
</p>

<p>
<b>使用方法</b>
</p>

<p>
要使用 Printing 包，需在你的初始化文件（参见《<a href="#Init-File">Emacs 初始化文件</a>》）中添加：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">require</span> '<span style="color: #008b8b;">printing</span>)
(pr-update-menus)
</pre>
</div>

<p>
<code>pr-update-menus</code> 函数会将菜单栏中默认的打印命令替换为包含多种打印选项的 'Printing' 子菜单。
</p>

<p>
你也可以执行命令： <code>M-x pr-interface RET</code> 该命令会创建一个名为 <code>*Printing Interface*</code> 的缓冲区（类似自定义设置缓冲区），在其中可以配置打印选项。选定打印内容与方式后，点击 Print 按钮即可启动打印任务（点击 <code>mouse-2</code> 鼠标中键，或将光标移至按钮上按 <code>RET</code> 回车）。如需了解更多选项的详细说明，可使用 'Interface Help' 按钮。
</p>
</div>
</div>
</section>
<section id="outline-container-Sorting" class="outline-2">
<h2 id="Sorting"><span class="section-number-2">43.</span> 文本排序</h2>
<div class="outline-text-2" id="text-Sorting">
<p>
Emacs 提供多条用于对缓冲区中文本进行排序的命令。所有命令均作用于区域（region）内的内容。它们会将区域内的文本划分成多条 <i>sort records排序记录</i> ，为每条记录确定一个 <i>sort key排序键</i> ，然后按照排序键决定的顺序重新排列这些记录。记录会按其键的字母顺序排列；若为数值排序，则按数值顺序排列。在字母排序中，按照 ASCII 字符序列，所有大写字母「A」到「Z」排在小写字母「a」之前（不过下文介绍的 <code>sort-fold-case</code> 可以改变这一行为）。
</p>

<p>
各种排序命令的区别在于，它们 <b>如何将文本划分成排序记录</b> ，以及 <b>使用每条记录的哪一部分作为排序键</b> 。大多数命令会把 <b>每一行</b> 当作一条独立的排序记录，但也有一些命令以 <b>段落</b> 或 <b>页</b> 作为排序记录。大多数排序命令会把 <b>整条排序记录</b> 本身作为排序键，但也有一些命令只使用记录的一 <b>部分</b> 作为排序键。
</p>

<dl class="org-dl">
<dt><code>M-x sort-lines</code></dt><dd>将区域按行划分，并通过比较整行文本进行排序。传入数值前缀参数表示按降序排序。</dd>
<dt><code>M-x sort-paragraphs</code></dt><dd>将区域按段落划分，并通过比较整个段落（忽略开头空行）进行排序。传入数值前缀参数表示按降序排序。</dd>
<dt><code>M-x sort-pages</code></dt><dd>将区域按页划分，并通过比较整页文本（忽略开头空行）进行排序。传入数值前缀参数表示按降序排序。</dd>
<dt><code>M-x sort-fields</code></dt><dd><p>
将区域按行划分，并通过比较每行中的某个字段进行排序。字段由空白字符分隔：一行中第一组连续的非空白字符为字段 1，第二组为字段 2，依此类推。
</p>

<p>
使用数值前缀参数指定按第几个字段排序：1 表示按第 1 个字段，以此类推；默认为 1。负数参数表示从右往左数字段：例如 -1 表示按最后一个字段排序。如果多行在用于排序的字段内容相同，它们会保持在原缓冲区中的相对顺序。
</p></dd>
<dt><code>M-x sort-numeric-fields</code></dt><dd>用法与 <code>M-x sort-fields</code> 类似，区别在于：会将指定字段转换为整数后再比较。作为文本时， '10' 排在 '2' 前面；作为数字时， '10' 排在 '2' 后面。默认情况下，数字按 <code>sort-numeric-base</code> 解释；以 '0x' 开头的数字会被解释为十六进制，以 '0' 开头的数字会被解释为八进制。</dd>
<dt><code>M-x sort-columns</code></dt><dd>用法与 <code>M-x sort-fields</code> 类似，区别在于：用于比较的文本来自每行中固定的列范围。带前缀参数时按逆序排序。此命令的更多细节见下文。</dd>
<dt><code>M-x reverse-region</code></dt><dd>将区域内的行顺序反转。这在需要按字段降序排序时很有用，因为相关排序命令本身不直接支持该功能。</dd>
</dl>

<p>
示例，如果缓冲区包含如下内容：
</p>

<div class="org-src-container">
<pre class="src src-org">On systems where clash detection (locking of files being edited) is
implemented, Emacs also checks the first time you modify a buffer
whether the file has changed on disk since it was last visited or
saved.  If it has, you are asked to confirm that you want to change
the buffer.
</pre>
</div>

<p>
对整个缓冲区执行 <code>M-x sort-lines</code> 后结果如下：
</p>
<div class="org-src-container">
<pre class="src src-org">On systems where clash detection (locking of files being edited) is
implemented, Emacs also checks the first time you modify a buffer
saved.  If it has, you are asked to confirm that you want to change
the buffer.
whether the file has changed on disk since it was last visited or
</pre>
</div>

<p>
可以看到大写字母 'O' 排在所有小写字母之前。如果改用 <code>C-u 2 M-x sort-fields</code> ，结果如下：
</p>

<div class="org-src-container">
<pre class="src src-org">implemented, Emacs also checks the first time you modify a buffer
saved.  If it has, you are asked to confirm that you want to change
the buffer.
On systems where clash detection (locking of files being edited) is
whether the file has changed on disk since it was last visited or
</pre>
</div>

<p>
此时排序键分别为：Emacs、If、buffer、systems 和 the。
</p>

<p>
<code>M-x sort-columns</code> 需要更多解释。你可以将光标置于某一列，标记置于另一列，以此指定列范围。由于这意味着你无法将光标或标记放在待排序文本首行的开头，该命令对「region区域」采用了特殊定义：光标所在行、标记所在行，以及二者之间的所有行，都被视为区域的一部分。
</p>

<p>
例如，要按第 10–15 列的内容对一个表格排序：可以将标记放在表格首行的第 10 列，光标放在表格末行的第 15 列，然后执行 <code>sort-columns</code> 。反之，标记放在首行第 15 列、光标放在末行第 10 列也可以。
</p>

<p>
可以将其理解为：对光标与标记围成的 <b>矩形区域排序</b> ，不同之处在于：矩形左侧和右侧的文本会随矩形内的文本一起移动。详见「<a href="#Rectangles">矩形操作</a>（Rectangles）」。
</p>

<p>
如果 <code>sort-fold-case</code> 不为 <code>nil</code> ，多数排序命令在比较时会忽略大小写差异。
</p>
</div>
</section>
<section id="outline-container-Picture-Mode" class="outline-2">
<h2 id="Picture-Mode"><span class="section-number-2">44.</span> 图片编辑</h2>
<div class="outline-text-2" id="text-Picture-Mode">
<p>
要编辑由文本字符构成的图片（例如，以注释形式出现在程序中、将寄存器划分为多个字段的示意图），可使用命令 <code>M-x picture-mode</code> 进入图片模式（Picture mode）。
</p>

<p>
在图片模式中，编辑基于文本的 <b><i>quarter-plane model 四分之一平面模型</i></b> ：文本字符分布在向右、向下无限延伸的区域中。该模型中不存在 “行尾” 的概念，最多只能确定行中最后一个非空白字符的位置。
</p>

<p>
当然，Emacs 本质上始终将文本视为字符序列，行也确实存在行尾。但图片模式会用变体命令替换最常用的编辑命令，以此模拟四分之一平面模型。这些变体通过插入空格或将制表符转换为空格来实现效果。
</p>

<p>
图片模式重新定义了 Emacs 大部分基础编辑命令，使其功能基本不变，但按照四分之一平面模型的方式工作。此外，图片模式还定义了一系列以 <code>C-c</code> 开头的按键，用于执行专用的图片编辑命令。
</p>

<p>
其中 <code>C-c C-c</code> 尤为重要。图片通常是某个文件的一部分，而该文件一般在其他主模式下编辑。图片模式会记录之前的主模式名称，之后你可以用 <code>C-c C-c</code> 命令 (<code>picture-mode-exit</code>) 返回原模式。 <code>C-c C-c</code> 还会删除行尾空格，除非提供数值前缀参数。
</p>

<p>
图片模式的专用命令在其他模式中同样可用（前提是已加载 <code>picture</code> 库），但仅在图片模式下绑定了按键。下面的说明会提到 “移动一列” 等操作，但所有图片模式命令对数值参数的处理方式与普通命令一致。
</p>

<p>
开启图片模式时会运行钩子 <code>picture-mode-hook</code> 。图片模式的更多扩展功能可在 <code>artist.el</code> 中找到。
</p>

<ul class="org-ul">
<li><a href="#Basic-Picture">图片模式基本编辑</a></li>
<li><a href="#Insert-in-Picture">插入后移动控制</a></li>
<li><a href="#Tabs-in-Picture">图片模式制表符</a></li>
<li><a href="#Rectangles-in-Picture">图片模式矩形命令</a></li>
</ul>
</div>
<div id="outline-container-Basic-Picture" class="outline-3">
<h3 id="Basic-Picture"><span class="section-number-3">44.1.</span> 图片模式基本编辑</h3>
<div class="outline-text-3" id="text-Basic-Picture">
<p>
在图片模式中，大部分按键功能与常规模式一致，但采用四象限平面的操作逻辑。例如， <code>C-f</code> 被重新绑定为 <code>picture-forward-column</code> 命令，将光标向右移动一列，必要时插入空格，确保不受行尾实际位置影响。 <code>C-b</code> 被重新绑定为 <code>picture-backward-column</code> ，始终将光标左移一列，必要时将制表符转换为多个空格。 <code>C-n</code> 和 <code>C-p</code> 分别被绑定为 <code>picture-move-down</code> 和 <code>picture-move-up</code> ，会自动插入空格或转换制表符，保证光标严格停在同一列。 <code>C-e</code> 执行 <code>picture-end-of-line</code> ，移动到行内最后一个非空白字符之后。 <code>C-a</code> 执行 <code>picture-beginning-of-line</code> 。（屏幕模式的选择不影响行首定位；该命令唯一额外作用是将当前图片列位置重置为 0。）
</p>

<p>
文本插入会通过 <b>Overwrite mode覆盖模式</b> 适配四象限屏幕模型（详见<a href="#Minor-Modes">次要模式</a>）。自插入字符会逐列覆盖已有文本，而非将文本向右挤开。 <code>RET</code> 执行 <code>picture-newline</code> ，仅跳至下一行行首，使新输入内容覆盖该行。
</p>

<p>
在图片模式中，原本用于删除或剪切文本的命令，会改为 <b>erase擦除</b> 文本（用空格替代）。
</p>
<ul class="org-ul">
<li><code>DEL</code> (<code>picture-backward-clear-column</code>)：用空格替换前一个字符，而非删除，光标同时左移。</li>
<li><code>C-d</code> (<code>picture-clear-column</code>)：用空格替换后续一个或多个字符，但光标不移动。（若想擦除为空格并跳过这些字符，可使用空格 <code>SPC</code> 。）</li>
<li><code>C-k</code> (<code>picture-clear-line</code>)：会真正清除行内容，但不会删除缓冲区中的换行符。</li>
</ul>

<p>
若要执行 <b>真正的插入操作</b> ，需使用专用命令：
</p>
<ul class="org-ul">
<li><code>C-o</code> (<code>picture-open-line</code>)：在当前行下方新建空白行，不会拆分现有行。</li>
<li><code>C-M-o</code> (<code>split-line</code>)：在图片模式中保持原有含义，未被修改。</li>
<li><code>C-j</code> (<code>picture-duplicate-line</code>)：在当前行下方插入一行内容相同的副本。</li>
</ul>

<p>
若要在图片模式中真正删除文本，可使用： <code>C-w</code> 、 <code>C-c C-d</code> （功能同普通模式下的 <code>C-d</code> ，即  <code>delete-char</code> ），或图片模式矩形操作命令（详见<a href="#Rectangles-in-Picture">图片模式矩形命令</a>）。
</p>
</div>
</div>
<div id="outline-container-Insert-in-Picture" class="outline-3">
<h3 id="Insert-in-Picture"><span class="section-number-3">44.2.</span> 插入后移动控制</h3>
<div class="outline-text-3" id="text-Insert-in-Picture">
<p>
由于图片模式下输入字符会覆盖原有内容并移动光标，因此对光标移动方式没有本质限制。默认情况下光标向右移动，但你可以为输入字符后指定8个方向（水平、垂直与对角线）的移动规则。这在缓冲区中绘制线条时非常实用。
</p>

<p>
<b>方向控制快捷键</b>
</p>
<dl class="org-dl">
<dt><code>C-c &lt;</code></dt><dd></dd>

<dt><code>C-c LEFT</code></dt><dd>插入后向左移动 (<code>picture-movement-left</code>)。</dd>
<dt><code>C-c &gt;</code></dt><dd></dd>

<dt><code>C-c RIGHT</code></dt><dd>插入后向右移动 (<code>picture-movement-right</code>)。</dd>
<dt><code>C-c ^</code></dt><dd></dd>

<dt><code>C-c UP</code></dt><dd>插入后向上移动 (<code>picture-movement-up</code>)。</dd>
<dt><code>C-c .</code></dt><dd></dd>

<dt><code>C-c DOWN</code></dt><dd>插入后向下移动 (<code>picture-movement-down</code>)。</dd>
<dt><code>C-c `</code></dt><dd></dd>

<dt><code>C-c Home</code></dt><dd>插入后向左上方移动（西北方向， <code>picture-movement-nw</code> ）。</dd>
<dt><code>C-c '</code></dt><dd></dd>

<dt><code>C-c PageUp</code></dt><dd></dd>

<dt><code>C-c prior</code></dt><dd>插入后向右上方移动（东北方向， <code>picture-movement-ne</code> ）。</dd>
<dt><code>C-c /</code></dt><dd></dd>

<dt><code>C-c End</code></dt><dd>插入后向左下方移动（西南方向， <code>picture-movement-sw</code> ）。</dd>
<dt><code>C-c \</code></dt><dd></dd>

<dt><code>C-c PageDown</code></dt><dd></dd>

<dt><code>C-c next</code></dt><dd>插入后向右下方移动（东南方向， <code>picture-movement-se</code> ）。</dd>
</dl>

<p>
<b>相对方向移动</b>
</p>

<p>
有两个命令会根据当前设定的插入方向来移动光标：
</p>
<ul class="org-ul">
<li><code>C-c C-f</code> (<code>picture-motion</code>)：向当前设定的插入方向移动。</li>
<li><code>C-c C-b</code> (<code>picture-motion-reverse</code>)：向当前设定方向的反方向移动。</li>
</ul>
</div>
</div>
<div id="outline-container-Tabs-in-Picture" class="outline-3">
<h3 id="Tabs-in-Picture"><span class="section-number-3">44.3.</span> 图片模式制表符</h3>
<div class="outline-text-3" id="text-Tabs-in-Picture">
<p>
图片模式提供两种类制表符的操作方式。
</p>

<p>
使用 <code>M-TAB</code> (<code>picture-tab-search</code>) 进行 <b>基于上下文的跳格</b> 。
</p>
<ul class="org-ul">
<li>不带参数时：光标跳至上一个非空行中，位于当前光标右侧、下一个 “有效字符” 的正下方。
这里的 “下一个” 指 <b>水平位置大于当前光标起始位置</b> 。</li>
<li>带前缀参数（如 <code>C-u M-TAB</code> ）时：跳至当前行中下一个这样的 “有效字符” 处。</li>
</ul>

<p>
<code>M-TAB</code> 不会修改文本，仅移动光标。“有效字符” 由变量 <code>picture-tab-chars</code> 定义，该变量用于指定一组字符。其语法与正则表达式中 '<code>[…]</code>' 内部的语法一致，但不包含方括号 '<code>[</code>' 和 '<code>]</code>' 。默认值为 <code>"!-~"</code> （表示所有可打印 ASCII 字符）。
</p>

<p>
<code>TAB</code> 键本身执行 <code>picture-tab</code> ，基于 <b>当前制表位设置</b> 工作，相当于图片模式版的 <code>tab-to-tab-stop</code> 。
</p>
<ul class="org-ul">
<li>通常仅移动光标；</li>
<li>若带数字参数，则会清空移动路径上的文本。</li>
</ul>

<p>
<code>C-c TAB</code> (<code>picture-set-tab-stops</code>) 将上下文跳格与制表位跳格结合起来。该命令会把当前行中 <code>M-TAB</code> 识别为有效字符的位置，设为制表位。配合 <code>TAB</code> 使用，可达到基于上下文跳格的效果；但在适用场景下，直接用 <code>M-TAB</code> 更方便。
</p>

<p>
为避免图片中出现真实制表符导致错乱（例如防止 <code>C-x TAB</code> 破坏画面），可以将变量 <code>indent-tabs-mode</code> 设为 <code>nil</code> 。
</p>
</div>
</div>
<div id="outline-container-Rectangles-in-Picture" class="outline-3">
<h3 id="Rectangles-in-Picture"><span class="section-number-3">44.4.</span> 图片模式矩形命令</h3>
<div class="outline-text-3" id="text-Rectangles-in-Picture">
<p>
图片模式定义了一批针对文本矩形区域操作的命令，其行为符合四象限平面模型。标准的矩形命令同样可以使用，详见 “<a href="#Rectangles">矩形操作</a>”（Rectangles）章节。
</p>

<p>
<b>命令一览</b>
</p>

<dl class="org-dl">
<dt><code>C-c C-k</code></dt><dd>用空格清空选中的矩形区域 (<code>picture-clear-rectangle</code>)。带前缀参数时，则直接删除该区域文本。</dd>
<dt><code>C-c C-w r</code></dt><dd>功能类似，但会先将矩形内容保存到寄存器 <i>r</i> 中 (<code>picture-clear-rectangle-to-register</code>)。详见 “<a href="#Registers">寄存器</a>”（Registers）章节。</dd>
<dt><code>C-c C-y</code></dt><dd>将上一次删除的矩形以覆盖方式粘贴到缓冲区，左上角对齐当前光标 (<code>picture-yank-rectangle</code>)。带参数时，则改为插入而非覆盖。</dd>
<dt><code>C-c C-x r</code></dt><dd>功能类似，但使用寄存器 <i>r</i> 中保存的矩形 (<code>picture-yank-rectangle-from-register</code>)。</dd>
</dl>

<p>
<b>与标准矩形命令的区别</b>
</p>

<p>
图片模式的矩形命令 <code>C-c C-k</code> (<code>picture-clear-rectangle</code>) 和 <code>C-c C-w</code> (<code>picture-clear-rectangle-to-register</code>) 与标准矩形命令不同：它们 <b>默认清空矩形（用空格填充）</b> ，而不是直接删除；这与图片模式中 <code>C-d</code> 的修改逻辑类似。
</p>

<p>
不过，在图片模式中有时也需要真正删除矩形，因此这些命令在带数字参数时会执行删除操作。无论是否带参数， <code>C-c C-k</code> 都会保存矩形内容，供 <code>C-c C-y</code> 使用。
</p>

<p>
图片模式的矩形粘贴命令与标准命令的区别：它们默认 <b>覆盖</b> 而非插入。这和图片模式中其他文本的插入逻辑一致。 <code>C-c C-y</code> (<code>picture-yank-rectangle</code>) 粘贴最近删除的矩形（以覆盖方式）， <code>C-c C-x</code> (<code>picture-yank-rectangle-from-register</code>) 则对指定寄存器中的矩形做同样操作。
</p>
</div>
</div>
</section>
<section id="outline-container-Editing-Binary-Files" class="outline-2">
<h2 id="Editing-Binary-Files"><span class="section-number-2">45.</span> 二进制文件编辑</h2>
<div class="outline-text-2" id="text-Editing-Binary-Files">
<p>
Emacs 提供一个用于编辑二进制文件的专用主模式：Hexl mode。使用方法：用 <code>M-x hexl-find-file</code> 代替 <code>C-x C-f</code> 打开文件。该命令会将文件内容转换成十六进制形式供你编辑；保存文件时，会自动转换回二进制。
</p>

<p>
你也可以使用 <code>M-x hexl-mode</code> 将当前已打开的缓冲区转换成十六进制格式。如果你先用普通方式打开文件，之后才发现它是二进制文件，这个功能就会很方便。
</p>

<p>
在 Hexl 模式下，插入文本始终是覆盖模式，目的是降低意外破坏文件数据对齐的风险。普通文本字符会直接覆盖自身（即用相同字符覆盖）。另有一些命令可通过编码插入特殊字符。大多数光标移动键以及 <code>C-x C-s</code> 在 Hexl 模式下效果与普通模式一致。下面列出 Hexl 模式其他重要的专用命令：
</p>

<dl class="org-dl">
<dt><code>C-M-d</code></dt><dd>输入十进制编码，插入一个字节。</dd>
<dt><code>C-M-o</code></dt><dd>输入八进制编码，插入一个字节。</dd>
<dt><code>C-M-x</code></dt><dd>输入十六进制编码，插入一个字节。</dd>
<dt><code>C-M-a</code></dt><dd>跳转到 512 字节页的起始位置。</dd>
<dt><code>C-M-e</code></dt><dd>跳转到 512 字节页的末尾。</dd>
<dt><code>C-x [</code></dt><dd>跳转到 1K 字节页的起始位置。</dd>
<dt><code>C-x ]</code></dt><dd>跳转到 1K 字节页的末尾。</dd>
<dt><code>M-g</code></dt><dd>跳转到十六进制指定的地址。</dd>
<dt><code>M-j</code></dt><dd>跳转到十进制指定的地址。</dd>
<dt><code>C-c C-c</code></dt><dd>退出 Hexl 模式，回到进入该模式之前缓冲区所在的主模式。</dd>
</dl>

<p>
其他 Hexl 命令还支持插入二进制字节串、按短整型 / 整型移动等；输入 <code>C-h a hexl- TAB</code> 可查看详情。
</p>

<p>
Hexl 模式也可用于编辑文本文件。当文本文件包含特殊字符或使用不常见编码时（见<a href="#Coding-Systems">编码系统</a>），这会很方便。为此，Hexl 中插入字节的命令同样可插入 ASCII 与非 ASCII 字符（包括多字节字符）。要用 Hexl 编辑文本文件，先正常打开文件，再执行 <code>M-x hexl-mode RET</code> 切换模式即可。之后你可以直接输入文本字符。但插入 <b>多字节字符</b> 需要特别小心，避免生成非法多字节序列：应当在光标位于文件中多字节序列的第一个字节时开始输入。
</p>
</div>
</section>
<section id="outline-container-Saving-Emacs-Sessions" class="outline-2">
<h2 id="Saving-Emacs-Sessions"><span class="section-number-2">46.</span> 保存 Emacs 会话</h2>
<div class="outline-text-2" id="text-Saving-Emacs-Sessions">
<p>
你可以使用 desktop 库在不同会话之间保存 Emacs 的状态。保存的 Emacs <i>desktop configuration 桌面配置</i> 包括：缓冲区、对应的文件名、主模式、缓冲区位置、窗口与框架配置，以及一些重要的全局变量。
</p>

<p>
要启用该功能，可以通过自定义缓冲区（参见<a href="#Easy-Customization">简易自定义界面</a>）将 <code>desktop-save-mode</code> 设置为 <code>t</code> ，以便在后续会话中生效；或者在你的初始化文件（参见 <a href="#Init-File">Emacs 初始化文件</a>）中添加这一行：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(desktop-save-mode 1)
</pre>
</div>

<p>
如果你在初始化文件中开启了 <code>desktop-save-mode</code> ，那么 Emacs 启动时会在 <code>desktop-path</code> （默认为用户 Emacs 目录，然后是家目录）中查找已保存的桌面，并使用找到的第一个桌面。当 Emacs 在开启 <code>desktop-save-mode</code> 的状态下运行时，默认会在桌面配置发生变化时自动保存桌面。变量 <code>desktop-auto-save-timeout</code> 决定 Emacs 检查桌面修改的频率。当你退出 Emacs 时，桌面也会被保存。
</p>

<p>
如果你不希望 Emacs 加载任何已保存的桌面配置，可以在命令行启动时指定选项 '<code>--no-desktop</code>' 。这会在当前会话中关闭 <code>desktop-save-mode</code> 。使用 '<code>--no-init-file</code>' 选项启动 Emacs 同样会禁止加载桌面，因为它会跳过通常用来开启 <code>desktop-save-mode</code> 的初始化文件。
</p>

<p>
你可以在 <b>不同目录</b> 下保存各自独立的桌面配置；只要将 <code>desktop-path</code> 自定义为把 <code>.</code> （当前目录）放在其他目录前面，那么从存有桌面配置的目录启动 Emacs，就会恢复对应目录的桌面。你可以使用 <code>M-x desktop-change-dir</code> 保存当前桌面，并重新加载另一个目录下保存的桌面。输入 <code>M-x desktop-revert</code> 可回到上一次加载的桌面。
</p>

<p>
Emacs 保存桌面的文件在会话运行期间会被 <b>加锁</b> ，避免被另一个 Emacs 会话意外覆盖。正常退出 Emacs 时该锁会被移除，但如果 Emacs 或系统崩溃，锁文件会保留。重启 Emacs 时，默认会询问你是否使用这个被锁定的桌面文件。你可以通过自定义变量 <code>desktop-load-locked-desktop</code> 来避免这个询问：
</p>
<ul class="org-ul">
<li>设置为 <code>nil</code> ：表示这种情况下永远不加载桌面</li>
<li>设置为 <code>t</code> ：表示不询问直接加载</li>
<li>你也可以将其设为特殊值 <code>check-pid</code> ：表示只有当锁定该桌面的 Emacs 进程不在本机运行时才加载。在多用户环境中（例如家目录通过 NFS 等远程挂载），锁定的 Emacs 可能仍在另一台机器运行，这种情况下 <b>不建议</b> 使用 <code>check-pid</code> 。</li>
</ul>

<p>
当 Emacs 以守护进程（daemon）模式启动时，无法向你提问，因此如果发现桌面文件被锁定，将不会加载，除非 <code>desktop-load-locked-desktop</code> 设为 <code>t</code> 。注意：在守护进程模式下恢复桌面还存在其他问题：例如守护进程无法使用图形界面功能，因此框架位置、大小、装饰等参数无法恢复。出于这个原因，你可能希望将守护进程下的桌面恢复延迟到 <b>第一个客户端连接时</b> 再执行：可以在 <code>server-after-make-frame-hook</code> 钩子中添加一个函数(见<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Frames.html#Creating-Frames">Creating Frames</a>)，调用 <code>desktop-read</code> （见下文）。
</p>

<p>
你可以随时使用命令 <code>M-x desktop-save</code> 强制立即保存当前桌面。这在以下情况很有用：
</p>
<ul class="org-ul">
<li>你不想使用自动恢复，因此没有开启 <code>desktop-save-mode</code></li>
<li>或你对桌面做了大量修改，希望确保在 Emacs 或系统崩溃时配置不会丢失</li>
</ul>

<p>
如果当前 Emacs 会话尚未加载任何桌面，可以使用 <code>M-x desktop-read</code> 恢复之前保存的桌面。
</p>

<p>
默认情况下，桌面会尝试保存并恢复 <b>框架与窗口配置</b> 。要禁用此功能，将 <code>desktop-restore-frames</code> 设置为 <code>nil</code> 。（可查看该变量的文档，了解相关选项以精细调整行为。）
</p>

<p>
当桌面恢复框架和窗口配置时，它会使用已记录的框架参数值， <b>忽略</b> 你在初始化文件（参见《<a href="#Init-File">Emacs 初始化文件</a>》）中对这些参数的任何设置。这意味着，恢复后的框架所使用的字体、外观等参数，将来自你上一次退出 Emacs 会话时保存在桌面文件里的数据；初始化文件中对这些参数的配置会被忽略。若要禁用此行为，可以自定义变量 <code>frameset-filter-alist</code> ，过滤掉你不希望被恢复的框架参数；之后这些参数就会按照你在初始化文件中的自定义设置来生效。
</p>

<p>
默认 <b>不保存</b> 访问远程文件的缓冲区信息。如需改变这一行为，可自定义变量 <code>desktop-files-not-to-save</code> 。这种情况下，你可能还需要自定义 <code>remote-file-name-access-timeout</code> ，它表示停止恢复远程文件缓冲区的超时秒数，避免 Emacs 在恢复包含远程文件的会话时被阻塞。
</p>

<p>
默认会一次性恢复桌面中的所有缓冲区。但如果缓冲区数量很多，速度可能较慢。你可以通过变量 <code>desktop-restore-eager</code> 指定 <b>立即恢复的最大缓冲区数量</b> ，剩下的缓冲区会在 Emacs 空闲 <b>时延迟恢复</b> 。
</p>

<p>
输入 <code>M-x desktop-clear</code> 清空 Emacs 桌面；例如，当你想接下来用 <code>M-x desktop-read</code> 切换到另一个桌面时很有用。 <code>desktop-clear</code> 命令会关闭除内部缓冲区外的所有缓冲区，并清空 <code>desktop-globals-to-clear</code> 中列出的全局变量。如果你希望保留某些缓冲区，可以自定义变量 <code>desktop-clear-preserve-buffers</code> ，它的值是一个正则表达式列表，匹配的缓冲区名不会被关闭。
</p>

<p>
如果你希望在会话间保存 <b>小缓冲区历史记录</b> ，可以使用 savehist 库。你也可以将选定的小缓冲区历史变量添加到 <code>desktop-globals-to-save</code> 中，让它们随 <code>desktop-save-mode</code> 一起保存。
</p>
</div>
</section>
<section id="outline-container-Recursive-Edit" class="outline-2">
<h2 id="Recursive-Edit"><span class="section-number-2">47.</span> 递归编辑层级</h2>
<div class="outline-text-2" id="text-Recursive-Edit">
<p>
<b><i>recursive edit递归编辑</i></b> 指的是这样一种场景：你正在执行某个 Emacs 命令的过程中，又使用 Emacs 命令进行任意编辑操作。例如，在查询替换（ <code>query-replace</code> ）过程中按下 <code>C-r</code> ，就会进入递归编辑，此时你可以修改当前缓冲区。退出递归编辑后，会回到之前的 query-replace 操作。详见<a href="#Query-Replace">查询替换</a>。
</p>

<p>
退出递归编辑，意味着返回到未执行完的命令中，让其继续执行。退出命令是： <code>C-M-c</code> (<code>exit-recursive-edit</code>)。
</p>

<p>
你也可以 <b><i>abort中止</i></b> 递归编辑。这与退出类似，但会 <b>直接终止</b> 未执行完的命令。使用命令 <code>C-]</code> (<code>abort-recursive-edit</code>) 。详见<a href="#Quitting">退出与中止</a>。
</p>

<p>
当你处于递归编辑时，模式行会在主模式和次要模式名称的外层括号外，再显示一对方括号 '<code>[]</code>' 来提示。所有窗口的模式行都会这样显示，因为递归编辑是整个 Emacs 的全局状态，而非某个窗口或缓冲区独有。
</p>

<p>
递归编辑可以 <b>嵌套</b> （递归中再进入递归）。例如，在查询替换中按 <code>C-r</code> 进入递归编辑后，你又执行了某个会进入调试器的命令，这就会在 <code>C-r</code> 的递归编辑层内，再开启一层调试器的递归编辑。模式行会为 <b>每一层</b> 正在进行的递归编辑显示一对方括号。
</p>

<p>
退出内层递归编辑（例如使用调试器的 <code>c</code> 命令）会 <b>恢复执行上一层的命令</b> 。当上一层命令执行完毕后，你可以再用 <code>C-M-c</code> 退出上一层递归编辑，依此类推。 <b>退出只作用于最内层</b> 。中止也只会退出一层递归编辑，立即回到上一层命令。如有需要，你可以继续中止上一层。
</p>

<p>
另外，命令 <code>M-x top-level</code> 会中止所有层级的递归编辑，直接回到最顶层命令读取状态。如果迷你缓冲区处于激活状态，它也会一并退出。
</p>

<p>
在递归编辑中编辑的文本，不一定与顶层编辑的是同一个。这取决于触发递归编辑的命令。如果调用递归编辑的命令先切换到了另一个缓冲区，你在递归编辑中操作的就是那个缓冲区。无论如何，在递归编辑中你仍可以 <b>照常切换缓冲区</b> （只要切换按键没有被重新绑定）。理论上你甚至可以在递归编辑里完成之后所有的编辑、打开文件等操作，但这偶尔会带来意外后果（如栈溢出）。因此记得在不需要时及时退出或中止递归编辑。
</p>

<p>
总体而言，GNU Emacs 尽量减少递归编辑层级的使用。因为它强制你必须按特定顺序返回 —— 从最内层一层层回到顶层。在可行的情况下，我们会将不同操作放在 <b>独立的缓冲区</b> 中，让你可以自由切换。有些命令会切换到新的主模式，并提供返回命令。这些方式让你能按自己选择的顺序回到未完成的任务，更灵活。
</p>
</div>
</section>
<section id="outline-container-Hyperlinking" class="outline-2">
<h2 id="Hyperlinking"><span class="section-number-2">48.</span> 超链接与网页导航功能</h2>
<div class="outline-text-2" id="text-Hyperlinking">
<p>
以下小节将介绍用于处理 Emacs 缓冲区文本中 URL 及其他类型链接的便捷功能。
</p>

<ul class="org-ul">
<li><a href="#EWW">使用 EWW 网页浏览</a></li>
<li><a href="#Embedded-WebKit-Widgets">嵌入式 WebKit 组件</a></li>
<li><a href="#Browse_002dURL">跟随 URL 链接</a></li>
<li><a href="#FFAP">查找光标位置的文件与 URL</a></li>
</ul>
</div>
<div id="outline-container-EWW" class="outline-3">
<h3 id="EWW"><span class="section-number-3">48.1.</span> 使用 EWW 网页浏览</h3>
<div class="outline-text-3" id="text-EWW">
<p>
EWW 全称 Emacs Web Wowser，是 Emacs 内置的网页浏览器包。它可以在 Emacs 缓冲区内部浏览 URL。使用命令 <code>M-x eww</code> 可以打开一个 URL 或进行网页搜索。你可以使用命令 <code>M-x eww-open-file</code> 打开本地文件。可以将 EWW 设为 <code>browse-url</code> 所使用的浏览器，详见 “<a href="#Browse_002dURL">访问 URL</a>” 一节。完整说明请查阅《Emacs Web Wowser 手册》中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/eww/index.html#Top">EWW</a> 部分。
</p>
</div>
</div>
<div id="outline-container-Embedded-WebKit-Widgets" class="outline-3">
<h3 id="Embedded-WebKit-Widgets"><span class="section-number-3">48.2.</span> 嵌入式 WebKit 组件</h3>
<div class="outline-text-3" id="text-Embedded-WebKit-Widgets">
<p>
如果 Emacs 在编译时启用了对应的支持包，就可以在缓冲区中显示浏览器组件。命令 <code>M-x xwidget-webkit-browse-url</code> 会要求输入一个 URL，并在浏览器组件中显示。默认情况下，该 URL 取自光标所在或光标之前的位置；但如果存在激活的选区（参见<a href="#Mark">标记与选区</a>），则默认 URL 来自选区内容（会自动去除其中的空白字符）。
</p>

<p>
执行该命令后，Emacs 会新建一个缓冲区，在其中用嵌入式浏览器显示指定的 URL。该缓冲区会进入 Xwidget-WebKit 模式（与图片模式类似，参见<a href="#Image-Mode">查看图片文件</a>），提供一键式命令用于滚动组件、调整大小和重新加载页面。在该缓冲区中按 <code>C-h b</code> 可查看所有按键绑定。
</p>

<p>
默认情况下，在 xwidget webkit 缓冲区中输入可自插入字符不会产生效果，或会触发某些特殊动作。若想让这些字符及常用编辑键正常输入，可以启用 <code>xwidget-webkit-edit-mode</code> ，该模式会重新定义按键，使其直接传递给 WebKit 组件。
</p>

<p>
你也可以在 xwidget webkit 缓冲区中按 <code>e</code> 来启用 <code>xwidget-webkit-edit-mode</code> 。
</p>

<p>
<code>xwidget-webkit-isearch-mode</code> 是一个次要模式，行为类似于增量搜索（参见<a href="#Incremental-Search">增量搜索</a>），但它作用于 WebKit 组件的内容，而非当前缓冲区。在 xwidget-webkit 缓冲区中，该模式绑定到 <code>C-s</code> 和 <code>C-r</code> 。当通过 <code>C-r</code> 启动时，初始搜索会按反向进行。
</p>

<p>
输入任意可自插入字符都会将该字符加入当前搜索串。按 <code>C-s</code> 会在 WebKit 组件中跳转到下一个搜索结果，按 <code>C-r</code> 则跳转到上一个结果。
</p>

<p>
按 <code>C-g</code> 可退出增量搜索。
</p>

<p>
命令 <code>xwidget-webkit-browse-history</code> 会打开一个缓冲区，列出当前 WebKit 缓冲区之前加载过的页面列表，按 <code>RET</code> 即可跳转到对应页面。该命令绑定到按键 <code>H</code> 。
</p>

<p>
WebKit 缓冲区默认启用 JavaScript，这可能不符合你的需求，因为网站常会用它来跟踪你的浏览行为。你可以通过将变量 <code>xwidget-webkit-disable-javascript</code> 设置为非 nil 值来禁用 JavaScript。修改后必须关闭所有 WebKit 缓冲区，该设置才会生效。
</p>
</div>
</div>
<div id="outline-container-Browse_002dURL" class="outline-3">
<h3 id="Browse_002dURL"><span class="section-number-3">48.3.</span> 跟随 URL 链接</h3>
<div class="outline-text-3" id="text-Browse_002dURL">
<dl class="org-dl">
<dt><code>M-x browse-url RET url RET</code></dt><dd>将一个 <i>URL</i> 加载到网页浏览器中。</dd>
</dl>

<p>
Browse-URL 包让你可以在 Emacs 内部方便地访问 URL。大多数 URL 会通过调用外部网页浏览器打开； ‘mailto:’ 类型的 URL 则会调用 Emacs 的 <code>compose-mail</code> 命令，向指定地址发送邮件（参见<a href="#Sending-Mail">发送邮件</a>）。
</p>

<p>
命令 <code>M-x browse-url</code> 会提示输入一个 URL 并访问它。如果光标位于一个合理的 URL 附近，该 URL 会作为默认值提供。Browse-URL 包还提供了其他你可能希望绑定快捷键的命令，例如 <code>browse-url-at-point</code> 和 <code>browse-url-at-mouse</code> 。
</p>

<p>
你可以通过 <code>browse-url</code> 定制组中的各种选项来调整 Browse-URL 的行为。其中，选项 <code>browse-url-mailto-function</code> 用于定义如何处理 ‘mailto:’ URL，而 <code>browse-url-browser-function</code> 用于指定默认浏览器。
</p>

<p>
你可以通过定制 <code>browse-url-handlers</code> 来让特定 URL 使用其他函数打开，它是一个由正则表达式或谓词与对应处理函数配对组成的关联列表。
</p>

<p>
更多信息可通过输入 <code>C-h P browse-url RET</code> 查看该包的注释说明。
</p>

<p>
Emacs 还提供一个次要模式，支持把 URL 当作文件来处理。url-handler-mode 是一个全局次要模式，会影响绝大多数处理文件名的 Emacs 命令与原语。开启该模式后，例如你可以使用 <code>C-x C-f https://www.gnu.org/ RET</code> 查看该网页的 HTML 内容，之后还能对其进行编辑并保存到本地文件。
</p>
</div>
</div>
<div id="outline-container-Goto-Address-mode" class="outline-3">
<h3 id="Goto-Address-mode"><span class="section-number-3">48.4.</span> 激活 URL 链接</h3>
<div class="outline-text-3" id="text-Goto-Address-mode">
<dl class="org-dl">
<dt><code>M-x goto-address-mode</code></dt><dd>在当前缓冲区中激活 URL 和电子邮件地址识别。</dd>
<dt><code>M-x global-goto-address-mode</code></dt><dd>在所有缓冲区中启用 <code>goto-address-mode</code> 。</dd>
</dl>

<p>
通过输入 <code>M-x goto-address-mode</code> ，你可以让 Emacs 在当前缓冲区里对 URL 进行特殊标记。启用这个缓冲区本地的次要模式后，它会找出缓冲区中所有的 URL，对其高亮显示，并将它们变成可点击的按钮。当光标位于 URL 文本上时，你可以按 <code>C-c RET</code> (<code>goto-address-at-point</code>) 访问该 URL；也可以使用 鼠标中键（ <code>mouse-2</code> ） 点击，或快速单击鼠标左键（ <code>mouse-1</code> ）打开（参见<a href="#Mouse-References">使用鼠标访问引用</a>）。访问 URL 的操作是通过调用 <code>browse-url</code> 子程序完成的（参见<a href="#Browse_002dURL">访问 URL</a>）。
</p>

<p>
将 <code>goto-address-mode</code> 添加到模式钩子以及显示新消息的钩子中（例如给 Rmail 使用的 <code>rmail-show-message-hook</code> ）会很实用。Gnus 或 MH-E 无需如此，因为它们自身已具备类似功能。
</p>
</div>
</div>
<div id="outline-container-FFAP" class="outline-3">
<h3 id="FFAP"><span class="section-number-3">48.5.</span> 查找光标位置的文件与 URL</h3>
<div class="outline-text-3" id="text-FFAP">
<p>
FFAP 包会替换部分用于查找文件的按键绑定（例如 <code>C-x C-f</code> ），替换为能提供更合理默认值的命令。当带有前缀参数时，这些命令的行为与普通命令一致；否则，它们会从光标周围的文本中获取默认文件名或 URL。如果在缓冲区中识别到的内容是 URL 而非文件名，命令会使用 <code>browse-url</code> 来打开它（参见<a href="#Browse_002dURL">访问 URL</a>）。
</p>

<p>
该功能在访问邮件、新闻缓冲区、README 文件、MANIFEST 文件等中的引用时非常实用。更多信息可输入 <code>C-h P ffap RET</code> 查看该包的注释说明。
</p>

<p>
输入 <code>M-x ffap-bindings</code> 即可启用 FFAP。这会设置以下按键绑定，并为 Rmail、Gnus 和 VM 文章缓冲区安装钩子以提供额外的 FFAP 功能。
</p>

<dl class="org-dl">
<dt><code>C-x C-f filename RET</code></dt><dd>打开 <i>filename</i> ，从光标周围文本猜测默认值 (<code>find-file-at-point</code>)。</dd>
<dt><code>C-x C-r filename RET</code></dt><dd><code>ffap-read-only</code> ，功能类似于 <code>find-file-read-only</code> 。</dd>
<dt><code>C-x C-v filename RET</code></dt><dd><code>ffap-alternate-file</code> ，功能类似于 <code>find-alternate-file</code> 。</dd>
<dt><code>C-x d directory RET</code></dt><dd>在指定 <i>directory目录</i> 打开 Dired，默认使用光标所在目录 (<code>dired-at-point</code>)。</dd>
<dt><code>C-x C-d directory RET</code></dt><dd><code>ffap-list-directory</code> ，功能类似于 <code>list-directory</code> 。</dd>
<dt><code>C-x 4 f filename RET</code></dt><dd><code>ffap-other-window</code> ，功能类似于 <code>find-file-other-window</code> 。</dd>
<dt><code>C-x 4 r filename RET</code></dt><dd><code>ffap-read-only-other-window</code> ，功能类似于 <code>find-file-read-only-other-window</code> 。</dd>
<dt><code>C-x 4 d directory RET</code></dt><dd><code>ffap-dired-other-window</code> ，功能类似于 <code>dired-other-window</code> 。</dd>
<dt><code>C-x 5 f filename RET</code></dt><dd><code>ffap-other-frame</code> ，功能类似于 <code>find-file-other-frame</code> 。</dd>
<dt><code>C-x 5 r filename RET</code></dt><dd><code>ffap-read-only-other-frame</code> ，功能类似于 <code>find-file-read-only-other-frame</code> 。</dd>
<dt><code>C-x 5 d directory RET</code></dt><dd><code>ffap-dired-other-frame</code> ，功能类似于 <code>dired-other-frame</code> 。</dd>
<dt><code>C-x t C-f filename RET</code></dt><dd><code>ffap-other-tab</code> ，功能类似于 <code>find-file-other-tab</code> 。</dd>
<dt><code>C-x t C-r filename RET</code></dt><dd><code>ffap-read-only-other-tab</code> ，功能类似于 <code>find-file-read-only-other-tab</code> 。</dd>
<dt><code>M-x ffap-next</code></dt><dd>在缓冲区中搜索下一个文件名或 URL，然后打开该文件或 URL。</dd>
<dt><code>S-mouse-3</code></dt><dd>ffap-at-mouse，从鼠标点击位置周围的文本猜测并打开文件。</dd>
<dt><code>C-S-mouse-3</code></dt><dd>显示当前缓冲区中提到的文件与 URL 菜单，选择后打开 (<code>ffap-menu</code>)。</dd>
</dl>
</div>
</div>
</section>
<section id="outline-container-Amusements" class="outline-2">
<h2 id="Amusements"><span class="section-number-2">49.</span> 游戏与其他娱乐功能</h2>
<div class="outline-text-2" id="text-Amusements">
<p>
animate 包可以让文本 “动起来”（例如 <code>M-x animate-birthday-present</code> ）。
</p>

<p>
<code>M-x blackbox</code> 、 <code>M-x mpuz</code> 和 <code>M-x 5x5</code> 是解谜游戏。
</p>
<ul class="org-ul">
<li><code>blackbox</code> ：通过层析成像的方式推断盒子内部物体的位置。</li>
<li><code>mpuz</code> ：展示一个字母替代数字的乘法谜题，你需要猜出密码 —— 输入一个字母，再输入你认为它代表的数字。</li>
<li><code>5x5</code> ：目标是填满所有方格。</li>
</ul>

<p>
<code>M-x bubbles</code> 是一款消泡泡游戏，目标是以最少步数消除尽可能多的泡泡。
</p>

<p>
<code>M-x decipher</code> 可以帮助你分析经过简单单字母替换加密的缓冲区内容。
</p>

<p>
<code>M-x dissociated-press</code> 会将当前缓冲区的文本逐词或逐字符打乱，并输出到名为 <code>*Dissociation*</code> 的缓冲区。正参数表示逐字符处理，并指定重叠字符数；负参数表示逐词处理，并指定重叠单词数。该功能生成的效果与马尔可夫链类似，但它是独立原创的算法；它会在随机跳转之间从原文中连续复制若干字符，而不像马尔可夫链那样每词或每字符都随机跳转。如果你希望文档通顺规范、易于理解，就别把这些错乱内容写进正式文档里。
</p>

<p>
<code>M-x dunnet</code> 运行一款纯文字冒险游戏。
</p>

<p>
如果你想多一点互动，可以试试 <code>M-x gomoku</code> ，和 Emacs 对战五子棋。
</p>

<p>
有点无聊可以试试 <code>M-x hanoi</code> （汉诺塔）。非常无聊可以给它一个数字参数。超级、超级无聊就用参数 9，静静看着就行。
</p>

<p>
<code>M-x life</code> 运行康威生命游戏（元胞自动机）。
</p>

<p>
<code>M-x morse-region</code> ：将选中区域文本转为摩尔斯电码； <code>M-x unmorse-region</code> ：将摩尔斯电码还原为文本； <code>M-x nato-region</code> ：将区域文本转为北约音标字母； <code>M-x denato-region</code> ：将北约音标字母还原。
</p>

<p>
<code>M-x pong</code> 、 <code>M-x snake</code> 和 <code>M-x tetris</code> 分别实现了经典的乒乓球、贪吃蛇、俄罗斯方块游戏。
</p>

<p>
<code>M-x solitaire</code> 是一款跳棋式单人纸牌游戏。
</p>

<p>
命令 <code>M-x zone</code> 会在 Emacs 空闲时，在屏幕上播放各种视觉特效小游戏。
</p>

<p>
“真正的程序员” 会用 <code>M-x butterfly</code> ，它用蝴蝶效应翻转磁盘上的一个比特，详见 <a href="https://xkcd.com/378">https://xkcd.com/378</a>。
</p>

<p>
最后，如果你感到沮丧，可以向著名的心理治疗师 Eliza 倾诉。只需执行 <code>M-x doctor</code> ，每次输入完毕后连按两次回车即可。
</p>
</div>
</section>
<section id="outline-container-Packages" class="outline-2">
<h2 id="Packages"><span class="section-number-2">50.</span> Emacs Lisp 软件包</h2>
<div class="outline-text-2" id="text-Packages">
<p>
Emacs 通过 <b>包（package）</b> 来扩展功能，包本质是 Emacs Lisp 库。这些包可以由你自己编写，也可以由他人提供。如果你希望安装某个包，并在后续的 Emacs 会话中都能使用，需要将其编译，并放到 Emacs 搜索 Lisp 库的目录中。关于这种手动安装方式的更多细节，参见《<a href="#Lisp-Libraries">Emacs 的 Lisp 代码库</a>》。很多包会在 Lisp 文件开头的长篇注释中，提供安装与使用说明；你可以按照这些说明来安装和微调该包的使用。
</p>

<p>
功能包也可以由 <b>软件包仓库（package archives）</b> 提供，这类仓库是 Emacs Lisp 包的大型集合。每个包都是独立的 Emacs Lisp 程序，有时还会附带 Info 手册等其他组件。Emacs 内置了一套机制，可以让你方便地从这类仓库下载并安装包。本章后续内容会介绍这套机制。
</p>

<p>
输入 <code>M-x list-packages RET</code> 可以列出从软件包仓库中可安装的所有包。该命令会打开一个名为 <code>*Packages*</code> 的缓冲区，展示所有包的列表，你可以通过这个缓冲区安装或卸载包。参见《<a href="#Package-Menu">软件包菜单缓冲区</a>》。
</p>

<p>
命令 <code>C-h P</code> (<code>describe-package</code>) 会提示输入包名，并打开一个帮助缓冲区，描述该包的属性与实现的功能。
</p>

<p>
默认情况下，Emacs 从两个仓库下载包：<a href="https://elpa.gnu.org/">GNU ELPA</a> 和 <a href="https://elpa.nongnu.org/">NonGNU ELPA</a>。它们由 Emacs 开发者维护、GNU 项目托管。你也可以选择从第三方仓库下载包。参见《<a href="#Package-Installation">软件包安装</a>》。
</p>

<p>
关于如何把一个 Emacs Lisp 程序制作成可安装的包，参见《Emacs Lisp 参考手册》中的 “<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Packaging.html#Packaging">打包</a>” 章节。
</p>

<ul class="org-ul">
<li><a href="#Package-Menu">软件包菜单缓冲区</a></li>
<li><a href="#Package-Statuses">软件包状态</a></li>
<li><a href="#Package-Installation">软件包安装</a></li>
<li><a href="#Package-Files">软件包文件与目录结构</a></li>
<li><a href="#Fetching-Package-Sources">获取软件包源码</a></li>
</ul>
</div>
<div id="outline-container-Package-Menu" class="outline-3">
<h3 id="Package-Menu"><span class="section-number-3">50.1.</span> 软件包菜单缓冲区</h3>
<div class="outline-text-3" id="text-Package-Menu">
<p>
执行命令 <code>M-x list-packages</code> 会打开软件包菜单。这是一个列出 Emacs 已知所有软件包的缓冲区，每个软件包占一行，包含以下信息：
</p>
<ul class="org-ul">
<li>软件包名称（如 'auctex'）</li>
<li>软件包版本号（如 '11.86'）</li>
<li>软件包状态 —— 通常为 'available' （可从软件包仓库下载）、 'installed' （已安装）或 'built-in' （Emacs 默认内置）。详见「<a href="#Package-Statuses">软件包状态</a>」。</li>
<li>若启用了多个软件包仓库，会显示该软件包所属仓库。</li>
<li>软件包的简短描述。</li>
</ul>

<p>
<code>list-packages</code> 命令会访问网络，从软件包仓库服务器获取可用软件包列表。若网络不可用，则使用最近一次获取的列表。
</p>

<p>
软件包列表缓冲区的核心命令是 <code>x</code> ：
</p>
<ul class="org-ul">
<li>若光标所在软件包未安装，执行安装；</li>
<li>若已安装，执行删除。</li>
</ul>

<p>
<b>软件包菜单可用命令</b>
</p>

<dl class="org-dl">
<dt><code>h</code></dt><dd>显示一条简短信息，总结软件包菜单的使用方法 (<code>package-menu-quick-help</code>)。</dd>
<dt><code>?</code></dt><dd></dd>

<dt><code>RET</code></dt><dd>显示当前行软件包的帮助缓冲区 (<code>package-menu-describe-package</code>)，与 <code>C-h P</code> 命令显示的帮助窗口类似（参见 <a href="#Packages">Emacs Lisp 软件包</a>）。</dd>
<dt><code>i</code></dt><dd>标记当前行的软件包以待安装 (<code>package-menu-mark-install</code>)。如果软件包状态为 “available”（可用），会在行首添加一个 'I' 字符；按下 <code>x</code> （见下文）将下载并安装该软件包。</dd>
<dt><code>d</code></dt><dd>标记当前行的软件包以待删除 (<code>package-menu-mark-delete</code>)。如果软件包状态为 “installed”（已安装），会在行首添加一个 'D' 字符；按下 <code>x</code> （见下文）将删除该软件包。关于删除软件包会涉及哪些操作，参见 “<a href="#Package-Files">软件包文件与目录结构</a>”。</dd>
<dt><code>w</code></dt><dd>在浏览器中打开当前行软件包的官方网站 (<code>package-browse-url</code>)。该功能通过 <code>browse-url</code> 调用浏览器。</dd>
<dt><code>~</code></dt><dd>将所有已废弃（obsolete）的软件包标记为待删除 (<code>package-menu-mark-obsolete-for-deletion</code>)。此命令会将所有状态为 “obsolete” 的软件包标记为待删除。</dd>
<dt><code>u</code></dt><dd></dd>

<dt><code>DEL</code></dt><dd>取消之前通过 <code>i</code> 或 <code>d</code> 命令为当前行添加的安装或删除标记 (<code>package-menu-mark-unmark</code>)。</dd>
<dt><code>U</code></dt><dd>将所有有可用新版本的软件包标记为待升级 (<code>package-menu-mark-upgrades</code>)。此命令会为新版本添加安装标记，并为旧的已安装版本（状态为 “obsolete”）添加删除标记。默认情况下，不会对有新版本的内置软件包进行标记，但可以通过自定义 <code>package-install-upgrade-built-in</code> 改变这一行为。参见 “<a href="#Package-Installation">软件包安装</a>”。如果你将 <code>package-install-upgrade-built-in</code> 设置为非 nil 值，请务必检查 <code>U</code> 命令标记的所有内置软件包，避免意外覆盖不想更新的内置包。</dd>
<dt><code>x</code></dt><dd>下载并安装所有标记为 <code>i</code> 的软件包及其依赖项；同时删除所有标记为 <code>d</code> 的软件包 (<code>package-menu-execute</code>)。执行后会清除所有标记。如果没有任何软件包被标记，此命令将直接安装光标下的软件包（若尚未安装），或删除光标下的软件包（若已安装）。</dd>
<dt><code>g</code></dt><dd></dd>

<dt><code>r</code></dt><dd>刷新软件包列表 (<code>revert-buffer</code>)。此操作会重新从软件包仓库获取可用软件包列表，并重新显示。</dd>
<dt><code>H</code></dt><dd>隐藏名称匹配正则表达式的软件包 (<code>package-menu-hide-package</code>)。命令会提示输入正则表达式，然后隐藏名称匹配的软件包。正则表达式的默认值仅隐藏光标所在的软件包，因此在提示时直接按 <code>RET</code> 即可隐藏当前软件包。</dd>
<dt><code>(</code></dt><dd>切换是否显示软件包的旧版本以及来自低优先级仓库的版本 (<code>package-menu-toggle-hiding</code>)。</dd>
<dt><code>/ a</code></dt><dd>按仓库来源过滤软件包列表 (<code>package-menu-filter-by-archive</code>)。命令会提示输入仓库名称（如 'gnu'），然后只显示来自该仓库的软件包。可以输入多个仓库名称，用逗号分隔。</dd>
<dt><code>/ d</code></dt><dd>按描述信息过滤软件包列表 (<code>package-menu-filter-by-description</code>)。命令会提示输入正则表达式，只显示描述信息匹配的软件包。</dd>
<dt><code>/ k</code></dt><dd>按关键词过滤软件包列表 (<code>package-menu-filter-by-keyword</code>)。命令会提示输入关键词（如 'games'），只显示带有该关键词的软件包。可以输入多个关键词，用逗号分隔。</dd>
<dt><code>/ N</code></dt><dd>按名称或描述过滤软件包列表 (<code>package-menu-filter-by-name-or-description</code>)。命令会提示输入正则表达式，只显示名称或描述匹配的软件包。</dd>
<dt><code>/ n</code></dt><dd>按名称过滤软件包列表 (<code>package-menu-filter-by-name</code>)。命令会提示输入正则表达式，只显示名称匹配的软件包。</dd>
<dt><code>/ s</code></dt><dd>按状态过滤软件包列表 (<code>package-menu-filter-by-status</code>)。命令会提示输入一个或多个状态（如 'available' ，参见 “<a href="#Package-Statuses">软件包状态</a>”），只显示状态匹配的软件包。可以输入多个状态值，用逗号分隔。</dd>
<dt><code>/ v</code></dt><dd>按版本过滤软件包列表 (<code>package-menu-filter-by-version</code>)。命令会先提示输入比较符号 '<code>&lt;</code>' 、 '<code>&gt;</code>' 或 '<code>=</code>'，再输入版本字符串，然后只显示版本满足条件的软件包。</dd>
<dt><code>/ m</code></dt><dd>只显示已被标记（待安装或待删除）的软件包 (<code>package-menu-filter-marked</code>)。</dd>
<dt><code>/ u</code></dt><dd>只显示有可用升级的软件包 (<code>package-menu-filter-upgradable</code>)。默认情况下，此过滤会排除有新版本的内置软件包，但可以通过自定义 <code>package-install-upgrade-built-in</code> 改变这一行为。参见 “<a href="#Package-Installation">软件包安装</a>”。</dd>
<dt><code>/ /</code></dt><dd>清除当前应用到软件包列表的所有过滤条件 (<code>package-menu-filter-clear</code>)。</dd>
</dl>

<p>
示例：在目标软件包行按 <code>i</code> 标记，再按 <code>x</code> 执行安装即可。
</p>
</div>
</div>
<div id="outline-container-Package-Statuses" class="outline-3">
<h3 id="Package-Statuses"><span class="section-number-3">50.2.</span> 软件包状态</h3>
<div class="outline-text-3" id="text-Package-Statuses">
<p>
一个软件包可以具有以下状态之一：
</p>
<dl class="org-dl">
<dt>'<code>available</code>'</dt><dd>该软件包尚未安装，但可以从软件包仓库下载并安装。</dd>
<dt>'<code>avail-obso</code>'</dt><dd>该软件包可用于安装，但同时存在更新的版本。具有此状态的软件包默认会被隐藏。</dd>
<dt>'<code>built-in</code>'</dt><dd>该软件包是 Emacs 默认内置的。无法通过软件包菜单删除，并且默认不参与升级（但你可以通过自定义 <code>package-install-upgrade-built-in</code> 改变这一点，参见 “<a href="#Package-Installation">软件包安装</a>”）。</dd>
<dt>'<code>dependency</code>'</dt><dd>该软件包是为满足其他软件包的依赖而自动安装的。</dd>
<dt>'<code>disabled</code>'</dt><dd>该软件包已通过 <code>package-load-list</code> 变量被禁用。</dd>
<dt>'<code>external</code>'</dt><dd>该软件包既不是内置包，也不来自 <code>package-user-dir</code> 指定的目录（参见 “<a href="#Package-Files">软件包文件与目录结构</a>”）。外部包的处理方式与内置包类似，无法删除。</dd>
<dt>'<code>held</code>'</dt><dd>该软件包被保留（held）。参见 “<a href="#Package-Installation">软件包安装</a>”。</dd>
<dt>'<code>incompat</code>'</dt><dd>该软件包因某些原因无法安装，例如依赖无法安装的软件包。</dd>
<dt>'<code>installed</code>'</dt><dd>该软件包已安装。</dd>
<dt>'<code>new</code>'</dt><dd>与 'available' 等价，区别在于：该软件包是你上一次执行 <code>M-x list-packages</code> 之后才加入仓库的。</dd>
<dt>'<code>obsolete</code>'</dt><dd>该软件包是已安装的旧版本；除该版本外，已安装更新版本。</dd>
</dl>
</div>
</div>
<div id="outline-container-Package-Installation" class="outline-3">
<h3 id="Package-Installation"><span class="section-number-3">50.3.</span> 软件包安装</h3>
<div class="outline-text-3" id="text-Package-Installation">
<p>
最方便的安装方式是使用软件包菜单（参见《<a href="#Package-Menu">软件包菜单缓冲区</a>》），你也可以使用命令 <code>M-x package-install</code> 。该命令会提示输入状态为 'available' 的软件包名称，然后下载并安装。同理，若要升级某个软件包，可使用 <code>M-x package-upgrade</code> ；若要升级所有软件包，可使用 <code>M-x package-upgrade-all</code> 。
</p>

<p>
默认情况下， <code>package-install</code> 不会考虑那些内置软件包（已随 Emacs 发行版自带）在软件仓库中有新版本的情况。具体来说，在命令提示时，补全候选列表中不会显示内置软件包。但如果你带前缀参数调用 <code>package-install</code> ，它就会同时考虑可升级的内置软件包。你可以通过自定义变量 <code>package-install-upgrade-built-in</code> 将此行为设为默认：若其值为非 nil，即使不带前缀参数， <code>package-install</code> 也会考虑内置软件包。注意：软件包菜单相关命令（参见《<a href="#Package-Menu">软件包菜单缓冲区</a>》）同样受此变量影响。
</p>

<p>
与之相反， <code>package-upgrade</code> 和 <code>package-upgrade-all</code> 永远不会处理内置软件包。如果你想用这些命令升级某些内置软件包，需要先对每个目标软件包执行一次升级：要么通过 <code>C-u M-x package-install RET</code> ，要么先将 <code>package-install-upgrade-built-in</code> 设为非 nil，再通过软件包菜单或 <code>package-install</code> 升级一次。
</p>

<p>
如果你将 <code>package-install-upgrade-built-in</code> 设为非 nil，在使用批量更新命令（如 <code>package-upgrade-all</code> 和软件包菜单中的 <code>U</code> ）时务必小心：这些命令可能会覆盖你本不想用仓库新版本替换的内置软件包。如果你只想更新少量内置软件包，就不要使用这些批量命令。
</p>

<p>
一个软件包可能依赖其他某些软件包，因为它需要用到后者提供的功能。当 Emacs 安装这类软件包时，会自动下载并安装所有尚未安装的依赖软件包。（若某个依赖包不可用，Emacs 会报错并中止安装。）软件包的依赖列表会显示在其帮助缓冲区中。
</p>

<p>
默认情况下，Emacs 从两个仓库下载软件包：<a href="https://elpa.gnu.org/">GNU ELPA</a> 和 <a href="https://elpa.nongnu.org/">NonGNU ELPA</a>。它们由 Emacs 开发者维护、GNU 项目托管。GNU ELPA 包含我们视作 GNU Emacs 组成部分、但与 Emacs 核心分开发布的 GNU 软件包。NonGNU ELPA 包含版权未转让给自由软件基金会的第三方软件包。<sup><a id="fnr.24" class="footref" href="#fn.24" role="doc-backlink">24</a></sup>
</p>

<p>
这由变量 <code>package-archives</code> 控制，其值是 Emacs 已知的软件包仓库列表。每个列表元素格式为 <code>(id . location)</code> ，其中 <i>id</i> 是仓库名称， <i>location</i> 是仓库目录的 URL 或名称。你可以修改此列表为第三方软件包仓库 —— 但风险自负，且只应使用你信任的第三方！
</p>

<dl class="org-dl">
<dt>用户选项： <code>package-archives</code></dt><dd><p>
该变量的值是一个关联列表，记录 Emacs 包管理器识别的软件包仓库。
</p>

<p>
每个元素对应一个仓库，格式为 <code>(id . location)</code> ： <i>id</i> 为仓库名称（字符串）， <i>location</i> 为仓库基础路径（字符串）
</p>

<p>
若基础路径以 ‘http:’ 或 ‘https:’ 开头，则被当作 HTTP (S) URL，Emacs 会通过 HTTP (S) 从该仓库下载软件包（默认 GNU 仓库就是如此）。
</p>

<p>
否则，基础路径应为目录名。此时 Emacs 通过普通文件访问从该仓库获取软件包。这类本地仓库主要用于测试。
</p></dd>
</dl>

<p>
软件包仓库维护者可以对软件包进行签名，以提高可信度。他们生成一对非对称加密密钥，用私钥为每个软件包生成 <i>signature file签名文件</i> 。你可以用公钥和签名文件验证软件包来源，并确保软件包未被篡改。签名验证通过 EasyPG 接口使用 <a href="https://www.gnupg.org/">GnuPG 软件包</a>完成（参见《Emacs EasyPG 助手手册》中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/epa/index.html#Top">EasyPG</a>）。有效签名并非软件包绝对安全的绝对保证，你仍应保持谨慎。
</p>

<p>
软件包仓库应提供获取其公钥的说明。一种方式是从密钥服务器（如 <a href="https://pgp.mit.edu/">https://pgp.mit.edu/</a>）下载。使用 <code>M-x package-import-keyring</code> 将公钥导入 Emacs。Emacs 将软件包密钥存放在变量 <code>package-gnupghome-dir</code> 指定的目录中，默认为 <code>package-user-dir</code> 下的 'gnupg' 子目录。这会让 Emacs 在验证签名时给 GnuPG 传入 '<code>--homedir</code>' 选项。若 <code>package-gnupghome-dir</code> 为 <code>nil</code> ，则不使用该选项。GNU 软件包仓库的公钥随 Emacs 一同分发，位于 <code>etc/package-keyring.gpg</code> ，Emacs 会自动使用。
</p>

<p>
若用户选项 <code>package-check-signature</code> 为非 nil，Emacs 会在安装软件包时尝试验证签名。若值为 <code>allow-unsigned</code> 且存在可用的 OpenPGP 配置：已签名的包会被检查，但你仍可安装未签名包。如果你使用某些不签名的仓库，可以将它们加入 <code>package-unsigned-archives</code> 列表。（若值为 <code>allow-unsigned</code> 但无可用 OpenPGP，则按 <code>nil</code> 处理。）
</p>
<ul class="org-ul">
<li>若值为 <code>t</code> ：必须至少有一个有效签名。</li>
<li>若值为 <code>all</code> ：所有签名都必须有效。</li>
</ul>

<p>
关于加密密钥与签名的更多信息，参见《GNU 隐私卫士手册》中的 <a href="https://www.gnupg.org/documentation/manuals/gnupg/index.html#Top">GnuPG</a>。Emacs 自带 GNU Privacy Guard 接口，参见《Emacs EasyPG 助手手册》中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/epa/index.html#Top">EasyPG</a>。
</p>

<p>
如果你启用了多个软件包仓库，且其中某些仓库提供同一软件包的不同版本，选项 <code>package-pinned-packages</code> 会很有用。你可以在该列表中添加「软件包 / 仓库」对，确保指定软件包只从指定仓库下载。
</p>

<p>
另一个在多仓库下有用的选项是 <code>package-archive-priorities</code> 。它指定每个仓库的优先级（数字越大优先级越高）。默认优先级为 0，除非本选项另行指定。如果高优先级仓库中存在某个软件包，低优先级仓库中的同名包将不会在菜单中显示。（这由 <code>package-menu-hide-low-priority</code> 控制。）
</p>

<p>
软件包下载、字节编译并安装后，会在当前 Emacs 会话中生效。生效过程会将其目录加入 <code>load-path</code> 并加载其自动加载项。不同软件包的自动加载效果各不相同：多数只是提供新命令，有些则对 Emacs 会话产生更广泛的影响。相关信息请查阅该软件包的帮助缓冲区。
</p>

<p>
已安装的软件包会在后续所有会话中由 Emacs 自动生效。该过程发生在启动时：处理 <i>early init file早期初始化文件</i> 之后、处理常规 <i>init file 初始化文件</i> 之前（参见《<a href="#Early-Init-File">早期初始化文件</a>》）。一个例外：如果 Emacs 以 '<code>-q</code>' 或 '<code>--no-init-file</code>' 选项启动（参见《<a href="#Initial-Options">初始选项</a>》），则不会在启动时自动加载软件包。
</p>

<p>
若要禁止 Emacs 在启动时自动加载软件包，将变量 <code>package-enable-at-startup</code> 设为 <code>nil</code> 。你必须在 <i>early init file早期初始化文件</i> 中设置，因为该变量在加载常规 <i>init file初始化文件</i> 之前就会被读取。因此，如果你通过 <code>Customize</code> 自定义该变量，应将设置保存到早期初始化文件中。方法是：在保存 <code>package-enable-at-startup</code> 之前，将变量 <code>custom-file</code> （参见《<a href="#Saving-Customizations">保存自定义设置</a>》）设为指向你的早期初始化文件。
</p>

<p>
如果你安装了大量软件包，将用户选项 <code>package-quickstart</code> 设为 <code>t</code> 可以提升启动速度。启用后，Emacs 会预先计算很多内容，而不是每次启动都重新计算。但这样做之后，当激活方式需要改变时（例如修改 <code>package-load-list</code> ），你必须手动运行命令 <code>package-quickstart-refresh</code> 。
</p>

<p>
即使你将 <code>package-enable-at-startup</code> 设为 <code>nil</code> ，仍可在启动中或启动后让软件包生效：
</p>
<ul class="org-ul">
<li>要在启动时生效：在初始化文件中调用函数 <code>package-activate-all</code> 。</li>
<li>要在启动后生效：执行 <code>M-: (package-activate-all) RET</code> 。</li>
</ul>

<p>
若要对启动时哪些软件包生效进行更精细的控制，可以使用变量 <code>package-load-list</code> 。它的值应当是一个列表。格式为 <code>(name version)</code> 的列表元素用于告知 Emacs：使名为 <i>name</i> 的软件包的 <i>version</i> 版本生效。
</p>

<p>
这里的 <i>version</i> 可以是：
</p>
<ul class="org-ul">
<li>一个版本字符串（对应软件包的某个具体版本），</li>
<li>或 <code>t</code> （表示使用任意已安装的版本），</li>
<li>或 <code>nil</code> （表示不使用任何版本；这会禁用该软件包，阻止其生效）。</li>
</ul>

<p>
列表元素也可以是符号 <code>all</code> ，表示：对列表中其他元素未指定的所有软件包，使用其最新已安装版本。该变量的默认值为 <code>'(all)</code> 。
</p>

<p>
例如，若将 <code>package-load-list</code> 设为 <code>'((muse "3.20") all)</code> ： Emacs 只会让 'muse' 包的 3.20 版生效，其他所有非 muse 软件包使用任意已安装版本。已安装的其他 'muse' 版本会被忽略。 'muse' 包在软件包菜单中将显示为「held」（保留）状态。
</p>

<p>
Emacs 字节码相当稳定，但仍可能出现字节码过时、或编译文件依赖的宏在新版 Emacs 中已变更的情况。你可以使用： <code>M-x package-recompile</code> 重新编译某个软件包，或 <code>M-x package-recompile-all</code> 重新编译所有软件包。（若安装包很多，后者可能需要较长时间。）
</p>
</div>
</div>
<div id="outline-container-Package-Files" class="outline-3">
<h3 id="Package-Files"><span class="section-number-3">50.4.</span> 软件包文件与目录结构</h3>
<div class="outline-text-3" id="text-Package-Files">
<p>
每个软件包都以 <b>单个软件包文件</b> 的形式从软件仓库下载：可以是一个 Emacs Lisp 源码文件，或是一个包含多个 Emacs Lisp 源码及其他文件的 tar 包。
</p>

<p>
软件包文件由负责安装软件包的 Emacs 命令自动获取、处理与清理。通常情况下，你无需直接操作这些文件，除非你正在 <b>制作软件包</b> （参见《Emacs Lisp 参考手册》中的 “<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Packaging.html#Packaging">打包</a>”）。如果你需要直接从软件包文件安装软件包，可使用命令 <code>M-x package-install-file</code> 。
</p>

<p>
软件包安装后，其内容会被放置在 <code>~/.emacs.d/elpa/</code> 的子目录中。（你可以通过自定义变量 <code>package-user-dir</code> 修改该目录名称。）软件包子目录的命名格式为： <i>name-version</i> ，其中 <i>name</i> 是软件包名， <i>version</i> 是版本字符串。
</p>

<p>
除 <code>package-user-dir</code> 外，Emacs 还会在 <code>package-directory-list</code> 列出的目录中查找已安装的软件包。这些目录供系统管理员使用，用于提供 <b>系统级全局可用</b> 的 Emacs 软件包；Emacs 自身永远不会将软件包安装到这些位置。 <code>package-directory-list</code> 中的软件包子目录结构与 <code>package-user-dir</code> 保持一致。
</p>

<p>
删除软件包（参见《<a href="#Package-Menu">软件包菜单缓冲区</a>》）需要删除对应的软件包子目录。该操作仅对安装在 <code>package-user-dir</code> 中的软件包有效；如果对系统级目录中的软件包执行删除命令，Emacs 会报错。
</p>
</div>
</div>
<div id="outline-container-Fetching-Package-Sources" class="outline-3">
<h3 id="Fetching-Package-Sources"><span class="section-number-3">50.5.</span> 获取软件包源码</h3>
<div class="outline-text-3" id="text-Fetching-Package-Sources">
<p>
默认情况下， <code>package-install</code> 会从软件包仓库下载一个 Tarball 并安装其中的文件。如果你希望修改该软件包的源码并与他人共享你的改动，这种方式可能不够用。这种情况下，你可能更希望直接获取并使用上游源码。这通常会让开发补丁与提交 bug 变得更简单。
</p>

<p>
实现这一点的一种方式是使用 <code>package-vc-install</code> ，直接从源码仓库获取软件包的源代码。该命令同样会自动确保所有文件被字节编译并设置自动加载，就像普通软件包一样。以这种方式安装的软件包与其他软件包行为完全一致：你可以用 <code>package-upgrade</code> 或 <code>package-upgrade-all</code> 升级，用 <code>package-delete</code> 删除，它们甚至会显示在普通的软件包列表中。如果你只想克隆软件包源码，不把它加入软件包列表，可以使用 <code>package-vc-checkout</code> 。
</p>

<p>
注意：目前内置软件包无法使用 <code>package-vc-install</code> 进行升级。
</p>

<p>
在源码检出（checkout）后，你可能希望基于最新开发版复现某个 bug，或实现某个新功能。如果软件包元数据中注明了维护者联系方式，你可以使用命令 <code>package-report-bug</code> 通过邮件提交 bug。该报告将包含你自定义过的所有用户选项。如果你做了改动并希望分享给维护者，可以先提交改动，再使用命令 <code>package-vc-prepare-patch</code> 生成补丁。详见 “<a href="#Preparing-Patches">准备补丁</a>”。
</p>

<p>
如果你维护自己的软件包，可能希望使用本地检出，而不是克隆远程仓库。可以使用 <code>package-vc-install-from-checkout</code> 实现：它会从软件包目录（见 “<a href="#Package-Files">软件包文件与目录结构</a>”）创建一个指向你本地检出目录的符号链接，并初始化代码。注意：你可能需要使用 <code>package-vc-rebuild</code> 重新执行初始化并更新自动加载信息。
</p>

<ul class="org-ul">
<li><a href="#Specifying-Package-Sources">指定软件包源码</a></li>
</ul>
</div>
<div id="outline-container-Specifying-Package-Sources" class="outline-4">
<h4 id="Specifying-Package-Sources"><span class="section-number-4">50.5.1.</span> 指定软件包源码</h4>
<div class="outline-text-4" id="text-Specifying-Package-Sources">
<p>
要从源码安装软件包，Emacs 必须知道从哪里获取该软件包的源码（如代码仓库），以及代码结构的基本信息（如多文件软件包的主文件）。软件包说明（package specification） 就是用来描述这些信息的。
</p>

<p>
当软件包仓库支持时（见《Emacs Lisp 参考手册》中的 “<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Package-Archives.html#Package-Archives">软件包仓库</a>”），Emacs 可以自动从该仓库下载软件包说明。如果传给 <code>package-vc-install</code> 的第一个参数是一个表示软件包名的符号，Emacs 就会使用仓库为该软件包提供的说明。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #b22222;">;; </span><span style="color: #b22222;">Emacs &#20250;&#20174; GNU ELPA &#19979;&#36733; BBDB &#30340;&#36719;&#20214;&#21253;&#35828;&#26126;&#65306;
</span>(package-vc-install 'bbdb)
</pre>
</div>

<p>
传给 <code>package-vc-install</code> 的第一个参数也可以是一个软件包说明。这允许你从用户选项 <code>package-archives</code> 列出的已知仓库之外的其他位置安装源码包。软件包说明是一个形如 <code>(name . spec)</code> 的列表，其中 <i>spec</i> 是一个属性列表，可使用下表中的任意关键字。
</p>

<p>
关于代码仓库与版本控制系统的基本术语定义，见《GNU Emacs 手册》中的 “<a href="#VCS-Concepts">VCS 概念</a>”。
</p>
<dl class="org-dl">
<dt><code>:url</code></dt><dd>字符串，指定获取软件包源码的仓库 URL。</dd>
<dt><code>:branch</code></dt><dd>字符串，指定要安装的代码修订版本。不要与软件包的版本号混淆。</dd>
<dt><code>:lisp-dir</code></dt><dd>字符串，相对于仓库根目录的 Lisp 源码加载目录，默认为仓库根目录。</dd>
<dt><code>:main-file</code></dt><dd>字符串，项目的主文件，用于提取软件包元数据。如果未指定，默认使用软件包名加上 ".el" 后缀。</dd>
<dt><code>:doc</code></dt><dd>字符串，相对于仓库根目录的文档文件，用于构建 Info 文件。可以是 Texinfo 文件或 Org 文件。</dd>
<dt><code>:make</code></dt><dd>字符串或字符串列表，指定仓库中 Makefile 里需要在构建 Info 文件之前运行的目标。仅当 <code>package-vc-allow-build-commands</code> 为非 nil 时生效。</dd>
<dt><code>:shell-command</code></dt><dd>字符串，指定在构建 Info 文件之前要运行的 shell 命令。仅当 <code>package-vc-allow-build-commands</code> 为非 nil 时生效。</dd>
<dt><code>:vc-backend</code></dt><dd>符号，指定用于下载软件包仓库的 VC 后端（见《GNU Emacs 手册》中的 “<a href="#Version-Control-Systems">版本控制系统</a>”）。如果省略，Emacs 会根据提供的 URL 尝试自动推断；若推断失败，则回退到 <code>package-vc-default-backend</code> 的值。</dd>
</dl>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #b22222;">;; </span><span style="color: #b22222;">&#25163;&#21160;&#25351;&#23450;&#20449;&#24687;&#31034;&#20363;&#65306;
</span>(package-vc-install
 '(bbdb <span style="color: #483d8b;">:url</span> <span style="color: #8b2252;">"https://git.savannah.nongnu.org/git/bbdb.git"</span>
        <span style="color: #483d8b;">:lisp-dir</span> <span style="color: #8b2252;">"lisp"</span>
        <span style="color: #483d8b;">:doc</span> <span style="color: #8b2252;">"doc/bbdb.texi"</span>))
</pre>
</div>
</div>
</div>
</div>
</section>
<section id="outline-container-Customization" class="outline-2">
<h2 id="Customization"><span class="section-number-2">51.</span> 定制</h2>
<div class="outline-text-2" id="text-Customization">
<p>
本章介绍几种自定义 Emacs 行为的简单方法。
</p>

<p>
除本章所述方法外，有关使用 X 资源自定义 Emacs 的信息，参见《<a href="#X-Resources">X 选项与资源</a>》；有关录制和重放键盘宏的信息，参见《<a href="#Keyboard-Macros">键盘宏</a>》。如需进行更深入、更灵活的修改，则需要编写 Emacs Lisp 代码，参见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/index.html#Top">Emacs Lisp</a>》。
</p>

<ul class="org-ul">
<li><a href="#Easy-Customization">简易自定义界面</a></li>
<li><a href="#Variables">变量</a></li>
<li><a href="#Key-Bindings">按键绑定自定义</a></li>
<li><a href="#Init-File">Emacs 初始化文件</a></li>
<li><a href="#Authentication">保存持久化认证信息</a></li>
</ul>
</div>
<div id="outline-container-Easy-Customization" class="outline-3">
<h3 id="Easy-Customization"><span class="section-number-3">51.1.</span> 简易自定义界面</h3>
<div class="outline-text-3" id="text-Easy-Customization">
<p>
Emacs 拥有大量可供修改的 <i>settings(设置)</i> 。绝大多数设置都是 <i>customizable variables(可自定义变量)</i> （参见 <a href="#Variables">变量</a>），也被称为 <i>user options用户选项</i> 。可自定义变量数量庞大，控制着 Emacs 行为的方方面面；本手册中记载的变量已收录在<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Variable-Index.html">变量索引里</a>。另一类独立的设置是 <i>faces(外观)</i> ，它们决定文本的字体、颜色及其他属性（参见 <a href="#Faces">文本外观</a>）。
</p>

<p>
若要浏览和修改设置（包括变量与外观），请输入 <code>M-x customize</code> 。该命令会创建一个 /customization buffer(自定义缓冲区)/，你可以在其中浏览按逻辑组织的设置列表，编辑并设置它们的值，还能永久保存修改。
</p>

<ul class="org-ul">
<li><a href="#Customization-Groups">自定义组</a></li>
<li><a href="#Browsing-Custom">浏览与搜索设置</a></li>
<li><a href="#Changing-a-Variable">修改变量</a></li>
<li><a href="#Saving-Customizations">保存自定义设置</a></li>
<li><a href="#Face-Customization">自定义外观</a></li>
<li><a href="#Specific-Customization">自定义特定项</a></li>
<li><a href="#Custom-Themes">自定义主题</a></li>
<li><a href="#Creating-Custom-Themes">创建自定义主题</a></li>
</ul>
</div>
<div id="outline-container-Customization-Groups" class="outline-4">
<h4 id="Customization-Groups"><span class="section-number-4">51.1.1.</span> 自定义组</h4>
<div class="outline-text-4" id="text-Customization-Groups">
<p>
自定义设置被组织到 <i>customization groups自定义组</i> 中。这些组又被归到更大的组里，一直向上汇总到一个名为 <code>Emacs</code> 的主组。
</p>

<p>
执行 <code>M-x customize</code> 会创建一个自定义缓冲区，显示顶层的 <code>Emacs</code> 组。它的部分内容大致如下：
</p>

<div class="org-src-container">
<pre class="src src-org">For help using this buffer, see [Easy Customization] in the [Emacs manual].

<span style="text-decoration: underline;">________________________________________</span> [ Search ]

 Operate on all settings in this buffer:
 [ Revert... ] [ Apply ] [ Apply and Save ]


Emacs group: Customization of the One True Editor.
      [State]: visible group members are all at standard values.
      See also [Manual].

[Editing]      Basic text editing facilities.
[Convenience]  Convenience features for faster editing.

...more second-level groups...

-----
&#22914;&#38656;&#20102;&#35299;&#27492;&#32531;&#20914;&#21306;&#30340;&#20351;&#29992;&#26041;&#27861;&#65292;&#35831;&#21442;&#38405;&#12298;Emacs &#25163;&#20876;&#12299;&#20013;&#30340; [&#31616;&#26131;&#33258;&#23450;&#20041;] &#31456;&#33410;&#12290;
<span style="text-decoration: underline;">________________________________________</span> [&#25628;&#32034;]
&#23545;&#26412;&#32531;&#20914;&#21306;&#20013;&#30340;&#25152;&#26377;&#35774;&#32622;&#25191;&#34892;&#25805;&#20316;&#65306;
[&#24674;&#22797;&#8230;] [ &#24212;&#29992; ] [ &#24212;&#29992;&#24182;&#20445;&#23384; ]
Emacs &#32452;&#65306;&#23545;&#21807;&#19968;&#30495;&#27491;&#32534;&#36753;&#22120;&#30340;&#33258;&#23450;&#20041;&#12290;
    [&#29366;&#24577;]&#65306;&#21487;&#35265;&#30340;&#32452;&#25104;&#21592;&#22343;&#20026;&#26631;&#20934;&#20540;&#12290;
    &#21478;&#35265; [&#25163;&#20876;]&#12290;

[Editing] &#22522;&#26412;&#25991;&#26412;&#32534;&#36753;&#21151;&#33021;&#12290;[&#20415;&#25463;] &#29992;&#20110;&#26356;&#24555;&#32534;&#36753;&#30340;&#20415;&#25463;&#29305;&#24615;&#12290;
&#8230;&#8230; &#26356;&#22810;&#20108;&#32423;&#32452;&#8230;&#8230;
</pre>
</div>

<p>
该缓冲区的主体部分显示 'Emacs' 自定义组，其中包含多个其他组（如 Editing「编辑」、Convenience「便捷」等）。这些组的内容不会在这里全部列出，只会显示一行说明文档。
</p>

<p>
组的 <b><i>state状态</i></b> 会表明该组内的设置是否已被编辑、设定或保存。参见 <a href="#Changing-a-Variable">修改变量</a>。
</p>

<p>
自定义缓冲区的大部分内容是 <b>只读</b> 的，但包含一些你可以编辑的 <i>editable fields可编辑区域</i> 。例如，自定义缓冲区顶部有一个用于搜索设置的可编辑区域（参见 <a href="#Browsing-Custom">浏览和搜索设置</a>）。缓冲区中还有 <i>button按钮</i> 和 <i>links链接</i> ，你可以通过鼠标点击，或将光标移到该处并按 <code>RET</code> 来激活。例如，像 '<code>[Editing]</code>' 这样的组名就是链接；激活其中一个链接会打开对应组的自定义缓冲区。
</p>

<p>
在自定义缓冲区中，你可以按 <code>TAB</code> (<code>widget-forward</code>) 向前跳到下一个按钮或可编辑区域。按 <code>S-TAB</code> (<code>widget-backward</code>) 向后跳回上一个按钮或可编辑区域。
</p>
</div>
</div>
<div id="outline-container-Browsing-Custom" class="outline-4">
<h4 id="Browsing-Custom"><span class="section-number-4">51.1.2.</span> 浏览与搜索设置</h4>
<div class="outline-text-4" id="text-Browsing-Custom">
<p>
在由 <code>M-x customize</code> 创建的顶层自定义缓冲区中，你可以通过链接进入 'Emacs' 自定义组的子组。这些子组中可能包含可供你自定义的设置；它们也可能包含更深层的子组，用于处理 Emacs 中更专门的子系统。在浏览自定义组的层级结构时，你可以找到想要自定义的设置。
</p>

<p>
如果你想要自定义某个特定的设置或自定义组，可以直接使用以下命令直达目标： <code>M-x customize-option</code> 、 <code>M-x customize-face</code> 或 <code>M-x customize-group</code> 。参见「<a href="#Specific-Customization">自定义特定项</a>」。
</p>

<p>
如果你不确定要自定义哪些组或设置，可以在每个自定义缓冲区顶部的 <b>可编辑搜索框</b> 中进行搜索。你可以在其中输入搜索词 —— 可以是一个或多个用空格分隔的单词，也可以是正则表达式（参见「<a href="#Regexps">正则表达式语法</a>」）。然后在搜索框中按 <code>RET</code> ，或点击旁边的「Search」（搜索）按钮，即可切换到一个新的自定义缓冲区，其中显示与这些关键词匹配的组和设置。但请注意：该功能只会搜索 <b>当前 Emacs 会话中已加载</b> 的组和设置。
</p>

<p>
如果你不希望自定义缓冲区显示搜索框，可将变量 <code>custom-search-field</code> 设为 <code>nil</code> 。
</p>

<p>
命令 <code>M-x customize-apropos</code> 与使用搜索框类似，区别在于它通过迷你缓冲区（minibuffer）读取搜索词。参见「<a href="#Specific-Customization">自定义特定项</a>」。
</p>

<p>
<code>M-x customize-browse</code> 是另一种浏览可用设置的方式。该命令会创建一个专用的自定义缓冲区，只以结构化布局显示组和设置的名称。你可以点击组名旁边的 '<code>[+]</code>' 按钮，在当前缓冲区中展开该组的内容；当内容展开后，按钮会变为 '<code>[-]</code>' ，再次点击即可隐藏内容。此缓冲区中的每个组或设置都带有 '<code>[Group]</code>' （组）、 '<code>[Option]</code>' （选项）或  '<code>[Face]</code>' （外观）链接。点击这些链接会创建一个普通的自定义缓冲区，专门显示该组、选项或外观 —— 这就是修改通过 <code>M-x customize-browse</code> 找到的设置的方法。
</p>
</div>
</div>
<div id="outline-container-Changing-a-Variable" class="outline-4">
<h4 id="Changing-a-Variable"><span class="section-number-4">51.1.3.</span> 修改变量</h4>
<div class="outline-text-4" id="text-Changing-a-Variable">
<p>
下面是变量（也叫用户选项）在自定义缓冲区中的显示示例：
</p>

<div class="org-src-container">
<pre class="src src-org">[Hide] Kill Ring Max: Integer (positive or zero): 120
   [State]: STANDARD.
   Maximum length of kill ring before oldest elements are thrown away.

-----
[&#38544;&#34255;] Kill Ring Max(&#21098;&#20999;&#29615;&#26368;&#22823;&#38271;&#24230;)&#65306;&#25972;&#25968;&#65288;&#27491;&#25968;&#25110;&#38646;&#65289;&#65306;120
    [&#29366;&#24577;]&#65306;&#26631;&#20934;&#12290;
    &#21098;&#20999;&#29615;&#30340;&#26368;&#22823;&#38271;&#24230;&#65292;&#36229;&#20986;&#21518;&#26368;&#26087;&#30340;&#20803;&#32032;&#20250;&#34987;&#20002;&#24323;&#12290;
</pre>
</div>

<p>
第一行显示变量名为 <code>kill-ring-max</code> ，为便于阅读格式化为 '<code>Kill Ring Max</code>' ，同时标明其预期类型：正整数或零。默认值为 '120' 。标有  '<code>[Hide]</code>' （隐藏）的按钮激活后会隐藏变量的值与状态；这在避免因值过长而挤满自定义缓冲区时很有用（正因如此，值很长的变量默认可能是隐藏状态）。点击 '<code>[Hide]</code>' 后，按钮会变为 '<code>[Show Value]</code>' （显示值），再次激活可重新显示值与状态。在图形界面下， '<code>[Hide]</code>' 和 '<code>[Show Value]</code>' 会分别替换为向下和向右的小三角图标。
</p>

<p>
变量名下方一行是该变量的 <b><i>customization state 自定义状态</i></b> ：本例中 'STANDARD' （标准）表示你尚未修改过该变量，使用的是默认值。 '<code>[State]</code>' （状态）按钮会弹出一个菜单，提供用于自定义该变量的操作。
</p>

<p>
状态行下方是变量的 <b>说明文档</b> ，与 <code>C-h v</code> 命令显示的内容一致（参见 “<a href="#Examining">查看与设置变量</a>”）。如果文档超过一行，可能只显示一行，该行末尾会有 '<code>[More]</code>' （更多）按钮；激活可查看完整文档。
</p>

<p>
要为 '<code>Kill Ring Max</code>' 输入新值，只需将光标移到值上直接编辑即可。例如，按 <code>M-d</code> 删除 120，再输入其他数字。当你开始修改文本时， '<code>[State]</code>' 行会变为：
</p>

<div class="org-src-container">
<pre class="src src-org">[State]: EDITED, shown value does not take effect until you
         set or save it.

-----
[&#29366;&#24577;]&#65306;&#24050;&#32534;&#36753;&#65292;&#25152;&#26174;&#31034;&#30340;&#20540;&#38656;&#35774;&#32622;&#25110;&#20445;&#23384;&#21518;&#25165;&#20250;&#29983;&#25928;&#12290;
</pre>
</div>

<p>
编辑值并 <b>不会立即生效</b> 。要使其生效，必须激活 '<code>[State]</code>' 按钮并选择 '<code>Set for Current Session</code>' 「为当前会话设置」。之后变量状态会变为：
</p>

<div class="org-src-container">
<pre class="src src-org">[State]: SET for current session only.

-----
[&#29366;&#24577;]&#65306;&#20165;&#23545;&#24403;&#21069;&#20250;&#35805;&#24050;&#35774;&#32622;&#12290;
</pre>
</div>

<p>
你不必担心输入无效值； '<code>Set for Current Session</code>' 「为当前会话设置」 会自动检查合法性，不会接受不合法的值。
</p>

<p>
在编辑某些类型的值（如文件名、目录名、Emacs 命令名）时，可以用 <code>C-M-i</code> (<code>widget-complete</code>) 或等价的 <code>M-TAB</code> / <code>ESC TAB</code> 进行补全，用法与迷你缓冲区补全类似（参见 “<a href="#Completion">补全</a>”）。
</p>

<p>
在可编辑值区域按 <code>RET</code> ，会像 <code>TAB</code> 一样将光标跳到下一个区域或按钮。编辑完一个区域后按 <code>RET</code> 即可继续下一项。要在可编辑区域内插入换行，使用 <code>C-o</code> 或 <code>C-q C-j</code> 。
</p>

<p>
有些变量只允许 <b>固定的合法值集合</b> ，不允许直接编辑。此时值前面会出现 '<code>[Value Menu]</code>' （值菜单）按钮，激活后可从列表中选择值。对于布尔 "on or off" 类型的值，按钮显示为 '<code>[Toggle]</code>' （切换），点击可翻转值。使用 '<code>[Value Menu]</code>' 或 '<code>[Toggle]</code>' 后，仍需再次设置变量才能让选中的值生效。
</p>

<p>
有些变量的值具有 <b>复杂结构</b> 。例如 <code>minibuffer-frame-alist</code> 的值是一个关联列表，它在自定义缓冲区中大致如下显示：
</p>

<div class="org-src-container">
<pre class="src src-org">[Hide] Minibuffer Frame Alist:
[INS] [DEL] Parameter: width
            Value: 80
[INS] [DEL] Parameter: height
            Value: 2
[INS]
   [ State ]: STANDARD.
   Alist of parameters for the initial minibuffer frame. [Hide]
   [&#8230;more lines of documentation&#8230;]

-----
[&#38544;&#34255;] &#23567;&#32531;&#20914;&#21306;&#26694;&#26550;&#20851;&#32852;&#21015;&#34920;&#65306;
[&#25554;&#20837;] [&#21024;&#38500;] &#21442;&#25968;&#65306;&#23485;&#24230;
             &#20540;&#65306;80
[&#25554;&#20837;] [&#21024;&#38500;] &#21442;&#25968;&#65306;&#39640;&#24230;
             &#20540;&#65306;2
[&#25554;&#20837;]
    [&#29366;&#24577;]&#65306;&#26631;&#20934;&#12290;
    &#21021;&#22987;&#23567;&#32531;&#20914;&#21306;&#26694;&#26550;&#30340;&#21442;&#25968;&#20851;&#32852;&#21015;&#34920;&#12290;[&#38544;&#34255;]
    [&#8230;&#8230; &#26356;&#22810;&#25991;&#26723;&#34892;&#8230;&#8230;]
</pre>
</div>

<p>
这种情况下，列表中的每一项关联都由 '<code>Parameter</code>' 「参数」和 '<code>Value</code>' 「值」两部分组成，两者都是可编辑区域。你可以用旁边的 '<code>[DEL]</code>' （删除）按钮删除某条关联；用对应位置的 '<code>[INS]</code>' （插入）按钮添加新关联，最后一个 '<code>[INS]</code>' 会在列表末尾插入。
</p>

<p>
设置一个变量后，新值 <b>只在当前 Emacs 会话生效</b> 。要将值保存以便未来会话使用，需通过 '<code>[State]</code>' 按钮选择 '<code>Save for Future Sessions</code>' 「为未来会话保存」。参见 “<a href="#Saving-Customizations">保存自定义设置</a>”。
</p>

<p>
你也可以通过 '<code>[State]</code>' 按钮选择 '<code>Erase Customization</code>' 「清除自定义」，将变量恢复为标准值。实际上共有四种重置操作：
</p>
<dl class="org-dl">
<dt>'<code>Undo Edits</code>'</dt><dd>「撤销编辑」如果你修改了变量但尚未设置，此操作会将自定义缓冲区中的文本恢复为实际当前值。</dd>
<dt>'<code>Revert This Session's Customizations</code>'</dt><dd>「恢复此会话的自定义」将变量值恢复到上一次保存的值（如果有），否则恢复为标准值，并同步更新缓冲区文本。</dd>
<dt>'<code>Erase Customization</code>'</dt><dd>「清除自定义」将变量设为标准值，并 <b>删除你之前保存过的值</b> 。</dd>
<dt>'<code>Set to Backup Value</code>'</dt><dd>「设为备份值」将变量恢复为本会话中在自定义缓冲区里 <b>曾经设置过的旧值</b> 。如果你自定义过一个变量又重置丢弃了它，可以用此操作找回。</dd>
</dl>

<p>
有时需要为某条自定义 <b>记录注释</b> 。可从 '<code>[State]</code>' 菜单中选择 '<code>Add Comment</code>' 「添加注释」，创建一个用于输入注释的区域。
</p>

<p>
自定义缓冲区顶部附近有两行按钮：
</p>
<div class="org-src-container">
<pre class="src src-org"> Operate on all settings in this buffer:
 [Revert...] [Apply] [Apply and Save]

 -----
&#23545;&#26412;&#32531;&#20914;&#21306;&#20013;&#25152;&#26377;&#35774;&#32622;&#25191;&#34892;&#25805;&#20316;&#65306;
[&#24674;&#22797;&#8230;] [&#24212;&#29992;] [&#24212;&#29992;&#24182;&#20445;&#23384;]
</pre>
</div>

<p>
'<code>[Revert...]</code>' （恢复…）按钮会弹出菜单，包含上面提到的前三种重置操作。 '<code>[Apply]</code>' （应用）按钮为 <b>当前会话应用</b> 所有设置。 '<code>[Apply and Save]</code>' （应用并保存）按钮会应用设置并 <b>保存到未来会话</b> ；如果 Emacs 以 '<code>-q</code>' 或 '<code>-Q</code>' 参数启动（参见 “<a href="#Initial-Options">初始选项</a>”），则不会显示此按钮。
</p>

<p>
命令 <code>C-c C-c</code> (<code>Custom-set</code>) 等价于点击 '<code>[Set for Current Session]</code>' 「为当前会话设置」。命令 <code>C-x C-s</code> (<code>Custom-save</code>) 等价于点击 '<code>[Save for Future Sessions]</code>' 「为未来会话保存」。
</p>

<p>
'<code>[Exit]</code>' （退出）按钮会退出自定义缓冲区，并将缓冲区放到缓冲区列表底部。若想让它直接 <b>杀死</b> 自定义缓冲区，可将变量 <code>custom-buffer-done-kill</code> 设为 <code>t</code> 。
</p>
</div>
</div>
<div id="outline-container-Saving-Customizations" class="outline-4">
<h4 id="Saving-Customizations"><span class="section-number-4">51.1.4.</span> 保存自定义设置</h4>
<div class="outline-text-4" id="text-Saving-Customizations">
<p>
在自定义缓冲区中，你可以通过变量的 '<code>[State]</code>' （状态）按钮选择 '<code>Save for Future Sessions</code>' 「为未来会话保存」 来保存该项自定义设置。命令 <code>C-x C-s</code> (<code>Custom-save</code>)，或是自定义缓冲区顶部的 '<code>[Apply and Save]</code>' 「应用并保存」 按钮，会保存缓冲区中所有可生效的设置。
</p>

<p>
保存的原理是将配置代码写入一个文件，通常是你的 <b>initialization file初始化文件</b> （参见《<a href="#Init-File">Emacs 初始化文件</a>》）。之后的 Emacs 会话会在启动时自动读取该文件，重新应用这些自定义设置。
</p>

<p>
你可以选择将自定义设置保存在初始化文件以外的其他位置。要实现这一点，必须在初始化文件中添加几行代码：将变量 <code>custom-file</code> 设置为你想要的文件路径，并加载该文件。例如：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq</span> custom-file <span style="color: #8b2252;">"~/.config/emacs-custom.el"</span>)
(load custom-file)
</pre>
</div>

<p>
你甚至可以为不同版本的 Emacs 指定不同的自定义文件，示例如下：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">cond</span> ((&lt; emacs-major-version 28)
       <span style="color: #b22222;">;; </span><span style="color: #b22222;">Emacs 27 &#29256;&#26412;&#30340;&#33258;&#23450;&#20041;&#25991;&#20214;
</span>       (<span style="color: #a020f0;">setq</span> custom-file <span style="color: #8b2252;">"~/.config/custom-27.el"</span>))
      ((<span style="color: #a020f0;">and</span> (= emacs-major-version 26)
            (&lt; emacs-minor-version 3))
       <span style="color: #b22222;">;; </span><span style="color: #b22222;">Emacs 26 &#29256;&#26412;&#65288;26.3 &#20043;&#21069;&#65289;&#30340;&#33258;&#23450;&#20041;&#25991;&#20214;
</span>       (<span style="color: #a020f0;">setq</span> custom-file <span style="color: #8b2252;">"~/.config/custom-26.el"</span>))
      (t
       <span style="color: #b22222;">;; </span><span style="color: #b22222;">Emacs 28.1 &#21450;&#26356;&#39640;&#29256;&#26412;
</span>       (<span style="color: #a020f0;">setq</span> custom-file <span style="color: #8b2252;">"~/.config/emacs-custom.el"</span>)))

(load custom-file)
</pre>
</div>

<p>
如果 Emacs 是以 '<code>-q</code>' 或 '<code>--no-init-file</code>' 参数启动的（参见《<a href="#Initial-Options">初始选项</a>》），它将 <b>不允许</b> 你把自定义设置保存到初始化文件中。这是因为在这种会话下保存自定义设置，会覆盖掉你原本初始化文件里的其他所有配置。
</p>

<p>
请注意： <b>任何没有选择为未来会话保存的自定义设置，在退出 Emacs 后都会丢失</b> 。如果你希望在退出时收到 “有未保存的自定义设置” 的提醒，可以在初始化文件中添加以下代码：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'kill-emacs-query-functions
          'custom-prompt-customize-unsaved-options)
</pre>
</div>
</div>
</div>
<div id="outline-container-Face-Customization" class="outline-4">
<h4 id="Face-Customization"><span class="section-number-4">51.1.5.</span> 自定义外观</h4>
<div class="outline-text-4" id="text-Face-Customization">
<p>
你可以自定义外观（face）（见<a href="#Faces">文本外观</a>），它决定 Emacs 如何显示不同类型的文本。自定义组中可以同时包含变量和外观。
</p>

<p>
例如，在编程语言模式下，源代码注释使用 <code>font-lock-comment-face</code> 显示（见<a href="#Font-Lock">字体锁定模式</a>）。在自定义缓冲区中，点击 '<code>[Show All Attributes]</code>' 「[显示全部属性]」链接后，该外观大致如下所示：
</p>

<div class="org-src-container">
<pre class="src src-org">[Hide] Font Lock Comment Face:[sample]
   [State] : STANDARD.
   Font Lock mode face used to highlight comments.
   [ ] Font Family: --
   [ ] Font Foundry: --
   [ ] Width: --
   [ ] Height: --
   [ ] Weight: --
   [ ] Slant: --
   [ ] Underline: --
   [ ] Overline: --
   [ ] Strike-through: --
   [ ] Box around text: --
   [ ] Inverse-video: --
   [X] Foreground: Firebrick     [Choose]  (sample)
   [ ] Background: --
   [ ] Stipple: --
   [ ] Inherit: --
   [Hide Unused Attributes]

----

[&#38544;&#34255;] &#23383;&#20307;&#38145;&#23450;&#27880;&#37322;&#22806;&#35266;&#65306;[&#31034;&#20363;]
    [&#29366;&#24577;]&#65306;&#26631;&#20934;&#12290;
    &#23383;&#20307;&#38145;&#23450;&#27169;&#24335;&#20013;&#29992;&#20110;&#39640;&#20142;&#27880;&#37322;&#30340;&#22806;&#35266;&#12290;
    [ ] &#23383;&#20307;&#26063;&#65306;--
    [ ] &#23383;&#20307;&#38136;&#36896;&#21378;&#65306;--
    [ ] &#23485;&#24230;&#65306;--
    [ ] &#39640;&#24230;&#65306;--
    [ ] &#31895;&#32454;&#65306;--
    [ ] &#20542;&#26012;&#65306;--
    [ ] &#19979;&#21010;&#32447;&#65306;--
    [ ] &#19978;&#21010;&#32447;&#65306;--
    [ ] &#21024;&#38500;&#32447;&#65306;--
    [ ] &#25991;&#26412;&#22806;&#26694;&#65306;--
    [ ] &#21453;&#33394;&#65306;--
    [X] &#21069;&#26223;&#33394;&#65306;&#30742;&#32418;&#33394; [&#36873;&#25321;] (&#31034;&#20363;)
    [ ] &#32972;&#26223;&#33394;&#65306;--
    [ ] &#28857;&#30011;&#22270;&#26696;&#65306;--
    [ ] &#32487;&#25215;&#65306;--
    [&#38544;&#34255;&#26410;&#20351;&#29992;&#23646;&#24615;]
</pre>
</div>

<p>
前三行显示外观名称、'<code>[State]</code>' 「[状态]」按钮和外观说明。下方是 <i>face attributes外观属性</i> 列表。每个属性前面都有一个复选框：
</p>
<ul class="org-ul">
<li>勾选框 '<code>[X]</code>' 表示该外观为此属性指定了值；</li>
<li>空复选框 '<code>[ ]</code>' 表示该外观未为此属性指定特殊值。你可以激活复选框来设定或取消设定对应属性。</li>
</ul>

<p>
一个外观不必指定每一个属性；事实上，大多数外观只指定少数几个属性。在上例中， <code>font-lock-comment-face</code> 只指定了前景色。任何未指定的属性都会从名为 <code>default</code> 的特殊外观中继承，而 <code>default</code> 外观的所有属性都是完整指定的。 <code>default</code> 外观用于显示没有显式指定外观的文本；此外，它的背景色属性同时作为框架的背景色。
</p>

<p>
属性列表末尾的 '<code>[Hide Unused Attributes]</code>' 「[隐藏未使用属性]」按钮会隐藏该外观未设定的属性。当属性被隐藏时，按钮会变为 '<code>[Show All Attributes]</code>' 「[显示全部属性]」，点击可重新显示完整属性列表。自定义缓冲区在初始时可能会隐藏未设定的属性，避免界面杂乱。
</p>

<p>
当某个属性被设定后，你可以用常规方式修改它的值。
</p>

<p>
<i>Foreground 前景色</i> 和 <i>background colors 背景色</i> 既可以用颜色名指定，也可以用 RGB 三元组指定（见<a href="#Colors">外观颜色</a>）。你也可以使用 '<code>[Choose]</code>' 「[选择]」按钮切换到颜色名列表；在该缓冲区中用回车选中一个颜色，颜色名就会填入值区域。
</p>

<p>
外观的设置、保存和重置操作与变量的对应操作完全相同（见<a href="#Changing-a-Variable">修改变量</a>）。
</p>

<p>
一个外观可以为不同类型的显示器指定不同的显示效果。例如，同一个外观可以在彩色显示器上让文字显示为红色，在单色显示器上使用粗体。要为一个外观指定多种显示效果，可以在 '<code>[State]</code>' 「[状态]」按钮的菜单中选择 '<code>For All Kinds of Displays</code>' 「适用于所有类型显示器」。
</p>
</div>
</div>
<div id="outline-container-Specific-Customization" class="outline-4">
<h4 id="Specific-Customization"><span class="section-number-4">51.1.6.</span> 自定义特定项</h4>
<div class="outline-text-4" id="text-Specific-Customization">
<dl class="org-dl">
<dt><code>M-x customize-option RET option RET</code></dt><dd></dd>

<dt><code>M-x customize-variable RET option RET</code></dt><dd>只为单个 <i>user option用户选项</i> 创建自定义缓冲区。</dd>
<dt><code>M-x customize-face RET face RET</code></dt><dd>只为单个 <i>face外观</i> 创建自定义缓冲区。</dd>
<dt><code>M-x customize-icon RET face RET</code></dt><dd>只为单个 <i>icon图标</i> 创建自定义缓冲区。</dd>
<dt><code>M-x customize-group RET group RET</code></dt><dd>只为单个自定义 <i>group组</i> 创建自定义缓冲区。</dd>
<dt><code>M-x customize-apropos RET regexp RET</code></dt><dd>为所有匹配该 <i>regexp正则表达式</i> 的设置和组创建自定义缓冲区。</dd>
<dt><code>M-x customize-changed RET version RET</code></dt><dd>创建自定义缓冲区，显示自指定 Emacs 版本以来 <b>含义发生变化或新增</b> 的所有用户选项、外观和组。</dd>
<dt><code>M-x customize-saved</code></dt><dd>创建包含 <b>所有已保存设置</b> 的自定义缓冲区。</dd>
<dt><code>M-x customize-unsaved</code></dt><dd>创建包含 <b>所有已设置但未保存</b> 的设置的自定义缓冲区。</dd>
</dl>

<p>
如果你想自定义某个特定用户选项，输入 <code>M-x customize-option</code> 。该命令会读取变量名，并只为这一个用户选项创建自定义缓冲区。在迷你缓冲区中输入变量名时支持补全，但只对已加载到 Emacs 中的变量名生效。
</p>

<p>
同理，你可以用 <code>M-x customize-face</code> 自定义特定外观，用 <code>M-x customize-group</code> 为特定自定义组打开自定义缓冲区。
</p>

<p>
<code>M-x customize-apropos</code> 会提示输入搜索词（可以是空格分隔的单词，或正则表达式），并为所有 <b>已加载</b> 且名称匹配的设置和组创建自定义缓冲区。这与自定义缓冲区顶部的搜索框功能类似（见<a href="#Customization-Groups">自定义组</a>）。
</p>

<p>
当你升级到新的 Emacs 版本时，可能想查看新增的设置，或含义、默认值发生变化的设置。使用 <code>M-x customize-changed</code> 并在迷你缓冲区中输入旧版本号即可。它会创建自定义缓冲区，显示自该版本以来定义发生变化的所有设置和组，并在需要时自动加载它们。
</p>

<p>
如果你修改了设置后想重新查看或撤销，可以使用以下两个命令：
</p>
<ul class="org-ul">
<li>使用 <code>M-x customize-saved</code> 查看并编辑已保存的设置。</li>
<li>使用 <code>M-x customize-unsaved</code> 查看并编辑已设置但未保存的设置。</li>
</ul>
</div>
</div>
<div id="outline-container-Custom-Themes" class="outline-4">
<h4 id="Custom-Themes"><span class="section-number-4">51.1.7.</span> 自定义主题</h4>
<div class="outline-text-4" id="text-Custom-Themes">
<p>
<i>Custom themes自定义主题</i> 是可以 <b>整体启用或禁用</b> 的设置集合。你可以用自定义主题在多套配置间快速切换，也能把整套配置从一台电脑迁移到另一台。
</p>

<p>
一个自定义主题以一份 Emacs Lisp 源文件的形式存储。如果主题名为 <i>name</i> ，对应的主题文件就是 <code>name-theme.el</code> 。关于主题文件的格式与创建方法，参见「<a href="#Creating-Custom-Themes">创建自定义主题</a>」。
</p>

<p>
输入 <code>M-x customize-themes</code> 可进入名为 <code>*Custom Themes*</code> 的缓冲区，其中列出 Emacs 能识别的所有自定义主题。默认情况下，Emacs 会在两个位置查找主题文件：
</p>
<ul class="org-ul">
<li>变量 <code>custom-theme-directory</code> 指定的目录（默认为 <code>~/.emacs.d/</code> ）</li>
<li>Emacs 安装目录下的 <code>etc/themes</code> 目录（参见变量 <code>data-directory</code> ）</li>
</ul>

<p>
后者包含随 Emacs 分发的若干自带主题，主要用于修改外观以适配不同配色方案。（注意：自定义主题 <b>不局限于</b> 修改外观，也可以用来修改变量。）
</p>

<p>
如果你希望 Emacs 在其他目录查找自定义主题，把目录加入列表变量 <code>custom-theme-load-path</code> 即可。它的默认值是 <code>(custom-theme-directory t)</code> ：符号 <code>custom-theme-directory</code> 代表变量 <code>custom-theme-directory</code> 的实际路径，符号 <code>t</code> 代表内置主题目录 <code>etc/themes</code> 。 <code>*Custom Themes*</code> 缓冲区里列出的，就是在 <code>custom-theme-load-path</code> 路径下找到的所有主题。
</p>

<p>
在 <code>*Custom Themes*</code> 缓冲区中，你可以勾选 / 取消勾选一个自定义主题旁边的复选框，为 <b>当前 Emacs 会话</b> 启用或禁用该主题。启用一个自定义主题后，它的所有设置（变量和外观）都会在会话中生效。要把选中的主题应用到 <b>未来所有 Emacs 会话</b> ，输入 <code>C-x C-s</code> (<code>custom-theme-save</code>) 或点击 '<code>[Save Theme Settings]</code>' 「[保存主题设置]」按钮。
</p>

<p>
<b>首次启用</b> 一个自定义主题时，Emacs 会显示主题文件内容，并询问你是否确定加载。因为加载主题可能执行任意 Lisp 代码， <b>只应加载你确认安全的主题</b> 。如果安全，Emacs 会提供 “以后记住该主题可信” 的选项（通过把文件的 SHA-256 哈希保存到变量 <code>custom-safe-themes</code> 实现）。如果你想把 <b>所有主题</b> 都视为安全，可将该变量设为 <code>t</code> 。Emacs 自带主题（位于 <code>etc/themes</code> 下）不受此检查限制，永远被视为安全。
</p>

<p>
设置或保存自定义主题，本质上是在修改变量 <code>custom-enabled-themes</code> 。该变量的值是一个 <b>已启用主题名称列表</b> （以 Lisp 符号形式，如 <code>tango</code> ）。你也可以不使用 <code>*Custom Themes*</code> 缓冲区，而是用普通自定义界面（如 <code>M-x customize-option</code> ）直接修改这个变量。注意：自定义主题 <b>不允许</b> 自行设置 <code>custom-enabled-themes</code> 。
</p>

<p>
你通过自定义缓冲区做的任何修改， <b>优先级高于</b> 主题设置。这让你可以轻松覆盖主题中不满意的个别配置。如果两个不同主题的设置冲突，在 <code>custom-enabled-themes</code> 列表中靠前的主题优先。在自定义缓冲区中，如果某项设置被主题从默认值修改过，它的 '<code>State</code>' 「状态」会显示为 '<code>THEMED</code>' （已应用主题），而不是 '<code>STANDARD</code>' （标准）。
</p>

<p>
你可以在当前 Emacs 会话中直接启用某个特定主题：
</p>
<ul class="org-ul">
<li><code>M-x load-theme</code> ：提示输入主题名，从文件加载并启用。</li>
<li><code>M-x enable-theme</code> ：如果某主题文件已加载过，可直接启用而不重新加载文件。</li>
<li><code>M-x disable-theme</code> ：禁用一个自定义主题。</li>
</ul>

<p>
要查看某个自定义主题的说明：
</p>
<ul class="org-ul">
<li>在 <code>*Custom Themes*</code> 缓冲区中，将光标移到对应行按 =?=；</li>
<li>或在任意位置输入 <code>M-x describe-theme</code> 并输入主题名</li>
</ul>

<p>
部分主题提供变体（最常见是浅色、深色两种）。你可以用 <code>M-x theme-choose-variant</code> 切换到另一变体：
</p>
<ul class="org-ul">
<li>如果当前激活主题只有一个变体，会直接切换</li>
<li>如果有多个变体，命令会提示你选择哪一个</li>
</ul>

<p>
注意： <code>theme-choose-variant</code> 只在 <b>同时只激活一个主题</b> 时有效。
</p>
</div>
</div>
<div id="outline-container-Creating-Custom-Themes" class="outline-4">
<h4 id="Creating-Custom-Themes"><span class="section-number-4">51.1.8.</span> 创建自定义主题</h4>
<div class="outline-text-4" id="text-Creating-Custom-Themes">
<p>
你可以使用与自定义缓冲区类似的界面来定义自定义主题，输入 <code>M-x customize-create-theme</code> 。该命令会切换到名为 <code>*Custom Theme*</code> 的缓冲区，并会询问是否要在主题中插入一些常用的 Emacs 外观（face）（这是一个便捷选项，因为自定义主题常用来配置外观）。如果你选择否，主题初始将不包含任何设置。
</p>

<p>
在 <code>*Custom Theme*</code> 缓冲区顶部附近，有可编辑区域，你可以在这里输入 <b>主题名称</b> 和 <b>主题描述</b> 。名称可以是除 'user' 以外的任意名称。描述会在你对该主题执行 <code>M-x describe-theme</code> 时显示，其第一行应为简短的单句摘要；在 <code>M-x customize-themes</code> 打开的缓冲区中，这句话会显示在主题名称旁边。
</p>

<p>
要向主题添加新设置，可以使用 '<code>[Insert Additional Face]</code>' 「插入额外外观」 或 '<code>[Insert Additional Variable]</code>' 「插入额外变量」 按钮。每个按钮都会通过小缓冲区读取外观或变量名（支持补全），并插入对应外观或变量的自定义条目。你可以像在普通自定义缓冲区中一样修改变量值或外观属性。要从主题中移除某个外观或变量，取消其名称旁边的复选框即可。
</p>

<p>
指定好主题的外观和变量后，输入 <code>C-x C-s</code> (<code>custom-theme-write</code>) 或使用缓冲区中的 '<code>[Save Theme]</code>' 「保存主题」 按钮。这会将主题文件以 <i>name</i>-theme.el 的格式保存在 <code>custom-theme-directory</code> 指定的目录中。
</p>

<p>
在 <code>*Custom Theme*</code> 缓冲区中，你可以通过激活 '<code>[Visit Theme]</code>' 「访问主题」 按钮并指定主题名，来查看和编辑已有的自定义主题。你也可以使用 '<code>[Merge Theme]</code>' 「合并主题」 按钮，将另一个主题的设置导入当前缓冲区。通过 '<code>[Merge Theme]</code>' 「合并主题」 按钮并指定特殊主题 'user' ，可以将你非主题形式的自定义设置导入到一个自定义主题中。
</p>

<p>
主题文件本质上就是一个 Emacs Lisp 源文件，加载自定义主题就是加载该 Lisp 文件。因此，你也可以直接编辑主题文件，而不使用 <code>*Custom Theme*</code> 缓冲区。详情参见《Emacs Lisp 参考手册》中的 “<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Custom-Themes.html#Custom-Themes">自定义主题</a>” 章节。
</p>
</div>
</div>
</div>
<div id="outline-container-Variables" class="outline-3">
<h3 id="Variables"><span class="section-number-3">51.2.</span> 变量</h3>
<div class="outline-text-3" id="text-Variables">
<p>
<i>variable 变量</i> 是一个拥有值的 Lisp 符号（symbol），该符号的名称也称为 <i>variable  name变量名</i> 。变量名可以包含文件名中允许的任意字符，但绝大多数变量名由普通单词加连字符分隔构成。
</p>

<p>
变量名本身简要说明了它的作用。大多数变量还附带 <b><i>documentation string文档字符串</i></b> ，用于说明：
</p>
<ul class="org-ul">
<li>变量的用途</li>
<li>应该接受什么类型的值</li>
<li>该值会如何被使用。你可以使用帮助命令 <code>C-h v</code> (<code>describe-variable</code>) 查看这份文档。参见「<a href="#Examining">查看与设置变量</a>」。</li>
</ul>

<p>
Emacs 内部使用大量 Lisp 变量来记录状态，但对普通用户最有意义的，是那些 <b>允许用户修改</b> 的变量 —— 它们被称为 <b><i>customizable variables 可自定义变量</i></b> 或 <b><i>user options用户选项</i></b> （见<a href="#Easy-Customization">简易自定义界面</a>）。在接下来的小节中，我们会介绍 Emacs 变量的其他用法，例如如何在自定义界面之外设置变量。
</p>

<p>
Emacs Lisp 中，除少数例外， <b>任何变量都可以接受任意类型的值</b> 。但很多变量只有在被赋予 <b>特定类型</b> 的值时才有意义。例如， <code>kill-ring-max</code> （用于指定剪切环最大长度）只接受数字；如果你给它赋一个字符串， <code>C-y</code> (<code>yank</code>) 等命令就会报错。
</p>

<p>
另一方面，有些变量 <b>不关心类型</b> ：比如某个变量在值为 <code>nil</code> 时有一种效果，非 nil 时有另一种效果。那么任何不是符号 nil 的值都会触发第二种效果，无论它本身是什么类型。按照惯例，我们通常用符号 <code>t</code> （表示 “true”）来表示非 nil 值。
</p>

<p>
如果你通过 <b>自定义缓冲区</b> 设置变量，就不用担心类型不合法：自定义界面通常只允许你输入有意义的值。如有疑问，可用 <code>C-h v</code> 查看变量的文档字符串，确认它期望的类型。
</p>

<ul class="org-ul">
<li><a href="#Examining">查看与设置变量</a></li>
<li><a href="#Hooks">钩子</a></li>
<li><a href="#Locals">局部变量</a></li>
<li><a href="#File-Variables">文件中的局部变量</a></li>
<li><a href="#Directory-Variables">目录级局部变量</a></li>
<li><a href="#Connection-Variables">连接级局部变量</a></li>
</ul>
</div>
<div id="outline-container-Examining" class="outline-4">
<h4 id="Examining"><span class="section-number-4">51.2.1.</span> 查看与设置变量</h4>
<div class="outline-text-4" id="text-Examining">
<dl class="org-dl">
<dt><code>C-h v var RET</code></dt><dd>显示变量 <i>var</i> 的值与文档 (<code>describe-variable</code>)。</dd>
<dt><code>M-x set-variable RET var RET value RET</code></dt><dd>将变量 <i>var</i> 的值修改为 <i>value新值</i> 。</dd>
</dl>

<p>
要查看一个变量的值，使用 <code>C-h v</code> (<code>describe-variable</code>)。它会通过迷你缓冲区读取变量名（支持补全），并显示该变量的值和文档。例如：
</p>

<div class="org-src-container">
<pre class="src src-shell">C-h v fill-column RET
</pre>
</div>

<p>
会显示类似如下内容：
</p>

<div class="org-src-container">
<pre class="src src-org">fill-column is a variable defined in &#8216;C source code&#8217;.
Its value is 70

  Automatically becomes buffer-local when set.
  This variable is safe as a file local variable if its value
  satisfies the predicate &#8216;integerp&#8217;.
  Probably introduced at or before Emacs version 18.

Documentation:
Column beyond which automatic line-wrapping should happen.
Interactively, you can set the buffer local value using C-x f.

You can customize this variable.

-----
fill-column &#26159;&#22312;&#8216;C &#28304;&#20195;&#30721;&#8217;&#20013;&#23450;&#20041;&#30340;&#21464;&#37327;&#12290;
&#23427;&#30340;&#20540;&#26159; 70

  &#35774;&#32622;&#26102;&#33258;&#21160;&#21464;&#20026;&#32531;&#20914;&#21306;&#23616;&#37096;&#21464;&#37327;&#12290;
  &#22914;&#26524;&#35813;&#21464;&#37327;&#30340;&#20540;&#28385;&#36275;&#35859;&#35789;&#8216;integerp&#8217;&#65292;&#21017;&#23427;&#21487;&#20197;&#23433;&#20840;&#22320;&#20316;&#20026;&#25991;&#20214;&#23616;&#37096;&#21464;&#37327;&#12290;
  &#22823;&#27010;&#22312; Emacs 18 &#29256;&#25110;&#26356;&#26089;&#24341;&#20837;&#12290;

&#25991;&#26723;&#65306;
&#36229;&#36807;&#35813;&#21015;&#26102;&#33258;&#21160;&#36827;&#34892;&#25442;&#34892;&#12290;
&#20132;&#20114;&#20351;&#29992;&#26102;&#65292;&#20320;&#21487;&#20197;&#29992; C-x f &#35774;&#32622;&#32531;&#20914;&#21306;&#23616;&#37096;&#20540;&#12290;

&#20320;&#21487;&#20197;&#33258;&#23450;&#20041;&#27492;&#21464;&#37327;&#12290;
</pre>
</div>

<p>
显示 “You can customize the variable 这一行，说明该变量是 <b>用户选项</b> 。 <code>C-h v</code> 并不限于用户选项，也可以查看非自定义变量。
</p>

<p>
设置某个可自定义变量最方便的方式是使用 <code>M-x set-variable</code> 。它先通过迷你缓冲区读取变量名（支持补全），再通过迷你缓冲区第二次读取表示新值的 Lisp 表达式（你可以用 <code>M-n</code> 将旧值插入小缓冲区进行编辑）。例如：
</p>

<div class="org-src-container">
<pre class="src src-shell">M-x set-variable RET fill-column RET 75 RET
</pre>
</div>

<p>
将 <code>fill-column</code> 设置为 75。
</p>

<p>
<code>M-x set-variable</code> 只适用于可自定义变量，但你可以用 Lisp 表达式设置任意变量，例如：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq</span> fill-column 75)
</pre>
</div>

<p>
要执行这样的表达式，输入 <code>M-:</code> (<code>eval-expression</code>)，并在迷你缓冲区中输入表达式（见 “<a href="#Lisp-Eval">执行 Emacs Lisp 表达式</a>”）。或者进入 <code>*scratch*</code> 缓冲区，输入表达式后按 <code>C-j</code> （见 “<a href="#Lisp-Interaction">Lisp 交互缓冲区</a>”）。
</p>

<p>
与所有自定义 Emacs 的方式一样（除非另有说明），设置变量 <b>只影响当前 Emacs 会话</b> 。要让变量在未来会话中生效，唯一的方法是把配置写到 <b>初始化文件</b> 中（见 “<a href="#Init-File">Emacs 初始化文件</a>”）。
</p>

<p>
如果你要在初始化文件中设置可自定义变量，且不想使用 <code>Customize</code> 界面，可以使用 <code>setopt</code> 宏。例如：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setopt</span> fill-column 75)
</pre>
</div>

<p>
它的效果和 <code>setq</code> 一样，但如果该变量有专门的设置函数，使用 <code>setopt</code> 时会 <b>自动运行</b> 这些函数。你也可以对非自定义变量使用 <code>setopt</code> ，但效率会比 <code>setq</code> 低。
</p>
</div>
</div>
<div id="outline-container-Hooks" class="outline-4">
<h4 id="Hooks"><span class="section-number-4">51.2.2.</span> 钩子</h4>
<div class="outline-text-4" id="text-Hooks">
<p>
<i>Hooks钩子</i> 是自定义 Emacs 的重要机制。钩子是一个 Lisp 变量，里面保存着一组函数，会在某个预先定义好的时机被调用（这一过程称为 <i>running the hook运行钩子</i> ）。列表里的每个函数，都称为该钩子的 <b><i>hook functions钩子函数</i></b> 。例如，钩子 <code>kill-emacs-hook</code> 会在 <b>即将退出 Emacs</b> 时运行（参见 “<a href="#Exiting">退出 Emacs</a>”）。
</p>

<p>
大多数钩子都是 <b><i>normal hooks普通钩子</i></b> 。这意味着 Emacs 运行钩子时，会 <b>依次调用每个钩子函数，且不传递任何参数</b> 。我们尽量让大部分钩子都是普通钩子，以便你能用统一的方式使用它们。所有以 '<code>-hook'</code> 结尾的变量都是普通钩子。
</p>

<p>
少数钩子是 <b>非普通钩子</b> 。它们的名字以 '<code>-functions</code>' 结尾，而不是 '<code>-hook</code>' （一些旧代码可能还在使用已废弃的后缀 '<code>-hooks</code>' ）。这类钩子之所以 “非普通”，是因为函数的调用方式不同：可能会传入参数，或者返回值会被特殊处理。例如， <code>find-file-not-found-functions</code> 就是非普通钩子，因为只要有一个钩子函数返回非 nil 值，剩下的函数就 <b>不再执行</b> （参见 “<a href="#Visiting">访问文件</a>”）。每个非普通钩子变量的文档都会说明其函数的具体调用方式。
</p>

<p>
你可以像设置其他 Lisp 变量一样，用 <code>setq</code> 设置钩子变量，但 <b>推荐</b> 使用 <code>add-hook</code> 向钩子（无论普通或非普通）中添加函数，如下例所示。详情参见《Emacs Lisp 参考手册》中的 “<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Hooks.html#Hooks">Hooks</a>” 章节。
</p>

<p>
大多数 <b>主模式</b> 都会在初始化的最后一步运行一个或多个 <b><i>mode hooks模式钩子</i></b> 。模式钩子是自定义单个模式行为的便捷方式，它们 <b>永远是普通钩子</b> 。例如，下面的代码可以在 Text 模式及其派生模式中自动开启自动换行模式：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'text-mode-hook 'auto-fill-mode)
</pre>
</div>

<p>
它的原理是调用 <code>auto-fill-mode</code> ，不提供参数时会启用该次要模式（参见 “<a href="#Minor-Modes">次要模式</a>”）。接下来，假设你不希望在 LaTeX 模式（Text 模式的派生模式）中开启自动换行，可以再加一行：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'latex-mode-hook (<span style="color: #a020f0;">lambda</span> () (auto-fill-mode -1)))
</pre>
</div>

<p>
这里我们用特殊宏 <code>lambda</code> 构造了一个 <b>匿名函数</b> （参见《Emacs Lisp 参考手册》中的 “<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Lambda-Expressions.html#Lambda-Expressions">Lambda 表达式</a>”），它调用 <code>auto-fill-mode</code> 并传入参数 <code>-1</code> 来关闭该次要模式。由于 LaTeX 模式会在运行 <code>text-mode-hook</code> 之后运行 <code>latex-mode-hook</code> ，最终效果就是关闭自动换行。
</p>

<p>
下面是一个更复杂的例子，展示如何用钩子自定义 C 语言代码的缩进风格：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq</span> my-c-style
  '((c-comment-only-line-offset . 4)
    (c-cleanup-list . (scope-operator
                       empty-defun-braces
                       defun-close-semi))))

(add-hook 'c-mode-common-hook
  (<span style="color: #a020f0;">lambda</span> () (c-add-style <span style="color: #8b2252;">"my-style"</span> my-c-style t)))
</pre>
</div>

<p>
主模式钩子也会作用于从它 <b><i>derived派生</i></b> 出来的其他主模式（参见《Emacs Lisp 参考手册》中的 “<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Derived-Modes.html#Derived-Modes">派生模式</a>”）。例如，HTML 模式派生自 Text 模式（参见 “<a href="#HTML-Mode">SGML 和 HTML 模式</a>”）；启用 HTML 模式时，会先运行 <code>text-mode-hook</code> ，再运行 <code>html-mode-hook</code> 。这让你可以用一个钩子同时影响多个相关模式。特别地，如果你想让某个钩子函数作用于 <b>所有编程语言模式</b> ，可以把它加到 <code>prog-mode-hook</code> ；Prog 模式本身几乎不做任何事，就是为了让其他模式继承而设计的。
</p>

<p>
设计钩子函数时，最好让它们 <b>不依赖执行顺序</b> 。任何对顺序的依赖都容易出问题。不过顺序本身是可预测的：钩子函数会按照它们在钩子列表中的 <b>先后顺序执行</b> 。
</p>

<p>
如果你反复调用 <code>add-hook</code> 往同一个钩子添加不同版本的函数，要记住：所有添加过的版本都会一起留在钩子变量里。你可以用 <code>remove-hook</code> 删除单个函数，或者用 <code>(setq hook-variable nil)</code> 清空全部内容。
</p>

<p>
如果钩子变量是 <b><i>buffer-local缓冲区局部</i></b> 的，就会使用局部值而不是全局值。但是，如果局部变量里包含元素 <code>t</code> ，那么 <b>全局钩子也会一并运行</b> 。
</p>
</div>
</div>
<div id="outline-container-Locals" class="outline-4">
<h4 id="Locals"><span class="section-number-4">51.2.3.</span> 局部变量</h4>
<div class="outline-text-4" id="text-Locals">
<dl class="org-dl">
<dt><code>M-x make-local-variable RET var RET</code></dt><dd>让变量 <i>var</i> 在当前缓冲区中拥有局部值。</dd>
<dt><code>M-x kill-local-variable RET var RET</code></dt><dd>让变量 <i>var</i> 在当前缓冲区中恢复使用全局值。</dd>
<dt><code>M-x make-variable-buffer-local RET var RET</code></dt><dd>标记变量 <i>var</i> ，使其在被设置时自动变为当前缓冲区局部。</dd>
</dl>

<p>
几乎所有变量都可以设为特定缓冲区本地。这意味着它在该缓冲区中的值，与其他缓冲区中的值相互独立。有少数变量在每个缓冲区中默认就是局部的。其余所有 Emacs 变量都有一个 <i>global value全局值</i> ，在所有未设为局部的缓冲区中生效。
</p>

<p>
<code>M-x make-local-variable</code> 读取一个变量名，并将其设为当前缓冲区局部。之后在本缓冲区修改它的值，不会影响其他缓冲区；全局值的改动也不会影响本缓冲区。
</p>

<p>
<code>M-x make-variable-buffer-local</code> 会标记一个变量，使其一旦被设置，就自动变成局部变量。更准确地说：一个变量被这样标记后，所有常规的赋值方式都会先隐式执行 <code>make-local-variable</code> 。我们称这类变量为 <b>按缓冲区变量</b> （per-buffer）。Emacs 中很多变量默认就是这类；变量的文档字符串会说明这一点。按缓冲区变量的全局值通常不在任何缓冲区直接生效，但它仍有意义：它是 <b>每个新缓冲区创建时该变量的初始值</b> 。
</p>

<p>
<b>主模式</b> (见<a href="#Major-Modes">主模式</a>)在设置变量前，总会先将变量设为缓冲区局部。这就是为什么在一个缓冲区切换主模式，不会影响其他缓冲区。 <b>次要模式</b> 也是通过设置变量工作：通常每个次要模式都有一个控制变量，模式启用时为非 nil（参见 “<a href="#Minor-Modes">次要模式</a>”）。很多次要模式的控制变量本身就是按缓冲区的，因此永远是缓冲区局部；否则你也可以像其他变量一样，手动将其设为特定缓冲区局部。
</p>

<p>
有少数变量 <b>不能是缓冲区局部</b> ，因为它们默认是 <b>每个显示设备局部</b> （参见 “<a href="#Multiple-Displays">多显示器</a>”）。如果你试图将这类变量设为缓冲区局部，会收到错误信息。
</p>

<p>
<code>M-x kill-local-variable</code> 取消指定变量在当前缓冲区的局部状态，此后该变量的 <b>全局值</b> 在此缓冲区生效。切换主模式时，会清除缓冲区的所有局部变量，只有少数被标记为 <b>永久局部</b> 的变量例外。
</p>

<p>
无论当前缓冲区是否有局部值，你都可以用 Lisp 结构 <code>setq-default</code> 来设置变量的 <b>全局值</b> 。用法与 <code>setq</code> 一样，但它设置的是全局值而非局部值（如果存在局部值）。当当前缓冲区有局部值时，新的全局值要等到切换到其他缓冲区才会显现。示例：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq-default</span> fill-column 75)
</pre>
</div>

<p>
对于被 <code>make-variable-buffer-local</code> 标记过的变量， <code>setq-default</code> 是设置其全局值的 <b>唯一方式</b> 。
</p>

<p>
Lisp 程序可以用 <code>default-value</code> 查看变量的默认（全局）值。该函数接受一个符号作为参数，返回其默认值。参数需要被求值，通常要显式加引号。例如，获取 <code>fill-column</code> 的默认值：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(default-value 'fill-column)
</pre>
</div>
</div>
</div>
<div id="outline-container-File-Variables" class="outline-4">
<h4 id="File-Variables"><span class="section-number-4">51.2.4.</span> 文件中的局部变量</h4>
<div class="outline-text-4" id="text-File-Variables">
<p>
在使用 Emacs 编辑文件时，文件本身可以指定要使用的本地变量值。打开文件或设置主模式时，Emacs 会检查文件中的本地变量声明；它会自动将这些变量设为缓冲区本地变量，并将其值设置为文件中指定的值。
</p>

<p>
如果文件所在目录已声明目录本地变量（参见 “<a href="#Directory-Variables">按目录本地变量</a>”），文件本地变量会覆盖目录本地变量。
</p>

<ul class="org-ul">
<li><a href="#Specifying-File-Variables">指定文件变量</a></li>
<li><a href="#Safe-File-Variables">文件变量的安全性</a></li>
</ul>
</div>
<div id="outline-container-Specifying-File-Variables" class="outline-5">
<h5 id="Specifying-File-Variables"><span class="section-number-5">51.2.4.1.</span> 指定文件变量</h5>
<div class="outline-text-5" id="text-Specifying-File-Variables">
<p>
指定文件本地变量值有两种方式：在文件 <i>first line首行</i> ，或使用本地变量列表。以下是在首行指定的方法：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">-*- mode: modename<span style="color: #b22222;">; </span><span style="color: #b22222;">var: value; &#8230; -*-</span>
</pre>
</div>

<p>
你可以用这种方式指定任意多组 “变量 / 值” 对，每组用冒号和分号分隔。特殊的 “变量 / 值” 对 <code>mode: modename</code> ;（如果存在）用于指定主模式（无需带 '-mode' 后缀）。值会被直接使用， <b>不会被求值</b> 。
</p>

<p>
你可以使用 <code>M-x add-file-local-variable-prop-line</code> 代替手动添加条目。该命令会提示输入变量名和值，并以合适的格式将它们添加到首行。 <code>M-x delete-file-local-variable-prop-line</code> 会提示输入变量名，并从该行中删除对应的条目。命令 <code>M-x copy-dir-locals-to-file-locals-prop-line</code> 可将当前的目录本地变量复制到首行（参见 “<a href="#Directory-Variables">按目录本地变量</a>”）。
</p>

<p>
下面是一个首行示例，指定 Lisp 模式并设置两个数值型变量：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #b22222;">;; </span><span style="color: #b22222;">-*- mode: Lisp; fill-column: 75; comment-column: 50; -*-</span>
</pre>
</div>

<p>
除 <code>mode</code> 外，作为文件变量具有特殊含义的其他关键字还有： <code>coding</code> 、 <code>unibyte</code> 和 <code>eval</code> 。下文会介绍这些关键字。
</p>

<p>
在 Shell 脚本中，首行用于指定脚本解释器，因此不能在那里放置本地变量。为适配这种情况，如果首行指定了解释器，Emacs 会 <b>检查 <i>second line第二行</i></b> 是否有本地变量声明。对于以特殊字符串 <code>'\"</code> 开头以指定 <code>troff</code> 预处理程序列表的 man 手册页（并非全部都如此），规则也是一样的。
</p>

<p>
除了使用 '-*-' 行之外，你还可以在文件末尾附近用 <i>local variables list本地变量列表</i> 定义文件本地变量。本地变量列表的起始位置距离文件末尾不应超过 3000 字符；如果文件分页，则必须位于最后一页。
</p>

<p>
如果一个文件同时存在本地变量列表和 '-*-' 行，
</p>
<ul class="org-ul">
<li>Emacs 会先处理 '-*-' 行的所有内容，再处理本地变量列表。</li>
<li>主模式指定是个例外：无论出现在哪里，Emacs 都会 <b>最先应用</b> 主模式，因为大多数主模式在初始化时会清除所有本地变量。</li>
</ul>

<p>
本地变量列表以包含字符串 '<code>Local Variables</code>' : 的行开始，以包含 '<code>End:</code>' 的行结束。中间每行写一组变量名和值，示例如下：
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #b22222;">/* </span><span style="color: #b22222;">Local Variables&#58;</span><span style="color: #b22222;">  */</span>
<span style="color: #b22222;">/* </span><span style="color: #b22222;">mode: c</span><span style="color: #b22222;">           */</span>
<span style="color: #b22222;">/* </span><span style="color: #b22222;">comment-column: 0</span><span style="color: #b22222;"> */</span>
<span style="color: #b22222;">/* </span><span style="color: #b22222;">End:</span><span style="color: #b22222;">              */</span>
</pre>
</div>

<p>
本例中每行都以前缀 <code>/*</code> 开头、后缀 <code>*/</code> 结尾。Emacs 通过列表首行中包裹着 '<code>Local Variables:</code>' 的前缀和后缀来识别它们，然后自动在列表其他行中忽略这些前缀后缀。使用前缀 / 后缀的常见原因是：将本地变量列表 <b>嵌入注释</b> ，避免干扰处理该文件的其他程序。上面的例子适用于 C 语言，其注释以 <code>/*</code> 开头、 <code>*/</code> 结尾。
</p>

<p>
如果某些无关文本可能被 Emacs 误判为本地变量列表，你可以在该文本后插入一个换页符（分页符，参见 <a href="#Pages">Pages</a>）来避免。Emacs 只在文件 <b>最后一页</b> 、最后一个分页符之后查找文件本地变量。
</p>

<p>
除了直接手写本地变量列表，你还可以使用命令 <code>M-x add-file-local-variable</code> 。该命令会提示输入变量名和值，并将它们加入列表，必要时自动添加 '<code>Local Variables:</code>' 字符串与起止标记。命令 <code>M-x delete-file-local-variable</code> 从列表中删除一个变量。 <code>M-x copy-dir-locals-to-file-locals</code> 将目录本地变量复制到该列表（参见 “<a href="#Directory-Variables">按目录本地变量</a>”）。
</p>

<p>
与 <code>-*-</code> 行一样，本地变量列表中的变量值会 <i>直接使用，不会先被求值</i> 。如果你想把一个长字符串值拆成多行书写，可以使用反斜杠 + 换行（ <code>\+ 换行</code> ），Lisp 字符串常量中会忽略这种写法。你应该在每一行都加上前缀和后缀，即使该行在字符串中间开始或结束 —— 处理列表时它们会被自动去掉。示例：
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;"># </span><span style="color: #b22222;">Local Variables&#58;
</span><span style="color: #b22222;"># </span><span style="color: #b22222;">compile-command: "cc foo.c -Dfoo=bar -Dhack=whatever \
</span><span style="color: #b22222;">#   </span><span style="color: #b22222;">-Dmumble=blaah"
</span><span style="color: #b22222;"># </span><span style="color: #b22222;">End:</span>
</pre>
</div>

<p>
在本地变量列表中，部分名称具有特殊含义：
</p>
<ul class="org-ul">
<li><code>mode</code> ：启用指定的主模式。</li>
<li><code>eval</code> ：对指定的 Lisp 表达式求值（表达式的返回值会被忽略）。</li>
<li><code>coding</code> ：指定该文件字符编码转换所用的编码系统。参见 “<a href="#Coding-Systems">编码系统</a>”。</li>
<li><code>unibyte</code> ：若值为 <code>t</code> ，则以单字节模式加载或编译该 Emacs Lisp 文件。参见《GNU Emacs Lisp 参考手册》中的 “<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Disabling-Multibyte.html#Disabling-Multibyte">禁用多字节字符</a>”。</li>
</ul>

<p>
这四个关键字并非真正的变量；在其他上下文中设置它们没有特殊含义。
</p>

<p>
如果你在不同 Emacs 版本间编辑文件，新版 Emacs 引入了处理某类文件的新模式，你可以用多个 <code>mode</code> 条目，让新版 Emacs 使用新模式（如 <code>my-new-mode</code> ），旧版 Emacs 回退到旧模式（如 <code>my-old-mode</code> ）。在文件首行中可以这样写：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">-*- mode: my-old<span style="color: #b22222;">; </span><span style="color: #b22222;">mode: my-new -*-</span>
</pre>
</div>

<p>
Emacs 会使用 <b>最后找到</b> 的那个已定义模式：旧版 Emacs 会忽略 <code>my-new-mode</code> ，而支持 <code>my-new-mode</code> 的新版 Emacs 会忽略 <code>my-old-mode</code> 。同理，在文件末尾的本地变量块中：
</p>

<div class="org-src-container">
<pre class="src src-org">Local Variables&#58;
mode: my-old
mode: my-new
End:
</pre>
</div>

<p>
<b>不要</b> 将 <code>mode</code> 关键字用于次要模式。若要在本地变量列表中启用或禁用某个次要模式，请使用 <code>eval</code> 关键字，并搭配执行对应模式命令的 Lisp 表达式（详见「<a href="#Minor-Modes">次要模式</a>」）。例如，下面这段本地变量列表通过无参数调用 <code>eldoc-mode</code> 来启用 ElDoc 模式（见<a href="#Programming-Language-Doc">编程语言文档查阅</a>）（传入参数 1 效果相同），并通过传入参数 -1 调用 <code>font-lock-mode</code> 来禁用语法高亮（Font Lock）模式。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #b22222;">;; </span><span style="color: #b22222;">Local Variables&#58;
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">eval: (eldoc-mode)
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">eval: (font-lock-mode -1)
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">End:</span>
</pre>
</div>

<p>
但要注意：以这种方式指定次要模式通常 <b>并不合适</b> 。次要模式多是用户个人偏好，将你的偏好强加给其他可能编辑该文件的用户并不妥当。如果你希望根据场景自动启用 / 禁用次要模式，通常更适合在 <b>主模式钩子</b> 中实现（参见 “<a href="#Hooks">钩子</a>”）。
</p>

<p>
使用命令 <code>M-x normal-mode</code> 可根据文件名与内容，重置缓冲区的本地变量与主模式（包括本地变量列表，如果有的话）。参见 “<a href="#Choosing-Modes">选择文件模式</a>”
</p>
</div>
</div>
<div id="outline-container-Safe-File-Variables" class="outline-5">
<h5 id="Safe-File-Variables"><span class="section-number-5">51.2.4.2.</span> 文件变量的安全性</h5>
<div class="outline-text-5" id="text-Safe-File-Variables">
<p>
文件局部变量可能存在安全风险；当你打开他人编写的文件时，无法预知文件中的局部变量列表会对你的 Emacs 产生何种影响。~eval~ “变量” 以及 <code>load-path</code> 等其他变量若被设置不当，可能会执行你本不想运行的 Lisp 代码。
</p>

<p>
因此，每当 Emacs 遇到 <b>无法确认安全</b> 的文件局部变量取值时，都会显示该文件完整的局部变量列表，并在应用前向你请求确认。你可以按下 <code>y</code> 或 <code>SPC</code> 使局部变量列表生效，或按下 <code>n</code> 忽略这些变量。如果 Emacs 以批处理模式运行（参见「<a href="#Initial-Options">初始选项</a>」），由于无法向你询问，会默认按 <code>n</code> 处理。
</p>

<p>
Emacs 通常会将某些变量 / 取值对认定为安全。例如， <code>comment-column</code> 或 <code>fill-column</code> 接受任意整数都是安全的。如果一个文件只指定了已知安全的变量 / 取值对，Emacs 会直接应用，不再请求确认。反之，你可以在确认提示时按下 <code>!</code> ，让 Emacs 将当前文件里所有变量 / 取值对都记录为安全。之后 Emacs 再次遇到这些变量 / 取值（无论在同一文件还是其他文件），都会默认视为安全。
</p>

<p>
你也可以在确认提示时按下 <code>i</code> ，让 Emacs永久忽略该文件中的所有变量 / 取值对 —— 此后这些配置在本文件及所有其他文件中都会被忽略。
</p>

<p>
当 Emacs 对设置目录局部变量请求确认时（参见「<a href="#Directory-Variables">按目录设置局部变量</a>」），在提示处按下 <code>+</code> ，会一次性应用所有变量，并将该目录加入 <code>safe-local-variable-directories</code> 列表（下文说明）。此后 Emacs 会认为该目录是可信的，直接加载其中的所有目录局部变量。 <code>+</code> 操作只应在你完全信任该目录内容时使用。
</p>

<p>
有些变量（如 <code>load-path</code> ）被视为高风险变量：几乎没有合理理由将它们设为局部变量，修改它们可能带来危险。如果一个文件只包含高风险局部变量，Emacs 在确认提示中不会提供、也不接受 <code>!</code> 作为输入。如果文件中既有高风险变量，也有仅潜在不安全的变量，你仍可以在提示处输入 <code>!</code> ：它会应用所有变量，但只将非高风险的那些标记为未来可信任。如果你确实想为高风险变量记录安全取值，可直接通过自定义 <code>safe-local-variable-values</code> 实现（参见「<a href="#Easy-Customization">简易自定义界面</a>」）。同理，若想记录需要永久忽略的高风险变量取值，可自定义 <code>ignored-local-variable-values</code> 。
</p>

<p>
有时你希望始终信任某些目录中的目录变量，从这些目录加载局部变量时跳过确认提示，即便其中包含风险变量。变量 <code>safe-local-variable-directories</code> 就用于保存这类目录列表，列表中的目录名必须是完整绝对路径。如果变量 <code>enable-remote-dir-locals</code> 设为非空值，该列表还可包含远程目录（参见「<a href="#Remote-Files">远程文件</a>」）。
</p>

<p>
变量 <code>enable-local-variables</code> 用于控制 Emacs 处理局部变量的方式，默认值为 <code>t</code> ，即采用上文描述的行为：
</p>
<ul class="org-ul">
<li>若设为 <code>nil</code> ：Emacs 直接忽略所有文件局部变量。</li>
<li>若设为 <code>:safe</code> ：只使用安全取值，忽略其余所有。</li>
<li>若设为 <code>:all</code> ：Emacs 会应用所有文件局部变量，无论取值是否安全（不建议长期使用）。</li>
<li>其他取值：对每个含局部变量的文件都向你询问，不自动判断是否安全。</li>
</ul>

<p>
变量 <code>enable-local-eval</code> 控制 Emacs 是否处理 <code>eval</code> 变量，取值与 <code>enable-local-variables</code> 类似，可为 <code>t</code> 、 <code>nil</code> 或其他值。其默认值为 <code>maybe</code> （既非 t 也非 nil），因此 Emacs 通常会对处理 <code>eval</code> 变量请求确认。
</p>

<p>
作为例外：如果某个 <code>eval</code> 表达式出现在变量 <code>safe-local-eval-forms</code> 中，Emacs 执行时不会请求任何确认。
</p>
</div>
</div>
</div>
<div id="outline-container-Directory-Variables" class="outline-4">
<h4 id="Directory-Variables"><span class="section-number-4">51.2.5.</span> 目录级局部变量</h4>
<div class="outline-text-4" id="text-Directory-Variables">
<p>
有时，你可能希望对某个目录及其子目录下的 <b>所有文件</b> 定义同一套局部变量，例如大型软件项目的目录树。这可以通过目录局部变量来实现。 <b>文件局部变量会覆盖目录局部变量</b> ，因此：如果目录中某些文件需要特殊设置，你可以先用目录变量为目录下大多数文件设置通用配置，再在少数需要覆盖的文件里单独定义文件局部变量。
</p>

<p>
定义目录局部变量的常规方式，是在目录中放置一个名为 <code>.dir-locals.el</code> 的文件<sup><a id="fnr.25" class="footref" href="#fn.25" role="doc-backlink">25</a></sup>。每当 Emacs 打开该目录或其任意子目录中的文件时，都会应用 <code>.dir-locals.el</code> 里定义的目录局部变量，就像这些变量是该文件自身的文件局部变量一样（见「<a href="#File-Variables">文件中的局部变量</a>」）。Emacs 会从当前打开文件所在的目录开始，向上遍历目录树查找 <code>.dir-locals.el</code> 。为避免速度变慢，远程文件默认跳过此搜索。如果需要，可以将变量 <code>enable-remote-dir-locals</code> 设为 <code>t</code> ，从而对远程文件也启用搜索。
</p>

<p>
你还可以使用 <code>.dir-locals-2.el</code> 。如果它与 <code>.dir-locals.el</code> 位于同一目录，Emacs 会在加载 <code>.dir-locals.el</code> 之后额外加载它。这在 <code>.dir-locals.el</code> 处于共享仓库的版本控制中、无法用于个人自定义时非常有用。
</p>

<p>
<code>.dir-locals.el</code> 文件应存放一个特定结构的列表，它将主模式名（符号）映射到关联列表（alists）（见《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Association-Lists.html#Association-Lists">关联列表</a>）。每个关联列表项由一个变量名和该变量的目录局部值组成，在指定主模式启用时生效。你可以不写模式名，而是指定 <code>nil</code> ，表示该关联列表对所有模式生效；也可以指定一个子目录（字符串），此时该关联列表只对该子目录下的所有文件生效。
</p>

<p>
下面是一个 <code>.dir-locals.el</code> 文件示例：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">((nil . ((indent-tabs-mode . t)
         (fill-column . 80)
         (mode . auto-fill)))
 (c-mode . ((c-file-style . <span style="color: #8b2252;">"BSD"</span>)
            (subdirs . nil)))
 (<span style="color: #8b2252;">"src/imported"</span>
  . ((nil . ((change-log-default-name
              . <span style="color: #8b2252;">"ChangeLog.local"</span>))))))
</pre>
</div>

<p>
它为目录树下任意文件设置了 <code>indent-tabs-mode</code> 和 <code>fill-column</code> ，并为所有 C 源码文件设置了缩进风格。特殊的 mode 项用于指定要启用的次要模式，因此 <code>(mode . auto-fill)</code> 表示需要启用 <code>auto-fill-mode</code> 。特殊的 <code>subdirs</code> 项不是变量，而是一个关键字，表示 C 模式的设置只应用于当前目录，不应用到子目录。最后，它为 <code>src/imported</code> 子目录下的所有文件指定了不同的 ChangeLog 文件名。
</p>

<p>
如果 <code>.dir-locals.el</code> 中，同一个变量在不同模式或不同目录下定义了多个值，Emacs 会按更具体优先的规则应用：更具体的模式优先于更通用的模式；目录指定的值优先级高于模式指定的值。例如：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">((nil . ((fill-column . 40)))
 (c-mode . ((fill-column . 50)))
 (prog-mode . ((fill-column . 60)))
 (<span style="color: #8b2252;">"narrow-files"</span> . ((nil . ((fill-column . 20))))))
</pre>
</div>

<p>
使用 <code>c-mode</code> 的文件同时匹配 <code>prog-mode</code> （因为前者继承自后者），但 C 文件中 <code>fill-column</code> 仍取 50，因为 <code>c-mode</code> 更具体。其他继承自 <code>prog-mode</code> 的模式会使用 60。 <code>narrow-files</code> 目录下的任何文件都会使用 20，即使它们使用 <code>c-mode</code> ，因为目录项优先级高于模式项。
</p>

<p>
你可以在 <code>.dir-locals.el</code> 中指定变量 mode、eval 和 unibyte，它们的含义与文件局部变量中一致。coding 不能作为目录局部变量指定。详见「文件中的局部变量」。
</p>

<p>
<code>.dir-locals.el</code> 中的特殊键 <code>auto-mode-alist</code> 可用于设置文件的主模式，用法与变量 <code>auto-mode-alist</code> 非常相似（见「<a href="#Choosing-Modes">选择文件模式</a>」）。例如，你可以这样告诉 Emacs：本目录下的 <code>.def</code> 文件应使用 C 模式：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">((auto-mode-alist . ((<span style="color: #8b2252;">"\\.def\\'"</span> . c-mode))))
</pre>
</div>

<p>
不必手动编辑 <code>.dir-locals.el</code> ，你可以使用命令： <code>M-x add-dir-local-variable</code> 提示输入模式或子目录、变量名与值，并添加目录局部变量定义项。 <code>M-x delete-dir-local-variable</code> 删除一项。 <code>M-x copy-file-locals-to-dir-locals</code> 将当前文件的文件局部变量复制到 <code>.dir-locals.el</code> ；如果同时存在 <code>.dir-locals-2.el</code> ，则复制到后者。
</p>

<p>
使用前缀参数时，这三个命令都会提示你选择要修改的文件。文件不必已存在，但必须输入合法文件名： <code>.dir-locals.el</code> 或 <code>.dir-locals-2.el</code> 。
</p>

<p>
还有一个命令可弹出简易自定义缓冲区编辑目录局部变量： <code>customize-dirlocals</code> （见「<a href="#Easy-Customization">简易自定义界面</a>」）。
</p>

<p>
另一种指定目录局部变量的方法是：使用函数 <code>dir-locals-set-class-variables</code> 在一个 <i>directory class目录类</i> 中定义一组变量 / 值对，再用函数 <code>dir-locals-set-directory-class</code> 告诉 Emacs 哪些目录对应这个类。这些函数调用通常写在你的初始化文件中（见「<a href="#Init-File">Emacs 初始化文件</a>」）。当你因某些原因无法在目录中放置 <code>.dir-locals.el</code> 时，这种方法很有用。例如，你可以用这种方式对不可写目录应用设置：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(dir-locals-set-class-variables 'unwritable-directory
   '((nil . ((some-useful-setting . value)))))

(dir-locals-set-directory-class
   <span style="color: #8b2252;">"/usr/include/"</span> 'unwritable-directory)
</pre>
</div>

<p>
如果一个变量同时指定了目录局部值和文件局部值，文件局部值优先。不安全的目录局部变量的处理方式，与不安全的文件局部变量完全相同（见「<a href="#Safe-File-Variables">文件变量的安全性</a>」）。
</p>

<p>
目录局部变量也会在某些不直接打开文件、但在目录内工作的缓冲区中生效，例如 Dired 缓冲区（见「<a href="#Dired">Dired：目录编辑器</a>」）。
</p>

<ul class="org-ul">
<li><a href="#EditorConfig-support">通过 EditorConfig 设置目录级变量</a></li>
</ul>
</div>
<div id="outline-container-EditorConfig-support" class="outline-5">
<h5 id="EditorConfig-support"><span class="section-number-5">51.2.5.1.</span> 通过 EditorConfig 设置目录级变量</h5>
<div class="outline-text-5" id="text-EditorConfig-support">
<p>
<a href="https://editorconfig.org/">EditorConfig 标准是</a> <code>.dir-locals.el</code> 文件的一种替代方案，它虽然只能控制极少数变量，但优点是 <b>与编辑器无关</b> ，并非 Emacs 专用。这些配置保存在名为 <code>.editorconfig</code> 的文件中，会作用于该目录及其子目录下的文件。
</p>

<p>
如果希望 Emacs 遵循 <code>.editorconfig</code> 文件中的配置，需要开启全局次要模式 <code>editorconfig-mode</code> 。通常只需这样启用即可：当该模式激活后，每当打开一个文件，Emacs 会在该文件所在目录及其上级目录中查找 <code>.editorconfig</code> ，就像查找 <code>.dir-locals.el</code> 一样。
</p>

<p>
如果同时找到 <code>.editorconfig</code> 和 <code>.dir-locals.el</code> ，两者的配置会合并；若出现配置冲突， <b>目录层级更近</b> 的文件中的配置优先；如果层级相同，则 <code>.dir-locals.el</code> 优先。在安全性方面， <code>.editorconfig</code> 的配置会受到与 <code>.dir-locals.el</code> 和文件局部变量相同的安全检查（同样遵循 <code>enable-local-variables</code> ）。详见 “<a href="#Safe-File-Variables">文件变量的安全性</a>”。
</p>

<p>
EditorConfig 标准中的 <code>indent_size</code> （缩进大小）在 Emacs 中没有固定对应的变量，而是需要根据主模式设置不同的变量。理想情况下，所有主模式都应设置对应的 <code>editorconfig-indent-size-vars</code> ；但如果你使用的某个主模式因尚未支持而导致 <code>indent_size</code> 不生效，可以通过自定义变量 <code>editorconfig-indentation-alist</code> ，告诉 Emacs 在该主模式下需要设置哪些变量。
</p>

<p>
类似地，删除行尾空白有多种不同实现方式。当使用 EditorConfig 的 <code>trim_trailing_whitespace</code> （删除行尾空白）配置时，默认情况下 <code>editorconfig-mode</code> 会在每次保存文件时直接调用 <code>delete-trailing-whitespace</code> （参见 “<a href="#Useless-Whitespace">无用空白</a>”）。如果你希望使用其他行为，可以将 <code>editorconfig-trim-whitespaces-mode</code> 自定义为你偏好的次要模式，例如 <code>ws-butler-mode</code> 。
</p>
</div>
</div>
</div>
<div id="outline-container-Connection-Variables" class="outline-4">
<h4 id="Connection-Variables"><span class="section-number-4">51.2.6.</span> 连接级局部变量</h4>
<div class="outline-text-4" id="text-Connection-Variables">
<p>
大部分变量反映的是本地机器上的状态。当你在使用远程默认目录的缓冲区中操作时，这些变量往往需要使用不同的值。例如调用 shell 时的行为：在本地机器上，你可能使用 <code>/bin/bash</code> 并依赖 <code>termcap</code> ；但在远程机器上，则可能是 <code>/bin/ksh</code> 与 <code>terminfo</code> 。
</p>

<p>
这类需求可以通过连接局部变量（connection-local variables）实现。目录局部变量与文件局部变量的优先级高于连接局部变量。不安全的连接局部变量，其处理方式与不安全的文件局部变量相同（参见 “<a href="#Safe-File-Variables">文件变量的安全性</a>”）。
</p>

<p>
连接局部变量通过 <code>connection-local-set-profile-variables</code> 函数，以 <b>配置文件（profile）</b> 的形式成组声明变量 / 值对。函数 <code>connection-local-set-profiles</code> 则根据指定的匹配条件（用于标识远程主机）来激活这些配置文件：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(connection-local-set-profile-variables 'remote-terminfo
   '((system-uses-terminfo . t)
     (comint-terminfo-terminal . <span style="color: #8b2252;">"dumb-emacs-ansi"</span>)))

(connection-local-set-profile-variables 'remote-ksh
   '((shell-file-name . <span style="color: #8b2252;">"/bin/ksh"</span>)
     (shell-command-switch . <span style="color: #8b2252;">"-c"</span>)))

(connection-local-set-profile-variables 'remote-bash
   '((shell-file-name . <span style="color: #8b2252;">"/bin/bash"</span>)
     (shell-command-switch . <span style="color: #8b2252;">"-c"</span>)))

(connection-local-set-profiles
   '(<span style="color: #483d8b;">:application</span> tramp <span style="color: #483d8b;">:machine</span> <span style="color: #8b2252;">"remotemachine"</span>)
   'remote-terminfo 'remote-ksh)
</pre>
</div>

<p>
这段代码声明了三个不同的配置文件： <code>remote-terminfo</code> 、 <code>remote-ksh</code> 和 <code>remote-bash</code> 。其中 <code>remote-terminfo</code> 和 <code>remote-ksh</code> 会应用到所有远程默认目录的主机名匹配正则表达式 "remotemachine" 的缓冲区。
</p>

<p>
这类匹配条件还可以根据以下属性区分：
</p>
<ul class="org-ul">
<li><code>:protocol</code> （即 Tramp 方法）</li>
<li><code>:user</code> （远程用户名）</li>
</ul>
<p>
条件为 <code>nil</code> 时，匹配所有带有远程默认目录的缓冲区。
</p>

<p>
注意事项，当多个配置文件声明同一个变量，且这些配置文件的匹配条件可能同时生效时，最终使用哪个变量值是未定义的，需谨慎使用。
</p>

<p>
如果在某个缓冲区中设置了连接局部变量，之后又修改了该缓冲区的主模式，需要特别注意：切换主模式时，所有缓冲区局部变量都会被清除，连接局部变量的值也会丢失。可以通过将对应变量的 <code>permanent-local</code> 符号属性设为非 nil 来避免这一问题。
</p>
</div>
</div>
</div>
<div id="outline-container-Key-Bindings" class="outline-3">
<h3 id="Key-Bindings"><span class="section-number-3">51.3.</span> 按键绑定自定义</h3>
<div class="outline-text-3" id="text-Key-Bindings">
<p>
本节介绍 <i>key bindings按键绑定</i> （将按键映射到命令）与 <i>keymaps键映射表</i> （记录按键绑定），同时说明如何自定义按键绑定（通过编辑初始化文件实现，参见「<a href="#Init-Rebinding">在初始化文件中重新绑定按键</a>」）。
</p>

<p>
由于多数模式都会定义自身的按键绑定，激活某个模式可能会覆盖你自定义的按键绑定。有少量按键是保留给用户自定义绑定的，模式不应占用，因此使用这些按键的绑定在这方面更安全。保留的按键序列包括：
</p>
<ul class="org-ul">
<li><code>C-c</code> 后接一个字母（大写或小写）</li>
<li>不带修饰键的功能键 F5 至 F9（参见「<a href="#Modifier-Keys">修饰键</a>」）</li>
</ul>


<ul class="org-ul">
<li><a href="#Keymaps">键映射</a></li>
<li><a href="#Prefix-Keymaps">前缀键映射</a></li>
<li><a href="#Local-Keymaps">局部键映射</a></li>
<li><a href="#Minibuffer-Maps">迷你缓冲区键映射</a></li>
<li><a href="#Rebinding">交互式修改键绑定</a></li>
<li><a href="#Init-Rebinding">在初始化文件中重新绑定键</a></li>
<li><a href="#Modifier-Keys">修饰键</a></li>
<li><a href="#Function-Keys">重新绑定功能键</a></li>
<li><a href="#Named-ASCII-Chars">命名 ASCII 控制字符</a></li>
<li><a href="#Mouse-Buttons">重新绑定鼠标按钮</a></li>
<li><a href="#Disabling">禁用命令</a></li>
</ul>
</div>
<div id="outline-container-Keymaps" class="outline-4">
<h4 id="Keymaps"><span class="section-number-4">51.3.1.</span> 键映射</h4>
<div class="outline-text-4" id="text-Keymaps">
<p>
正如 “<a href="#Commands">按键与命令</a>” 一节所述，每个 Emacs 命令都是一个 Lisp 函数，其定义支持交互式使用。与所有 Lisp 函数一样，命令拥有一个函数名，通常由小写字母和连字符组成。
</p>

<p>
<i>key sequence按键序列</i> （简称 <i>key按键</i> ）是一组作为整体具有意义的输入事件序列。输入事件包括字符、功能键和鼠标按键 —— 所有你可以发送给计算机的输入。按键序列的含义来自它的绑定，即该按键序列所执行的命令。
</p>

<p>
按键序列与命令函数之间的绑定关系，存储在名为 <b>键映射（keymap）</b> 的数据结构中。Emacs 包含大量键映射，每种键映射只在特定场景下生效。
</p>

<p>
<i>global全局</i> 键映射是最重要的键映射，因为它始终生效。全局键映射为 <b>基本模式（Fundamental mode）</b> 定义按键（参见<a href="#Major-Modes">主模式</a>）；其中大部分定义对绝大多数或全部主模式通用。每个主模式或次要模式都可以拥有自己的键映射，用于覆盖全局键映射中部分按键的定义。
</p>

<p>
例如， <code>g</code> 这类自插入字符能够自动插入文本，是因为全局键映射将它绑定到 <code>self-insert-command</code> 命令。 <code>C-a</code> 这类标准 Emacs 编辑按键，其默认功能也来自全局键映射。用于重新绑定按键的命令（如 <code>M-x keymap-global-set</code> ），其工作方式就是将新绑定存入全局键映射的对应位置（参见<a href="#Rebinding">交互式修改按键绑定</a>）。使用命令 <code>C-h b</code> 可以查看当前所有按键绑定。
</p>

<p>
现代键盘通常同时拥有字符键和功能键。功能键与字符键一样会发送输入事件，键映射也可以为功能键设置绑定。按键序列可以混合功能键与字符。例如，如果你的键盘有 <code>Home</code> 功能键，Emacs 可以识别 <code>C-x Home</code> 这类按键序列。你甚至可以混合鼠标事件与键盘事件，例如 <code>S-down-mouse-1</code> 。
</p>

<p>
在文本终端下，按下一个功能键实际上会向计算机发送一串字符序列；该序列的具体格式取决于功能键与终端类型（通常以 <code>ESC [</code> 开头）。如果 Emacs 能正确识别你的终端类型，会自动将这类序列当作单个输入事件处理。
</p>

<p>
以 <code>C-c</code> 后接一个字母（大写或小写，ASCII 或非 ASCII）组成的按键序列 <b>保留给用户使用</b> 。Emacs 自身永远不会绑定这些按键序列，Emacs 扩展也应避免占用它们。也就是说，用户可以放心绑定 <code>C-c a</code> 或 <code>C-c ç</code> 这类按键，不必担心被 Emacs 其他绑定覆盖。
</p>
</div>
</div>
<div id="outline-container-Prefix-Keymaps" class="outline-4">
<h4 id="Prefix-Keymaps"><span class="section-number-4">51.3.2.</span> 前缀键映射</h4>
<div class="outline-text-4" id="text-Prefix-Keymaps">
<p>
在内部实现中，Emacs 在每个键映射里只记录 <b>单个事件</b> 。解析由多个事件组成的按键序列，需要通过 <b>一连串键映</b> 射来完成：第一个键映射给出第一个事件的定义，该定义又是另一个键映射，再用它去查找序列中的第二个事件，依此类推。因此，像 <code>C-x</code> 或 <code>ESC</code> 这样的前缀键都拥有自己的键映射，里面存放着紧跟在该前缀之后的事件定义。
</p>

<p>
前缀键的定义通常是一个键映射，用于查找后续的事件。该定义也可以是一个 Lisp 符号，其函数定义就是对应的后续键映射；效果完全相同，但这样会为前缀键提供一个命令名，可用来说明该前缀键的用途。例如， <code>C-x</code> 绑定到符号 <code>Control-X-prefix</code> ，它的函数定义就是存放 <code>C-x</code> 系列命令的键映射。 <code>C-c</code> 、 <code>C-x</code> 、 <code>C-h</code> 和 <code>ESC</code> 作为前缀键的定义出现在全局键映射中，因此这些前缀键始终可用。
</p>

<p>
除了普通前缀键，还有一个虚拟的 “前缀键” 用于表示菜单栏；关于菜单栏按键绑定的特殊信息，参见《Emacs Lisp 参考手册》中的 “<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Menu-Bar.html#Menu-Bar">菜单栏</a>” 一节。触发弹出菜单的鼠标按键事件也属于前缀键；更多细节参见《Emacs Lisp 参考手册》中的 “<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Menu-Keymaps.html#Menu-Keymaps">菜单键映射</a>” 一节。
</p>

<p>
部分前缀键映射存放在以特定名称命名的变量中：
</p>
<ul class="org-ul">
<li><code>ctl-x-map</code> 是 <code>C-x</code> 之后所跟字符对应的键映射变量名。</li>
<li><code>help-map</code> 对应 <code>C-h</code> 之后的字符。</li>
<li><code>esc-map</code> 对应 <code>ESC</code> 之后的字符。因此，所有 Meta 字符实际上都由该键映射定义。</li>
<li><code>ctl-x-4-map</code> 对应 <code>C-x 4</code> 之后的字符。</li>
<li><code>mode-specific-map</code> 对应 <code>C-c</code> 之后的字符。</li>
<li><code>project-prefix-map</code> 对应 <code>C-x p</code> 之后的字符，用于项目相关命令（参见 “<a href="#Projects">使用项目</a>”）。</li>
</ul>
</div>
</div>
<div id="outline-container-Local-Keymaps" class="outline-4">
<h4 id="Local-Keymaps"><span class="section-number-4">51.3.3.</span> 局部键映射</h4>
<div class="outline-text-4" id="text-Local-Keymaps">
<p>
到目前为止，我们已经介绍了全局键映射的相关细节。主模式通过提供自身的局部键映射来自定义 Emacs 行为。例如，C 语言模式会重新定义 TAB 键，使其为 C 代码对当前行进行缩进。次要模式也可以拥有局部键映射；只要某个次要模式处于启用状态，它的键映射定义就会同时覆盖主模式的局部键映射和全局键映射。此外，缓冲区中的部分文本也可以指定自身的键映射，覆盖所有其他键映射。
</p>

<p>
局部键映射可以将某个按键重新定义为前缀键，只需将其定义为一个前缀键映射即可。如果该按键在全局中也被定义为前缀，那么它的局部定义与全局定义（两者都是键映射）会有效合并：查找前缀键之后的事件时，两种定义都会被使用。例如，如果某个局部键映射将 <code>C-c</code> 定义为前缀键映射，并且该映射中把 <code>C-z</code> 绑定到某个命令，这就为 <code>C-c C-z</code> 提供了局部含义。这不会影响其他以 <code>C-c</code> 开头的序列；如果这些序列没有对应的局部绑定，它们的全局绑定依然生效。
</p>

<p>
另一种理解方式是：Emacs 处理多事件按键序列时，会依次在多个键映射中查找整个按键序列的绑定。它会先检查已启用的次要模式键映射，然后检查主模式键映射，最后检查全局键映射。这并非键查找的精确内部机制，但在通常情况下足以帮你理解最终效果。
</p>
</div>
</div>
<div id="outline-container-Minibuffer-Maps" class="outline-4">
<h4 id="Minibuffer-Maps"><span class="section-number-4">51.3.4.</span> 迷你缓冲区键映射</h4>
<div class="outline-text-4" id="text-Minibuffer-Maps">
<p>
迷你缓冲拥有一套自身的局部键映射，其中包含各种补全与退出命令。
</p>
<ul class="org-ul">
<li><code>minibuffer-local-map</code> 用于普通输入（无补全）。</li>
<li><code>minibuffer-local-ns-map</code> 与之类似，区别是空格 <code>SPC</code> 与回车 <code>RET</code> 一样会直接退出。</li>
<li><code>minibuffer-local-completion-map</code> 用于宽松补全。</li>
<li><code>minibuffer-local-must-match-map</code> 用于严格补全与谨慎补全。</li>
<li><code>minibuffer-local-filename-completion-map</code> 和上面两个类似，但专门用于文件名补全，它不会绑定空格 <code>SPC</code> 。</li>
</ul>

<p>
默认情况下，在 <code>minibuffer-local-completion-map</code> 里， <code>TAB</code> 、 <code>SPC</code> 和 <code>?</code> 用于触发补全。如果你经常需要对包含空格或问号的内容进行补全，可以把下面代码放到配置文件中，禁用这些按键的补全功能：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(keymap-set minibuffer-local-completion-map <span style="color: #8b2252;">"SPC"</span> 'self-insert-command)
(keymap-set minibuffer-local-completion-map <span style="color: #8b2252;">"?"</span> 'self-insert-command)
</pre>
</div>
</div>
</div>
<div id="outline-container-Rebinding" class="outline-4">
<h4 id="Rebinding"><span class="section-number-4">51.3.5.</span> 交互式修改键绑定</h4>
<div class="outline-text-4" id="text-Rebinding">
<p>
重新定义 Emacs 按键的方式，是修改它在键映射中的条目。你可以修改全局键映射，这样修改会在所有主模式中生效（那些对同一按键有覆盖性局部绑定的模式除外）。或者，你也可以修改局部键映射，这会影响所有使用同一主模式的缓冲区。
</p>

<p>
本节介绍如何为当前 Emacs 会话重新绑定按键。关于如何让按键绑定在后续 Emacs 会话中持续生效，参见「<a href="#Init-Rebinding">在初始化文件中重新绑定按键</a>」。
</p>

<dl class="org-dl">
<dt><code>M-x keymap-global-set RET key cmd RET</code></dt><dd>全局定义 <i>key按键</i> ，使其运行指定 <i>cmd命令</i> 。</dd>
<dt><code>M-x keymap-local-set RET key cmd RET</code></dt><dd>在当前生效的主模式中局部定义 <i>key按键</i> ，使其运行指定 <i>cmd命令</i> 。</dd>
<dt><code>M-x keymap-global-unset RET key</code></dt><dd>在全局键映射中取消该 <i>key按键</i> 的定义。</dd>
<dt><code>M-x keymap-local-unset RET key</code></dt><dd>在当前主模式中局部取消该 <i>key按键</i> 的定义。</dd>
</dl>

<p>
例如，下面的操作将 <code>C-z</code> 绑定到 <code>shell</code> 命令（参见<a href="#Interactive-Shell">交互式子 Shell</a>），替换掉 <code>C-z</code> 原本的全局定义：
</p>

<div class="org-src-container">
<pre class="src src-shell">M-x keymap-global-set RET C-z shell RET
</pre>
</div>

<p>
<code>keymap-global-set</code> 命令会在按下按键后读取命令名。按下按键后，会出现类似下面的提示，让你确认正在绑定想要的按键：
</p>

<div class="org-src-container">
<pre class="src src-shell">Set key C-z to command:
</pre>
</div>

<p>
你可以用同样方式重新定义功能键和鼠标事件；只需在指定要重新绑定的按键时，按下功能键或点击鼠标即可。
</p>

<p>
你也可以用同样方式重新绑定 <b>包含多个事件</b> 的按键。Emacs 会持续读取按键，直到它是一个完整按键（即不是前缀键）为止。例如，如果你输入 <code>C-f</code> 作为按键，到此结束；它会立刻进入迷你缓冲读取命令名。但如果你输入 <code>C-x</code> ，因为它是前缀键，Emacs 会继续读取下一个字符；如果下一个是 <code>4</code> （也是前缀），它会再读取一个字符，依此类推。例如：
</p>

<div class="org-src-container">
<pre class="src src-shell">M-x keymap-global-set RET C-x 4 $ spell-other-window RET
</pre>
</div>

<p>
会将 <code>C-x 4 $</code> 重新定义为运行（虚构的） <code>spell-other-window</code> 命令。
</p>

<p>
你可以用 <code>keymap-global-unset</code> 移除一个按键的全局定义。这会让该按键 <i>undefined未定义</i> ；按下时 Emacs 只会发出蜂鸣声。类似地， <code>keymap-local-unset</code> 会让按键在当前主模式键映射中未定义，从而使该主模式下重新使用全局定义（或无定义）。
</p>

<p>
如果你已经重新定义（或取消定义）了一个按键，之后想要撤销修改， <b>仅取消定义是不够的</b> —— 你需要用它的 <b>标准定义</b> 重新绑定该按键。要查看一个按键的标准定义名称，可以在全新启动的 Emacs 中进入 Fundamental 模式缓冲区，并用 <code>C-h c</code> 查看。本手册中对按键的说明也会列出它们对应的命令名。
</p>

<p>
如果你想防止自己误执行某个命令， <b>更好的做法是禁用该命令，而不是取消按键定义</b> 。当你真的需要使用时，启用被禁用的命令比重新定义按键更省事。参见「<a href="#Disabling">禁用命令</a>」。
</p>
</div>
</div>
<div id="outline-container-Init-Rebinding" class="outline-4">
<h4 id="Init-Rebinding"><span class="section-number-4">51.3.6.</span> 在初始化文件中重新绑定键</h4>
<div class="outline-text-4" id="text-Init-Rebinding">
<p>
如果你有一组常用的按键绑定，希望长期生效，可以通过编写 Lisp 代码，把它们写在 <b>初始化文件</b> 里。关于初始化文件的说明，参见《<a href="#Init-File">Emacs 初始化文件</a>》。
</p>

<p>
使用 Lisp 编写按键绑定的 <b>推荐方式</b> 是使用 <code>keymap-global-set</code> 或 <code>keymap-set</code> 函数。例如，下面代码将全局键映射中的 <code>C-z</code> 绑定到 <code>shell</code> 命令（参见<a href="#Interactive-Shell">交互式子 Shell</a>）：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(keymap-global-set <span style="color: #8b2252;">"C-z"</span> 'shell)
</pre>
</div>

<p>
<code>keymap-global-set</code> 的第一个参数描述按键序列，它是一个由空格分隔多个按键组成的字符串。带修饰符的按键可以通过前缀指定，如 'C-' 表示 Ctrl， 'M-' 表示 Meta。特殊按键（如 <code>TAB</code> 、 <code>RET</code> ）可以用尖括号表示： <code>&lt;TAB&gt;</code> 、 <code>&lt;RET&gt;</code> 。
</p>

<p>
绑定到按键序列的命令名（如上例中的 <code>shell</code> ）前面的 <b>单引号</b> ，表示它是一个常量符号，而非变量。如果省略引号，Emacs 会尝试把 <code>shell</code> 当作变量求值，这通常会报错，也不是你想要的效果。
</p>

<p>
下面是更多示例，包括绑定功能键和鼠标事件：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(keymap-global-set <span style="color: #8b2252;">"C-c y"</span> 'clipboard-yank)
(keymap-global-set <span style="color: #8b2252;">"C-M-q"</span> 'query-replace)
(keymap-global-set <span style="color: #8b2252;">"&lt;f5&gt;"</span> 'flyspell-mode)
(keymap-global-set <span style="color: #8b2252;">"C-&lt;f5&gt;"</span> 'display-line-numbers-mode)
(keymap-global-set <span style="color: #8b2252;">"C-&lt;right&gt;"</span> 'forward-sentence)
(keymap-global-set <span style="color: #8b2252;">"&lt;mouse-2&gt;"</span> 'mouse-save-then-kill)
</pre>
</div>

<p>
按键序列也可以直接绑定到 Lisp 字符串，而不是命令。字符串的写法与按键序列语法相同。例如，把 <code>C-c h</code> 绑定到字符串 'hello' ：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(keymap-global-set <span style="color: #8b2252;">"C-c h"</span> <span style="color: #8b2252;">"h e l l o"</span>)
</pre>
</div>

<p>
这样写比较繁琐，可以用便捷函数 <code>key-description</code> ：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(keymap-global-set <span style="color: #8b2252;">"C-c h"</span> (key-description <span style="color: #8b2252;">"hello"</span>))
</pre>
</div>

<p>
字符串中可以 <b>直接写非 ASCII 字符</b> 。例如绑定到 'olá' ：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(keymap-global-set <span style="color: #8b2252;">"C-c h"</span> (key-description <span style="color: #8b2252;">"ol&#225;"</span>))
</pre>
</div>

<p>
但要注意，语言环境与编码系统可能会给非 ASCII 字符的按键绑定带来问题（参见<a href="#Init-Non_002dASCII">初始化文件中的非 ASCII 字符</a>）。直接使用 <b>Unicode 编码</b> 可以避免这类问题（如何在 Emacs 内查看字符编码，参见<a href="#International-Chars">国际字符集简介</a>）：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(keymap-global-set <span style="color: #8b2252;">"C-c h"</span> (key-description <span style="color: #8b2252;">"ol\u00E1"</span>))
</pre>
</div>

<p>
你也可以使用底层函数 <code>define-key</code> 和 <code>global-set-key</code> 。例如，用底层函数实现上面 <code>C-z</code> 绑定 <code>shell</code> 的效果：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(global-set-key (kbd <span style="color: #8b2252;">"C-z"</span>) 'shell)
</pre>
</div>

<p>
指定按键序列有多种方式，最简单的是使用示例中的 <code>kbd</code> 函数。 <code>kbd</code> 接收一个表示按键序列的字符串，将其转换为适合 <code>global-set-key</code> 等底层函数使用的格式。更多关于用 Lisp 绑定按键的细节，参见《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Keymaps.html#Keymaps">键映射</a>章节。
</p>

<p>
正如 <a href="#Local-Keymaps">局部键映射</a> 中所述，主模式和次要模式都可以定义局部键映射。这些键映射会在会话中 <b>第一次加载该模式</b> 时创建。可以使用 <code>keymap-set</code> 函数修改指定的键映射，使用 <code>keymap-unset</code> 移除按键绑定。
</p>

<p>
由于模式的键映射只有在加载后才会创建，因此必须 <b>延迟执行</b> 修改它们的代码，例如把代码放到 * 模式钩子（mode hook）* 中（参见<a href="#Hooks">钩子</a>）。例如，Texinfo 模式会运行 <code>texinfo-mode-hook</code> 。下面示例展示如何通过钩子，在 Texinfo 模式中添加局部绑定 <code>C-c n</code> 、 <code>C-c p</code> ，并移除 <code>C-c C-x x</code> 的绑定：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'texinfo-mode-hook
          (<span style="color: #a020f0;">lambda</span> ()
            (keymap-set texinfo-mode-map <span style="color: #8b2252;">"C-c p"</span> 'backward-paragraph)
            (keymap-set texinfo-mode-map <span style="color: #8b2252;">"C-c n"</span> 'forward-paragraph)
            (keymap-set texinfo-mode-map <span style="color: #8b2252;">"C-c C-x x"</span> nil)))
</pre>
</div>
</div>
</div>
<div id="outline-container-Modifier-Keys" class="outline-4">
<h4 id="Modifier-Keys"><span class="section-number-4">51.3.7.</span> 修饰键</h4>
<div class="outline-text-4" id="text-Modifier-Keys">
<p>
Emacs 的默认按键绑定对 <b>带修饰符的字母</b> 不区分大小写。也就是说， <code>C-A</code> 与 <code>C-a</code> 功能相同， <code>M-A</code> 与 <code>M-a</code> 功能相同。这一规则只适用于字母，不适用于其他按键的 <code>Shift</code> 版本；例如 <code>C-@</code> 和 <code>C-2</code> 就不是同一个按键。
</p>

<p>
带 Control 修饰符的字母通常被视为不区分大小写：Emacs 总是把 <code>C-A</code> 当作 <code>C-a</code> 、 <code>C-B</code> 当作 <code>C-b</code> ，依此类推。这是出于历史原因：在非图形化环境中，这些按键本身就没有区别。不过，在 <b>图形界面（GUI）</b> 中，你可以绑定带 <code>Shift</code> 的 <code>Control + 字母组合</code> ：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(keymap-global-set <span style="color: #8b2252;">"C-S-n"</span> #'previous-line)
</pre>
</div>

<p>
对于其他所有修饰符，你都可以在自定义 Emacs 时让修饰后的字母区分大小写（即使在非图形界面也可以）。例如，你可以让 <code>M-a</code> 和 <code>M-A</code> 执行不同命令。
</p>

<p>
虽然日常常用的只有 <code>Control</code> 和 <code>Meta</code> 修饰键，但 Emacs 还支持另外三种修饰键： <code>Super</code> 、 <code>Hyper</code>  和 <code>Alt</code> 。大多数终端不支持使用这些修饰键；键盘上标注的 <code>Alt</code> 键通常发出的是 <code>Meta</code> 信号，而非 <code>Alt</code> 。Emacs 的标准按键绑定中 <b>没有</b> 使用 <code>Super</code> 、 <code>Hyper</code> 的按键，使用 <code>Alt</code> 的也很少。但你可以自定义这些修饰键的绑定。它们的标识分别是：
</p>
<ul class="org-ul">
<li>'s-' ：Super</li>
<li>'H-' ：Hyper</li>
<li>'A-' ：Alt</li>
</ul>

<p>
即使你的键盘没有这些额外修饰键，也可以用 <code>C-x @</code> 来输入：
</p>
<ul class="org-ul">
<li><code>C-x @ h</code> 给下一个字符加上 Hyper 修饰</li>
<li><code>C-x @ s</code> 给下一个字符加上 Super 修饰</li>
<li><code>C-x @ a</code> 给下一个字符加上 Alt 修饰</li>
</ul>

<p>
例如， <code>C-x @ h C-a</code> 就相当于输入 <code>Hyper-Control-a</code> 。（但不能对同一个字符连续按两次 <code>C-x @</code> 来叠加两个修饰符，因为第一次修饰会作用在 <code>C-x</code> 上。）同理，也可以用 <code>C-x @ S</code> 、 <code>C-x @ c</code> 、 <code>C-x @ m</code> 分别输入 <code>Shift</code> 、 <code>Control</code> 、 <code>Meta</code> ，只是很少用到。
</p>

<p>
在图形终端下，你可以开启 修饰键栏模式（Modifier Bar mode），通过点击工具栏按钮来模拟缺少的修饰键。参见 “<a href="#Tool-Bars">工具栏</a>”。
</p>
</div>
</div>
<div id="outline-container-Function-Keys" class="outline-4">
<h4 id="Function-Keys"><span class="section-number-4">51.3.8.</span> 重新绑定功能键</h4>
<div class="outline-text-4" id="text-Function-Keys">
<p>
按键序列可以包含普通字符，也可以包含功能键。Lisp 用字符（实际是整数）表示键盘上的普通字符，用Lisp 符号表示功能键。如果一个功能键的标签是一个单词，那么这个单词就是对应 Lisp 符号的名称。下面是常见功能键在 Lisp 中的常规名称：
</p>
<dl class="org-dl">
<dt><code>left</code>, <code>up</code>, <code>right</code>, <code>down</code></dt><dd>光标方向键。</dd>
<dt><code>begin</code>, <code>end</code>, <code>home</code>, <code>next</code>, <code>prior</code></dt><dd>其他光标定位键。</dd>
<dt><code>select</code>, <code>print</code>, <code>execute</code>, <code>backtab</code></dt><dd></dd>

<dt><code>insert</code>, <code>undo</code>, <code>redo</code>, <code>clearline</code></dt><dd></dd>

<dt><code>insertline</code>, <code>deleteline</code>, <code>insertchar</code>, <code>deletechar</code></dt><dd>杂项功能键。</dd>
<dt><code>f1</code>, <code>f2</code>, … <code>f35</code></dt><dd>编号功能键（键盘顶部的功能键）。</dd>
<dt><code>kp-add</code>, <code>kp-subtract</code>, <code>kp-multiply</code>, <code>kp-divide</code></dt><dd></dd>

<dt><code>kp-backtab</code>, <code>kp-space</code>, <code>kp-tab</code>, <code>kp-enter</code></dt><dd></dd>

<dt><code>kp-separator</code>, <code>kp-decimal</code>, <code>kp-equal</code></dt><dd></dd>

<dt><code>kp-prior</code>, <code>kp-next</code>, <code>kp-end</code>, <code>kp-home</code></dt><dd></dd>

<dt><code>kp-left</code>, <code>kp-up</code>, <code>kp-right</code>, <code>kp-down</code></dt><dd></dd>

<dt><code>kp-insert</code>, <code>kp-delete</code></dt><dd>小键盘按键（主键盘右侧），包含符号或功能键。</dd>
<dt><code>kp-0</code>, <code>kp-1</code>, … <code>kp-9</code></dt><dd>小键盘数字键。</dd>
<dt><code>kp-f1</code>, <code>kp-f2</code>, <code>kp-f3</code>, <code>kp-f4</code></dt><dd>小键盘 PF 键。</dd>
</dl>

<p>
这些名称是通用惯例，但某些系统（尤其是使用 X 窗口时）可能使用不同名称。想要确定你的终端上某个功能键对应的具体符号，可以按 <code>C-h c</code> 再按该键查看。
</p>

<p>
关于绑定功能键的示例，参见「<a href="#Init-Rebinding">在初始化文件中重新绑定按键</a>」。
</p>

<p>
很多键盘右侧带有数字小键盘。小键盘上的数字键同时也是光标移动键，由标有 'Num Lock' 的按键切换。默认情况下，Emacs 会将这些按键翻译为主键盘上对应的按键。例如：
</p>
<ul class="org-ul">
<li>当 'Num Lock' 开启时，小键盘上标有 '8' 的键产生 <code>kp-8</code> ，会被翻译成 <code>8</code> ；</li>
<li>当 'Num Lock' 关闭时，同一个键产生 <code>kp-up</code> ，会被翻译成 <code>UP</code> 。</li>
</ul>

<p>
如果你重新绑定了 <code>8</code> 或 <code>UP</code> 这类按键，对应的小键盘按键也会受影响。但是，如果你直接重新绑定某个 'kp-' 开头的按键，则不会影响主键盘上的等价按键。注意：带修饰符的按键不会被翻译。例如，按住 <code>Meta</code> 键再按小键盘的 '8' ，会生成 <code>M-kp-8</code> 。
</p>

<p>
Emacs 提供了便捷方式来绑定数字小键盘按键，通过以下变量： <code>keypad-setup</code> 、 <code>keypad-numlock-setup</code> 、 <code>keypad-shifted-setup</code> 、 <code>keypad-numlock-shifted-setup</code> 。这些选项可以在 <code>keyboard</code> 自定义组中找到（参见<a href="#Easy-Customization">简易自定义界面</a>）。你可以重新绑定这些按键以实现其他功能，例如输入数字前缀参数。
</p>
</div>
</div>
<div id="outline-container-Named-ASCII-Chars" class="outline-4">
<h4 id="Named-ASCII-Chars"><span class="section-number-4">51.3.9.</span> 命名 ASCII 控制字符</h4>
<div class="outline-text-4" id="text-Named-ASCII-Chars">
<p>
TAB、RET、BS、LFD、ESC 和 DEL 最初是某些 ASCII 控制字符的名称，它们使用极为频繁，因此拥有了专属的特殊按键。例如， <code>TAB</code> 原本就是 <code>C-i</code> 的另一种写法。后来，用户发现在 Emacs 中区分这些按键与用 <code>Ctrl</code> 输入的对应控制字符会更方便。因此，在大多数现代终端上，它们 <b>不再等同</b> ： <code>TAB</code> 与 <code>C-i</code> 是不同的按键。
</p>

<p>
如果键盘支持区分，Emacs 就能识别这两种输入。它会把这些特殊按键当作名称为 <code>tab</code> 、 <code>return</code> 、=backspace= 、 <code>linefeed</code> 、 <code>escape</code> 和 <code>delete</code> 的功能键来处理。如果这些功能键没有自己的绑定，会自动转成对应的 ASCII 字符。这样一来，除非特意区分，用户和 Lisp 程序都无需在意二者差别。
</p>

<p>
如果你不想区分（例如） <code>TAB</code> 和 <code>C-i</code> ，只需为 ASCII 字符 <code>TAB</code> （八进制码 011）设置一次绑定即可。如果你 <b>希望</b> 区分，就分别为该 ASCII 字符和功能键 <code>tab</code> 各设一个绑定。
</p>

<p>
在普通 ASCII 终端上，无法区分 <code>TAB</code> 和 <code>C-i</code> （其他同类组合也一样），因为终端在两种情况下发送的是同一个字符。
</p>
</div>
</div>
<div id="outline-container-Mouse-Buttons" class="outline-4">
<h4 id="Mouse-Buttons"><span class="section-number-4">51.3.10.</span> 重新绑定鼠标按钮</h4>
<div class="outline-text-4" id="text-Mouse-Buttons">
<p>
Emacs 同样使用 Lisp 符号来表示鼠标按键。Emacs 中的普通鼠标事件是 <b><i>click events点击事件</i></b> ：在按下并松开按键、且未移动鼠标时触发。你也可以获得 <b><i>drag events拖动事件</i></b> ：按住按键的同时移动鼠标，在最终松开时触发。
</p>

<p>
基础点击事件的符号为： <code>mouse-1</code> 表示最左侧按键， <code>mouse-2</code> 为下一个，依此类推。例如，可将第二个鼠标按键重新定义为分割当前窗口：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(keymap-global-set <span style="color: #8b2252;">"&lt;mouse-2&gt;"</span> 'split-window-below)
</pre>
</div>

<p>
拖动事件的符号类似，只是在 'mouse' 前加前缀 'drag-' 。例如，拖动第一个按键会生成 <code>drag-mouse-1</code> 事件。
</p>

<p>
你还可以为 <b>按下鼠标按键瞬间</b> 的事件定义绑定。这类事件以 'down-' 而非 'drag-' 开头，且只有在存在绑定时才会生成。当你收到一个按下事件后，必然会跟随一个对应的点击或拖动事件。
</p>

<p>
你可以区分 <b>single单击、double双击、triple clicks三击</b> 。双击是指在大致相同位置快速点击同一按键两次。第一次点击产生普通点击事件；如果第二次点击足够快，则会产生 <b>双击事件</b> 。双击事件的类型以 'double-' 开头，例如 <code>double-mouse-3</code> 。
</p>

<p>
这意味着你可以给同一位置的第二次点击赋予特殊含义，但必须基于第一次点击已经执行了普通单击的绑定。
</p>

<p>
这虽然限制了双击能做的事，但界面设计规范建议任何情况下都应遵守这一约束：双击应做与单击类似、但更进一步的操作，双击命令只需负责额外的工作。
</p>

<p>
如果某个双击事件没有绑定，会自动降级为对应单击事件。因此，若未专门定义双击，它会执行两次单击命令。
</p>

<p>
Emacs 同样支持以 'triple-' 开头的 <b>三击事件</b> 。Emacs 不把四击当作独立事件类型，三次以上的点击会继续生成三击事件。不过点击总数会记录在事件列表中，熟悉 Emacs Lisp 可自行区分（详见《Emacs Lisp 参考手册》的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Click-Events.html#Click-Events">点击事件</a>）。不建议为超过三击的点击设置独立含义，但可以让后续点击循环复用前三种含义：四击 = 单击，五击 = 双击，六击 = 三击。
</p>

<p>
Emacs 还会在拖动与按下事件中记录多次点击。例如：双击后按住拖动，会产生 'double-drag-' 事件；第二次按下瞬间会产生 'double-down-' 事件（若无绑定则和所有按下事件一样被忽略）。
</p>

<p>
变量 <code>double-click-time</code> 设定多击之间允许的最大间隔时间，单位毫秒： <code>nil</code> ：不识别双击； <code>t</code> ：无时间限制；默认：500（0.5 秒）
</p>

<p>
变量 <code>double-click-fuzz</code> 设定多击之间允许的鼠标最大移动距离：图形界面：单位为像素；文本终端：单位为 1/8 字符宽度；默认：3
</p>

<p>
鼠标事件符号中也可体现修饰键状态，使用常见前缀： ‘C-’、‘M-’、‘H-’、‘s-’、‘A-’、‘S-’。修饰键前缀永远在 ‘double-’/‘triple-’ 之前，后者又永远在 ‘drag-’/‘down-’ 之前。
</p>

<p>
窗口中存在不显示缓冲区文本的特殊区域，如模式行、滚动条。可通过 <b>虚拟前缀键</b> 判断鼠标事件是否来自这些区域。例如，在模式行中点击鼠标，会在普通鼠标符号前加上前缀 <code>mode-line</code> 。下面示例将模式行上的鼠标左键点击绑定到 <code>scroll-up-command</code> ：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(keymap-global-set <span style="color: #8b2252;">"&lt;mode-line&gt; &lt;mouse-1&gt;"</span> 'scroll-up-command)
</pre>
</div>

<p>
完整虚拟前缀键列表：
</p>
<dl class="org-dl">
<dt><code>mode-line</code></dt><dd>鼠标位于窗口模式行。</dd>
<dt><code>vertical-line</code></dt><dd>鼠标位于并排窗口间的垂直分隔线（若有滚动条则会取代该位置）。</dd>
<dt><code>vertical-scroll-bar</code></dt><dd>鼠标位于垂直滚动条（Emacs 当前仅支持此类滚动条）。</dd>
<dt><code>menu-bar</code></dt><dd>鼠标位于菜单栏。</dd>
<dt><code>tab-bar</code></dt><dd>鼠标位于标签栏。</dd>
<dt><code>tab-line</code></dt><dd>鼠标位于标签行。</dd>
<dt><code>header-line</code></dt><dd>鼠标位于标题行。</dd>
</dl>

<p>
你可以在一个按键序列中放入多个鼠标按键，但这并不常用。
</p>
</div>
</div>
<div id="outline-container-Disabling" class="outline-4">
<h4 id="Disabling"><span class="section-number-4">51.3.11.</span> 禁用命令</h4>
<div class="outline-text-4" id="text-Disabling">
<p>
<b>Diabling a command禁用命令</b> 是指：以交互方式调用该命令时，Emacs 会要求用户确认。禁用命令的目的是 <b>防止用户误执行</b> ，主要用于那些对新手可能造成困扰的命令。
</p>

<p>
在 Emacs 中尝试调用被禁用的交互命令时，会立即弹出一个窗口，显示命令名、文档以及操作说明；然后 Emacs 会等待你的输入，让你选择：
</p>
<ul class="org-ul">
<li>按要求执行该命令</li>
<li>启用该命令并执行</li>
<li>取消操作</li>
</ul>

<p>
如果你选择启用命令，还需要再回答一个问题：是永久启用，还是仅当前会话有效。（永久启用会自动修改你的初始化文件。）你也可以按 <code>!</code> ，仅在当前会话中启用所有命令。
</p>

<p>
禁用命令的底层机制是：给命令对应的 Lisp 符号设置一个非 nil 的 <code>disabled</code> 属性。对应的 Lisp 代码如下：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(put 'delete-region 'disabled t)
</pre>
</div>

<p>
如果 <code>disabled</code> 属性的值是一个字符串，该字符串会在调用命令时一起显示：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(put 'delete-region 'disabled
     <span style="color: #8b2252;">"&#24314;&#35758;&#20248;&#20808;&#20351;&#29992; `</span><span style="color: #008b8b;">kill-region</span><span style="color: #8b2252;">'&#12290;\n"</span>)
</pre>
</div>

<p>
除了直接禁用命令，你还可以选择更温和的方式：执行前询问。例如，想在执行 <code>M-&gt;</code> (<code>end-of-buffer</code>) 命令前弹出确认，可以在初始化文件中加入：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(command-query
 'end-of-buffer
 <span style="color: #8b2252;">"&#30830;&#23450;&#35201;&#36339;&#36716;&#21040;&#32531;&#20914;&#21306;&#26411;&#23614;&#21527;&#65311;"</span>)
</pre>
</div>

<p>
默认会用 y/n 询问；如果给第三个可选参数传非 nil 值，则会用 yes/no 询问。
</p>

<p>
你可以通过两种方式禁用命令：直接编辑初始化文件；使用命令 <code>M-x disable-command</code> ，它会自动帮你修改初始化文件。同理， <code>M-x enable-command</code> 会修改初始化文件，永久启用某个命令。参见《<a href="#Init-File">Emacs 初始化文件</a>》。
</p>

<p>
如果 Emacs 以 '<code>-q</code>' 或 '<code>--no-init-file</code>' 参数启动（参见<a href="#Initial-Options">启动选项</a>），它不会修改你的初始化文件。因为 Emacs 没有加载过你的配置，修改可能导致信息丢失。
</p>

<p>
一个命令是否被禁用，与调用它的按键无关；即使通过 <code>M-x</code> 调用，禁用规则同样生效。但是，从 Lisp 程序中作为函数调用该命令时，禁用不会生效。
</p>
</div>
</div>
</div>
<div id="outline-container-Init-File" class="outline-3">
<h3 id="Init-File"><span class="section-number-3">51.4.</span> Emacs 初始化文件</h3>
<div class="outline-text-3" id="text-Init-File">
<p>
Emacs 启动时，通常会尝试从 <i>initialization file初始化文件</i> （简称 init file）加载一个 Lisp 程序。如果该文件存在，它会定义如何为你初始化 Emacs，以及如何定制各种可选功能。你通过 <code>M-x customize</code> 进行的自定义设置（参见<a href="#Easy-Customization">简易自定义界面</a>），默认也会保存在初始化文件中（参见<a href="#Saving-Customizations">保存自定义设置</a>）。
</p>

<p>
传统上使用 <code>~/.emacs</code> 作为初始化文件，不过 Emacs 也会查找以下位置： <code>~/.emacs.el</code> 、 <code>~/.emacs.d/init.el</code> 、 <code>~/.config/emacs/init.el</code> 等。参见《<a href="#Find-Init">Emacs 如何找到你的初始化文件</a>》。
</p>

<p>
如果你希望把所有 Emacs 配置集中在一个目录里，推荐使用： <code>~/.emacs.d/init.el</code> 或符合 XDG 规范的 <code>~/.config/emacs/init.el</code> 。
</p>

<p>
你可以使用命令行参数： '<code>-q</code>'：禁止加载你的初始化文件； '<code>-u</code>'（或 '<code>--user</code>'）：指定加载其他用户的初始化文件。参见《<a href="#Initial-Options">启动选项</a>》。
</p>

<p>
还存在一个 <b>默认初始化文件</b> ，它是名为 <code>default.el</code> 的库文件，Emacs 会在标准库搜索路径中查找。官方发行版中并不自带该文件，通常由系统管理员创建，用于存放全局公共配置。如果该文件存在，每次启动 Emacs 都会加载（使用 '<code>-q</code>' 时除外）。 <b>但你的个人初始化文件会优先加载</b> ；如果其中把 <code>inhibit-default-init</code> 设置为非 nil，则不会再加载 <code>default.el</code> 。
</p>

<p>
你的系统还可能有一个 <b>站点启动文件</b> ，名为 <code>site-start.el</code> 。与 <code>default.el</code> 一样，Emacs 会在标准 Lisp 库路径中查找该文件，并在 <b>加载你的个人配置之前</b> 优先加载它。若要禁止加载该文件，可以使用参数 '<code>--no-site-file</code>' 。参见《<a href="#Initial-Options">启动选项</a>》。不建议把部分用户不喜欢的配置放在 <code>site-start.el</code> 中，更适合放在 <code>default.el</code> ，方便用户自行覆盖。
</p>

<p>
你可以把 <code>default.el</code> 和 <code>site-start.el</code> 放在 Emacs 搜索 Lisp 库的任意目录下。变量 <code>load-path</code> （参见《<a href="#Lisp-Libraries">Emacs Lisp 代码库</a>》）定义了这些目录。很多系统会把这些文件放在 Emacs 安装目录下的 <code>site-lisp</code> 子目录，例如： <code>/usr/local/share/emacs/site-lisp</code> 。
</p>

<p>
不建议对你的初始化文件进行字节编译（参见《Emacs Lisp 参考手册》中的<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Byte-Compilation.html#Byte-Compilation">字节编译</a>）。它通常不会明显加快启动速度，而且忘记重新编译时还容易出问题。更好的做法是使用 Emacs Server 减少启动次数（参见《<a href="#Emacs-Server">将 Emacs 作为服务器使用</a>》）。如果你的配置里定义了大量函数，建议把它们移到单独的文件里并进行字节编译，再在初始化文件中加载。
</p>

<p>
如果你要编写超出简单自定义范围的真实 Emacs Lisp 程序，应当阅读《Emacs Lisp 参考手册》。参见《Emacs Lisp 参考手册》中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/index.html#Top">Emacs Lisp</a> 章节。
</p>

<ul class="org-ul">
<li><a href="#Init-Syntax">初始化文件语法</a></li>
<li><a href="#Init-Examples">初始化文件示例</a></li>
<li><a href="#Terminal-Init">终端专用初始化</a></li>
<li><a href="#Find-Init">Emacs 查找初始化文件的方式</a></li>
<li><a href="#Init-Non_002dASCII">初始化文件中的非 ASCII 字符</a></li>
<li><a href="#Early-Init-File">早期初始化文件</a></li>
</ul>
</div>
<div id="outline-container-Init-Syntax" class="outline-4">
<h4 id="Init-Syntax"><span class="section-number-4">51.4.1.</span> 初始化文件语法</h4>
<div class="outline-text-4" id="text-Init-Syntax">
<p>
初始化文件中包含一个或多个 Lisp 表达式。每个表达式由一个函数名后跟若干参数组成，整体用括号包裹。例如： <code>(setq fill-column 60)</code> 会调用 <code>setq</code> 函数，将变量 <code>fill-column</code> （参见 “<a href="#Filling">文本填充</a>”）设为 60。
</p>

<p>
你可以用 <code>setq</code> 设置任意 Lisp 变量，但在初始化文件中，对某些变量直接用 setq 可能达不到预期效果。有些变量在用 <code>setq</code> 设置时会自动变成 <b>buffer-local缓冲区局部变量</b> ；而在初始化文件中，你通常需要设置它的 <b>默认值</b> ，这时应使用 <code>setq-default</code> 。（下一节会同时给出这两种写法的示例。）
</p>

<p>
部分可定制的次要模式变量，在通过自定义界面（Customize） 设置时会自动启用对应模式，但普通的 <code>setq</code> 不会触发这一逻辑；若要在初始化文件中启用该模式，需要直接调用对应的次要模式命令。最后，少数可定制用户选项的初始化逻辑比较复杂，这类变量必须通过自定义界面设置（参见 “<a href="#Customization">自定义</a>”），或使用 <code>customize-set-variable</code> / <code>setopt</code> （参见 “<a href="#Examining">查看与设置变量</a>”）。
</p>

<p>
<code>setq</code> 的第二个参数是表示变量新值的表达式。它可以是常量、变量或函数调用表达式。在初始化文件中，常量是最常用的形式，包括：
</p>
<dl class="org-dl">
<dt>Numbers</dt><dd>数字以十进制书写，可在开头带负号。</dd>
<dt>String</dt><dd><p>
Lisp 字符串语法与 C 字符串基本相同，并增加了一些扩展特性。字符串常量以双引号 <code>"</code> 开始和结束。
</p>

<p>
字符串中可以直接包含换行符与特殊字符，但通常使用反斜杠转义序列更清晰：
</p>
<ul class="org-ul">
<li>'<code>\n</code>' 换行</li>
<li>'<code>\b</code>' 退格</li>
<li>'<code>\r</code>' 回车</li>
<li>'<code>\t</code>' 制表符</li>
<li>'<code>\f</code>' 换页（Ctrl-L）</li>
<li>'<code>\e</code>' 转义</li>
<li>'<code>\\</code>' 反斜杠本身</li>
<li>'<code>\"</code>' 双引号</li>
<li>'<code>\ooo</code>' 八进制编码为 ooo 的字符</li>
</ul>

<p>
反斜杠与双引号是必须使用转义的字符。
</p>

<p>
'<code>\C-</code>' 可作为控制字符前缀，例如 '<code>\C-s</code> 表示 <code>Ctrl-S=； '</code>\M-<code>' 可作为 Meta 字符前缀，例如 '</code>\M-a=' 表示 <code>Meta-A</code> ， '<code>\M-\C-a</code>' 表示 <code>Ctrl-Meta-A</code> 。
</p>

<p>
关于在初始化文件中使用非 ASCII 字符，参见 “<a href="#Init-Non_002dASCII">初始化文件中的非 ASCII 字符</a>”。
</p></dd>

<dt>Characters</dt><dd><p>
Lisp 字符常量以 '?' 开头，后跟一个字符或以 '<code>\</code>' 开头的转义序列。示例： <code>?x</code> 、 <code>?\n</code> 、 <code>?\"</code> 、 <code>?\</code> )。注意：在 Lisp 中，字符串与字符不可互换，某些语境只能用字符串，某些只能用字符。
</p>

<p>
关于将命令绑定到发送非 ASCII 字符的按键，参见 “<a href="#Init-Non_002dASCII">初始化文件中的非 ASCII 字符</a>”。
</p></dd>

<dt>True</dt><dd><code>t</code> 表示 “真”。</dd>

<dt>Fasle</dt><dd><code>nil</code> 表示 “假”。</dd>

<dt>其他 Lisp 对象</dt><dd>写一个单引号 '，后跟你要使用的 Lisp 对象。</dd>
</dl>

<p>
如需了解更多 Emacs Lisp 语法，参见《Emacs Lisp 参考手册》中的 “<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Introduction.html#Introduction">简介</a>” 部分。
</p>
</div>
</div>
<div id="outline-container-Init-Examples" class="outline-4">
<h4 id="Init-Examples"><span class="section-number-4">51.4.2.</span> 初始化文件示例</h4>
<div class="outline-text-4" id="text-Init-Examples">
<p>
下面是一些用 Lisp 表达式实现常见需求的示例：
</p>

<ul class="org-ul">
<li><p>
将一个目录添加到 <code>load-path</code> 变量中。之后你就可以把 Emacs 自带之外的 Lisp 库放在这个目录里，并通过 <code>M-x load-library</code> 加载它们。参见《<a href="#Lisp-Libraries">Emacs Lisp 代码库</a>》。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-to-list 'load-path <span style="color: #8b2252;">"/path/to/lisp/libraries"</span>)
</pre>
</div></li>

<li><p>
在 C 模式中，如果光标在一行中间，按 <code>TAB</code> 只插入一个制表符。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq</span> c-tab-always-indent nil)
</pre>
</div>

<p>
这里的变量取值通常是 <code>t</code> （真），另一种取值是 <code>nil</code> （假）。
</p></li>

<li><p>
默认让搜索区分大小写（在所有未覆盖该设置的缓冲区中生效）。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq-default</span> case-fold-search nil)
</pre>
</div>

<p>
这会设置默认值，对所有没有为该变量设置局部值的缓冲区生效（见<a href="#Locals">局部变量</a>）。如果用 <code>setq</code> 设置 <code>case-fold-search</code> ，只会影响当前缓冲区的局部值，这通常不是你在初始化文件里想要的效果。
</p></li>

<li><p>
指定你自己的邮箱地址（如果 Emacs 无法正确识别）。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq</span> user-mail-address <span style="color: #8b2252;">"&#20320;&#30340;&#37038;&#31665;@example.com"</span>)
</pre>
</div>

<p>
许多 Emacs 包（如 Message 模式）在需要知道你的邮箱时会查阅 <code>user-mail-address</code> 。
各种 Emacs 包（例如 Message 模式）在需要知道你的电子邮件地址时，都会读取 <code>user-mail-address</code> 。参见 “<a href="#Mail-Headers">邮件头字段</a>”。
</p></li>

<li><p>
将文本模式设为新建缓冲区的默认模式。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq-default</span> major-mode 'text-mode)
</pre>
</div>

<p>
注意这里使用 <code>text-mode</code> ，因为它是进入文本模式的命令。其前面的单引号会把这个符号变成常量；否则 <code>text-mode</code> 会被当作变量名处理。
</p></li>

<li><p>
为支持大部分西欧语言的 Latin-1 字符集设置默认环境。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(set-language-environment <span style="color: #8b2252;">"Latin-1"</span>)
</pre>
</div></li>

<li><p>
关闭行号模式（一个全局次要模式）。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(line-number-mode 0)
</pre>
</div></li>

<li><p>
在文本模式及相关模式中自动启用自动换行模式（参见<a href="#Hooks">钩子</a>）。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-hook 'text-mode-hook 'auto-fill-mode)
</pre>
</div></li>

<li><p>
修改使用剪贴板时的编码系统（参见<a href="#Communication-Coding">进程间通信的编码系统</a>）。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setopt</span> selection-coding-system 'utf-8)
</pre>
</div></li>

<li><p>
加载已安装的名为 <code>foo</code> 的 Lisp 库（实际是标准 Emacs 目录下的 <code>foo.elc</code> 或 <code>foo.el</code> 文件）。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(load <span style="color: #8b2252;">"foo"</span>)
</pre>
</div></li>
</ul>


<p>
当 load 的参数是相对文件名（不以 '<code>/</code>' 或 '<code>~</code>' 开头）时， <code>load</code> 会在 <code>load-path</code> 目录列表中搜索（参见 <a href="#Lisp-Libraries">Emacs 的 Lisp 代码库</a>）。
</p>

<ul class="org-ul">
<li><p>
从你的家目录加载编译后的 Lisp 文件 <code>foo.elc</code> 。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(load <span style="color: #8b2252;">"~/foo.elc"</span>)
</pre>
</div>

<p>
这里使用的是完整文件名，因此不会进行目录搜索。
</p></li>

<li><p>
告诉 Emacs：通过加载名为 <code>mypackage</code> 的 Lisp 库（即 <code>mypackage.elc</code> 或 <code>mypackage.el</code> 文件）来查找函数 <code>myfunction</code> 的定义：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(autoload 'myfunction <span style="color: #8b2252;">"mypackage"</span> <span style="color: #8b2252;">"Do what I say."</span> t)
</pre>
</div>

<p>
其中字符串 "Do what I say." 是该函数的文档字符串。在自动加载定义中指定它，即使包尚未加载，帮助命令也能显示该说明。最后一个参数 <code>t</code> 表示此函数是交互式的，即可以通过键入 <code>M-x myfunction RET</code> 或绑定到按键来交互式调用。如果函数非交互式，则省略 <code>t</code> 或使用 <code>nil</code> 。
</p></li>

<li><p>
将按键 <code>C-x l</code> 重新绑定到函数 <code>make-symbolic-link</code> （参见<a href="#Init-Rebinding">在初始化文件中重新绑定按键</a>）。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(keymap-global-set <span style="color: #8b2252;">"C-x l"</span> 'make-symbolic-link)
</pre>
</div>
<p>
或
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(keymap-set global-map <span style="color: #8b2252;">"C-x l"</span> 'make-symbolic-link)
</pre>
</div>

<p>
再次注意：单引号用于引用符号 <code>make-symbolic-link</code> ，而非其变量值。
</p></li>

<li><p>
仅在 Lisp 模式下做同样的绑定。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(keymap-set lisp-mode-map <span style="color: #8b2252;">"C-x l"</span> 'make-symbolic-link)
</pre>
</div></li>

<li><p>
将基础模式中当前绑定到 <code>next-line</code> 的所有按键，重新定义为执行 <code>forward-line</code> 。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(keymap-substitute global-map 'next-line 'forward-line)
</pre>
</div></li>

<li><p>
取消 <code>C-x C-v</code> 的按键定义。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(keymap-global-unset <span style="color: #8b2252;">"C-x C-v"</span>)
</pre>
</div>

<p>
取消一个按键定义的原因之一是把它设为前缀键。只要给 <code>C-x C-v</code> 定义任何内容，它就会成为前缀，但必须先解除它原本非前缀的定义。
</p></li>
<li><p>
让符号 '<code>$</code>' 在文本模式中具有标点符号的语法属性。注意这里使用了字符常量 '<code>$</code>'。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(modify-syntax-entry ?\$ <span style="color: #8b2252;">"."</span> text-mode-syntax-table)
</pre>
</div></li>

<li><p>
允许无确认地使用 <code>narrow-to-region</code> 命令。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(put 'narrow-to-region 'disabled nil)
</pre>
</div></li>

<li><p>
根据不同平台与 Emacs 版本调整配置。
</p>

<p>
用户通常希望 Emacs 在所有系统上行为一致，因此同一个初始化文件适用于所有平台。但有时，你用于自定义 Emacs 的某个函数在某些平台或旧版 Emacs 中不可用。要处理这种情况，可以把相关配置放在条件判断里，先检测函数或功能是否存在，示例如下：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">if</span> (fboundp 'blink-cursor-mode)
    (blink-cursor-mode 0))

(<span style="color: #a020f0;">if</span> (boundp 'coding-category-utf-8)
    (set-coding-priority '(coding-category-utf-8)))
</pre>
</div>

<p>
你也可以直接忽略函数未定义时产生的错误：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">ignore-errors</span> (set-face-background 'region <span style="color: #8b2252;">"grey75"</span>))
</pre>
</div>

<p>
对不存在的变量使用 <code>setq</code> 通常无害，因此这类语句不需要加条件。
</p></li>

<li><p>
使用 <code>use-package</code> 自动加载并配置包。
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">use-package</span> hi-lock
  <span style="color: #483d8b;">:defer</span> t
  <span style="color: #483d8b;">:init</span> (add-hook 'some-hook 'hi-lock-mode)
  <span style="color: #483d8b;">:config</span> (<span style="color: #a020f0;">use-package</span> my-hi-lock)
  <span style="color: #483d8b;">:bind</span> ((<span style="color: #8b2252;">"M-o l"</span> . highlight-lines-matching-regexp)
         (<span style="color: #8b2252;">"M-o r"</span> . highlight-regexp)
         (<span style="color: #8b2252;">"M-o w"</span> . highlight-phrase)))
</pre>
</div>

<p>
这段配置会在 <code>hi-lock</code> 的命令或变量首次被使用时延迟加载，绑定 3 个按键到其命令，并在加载 <code>hi-lock</code> 后额外加载 <code>my-hi-lock</code> 包（用于进一步定制 <code>hi-lock</code> ）。 <code>use-package</code> 功能有完整的官方手册，参见 <a href="https://www.gnu.org/software/emacs/manual/html_node/use-package_html/index.html#Top">use-package 用户手册</a>。
</p></li>
</ul>
</div>
</div>
<div id="outline-container-Terminal-Init" class="outline-4">
<h4 id="Terminal-Init"><span class="section-number-4">51.4.3.</span> 终端专用初始化</h4>
<div class="outline-text-4" id="text-Terminal-Init">
<p>
每种终端类型都可以对应一个 Lisp 库，当 Emacs 在该类型终端上运行时会自动加载这个库。对于名为 <i>termtype</i> 的终端类型，对应的库为 <code>term</code> / <code>termtype</code> 。（如果关联列表 <code>term-file-aliases</code> 中存在形如 (termtype . alias) 的条目，Emacs 会用 alias 代替 termtype。）该库会按照常规方式在 <code>load-path</code> 目录中搜索，并尝试后缀 <code>.elc</code> 和 <code>.el</code> 。通常它位于大多数 Emacs 库所在目录的 <code>term</code> 子目录下。
</p>

<p>
终端专用库的常见用途是：借助 <code>input-decode-map</code> ，将终端功能键发出的转义序列映射为更有意义的名称。可参考文件 <code>term/lk201.el</code> 了解具体实现方式。许多功能键会根据 Termcap 数据库中的信息自动映射；终端专用库只需负责映射那些 Termcap 未定义的功能键。
</p>

<p>
当终端类型名称中包含连字符时，在选择库名时 <b>只取第一个连字符之前的部分</b> 。因此，终端类型 'aaa-48' 和 'aaa-30-rv' 都会使用同一个库 term/aaa。库中的代码可以通过 <code>(getenv "TERM")</code> 获取完整的终端类型名称。
</p>

<p>
库名由变量 <code>term-file-prefix</code> 的值与终端类型名拼接而成。你可以在 <code>.emacs</code> 文件中将 <code>term-file-prefix</code> 设置为 <code>nil</code> ，从而禁止加载终端专用库。
</p>

<p>
Emacs 会在初始化的最后阶段运行钩子 <code>tty-setup-hook</code> ，此时 <code>.emacs</code> 文件与所有终端专用库都已加载完毕。如果你想覆盖部分终端专用库的设置，或是为没有对应库的终端定义初始化逻辑，可以向这个钩子添加函数。参见 Hooks（<a href="#Hooks">钩子</a>）。
</p>
</div>
</div>
<div id="outline-container-Find-Init" class="outline-4">
<h4 id="Find-Init"><span class="section-number-4">51.4.4.</span> Emacs 查找初始化文件的方式</h4>
<div class="outline-text-4" id="text-Find-Init">
<p>
Emacs 通常会在你家目录下的某个位置查找初始化文件<sup><a id="fnr.26" class="footref" href="#fn.26" role="doc-backlink">26</a></sup>。详见《<a href="#Init-File">Emacs 初始化文件</a>》。
</p>

<p>
Emacs 按以下顺序查找初始化文件： <code>~/.emacs.el</code> 、 <code>~/.emacs</code> 或 <code>~/.emacs.d/init.el</code> ，你可以任选其中一个文件名使用。（注意：只有直接位于家目录下的位置，其基本名才以点开头。）
</p>

<p>
Emacs 还会在 XDG 兼容路径 下查找 <code>init.el</code> ，默认目录为 <code>~/.config/emacs</code> 。你可以通过设置环境变量 <code>XDG_CONFIG_HOME</code> 来覆盖该路径，它的值会替换掉默认 XDG 初始化文件路径中的 <code>~/.config</code> 。但是，如果 <code>~/.emacs.d</code> 、 <code>~/.emacs</code> 或 <code>~/.emacs.el</code> 存在，会优先使用这些路径。这意味着，你必须删除或重命名它们，才能使用 XDG 路径。
</p>

<p>
另外注意：如果 XDG 路径和 <code>~/.emacs.d</code> 都不存在，Emacs 会 <b>自动创建</b>  <code>~/.emacs.d</code> （并在后续启动时使用它）。
</p>

<p>
Emacs 会把 <code>user-emacs-directory</code> 设置为它最终决定使用的目录。该目录随后会被用来查找其他用户专属的 Emacs 文件，例如：
</p>
<ul class="org-ul">
<li><code>custom-file</code> （见 <a href="#Saving-Customizations">保存自定义设置</a>）</li>
<li>保存的桌面会话（见 <a href="#Saving-Emacs-Sessions">保存 Emacs 会话</a>）</li>
<li>以及其他文件。</li>
</ul>

<p>
它还会被用来计算 <code>native-comp-eln-load-path</code> 的值（详见 <a href="#Lisp-Libraries">Emacs Lisp 代码库</a>），这是 Emacs 查找原生编译 Lisp 代码、以及存放异步编译包生成的新编译代码的地方。命令行选项 '<code>--init-directory</code>' （详见<a href="#Initial-Options">初始化选项</a>）可以覆盖上述搜索用户初始化文件后确定的 <code>user-emacs-directory</code> 值。
</p>

<p>
由于 <code>user-emacs-directory</code> 一旦由 Emacs 确定后，启动流程的其余部分会用它来定位其他文件和目录，我们不建议在你的初始化文件中修改它的值，否则可能干扰或破坏 Emacs 会话的正常启动。
</p>

<p>
尽管这种做法能兼容旧版 Emacs，但现代 POSIX 平台更推荐将初始化文件放在 <code>~/.config</code> 下，这样在排查因损坏的初始化文件导致的问题，或归档配置文件时，只需重命名该目录即可。
</p>

<p>
为了让旧版 Emacs 也能在当前默认位置找到配置文件，你可以执行下面这行 Emacs Lisp 代码：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(make-symbolic-link <span style="color: #8b2252;">".config/emacs"</span> <span style="color: #8b2252;">"~/.emacs.d"</span>)
</pre>
</div>

<p>
但是，如果你从 su 启动的 shell 中运行 Emacs，且环境中未设置 <code>XDG_CONFIG_HOME</code> ，Emacs 会尝试查找你自己的初始化文件，而不是当前切换到的用户的文件。这样做的目的是：即使你以超级用户身份运行，也能使用你自己的编辑器配置。
</p>

<p>
更精确地说：Emacs 首先确定要使用哪个用户的初始化文件。它从环境变量 <code>LOGNAME</code> 和 <code>USER</code> 中获取你的用户名；如果两者都不存在，则使用有效用户 ID。如果该用户名与真实用户 ID 匹配，Emacs 就使用 <code>HOME</code> ；否则，它会在系统用户数据库中查找对应用户名的家目录。
</p>

<p>
为简洁起见，Emacs 其余文档通常只使用当前默认路径 <code>~/.emacs.d/init.el</code> 来指代初始化文件。
</p>
</div>
</div>
<div id="outline-container-Init-Non_002dASCII" class="outline-4">
<h4 id="Init-Non_002dASCII"><span class="section-number-4">51.4.5.</span> 初始化文件中的非 ASCII 字符</h4>
<div class="outline-text-4" id="text-Init-Non_002dASCII">
<p>
如果你的初始化文件在字符串或按键绑定中包含非 ASCII 字符（如带重音的字母），语言与编码系统可能会引发问题。
</p>

<p>
若要在初始化文件中使用非 ASCII 字符，你应当在初始化文件的第一行添加 <code>-*-coding: 编码系统-*-</code> 标记，并指定一个支持对应字符的编码系统。参见 “<a href="#Recognize-Coding">识别编码系统</a>”。这是因为，当 Emacs 读取初始化文件中使用这类字符串的部分时，用于解码非 ASCII 文本的默认设置可能尚未完成，可能导致 Emacs 错误解码这些字符串。之后应避免编写会以其他方式修改编码系统的 Emacs Lisp 代码，例如调用 <code>set-language-environment</code> 。
</p>

<p>
不直接使用非 ASCII 字符的一种替代方案是，使用《Emacs Lisp 参考手册》“<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/General-Escape-Syntax.html#General-Escape-Syntax">通用转义语法</a>” 一节中介绍的某种字符转义语法，这些语法可以仅用 ASCII 字符表示所有 Unicode 码点。
</p>

<p>
若要绑定非 ASCII 按键，必须使用向量形式（参见<a href="#Init-Rebinding">在初始化文件中重新绑定按键</a>）。不能使用字符串形式，因为非 ASCII 字符会被解析为 Meta 键。示例：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(global-set-key [?&#23383;&#31526;] 'some-function)
</pre>
</div>

<p>
先按下 <code>C-q</code> ，再按下你想要绑定的按键，即可插入对应的 <i>字符</i> 。
</p>
</div>
</div>
<div id="outline-container-Early-Init-File" class="outline-4">
<h4 id="Early-Init-File"><span class="section-number-4">51.4.6.</span> 早期初始化文件</h4>
<div class="outline-text-4" id="text-Early-Init-File">
<p>
Emacs 的绝大多数自定义配置都应当放在普通的初始化文件中。参见《<a href="#Init-File">Emacs 初始化文件</a>》。但有时需要让某些自定义配置在 Emacs 启动过程中早于普通初始化文件加载时就生效，这类配置可以放在 <b>早期初始化文件</b> 中： <code>~/.config/emacs/early-init.el</code> 或 <code>~/.emacs.d/early-init.el</code> 。
</p>

<p>
该文件会在 <b>包管理系统和图形界面（GUI）初始化之前</b> 被加载，因此你可以在其中自定义影响包初始化流程的变量，例如： <code>package-enable-at-startup</code> 、 <code>package-load-list</code> 、 <code>package-user-dir</code> 。注意：像 <code>package-archives</code> 这类 <b>只影响新包安装、不影响已安装包加载</b> 的变量，可以在普通初始化文件中自定义。参见《<a href="#Package-Installation">包安装</a>》。
</p>

<p>
<b>不建议</b> 把本来可以放在普通初始化文件中的配置移到 <code>early-init.el</code> 里。原因是：早期初始化文件在 GUI 初始化之前就读取，与 GUI 相关的自定义配置在 <code>early-init.el</code> 中 <b>无法可靠生效</b> ；而普通初始化文件是在 GUI 初始化之后才加载的。如果你必须在早期初始化文件中使用依赖 GUI 功能的配置，应将它们放到 Emacs 启动提供的钩子中运行，例如 <code>window-setup-hook</code> 或 <code>tty-setup-hook</code> 。参见《<a href="#Hooks">钩子</a>》。
</p>

<p>
关于早期初始化文件的更多信息，可参见《Emacs Lisp 参考手册》中的《<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Init-File.html#Init-File">初始化文件</a>》章节。
</p>
</div>
</div>
</div>
<div id="outline-container-Authentication" class="outline-3">
<h3 id="Authentication"><span class="section-number-3">51.5.</span> 保存持久化认证信息</h3>
<div class="outline-text-3" id="text-Authentication">
<p>
部分需要连接外部服务的 Emacs 包会要求身份认证（参见 “<a href="#Passwords">输入密码</a>”），例如《Gnus 手册》中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/gnus/index.html#Top">Gnus</a>、《Tramp 手册》中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/tramp/index.html#Top">Tramp</a> 等。为避免反复输入相同的用户名和密码，Emacs 提供了 <code>auth-source</code> 库，用于持久化保存这类认证信息。
</p>

<p>
默认情况下，认证信息会从以下文件中读取： <code>~/.authinfo</code> 、 <code>~/.authinfo.gpg</code> 或 <code>~/.netrc</code> 。这些文件的语法与 <code>ftp</code> 等工具使用的 netrc 文件类似，格式如下：
</p>


<p>
machine <i>mymachine</i> login <i>myloginname</i> password <i>mypassword</i> port <i>myport</i>
</p>


<p>
同样， <code>auth-source</code> 库支持多种存储后端，目前包括传统的 netrc 后端、JSON 文件、密钥服务 API（Secret Service API），以及类 UNIX 系统的标准密码管理器 pass。
</p>

<p>
所有这些存储方式都可以通过用户选项 <code>auth-sources</code> 进行自定义，详见 <a href="https://www.gnu.org/software/emacs/manual/html_node/auth/Help-for-users.html#Help-for-users">Emacs auth-source</a> 相关文档。
</p>

<p>
当交互式输入的密码在已配置的后端中不存在时，部分后端会提供 <b>持久化保存密码</b> 的功能。你可以通过自定义用户选项 <code>auth-source-save-behavior</code> 来修改这一行为。
</p>
</div>
</div>
</section>
<section id="outline-container-Quitting" class="outline-2">
<h2 id="Quitting"><span class="section-number-2">52.</span> 退出与中止</h2>
<div class="outline-text-2" id="text-Quitting">
<dl class="org-dl">
<dt><code>C-g</code></dt><dd></dd>

<dt><code>C-Break</code> （仅 MS‑DOS）</dt><dd>退出：取消正在运行或尚未输入完成的命令。</dd>
<dt><code>C-]</code></dt><dd>退出最内层的递归编辑层级，并取消调用该层级的命令 (<code>abort-recursive-edit</code>)。</dd>
<dt><code>ESC ESC ESC</code></dt><dd>根据场景执行退出或中止操作 (<code>keyboard-escape-quit</code>)。</dd>
<dt><code>M-x top-level</code></dt><dd>中止当前所有正在执行的递归编辑层级。</dd>
<dt><code>C-/</code></dt><dd></dd>

<dt><code>C-x u</code></dt><dd></dd>

<dt><code>C-_</code></dt><dd>取消之前对缓冲区内容所做的修改 (<code>undo</code>)。</dd>
</dl>

<p>
在命令执行完毕前取消命令有两种方式：使用 <code>C-g</code> 退出，以及使用 <code>C-]</code> 或 <code>M-x top-level</code> 中止。退出用于取消尚未输入完成或正在运行的命令。中止用于退出递归编辑层级，并取消调用该递归编辑的命令（见 “<a href="#Recursive-Edit">递归编辑层级</a>”）。
</p>

<p>
使用 <code>C-g</code> 退出可以取消你不想要的半输入命令或数字参数。此外，若命令正在运行， <code>C-g</code> 可以相对安全地停止该命令。例如，如果你中止一个耗时较长的删除命令，你的文本要么仍 <i>全部</i> 保留在缓冲区，要么 <i>全部</i> 保存在删除环中，或两者都有。如果区域处于激活状态， <code>C-g</code> 会取消标记激活，除非 “临时标记模式” 已关闭（见 “<a href="#Disabled-Transient-Mark">禁用临时标记模式</a>”）。如果你正在进行增量搜索， <code>C-g</code> 的行为会比较特殊；有时需要连续按两次 <code>C-g</code> 才能退出搜索。详见 “<a href="#Incremental-Search">增量搜索</a>”。
</p>

<p>
如果在小缓冲区中输入 <code>C-g</code> ，会退出打开该小缓冲区的命令并关闭它。如果该小缓冲区不是最近打开的（当 <code>minibuffer-follows-selected-frame</code> 为 <code>nil</code> 时可能出现，见 “<a href="#Basic-Minibuffer">使用小缓冲区</a>”）， <code>C-g</code> 在确认后会一并关闭更近打开的小缓冲区并退出相关命令。
</p>

<p>
在 MS‑DOS 上， <code>C-Break</code> 与 <code>C-g</code> 一样作为退出键使用。原因是在 MS‑DOS 中，命令运行时无法在与用户交互的间隙识别 <code>C-g</code> ，而 <code>C-Break</code> 则可以随时被识别。详见 “<a href="#MS_002dDOS-Keyboard">MS‑DOS 键盘使用</a>”。
</p>

<p>
<code>C-g</code> 的工作原理是在按下时立即将变量 <code>quit-flag</code> 设为 <code>t</code> ；Emacs Lisp 会频繁检查该变量，若非 nil 则退出。只有当 Emacs 正等待输入时， <code>C-g</code> 才会作为命令实际执行，此时运行的是 <code>keyboard-quit</code> 。
</p>

<p>
在文本终端下，如果在第一个 <code>C-g</code> 被识别之前再次按下 <code>C-g</code> ，会激活紧急退出功能并返回 shell。详见 “<a href="#Emergency-Escape">紧急退出</a>”。
</p>

<p>
有些情况下你无法退出。当 Emacs 正在等待操作系统完成某项操作时，除非 Emacs 为特定系统调用做了专门处理，否则无法退出。我们已经为用户通常希望退出的系统调用做了处理，但你仍可能遇到未处理的情况。一种非常常见的情况是：通过 NFS 等待文件输入或输出时，Emacs 本身支持退出，但很多 NFS 实现不允许用户程序在服务器挂起时停止等待。
</p>

<p>
使用 <code>C-]</code> (<code>abort-recursive-edit</code>) 中止用于退出递归编辑层级并取消调用它的命令。 <code>C-g</code> 无法做到这一点，因为它的作用是取消递归编辑内部尚未输入完成的命令。两种操作都很有用。例如，如果你在递归编辑中输入了 <code>C-u 8</code> 作为数字参数，可以用 <code>C-g</code> 取消该参数并继续留在递归编辑中。
</p>

<p>
<code>ESC ESC ESC</code> (<code>keyboard-escape-quit</code>) 序列既可退出也可中止。（我们这样定义是因为在很多 PC 程序中 <code>ESC</code> 表示 “退出”。）它可以像 <code>C-g</code> 一样取消前缀参数、清除选中区域、退出查询替换；也可以像 <code>C-]</code> 一样退出小缓冲区或递归编辑；还可以像 <code>C-x 1</code> 一样取消分屏，只保留一个窗口。但它不能停止正在运行的命令，因为它作为普通命令执行，只有等 Emacs 准备好接收下一条命令时才会生效。
</p>

<p>
<code>M-x top-level</code> 命令等价于连续多次按下 <code>C-]</code> ，一次性退出所有递归编辑层级；如果小缓冲区处于激活状态，也会退出。 <code>C-]</code> 一次只退出一层，而 <code>top-level</code> 一次性全部退出。与 <code>C-g</code> 不同， <code>C-]</code> 和 <code>top-level</code> 都和其他普通命令一样，只在 Emacs 准备接收命令时生效。 <code>C-]</code> 是一个普通按键，其功能仅来自按键映射中的绑定。详见 “<a href="#Recursive-Edit">递归编辑层级</a>”。
</p>

<p>
严格来说， <code>C-/</code> (<code>undo</code>) 并不是取消正在执行的命令，而是可以理解为 “取消已经执行完的命令”。关于撤销功能的更多信息，见 “<a href="#Undo">撤销</a>”。
</p>
</div>
</section>
<section id="outline-container-Lossage" class="outline-2">
<h2 id="Lossage"><span class="section-number-2">53.</span> 处理 Emacs 故障</h2>
<div class="outline-text-2" id="text-Lossage">
<p>
本节介绍如何识别并处理 Emacs 未按预期运行的情况，例如 keyboard code mixups(键盘编码错乱)、garbled displays(显示乱码)、running out of memory(内存不足)、crashes and hang(崩溃与卡死)等。
</p>

<p>
如果你认为自己发现了 Emacs 中的错误，请参阅<a href="#Bugs">报告错误</a>。
</p>

<ul class="org-ul">
<li><a href="#Stuck-Recursive">递归编辑层级</a></li>
<li><a href="#Screen-Garbled">屏幕乱码</a></li>
<li><a href="#Text-Garbled">文本乱码</a></li>
<li><a href="#Memory-Full">内存不足</a></li>
<li><a href="#Crashing">Emacs 崩溃时</a></li>
<li><a href="#After-a-Crash">崩溃后的恢复</a></li>
<li><a href="#Emergency-Escape">紧急退出</a></li>
<li><a href="#DEL-Does-Not-Delete">当 <code>DEL</code> 键无法删除时</a></li>
</ul>
</div>
<div id="outline-container-Stuck-Recursive" class="outline-3">
<h3 id="Stuck-Recursive"><span class="section-number-3">53.1.</span> 递归编辑层级</h3>
<div class="outline-text-3" id="text-Stuck-Recursive">
<p>
<b>Recursive editing levels 递归编辑层级</b> 是 Emacs 中重要且实用的功能，但如果你不了解它，可能会误以为是程序出错。
</p>

<p>
如果模式行里显示主模式和次模式名称的括号外出现了方括号 '<code>[…]</code>' ，说明你进入了 <b>递归编辑层级</b> 。如果你并非有意进入，或者不明白这是什么意思，直接退出该层级即可。退出方法：输入 <code>M-x top-level</code> 。详见 “<a href="#Recursive-Edit">递归编辑层级</a>”。
</p>
</div>
</div>
<div id="outline-container-Screen-Garbled" class="outline-3">
<h3 id="Screen-Garbled"><span class="section-number-3">53.2.</span> 屏幕乱码</h3>
<div class="outline-text-3" id="text-Screen-Garbled">
<p>
如果文本终端上的文字显示异常，首先要检查缓冲区里的内容是否真的出错。按下 <code>C-l</code> (<code>recenter-top-bottom</code>) 重新刷新整个屏幕。如果刷新后显示正常，说明问题仅出在上一次的屏幕更新过程中。（否则，请参阅下一节。）
</p>

<p>
显示刷新问题通常是因为你所用终端的 terminfo 配置不正确。Emacs 发行包中的 <code>etc/TERMS</code> 文件提供了这类已知问题的修复方案。 <code>INSTALL</code> 文件里也有专门章节给出这类问题的通用解决建议。
如果你确认使用的是正确的 terminfo 配置，那么问题可能出在 terminfo 条目本身存在错误，或是 Emacs 中存在针对某些终端类型的 bug。
</p>
</div>
</div>
<div id="outline-container-Text-Garbled" class="outline-3">
<h3 id="Text-Garbled"><span class="section-number-3">53.3.</span> 文本乱码</h3>
<div class="outline-text-3" id="text-Text-Garbled">
<p>
如果按 <code>C-l</code> 刷新后文本依然异常，先按 <code>C-h l</code> (<code>view-lossage</code>) 查看你刚才输入了哪些命令，导致了当前结果。然后逐步使用 <code>C-x u</code> (<code>undo</code>) 回退操作，直到恢复到你认为正确的状态。
</p>

<p>
如果缓冲区开头或结尾有一大段文本看似丢失，检查模式行中是否出现 'Narrow' 字样。如果出现，说明你看不见的文本很可能仍然存在，只是暂时被限制显示。输入 <code>C-x n w</code> (<code>widen</code>) 即可重新显示全部内容。见  <a href="#Narrowing">窄化显示</a>
</p>
</div>
</div>
<div id="outline-container-Memory-Full" class="outline-3">
<h3 id="Memory-Full"><span class="section-number-3">53.4.</span> 内存不足</h3>
<div class="outline-text-3" id="text-Memory-Full">
<p>
如果你收到错误提示 “Virtual memory exceeded”（超出虚拟内存），请使用 <code>C-x s</code> (<code>save-some-buffers</code>) 保存已修改的缓冲区。这种保存方式对额外内存的需求最小。Emacs 会保留一部分 <b>备用内存</b> ，在出现该错误时启用；这部分内存通常足以让 <code>C-x s</code> 完成保存工作。当备用内存耗尽时，模式行开头会显示 '!MEM FULL!' ，表示已无备用内存。
</p>

<p>
保存好修改的缓冲区后，你可以退出当前 Emacs 会话并重新启动，或者使用 <code>M-x kill-some-buffers</code> 在当前 Emacs 进程中释放空间。如果释放的空间足够，Emacs 会重新补充内存储备，模式行上的 '!MEM FULL!' 也会消失，这意味着你可以安全地继续在同一个 Emacs 会话中编辑。
</p>

<p>
<b>内存不足</b> 时，不要使用 <code>M-x buffer-menu</code> 来保存或关闭缓冲区，因为缓冲区菜单本身需要相当多的内存，而备用内存可能不足以支撑它运行。
</p>

<p>
在 GNU/Linux 系统中，Emacs 通常不会收到内存不足的通知；相反，当内存耗尽时，操作系统可能会直接杀死 Emacs 进程。这个机制被称为 <b>out-of-memory killer内存溢出杀手</b> （OOM killer）。在这种机制下，Emacs 无法及时感知内存不足，也就无法像上面描述的那样让你保存缓冲区。
</p>

<p>
不过，你可以关闭操作系统的这一行为，让 Emacs 在被杀死之前有机会以更合理的方式处理内存不足问题。方法如下：使用 root 权限编辑文件 <code>/etc/sysctl.conf</code> ，加入以下两行，然后在 shell 中执行 <code>sysctl -p</code> ：
</p>

<div class="org-src-container">
<pre class="src src-shell">vm.overcommit_memory=2
vm.overcommit_ratio=0
</pre>
</div>

<p>
请注意：以上设置会影响系统上的 <b>所有进程</b> ，并会改变系统在内存压力下的整体行为，而不仅仅是 Emacs 进程。
</p>
</div>
</div>
<div id="outline-container-Crashing" class="outline-3">
<h3 id="Crashing"><span class="section-number-3">53.5.</span> Emacs 崩溃时</h3>
<div class="outline-text-3" id="text-Crashing">
<p>
Emacs 本不应崩溃，但如果真的发生，它会在退出前生成一份崩溃报告。崩溃报告会输出到标准错误流。如果 Emacs 是在 GNU 或类 Unix 系统的图形桌面环境下启动的，标准错误流通常会被重定向到如 <code>~/.xsession-errors</code> 之类的文件，你可以在那里查找崩溃报告。在 MS-Windows 上，崩溃报告除了输出到标准错误流外，还会写入 Emacs 进程当前目录下名为 <code>emacs_backtrace.txt</code> 的文件。
</p>

<p>
崩溃报告的格式取决于平台。在某些平台（例如使用 GNU C 库的系统）上，崩溃报告包含一份 <b>回溯信息</b> （backtrace），描述崩溃前的程序执行状态，可用于协助调试崩溃原因。下面是 GNU 系统上的一个示例：
</p>

<div class="org-src-container">
<pre class="src src-shell">Fatal error 11: Segmentation fault
Backtrace:
emacs[0x5094e4]
emacs[0x4ed3e6]
emacs[0x4ed504]
/lib64/libpthread.so.0[0x375220efe0]
<span style="color: #0000ff;">/lib64/libpthread.so.0</span>(<span style="color: #483d8b;">read</span>+0xe)[0x375220e08e]
emacs[0x509af6]
emacs[0x5acc26]
&#8230;
</pre>
</div>

<p>
数字 '11' 是与崩溃对应的系统信号编号，本例中为段错误。十六进制数字是程序地址，可以通过调试工具与源代码行关联起来。例如，GDB 命令 '<code>list *0x509af6</code>' 可以显示与 '<code>emacs[0x509af6]</code>' 对应的源代码行。如果你的系统装有 <code>addr2line</code> 工具，可以使用下面的 shell 命令输出带源代码行号的回溯信息：
</p>

<div class="org-src-container">
<pre class="src src-shell">sed -n <span style="color: #8b2252;">'s/.*\[\(.*\)]$/\1/p'</span> backtrace |
  addr2line -C -f -i -p -e bindir/emacs-binary
</pre>
</div>

<p>
在 MS-Windows 上，回溯信息的格式略有不同，例如：
</p>

<div class="org-src-container">
<pre class="src src-shell">Backtrace:
00007ff61166a12e
00007ff611538be1
00007ff611559601
00007ff6116ce84a
00007ff9b7977ff0
&#8230;
</pre>
</div>

<p>
因此不需要通过 sed 过滤，直接使用以下命令即可显示源代码行号：
</p>

<div class="org-src-container">
<pre class="src src-shell">addr2line -C -f -i -p -e bindir/emacs-binary &lt; backtrace
</pre>
</div>

<p>
这里的 <i>backtrace</i> 是存放回溯信息的文本文件名（在 MS-Windows 上即为 Emacs 启动目录下的 <code>emacs_backtrace.txt</code> ）， <i>bindir</i> 是 Emacs 可执行文件所在目录， <i>emacs-binary</i> 是 Emacs 可执行文件名：在 GNU 和类 Unix 系统上通常是 <code>emacs</code> ，在 MS-Windows 和 MS-DOS 上是 <code>emacs.exe</code> 。如果你的 <code>addr2line</code> 版本较旧不支持 <code>-p</code> 选项，去掉该参数即可。
</p>

<p>
在支持核心转储文件的系统上，Emacs 还可以在崩溃时可选地生成 <b>核心转储</b> （core dump）。核心转储是一个包含崩溃前程序完整运行状态的大容量文件，通常通过载入调试器（如 GDB）进行分析。在很多平台上，核心转储默认是关闭的，你必须显式启用，例如在 shell 中执行： <code>ulimit -c unlimited</code> （可以把这条命令加到 shell 启动脚本里。）
</p>
</div>
</div>
<div id="outline-container-After-a-Crash" class="outline-3">
<h3 id="After-a-Crash"><span class="section-number-3">53.6.</span> 崩溃后的恢复</h3>
<div class="outline-text-3" id="text-After-a-Crash">
<p>
如果 Emacs 或计算机崩溃，你可以通过 <b>自动保存文件</b> 恢复崩溃时正在编辑的文件。方法是：重新启动 Emacs，执行命令： <code>M-x recover-session</code>
</p>

<p>
该命令会先打开一个缓冲区，列出所有中断的会话文件及对应日期。你需要选择要恢复的会话（通常是最近一次），将光标移到该项，然后按 <code>C-c C-c</code> 。
</p>

<p>
之后， <code>recover-session</code> 会逐一处理该会话中你正在编辑的文件，询问是否恢复。若输入 <code>y</code> ，它会显示文件与自动保存文件的时间，并再次确认是否恢复。第二次必须确认 <code>yes</code> ，Emacs 才会从自动保存文件中恢复文本。
</p>

<p>
恢复完成后，你选择恢复的文件会出现在 Emacs 缓冲区中， <b>必须手动保存</b> ，才能真正更新磁盘上的文件。
</p>

<p>
作为最后手段：如果你有未关联到任何文件的缓冲区内容，或自动保存记录的内容不够新，你可以借助 GDB 调试器与脚本 <code>etc/emacs-buffer.gdb</code> ，从核心转储文件（core dump） 中提取内容 —— 前提是已保存核心转储，且 Emacs 可执行文件未去除调试符号。
</p>

<p>
获取核心转储后，立即将其重命名（如 <code>core.emacs</code> ），避免下次崩溃覆盖它。
</p>

<p>
使用该脚本的方法：用 GDB 加载 Emacs 程序与核心转储，例如： '<code>gdb /usr/bin/emacs core.emacs</code>' 。在 GDB 提示符下加载恢复脚本： '<code>source /usr/src/emacs/etc/emacs-buffer.gdb</code>' 。然后输入命令： <code>ybuffer-list</code> ：查看可恢复的缓冲区列表及编号。 <code>ysave-buffer</code> ：保存指定编号的缓冲区到文件。建议使用 <b>不存在的文件名</b> 保存；若文件已存在，脚本不会备份旧内容。
</p>
</div>
</div>
<div id="outline-container-Emergency-Escape" class="outline-3">
<h3 id="Emergency-Escape"><span class="section-number-3">53.7.</span> 紧急退出</h3>
<div class="outline-text-3" id="text-Emergency-Escape">
<p>
在文本终端下，如果你在 Emacs 还没来得及响应第一个 <code>C-g</code> 时就按下第二个 <code>C-g</code> ， <b>emergency escape紧急退出</b> 功能会立刻挂起 Emacs。这样无论 Emacs 卡死得多严重，你都能退出 GNU Emacs。正常情况下，Emacs 会极快地响应第一个 <code>C-g</code> ，第二个 <code>C-g</code> 不会触发紧急退出。但如果某些问题导致 Emacs 无法正常处理第一个 <code>C-g</code> ，第二个就能让你回到 shell。
</p>

<p>
当你从紧急退出造成的挂起中恢复 Emacs 时，它会提示已恢复，并在继续之前询问一两个问题：
</p>

<div class="org-src-container">
<pre class="src src-shell">Emacs is resuming after an emergency escape.
Auto-save? (y or n)
<span style="color: #0000ff;">Abort</span> (and dump core)? (y or n)
</pre>
</div>

<p>
每个问题用 <code>y</code> 或 <code>n</code> 加 <code>RET</code> 回车回答。
</p>
<ul class="org-ul">
<li>对 'Auto-save?' 回答 <code>y</code> ，会立即对所有开启了自动保存的已修改缓冲区执行自动保存；回答 <code>n</code> 则跳过。如果 Emacs 处于无法安全执行自动保存的状态，该问题会被省略。</li>
<li>对 'Abort (and dump core)?' 回答 <code>y</code> ，会让 Emacs 崩溃并生成核心转储文件。这是为了让高手能分析 Emacs 一开始无法退出的原因。生成核心转储后程序不会继续运行。</li>
</ul>

<p>
如果对这个问题回答 <code>n</code> ，Emacs 会继续执行。运气好的话，它最终会执行你之前请求的退出操作。如果不行，之后每一次连续按 <code>C-g</code> 都会再次触发紧急退出。
</p>

<p>
如果 Emacs 并没有真卡死，只是慢，你可能会不小心触发双击 <code>C-g</code> 。这时只需恢复运行并对两个问题都回答 <code>n</code> ，就能回到之前的状态，你之前请求的退出操作会慢慢执行。
</p>

<p>
<b>紧急退出仅在文本终端下有效</b> 。在图形界面下，你可以用鼠标关闭 Emacs 或切换到其他程序。
</p>

<p>
在 MS-DOS 系统中，需要连续按 <code>C-Break</code> （两次）才能触发紧急退出；但在某些情况下（如系统调用卡死、或 Emacs 在 C 代码的紧凑循环中卡住），该操作可能无效。
</p>
</div>
</div>
<div id="outline-container-DEL-Does-Not-Delete" class="outline-3">
<h3 id="DEL-Does-Not-Delete"><span class="section-number-3">53.8.</span> 当 <code>DEL</code> 键无法删除时</h3>
<div class="outline-text-3" id="text-DEL-Does-Not-Delete">
<p>
每个键盘都有一个大键，通常标为 <code>BACKSPACE</code> ，一般用来删除刚输入的最后一个字符。在 Emacs 中，这个键理应等价于 <code>DEL</code> 。
</p>

<p>
在图形界面下启动 Emacs 时，它会自动判断哪个键应该是 <code>DEL</code> 。在某些特殊情况下，Emacs 从系统获取到错误信息，导致 <code>BACKSPACE</code> <b>变成向前删除</b> ，而不是向后删除。
</p>

<p>
有些键盘还有 <code>Delete</code> 键，通常用于向前删除。如果这个键在 Emacs 里变成向后删除，也说明 Emacs 获取了错误信息 —— 只是方向相反。
</p>

<p>
在文本终端下，如果你发现按 <code>BACKSPACE</code> 会像 <code>C-h</code> 一样弹出帮助，而不是删除字符，说明该键实际发送的是 'BS' 字符。Emacs 本应把 'BS' 当作 <code>DEL</code> 处理，但没有生效。
</p>

<p>
所有这类情况，临时解决方法都一样：执行命令 <code>M-x normal-erase-is-backspace-mode</code> 。它会在 Emacs 处理 <code>DEL</code> 的两种模式之间切换。如果启动时模式不对，执行一次通常就能切到正确模式。在文本终端下，如果 <code>BS</code> 已经被当作 <code>DEL</code> 使用，你想查看帮助时请用 <code>F1</code> 代替 <code>C-h</code> ； <code>C-?</code> 通常也可以（如果它发送的是编码 <code>127</code> ）。
</p>

<p>
<b>要让所有 Emacs 会话都永久修复</b> ，把下面其中一行写到你的初始化文件里（见 <a href="#Init-File">Emacs 初始化文件</a>）。对于 <code>BACKSPACE</code> 向前删的情况，用这行让 <code>BACKSPACE</code> 等价于 <code>DEL</code> ：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(normal-erase-is-backspace-mode 0)
</pre>
</div>

<p>
对于另外两种问题，用这行：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(normal-erase-is-backspace-mode 1)
</pre>
</div>

<p>
另一种永久修复方法是自定义变量 <code>normal-erase-is-backspace</code> ：值为 <code>t</code> ： <code>BS</code> / <code>BACKSPACE</code> 作为 <code>DEL</code> ；值为 <code>nil</code> ：使用另一种模式。参见「<a href="#Easy-Customization">简易自定义界面</a>」。
</p>
</div>
</div>
</section>
<section id="outline-container-Bugs" class="outline-2">
<h2 id="Bugs"><span class="section-number-2">54.</span> 报告漏洞</h2>
<div class="outline-text-2" id="text-Bugs">
<p>
如果你认为在 Emacs 中发现了错误，请进行报告。我们无法保证一定会修复，也不一定会认同这是一个错误，但我们非常希望收到你的反馈。你希望新增的功能建议也同样适用本节内容。本章将帮助你判断是否真的发现了错误，并在确认后构建一份有效的错误报告。
</p>

<p>
当你发现可能是错误的问题时，通用流程如下：
</p>
<ul class="org-ul">
<li>先确认你发现的问题是否为已知问题，或是已经被报告 / 修复的错误。参见「<a href="#Known-Problems">查阅现有错误报告与已知问题</a>」，其中会说明如何查找已知问题和错误。</li>
<li>如果你不确定当前表现是否属于错误，参见「<a href="#Bug-Criteria">何时算作错误</a>」，其中说明了我们认定的 Emacs 明确错误类型。</li>
<li>当你确定发现了错误后，参见「<a href="#Understanding-Bug-Reporting">理解错误报告</a>」，它会帮助你以最高效的方式描述问题，让我们更容易复现与排查。</li>
<li>接下来，参见「<a href="#Checklist">错误报告清单</a>」，其中详细说明了如何提交错误报告以及需要包含哪些信息。简单来说，你可以通过 Emacs 命令 <code>report-emacs-bug</code> 以电子邮件方式提交错误报告，该命令会辅助你完成整个流程。提交错误报告会启动错误调查与修复流程，你会收到相关讨论邮件的副本，我们可能会请你提供更多信息、测试可能的修复方案等。</li>
<li>如果你认为发现了需要保密沟通的安全问题，请直接联系 GNU Emacs 维护者。联系方式可在 Emacs 发行版中的 <code>admin/MAINTAINERS</code> 文件中查看。</li>
<li>最后，如果你希望为 Emacs 提交具体修改（无论是修复错误、新增功能还是改进文档），详情请参见「<a href="#Sending-Patches">为 GNU Emacs 提交补丁</a>」。</li>

<li><a href="#Known-Problems">查看现有漏洞报告与已知问题</a></li>
<li><a href="#Bug-Criteria">漏洞的判定标准</a></li>
<li><a href="#Understanding-Bug-Reporting">理解漏洞报告</a></li>
<li><a href="#Checklist">漏洞报告检查清单</a></li>
<li><a href="#Sending-Patches">提交 GNU Emacs 补丁</a></li>
</ul>
</div>
<div id="outline-container-Known-Problems" class="outline-3">
<h3 id="Known-Problems"><span class="section-number-3">54.1.</span> 查看现有漏洞报告与已知问题</h3>
<div class="outline-text-3" id="text-Known-Problems">
<p>
在报告错误之前，请尽可能先检查该问题是否已被我们知晓。事实上，它可能已经在 Emacs 的后续发行版或开发版中被修复。下面是你可以查阅已知问题的主要渠道：
</p>

<ul class="org-ul">
<li><code>etc/PROBLEMS</code> 文件：按 <code>C-h C-p</code> 即可阅读。该文件列出了在编译、安装与运行 Emacs 时常见的典型问题，重点收录那些由其他软件导致、难以在 Emacs 内部直接修复的问题。其中通常会提供变通方案与解决建议。</li>
<li><p>
GNU 缺陷跟踪系统：地址为 <a href="https://debbugs.gnu.org">https://debbugs.gnu.org</a>。Emacs 相关的缺陷与问题都归类在 emacs 软件包下。该系统会记录每个缺陷的状态、初始报告、缺陷提交者与 Emacs 开发者后续的讨论和修复信息。你可以按标题、严重程度等条件搜索缺陷。如需更复杂的搜索条件，可使用 <a href="https://debbugs.gnu.org/cgi/search.cgi">https://debbugs.gnu.org/cgi/search.cgi</a>。
</p>

<p>
除了网页浏览，你也可以在 Emacs 内部使用 debbugs 包浏览缺陷（可通过包菜单安装，参见 Emacs Lisp 包）。该包提供命令： <code>M-x debbugs-gnu</code> ：列出缺陷、 <code>M-x debbugs-gnu-search</code> ：搜索特定缺陷、 <code>M-x debbugs-gnu-usertags</code> ：查看由 Emacs 维护者添加的用户标签。
</p></li>
<li><p>
‘bug-gnu-emacs’ 邮件列表（同时作为新闻组 gnu.emacs.bug）：存档地址为 <a href="https://lists.gnu.org/mailman/listinfo/bug-gnu-emacs">https://lists.gnu.org/mailman/listinfo/bug-gnu-emacs</a>。该列表是发送到缺陷跟踪系统的 Emacs 错误报告与后续消息的镜像，同时还包含 2008 年初缺陷跟踪系统启用之前的旧报告。
</p>

<p>
你可以订阅该列表。请注意，其用途是向 Emacs 维护者提供缺陷与功能需求信息，因此报告可能包含大量内容，围观者请勿对此抱怨。
</p></li>
<li>‘emacs-pretest-bug’ 邮件列表：该列表已不再使用，仅作历史参考。它曾用于接收 Emacs 开发版（未正式发布）的错误报告。2003 年至 2007 年中的存档可在 <a href="https://lists.gnu.org/r/emacs-pretest-bug/">https://lists.gnu.org/r/emacs-pretest-bug/</a> 查看。现在发送到该列表的邮件会自动转发到 ‘bug-gnu-emacs’。</li>
<li>‘emacs-devel’ 邮件列表：有时有人会在此报告错误，但这并非该列表的主要用途。提交错误报告最好还是发到专用的缺陷列表。你在报告错误前 <b>无需</b> 阅读此列表。</li>
</ul>
</div>
</div>
<div id="outline-container-Bug-Criteria" class="outline-3">
<h3 id="Bug-Criteria"><span class="section-number-3">54.2.</span> 漏洞的判定标准</h3>
<div class="outline-text-3" id="text-Bug-Criteria">
<p>
如果 Emacs 访问了非法内存地址（又称 “段错误”），或因程序内部问题导致系统错误退出（而非 “磁盘已满” 这类外部问题），那么这 <b>肯定是一个错误</b> 。
</p>

<p>
如果 Emacs 的显示内容与缓冲区实际内容不一致，这属于错误。但你应先确认是否是 <b>缓冲区缩窄</b> 等功能导致（参见<a href="#Narrowing">缩窄</a>），这类功能会隐藏缓冲区部分内容或改变显示方式。
</p>

<p>
某个命令执行时间过长、迟迟无法完成， <b>可能</b> 是错误，但你必须确认这确实是 Emacs 的问题。有些命令本身就需要较长时间。按下 <code>C-g</code> （MS‑DOS 下为 <code>C-Break</code> ），然后按 <code>C-h l</code> 查看 Emacs 接收到的输入是否符合你的意图；如果输入明显应该被快速处理，可提交错误报告。如果你不确定该命令是否本就耗时，可查阅手册或寻求帮助确认。
</p>

<p>
如果你熟悉的某个命令，在其正常逻辑本应合理生效的场景下却抛出 Emacs 错误信息，这 <b>很可能是一个错误</b> 。
</p>

<p>
如果一个命令执行了错误的操作，这是错误。但请务必先确认它 <b>本应</b> 做什么。如果你不熟悉该命令，它可能实际上运行正常。如有疑问，查阅该命令的文档（参见 “<a href="#Name-Help">按命令或变量名查看帮助</a>”）。
</p>

<p>
一个命令的设计逻辑，可能并非编辑操作的最优方案。这是一类很重要的问题，但也属于 <b>主观判断</b> 。而且，很可能因为你不了解某些现有功能而得出这种结论。建议你在通过常规方式查阅文档、确信已理解其用法、并确定你想要的功能确实不存在之后，再对此类问题提出反馈。也可以咨询其他 Emacs 用户。如果仔细阅读手册后仍不理解命令的用途，可检查索引和术语表中是否有不明确的术语。
</p>

<p>
如果重新认真阅读手册后，你仍然不理解命令应该如何使用，这说明 <b>手册本身存在错误</b> ，你应当报告。手册的作用就是让非 Emacs 专家（包括你）清晰理解所有内容。报告文档错误与报告程序错误同等重要。
</p>

<p>
如果函数或变量的内置文档与手册内容不一致，则其中必有一个错误，这属于 bug。
</p>

<p>
对于 <b>非 Emacs 自带</b> 的扩展包问题，最好先向该包的开发者报告。
</p>
</div>
</div>
<div id="outline-container-Understanding-Bug-Reporting" class="outline-3">
<h3 id="Understanding-Bug-Reporting"><span class="section-number-3">54.3.</span> 理解漏洞报告</h3>
<div class="outline-text-3" id="text-Understanding-Bug-Reporting">
<p>
当你确定存在错误时，进行报告非常重要，并且要以有用的方式来报告。最有价值的内容是： <b>精确描述你输入的每一条命令</b> —— 从启动 Emacs 的 Shell 命令开始，直到问题出现为止，以及执行这些命令后产生的结果。
</p>

<p>
报告错误最重要的原则是：只 <b>陈述事实</b> 。假设和文字描述无法替代详细的原始数据。陈述事实本应很直接，但很多人却倾向于给出自己的推测，并用推测代替事实。如果这些解释是基于对 Emacs 实现方式的猜测，它们可能毫无用处；与此同时，因为缺少事实，我们将无法获得关于该错误的真实信息。如果你确实想调试问题，并报告并非猜测的可靠分析，这很有用 —— 但请 <b>同时附上原始事实</b> 。
</p>

<p>
举个例子：假设你输入 <code>C-x C-f /glorp/baz.ugh RET</code> 打开一个你知道体积很大的文件，而 Emacs 显示了「I feel pretty today」。错误报告需要包含 <b>全部这些信息</b> 。你不应该想当然地认为问题是由文件大小导致，并只说：“我打开了一个大文件，Emacs 显示了‘I feel pretty today’。” 这就是我们所说的 <b>“猜测式解释”</b> 。问题的根源可能只是文件名里有一个字母 ‘z’。如果是这样，我们收到你的报告后，会用某个没有字母 ‘z’ 的大文件去测试，结果无法复现问题。我们根本不可能猜到，应该去打开一个文件名里带 ‘z’ 的文件。
</p>

<p>
你甚至不应该用 “打开文件” 来代替 <code>C-x C-f</code> 。因为打开文件的方式不止一种，无法确定所有方式都能触发该问题。同样，与其说 “如果一行里有三个字符”，不如直接写 “输入 RET A B C RET C-p 之后”—— 也就是说， <b>请告诉我们你是如何输入文本的</b> ，即你那边能触发问题的具体操作。
</p>

<p>
如果可能，请尽量用 <code>emacs -Q</code> 启动 Emacs（这样 Emacs 会在无任何自定义配置的环境下启动；参见<a href="#Initial-Options">初始选项</a>），并重复触发错误的步骤，快速尝试复现问题。如果这样能复现错误，就可以排除你个人配置导致的问题，让错误更容易被复现。此时你的错误报告应首先说明：你是用 <code>emacs -Q</code> 启动的 Emacs，然后附上 <b>精确的复现步骤</b> 。如果可以，请提供复现错误所需文件的 <b>完整内容</b> 。
</p>

<p>
有些错误无法在 <code>emacs -Q</code> 下复现；有些则完全难以复现。这种情况下，你仍应报告你所掌握的信息 —— 但和之前一样，请 <b>只描述你第一次触发错误时的原始操作事实</b> 。
</p>

<p>
如果你有多个问题需要报告，请 <b>为每个问题单独提交一份错误报告</b> 。
</p>
</div>
</div>
<div id="outline-container-Checklist" class="outline-3">
<h3 id="Checklist"><span class="section-number-3">54.4.</span> 漏洞报告检查清单</h3>
<div class="outline-text-3" id="text-Checklist">
<p>
在报告错误之前，请先确认该问题是否已被他人报告（参见<a href="#Known-Problems">查阅现有错误报告与已知问题</a>）。
</p>

<p>
如果条件允许，可以尝试使用最新版 Emacs，查看问题是否已被修复。更好的做法是尝试最新的开发版。我们理解这对部分用户来说并不容易，因此 <b>并非必须</b> 在报告前做这一步。
</p>

<p>
编写 Emacs 错误报告的最佳方式是使用命令 <code>M-x report-emacs-bug</code> 。该命令会创建一个邮件缓冲区（参见<a href="#Sending-Mail">发送邮件</a>），并自动插入部分关键信息。但它无法提供所有必需内容，你仍需阅读并遵守下面的指南，在发送邮件前手动补充其他重要信息。你可能觉得 <code>M-x report-emacs-bug</code> 插入的某些信息无关紧要，但除非你非常确定，否则最好保留，由开发者自行判断是否有用。
</p>

<p>
写完报告后，按 <code>C-c C-c</code> 即可发送给 Emacs 维护者，邮件地址为 <a href="https://lists.gnu.org/mailman/listinfo/bug-gnu-emacs">bug-gnu-emacs</a>。如果你无法在 Emacs 内部发送邮件，可以将报告内容复制到你常用的邮件客户端（如果系统支持，可按 <code>C-c M-i</code> 让 Emacs 自动帮你复制），然后发送到该地址。你也可以直接写邮件到该地址，描述问题并包含下面提到的必要信息。
</p>

<p>
如果你想向 Emacs 提交代码（修复问题或实现新功能），最简单的方式是向 Emacs 问题跟踪器发送补丁。可使用命令 <code>M-x submit-emacs-patch</code> ，用法与报告错误类似；详见<a href="#Sending-Patches">为 GNU Emacs 提交补丁</a>。
</p>

<p>
无论哪种方式，你的报告都会发送到 ‘bug-gnu-emacs’ 邮件列表，并保存到 GNU 缺陷跟踪系统 <a href="https://debbugs.gnu.org">https://debbugs.gnu.org</a>。请提供有效的回复邮箱地址，以便我们需要向你询问更多信息。提交内容需要审核，因此你的报告可能会延迟一段时间才出现在跟踪系统中。
</p>

<p>
报告错误不需要了解 GNU 缺陷跟踪系统的工作方式，但如果你愿意，可以阅读其在线文档，了解可用的各类功能。
</p>

<p>
所有发送到 ‘bug-gnu-emacs’ 邮件列表的邮件都会同步到新闻组 ‘gnu.emacs.bug’，反之亦然。但我们 <b>不建议</b> 你通过新闻组发布错误报告（或回复）。这会让我们在需要补充信息时很难联系到你，并且与缺陷跟踪系统的集成效果不佳。
</p>

<p>
如果你的数据超过 500,000 字节，请不要直接放在错误报告里；可以说明可按需提供，或放到网上并给出地址。大型附件最好压缩后发送。
</p>

<p>
GNU 缺陷跟踪系统会为你的报告分配一个错误编号；后续讨论时请使用该编号，并把错误地址保留在收件人列表中，以便跟踪器记录讨论内容。错误地址格式类似 ‘nnnnn@debbugs.gnu.org’，其中 <i>nnnnn</i> 是错误编号。
</p>

<p>
为了让维护者能够排查错误，你的报告应包含以下所有内容：
</p>
<ul class="org-ul">
<li><p>
描述你观察到的、你认为不正确的行为。例如：“Emacs 进程收到致命信号”，或 “最终文本如下，我认为这是错误的”。
</p>

<p>
当然，如果错误是 Emacs 直接崩溃，那很明显。但如果是文本错误，维护者可能看不出问题所在。不要把这交给运气。
</p>

<p>
即使你遇到的问题是崩溃，也请 <b>明确说明</b> 。可能存在一些特殊情况，例如你的源码不同步，或遇到了系统 C 库的错误。（这种情况真实发生过！）你的版本会崩溃，我们这边可能不会。如果你明确说明会崩溃，那么当我们这里不崩溃时，就知道错误没有复现。如果你不说，我们就无法判断错误是否出现 —— 无法从观察中得出结论。
</p>

<p>
通常，对行为和复现步骤的描述需要包含以下一个或多个方面：
</p>
<ul class="org-ul">
<li>复现错误所需的任何文件的完整内容。如果你能给出不依赖任何文件就能复现问题的方法，也请提供。这会极大方便调试。如果确实需要文件，请确保我们能看到 <b>精确内容</b> 。例如，行尾是否有空格、缓冲区最后一行是否有换行符都可能有影响（理论上程序不应该关心最后一行是否结束，但错误往往不按理论来）。</li>

<li><p>
我们需要输入的精确命令以复现错误。如果可能，给出在使用 -Q 参数启动的 Emacs 下的完整复现步骤（参见<a href="#Initial-Options">初始选项</a>）。这会跳过你的个人配置。
</p>

<p>
精确记录 Emacs 输入的一种方法是使用操作记录文件（dribble file）。使用命令 <code>M-x open-dribble-file</code> 开始记录。之后 Emacs 会把你所有的输入复制到指定文件，直到 Emacs 进程退出。注意：敏感信息（如密码）可能会被记录在该文件中。
</p></li>

<li>如果错误是 Emacs 手册或 Emacs Lisp 参考手册与实际行为不符，或文字令人困惑，请复制你认为有问题的手册内容。如果章节不长，给出章节名即可。</li>

<li><p>
如果错误表现为 Emacs 错误信息， <b>精确抄写错误信息原文</b> ，以及显示 Lisp 程序如何触发该错误的 <b>调用栈（backtrace）</b> 非常重要。
</p>

<p>
为了准确获取错误信息，从 <code>*Messages*</code> 缓冲区复制到错误报告中。复制全部内容，不要只复制一部分。
</p></li>

<li>检查你加载到 Lisp 环境中的任何程序（包括初始化文件）是否设置了可能影响 Emacs 行为的变量。同时，查看在不加载配置文件的全新启动的 Emacs 中是否会出现问题（使用 <code>-Q</code> 参数启动以避免加载配置文件）。如果问题在纯净环境中不出现，你 <b>必须</b> 提供触发问题所需加载的 <b>所有程序的精确内容</b> 。</li>

<li>如果问题确实依赖于非 Emacs 标准的配置文件或其他 Lisp 程序，你应先向其维护者反馈，确认不是这些程序自身的错误。在他们确认是正确使用 Emacs 却出现问题后，再由他们报告错误。</li>

<li>如果你想提到 GNU Emacs 源码中的某处内容，请附上该行代码及前后几行上下文。不要只给行号。开发版源码的行号与你使用的版本并不一致。维护者需要额外工作量才能确定你指定行号的代码，而且无法保证准确。</li>

<li><p>
对于文本模式终端上可能出现的显示错误：终端类型（环境变量 <code>TERM</code> 的值），该终端在 <code>/etc/termcap</code> 中的完整 termcap 条目（该文件在不同机器上并不完全相同），Emacs 实际发送给终端的输出内容。
</p>

<p>
收集终端输出的方法是：启动 Emacs 后立即执行命令 M-x open-termscript，它会让你输入一个文件名，之后 Emacs 会把所有终端输出记录到该文件，直到进程退出。如果问题在 Emacs 启动时就出现，可以把下面的 Lisp 表达式加入你的 Emacs 初始化文件：
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(open-termscript <span style="color: #8b2252;">"~/termscript"</span>)
</pre>
</div>

<p>
这样在 Emacs 第一次显示屏幕时就会开始记录。
</p>

<p>
注意：如果没有对应类型的终端，修复依赖终端的错误通常非常困难，有时甚至无法修复。
</p></li>
</ul></li>

<li>Emacs 版本号。没有它，我们无法判断在当前版本中检查该错误是否有意义。 <code>M-x report-emacs-bug</code> 会自动包含该信息；如果你不使用该命令，可以用 <code>M-x emacs-version RET</code> 获取版本号。如果该命令无效，你使用的很可能不是 GNU Emacs，应去别处报告错误。</li>

<li>你使用的机器类型、操作系统名称与版本号（同样由 <code>M-x report-emacs-bug</code> 自动包含）。 <code>M-x emacs-version RET</code> 也会提供这些信息。从 <code>*Messages*</code> 缓冲区复制完整输出以保证准确，或使用 <code>C-u M-x emacs-version RET</code> 将版本信息直接插入当前缓冲区。</li>

<li>编译 Emacs 时传给 <code>configure</code> 命令的命令行参数（由 <code>M-x report-emacs-bug</code> 自动包含）。</li>

<li><p>
你对 Emacs 源码所做任何修改的完整列表。（除非错误在未修改的 Emacs 中也出现，否则我们可能没有时间排查。但如果你做了修改却不告知，只会误导我们。）
</p>

<p>
请 <b>精确描述</b> 这些修改。只用文字描述不够 —— 请提供统一上下文差异（unified context diff）。
</p>

<p>
添加自有文件或移植到其他机器也属于源码修改。
</p></li>

<li>与标准 GNU Emacs 安装流程不一致的任何细节。</li>

<li><p>
如果与非 ASCII 文本或国际化相关，需提供启动 Emacs 时生效的区域设置（locale）。 <code>M-x report-emacs-bug</code> 会自动包含；在 GNU/Linux、Unix 或 POSIX 风格 shell（如 Bash）下，也可以用以下命令查看：
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #483d8b;">echo</span> <span style="color: #a0522d;">LC_ALL</span>=$<span style="color: #a0522d;">LC_ALL</span> <span style="color: #a0522d;">LC_COLLATE</span>=$<span style="color: #a0522d;">LC_COLLATE</span> <span style="color: #a0522d;">LC_CTYPE</span>=$<span style="color: #a0522d;">LC_CTYPE</span> <span style="color: #8b2252;">\</span>
  <span style="color: #a0522d;">LC_MESSAGES</span>=$<span style="color: #a0522d;">LC_MESSAGES</span> <span style="color: #a0522d;">LC_TIME</span>=$<span style="color: #a0522d;">LC_TIME</span> <span style="color: #a0522d;">LANG</span>=$<span style="color: #a0522d;">LANG</span>
</pre>
</div>
<p>
也可以使用 locale 命令（如果系统有）查看区域设置。
</p></li>
</ul>

<p>
以下内容在错误报告中 <b>不是必需</b> 的：
</p>

<ul class="org-ul">
<li><p>
对错误 “外围情况” 的描述 —— 对可复现错误来说没有必要。
</p>

<p>
很多人遇到错误后会花大量时间研究修改输入文件的哪些内容会让错误消失或不影响。
</p>

<p>
这通常耗时且用处不大，因为我们排查错误的方式是在调试器中运行单个示例并打断点，而不是从一堆示例中纯推理。你可以节省时间，不必寻找更多示例，直接提交报告，回去继续编辑，然后发现下一个错误。
</p>

<p>
当然，如果你能找到更简单的复现示例来代替原始示例，会更方便。输出错误更容易观察，调试耗时更短等。
</p>

<p>
但简化并非必须；如果你做不到或没时间，直接用原始用例报告即可。
</p></li>

<li><p>
核心转储文件（core dump）。
</p>

<p>
调试 core dump 可能有用，但只能在你的机器上、用你的 Emacs 可执行文件进行。因此发送 core dump 给维护者没有用。 <b>绝对不要</b> 把 core 文件放在邮件报告里！这种超大邮件会带来极大麻烦。
</p></li>

<li><p>
Emacs 运行的系统调用跟踪日志。
</p>

<p>
系统调用跟踪只对少数特殊调试有用，大多数情况下信息量很少。但奇怪的是，很多人似乎认为报告崩溃就应该发系统调用跟踪。这可能是调试无源码或无调试符号程序时养成的习惯。
</p>

<p>
对大多数程序来说，调用栈（backtrace）远比系统调用跟踪有用得多。即使在 Emacs 中，简单的调用栈通常也更有用，当然你可以配合变量值和用 pr 打印的 Lisp 对象来补充完整信息。
</p></li>

<li><p>
错误的补丁。
</p>

<p>
一份高质量的错误修复补丁是很有用的。但不要以为只提供补丁就足够，从而省略错误报告所需的其他信息（例如测试用例）。我们可能会发现你补丁中存在的问题，并决定用其他方式修复，也可能完全无法理解你的补丁。如果我们不明白你想要修复的是什么错误，或者你的补丁为何能起到改进作用，我们就不能合入它。
</p></li>
</ul>
<p>
有关如何让我们更容易理解并合入你的补丁的指南，请参见<a href="#Sending-Patches">为 GNU Emacs 提交补丁</a>。
</p>

<ul class="org-ul">
<li><p>
对错误原因或依赖条件的猜测。
</p>

<p>
这类猜测通常是错的。即使是专家，不先用调试器确认事实也无法猜对。
</p></li>
</ul>

<p>
如果你愿意调试 Emacs 并提供更多错误信息，以下建议会很有用：
</p>

<ul class="org-ul">
<li><p>
如果错误表现为错误信息，尝试为错误提供 Lisp 调用栈。在错误发生前使用 <code>M-x toggle-debug-on-error</code> （即先执行该命令，再复现错误）。这会让错误触发 Lisp 调试器并显示调用栈。把调试器的调用栈内容复制到错误报告中。（在触发错误前加载相关 Lisp 的 <code>*.el</code> 源文件，调用栈会更详细，如果你知道如何查找和加载这些文件，可以这样做。）
</p>

<p>
调试错误建议使用 Edebug。详见 Emacs Lisp 参考手册中的 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Edebug.html#Edebug">Edebug</a> 章节。
</p>

<p>
只有在你知道如何复现错误时，才能使用调试器。如果无法复现，至少复制完整的错误信息。
</p></li>

<li><p>
如果 Emacs 似乎陷入无限循环或极长操作，在变量 <code>debug-on-quit</code> 不为 <code>nil</code> 时按 <code>C-g</code> ，会启动 Lisp 调试器并显示调用栈。该调用栈对调试此类长循环很有用，如果你能生成，请复制到报告中。
</p>

<p>
如果 Emacs 不响应 <code>C-g</code> （例如 <code>inhibit-quit</code> 被设置），可以从外部发送 <code>debug-on-event</code> 指定的信号（默认为 SIGUSR2）让其进入调试器。
</p></li>

<li><p>
来自 GDB 等 C 调试器的额外信息可能帮助他人在没有对应机器的情况下定位问题。如果你不会用 GDB，请阅读 GDB 手册 —— 篇幅不长，使用简单。你可以在与 Emacs 相同的站点找到 GDB 发行版及在线手册。在 GDB 中运行 Emacs，应切换到编译 Emacs 的 src 子目录，然后执行 <code>gdb ./emacs</code> 。保持当前目录为 src 很重要，这样 GDB 才会读取该目录下的 <code>.gdbinit</code> 文件。（你也可以在 GDB 内用 <code>source ./.gdbinit</code> 加载。）
</p>

<p>
但收集额外信息时要思考，这些信息是否能说明错误原因。
</p>

<p>
例如，很多人只发送 C 层调用栈，这本身用处不大。带参数的简单调用栈通常无法说明 GNU Emacs 内部发生了什么，因为调用栈中的大多数参数都是指向 Lisp 对象的指针。这些指针的数值没有任何意义，重要的是它们指向的对象内容（而大部分内容本身也是指针）。
</p>

<p>
为了提供有用信息，你需要 <b>以 Lisp 语法显示 Lisp 对象的值</b> 。对栈底部附近几个栈帧中的每个 Lisp 对象变量都这样做。查看源码以确定哪些变量是 Lisp 对象，因为调试器会把它们当作整数。
</p>

<p>
要以 Lisp 语法显示变量值，先打印其数值，然后使用 GDB 自定义命令 pr 以 Lisp 语法打印对象。（如果必须使用其他调试器，调用函数 debug_print 并将对象作为参数。）pr 命令由 <code>.gdbinit</code> 定义，且只在调试运行中的进程时有效（不适用于 core dump）。
</p>

<p>
为了让 Lisp 错误中断 Emacs 并返回 GDB，在 <code>Fsignal</code> 处设置断点。
</p>

<p>
要查看正在运行的 Lisp 函数调用栈，使用 GDB 命令 <code>xbacktrace</code> 。
</p>

<p>
文件 <code>.gdbinit</code> 还定义了其他几个用于查看 Lisp 对象类型和内容的命令，名称以 ‘x’ 开头。这些命令比 <code>pr</code> 层级更低、使用更不便，但在 <code>pr</code> 无法工作时（如调试 core dump 或 Emacs 收到致命信号时）仍可使用。
</p>

<p>
Emacs 发行版中的 <code>etc/DEBUG</code> 文件提供了更详细的调试建议与技巧。该文件还包含排查 Emacs 无响应问题的说明（很多人以为 Emacs “hung卡死”，但实际上可能只是进入了无限循环）。
</p>

<p>
可以使用变量 <code>data-directory</code> 中保存的路径，找到你 Emacs 安装中的 <code>etc/DEBUG</code> 文件。
</p></li>
</ul>
</div>
</div>
<div id="outline-container-Sending-Patches" class="outline-3">
<h3 id="Sending-Patches"><span class="section-number-3">54.5.</span> 提交 GNU Emacs 补丁</h3>
<div class="outline-text-3" id="text-Sending-Patches">
<p>
如果你愿意为 GNU Emacs 编写错误修复或功能改进，这将非常有帮助。在提交修改时，请遵守以下指南，以便维护者能够轻松处理。如果你不遵守这些指南，你的信息可能仍然有用，但处理起来会花费额外精力。维护 GNU Emacs 本身已是繁重工作，只有你尽力配合，我们才能及时处理所有贡献。
</p>

<p>
每份补丁在我们正式评估前，都必须包含以下几部分信息，具体说明如下：
</p>

<p>
准备好所有内容后，请使用命令 <code>M-x submit-emacs-patch</code> 发送补丁。该命令会提示你输入补丁的主题和补丁文件，然后创建并打开一个 Message 模式缓冲区，将补丁文件作为附件，并允许你补充更多说明以及下面要求的其他信息。完成后按 <code>C-c C-c</code> ，即可通过电子邮件将补丁发送给开发者。补丁会被提交到 GNU 缺陷跟踪系统 <a href="https://debbugs.gnu.org">https://debbugs.gnu.org</a>，系统会像处理错误报告一样为你的提交分配编号。开发者通常会进行回复，可能会向你询问更多细节或补充信息，因此请务必提供有效的回复邮箱地址。
</p>

<p>
以下是我们要求你在提交补丁时提供的内容：
</p>

<ul class="org-ul">
<li>说明你要修复的问题，或补丁带来的改进
<ul class="org-ul">
<li>如果是修复已有错误，最好在 ‘bug-gnu-emacs’ 邮件列表的相关讨论下回复，或在 GNU 缺陷跟踪系统的对应条目下回复，并解释你的修改为何能修复该错误。</li>
<li>如果是新增功能，请包含功能描述与你的实现说明。</li>
<li>如果是新发现的错误，请为你修复的问题提供一份完整的错误报告（参见「<a href="#Checklist">错误报告清单</a>」）。在合入修改前，我们需要确认其正确性。即使修改本身正确，如果没有办法复现它要修复的问题，我们也可能难以理解。</li>
</ul></li>

<li>在代码修改中加入恰当的注释，帮助日后阅读源码的人理解为什么需要这项修改。</li>

<li><p>
不要把不同目的的修改混在一起，请分开单独提交。
</p>

<p>
如果你出于两个不同原因做了两项修改，我们可能不会同时合入两者，可能只合入其中一个，或是在不同版本中分别合入。如果你把所有修改混在同一组差异文件里，我们就需要额外工作来拆分，判断哪些部分对应哪个目的。如果我们没有时间处理，可能会长期推迟合入你的补丁。
</p>

<p>
如果你每项修改完成后就立即提交，并附带独立说明，那么两项修改就不会纠缠在一起，我们也可以分别正常评估，无需额外拆分。
</p></li>

<li><p>
每项修改完成后请立即提交。有些人以为把大量修改积攒到一起提交是在帮我们，但如上所述，这其实是最糟糕的做法。
</p>

<p>
既然你应该分开提交每项修改，不妨完成后立刻发送。如果修改很重要，我们可以选择立即合入。
</p></li>

<li>补丁本身，可以通过以下方式生成：
<ul class="org-ul">
<li>如果你使用 Emacs 代码仓库，请先确保本地副本是最新的（例如用 <code>git pull</code> ）。你可以将修改提交到私有分支，然后用 <code>git format-patch master</code> 从主干版本生成补丁。（这是 <b>推荐方式</b> ，会让我们更方便地应用补丁。）你也可以不提交修改，直接使用下面介绍的 <code>git diff</code> 。</li>

<li><p>
使用 <code>diff -u</code> 生成差异文件。如果使用 GNU diff，对 C 代码生成差异时请用： <code>diff -u -F'^[_a-zA-Z0-9$]\+ *('</code> 。这会显示每处修改所在的函数名。
</p>

<p>
生成差异时，避免新旧版本混淆。请将旧版本作为 diff 的第一个参数，新版本作为第二个参数。并在文件名中明确区分哪个是旧版本，哪个是你修改后的新版本。
</p></li>
</ul></li>

<li><p>
为你的修改编写提交日志。这既能节省我们额外编写的工作量，也能帮助解释你的修改，方便我们理解。
</p>

<p>
提交日志的目的是说明修改的理由、代码如何解决对应问题，并让别人能清楚看到修改内容。因此你需要 <b>具体说明修改了哪些函数、为什么修改</b> 。关于我们对规范、清晰的提交日志的格式与要求，详见 Emacs 源码树中 <code>CONTRIBUTE</code> 文件的「Commit messages」部分。
</p>

<p>
你也可以参考近期提交的提交日志范例，了解需要包含哪些信息以及我们使用的风格。注意：与其他一些项目不同， <b>我们要求文档（即 Texinfo 文件）也必须提供提交日志</b> 。参见<a href="#Change-Log">变更日志</a>，亦可参阅网址：<a href="https://www.gnu.org/prep/standards/html_node/Change-Log-Concepts.html">https://www.gnu.org/prep/standards/html_node/Change-Log-Concepts.html</a>，以及《GNU 编码标准》中的<a href="https://www.gnu.org/prep/standards/html_node/Change-Log-Concepts.html#Change-Log-Concepts">变更日志</a>相关理念章节。
</p></li>

<li><p>
编写修复代码时，请记住：我们不能合入会破坏其他系统的修改。请考虑你的修改在其他类型系统上编译或运行时可能产生的影响。
</p>

<p>
有时人们提交的修复总体上可能是改进，但很难完全确定。合入这类修改成本很高，因为我们必须非常仔细地审查。当然，一份充分说明修改合理性的解释能帮助我们信服。
</p>

<p>
最安全的修改是只针对某台机器或某个系统使用的文件或代码片段。它们是安全的，因为不会在其他机器或系统上引入新错误。
</p>

<p>
请将补丁设计为 <b>明显安全可合入</b> 的形式，帮助我们分担工作量。
</p></li>
</ul>
</div>
</div>
</section>
<section id="outline-container-Contributing" class="outline-2">
<h2 id="Contributing"><span class="section-number-2">55.</span> 为 Emacs 开发做贡献</h2>
<div class="outline-text-2" id="text-Contributing">
<p>
Emacs 是一个协作型项目，我们鼓励所有人参与贡献。
</p>

<p>
你可以通过多种方式为 Emacs 贡献力量：
</p>
<ul class="org-ul">
<li>发现并报告错误；详见《<a href="#Bugs">报告错误</a>》。</li>
<li>在 Emacs 用户邮件列表 <a href="https://lists.gnu.org/mailman/listinfo/help-gnu-emacs">https://lists.gnu.org/mailman/listinfo/help-gnu-emacs</a> 解答问题。</li>
<li>编写文档，既可在 <a href="https://www.emacswiki.org/">Wiki</a> 上，也可在 Emacs 源码仓库中贡献（详见《<a href="#Sending-Patches">为 GNU Emacs 提交补丁</a>》）。</li>
<li>检查已有错误报告是否在新版 Emacs 中已修复：<a href="https://debbugs.gnu.org/cgi/pkgreport.cgi?which=pkg&amp;data=emacs">https://debbugs.gnu.org/cgi/pkgreport.cgi?which=pkg&amp;data=emacs</a>。</li>
<li>修复已有的错误报告。</li>
<li>实现 Emacs 发行版中 <code>etc/TODO</code> 文件里列出的功能，并提交补丁。</li>
<li>实现新功能，并提交补丁。</li>
<li>开发可与 Emacs 配合使用的扩展包，并自行发布或上传到 GNU ELPA（<a href="https://elpa.gnu.org/">https://elpa.gnu.org/</a>）。</li>
<li>将 Emacs 移植到新平台，不过如今这种情况已不常见。</li>
</ul>

<p>
如果你想参与改进 Emacs，请通过 <a href="https://lists.gnu.org/mailman/listinfo/emacs-devel">emacs-devel 邮件列表</a>联系维护者。你可以询问推荐的项目，也可以提出自己的想法。
</p>

<p>
如果你有功能需求或改进建议，最佳提交渠道是 <a href="https://lists.gnu.org/mailman/listinfo/bug-gnu-emacs">bug-gnu-emacs</a>。请尽可能清晰地说明你希望看到的改动，以及你认为它能如何改进 Emacs、为什么值得改进。
</p>

<p>
如果你已经写出了改进代码，请告知我们。如果你还未开始工作，建议在动手前先联系 <a href="https://lists.gnu.org/mailman/listinfo/emacs-devel">emacs-devel</a>；我们可以给出建议，让你的扩展能更好地融入 Emacs 整体。
</p>

<p>
实现功能时，请遵循 Emacs 编码规范；详见《<a href="#Coding-Standards">编码规范</a>》。此外，较大规模的贡献需要向 FSF 转让版权；详见《<a href="#Copyright-Assignment">版权转让</a>》。
</p>

<p>
Emacs 的开发版可以从源码仓库下载，那里有一群开发者在积极维护。访问详情请见 Emacs 项目页面：<a href="https://savannah.gnu.org/projects/emacs/">https://savannah.gnu.org/projects/emacs/</a>。
</p>

<p>
基于当前最新开发版编写补丁非常重要。如果你从旧版本开始修改，补丁可能会过时（导致维护者难以合入），或者 Emacs 本身的改动已让你的补丁不再必要。下载源码仓库后，请阅读 <code>INSTALL.REPO</code> 文件了解编译说明（它与普通版本的编译方式有一定区别）。
</p>

<p>
如果你希望做更全面的贡献，可以查看 Emacs 源码树中的 <code>CONTRIBUTE</code> 文件，了解如何成为一名 Emacs 开发者。该文件随每一个正式发布的 Emacs 源码压缩包一同分发，也可在 <a href="https://git.savannah.gnu.org/cgit/emacs.git/tree/CONTRIBUTE">Emacs 在线源码仓库</a>中找到。如果你按 <a href="https://savannah.gnu.org/projects/emacs/">https://savannah.gnu.org/projects/emacs/</a> 中的说明克隆了 Emacs 仓库，可在源码树顶层目录找到该文件。
</p>

<p>
如需查阅 Emacs 相关文档（以理解如何实现你想要的改动），可参考：
</p>
<ul class="org-ul">
<li>Emacs 手册：<a href="https://www.gnu.org/software/emacs/manual/emacs.html">https://www.gnu.org/software/emacs/manual/emacs.html</a></li>
<li>Emacs Lisp 参考手册：<a href="https://www.gnu.org/software/emacs/manual/elisp.html">https://www.gnu.org/software/emacs/manual/elisp.html</a></li>
<li><a href="https://www.gnu.org/software/emacs">https://www.gnu.org/software/emacs</a></li>
<li><a href="https://www.emacswiki.org/">https://www.emacswiki.org/</a></li>
<li><a href="#Coding-Standards">编码标准</a></li>
<li><a href="#Copyright-Assignment">版权转让</a></li>
</ul>
</div>
<div id="outline-container-Coding-Standards" class="outline-3">
<h3 id="Coding-Standards"><span class="section-number-3">55.1.</span> 编码标准</h3>
<div class="outline-text-3" id="text-Coding-Standards">
<p>
贡献的代码应遵循 GNU 编码规范。该手册可在网上查阅，地址为：<a href="https://www.gnu.org/prep/standards/">https://www.gnu.org/prep/standards/</a>。你的系统中也可能在 Info 文档里提供了本地版本，详见《<a href="https://www.gnu.org/prep/standards/html_node/index.html#Top">GNU 编码规范</a>》。
</p>

<p>
若代码未遵循该规范，我们需要安排人员对其进行修正后，方可纳入使用。
</p>

<p>
Emacs 另有额外的样式与编码约定，具体包括：
</p>
<ul class="org-ul">
<li>《Emacs Lisp 参考手册》中 “技巧与约定” 附录，地址为：<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Tips.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Tips.html</a>。</li>
<li>拟纳入 Emacs 的 Lisp 代码，应避免使用 <code>advice-add</code> 或 <code>with-eval-after-load</code> 函数。</li>
<li>移除所有源码文件和文本文件中的尾随空白字符。</li>
<li>在 Lisp 代码中，使用 <code>?\s</code> 表示空格字符，而非直接使用 <code>?</code> 。</li>
</ul>
</div>
</div>
<div id="outline-container-Copyright-Assignment" class="outline-3">
<h3 id="Copyright-Assignment"><span class="section-number-3">55.2.</span> 版权转让</h3>
<div class="outline-text-3" id="text-Copyright-Assignment">
<p>
FSF（自由软件基金会）是 GNU Emacs 的版权持有者。FSF 是一家非营利组织，其全球使命是推动计算机用户自由，维护所有自由软件用户的权利。通用信息详见其官网：<a href="https://www.fsf.org/">https://www.fsf.org/</a>。
</p>

<p>
一般而言，对于对 GNU Emacs 及 GNU ELPA 中托管的软件包做出的 <b>非 trivial（非微小）贡献</b> ，我们要求将版权转让给 FSF。相关背景原因见：<a href="https://www.gnu.org/licenses/why-assign.html">https://www.gnu.org/licenses/why-assign.html</a>。
</p>

<p>
版权转让流程十分简便，许多国家的居民可以 <b>全程在线完成</b> 。如需开始办理，请按照 Emacs 发行包中 <code>etc/copyright-assign.txt</code> 文件里的说明操作。你可以通过 <a href="mailto:emacs-devel@gnu.org">emacs-devel@gnu.org</a> 邮件列表咨询任何相关问题（我们会为你解答或指引至能解答的人员）。
</p>

<p>
（请注意：在 emacs-devel 列表中讨论 “为何部分 GNU 项目要求版权转让” 属于偏离主题，相关讨论请前往 gnu-misc-discuss 列表。）
</p>

<p>
<b>版权声明</b> 也是一种可选方式，但我们更倾向于版权转让。注意：版权声明与版权转让一样，需要你向 FSF 提交签署后的文件，仅声明 “此作品已进入公有领域” 是不够的。此外，版权声明 <b>不能适用于后续作品</b> ，每次提交新内容都需要重新办理。
</p>

<p>
我们接受 <b>小幅改动</b> （大致为少于 15 行代码）无需版权转让。该限制为 <b>累计上限</b> （例如：3 个独立的 5 行补丁合计也会达到上限）。
</p>
</div>
</div>
</section>
<section id="outline-container-Service" class="outline-2">
<h2 id="Service"><span class="section-number-2">56.</span> 如何获取 GNU Emacs 相关帮助</h2>
<div class="outline-text-2" id="text-Service">
<p>
如果你需要关于安装、使用或修改 GNU Emacs 的帮助，有两种途径可以获取：
</p>
<ul class="org-ul">
<li>发送邮件至 <a href="https://lists.gnu.org/mailman/listinfo/help-gnu-emacs">help-gnu-emacs 邮件列表</a>，或在新闻组 <code>gnu.emacs.help</code> 发布求助信息。（该邮件列表与新闻组是互通的，使用其中任意一个均可。）</li>
<li>在<a href="https://www.fsf.org/resources/service/">服务目录</a>中查找可提供有偿帮助的人员。</li>
</ul>
</div>
</section>
<section id="outline-container-Copying" class="outline-2">
<h2 id="Copying">附录 A GNU 通用公共许可证</h2>
<div class="outline-text-2" id="text-Copying">
<p>
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Copying.html">GNU GENERAL PUBLIC LICENSE</a>
</p>
</div>
</section>
<section id="outline-container-GNU-Free-Documentation-License" class="outline-2">
<h2 id="GNU-Free-Documentation-License">附录 B GNU 自由文档许可证</h2>
<div class="outline-text-2" id="text-GNU-Free-Documentation-License">
<p>
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/GNU-Free-Documentation-License.html">GNU Free Documentation License</a>
</p>
</div>
</section>
<section id="outline-container-Emacs-Invocation" class="outline-2">
<h2 id="Emacs-Invocation">附录 C Emacs 启动命令行参数</h2>
<div class="outline-text-2" id="text-Emacs-Invocation">
<p>
Emacs 支持在启动时通过命令行参数执行各类操作。这些参数主要用于与其他编辑器兼容，以及完成复杂任务。 <b>日常编辑我们不建议使用它们</b> （如需从命令行访问已运行的 Emacs 进程，可参见《<a href="#Emacs-Server">将 Emacs 作为服务器使用</a>》）。
</p>

<p>
以 '<code>-</code>' 开头的参数是选项，'<code>+行号</code>' 也属于选项。所有其他参数用于指定要打开的文件。Emacs 启动时会打开这些文件，命令行中 <b>最后一个指定的文件</b> 成为当前缓冲区，其他文件也会在各自缓冲区中打开。与大多数程序一样，特殊参数 '<code>--</code>' 表示：后续所有参数均为文件名，而非选项，即使它们以 '<code>-</code>' 开头。
</p>

<p>
Emacs 命令选项可设置多项内容，例如 X 窗口的大小、位置、颜色等。部分选项用于高级场景，比如在批处理模式下对文件运行 Lisp 函数。本章各节将按用途分类介绍可用选项。
</p>

<p>
选项有两种写法：
</p>
<ul class="org-ul">
<li>短格式：以单个 ‘-’ 开头</li>
<li>长格式：以 ‘&#x2013;’ 开头</li>
</ul>

<p>
例如 ‘-d’ 是短格式，对应的长格式是 ‘&#x2013;display’。
</p>

<p>
以 ‘&#x2013;’ 开头的长格式更易记，但输入更长。不过你不必完整拼写，只要输入无歧义的缩写即可。当长格式需要参数时，选项名与参数之间可以用空格或等号分隔。例如 ‘&#x2013;display’ 可以写成： ‘&#x2013;display sugar-bombs:0.0’ 或 ‘&#x2013;display=sugar-bombs:0.0’
</p>

<p>
我们推荐使用等号，因为关系更清晰，下面表格中也统一使用等号。
</p>

<p>
大多数选项用于初始化 Emacs 或设置会话参数，称为初始选项。少数选项用于执行具体动作，如加载库、调用 Lisp 函数，称为动作选项。这些选项与文件名统称为动作参数。动作参数以字符串列表形式保存在变量 <code>command-line-args</code> 中。（实际上，Emacs 启动时 <code>command-line-args</code> 会包含所有命令行参数；初始化过程中，已处理的初始选项会从列表中移除，最终只保留动作参数。）
</p>

<ul class="org-ul">
<li><a href="#Action-Arguments">动作参数</a></li>
<li><a href="#Initial-Options">初始选项</a></li>
<li><a href="#Command-Example">命令参数示例</a></li>
<li><a href="#Environment">环境变量</a></li>
<li><a href="#Display-X">指定显示名称</a></li>
<li><a href="#Font-X">字体设置选项</a></li>
<li><a href="#Colors-X">窗口颜色选项</a></li>
<li><a href="#Window-Size-X">窗口大小与位置选项</a></li>
<li><a href="#Borders-X">内部与外部边框</a></li>
<li><a href="#Title-X">框架标题</a></li>
<li><a href="#Icons-X">图标</a></li>
<li><a href="#Misc-X">其他显示选项</a></li>
</ul>
</div>
<div id="outline-container-Action-Arguments" class="outline-3">
<h3 id="Action-Arguments">C.1 动作参数</h3>
<div class="outline-text-3" id="text-Action-Arguments">
</div>
</div>
<div id="outline-container-Initial-Options" class="outline-3">
<h3 id="Initial-Options">C.2 初始选项</h3>
<div class="outline-text-3" id="text-Initial-Options">
</div>
</div>
<div id="outline-container-Command-Example" class="outline-3">
<h3 id="Command-Example">C.3 命令参数示例</h3>
<div class="outline-text-3" id="text-Command-Example">
</div>
</div>
<div id="outline-container-Environment" class="outline-3">
<h3 id="Environment">C.4 环境变量</h3>
<div class="outline-text-3" id="text-Environment">
</div>
<div id="outline-container-General-Variables" class="outline-4">
<h4 id="General-Variables">C.4.1 通用变量</h4>
<div class="outline-text-4" id="text-General-Variables">
</div>
</div>
<div id="outline-container-Misc-Variables" class="outline-4">
<h4 id="Misc-Variables">C.4.2 杂项变量</h4>
<div class="outline-text-4" id="text-Misc-Variables">
</div>
</div>
<div id="outline-container-MS_002dWindows-Registry" class="outline-4">
<h4 id="MS_002dWindows-Registry">C.4.3 MS-Windows 系统注册表</h4>
<div class="outline-text-4" id="text-MS_002dWindows-Registry">
</div>
</div>
</div>
<div id="outline-container-Display-X" class="outline-3">
<h3 id="Display-X">C.5 指定显示名称</h3>
<div class="outline-text-3" id="text-Display-X">
</div>
</div>
<div id="outline-container-Font-X" class="outline-3">
<h3 id="Font-X">C.6 字体指定选项</h3>
<div class="outline-text-3" id="text-Font-X">
</div>
</div>
<div id="outline-container-Colors-X" class="outline-3">
<h3 id="Colors-X">C.7 窗口颜色选项</h3>
<div class="outline-text-3" id="text-Colors-X">
</div>
</div>
<div id="outline-container-Window-Size-X" class="outline-3">
<h3 id="Window-Size-X">C.8 窗口大小与位置选项</h3>
<div class="outline-text-3" id="text-Window-Size-X">
</div>
</div>
<div id="outline-container-Borders-X" class="outline-3">
<h3 id="Borders-X">C.9 内部边框与外部边框</h3>
<div class="outline-text-3" id="text-Borders-X">
</div>
</div>
<div id="outline-container-Title-X" class="outline-3">
<h3 id="Title-X">C.10 框架标题</h3>
<div class="outline-text-3" id="text-Title-X">
</div>
</div>
<div id="outline-container-Icons-X" class="outline-3">
<h3 id="Icons-X">C.11 图标</h3>
<div class="outline-text-3" id="text-Icons-X">
</div>
</div>
<div id="outline-container-Misc-X" class="outline-3">
<h3 id="Misc-X">C.12 其他显示选项</h3>
<div class="outline-text-3" id="text-Misc-X">
</div>
</div>
</section>
<section id="outline-container-X-Resources" class="outline-2">
<h2 id="X-Resources">附录 D X 窗口系统选项与资源</h2>
<div class="outline-text-2" id="text-X-Resources">
</div>
<div id="outline-container-Resources" class="outline-3">
<h3 id="Resources">D.1 X 资源</h3>
<div class="outline-text-3" id="text-Resources">
</div>
</div>
<div id="outline-container-Table-of-Resources" class="outline-3">
<h3 id="Table-of-Resources">D.2 Emacs 的 X 资源表</h3>
<div class="outline-text-3" id="text-Table-of-Resources">
</div>
</div>
<div id="outline-container-Lucid-Resources" class="outline-3">
<h3 id="Lucid-Resources">D.3 Lucid 菜单与对话框 X 资源</h3>
<div class="outline-text-3" id="text-Lucid-Resources">
</div>
</div>
<div id="outline-container-Motif-Resources" class="outline-3">
<h3 id="Motif-Resources">D.4 Motif 菜单 X 资源</h3>
<div class="outline-text-3" id="text-Motif-Resources">
</div>
</div>
<div id="outline-container-GTK-resources" class="outline-3">
<h3 id="GTK-resources">D.5 GTK+ 资源</h3>
<div class="outline-text-3" id="text-GTK-resources">
</div>
<div id="outline-container-GTK-Resource-Basics" class="outline-4">
<h4 id="GTK-Resource-Basics">D.5.1 GTK+ 资源基础</h4>
<div class="outline-text-4" id="text-GTK-Resource-Basics">
</div>
</div>
<div id="outline-container-GTK-Widget-Names" class="outline-4">
<h4 id="GTK-Widget-Names">D.5.2 GTK+ 组件名称</h4>
<div class="outline-text-4" id="text-GTK-Widget-Names">
</div>
</div>
<div id="outline-container-GTK-Names-in-Emacs" class="outline-4">
<h4 id="GTK-Names-in-Emacs">D.5.3 Emacs 中的 GTK+ 组件名称</h4>
<div class="outline-text-4" id="text-GTK-Names-in-Emacs">
</div>
</div>
<div id="outline-container-GTK-styles" class="outline-4">
<h4 id="GTK-styles">D.5.4 GTK+ 样式</h4>
<div class="outline-text-4" id="text-GTK-styles">
</div>
</div>
</div>
</section>
<section id="outline-container-Antinews" class="outline-2">
<h2 id="Antinews">附录 E Emacs 29 版本反向更新说明</h2>
<div class="outline-text-2" id="text-Antinews">
</div>
</section>
<section id="outline-container-Mac-OS-_002f-GNUstep" class="outline-2">
<h2 id="Mac-OS-_002f-GNUstep">附录 F Emacs 与 macOS / GNUstep</h2>
<div class="outline-text-2" id="text-Mac-OS-_002f-GNUstep">
</div>
<div id="outline-container-Mac-_002f-GNUstep-Basics" class="outline-3">
<h3 id="Mac-_002f-GNUstep-Basics">F.1 macOS 与 GNUstep 下的 Emacs 基本使用</h3>
<div class="outline-text-3" id="text-Mac-_002f-GNUstep-Basics">
</div>
<div id="outline-container-Grabbing-environment-variables" class="outline-4">
<h4 id="Grabbing-environment-variables">F.1.1 获取环境变量</h4>
<div class="outline-text-4" id="text-Grabbing-environment-variables">
</div>
</div>
</div>
<div id="outline-container-Mac-_002f-GNUstep-Customization" class="outline-3">
<h3 id="Mac-_002f-GNUstep-Customization">F.2 Mac / GNUstep 定制</h3>
<div class="outline-text-3" id="text-Mac-_002f-GNUstep-Customization">
</div>
<div id="outline-container-Modifier-keys" class="outline-4">
<h4 id="Modifier-keys">F.2.1 修饰键</h4>
<div class="outline-text-4" id="text-Modifier-keys">
</div>
</div>
<div id="outline-container-Frame-Variables" class="outline-4">
<h4 id="Frame-Variables">F.2.2 框架变量</h4>
<div class="outline-text-4" id="text-Frame-Variables">
</div>
</div>
<div id="outline-container-macOS-Trackpad_002fMousewheel-Variables" class="outline-4">
<h4 id="macOS-Trackpad_002fMousewheel-Variables">F.2.3 macOS 触控板 / 鼠标滚轮变量</h4>
<div class="outline-text-4" id="text-macOS-Trackpad_002fMousewheel-Variables">
</div>
</div>
</div>
<div id="outline-container-Mac-_002f-GNUstep-Events" class="outline-3">
<h3 id="Mac-_002f-GNUstep-Events">F.3 macOS / GNUstep 下的窗口系统事件</h3>
<div class="outline-text-3" id="text-Mac-_002f-GNUstep-Events">
</div>
</div>
<div id="outline-container-GNUstep-Support" class="outline-3">
<h3 id="GNUstep-Support">F.4 GNUstep 支持</h3>
<div class="outline-text-3" id="text-GNUstep-Support">
</div>
</div>
</section>
<section id="outline-container-Haiku" class="outline-2">
<h2 id="Haiku">附录 G Emacs 与 Haiku 系统</h2>
<div class="outline-text-2" id="text-Haiku">
</div>
<div id="outline-container-Haiku-Basics" class="outline-3">
<h3 id="Haiku-Basics">G.1 Haiku 系统下的安装与启动</h3>
<div class="outline-text-3" id="text-Haiku-Basics">
</div>
</div>
<div id="outline-container-Haiku-Fonts" class="outline-3">
<h3 id="Haiku-Fonts">G.2 Haiku 系统下的字体后端与选择</h3>
<div class="outline-text-3" id="text-Haiku-Fonts">
</div>
</div>
</section>
<section id="outline-container-Android" class="outline-2">
<h2 id="Android">附录 H Emacs 与 Android 系统</h2>
<div class="outline-text-2" id="text-Android">
</div>
<div id="outline-container-What-is-Android_003f" class="outline-3">
<h3 id="What-is-Android_003f">H.1 Android 版本历史</h3>
<div class="outline-text-3" id="text-What-is-Android_003f">
</div>
</div>
<div id="outline-container-Android-Startup" class="outline-3">
<h3 id="Android-Startup">H.2 在 Android 上启动 Emacs</h3>
<div class="outline-text-3" id="text-Android-Startup">
</div>
</div>
<div id="outline-container-Android-File-System" class="outline-3">
<h3 id="Android-File-System">H.3 Emacs 在 Android 上可访问的文件</h3>
<div class="outline-text-3" id="text-Android-File-System">
</div>
</div>
<div id="outline-container-Android-Document-Providers" class="outline-3">
<h3 id="Android-Document-Providers">H.4 在 Android 上从其他程序访问文件</h3>
<div class="outline-text-3" id="text-Android-Document-Providers">
</div>
</div>
<div id="outline-container-Android-Environment" class="outline-3">
<h3 id="Android-Environment">H.5 在 Android 下运行 Emacs</h3>
<div class="outline-text-3" id="text-Android-Environment">
</div>
</div>
<div id="outline-container-Android-Windowing" class="outline-3">
<h3 id="Android-Windowing">H.6 Android 窗口系统</h3>
<div class="outline-text-3" id="text-Android-Windowing">
</div>
</div>
<div id="outline-container-Android-Fonts" class="outline-3">
<h3 id="Android-Fonts">H.7 Android 下的字体后端与选择</h3>
<div class="outline-text-3" id="text-Android-Fonts">
</div>
</div>
<div id="outline-container-Android-Troubleshooting" class="outline-3">
<h3 id="Android-Troubleshooting">H.8 Android 启动问题排查</h3>
<div class="outline-text-3" id="text-Android-Troubleshooting">
</div>
</div>
<div id="outline-container-Android-Software" class="outline-3">
<h3 id="Android-Software">H.9 在 Android 上安装额外软件</h3>
<div class="outline-text-3" id="text-Android-Software">
</div>
</div>
</section>
<section id="outline-container-Microsoft-Windows" class="outline-2">
<h2 id="Microsoft-Windows">附录 I Emacs 与 Microsoft Windows/MS-DOS</h2>
<div class="outline-text-2" id="text-Microsoft-Windows">
</div>
<div id="outline-container-Windows-Startup" class="outline-3">
<h3 id="Windows-Startup">I.1 在 MS-Windows 上启动 Emacs 的方法</h3>
<div class="outline-text-3" id="text-Windows-Startup">
</div>
</div>
<div id="outline-container-Text-and-Binary" class="outline-3">
<h3 id="Text-and-Binary">I.2 文本文件与二进制文件</h3>
<div class="outline-text-3" id="text-Text-and-Binary">
</div>
</div>
<div id="outline-container-Windows-Files" class="outline-3">
<h3 id="Windows-Files">I.3 MS-Windows 上的文件名</h3>
<div class="outline-text-3" id="text-Windows-Files">
</div>
</div>
<div id="outline-container-ls-in-Lisp" class="outline-3">
<h3 id="ls-in-Lisp">I.4 MS-Windows 上的 ls 命令模拟</h3>
<div class="outline-text-3" id="text-ls-in-Lisp">
</div>
</div>
<div id="outline-container-Windows-HOME" class="outline-3">
<h3 id="Windows-HOME">I.5 MS-Windows 上的 HOME 目录与启动目录</h3>
<div class="outline-text-3" id="text-Windows-HOME">
</div>
</div>
<div id="outline-container-Windows-Keyboard" class="outline-3">
<h3 id="Windows-Keyboard">I.6 MS-Windows 上的键盘使用</h3>
<div class="outline-text-3" id="text-Windows-Keyboard">
</div>
</div>
<div id="outline-container-Windows-Mouse" class="outline-3">
<h3 id="Windows-Mouse">I.7 MS-Windows 上的鼠标使用</h3>
<div class="outline-text-3" id="text-Windows-Mouse">
</div>
</div>
<div id="outline-container-Windows-Processes" class="outline-3">
<h3 id="Windows-Processes">I.8 Windows 9X/ME 与 Windows NT/2K/XP/Vista/7/8/10 上的子进程</h3>
<div class="outline-text-3" id="text-Windows-Processes">
</div>
</div>
<div id="outline-container-Windows-Printing" class="outline-3">
<h3 id="Windows-Printing">I.9 MS-Windows 上的打印功能</h3>
<div class="outline-text-3" id="text-Windows-Printing">
</div>
</div>
<div id="outline-container-Windows-Fonts" class="outline-3">
<h3 id="Windows-Fonts">I.10 MS-Windows 上的字体指定</h3>
<div class="outline-text-3" id="text-Windows-Fonts">
</div>
</div>
<div id="outline-container-Windows-Misc" class="outline-3">
<h3 id="Windows-Misc">I.11 其他 Windows 专用功能</h3>
<div class="outline-text-3" id="text-Windows-Misc">
</div>
</div>
<div id="outline-container-MS_002dDOS" class="outline-3">
<h3 id="MS_002dDOS">I.12 Emacs 与 MS-DOS</h3>
<div class="outline-text-3" id="text-MS_002dDOS">
</div>
<div id="outline-container-MS_002dDOS-Keyboard" class="outline-4">
<h4 id="MS_002dDOS-Keyboard">I.12.1 MS-DOS 上的键盘使用</h4>
<div class="outline-text-4" id="text-MS_002dDOS-Keyboard">
</div>
</div>
<div id="outline-container-MS_002dDOS-Mouse" class="outline-4">
<h4 id="MS_002dDOS-Mouse">I.12.2 MS-DOS 上的鼠标使用</h4>
<div class="outline-text-4" id="text-MS_002dDOS-Mouse">
</div>
</div>
<div id="outline-container-MS_002dDOS-Display" class="outline-4">
<h4 id="MS_002dDOS-Display">I.12.3 MS-DOS 上的显示</h4>
<div class="outline-text-4" id="text-MS_002dDOS-Display">
</div>
</div>
<div id="outline-container-MS_002dDOS-File-Names" class="outline-4">
<h4 id="MS_002dDOS-File-Names">I.12.4 MS-DOS 上的文件名</h4>
<div class="outline-text-4" id="text-MS_002dDOS-File-Names">
</div>
</div>
<div id="outline-container-MS_002dDOS-Printing" class="outline-4">
<h4 id="MS_002dDOS-Printing">I.12.5 MS-DOS 上的打印功能</h4>
<div class="outline-text-4" id="text-MS_002dDOS-Printing">
</div>
</div>
<div id="outline-container-MS_002dDOS-and-MULE" class="outline-4">
<h4 id="MS_002dDOS-and-MULE">I.12.6 MS-DOS 上的国际语言支持</h4>
<div class="outline-text-4" id="text-MS_002dDOS-and-MULE">
</div>
</div>
<div id="outline-container-MS_002dDOS-Processes" class="outline-4">
<h4 id="MS_002dDOS-Processes">I.12.7 MS-DOS 上的子进程</h4>
<div class="outline-text-4" id="text-MS_002dDOS-Processes">
</div>
</div>
</div>
</section>
<section id="outline-container-Manifesto" class="outline-2">
<h2 id="Manifesto">GNU 宣言</h2>
<div class="outline-text-2" id="text-Manifesto">
</div>
<div id="outline-container-What_0027s-GNU_003f-Gnu_0027s-Not-Unix_0021" class="outline-3">
<h3 id="What_0027s-GNU_003f-Gnu_0027s-Not-Unix_0021">什么是 GNU？GNU 不是 Unix！</h3>
<div class="outline-text-3" id="text-What_0027s-GNU_003f-Gnu_0027s-Not-Unix_0021">
</div>
</div>
<div id="outline-container-Why-I-Must-Write-GNU" class="outline-3">
<h3 id="Why-I-Must-Write-GNU">我为何必须编写 GNU</h3>
<div class="outline-text-3" id="text-Why-I-Must-Write-GNU">
</div>
</div>
<div id="outline-container-Why-GNU-Will-Be-Compatible-with-Unix" class="outline-3">
<h3 id="Why-GNU-Will-Be-Compatible-with-Unix">为何 GNU 要与 Unix 兼容</h3>
<div class="outline-text-3" id="text-Why-GNU-Will-Be-Compatible-with-Unix">
</div>
</div>
<div id="outline-container-How-GNU-Will-Be-Available" class="outline-3">
<h3 id="How-GNU-Will-Be-Available">GNU 的获取方式</h3>
<div class="outline-text-3" id="text-How-GNU-Will-Be-Available">
</div>
</div>
<div id="outline-container-Why-Many-Other-Programmers-Want-to-Help" class="outline-3">
<h3 id="Why-Many-Other-Programmers-Want-to-Help">为何众多程序员愿意提供帮助</h3>
<div class="outline-text-3" id="text-Why-Many-Other-Programmers-Want-to-Help">
</div>
</div>
<div id="outline-container-How-You-Can-Contribute" class="outline-3">
<h3 id="How-You-Can-Contribute">你如何能做出贡献</h3>
<div class="outline-text-3" id="text-How-You-Can-Contribute">
</div>
</div>
<div id="outline-container-Why-All-Computer-Users-Will-Benefit" class="outline-3">
<h3 id="Why-All-Computer-Users-Will-Benefit">为何所有计算机用户都将受益</h3>
<div class="outline-text-3" id="text-Why-All-Computer-Users-Will-Benefit">
</div>
</div>
<div id="outline-container-Some-Easily-Rebutted-Objections-to-GNU_0027s-Goals" class="outline-3">
<h3 id="Some-Easily-Rebutted-Objections-to-GNU_0027s-Goals">对 GNU 目标的一些易反驳的反对意见</h3>
<div class="outline-text-3" id="text-Some-Easily-Rebutted-Objections-to-GNU_0027s-Goals">
</div>
</div>
</section>
<section id="outline-container-Glossary" class="outline-2">
<h2 id="Glossary">术语表</h2>
<div class="outline-text-2" id="text-Glossary">
</div>
</section>
<section id="outline-container-Acknowledgments" class="outline-2">
<h2 id="Acknowledgments">致谢</h2>
<div class="outline-text-2" id="text-Acknowledgments">
</div>
</section>
<section id="outline-container-Key-Index" class="outline-2">
<h2 id="Key-Index">按键（字符）索引</h2>
<div class="outline-text-2" id="text-Key-Index">
<p>
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Key-Index.html">Key-Index</a>
</p>
</div>
</section>
<section id="outline-container-Option-Index" class="outline-2">
<h2 id="Option-Index">命令行选项索引</h2>
<div class="outline-text-2" id="text-Option-Index">
<p>
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Option-Index.html">Option-Index</a>
</p>
</div>
</section>
<section id="outline-container-Command-Index" class="outline-2">
<h2 id="Command-Index">命令与函数索引</h2>
<div class="outline-text-2" id="text-Command-Index">
<p>
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Command-Index.html">Command-Index</a>
</p>
</div>
</section>
<section id="outline-container-Variable-Index" class="outline-2">
<h2 id="Variable-Index">变量索引</h2>
<div class="outline-text-2" id="text-Variable-Index">
<p>
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Variable-Index.html">Variable-Index</a>
</p>
</div>
</section>
<section id="outline-container-Concept-Index" class="outline-2">
<h2 id="Concept-Index">概念索引</h2>
<div class="outline-text-2" id="text-Concept-Index">
<p>
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Concept-Index.html">Concept-Index</a>
</p>
</div>
</section>
<section id="outline-container-h:A2EBE128-92C2-466C-B35A-D0315988F1F7" class="outline-2">
<h2 id="h:A2EBE128-92C2-466C-B35A-D0315988F1F7">脚注</h2>
<div class="outline-text-2" id="text-h:A2EBE128-92C2-466C-B35A-D0315988F1F7">
</div>
</section>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.发行说明" class="footnum" href="#fnr.发行说明" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
本手册本身受《GNU 自由文档许可证》保护。该许可证的理念与《通用公共许可证》相近，但更适用于文档类作品。参见《GNU 自由文档许可证》章节。
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
“point（光标位置）” 这一术语源于字符 <code>.</code> ，该字符曾是 TECO 语言（初代 Emacs 的开发语言）中用于定位编辑位置的命令。
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
出于历史原因，我们将 Alt 键称为 Meta 键。
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
在 site-start.el 文件中设置 inhibit-startup-screen 是无效的，因为启动界面的初始化流程，早于 site-start.el 文件的读取时间。关于 site-start.el 的更多信息，参见《<a href="#Init-File">Emacs 初始化文件</a>》章节。
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5" role="doc-backlink">5</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
ASCII 编码中并无 <code>C-SPC</code> 字符；在文本终端中，按下 <code>C-SPC</code> 通常会输入 <code>C-@</code> 字符。该按键同样绑定了 <code>set-mark-command</code> 命令，因此除非你的文本终端行为特殊，否则可直接将 <code>C-@</code> 视作 <code>C-SPC</code> 使用。
</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6" role="doc-backlink">6</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
除 <code>C-/</code> 外，撤销命令还绑定至 <code>C-x u</code> ，因该快捷键对初学者而言更易记忆：字母 <code>u</code> 对应英文 “undo（撤销）”；同时也绑定至 <code>C-_</code> ，原因是在部分文本终端中，按下 <code>C-/</code> 实际输入的是 <code>C-_</code> 。
</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7" role="doc-backlink">7</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
若你的文件系统不支持符号链接，Emacs 会改用普通文件实现文件锁定。
</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8" role="doc-backlink">8</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
在 Nextstep 系统中，由工具包创建的工具提示，其前景色和背景色也可通过设置 <code>tooltip-frame-parameters</code> 中包含的前景、背景框架参数进行自定义。
</p></div></div>

<div class="footdef"><sup><a id="fn.9" class="footnum" href="#fnr.9" role="doc-backlink">9</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
该行尾规范也被多用途互联网邮件扩展（MIME）的 '<code>text/*</code>' 类型正文及其他网络传输场景采用，与标准通用标记语言（SGML）参考语法中的记录开始 / 记录结束格式不同，Emacs 不直接支持后者。
</p></div></div>

<div class="footdef"><sup><a id="fn.10" class="footnum" href="#fnr.10" role="doc-backlink">10</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
若你在 X 窗口系统中运行 Emacs，可能需要通过以下命令告知 X 服务器新安装字体的存放路径：
</p>
<div class="org-src-container">
<pre class="src src-shell">xset fp+ /usr/local/share/emacs/fonts
xset fp rehash
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.11" class="footnum" href="#fnr.11" role="doc-backlink">11</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
更具体地说，是所有从prog-mode派生的模式（参见《Emacs Lisp 参考手册》中的「<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Derived-Modes.html#Derived-Modes">派生模式</a>」章节）。
</p></div></div>

<div class="footdef"><sup><a id="fn.12" class="footnum" href="#fnr.12" role="doc-backlink">12</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
单弯引号对应的字符编码为：左单弯引号 U+2018、右单弯引号 U+2019；双弯引号对应的字符编码为：左双弯引号 U+201C、右双弯引号 U+201D。在无法显示这类字符的文本终端中，信息阅读器可能会将其显示为打字机风格的 ASCII 直引号。
</p></div></div>

<div class="footdef"><sup><a id="fn.13" class="footnum" href="#fnr.13" role="doc-backlink">13</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
该格式已被 LaTeX 自带的slides文档类替代。
</p></div></div>

<div class="footdef"><sup><a id="fn.14" class="footnum" href="#fnr.14" role="doc-backlink">14</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
术语「S表达式（sexp）」原本用于指代 Lisp 语言中的表达式。
</p></div></div>

<div class="footdef"><sup><a id="fn.15" class="footnum" href="#fnr.15" role="doc-backlink">15</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
「ElDoc」这一名称源于历史原因：该模式最初仅为 Emacs Lisp 缓冲区提供支持。
</p></div></div>

<div class="footdef"><sup><a id="fn.16" class="footnum" href="#fnr.16" role="doc-backlink">16</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
在图形化显示界面中， <code>M-TAB</code> 组合键通常被窗口管理器占用，用于切换图形化窗口，因此你应改用 <code>C-M-i</code> 或 <code>ESC TAB</code> 来执行该操作。
</p></div></div>

<div class="footdef"><sup><a id="fn.17" class="footnum" href="#fnr.17" role="doc-backlink">17</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
即正则表达式与语法表。
</p></div></div>

<div class="footdef"><sup><a id="fn.18" class="footnum" href="#fnr.18" role="doc-backlink">18</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
标记是标识符引用的同义词。基于 <code>etags</code> 软件包的命令和功能历来沿用该含义的 “标记（tag）” 一词，本节也遵循这一传统。
</p></div></div>

<div class="footdef"><sup><a id="fn.19" class="footnum" href="#fnr.19" role="doc-backlink">19</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
美国国家安全局（The US National Security Agency）
</p></div></div>

<div class="footdef"><sup><a id="fn.20" class="footnum" href="#fnr.20" role="doc-backlink">20</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
该功能需要 Emacs 编译时带 libxml2 支持，或已安装 Lynx 浏览器。
</p></div></div>

<div class="footdef"><sup><a id="fn.21" class="footnum" href="#fnr.21" role="doc-backlink">21</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
对应文档类型所需的外部工具必须可用，且 Emacs 必须在图形界面框架中运行并支持 PNG 图片。若不满足这些条件，Emacs 会回退到其他主模式。
</p></div></div>

<div class="footdef"><sup><a id="fn.22" class="footnum" href="#fnr.22" role="doc-backlink">22</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
你不应该挂起 Shell 进程本身。挂起 Shell 的子任务是另一回事 —— 那是常规操作，但必须用 Shell 自身命令继续子任务，本命令做不到。
</p></div></div>

<div class="footdef"><sup><a id="fn.23" class="footnum" href="#fnr.23" role="doc-backlink">23</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
部分程序使用其他环境变量；例如，要让 TeX 使用 'emacsclient' ，可将环境变量 <code>TEXEDIT</code> 设为： 'emacsclient +%d %s'
</p></div></div>

<div class="footdef"><sup><a id="fn.24" class="footnum" href="#fnr.24" role="doc-backlink">24</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
关于版权转让的更多信息，参见《<a href="https://www.gnu.org/licenses/why-assign.html">为何 FSF 要求贡献者转让版权</a>》。
</p></div></div>

<div class="footdef"><sup><a id="fn.25" class="footnum" href="#fnr.25" role="doc-backlink">25</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
在 MS-DOS 下，受文件系统限制，该文件名应为 <code>_dir-locals.el</code> 。如果文件系统只支持 <code>8+3</code> 文件名，操作系统会将其截断为 <code>_dir-loc.el</code> 。
</p></div></div>

<div class="footdef"><sup><a id="fn.26" class="footnum" href="#fnr.26" role="doc-backlink">26</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
在 MS-Windows 系统中，没有一个被所有程序统一视为用户 “家目录” 的目录。Emacs 会使用相关目录之一作为家目录的等效位置；详见《<a href="#Windows-HOME">MS-Windows 上的 HOME 与启动目录</a>》。
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
    <div class=bar data-astro-cid-p3givckg>
        <div class=list data-astro-cid-p3givckg>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=simple-icons:gnuemacs height=1em viewBox="0 0 24 24" width=1em>
                    <title>emacs</title>
                    <symbol id=ai:simple-icons:gnuemacs>
                        <path d="M12 24C5.448 24 .118 18.617.118 12S5.448 0 12 0s11.882 5.383 11.882 12S18.552 24 12 24zM12 .661C5.813.661.779 5.748.779 12S5.813 23.339 12 23.339S23.221 18.253 23.221 12S18.187.661 12 .661zM8.03 20.197s.978.069 2.236-.042c.51-.045 2.444-.235 3.891-.552c0 0 1.764-.377 2.707-.725c.987-.364 1.524-.673 1.766-1.11c-.011-.09.074-.408-.381-.599c-1.164-.488-2.514-.4-5.185-.457c-2.962-.102-3.948-.598-4.472-.997c-.503-.405-.25-1.526 1.907-2.513c1.086-.526 5.345-1.496 5.345-1.496c-1.434-.709-4.109-1.955-4.659-2.224c-.482-.236-1.254-.591-1.421-1.021c-.19-.413.448-.768.804-.87c1.147-.331 2.766-.536 4.24-.56c.741-.012.861-.059.861-.059c1.022-.17 1.695-.869 1.414-1.976c-.252-1.13-1.579-1.795-2.84-1.565c-1.188.217-4.05 1.048-4.05 1.048c3.539-.031 4.131.028 4.395.398c.156.218-.071.518-1.015.672c-1.027.168-3.163.37-3.163.37c-2.049.122-3.492.13-3.925 1.046c-.283.599.302 1.129.558 1.46c1.082 1.204 2.646 1.853 3.652 2.331c.379.18 1.49.52 1.49.52c-3.265-.18-5.619.823-7.001 1.977c-1.562 1.445-.871 3.168 2.33 4.228c1.891.626 2.828.921 5.648.667c1.661-.09 1.923-.036 1.939.1c.023.192-1.845.669-2.355.816c-1.298.374-4.699 1.129-4.716 1.133z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:simple-icons:gnuemacs></use>
                </svg>
                <div class="content left" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Emacs</p>
                </div>
            </span>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=simple-icons:org height=1em viewBox="0 0 24 24" width=1em>
                    <title>org-mode</title>
                    <symbol id=ai:simple-icons:org>
                        <path d="M17.169 0c-.566.004-2.16 3.312-3.376 5.94a2.19 2.19 0 0 1-.408-1.267c-.03-.582-1.089.237-.936 1.275c-.068-.035-1.26.227-1.26.23c-.23-.93-.802-1.618-1.15-.563c-.701 1.663-.88 2.984.115 4.585c-.908 4.058-6.948 6.053-6.32 9.33c.175.004 1.634 3.48 6.337 2.057c5.557-1.577 8.624 2.116 8.978 2.375c.52.526-1.348-4.573-5.302-6.865c-2.339-1.276-.87-3.474-.703-4.25c0 0 1.874 1.312 3.232-.692c1.227.316 2.05-.224 3.105.158c.64.28 3.336.11 2.334-1.396c-.148.129.07.27-.075.46c-.043.056-.128.232-.408.315c-.314.149-.83.27-1.43-.37c-.434-.32-.748-.04-.992-.063c.152-.098.577-.315 1.264-.315c.388 0 .594.336.854.338c.174 0 .685-.262.787-.365c.63-.41.697-.278 1.012-.905c.17-.759-.215-.92-.332-1.129c-.032-.483-.436-.67-.919-.326c-1.106-.198-2.192-.105-2.728-.15c-1.175-.164-2.153-.786-2.153-.786c.143-.19.075-.6-.842-.628c-.315-.104-.45-.2-.745-.307c.61-1.37.674-2.007 1.418-4.004c.261-1.053 1.039-2.685.643-2.682zm-4.297 8.093c.03-.086.443.138.952.176c.395.03.805.048 1.296-.025c.03-.005.172.095-.15.194c-.02.01-.062-.01-.065.196c0 .022-.01.04-.02.046c-.15.152-.708.223-1.065.1c-.436-.17-.482-.316-.517-.443c-.305-.147-.47-.123-.43-.244zM9.685 10.2C8.86 9 8.929 8.36 8.96 7.256C7.961 8.288 6.855 8.3 5.18 8.58c-1.299.234-3.657 2.447-4.025 4.742c-.043.608-.08 2.183.424 3.498c.492 1.13.828 1.727 1.844 2.335c-.882-3.169 5.296-5.33 6.263-8.955z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:simple-icons:org></use>
                </svg>
                <div class="content left" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Orgmode</p>
                </div>
            </span>
            <a href=/donations.html class=entry data-astro-cid-p3givckg>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=simple-icons:astro height=1em viewBox="0 0 24 24" width=1em>
                    <title>Donations</title>
                    <symbol id=ai:simple-icons:astro>
                        <path d="M8.358 20.162c-1.186-1.07-1.532-3.316-1.038-4.944c.856 1.026 2.043 1.352 3.272 1.535c1.897.283 3.76.177 5.522-.678c.202-.098.388-.229.608-.36c.166.473.209.95.151 1.437c-.14 1.185-.738 2.1-1.688 2.794c-.38.277-.782.525-1.175.787c-1.205.804-1.531 1.747-1.078 3.119l.044.148a3.158 3.158 0 0 1-1.407-1.188a3.31 3.31 0 0 1-.544-1.815c-.004-.32-.004-.642-.048-.958c-.106-.769-.472-1.113-1.161-1.133c-.707-.02-1.267.411-1.415 1.09c-.012.053-.028.104-.045.165h.002zm-5.961-4.445s3.24-1.575 6.49-1.575l2.451-7.565c.092-.366.36-.614.662-.614c.302 0 .57.248.662.614l2.45 7.565c3.85 0 6.491 1.575 6.491 1.575L16.088.727C15.93.285 15.663 0 15.303 0H8.697c-.36 0-.615.285-.784.727l-5.516 14.99z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:simple-icons:astro></use>
                </svg>
                <div class="content left" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>打赏</p>
                </div>
            </span>
            </a>
            <span class=entry data-astro-cid-p3givckg>
                <svg xmlns="http://www.w3.org/2000/svg" class=heading data-astro-cid-p3givckg data-icon=simple-icons:copyright width="1em" height="1em" viewBox="0 0 24 24">
                    <title>Copyright</title>
                    <path fill="currentColor" d="M19 2a3 3 0 0 1 3 3v14a3 3 0 0 1-3 3H5a3 3 0 0 1-3-3V5a3 3 0 0 1 3-3zm-5 5h-4a1 1 0 0 0-1 1l.007.117A1 1 0 0 0 10 9h3v5a1 1 0 0 1-1.993.117L11 14a1 1 0 0 0-2 0a3 3 0 0 0 6 0V8a1 1 0 0 0-1-1" />
                    <use xlink:href=#ai:simple-icons:copyright></use>
                </svg>
                <div class="content left" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>© 2025 Jasper Hsu</p>
                </div>
            </span>
        </div>
        <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ class="list license" data-astro-cid-p3givckg>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=fa6-brands:creative-commons height=1em viewBox="0 0 496 512" width=0.97em>
                    <title>Creative Commons</title>
                    <symbol id=ai:fa6-brands:creative-commons>
                        <path d="m245.83 214.87l-33.22 17.28c-9.43-19.58-25.24-19.93-27.46-19.93c-22.13 0-33.22 14.61-33.22 43.84c0 23.57 9.21 43.84 33.22 43.84c14.47 0 24.65-7.09 30.57-21.26l30.55 15.5c-6.17 11.51-25.69 38.98-65.1 38.98c-22.6 0-73.96-10.32-73.96-77.05c0-58.69 43-77.06 72.63-77.06c30.72-.01 52.7 11.95 65.99 35.86zm143.05 0l-32.78 17.28c-9.5-19.77-25.72-19.93-27.9-19.93c-22.14 0-33.22 14.61-33.22 43.84c0 23.55 9.23 43.84 33.22 43.84c14.45 0 24.65-7.09 30.54-21.26l31 15.5c-2.1 3.75-21.39 38.98-65.09 38.98c-22.69 0-73.96-9.87-73.96-77.05c0-58.67 42.97-77.06 72.63-77.06c30.71-.01 52.58 11.95 65.56 35.86zM247.56 8.05C104.74 8.05 0 123.11 0 256.05c0 138.49 113.6 248 247.56 248c129.93 0 248.44-100.87 248.44-248c0-137.87-106.62-248-248.44-248zm.87 450.81c-112.54 0-203.7-93.04-203.7-202.81c0-105.42 85.43-203.27 203.72-203.27c112.53 0 202.82 89.46 202.82 203.26c-.01 121.69-99.68 202.82-202.84 202.82z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:fa6-brands:creative-commons></use>
                </svg>
                <div class="content right" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Creative Commons</p>
                </div>
            </span>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=fa6-brands:creative-commons-by height=1em viewBox="0 0 496 512" width=0.97em>
                    <title>Attribute</title>
                    <symbol id=ai:fa6-brands:creative-commons-by>
                        <path d="M314.9 194.4v101.4h-28.3v120.5h-77.1V295.9h-28.3V194.4c0-4.4 1.6-8.2 4.6-11.3c3.1-3.1 6.9-4.7 11.3-4.7H299c4.1 0 7.8 1.6 11.1 4.7c3.1 3.2 4.8 6.9 4.8 11.3zm-101.5-63.7c0-23.3 11.5-35 34.5-35s34.5 11.7 34.5 35c0 23-11.5 34.5-34.5 34.5s-34.5-11.5-34.5-34.5zM247.6 8C389.4 8 496 118.1 496 256c0 147.1-118.5 248-248.4 248C113.6 504 0 394.5 0 256C0 123.1 104.7 8 247.6 8zm.8 44.7C130.2 52.7 44.7 150.6 44.7 256c0 109.8 91.2 202.8 203.7 202.8c103.2 0 202.8-81.1 202.8-202.8c.1-113.8-90.2-203.3-202.8-203.3z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:fa6-brands:creative-commons-by></use>
                </svg>
                <div class="content right" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Attribute</p>
                </div>
            </span>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=fa6-brands:creative-commons-nc height=1em viewBox="0 0 496 512" width=0.97em>
                    <title>Noncommercial</title>
                    <symbol id=ai:fa6-brands:creative-commons-nc>
                        <path d="M247.6 8C387.4 8 496 115.9 496 256c0 147.2-118.5 248-248.4 248C113.1 504 0 393.2 0 256C0 123.1 104.7 8 247.6 8zM55.8 189.1c-7.4 20.4-11.1 42.7-11.1 66.9c0 110.9 92.1 202.4 203.7 202.4c122.4 0 177.2-101.8 178.5-104.1l-93.4-41.6c-7.7 37.1-41.2 53-68.2 55.4v38.1h-28.8V368c-27.5-.3-52.6-10.2-75.3-29.7l34.1-34.5c31.7 29.4 86.4 31.8 86.4-2.2c0-6.2-2.2-11.2-6.6-15.1c-14.2-6-1.8-.1-219.3-97.4zM248.4 52.3c-38.4 0-112.4 8.7-170.5 93l94.8 42.5c10-31.3 40.4-42.9 63.8-44.3v-38.1h28.8v38.1c22.7 1.2 43.4 8.9 62 23L295 199.7c-42.7-29.9-83.5-8-70 11.1c53.4 24.1 43.8 19.8 93 41.6l127.1 56.7c4.1-17.4 6.2-35.1 6.2-53.1c0-57-19.8-105-59.3-143.9c-39.3-39.9-87.2-59.8-143.6-59.8z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:fa6-brands:creative-commons-nc></use>
                </svg>
                <div class="content right" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Noncommercial</p>
                </div>
            </span>
            <span class=entry data-astro-cid-p3givckg>
                <svg class=heading data-astro-cid-p3givckg data-icon=fa6-brands:creative-commons-sa height=1em viewBox="0 0 496 512" width=0.97em>
                    <title>Share Alike</title>
                    <symbol id=ai:fa6-brands:creative-commons-sa>
                        <path d="M247.6 8C389.4 8 496 118.1 496 256c0 147.1-118.5 248-248.4 248C113.6 504 0 394.5 0 256C0 123.1 104.7 8 247.6 8zm.8 44.7C130.2 52.7 44.7 150.6 44.7 256c0 109.8 91.2 202.8 203.7 202.8c103.2 0 202.8-81.1 202.8-202.8c.1-113.8-90.2-203.3-202.8-203.3zM137.7 221c13-83.9 80.5-95.7 108.9-95.7c99.8 0 127.5 82.5 127.5 134.2c0 63.6-41 132.9-128.9 132.9c-38.9 0-99.1-20-109.4-97h62.5c1.5 30.1 19.6 45.2 54.5 45.2c23.3 0 58-18.2 58-82.8c0-82.5-49.1-80.6-56.7-80.6c-33.1 0-51.7 14.6-55.8 43.8h18.2l-49.2 49.2l-49-49.2h19.4z" fill=currentColor/>
                    </symbol>
                    <use xlink:href=#ai:fa6-brands:creative-commons-sa></use>
                </svg>
                <div class="content right" data-astro-cid-p3givckg>
                    <p data-astro-cid-p3givckg>Share Alike</p>
                </div>
            </span>
        </a>
    </div>
<!--
<script type="text/javascript" src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script type="text/javascript" src="https://unpkg.com/@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
<script type="text/javascript" src="https://unpkg.com/bootstrap@5.2.1/dist/js/bootstrap.min.js"></script>
<div id="back-to-top" class=""><svg viewBox="0 0 24 24"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path></svg></div>
-->
</div>
</body>
</html>
